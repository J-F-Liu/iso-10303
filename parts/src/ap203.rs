#![doc = r" This file is generated. Do not edit."]
#![allow(dead_code)]
use iso_10303::step::*;
use std::collections::HashSet;
#[derive(Default, Debug)]
pub struct Unimplemented {}
impl From<Parameter> for Unimplemented {
    fn from(_parameter: Parameter) -> Self {
        Unimplemented {}
    }
}
type AbsorbedDoseMeasure = Real;
type AccelerationMeasure = Real;
#[derive(Eq, PartialEq, Hash, Debug)]
pub enum ActionItems {
    EntityRef(EntityRef),
    ActionDirective(EntityRef),
    CharacterizedObject(EntityRef),
    ConfigurationEffectivity(EntityRef),
    DesignPdmCertificationItem(DesignPdmCertificationItem),
    DesignPdmClassificationItem(DesignPdmClassificationItem),
    DesignPdmDocumentReferenceItem(DesignPdmDocumentReferenceItem),
    DesignPdmIdentificationItem(DesignPdmIdentificationItem),
    DesignPdmRequirementAssignedItem(DesignPdmRequirementAssignedItem),
    Organization(EntityRef),
    PersonAndOrganization(EntityRef),
    ProductDefinition(EntityRef),
    ProductDefinitionFormation(EntityRef),
    ProductDefinitionFormationRelationship(EntityRef),
    ProductDefinitionRelationship(EntityRef),
}
impl Default for ActionItems {
    fn default() -> Self {
        ActionItems::ActionDirective(EntityRef::default())
    }
}
impl From<Parameter> for ActionItems {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::TypedParameter(typed_parameter) => match typed_parameter.type_name.as_str() {
                "DESIGN_PDM_CERTIFICATION_ITEM" => ActionItems::DesignPdmCertificationItem(
                    typed_parameter.parameters.into_iter().next().unwrap().into(),
                ),
                "DESIGN_PDM_CLASSIFICATION_ITEM" => ActionItems::DesignPdmClassificationItem(
                    typed_parameter.parameters.into_iter().next().unwrap().into(),
                ),
                "DESIGN_PDM_DOCUMENT_REFERENCE_ITEM" => ActionItems::DesignPdmDocumentReferenceItem(
                    typed_parameter.parameters.into_iter().next().unwrap().into(),
                ),
                "DESIGN_PDM_IDENTIFICATION_ITEM" => ActionItems::DesignPdmIdentificationItem(
                    typed_parameter.parameters.into_iter().next().unwrap().into(),
                ),
                "DESIGN_PDM_REQUIREMENT_ASSIGNED_ITEM" => ActionItems::DesignPdmRequirementAssignedItem(
                    typed_parameter.parameters.into_iter().next().unwrap().into(),
                ),
                _ => panic!("parameter type is not recognized: {}", typed_parameter.type_name),
            },
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EntityRef(id) => ActionItems::EntityRef(EntityRef(id)),
                _ => panic!("parameter is not an instance"),
            },
            _ => panic!("parameter is not recognized"),
        }
    }
}
#[derive(Eq, PartialEq, Hash, Debug)]
pub enum ActionMethodItems {
    EntityRef(EntityRef),
    Product(EntityRef),
    ProductDefinitionFormation(EntityRef),
}
impl Default for ActionMethodItems {
    fn default() -> Self {
        ActionMethodItems::Product(EntityRef::default())
    }
}
impl From<Parameter> for ActionMethodItems {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EntityRef(id) => ActionMethodItems::EntityRef(EntityRef(id)),
                _ => panic!("parameter is not an instance"),
            },
            _ => panic!("parameter is not recognized"),
        }
    }
}
#[derive(Eq, PartialEq, Hash, Debug)]
pub enum ActionRequestItem {
    EntityRef(EntityRef),
    ProductDefinition(EntityRef),
    ProductDefinitionFormation(EntityRef),
    ProductDefinitionFormationRelationship(EntityRef),
    ProductDefinitionRelationship(EntityRef),
    PropertyDefinition(EntityRef),
    VersionedActionRequest(EntityRef),
}
impl Default for ActionRequestItem {
    fn default() -> Self {
        ActionRequestItem::ProductDefinition(EntityRef::default())
    }
}
impl From<Parameter> for ActionRequestItem {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EntityRef(id) => ActionRequestItem::EntityRef(EntityRef(id)),
                _ => panic!("parameter is not an instance"),
            },
            _ => panic!("parameter is not recognized"),
        }
    }
}
#[derive(Eq, PartialEq, Hash, Debug)]
pub enum AheadOrBehind {
    Ahead,
    Exact,
    Behind,
}
impl Default for AheadOrBehind {
    fn default() -> Self {
        AheadOrBehind::Ahead
    }
}
impl From<String> for AheadOrBehind {
    fn from(value: String) -> Self {
        match value.as_str() {
            "AHEAD" => AheadOrBehind::Ahead,
            "EXACT" => AheadOrBehind::Exact,
            "BEHIND" => AheadOrBehind::Behind,
            _ => panic!("{} is not a valid value", value),
        }
    }
}
impl From<Parameter> for AheadOrBehind {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EnumValue(value) => value.into(),
                _ => panic!("parameter is not an enum value"),
            },
            Parameter::OmittedParameter => AheadOrBehind::default(),
            _ => panic!("parameter is not an enum value"),
        }
    }
}
type AmountOfSubstanceMeasure = Real;
#[derive(Debug)]
pub enum AngleDirectionReferenceSelect {
    EntityRef(EntityRef),
    Direction(EntityRef),
    Curve(EntityRef),
    PointPath(EntityRef),
}
impl Default for AngleDirectionReferenceSelect {
    fn default() -> Self {
        AngleDirectionReferenceSelect::Direction(EntityRef::default())
    }
}
impl From<Parameter> for AngleDirectionReferenceSelect {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EntityRef(id) => AngleDirectionReferenceSelect::EntityRef(EntityRef(id)),
                _ => panic!("parameter is not an instance"),
            },
            _ => panic!("parameter is not recognized"),
        }
    }
}
#[derive(Debug)]
pub enum AngleDirectionReferenceWithA2p3dSelect {
    AngleDirectionReferenceSelect(AngleDirectionReferenceSelect),
    Axis2Placement3d(EntityRef),
}
impl Default for AngleDirectionReferenceWithA2p3dSelect {
    fn default() -> Self {
        AngleDirectionReferenceWithA2p3dSelect::AngleDirectionReferenceSelect(AngleDirectionReferenceSelect::default())
    }
}
impl From<Parameter> for AngleDirectionReferenceWithA2p3dSelect {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::TypedParameter(typed_parameter) => match typed_parameter.type_name.as_str() {
                "ANGLE_DIRECTION_REFERENCE_SELECT" => {
                    AngleDirectionReferenceWithA2p3dSelect::AngleDirectionReferenceSelect(
                        typed_parameter.parameters.into_iter().next().unwrap().into(),
                    )
                }
                _ => panic!("parameter type is not recognized: {}", typed_parameter.type_name),
            },
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EntityRef(id) => {
                    AngleDirectionReferenceWithA2p3dSelect::Axis2Placement3d(EntityRef(id))
                }
                _ => panic!("parameter is not an instance"),
            },
            _ => panic!("parameter is not recognized"),
        }
    }
}
#[derive(Eq, PartialEq, Hash, Debug)]
pub enum AngleRelator {
    Equal,
    Large,
    Small,
}
impl Default for AngleRelator {
    fn default() -> Self {
        AngleRelator::Equal
    }
}
impl From<String> for AngleRelator {
    fn from(value: String) -> Self {
        match value.as_str() {
            "EQUAL" => AngleRelator::Equal,
            "LARGE" => AngleRelator::Large,
            "SMALL" => AngleRelator::Small,
            _ => panic!("{} is not a valid value", value),
        }
    }
}
impl From<Parameter> for AngleRelator {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EnumValue(value) => value.into(),
                _ => panic!("parameter is not an enum value"),
            },
            Parameter::OmittedParameter => AngleRelator::default(),
            _ => panic!("parameter is not an enum value"),
        }
    }
}
#[derive(Eq, PartialEq, Hash, Debug)]
pub enum AnnotationPlaneElement {
    EntityRef(EntityRef),
    DraughtingCallout(EntityRef),
    StyledItem(EntityRef),
}
impl Default for AnnotationPlaneElement {
    fn default() -> Self {
        AnnotationPlaneElement::DraughtingCallout(EntityRef::default())
    }
}
impl From<Parameter> for AnnotationPlaneElement {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EntityRef(id) => AnnotationPlaneElement::EntityRef(EntityRef(id)),
                _ => panic!("parameter is not an instance"),
            },
            _ => panic!("parameter is not recognized"),
        }
    }
}
#[derive(Debug)]
pub enum AnnotationRepresentationSelect {
    EntityRef(EntityRef),
    AreaDependentAnnotationRepresentation(EntityRef),
    PresentationArea(EntityRef),
    PresentationView(EntityRef),
    SymbolRepresentation(EntityRef),
    ViewDependentAnnotationRepresentation(EntityRef),
}
impl Default for AnnotationRepresentationSelect {
    fn default() -> Self {
        AnnotationRepresentationSelect::AreaDependentAnnotationRepresentation(EntityRef::default())
    }
}
impl From<Parameter> for AnnotationRepresentationSelect {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EntityRef(id) => AnnotationRepresentationSelect::EntityRef(EntityRef(id)),
                _ => panic!("parameter is not an instance"),
            },
            _ => panic!("parameter is not recognized"),
        }
    }
}
#[derive(Debug)]
pub enum AnnotationSymbolOccurrenceItem {
    EntityRef(EntityRef),
    AnnotationSymbol(EntityRef),
    DefinedSymbol(EntityRef),
}
impl Default for AnnotationSymbolOccurrenceItem {
    fn default() -> Self {
        AnnotationSymbolOccurrenceItem::AnnotationSymbol(EntityRef::default())
    }
}
impl From<Parameter> for AnnotationSymbolOccurrenceItem {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EntityRef(id) => AnnotationSymbolOccurrenceItem::EntityRef(EntityRef(id)),
                _ => panic!("parameter is not an instance"),
            },
            _ => panic!("parameter is not recognized"),
        }
    }
}
#[derive(Debug)]
pub enum AnnotationTextOccurrenceItem {
    EntityRef(EntityRef),
    TextLiteral(EntityRef),
    AnnotationText(EntityRef),
    AnnotationTextCharacter(EntityRef),
    CompositeText(EntityRef),
}
impl Default for AnnotationTextOccurrenceItem {
    fn default() -> Self {
        AnnotationTextOccurrenceItem::TextLiteral(EntityRef::default())
    }
}
impl From<Parameter> for AnnotationTextOccurrenceItem {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EntityRef(id) => AnnotationTextOccurrenceItem::EntityRef(EntityRef(id)),
                _ => panic!("parameter is not an instance"),
            },
            _ => panic!("parameter is not recognized"),
        }
    }
}
#[derive(Eq, PartialEq, Hash, Debug)]
pub enum ApprovalItem {
    EntityRef(EntityRef),
    Action(EntityRef),
    ActionDirective(EntityRef),
    AlternateProductRelationship(EntityRef),
    AppliedActionAssignment(EntityRef),
    AppliedUsageRight(EntityRef),
    AssemblyComponentUsageSubstitute(EntityRef),
    Certification(EntityRef),
    ConfigurationEffectivity(EntityRef),
    ConfigurationItem(EntityRef),
    Contract(EntityRef),
    Date(EntityRef),
    DirectedAction(EntityRef),
    Document(EntityRef),
    DocumentFile(EntityRef),
    Effectivity(EntityRef),
    ExecutedAction(EntityRef),
    GeneralPropertyRelationship(EntityRef),
    Group(EntityRef),
    GroupRelationship(EntityRef),
    InformationUsageRight(EntityRef),
    Product(EntityRef),
    ProductDefinition(EntityRef),
    ProductDefinitionFormation(EntityRef),
    ProductDefinitionFormationRelationship(EntityRef),
    ProductDefinitionRelationship(EntityRef),
    Representation(EntityRef),
    RequirementAssignment(EntityRef),
    SecurityClassification(EntityRef),
    ShapeAspectRelationship(EntityRef),
    VersionedActionRequest(EntityRef),
}
impl Default for ApprovalItem {
    fn default() -> Self {
        ApprovalItem::Action(EntityRef::default())
    }
}
impl From<Parameter> for ApprovalItem {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EntityRef(id) => ApprovalItem::EntityRef(EntityRef(id)),
                _ => panic!("parameter is not an instance"),
            },
            _ => panic!("parameter is not recognized"),
        }
    }
}
#[derive(Eq, PartialEq, Hash, Debug)]
pub enum ApprovedItem {
    EntityRef(EntityRef),
    Certification(EntityRef),
    Change(EntityRef),
    ChangeRequest(EntityRef),
    ConfigurationEffectivity(EntityRef),
    ConfigurationItem(EntityRef),
    Contract(EntityRef),
    Product(EntityRef),
    SecurityClassification(EntityRef),
    StartRequest(EntityRef),
    StartWork(EntityRef),
}
impl Default for ApprovedItem {
    fn default() -> Self {
        ApprovedItem::Certification(EntityRef::default())
    }
}
impl From<Parameter> for ApprovedItem {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EntityRef(id) => ApprovedItem::EntityRef(EntityRef(id)),
                _ => panic!("parameter is not an instance"),
            },
            _ => panic!("parameter is not recognized"),
        }
    }
}
#[derive(Eq, PartialEq, Hash, Debug)]
pub enum AreaDependentAnnotationRepresentationItem {
    AnnotationOccurrence(EntityRef),
    Axis2Placement(Axis2Placement),
}
impl Default for AreaDependentAnnotationRepresentationItem {
    fn default() -> Self {
        AreaDependentAnnotationRepresentationItem::AnnotationOccurrence(EntityRef::default())
    }
}
impl From<Parameter> for AreaDependentAnnotationRepresentationItem {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::TypedParameter(typed_parameter) => match typed_parameter.type_name.as_str() {
                "AXIS2_PLACEMENT" => AreaDependentAnnotationRepresentationItem::Axis2Placement(
                    typed_parameter.parameters.into_iter().next().unwrap().into(),
                ),
                _ => panic!("parameter type is not recognized: {}", typed_parameter.type_name),
            },
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EntityRef(id) => {
                    AreaDependentAnnotationRepresentationItem::AnnotationOccurrence(EntityRef(id))
                }
                _ => panic!("parameter is not an instance"),
            },
            _ => panic!("parameter is not recognized"),
        }
    }
}
type AreaMeasure = Real;
#[derive(Debug)]
pub enum AreaOrView {
    EntityRef(EntityRef),
    PresentationArea(EntityRef),
    PresentationView(EntityRef),
}
impl Default for AreaOrView {
    fn default() -> Self {
        AreaOrView::PresentationArea(EntityRef::default())
    }
}
impl From<Parameter> for AreaOrView {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EntityRef(id) => AreaOrView::EntityRef(EntityRef(id)),
                _ => panic!("parameter is not an instance"),
            },
            _ => panic!("parameter is not recognized"),
        }
    }
}
#[derive(Eq, PartialEq, Hash, Debug)]
pub enum AttributeClassificationItem {
    EntityRef(EntityRef),
    ActionDirective(EntityRef),
    ActionMethod(EntityRef),
    ActionProperty(EntityRef),
    ActionPropertyRepresentation(EntityRef),
    ActionRelationship(EntityRef),
    ActionRequestSolution(EntityRef),
    ActionRequestStatus(EntityRef),
    AlternateProductRelationship(EntityRef),
    AppliedActionAssignment(EntityRef),
    AppliedActionRequestAssignment(EntityRef),
    AppliedApprovalAssignment(EntityRef),
    AppliedCertificationAssignment(EntityRef),
    AppliedDocumentReference(EntityRef),
    AppliedDocumentUsageConstraintAssignment(EntityRef),
    AppliedEffectivityAssignment(EntityRef),
    AppliedEventOccurrenceAssignment(EntityRef),
    AppliedExternalIdentificationAssignment(EntityRef),
    AppliedIdentificationAssignment(EntityRef),
    AppliedOrganizationAssignment(EntityRef),
    AppliedOrganizationalProjectAssignment(EntityRef),
    AppliedPersonAndOrganizationAssignment(EntityRef),
    Approval(EntityRef),
    ApprovalPersonOrganization(EntityRef),
    ApprovalRelationship(EntityRef),
    ApprovalStatus(EntityRef),
    Certification(EntityRef),
    ContextDependentUnit(EntityRef),
    Contract(EntityRef),
    DateAndTimeAssignment(EntityRef),
    DateAssignment(EntityRef),
    DerivedUnit(EntityRef),
    DescriptiveRepresentationItem(EntityRef),
    DocumentFile(EntityRef),
    DocumentRelationship(EntityRef),
    Effectivity(EntityRef),
    EventOccurrenceRelationship(EntityRef),
    ExecutedAction(EntityRef),
    GeneralProperty(EntityRef),
    GeneralPropertyRelationship(EntityRef),
    Group(EntityRef),
    GroupRelationship(EntityRef),
    InformationRight(EntityRef),
    InformationUsageRight(EntityRef),
    Language(EntityRef),
    MeasureRepresentationItem(EntityRef),
    MeasureWithUnit(EntityRef),
    NamedUnit(EntityRef),
    OrganizationRelationship(EntityRef),
    OrganizationalAddress(EntityRef),
    OrganizationalProjectRelationship(EntityRef),
    PersonAndOrganization(EntityRef),
    PersonAndOrganizationAddress(EntityRef),
    Product(EntityRef),
    ProductCategory(EntityRef),
    ProductConcept(EntityRef),
    ProductConceptContext(EntityRef),
    ProductDefinition(EntityRef),
    ProductDefinitionContext(EntityRef),
    ProductDefinitionFormation(EntityRef),
    ProductDefinitionFormationRelationship(EntityRef),
    ProductDefinitionRelationship(EntityRef),
    PropertyDefinition(EntityRef),
    PropertyDefinitionRelationship(EntityRef),
    PropertyDefinitionRepresentation(EntityRef),
    Representation(EntityRef),
    RepresentationContext(EntityRef),
    RepresentationItem(EntityRef),
    SecurityClassification(EntityRef),
    TimeIntervalRelationship(EntityRef),
    UncertaintyMeasureWithUnit(EntityRef),
    UsageAssociation(EntityRef),
    VersionedActionRequest(EntityRef),
}
impl Default for AttributeClassificationItem {
    fn default() -> Self {
        AttributeClassificationItem::ActionDirective(EntityRef::default())
    }
}
impl From<Parameter> for AttributeClassificationItem {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EntityRef(id) => AttributeClassificationItem::EntityRef(EntityRef(id)),
                _ => panic!("parameter is not an instance"),
            },
            _ => panic!("parameter is not recognized"),
        }
    }
}
#[derive(Eq, PartialEq, Hash, Debug)]
pub enum AttributeLanguageItem {
    EntityRef(EntityRef),
    AlternateProductRelationship(EntityRef),
    ApplicationContext(EntityRef),
    AppliedCertificationAssignment(EntityRef),
    AppliedDocumentReference(EntityRef),
    AppliedDocumentUsageConstraintAssignment(EntityRef),
    AppliedExternalIdentificationAssignment(EntityRef),
    AppliedIdentificationAssignment(EntityRef),
    AppliedOrganizationalProjectAssignment(EntityRef),
    AppliedSecurityClassificationAssignment(EntityRef),
    Approval(EntityRef),
    ApprovalRelationship(EntityRef),
    ApprovalStatus(EntityRef),
    AssemblyComponentUsageSubstitute(EntityRef),
    AttributeValueAssignment(EntityRef),
    Certification(EntityRef),
    CertificationType(EntityRef),
    ConfigurationDesign(EntityRef),
    ConfigurationItem(EntityRef),
    Contract(EntityRef),
    DateRole(EntityRef),
    DateTimeRole(EntityRef),
    DescriptiveRepresentationItem(EntityRef),
    DocumentRelationship(EntityRef),
    DocumentUsageRole(EntityRef),
    Effectivity(EntityRef),
    EffectivityRelationship(EntityRef),
    EventOccurrence(EntityRef),
    ExternalSource(EntityRef),
    GeneralProperty(EntityRef),
    GeneralPropertyRelationship(EntityRef),
    GeometricRepresentationItem(EntityRef),
    GeometricTolerance(EntityRef),
    IdentificationRole(EntityRef),
    InformationRight(EntityRef),
    InformationUsageRight(EntityRef),
    MakeFromUsageOption(EntityRef),
    MappedItem(EntityRef),
    MultiLanguageAttributeAssignment(EntityRef),
    ObjectRole(EntityRef),
    OrganizationRelationship(EntityRef),
    OrganizationRole(EntityRef),
    OrganizationalProject(EntityRef),
    OrganizationalProjectRelationship(EntityRef),
    OrganizationalProjectRole(EntityRef),
    PersonAndOrganization(EntityRef),
    PersonAndOrganizationRole(EntityRef),
    Product(EntityRef),
    ProductCategory(EntityRef),
    ProductConcept(EntityRef),
    ProductConceptRelationship(EntityRef),
    ProductDefinition(EntityRef),
    ProductDefinitionContext(EntityRef),
    ProductDefinitionFormation(EntityRef),
    ProductDefinitionFormationRelationship(EntityRef),
    ProductDefinitionRelationship(EntityRef),
    ProductDefinitionShape(EntityRef),
    ProductRelatedProductCategory(EntityRef),
    PropertyDefinition(EntityRef),
    Representation(EntityRef),
    SecurityClassification(EntityRef),
    SecurityClassificationAssignment(EntityRef),
    ShapeAspect(EntityRef),
    ShapeAspectRelationship(EntityRef),
    ShapeRepresentation(EntityRef),
    TimeIntervalRole(EntityRef),
    TopologicalRepresentationItem(EntityRef),
    UncertaintyMeasureWithUnit(EntityRef),
    UncertaintyQualifier(EntityRef),
    UsageAssociation(EntityRef),
}
impl Default for AttributeLanguageItem {
    fn default() -> Self {
        AttributeLanguageItem::AlternateProductRelationship(EntityRef::default())
    }
}
impl From<Parameter> for AttributeLanguageItem {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EntityRef(id) => AttributeLanguageItem::EntityRef(EntityRef(id)),
                _ => panic!("parameter is not an instance"),
            },
            _ => panic!("parameter is not recognized"),
        }
    }
}
#[derive(Debug)]
pub enum AttributeType {
    Label(Label),
    Text(Text),
}
impl Default for AttributeType {
    fn default() -> Self {
        AttributeType::Label(Label::default())
    }
}
impl From<Parameter> for AttributeType {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::TypedParameter(typed_parameter) => match typed_parameter.type_name.as_str() {
                "LABEL" => AttributeType::Label(typed_parameter.parameters.into_iter().next().unwrap().into()),
                "TEXT" => AttributeType::Text(typed_parameter.parameters.into_iter().next().unwrap().into()),
                _ => panic!("parameter type is not recognized: {}", typed_parameter.type_name),
            },
            _ => panic!("parameter is not recognized"),
        }
    }
}
#[derive(Eq, PartialEq, Hash, Debug)]
pub enum Axis2Placement {
    EntityRef(EntityRef),
    Axis2Placement2d(EntityRef),
    Axis2Placement3d(EntityRef),
}
impl Default for Axis2Placement {
    fn default() -> Self {
        Axis2Placement::Axis2Placement2d(EntityRef::default())
    }
}
impl From<Parameter> for Axis2Placement {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EntityRef(id) => Axis2Placement::EntityRef(EntityRef(id)),
                _ => panic!("parameter is not an instance"),
            },
            _ => panic!("parameter is not recognized"),
        }
    }
}
#[derive(Eq, PartialEq, Hash, Debug)]
pub enum BSplineCurveForm {
    PolylineForm,
    CircularArc,
    EllipticArc,
    ParabolicArc,
    HyperbolicArc,
    Unspecified,
}
impl Default for BSplineCurveForm {
    fn default() -> Self {
        BSplineCurveForm::PolylineForm
    }
}
impl From<String> for BSplineCurveForm {
    fn from(value: String) -> Self {
        match value.as_str() {
            "POLYLINE_FORM" => BSplineCurveForm::PolylineForm,
            "CIRCULAR_ARC" => BSplineCurveForm::CircularArc,
            "ELLIPTIC_ARC" => BSplineCurveForm::EllipticArc,
            "PARABOLIC_ARC" => BSplineCurveForm::ParabolicArc,
            "HYPERBOLIC_ARC" => BSplineCurveForm::HyperbolicArc,
            "UNSPECIFIED" => BSplineCurveForm::Unspecified,
            _ => panic!("{} is not a valid value", value),
        }
    }
}
impl From<Parameter> for BSplineCurveForm {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EnumValue(value) => value.into(),
                _ => panic!("parameter is not an enum value"),
            },
            Parameter::OmittedParameter => BSplineCurveForm::default(),
            _ => panic!("parameter is not an enum value"),
        }
    }
}
#[derive(Eq, PartialEq, Hash, Debug)]
pub enum BSplineSurfaceForm {
    PlaneSurf,
    CylindricalSurf,
    ConicalSurf,
    SphericalSurf,
    ToroidalSurf,
    SurfOfRevolution,
    RuledSurf,
    GeneralisedCone,
    QuadricSurf,
    SurfOfLinearExtrusion,
    Unspecified,
}
impl Default for BSplineSurfaceForm {
    fn default() -> Self {
        BSplineSurfaceForm::PlaneSurf
    }
}
impl From<String> for BSplineSurfaceForm {
    fn from(value: String) -> Self {
        match value.as_str() {
            "PLANE_SURF" => BSplineSurfaceForm::PlaneSurf,
            "CYLINDRICAL_SURF" => BSplineSurfaceForm::CylindricalSurf,
            "CONICAL_SURF" => BSplineSurfaceForm::ConicalSurf,
            "SPHERICAL_SURF" => BSplineSurfaceForm::SphericalSurf,
            "TOROIDAL_SURF" => BSplineSurfaceForm::ToroidalSurf,
            "SURF_OF_REVOLUTION" => BSplineSurfaceForm::SurfOfRevolution,
            "RULED_SURF" => BSplineSurfaceForm::RuledSurf,
            "GENERALISED_CONE" => BSplineSurfaceForm::GeneralisedCone,
            "QUADRIC_SURF" => BSplineSurfaceForm::QuadricSurf,
            "SURF_OF_LINEAR_EXTRUSION" => BSplineSurfaceForm::SurfOfLinearExtrusion,
            "UNSPECIFIED" => BSplineSurfaceForm::Unspecified,
            _ => panic!("{} is not a valid value", value),
        }
    }
}
impl From<Parameter> for BSplineSurfaceForm {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EnumValue(value) => value.into(),
                _ => panic!("parameter is not an enum value"),
            },
            Parameter::OmittedParameter => BSplineSurfaceForm::default(),
            _ => panic!("parameter is not an enum value"),
        }
    }
}
#[derive(Debug)]
pub enum BaseSolidSelect {
    EntityRef(EntityRef),
    SolidModel(EntityRef),
    CsgPrimitive(CsgPrimitive),
    BooleanResult(EntityRef),
}
impl Default for BaseSolidSelect {
    fn default() -> Self {
        BaseSolidSelect::SolidModel(EntityRef::default())
    }
}
impl From<Parameter> for BaseSolidSelect {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::TypedParameter(typed_parameter) => match typed_parameter.type_name.as_str() {
                "CSG_PRIMITIVE" => {
                    BaseSolidSelect::CsgPrimitive(typed_parameter.parameters.into_iter().next().unwrap().into())
                }
                _ => panic!("parameter type is not recognized: {}", typed_parameter.type_name),
            },
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EntityRef(id) => BaseSolidSelect::EntityRef(EntityRef(id)),
                _ => panic!("parameter is not an instance"),
            },
            _ => panic!("parameter is not recognized"),
        }
    }
}
#[derive(Debug)]
pub enum BlendEndConditionSelect {
    EntityRef(EntityRef),
    PointOnCurve(EntityRef),
    EdgeCurve(EntityRef),
    Vertex(EntityRef),
}
impl Default for BlendEndConditionSelect {
    fn default() -> Self {
        BlendEndConditionSelect::PointOnCurve(EntityRef::default())
    }
}
impl From<Parameter> for BlendEndConditionSelect {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EntityRef(id) => BlendEndConditionSelect::EntityRef(EntityRef(id)),
                _ => panic!("parameter is not an instance"),
            },
            _ => panic!("parameter is not recognized"),
        }
    }
}
#[derive(Eq, PartialEq, Hash, Debug)]
pub enum BlendRadiusVariationType {
    LinearBlend,
    CubicBlend,
    UnspecifiedBlend,
}
impl Default for BlendRadiusVariationType {
    fn default() -> Self {
        BlendRadiusVariationType::LinearBlend
    }
}
impl From<String> for BlendRadiusVariationType {
    fn from(value: String) -> Self {
        match value.as_str() {
            "LINEAR_BLEND" => BlendRadiusVariationType::LinearBlend,
            "CUBIC_BLEND" => BlendRadiusVariationType::CubicBlend,
            "UNSPECIFIED_BLEND" => BlendRadiusVariationType::UnspecifiedBlend,
            _ => panic!("{} is not a valid value", value),
        }
    }
}
impl From<Parameter> for BlendRadiusVariationType {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EnumValue(value) => value.into(),
                _ => panic!("parameter is not an enum value"),
            },
            Parameter::OmittedParameter => BlendRadiusVariationType::default(),
            _ => panic!("parameter is not an enum value"),
        }
    }
}
#[derive(Debug)]
pub enum BooleanOperand {
    EntityRef(EntityRef),
    SolidModel(EntityRef),
    HalfSpaceSolid(EntityRef),
    CsgPrimitive(CsgPrimitive),
    BooleanResult(EntityRef),
}
impl Default for BooleanOperand {
    fn default() -> Self {
        BooleanOperand::SolidModel(EntityRef::default())
    }
}
impl From<Parameter> for BooleanOperand {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::TypedParameter(typed_parameter) => match typed_parameter.type_name.as_str() {
                "CSG_PRIMITIVE" => {
                    BooleanOperand::CsgPrimitive(typed_parameter.parameters.into_iter().next().unwrap().into())
                }
                _ => panic!("parameter type is not recognized: {}", typed_parameter.type_name),
            },
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EntityRef(id) => BooleanOperand::EntityRef(EntityRef(id)),
                _ => panic!("parameter is not an instance"),
            },
            _ => panic!("parameter is not recognized"),
        }
    }
}
#[derive(Eq, PartialEq, Hash, Debug)]
pub enum BooleanOperator {
    Union,
    Intersection,
    Difference,
}
impl Default for BooleanOperator {
    fn default() -> Self {
        BooleanOperator::Union
    }
}
impl From<String> for BooleanOperator {
    fn from(value: String) -> Self {
        match value.as_str() {
            "UNION" => BooleanOperator::Union,
            "INTERSECTION" => BooleanOperator::Intersection,
            "DIFFERENCE" => BooleanOperator::Difference,
            _ => panic!("{} is not a valid value", value),
        }
    }
}
impl From<Parameter> for BooleanOperator {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EnumValue(value) => value.into(),
                _ => panic!("parameter is not an enum value"),
            },
            Parameter::OmittedParameter => BooleanOperator::default(),
            _ => panic!("parameter is not an enum value"),
        }
    }
}
#[derive(Eq, PartialEq, Hash, Debug)]
pub enum BoxCharacteristicSelect {
    BoxHeight(BoxHeight),
    BoxWidth(BoxWidth),
    BoxSlantAngle(BoxSlantAngle),
    BoxRotateAngle(BoxRotateAngle),
}
impl Default for BoxCharacteristicSelect {
    fn default() -> Self {
        BoxCharacteristicSelect::BoxHeight(BoxHeight::default())
    }
}
impl From<Parameter> for BoxCharacteristicSelect {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::TypedParameter(typed_parameter) => match typed_parameter.type_name.as_str() {
                "BOX_HEIGHT" => {
                    BoxCharacteristicSelect::BoxHeight(typed_parameter.parameters.into_iter().next().unwrap().into())
                }
                "BOX_WIDTH" => {
                    BoxCharacteristicSelect::BoxWidth(typed_parameter.parameters.into_iter().next().unwrap().into())
                }
                "BOX_SLANT_ANGLE" => BoxCharacteristicSelect::BoxSlantAngle(
                    typed_parameter.parameters.into_iter().next().unwrap().into(),
                ),
                "BOX_ROTATE_ANGLE" => BoxCharacteristicSelect::BoxRotateAngle(
                    typed_parameter.parameters.into_iter().next().unwrap().into(),
                ),
                _ => panic!("parameter type is not recognized: {}", typed_parameter.type_name),
            },
            _ => panic!("parameter is not recognized"),
        }
    }
}
type BoxHeight = PositiveRatioMeasure;
type BoxRotateAngle = PlaneAngleMeasure;
type BoxSlantAngle = PlaneAngleMeasure;
type BoxWidth = PositiveRatioMeasure;
#[derive(Eq, PartialEq, Hash, Debug)]
pub enum CameraModelD3MultiClippingInterectionSelect {
    EntityRef(EntityRef),
    CameraModelD3MultiClippingUnion(EntityRef),
    Plane(EntityRef),
}
impl Default for CameraModelD3MultiClippingInterectionSelect {
    fn default() -> Self {
        CameraModelD3MultiClippingInterectionSelect::CameraModelD3MultiClippingUnion(EntityRef::default())
    }
}
impl From<Parameter> for CameraModelD3MultiClippingInterectionSelect {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EntityRef(id) => {
                    CameraModelD3MultiClippingInterectionSelect::EntityRef(EntityRef(id))
                }
                _ => panic!("parameter is not an instance"),
            },
            _ => panic!("parameter is not recognized"),
        }
    }
}
#[derive(Eq, PartialEq, Hash, Debug)]
pub enum CameraModelD3MultiClippingUnionSelect {
    EntityRef(EntityRef),
    CameraModelD3MultiClippingIntersection(EntityRef),
    Plane(EntityRef),
}
impl Default for CameraModelD3MultiClippingUnionSelect {
    fn default() -> Self {
        CameraModelD3MultiClippingUnionSelect::CameraModelD3MultiClippingIntersection(EntityRef::default())
    }
}
impl From<Parameter> for CameraModelD3MultiClippingUnionSelect {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EntityRef(id) => CameraModelD3MultiClippingUnionSelect::EntityRef(EntityRef(id)),
                _ => panic!("parameter is not an instance"),
            },
            _ => panic!("parameter is not recognized"),
        }
    }
}
type CapacitanceMeasure = Real;
#[derive(Eq, PartialEq, Hash, Debug)]
pub enum CategoryUsageItem {
    ProductClass(EntityRef),
}
impl Default for CategoryUsageItem {
    fn default() -> Self {
        CategoryUsageItem::ProductClass(EntityRef::default())
    }
}
impl From<Parameter> for CategoryUsageItem {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EntityRef(id) => CategoryUsageItem::ProductClass(EntityRef(id)),
                _ => panic!("parameter is not an instance"),
            },
            _ => panic!("parameter is not recognized"),
        }
    }
}
#[derive(Eq, PartialEq, Hash, Debug)]
pub enum CcClassifiedItem {
    EntityRef(EntityRef),
    AssemblyComponentUsage(EntityRef),
    ProductDefinitionFormation(EntityRef),
}
impl Default for CcClassifiedItem {
    fn default() -> Self {
        CcClassifiedItem::AssemblyComponentUsage(EntityRef::default())
    }
}
impl From<Parameter> for CcClassifiedItem {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EntityRef(id) => CcClassifiedItem::EntityRef(EntityRef(id)),
                _ => panic!("parameter is not an instance"),
            },
            _ => panic!("parameter is not recognized"),
        }
    }
}
#[derive(Eq, PartialEq, Hash, Debug)]
pub enum CcPersonOrganizationItem {
    EntityRef(EntityRef),
    Change(EntityRef),
    ChangeRequest(EntityRef),
    ConfigurationItem(EntityRef),
    Contract(EntityRef),
    Product(EntityRef),
    ProductDefinition(EntityRef),
    ProductDefinitionFormation(EntityRef),
    SecurityClassification(EntityRef),
    StartRequest(EntityRef),
    StartWork(EntityRef),
}
impl Default for CcPersonOrganizationItem {
    fn default() -> Self {
        CcPersonOrganizationItem::Change(EntityRef::default())
    }
}
impl From<Parameter> for CcPersonOrganizationItem {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EntityRef(id) => CcPersonOrganizationItem::EntityRef(EntityRef(id)),
                _ => panic!("parameter is not an instance"),
            },
            _ => panic!("parameter is not recognized"),
        }
    }
}
#[derive(Eq, PartialEq, Hash, Debug)]
pub enum CcSpecifiedItem {
    EntityRef(EntityRef),
    ProductDefinition(EntityRef),
    ShapeAspect(EntityRef),
}
impl Default for CcSpecifiedItem {
    fn default() -> Self {
        CcSpecifiedItem::ProductDefinition(EntityRef::default())
    }
}
impl From<Parameter> for CcSpecifiedItem {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EntityRef(id) => CcSpecifiedItem::EntityRef(EntityRef(id)),
                _ => panic!("parameter is not an instance"),
            },
            _ => panic!("parameter is not recognized"),
        }
    }
}
type CelsiusTemperatureMeasure = Real;
#[derive(Eq, PartialEq, Hash, Debug)]
pub enum CentralOrParallel {
    Central,
    Parallel,
}
impl Default for CentralOrParallel {
    fn default() -> Self {
        CentralOrParallel::Central
    }
}
impl From<String> for CentralOrParallel {
    fn from(value: String) -> Self {
        match value.as_str() {
            "CENTRAL" => CentralOrParallel::Central,
            "PARALLEL" => CentralOrParallel::Parallel,
            _ => panic!("{} is not a valid value", value),
        }
    }
}
impl From<Parameter> for CentralOrParallel {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EnumValue(value) => value.into(),
                _ => panic!("parameter is not an enum value"),
            },
            Parameter::OmittedParameter => CentralOrParallel::default(),
            _ => panic!("parameter is not an enum value"),
        }
    }
}
#[derive(Eq, PartialEq, Hash, Debug)]
pub enum CertificationItem {
    EntityRef(EntityRef),
    AlternateProductRelationship(EntityRef),
    MakeFromUsageOption(EntityRef),
    ProductDefinitionFormation(EntityRef),
    ProductDefinitionFormationRelationship(EntityRef),
}
impl Default for CertificationItem {
    fn default() -> Self {
        CertificationItem::AlternateProductRelationship(EntityRef::default())
    }
}
impl From<Parameter> for CertificationItem {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EntityRef(id) => CertificationItem::EntityRef(EntityRef(id)),
                _ => panic!("parameter is not an instance"),
            },
            _ => panic!("parameter is not recognized"),
        }
    }
}
#[derive(Eq, PartialEq, Hash, Debug)]
pub enum CertifiedItem {
    SuppliedPartRelationship(EntityRef),
}
impl Default for CertifiedItem {
    fn default() -> Self {
        CertifiedItem::SuppliedPartRelationship(EntityRef::default())
    }
}
impl From<Parameter> for CertifiedItem {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EntityRef(id) => CertifiedItem::SuppliedPartRelationship(EntityRef(id)),
                _ => panic!("parameter is not an instance"),
            },
            _ => panic!("parameter is not recognized"),
        }
    }
}
#[derive(Eq, PartialEq, Hash, Debug)]
pub enum ChangeRequestItem {
    ProductDefinitionFormation(EntityRef),
}
impl Default for ChangeRequestItem {
    fn default() -> Self {
        ChangeRequestItem::ProductDefinitionFormation(EntityRef::default())
    }
}
impl From<Parameter> for ChangeRequestItem {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EntityRef(id) => ChangeRequestItem::ProductDefinitionFormation(EntityRef(id)),
                _ => panic!("parameter is not an instance"),
            },
            _ => panic!("parameter is not recognized"),
        }
    }
}
#[derive(Debug)]
pub enum CharacterSpacingSelect {
    LengthMeasure(LengthMeasure),
    RatioMeasure(RatioMeasure),
    MeasureWithUnit(EntityRef),
    DescriptiveMeasure(DescriptiveMeasure),
}
impl Default for CharacterSpacingSelect {
    fn default() -> Self {
        CharacterSpacingSelect::LengthMeasure(LengthMeasure::default())
    }
}
impl From<Parameter> for CharacterSpacingSelect {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::TypedParameter(typed_parameter) => match typed_parameter.type_name.as_str() {
                "LENGTH_MEASURE" => {
                    CharacterSpacingSelect::LengthMeasure(typed_parameter.parameters.into_iter().next().unwrap().into())
                }
                "RATIO_MEASURE" => {
                    CharacterSpacingSelect::RatioMeasure(typed_parameter.parameters.into_iter().next().unwrap().into())
                }
                "DESCRIPTIVE_MEASURE" => CharacterSpacingSelect::DescriptiveMeasure(
                    typed_parameter.parameters.into_iter().next().unwrap().into(),
                ),
                _ => panic!("parameter type is not recognized: {}", typed_parameter.type_name),
            },
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EntityRef(id) => CharacterSpacingSelect::MeasureWithUnit(EntityRef(id)),
                _ => panic!("parameter is not an instance"),
            },
            _ => panic!("parameter is not recognized"),
        }
    }
}
#[derive(Debug)]
pub enum CharacterStyleSelect {
    EntityRef(EntityRef),
    CharacterGlyphStyleStroke(EntityRef),
    CharacterGlyphStyleOutline(EntityRef),
    TextStyleForDefinedFont(EntityRef),
}
impl Default for CharacterStyleSelect {
    fn default() -> Self {
        CharacterStyleSelect::CharacterGlyphStyleStroke(EntityRef::default())
    }
}
impl From<Parameter> for CharacterStyleSelect {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EntityRef(id) => CharacterStyleSelect::EntityRef(EntityRef(id)),
                _ => panic!("parameter is not an instance"),
            },
            _ => panic!("parameter is not recognized"),
        }
    }
}
#[derive(Debug)]
pub enum CharacterizedActionDefinition {
    EntityRef(EntityRef),
    Action(EntityRef),
    ActionMethod(EntityRef),
    ActionMethodRelationship(EntityRef),
    ActionRelationship(EntityRef),
}
impl Default for CharacterizedActionDefinition {
    fn default() -> Self {
        CharacterizedActionDefinition::Action(EntityRef::default())
    }
}
impl From<Parameter> for CharacterizedActionDefinition {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EntityRef(id) => CharacterizedActionDefinition::EntityRef(EntityRef(id)),
                _ => panic!("parameter is not an instance"),
            },
            _ => panic!("parameter is not recognized"),
        }
    }
}
#[derive(Eq, PartialEq, Hash, Debug)]
pub enum CharacterizedDefinition {
    CharacterizedObject(EntityRef),
    CharacterizedProductDefinition(CharacterizedProductDefinition),
    ShapeDefinition(ShapeDefinition),
}
impl Default for CharacterizedDefinition {
    fn default() -> Self {
        CharacterizedDefinition::CharacterizedObject(EntityRef::default())
    }
}
impl From<Parameter> for CharacterizedDefinition {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::TypedParameter(typed_parameter) => match typed_parameter.type_name.as_str() {
                "CHARACTERIZED_PRODUCT_DEFINITION" => CharacterizedDefinition::CharacterizedProductDefinition(
                    typed_parameter.parameters.into_iter().next().unwrap().into(),
                ),
                "SHAPE_DEFINITION" => CharacterizedDefinition::ShapeDefinition(
                    typed_parameter.parameters.into_iter().next().unwrap().into(),
                ),
                _ => panic!("parameter type is not recognized: {}", typed_parameter.type_name),
            },
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EntityRef(id) => CharacterizedDefinition::CharacterizedObject(EntityRef(id)),
                _ => panic!("parameter is not an instance"),
            },
            _ => panic!("parameter is not recognized"),
        }
    }
}
#[derive(Debug)]
pub enum CharacterizedMaterialProperty {
    EntityRef(EntityRef),
    MaterialPropertyRepresentation(EntityRef),
    ProductMaterialCompositionRelationship(EntityRef),
}
impl Default for CharacterizedMaterialProperty {
    fn default() -> Self {
        CharacterizedMaterialProperty::MaterialPropertyRepresentation(EntityRef::default())
    }
}
impl From<Parameter> for CharacterizedMaterialProperty {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EntityRef(id) => CharacterizedMaterialProperty::EntityRef(EntityRef(id)),
                _ => panic!("parameter is not an instance"),
            },
            _ => panic!("parameter is not recognized"),
        }
    }
}
#[derive(Eq, PartialEq, Hash, Debug)]
pub enum CharacterizedProductCompositionValue {
    MeasureWithUnit(EntityRef),
}
impl Default for CharacterizedProductCompositionValue {
    fn default() -> Self {
        CharacterizedProductCompositionValue::MeasureWithUnit(EntityRef::default())
    }
}
impl From<Parameter> for CharacterizedProductCompositionValue {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EntityRef(id) => CharacterizedProductCompositionValue::MeasureWithUnit(EntityRef(id)),
                _ => panic!("parameter is not an instance"),
            },
            _ => panic!("parameter is not recognized"),
        }
    }
}
#[derive(Eq, PartialEq, Hash, Debug)]
pub enum CharacterizedProductDefinition {
    EntityRef(EntityRef),
    ProductDefinition(EntityRef),
    ProductDefinitionRelationship(EntityRef),
}
impl Default for CharacterizedProductDefinition {
    fn default() -> Self {
        CharacterizedProductDefinition::ProductDefinition(EntityRef::default())
    }
}
impl From<Parameter> for CharacterizedProductDefinition {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EntityRef(id) => CharacterizedProductDefinition::EntityRef(EntityRef(id)),
                _ => panic!("parameter is not an instance"),
            },
            _ => panic!("parameter is not recognized"),
        }
    }
}
#[derive(Eq, PartialEq, Hash, Debug)]
pub enum ClassUsageEffectivityContextItem {
    ProductDefinition(EntityRef),
}
impl Default for ClassUsageEffectivityContextItem {
    fn default() -> Self {
        ClassUsageEffectivityContextItem::ProductDefinition(EntityRef::default())
    }
}
impl From<Parameter> for ClassUsageEffectivityContextItem {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EntityRef(id) => ClassUsageEffectivityContextItem::ProductDefinition(EntityRef(id)),
                _ => panic!("parameter is not an instance"),
            },
            _ => panic!("parameter is not recognized"),
        }
    }
}
#[derive(Eq, PartialEq, Hash, Debug)]
pub enum ClassificationItem {
    EntityRef(EntityRef),
    Action(EntityRef),
    ActionDirective(EntityRef),
    ActionMethod(EntityRef),
    ActionProperty(EntityRef),
    ActionRelationship(EntityRef),
    ActionRequestSolution(EntityRef),
    ActionRequestStatus(EntityRef),
    Address(EntityRef),
    AlternateProductRelationship(EntityRef),
    AppliedActionAssignment(EntityRef),
    AppliedActionRequestAssignment(EntityRef),
    AppliedApprovalAssignment(EntityRef),
    AppliedCertificationAssignment(EntityRef),
    AppliedContractAssignment(EntityRef),
    AppliedDateAndTimeAssignment(EntityRef),
    AppliedDateAssignment(EntityRef),
    AppliedDocumentReference(EntityRef),
    AppliedDocumentUsageConstraintAssignment(EntityRef),
    AppliedEffectivityAssignment(EntityRef),
    AppliedEventOccurrenceAssignment(EntityRef),
    AppliedExternalIdentificationAssignment(EntityRef),
    AppliedIdentificationAssignment(EntityRef),
    AppliedOrganizationAssignment(EntityRef),
    AppliedOrganizationalProjectAssignment(EntityRef),
    AppliedPersonAndOrganizationAssignment(EntityRef),
    AppliedSecurityClassificationAssignment(EntityRef),
    Approval(EntityRef),
    ApprovalPersonOrganization(EntityRef),
    ApprovalRelationship(EntityRef),
    ApprovalStatus(EntityRef),
    AssemblyComponentUsageSubstitute(EntityRef),
    CalendarDate(EntityRef),
    Certification(EntityRef),
    CharacterizedClass(EntityRef),
    CharacterizedObject(EntityRef),
    Class(EntityRef),
    ClassifiedItem(ClassifiedItem),
    ConfigurationItem(EntityRef),
    ContextDependentUnit(EntityRef),
    Contract(EntityRef),
    ConversionBasedUnit(EntityRef),
    DateAndTime(EntityRef),
    DateAndTimeAssignment(EntityRef),
    DateAssignment(EntityRef),
    DerivedUnit(EntityRef),
    DescriptiveRepresentationItem(EntityRef),
    DirectedAction(EntityRef),
    DocumentFile(EntityRef),
    DocumentRelationship(EntityRef),
    Effectivity(EntityRef),
    EventOccurrence(EntityRef),
    ExecutedAction(EntityRef),
    GeneralProperty(EntityRef),
    GeneralPropertyRelationship(EntityRef),
    Group(EntityRef),
    IdentificationAssignment(EntityRef),
    InformationRight(EntityRef),
    InformationUsageRight(EntityRef),
    Language(EntityRef),
    MeasureRepresentationItem(EntityRef),
    MeasureWithUnit(EntityRef),
    MultiLanguageAttributeAssignment(EntityRef),
    NamedUnit(EntityRef),
    Organization(EntityRef),
    OrganizationRelationship(EntityRef),
    OrganizationalAddress(EntityRef),
    OrganizationalProject(EntityRef),
    OrganizationalProjectRelationship(EntityRef),
    Person(EntityRef),
    PersonAndOrganizationAddress(EntityRef),
    Product(EntityRef),
    ProductCategory(EntityRef),
    ProductConcept(EntityRef),
    ProductDefinition(EntityRef),
    ProductDefinitionContext(EntityRef),
    ProductDefinitionFormation(EntityRef),
    ProductDefinitionFormationRelationship(EntityRef),
    ProductDefinitionRelationship(EntityRef),
    PropertyDefinition(EntityRef),
    PropertyDefinitionRepresentation(EntityRef),
    Representation(EntityRef),
    RepresentationContext(EntityRef),
    RepresentationItem(EntityRef),
    SecurityClassification(EntityRef),
    UncertaintyMeasureWithUnit(EntityRef),
    UsageAssociation(EntityRef),
    VersionedActionRequest(EntityRef),
}
impl Default for ClassificationItem {
    fn default() -> Self {
        ClassificationItem::Action(EntityRef::default())
    }
}
impl From<Parameter> for ClassificationItem {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::TypedParameter(typed_parameter) => match typed_parameter.type_name.as_str() {
                "CLASSIFIED_ITEM" => {
                    ClassificationItem::ClassifiedItem(typed_parameter.parameters.into_iter().next().unwrap().into())
                }
                _ => panic!("parameter type is not recognized: {}", typed_parameter.type_name),
            },
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EntityRef(id) => ClassificationItem::EntityRef(EntityRef(id)),
                _ => panic!("parameter is not an instance"),
            },
            _ => panic!("parameter is not recognized"),
        }
    }
}
#[derive(Eq, PartialEq, Hash, Debug)]
pub enum ClassifiedItem {
    EntityRef(EntityRef),
    Product(EntityRef),
    ProductDefinition(EntityRef),
    ProductDefinitionFormation(EntityRef),
}
impl Default for ClassifiedItem {
    fn default() -> Self {
        ClassifiedItem::Product(EntityRef::default())
    }
}
impl From<Parameter> for ClassifiedItem {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EntityRef(id) => ClassifiedItem::EntityRef(EntityRef(id)),
                _ => panic!("parameter is not an instance"),
            },
            _ => panic!("parameter is not recognized"),
        }
    }
}
#[derive(Debug)]
pub enum CompoundItemDefinition {
    ListRepresentationItem(ListRepresentationItem),
    SetRepresentationItem(SetRepresentationItem),
}
impl Default for CompoundItemDefinition {
    fn default() -> Self {
        CompoundItemDefinition::ListRepresentationItem(ListRepresentationItem::default())
    }
}
impl From<Parameter> for CompoundItemDefinition {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::TypedParameter(typed_parameter) => match typed_parameter.type_name.as_str() {
                "LIST_REPRESENTATION_ITEM" => CompoundItemDefinition::ListRepresentationItem(
                    typed_parameter.parameters.into_iter().next().unwrap().into(),
                ),
                "SET_REPRESENTATION_ITEM" => CompoundItemDefinition::SetRepresentationItem(
                    typed_parameter.parameters.into_iter().next().unwrap().into(),
                ),
                _ => panic!("parameter type is not recognized: {}", typed_parameter.type_name),
            },
            _ => panic!("parameter is not recognized"),
        }
    }
}
type ConductanceMeasure = Real;
#[derive(Debug)]
pub enum ConfigurationDesignItem {
    EntityRef(EntityRef),
    ProductDefinition(EntityRef),
    ProductDefinitionFormation(EntityRef),
}
impl Default for ConfigurationDesignItem {
    fn default() -> Self {
        ConfigurationDesignItem::ProductDefinition(EntityRef::default())
    }
}
impl From<Parameter> for ConfigurationDesignItem {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EntityRef(id) => ConfigurationDesignItem::EntityRef(EntityRef(id)),
                _ => panic!("parameter is not an instance"),
            },
            _ => panic!("parameter is not recognized"),
        }
    }
}
#[derive(Eq, PartialEq, Hash, Debug)]
pub enum ConfiguredEffectivityContextItem {
    ProductConceptFeatureAssociation(EntityRef),
}
impl Default for ConfiguredEffectivityContextItem {
    fn default() -> Self {
        ConfiguredEffectivityContextItem::ProductConceptFeatureAssociation(EntityRef::default())
    }
}
impl From<Parameter> for ConfiguredEffectivityContextItem {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EntityRef(id) => {
                    ConfiguredEffectivityContextItem::ProductConceptFeatureAssociation(EntityRef(id))
                }
                _ => panic!("parameter is not an instance"),
            },
            _ => panic!("parameter is not recognized"),
        }
    }
}
#[derive(Eq, PartialEq, Hash, Debug)]
pub enum ConfiguredEffectivityItem {
    ProductDefinition(EntityRef),
}
impl Default for ConfiguredEffectivityItem {
    fn default() -> Self {
        ConfiguredEffectivityItem::ProductDefinition(EntityRef::default())
    }
}
impl From<Parameter> for ConfiguredEffectivityItem {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EntityRef(id) => ConfiguredEffectivityItem::ProductDefinition(EntityRef(id)),
                _ => panic!("parameter is not an instance"),
            },
            _ => panic!("parameter is not recognized"),
        }
    }
}
#[derive(Debug)]
pub enum ConstructiveGeometryRepresentationOrShapeRepresenation {
    EntityRef(EntityRef),
    ConstructiveGeometryRepresentation(EntityRef),
    ShapeRepresentation(EntityRef),
}
impl Default for ConstructiveGeometryRepresentationOrShapeRepresenation {
    fn default() -> Self {
        ConstructiveGeometryRepresentationOrShapeRepresenation::ConstructiveGeometryRepresentation(EntityRef::default())
    }
}
impl From<Parameter> for ConstructiveGeometryRepresentationOrShapeRepresenation {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EntityRef(id) => {
                    ConstructiveGeometryRepresentationOrShapeRepresenation::EntityRef(EntityRef(id))
                }
                _ => panic!("parameter is not an instance"),
            },
            _ => panic!("parameter is not recognized"),
        }
    }
}
type ContextDependentMeasure = Real;
#[derive(Eq, PartialEq, Hash, Debug)]
pub enum ContractItem {
    EntityRef(EntityRef),
    ActionDirective(EntityRef),
    AlternateProductRelationship(EntityRef),
    DirectedAction(EntityRef),
    ExecutedAction(EntityRef),
    InformationUsageRight(EntityRef),
    Organization(EntityRef),
    PersonAndOrganization(EntityRef),
    Product(EntityRef),
    ProductDefinitionFormation(EntityRef),
}
impl Default for ContractItem {
    fn default() -> Self {
        ContractItem::ActionDirective(EntityRef::default())
    }
}
impl From<Parameter> for ContractItem {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EntityRef(id) => ContractItem::EntityRef(EntityRef(id)),
                _ => panic!("parameter is not an instance"),
            },
            _ => panic!("parameter is not recognized"),
        }
    }
}
#[derive(Eq, PartialEq, Hash, Debug)]
pub enum ContractedItem {
    ProductDefinitionFormation(EntityRef),
}
impl Default for ContractedItem {
    fn default() -> Self {
        ContractedItem::ProductDefinitionFormation(EntityRef::default())
    }
}
impl From<Parameter> for ContractedItem {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EntityRef(id) => ContractedItem::ProductDefinitionFormation(EntityRef(id)),
                _ => panic!("parameter is not an instance"),
            },
            _ => panic!("parameter is not recognized"),
        }
    }
}
type CountMeasure = Real;
#[derive(Debug)]
pub enum CsgPrimitive {
    EntityRef(EntityRef),
    Sphere(EntityRef),
    Block(EntityRef),
    RightAngularWedge(EntityRef),
    Torus(EntityRef),
    RightCircularCone(EntityRef),
    RightCircularCylinder(EntityRef),
}
impl Default for CsgPrimitive {
    fn default() -> Self {
        CsgPrimitive::Sphere(EntityRef::default())
    }
}
impl From<Parameter> for CsgPrimitive {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EntityRef(id) => CsgPrimitive::EntityRef(EntityRef(id)),
                _ => panic!("parameter is not an instance"),
            },
            _ => panic!("parameter is not recognized"),
        }
    }
}
#[derive(Debug)]
pub enum CsgSelect {
    BooleanResult(EntityRef),
    CsgPrimitive(CsgPrimitive),
}
impl Default for CsgSelect {
    fn default() -> Self {
        CsgSelect::BooleanResult(EntityRef::default())
    }
}
impl From<Parameter> for CsgSelect {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::TypedParameter(typed_parameter) => match typed_parameter.type_name.as_str() {
                "CSG_PRIMITIVE" => {
                    CsgSelect::CsgPrimitive(typed_parameter.parameters.into_iter().next().unwrap().into())
                }
                _ => panic!("parameter type is not recognized: {}", typed_parameter.type_name),
            },
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EntityRef(id) => CsgSelect::BooleanResult(EntityRef(id)),
                _ => panic!("parameter is not an instance"),
            },
            _ => panic!("parameter is not recognized"),
        }
    }
}
#[derive(Debug)]
pub enum CurveFontOrScaledCurveFontSelect {
    CurveStyleFontSelect(CurveStyleFontSelect),
    CurveStyleFontAndScaling(EntityRef),
}
impl Default for CurveFontOrScaledCurveFontSelect {
    fn default() -> Self {
        CurveFontOrScaledCurveFontSelect::CurveStyleFontSelect(CurveStyleFontSelect::default())
    }
}
impl From<Parameter> for CurveFontOrScaledCurveFontSelect {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::TypedParameter(typed_parameter) => match typed_parameter.type_name.as_str() {
                "CURVE_STYLE_FONT_SELECT" => CurveFontOrScaledCurveFontSelect::CurveStyleFontSelect(
                    typed_parameter.parameters.into_iter().next().unwrap().into(),
                ),
                _ => panic!("parameter type is not recognized: {}", typed_parameter.type_name),
            },
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EntityRef(id) => {
                    CurveFontOrScaledCurveFontSelect::CurveStyleFontAndScaling(EntityRef(id))
                }
                _ => panic!("parameter is not an instance"),
            },
            _ => panic!("parameter is not recognized"),
        }
    }
}
#[derive(Debug)]
pub enum CurveOnSurface {
    EntityRef(EntityRef),
    Pcurve(EntityRef),
    SurfaceCurve(EntityRef),
    CompositeCurveOnSurface(EntityRef),
}
impl Default for CurveOnSurface {
    fn default() -> Self {
        CurveOnSurface::Pcurve(EntityRef::default())
    }
}
impl From<Parameter> for CurveOnSurface {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EntityRef(id) => CurveOnSurface::EntityRef(EntityRef(id)),
                _ => panic!("parameter is not an instance"),
            },
            _ => panic!("parameter is not recognized"),
        }
    }
}
#[derive(Debug)]
pub enum CurveOrAnnotationCurveOccurrence {
    EntityRef(EntityRef),
    Curve(EntityRef),
    AnnotationCurveOccurrence(EntityRef),
}
impl Default for CurveOrAnnotationCurveOccurrence {
    fn default() -> Self {
        CurveOrAnnotationCurveOccurrence::Curve(EntityRef::default())
    }
}
impl From<Parameter> for CurveOrAnnotationCurveOccurrence {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EntityRef(id) => CurveOrAnnotationCurveOccurrence::EntityRef(EntityRef(id)),
                _ => panic!("parameter is not an instance"),
            },
            _ => panic!("parameter is not recognized"),
        }
    }
}
#[derive(Debug)]
pub enum CurveOrRender {
    EntityRef(EntityRef),
    CurveStyle(EntityRef),
    CurveStyleRendering(EntityRef),
}
impl Default for CurveOrRender {
    fn default() -> Self {
        CurveOrRender::CurveStyle(EntityRef::default())
    }
}
impl From<Parameter> for CurveOrRender {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EntityRef(id) => CurveOrRender::EntityRef(EntityRef(id)),
                _ => panic!("parameter is not an instance"),
            },
            _ => panic!("parameter is not recognized"),
        }
    }
}
#[derive(Debug)]
pub enum CurveStyleFontSelect {
    EntityRef(EntityRef),
    CurveStyleFont(EntityRef),
    PreDefinedCurveFont(EntityRef),
    ExternallyDefinedCurveFont(EntityRef),
}
impl Default for CurveStyleFontSelect {
    fn default() -> Self {
        CurveStyleFontSelect::CurveStyleFont(EntityRef::default())
    }
}
impl From<Parameter> for CurveStyleFontSelect {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EntityRef(id) => CurveStyleFontSelect::EntityRef(EntityRef(id)),
                _ => panic!("parameter is not an instance"),
            },
            _ => panic!("parameter is not recognized"),
        }
    }
}
#[derive(Eq, PartialEq, Hash, Debug)]
pub enum DateAndTimeItem {
    EntityRef(EntityRef),
    Action(EntityRef),
    ActionDirective(EntityRef),
    AppliedActionAssignment(EntityRef),
    AppliedOrganizationAssignment(EntityRef),
    AppliedPersonAndOrganizationAssignment(EntityRef),
    AppliedSecurityClassificationAssignment(EntityRef),
    ApprovalPersonOrganization(EntityRef),
    Certification(EntityRef),
    Contract(EntityRef),
    DirectedAction(EntityRef),
    Document(EntityRef),
    DocumentFile(EntityRef),
    EventOccurrence(EntityRef),
    ExecutedAction(EntityRef),
    InformationUsageRight(EntityRef),
    OrganizationalProject(EntityRef),
    ProductDefinition(EntityRef),
    ProductDefinitionFormation(EntityRef),
    ProductDefinitionRelationship(EntityRef),
    RuleAction(EntityRef),
    SecurityClassification(EntityRef),
    VersionedActionRequest(EntityRef),
}
impl Default for DateAndTimeItem {
    fn default() -> Self {
        DateAndTimeItem::Action(EntityRef::default())
    }
}
impl From<Parameter> for DateAndTimeItem {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EntityRef(id) => DateAndTimeItem::EntityRef(EntityRef(id)),
                _ => panic!("parameter is not an instance"),
            },
            _ => panic!("parameter is not recognized"),
        }
    }
}
#[derive(Eq, PartialEq, Hash, Debug)]
pub enum DateItem {
    EntityRef(EntityRef),
    Action(EntityRef),
    ActionDirective(EntityRef),
    AppliedActionAssignment(EntityRef),
    AppliedOrganizationAssignment(EntityRef),
    AppliedPersonAndOrganizationAssignment(EntityRef),
    AppliedSecurityClassificationAssignment(EntityRef),
    ApprovalPersonOrganization(EntityRef),
    Certification(EntityRef),
    Contract(EntityRef),
    DirectedAction(EntityRef),
    Document(EntityRef),
    DocumentFile(EntityRef),
    EventOccurrence(EntityRef),
    ExecutedAction(EntityRef),
    InformationUsageRight(EntityRef),
    OrganizationalProject(EntityRef),
    ProductDefinition(EntityRef),
    ProductDefinitionFormation(EntityRef),
    ProductDefinitionRelationship(EntityRef),
    SecurityClassification(EntityRef),
    VersionedActionRequest(EntityRef),
}
impl Default for DateItem {
    fn default() -> Self {
        DateItem::Action(EntityRef::default())
    }
}
impl From<Parameter> for DateItem {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EntityRef(id) => DateItem::EntityRef(EntityRef(id)),
                _ => panic!("parameter is not an instance"),
            },
            _ => panic!("parameter is not recognized"),
        }
    }
}
#[derive(Eq, PartialEq, Hash, Debug)]
pub enum DateTimeItem {
    EntityRef(EntityRef),
    ApprovalPersonOrganization(EntityRef),
    Certification(EntityRef),
    Change(EntityRef),
    ChangeRequest(EntityRef),
    Contract(EntityRef),
    ProductDefinition(EntityRef),
    SecurityClassification(EntityRef),
    StartRequest(EntityRef),
    StartWork(EntityRef),
}
impl Default for DateTimeItem {
    fn default() -> Self {
        DateTimeItem::ApprovalPersonOrganization(EntityRef::default())
    }
}
impl From<Parameter> for DateTimeItem {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EntityRef(id) => DateTimeItem::EntityRef(EntityRef(id)),
                _ => panic!("parameter is not an instance"),
            },
            _ => panic!("parameter is not recognized"),
        }
    }
}
#[derive(Debug)]
pub enum DateTimeOrEventOccurrence {
    DateTimeSelect(DateTimeSelect),
    EventOccurrence(EntityRef),
}
impl Default for DateTimeOrEventOccurrence {
    fn default() -> Self {
        DateTimeOrEventOccurrence::DateTimeSelect(DateTimeSelect::default())
    }
}
impl From<Parameter> for DateTimeOrEventOccurrence {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::TypedParameter(typed_parameter) => match typed_parameter.type_name.as_str() {
                "DATE_TIME_SELECT" => DateTimeOrEventOccurrence::DateTimeSelect(
                    typed_parameter.parameters.into_iter().next().unwrap().into(),
                ),
                _ => panic!("parameter type is not recognized: {}", typed_parameter.type_name),
            },
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EntityRef(id) => DateTimeOrEventOccurrence::EventOccurrence(EntityRef(id)),
                _ => panic!("parameter is not an instance"),
            },
            _ => panic!("parameter is not recognized"),
        }
    }
}
#[derive(Debug)]
pub enum DateTimeSelect {
    EntityRef(EntityRef),
    Date(EntityRef),
    DateAndTime(EntityRef),
    LocalTime(EntityRef),
}
impl Default for DateTimeSelect {
    fn default() -> Self {
        DateTimeSelect::Date(EntityRef::default())
    }
}
impl From<Parameter> for DateTimeSelect {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EntityRef(id) => DateTimeSelect::EntityRef(EntityRef(id)),
                _ => panic!("parameter is not an instance"),
            },
            _ => panic!("parameter is not recognized"),
        }
    }
}
type DayInMonthNumber = i64;
type DayInWeekNumber = i64;
type DayInYearNumber = i64;
#[derive(Debug)]
pub enum DefinedSymbolSelect {
    EntityRef(EntityRef),
    PreDefinedSymbol(EntityRef),
    ExternallyDefinedSymbol(EntityRef),
}
impl Default for DefinedSymbolSelect {
    fn default() -> Self {
        DefinedSymbolSelect::PreDefinedSymbol(EntityRef::default())
    }
}
impl From<Parameter> for DefinedSymbolSelect {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EntityRef(id) => DefinedSymbolSelect::EntityRef(EntityRef(id)),
                _ => panic!("parameter is not an instance"),
            },
            _ => panic!("parameter is not recognized"),
        }
    }
}
#[derive(Debug)]
pub enum DerivedPropertySelect {
    EntityRef(EntityRef),
    PropertyDefinition(EntityRef),
    ActionProperty(EntityRef),
}
impl Default for DerivedPropertySelect {
    fn default() -> Self {
        DerivedPropertySelect::PropertyDefinition(EntityRef::default())
    }
}
impl From<Parameter> for DerivedPropertySelect {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EntityRef(id) => DerivedPropertySelect::EntityRef(EntityRef(id)),
                _ => panic!("parameter is not an instance"),
            },
            _ => panic!("parameter is not recognized"),
        }
    }
}
#[derive(Debug)]
pub enum DescriptionAttributeSelect {
    EntityRef(EntityRef),
    ActionRequestSolution(EntityRef),
    ApplicationContext(EntityRef),
    ApprovalRole(EntityRef),
    ConfigurationDesign(EntityRef),
    DateRole(EntityRef),
    DateTimeRole(EntityRef),
    ContextDependentShapeRepresentation(EntityRef),
    Effectivity(EntityRef),
    ExternalSource(EntityRef),
    OrganizationRole(EntityRef),
    PersonAndOrganizationRole(EntityRef),
    PersonAndOrganization(EntityRef),
    PropertyDefinitionRepresentation(EntityRef),
    Representation(EntityRef),
}
impl Default for DescriptionAttributeSelect {
    fn default() -> Self {
        DescriptionAttributeSelect::ActionRequestSolution(EntityRef::default())
    }
}
impl From<Parameter> for DescriptionAttributeSelect {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EntityRef(id) => DescriptionAttributeSelect::EntityRef(EntityRef(id)),
                _ => panic!("parameter is not an instance"),
            },
            _ => panic!("parameter is not recognized"),
        }
    }
}
type DescriptiveMeasure = String;
type DesignPdmCertificationItem = PdmCertificationItem;
type DesignPdmClassificationItem = PdmClassificationItem;
type DesignPdmDocumentReferenceItem = PdmDocumentReferenceItem;
type DesignPdmIdentificationItem = EntityRef;
type DesignPdmRequirementAssignedItem = EntityRef;
type DimensionCount = i64;
#[derive(Eq, PartialEq, Hash, Debug)]
pub enum DimensionExtentUsage {
    Origin,
    Target,
}
impl Default for DimensionExtentUsage {
    fn default() -> Self {
        DimensionExtentUsage::Origin
    }
}
impl From<String> for DimensionExtentUsage {
    fn from(value: String) -> Self {
        match value.as_str() {
            "ORIGIN" => DimensionExtentUsage::Origin,
            "TARGET" => DimensionExtentUsage::Target,
            _ => panic!("{} is not a valid value", value),
        }
    }
}
impl From<Parameter> for DimensionExtentUsage {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EnumValue(value) => value.into(),
                _ => panic!("parameter is not an enum value"),
            },
            Parameter::OmittedParameter => DimensionExtentUsage::default(),
            _ => panic!("parameter is not an enum value"),
        }
    }
}
#[derive(Debug)]
pub enum DimensionalCharacteristic {
    EntityRef(EntityRef),
    DimensionalLocation(EntityRef),
    DimensionalSize(EntityRef),
}
impl Default for DimensionalCharacteristic {
    fn default() -> Self {
        DimensionalCharacteristic::DimensionalLocation(EntityRef::default())
    }
}
impl From<Parameter> for DimensionalCharacteristic {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EntityRef(id) => DimensionalCharacteristic::EntityRef(EntityRef(id)),
                _ => panic!("parameter is not an instance"),
            },
            _ => panic!("parameter is not recognized"),
        }
    }
}
#[derive(Eq, PartialEq, Hash, Debug)]
pub enum DirectionCountSelect {
    UDirectionCount(UDirectionCount),
    VDirectionCount(VDirectionCount),
}
impl Default for DirectionCountSelect {
    fn default() -> Self {
        DirectionCountSelect::UDirectionCount(UDirectionCount::default())
    }
}
impl From<Parameter> for DirectionCountSelect {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::TypedParameter(typed_parameter) => match typed_parameter.type_name.as_str() {
                "U_DIRECTION_COUNT" => {
                    DirectionCountSelect::UDirectionCount(typed_parameter.parameters.into_iter().next().unwrap().into())
                }
                "V_DIRECTION_COUNT" => {
                    DirectionCountSelect::VDirectionCount(typed_parameter.parameters.into_iter().next().unwrap().into())
                }
                _ => panic!("parameter type is not recognized: {}", typed_parameter.type_name),
            },
            _ => panic!("parameter is not recognized"),
        }
    }
}
#[derive(Eq, PartialEq, Hash, Debug)]
pub enum DocumentIdentifierAssignedItem {
    Document(EntityRef),
}
impl Default for DocumentIdentifierAssignedItem {
    fn default() -> Self {
        DocumentIdentifierAssignedItem::Document(EntityRef::default())
    }
}
impl From<Parameter> for DocumentIdentifierAssignedItem {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EntityRef(id) => DocumentIdentifierAssignedItem::Document(EntityRef(id)),
                _ => panic!("parameter is not an instance"),
            },
            _ => panic!("parameter is not recognized"),
        }
    }
}
#[derive(Eq, PartialEq, Hash, Debug)]
pub enum DocumentReferenceItem {
    EntityRef(EntityRef),
    ActionMethod(EntityRef),
    AppliedExternalIdentificationAssignment(EntityRef),
    AssemblyComponentUsage(EntityRef),
    CharacterizedClass(EntityRef),
    CharacterizedObject(EntityRef),
    ConfigurationItem(EntityRef),
    DescriptiveRepresentationItem(EntityRef),
    DimensionalSize(EntityRef),
    ExecutedAction(EntityRef),
    ExternallyDefinedDimensionDefinition(EntityRef),
    ExternallyDefinedItem(EntityRef),
    Group(EntityRef),
    GroupRelationship(EntityRef),
    InformationRight(EntityRef),
    InformationUsageRight(EntityRef),
    MaterialDesignation(EntityRef),
    MeasureRepresentationItem(EntityRef),
    Product(EntityRef),
    ProductCategory(EntityRef),
    ProductDefinition(EntityRef),
    ProductDefinitionFormation(EntityRef),
    ProductDefinitionFormationRelationship(EntityRef),
    ProductDefinitionRelationship(EntityRef),
    PropertyDefinition(EntityRef),
    Representation(EntityRef),
    RepresentationItem(EntityRef),
    RuleSet(EntityRef),
    ShapeAspect(EntityRef),
    ShapeAspectRelationship(EntityRef),
    UsageAssociation(EntityRef),
    VersionedActionRequest(EntityRef),
}
impl Default for DocumentReferenceItem {
    fn default() -> Self {
        DocumentReferenceItem::ActionMethod(EntityRef::default())
    }
}
impl From<Parameter> for DocumentReferenceItem {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EntityRef(id) => DocumentReferenceItem::EntityRef(EntityRef(id)),
                _ => panic!("parameter is not an instance"),
            },
            _ => panic!("parameter is not recognized"),
        }
    }
}
type DoseEquivalentMeasure = Real;
#[derive(Eq, PartialEq, Hash, Debug)]
pub enum DraughtingCalloutElement {
    EntityRef(EntityRef),
    AnnotationTextOccurrence(EntityRef),
    AnnotationSymbolOccurrence(EntityRef),
    AnnotationCurveOccurrence(EntityRef),
}
impl Default for DraughtingCalloutElement {
    fn default() -> Self {
        DraughtingCalloutElement::AnnotationTextOccurrence(EntityRef::default())
    }
}
impl From<Parameter> for DraughtingCalloutElement {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EntityRef(id) => DraughtingCalloutElement::EntityRef(EntityRef(id)),
                _ => panic!("parameter is not an instance"),
            },
            _ => panic!("parameter is not recognized"),
        }
    }
}
#[derive(Debug)]
pub enum DraughtingModelItemAssociationSelect {
    EntityRef(EntityRef),
    AnnotationOccurrence(EntityRef),
    DraughtingCallout(EntityRef),
}
impl Default for DraughtingModelItemAssociationSelect {
    fn default() -> Self {
        DraughtingModelItemAssociationSelect::AnnotationOccurrence(EntityRef::default())
    }
}
impl From<Parameter> for DraughtingModelItemAssociationSelect {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EntityRef(id) => DraughtingModelItemAssociationSelect::EntityRef(EntityRef(id)),
                _ => panic!("parameter is not an instance"),
            },
            _ => panic!("parameter is not recognized"),
        }
    }
}
#[derive(Eq, PartialEq, Hash, Debug)]
pub enum DraughtingModelItemSelect {
    EntityRef(EntityRef),
    MappedItem(EntityRef),
    StyledItem(EntityRef),
    Axis2Placement(Axis2Placement),
    CameraModel(EntityRef),
    DraughtingCallout(EntityRef),
}
impl Default for DraughtingModelItemSelect {
    fn default() -> Self {
        DraughtingModelItemSelect::MappedItem(EntityRef::default())
    }
}
impl From<Parameter> for DraughtingModelItemSelect {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::TypedParameter(typed_parameter) => match typed_parameter.type_name.as_str() {
                "AXIS2_PLACEMENT" => DraughtingModelItemSelect::Axis2Placement(
                    typed_parameter.parameters.into_iter().next().unwrap().into(),
                ),
                _ => panic!("parameter type is not recognized: {}", typed_parameter.type_name),
            },
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EntityRef(id) => DraughtingModelItemSelect::EntityRef(EntityRef(id)),
                _ => panic!("parameter is not an instance"),
            },
            _ => panic!("parameter is not recognized"),
        }
    }
}
#[derive(Eq, PartialEq, Hash, Debug)]
pub enum DraughtingTitledItem {
    EntityRef(EntityRef),
    DrawingRevision(EntityRef),
    DrawingSheetRevision(EntityRef),
}
impl Default for DraughtingTitledItem {
    fn default() -> Self {
        DraughtingTitledItem::DrawingRevision(EntityRef::default())
    }
}
impl From<Parameter> for DraughtingTitledItem {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EntityRef(id) => DraughtingTitledItem::EntityRef(EntityRef(id)),
                _ => panic!("parameter is not an instance"),
            },
            _ => panic!("parameter is not recognized"),
        }
    }
}
#[derive(Eq, PartialEq, Hash, Debug)]
pub enum EffectivityItem {
    EntityRef(EntityRef),
    AssemblyComponentUsageSubstitute(EntityRef),
    Product(EntityRef),
    ProductDefinition(EntityRef),
    ProductDefinitionFormation(EntityRef),
    ProductDefinitionRelationship(EntityRef),
    ProductDefinitionSubstitute(EntityRef),
}
impl Default for EffectivityItem {
    fn default() -> Self {
        EffectivityItem::AssemblyComponentUsageSubstitute(EntityRef::default())
    }
}
impl From<Parameter> for EffectivityItem {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EntityRef(id) => EffectivityItem::EntityRef(EntityRef(id)),
                _ => panic!("parameter is not an instance"),
            },
            _ => panic!("parameter is not recognized"),
        }
    }
}
type ElectricChargeMeasure = Real;
type ElectricCurrentMeasure = Real;
type ElectricPotentialMeasure = Real;
type EnergyMeasure = Real;
#[derive(Eq, PartialEq, Hash, Debug)]
pub enum EventOccurrenceItem {
    OrganizationalProject(EntityRef),
}
impl Default for EventOccurrenceItem {
    fn default() -> Self {
        EventOccurrenceItem::OrganizationalProject(EntityRef::default())
    }
}
impl From<Parameter> for EventOccurrenceItem {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EntityRef(id) => EventOccurrenceItem::OrganizationalProject(EntityRef(id)),
                _ => panic!("parameter is not an instance"),
            },
            _ => panic!("parameter is not recognized"),
        }
    }
}
#[derive(Eq, PartialEq, Hash, Debug)]
pub enum ExternalIdentificationItem {
    EntityRef(EntityRef),
    ActionRelationship(EntityRef),
    ActionRequestStatus(EntityRef),
    AppliedOrganizationAssignment(EntityRef),
    AppliedPersonAndOrganizationAssignment(EntityRef),
    Approval(EntityRef),
    ApprovalStatus(EntityRef),
    DateAndTimeAssignment(EntityRef),
    DateAssignment(EntityRef),
    DocumentFile(EntityRef),
    ExternalSource(EntityRef),
    ExternallyDefinedClass(EntityRef),
    ExternallyDefinedContextDependentUnit(EntityRef),
    ExternallyDefinedConversionBasedUnit(EntityRef),
    ExternallyDefinedGeneralProperty(EntityRef),
    ExternallyDefinedPictureRepresentationItem(EntityRef),
    ExternallyDefinedRepresentationItem(EntityRef),
    OrganizationalAddress(EntityRef),
    ProductDefinition(EntityRef),
    SecurityClassification(EntityRef),
    TrimmedCurve(EntityRef),
    VersionedActionRequest(EntityRef),
}
impl Default for ExternalIdentificationItem {
    fn default() -> Self {
        ExternalIdentificationItem::ActionRelationship(EntityRef::default())
    }
}
impl From<Parameter> for ExternalIdentificationItem {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EntityRef(id) => ExternalIdentificationItem::EntityRef(EntityRef(id)),
                _ => panic!("parameter is not an instance"),
            },
            _ => panic!("parameter is not recognized"),
        }
    }
}
#[derive(Eq, PartialEq, Hash, Debug)]
pub enum FillAreaStyleTileShapeSelect {
    EntityRef(EntityRef),
    FillAreaStyleTileCurveWithStyle(EntityRef),
    FillAreaStyleTileColouredRegion(EntityRef),
    FillAreaStyleTileSymbolWithStyle(EntityRef),
    PreDefinedTile(EntityRef),
    ExternallyDefinedTile(EntityRef),
}
impl Default for FillAreaStyleTileShapeSelect {
    fn default() -> Self {
        FillAreaStyleTileShapeSelect::FillAreaStyleTileCurveWithStyle(EntityRef::default())
    }
}
impl From<Parameter> for FillAreaStyleTileShapeSelect {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EntityRef(id) => FillAreaStyleTileShapeSelect::EntityRef(EntityRef(id)),
                _ => panic!("parameter is not an instance"),
            },
            _ => panic!("parameter is not recognized"),
        }
    }
}
#[derive(Eq, PartialEq, Hash, Debug)]
pub enum FillStyleSelect {
    EntityRef(EntityRef),
    FillAreaStyleColour(EntityRef),
    ExternallyDefinedTileStyle(EntityRef),
    FillAreaStyleTiles(EntityRef),
    ExternallyDefinedHatchStyle(EntityRef),
    FillAreaStyleHatching(EntityRef),
}
impl Default for FillStyleSelect {
    fn default() -> Self {
        FillStyleSelect::FillAreaStyleColour(EntityRef::default())
    }
}
impl From<Parameter> for FillStyleSelect {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EntityRef(id) => FillStyleSelect::EntityRef(EntityRef(id)),
                _ => panic!("parameter is not an instance"),
            },
            _ => panic!("parameter is not recognized"),
        }
    }
}
#[derive(Debug)]
pub enum FontSelect {
    EntityRef(EntityRef),
    PreDefinedTextFont(EntityRef),
    ExternallyDefinedTextFont(EntityRef),
    TextFont(EntityRef),
}
impl Default for FontSelect {
    fn default() -> Self {
        FontSelect::PreDefinedTextFont(EntityRef::default())
    }
}
impl From<Parameter> for FontSelect {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EntityRef(id) => FontSelect::EntityRef(EntityRef(id)),
                _ => panic!("parameter is not an instance"),
            },
            _ => panic!("parameter is not recognized"),
        }
    }
}
type ForceMeasure = Real;
#[derive(Debug)]
pub enum FoundedItemSelect {
    EntityRef(EntityRef),
    FoundedItem(EntityRef),
    RepresentationItem(EntityRef),
}
impl Default for FoundedItemSelect {
    fn default() -> Self {
        FoundedItemSelect::FoundedItem(EntityRef::default())
    }
}
impl From<Parameter> for FoundedItemSelect {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EntityRef(id) => FoundedItemSelect::EntityRef(EntityRef(id)),
                _ => panic!("parameter is not an instance"),
            },
            _ => panic!("parameter is not recognized"),
        }
    }
}
type FrequencyMeasure = Real;
#[derive(Debug)]
pub enum GeneralizedSurfaceSelect {
    EntityRef(EntityRef),
    Surface(EntityRef),
    FaceSurface(EntityRef),
    SurfacedOpenShell(EntityRef),
}
impl Default for GeneralizedSurfaceSelect {
    fn default() -> Self {
        GeneralizedSurfaceSelect::Surface(EntityRef::default())
    }
}
impl From<Parameter> for GeneralizedSurfaceSelect {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EntityRef(id) => GeneralizedSurfaceSelect::EntityRef(EntityRef(id)),
                _ => panic!("parameter is not an instance"),
            },
            _ => panic!("parameter is not recognized"),
        }
    }
}
#[derive(Eq, PartialEq, Hash, Debug)]
pub enum GeometricSetSelect {
    EntityRef(EntityRef),
    Point(EntityRef),
    Curve(EntityRef),
    Surface(EntityRef),
}
impl Default for GeometricSetSelect {
    fn default() -> Self {
        GeometricSetSelect::Point(EntityRef::default())
    }
}
impl From<Parameter> for GeometricSetSelect {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EntityRef(id) => GeometricSetSelect::EntityRef(EntityRef(id)),
                _ => panic!("parameter is not an instance"),
            },
            _ => panic!("parameter is not recognized"),
        }
    }
}
#[derive(Eq, PartialEq, Hash, Debug)]
pub enum GroupableItem {
    EntityRef(EntityRef),
    GeometricRepresentationItem(EntityRef),
    GroupRelationship(EntityRef),
    MappedItem(EntityRef),
    PackageProductConceptFeature(EntityRef),
    ProductConceptFeature(EntityRef),
    ProductDefinition(EntityRef),
    ProductDefinitionFormation(EntityRef),
    PropertyDefinitionRepresentation(EntityRef),
    Representation(EntityRef),
    RepresentationItem(EntityRef),
    RepresentationRelationshipWithTransformation(EntityRef),
    ShapeAspect(EntityRef),
    ShapeAspectRelationship(EntityRef),
    ShapeRepresentationRelationship(EntityRef),
    StyledItem(EntityRef),
    TopologicalRepresentationItem(EntityRef),
}
impl Default for GroupableItem {
    fn default() -> Self {
        GroupableItem::GeometricRepresentationItem(EntityRef::default())
    }
}
impl From<Parameter> for GroupableItem {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EntityRef(id) => GroupableItem::EntityRef(EntityRef(id)),
                _ => panic!("parameter is not an instance"),
            },
            _ => panic!("parameter is not recognized"),
        }
    }
}
type HourInDay = i64;
#[derive(Debug)]
pub enum IdAttributeSelect {
    EntityRef(EntityRef),
    Action(EntityRef),
    Address(EntityRef),
    ProductCategory(EntityRef),
    PropertyDefinition(EntityRef),
    ShapeAspect(EntityRef),
    ShapeAspectRelationship(EntityRef),
    ApplicationContext(EntityRef),
    Group(EntityRef),
    OrganizationalProject(EntityRef),
    Representation(EntityRef),
}
impl Default for IdAttributeSelect {
    fn default() -> Self {
        IdAttributeSelect::Action(EntityRef::default())
    }
}
impl From<Parameter> for IdAttributeSelect {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EntityRef(id) => IdAttributeSelect::EntityRef(EntityRef(id)),
                _ => panic!("parameter is not an instance"),
            },
            _ => panic!("parameter is not recognized"),
        }
    }
}
#[derive(Eq, PartialEq, Hash, Debug)]
pub enum IdentificationItem {
    EntityRef(EntityRef),
    ApprovalStatus(EntityRef),
    CharacterizedClass(EntityRef),
    Class(EntityRef),
    ConfigurationItem(EntityRef),
    Contract(EntityRef),
    DimensionalSize(EntityRef),
    DocumentFile(EntityRef),
    GeneralProperty(EntityRef),
    Group(EntityRef),
    GroupRelationship(EntityRef),
    InformationRight(EntityRef),
    InformationUsageRight(EntityRef),
    MaterialDesignation(EntityRef),
    Organization(EntityRef),
    PersonAndOrganization(EntityRef),
    Product(EntityRef),
    ProductCategory(EntityRef),
    ProductClass(EntityRef),
    ProductConcept(EntityRef),
    ProductConceptFeature(EntityRef),
    ProductDefinition(EntityRef),
    ProductDefinitionFormation(EntityRef),
    ProductIdentification(EntityRef),
    Representation(EntityRef),
    RuleSet(EntityRef),
    SecurityClassification(EntityRef),
    SecurityClassificationLevel(EntityRef),
    ShapeAspectRelationship(EntityRef),
    ShapeRepresentation(EntityRef),
    UsageAssociation(EntityRef),
}
impl Default for IdentificationItem {
    fn default() -> Self {
        IdentificationItem::ApprovalStatus(EntityRef::default())
    }
}
impl From<Parameter> for IdentificationItem {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EntityRef(id) => IdentificationItem::EntityRef(EntityRef(id)),
                _ => panic!("parameter is not an instance"),
            },
            _ => panic!("parameter is not recognized"),
        }
    }
}
type Identifier = String;
type IlluminanceMeasure = Real;
type InductanceMeasure = Real;
#[derive(Eq, PartialEq, Hash, Debug)]
pub enum InstanceUsageContextSelect {
    EntityRef(EntityRef),
    ProductDefinitionRelationship(EntityRef),
    ProductDefinitionUsage(EntityRef),
}
impl Default for InstanceUsageContextSelect {
    fn default() -> Self {
        InstanceUsageContextSelect::ProductDefinitionRelationship(EntityRef::default())
    }
}
impl From<Parameter> for InstanceUsageContextSelect {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EntityRef(id) => InstanceUsageContextSelect::EntityRef(EntityRef(id)),
                _ => panic!("parameter is not an instance"),
            },
            _ => panic!("parameter is not recognized"),
        }
    }
}
#[derive(Debug)]
pub enum InvisibilityContext {
    EntityRef(EntityRef),
    PresentationRepresentation(EntityRef),
    PresentationSet(EntityRef),
}
impl Default for InvisibilityContext {
    fn default() -> Self {
        InvisibilityContext::PresentationRepresentation(EntityRef::default())
    }
}
impl From<Parameter> for InvisibilityContext {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EntityRef(id) => InvisibilityContext::EntityRef(EntityRef(id)),
                _ => panic!("parameter is not an instance"),
            },
            _ => panic!("parameter is not recognized"),
        }
    }
}
#[derive(Eq, PartialEq, Hash, Debug)]
pub enum InvisibleItem {
    EntityRef(EntityRef),
    DraughtingCallout(EntityRef),
    PresentationLayerAssignment(EntityRef),
    Representation(EntityRef),
    StyledItem(EntityRef),
}
impl Default for InvisibleItem {
    fn default() -> Self {
        InvisibleItem::DraughtingCallout(EntityRef::default())
    }
}
impl From<Parameter> for InvisibleItem {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EntityRef(id) => InvisibleItem::EntityRef(EntityRef(id)),
                _ => panic!("parameter is not an instance"),
            },
            _ => panic!("parameter is not recognized"),
        }
    }
}
type IrUsageItem = ActionItems;
#[derive(Eq, PartialEq, Hash, Debug)]
pub enum KnotType {
    UniformKnots,
    QuasiUniformKnots,
    PiecewiseBezierKnots,
    Unspecified,
}
impl Default for KnotType {
    fn default() -> Self {
        KnotType::UniformKnots
    }
}
impl From<String> for KnotType {
    fn from(value: String) -> Self {
        match value.as_str() {
            "UNIFORM_KNOTS" => KnotType::UniformKnots,
            "QUASI_UNIFORM_KNOTS" => KnotType::QuasiUniformKnots,
            "PIECEWISE_BEZIER_KNOTS" => KnotType::PiecewiseBezierKnots,
            "UNSPECIFIED" => KnotType::Unspecified,
            _ => panic!("{} is not a valid value", value),
        }
    }
}
impl From<Parameter> for KnotType {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EnumValue(value) => value.into(),
                _ => panic!("parameter is not an enum value"),
            },
            Parameter::OmittedParameter => KnotType::default(),
            _ => panic!("parameter is not an enum value"),
        }
    }
}
type Label = String;
#[derive(Eq, PartialEq, Hash, Debug)]
pub enum LayeredItem {
    EntityRef(EntityRef),
    PresentationRepresentation(EntityRef),
    RepresentationItem(EntityRef),
}
impl Default for LayeredItem {
    fn default() -> Self {
        LayeredItem::PresentationRepresentation(EntityRef::default())
    }
}
impl From<Parameter> for LayeredItem {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EntityRef(id) => LayeredItem::EntityRef(EntityRef(id)),
                _ => panic!("parameter is not an instance"),
            },
            _ => panic!("parameter is not recognized"),
        }
    }
}
type LengthMeasure = Real;
#[derive(Eq, PartialEq, Hash, Debug)]
pub enum LimitCondition {
    MaximumMaterialCondition,
    LeastMaterialCondition,
    RegardlessOfFeatureSize,
}
impl Default for LimitCondition {
    fn default() -> Self {
        LimitCondition::MaximumMaterialCondition
    }
}
impl From<String> for LimitCondition {
    fn from(value: String) -> Self {
        match value.as_str() {
            "MAXIMUM_MATERIAL_CONDITION" => LimitCondition::MaximumMaterialCondition,
            "LEAST_MATERIAL_CONDITION" => LimitCondition::LeastMaterialCondition,
            "REGARDLESS_OF_FEATURE_SIZE" => LimitCondition::RegardlessOfFeatureSize,
            _ => panic!("{} is not a valid value", value),
        }
    }
}
impl From<Parameter> for LimitCondition {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EnumValue(value) => value.into(),
                _ => panic!("parameter is not an enum value"),
            },
            Parameter::OmittedParameter => LimitCondition::default(),
            _ => panic!("parameter is not an enum value"),
        }
    }
}
type ListOfReversibleTopologyItem = Vec<EntityRef>;
type ListRepresentationItem = Vec<EntityRef>;
type LuminousFluxMeasure = Real;
type LuminousIntensityMeasure = Real;
type MagneticFluxDensityMeasure = Real;
type MagneticFluxMeasure = Real;
#[derive(Debug)]
pub enum MarkerSelect {
    MarkerType(MarkerType),
    PreDefinedMarker(EntityRef),
}
impl Default for MarkerSelect {
    fn default() -> Self {
        MarkerSelect::MarkerType(MarkerType::default())
    }
}
impl From<Parameter> for MarkerSelect {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::TypedParameter(typed_parameter) => match typed_parameter.type_name.as_str() {
                "MARKER_TYPE" => {
                    MarkerSelect::MarkerType(typed_parameter.parameters.into_iter().next().unwrap().into())
                }
                _ => panic!("parameter type is not recognized: {}", typed_parameter.type_name),
            },
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EntityRef(id) => MarkerSelect::PreDefinedMarker(EntityRef(id)),
                _ => panic!("parameter is not an instance"),
            },
            _ => panic!("parameter is not recognized"),
        }
    }
}
#[derive(Eq, PartialEq, Hash, Debug)]
pub enum MarkerType {
    Dot,
    X,
    Plus,
    Asterisk,
    Ring,
    Square,
    Triangle,
}
impl Default for MarkerType {
    fn default() -> Self {
        MarkerType::Dot
    }
}
impl From<String> for MarkerType {
    fn from(value: String) -> Self {
        match value.as_str() {
            "DOT" => MarkerType::Dot,
            "X" => MarkerType::X,
            "PLUS" => MarkerType::Plus,
            "ASTERISK" => MarkerType::Asterisk,
            "RING" => MarkerType::Ring,
            "SQUARE" => MarkerType::Square,
            "TRIANGLE" => MarkerType::Triangle,
            _ => panic!("{} is not a valid value", value),
        }
    }
}
impl From<Parameter> for MarkerType {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EnumValue(value) => value.into(),
                _ => panic!("parameter is not an enum value"),
            },
            Parameter::OmittedParameter => MarkerType::default(),
            _ => panic!("parameter is not an enum value"),
        }
    }
}
type MassMeasure = Real;
#[derive(Debug)]
pub enum MeasureValue {
    AbsorbedDoseMeasure(AbsorbedDoseMeasure),
    DoseEquivalentMeasure(DoseEquivalentMeasure),
    RadioactivityMeasure(RadioactivityMeasure),
    AccelerationMeasure(AccelerationMeasure),
    AmountOfSubstanceMeasure(AmountOfSubstanceMeasure),
    AreaMeasure(AreaMeasure),
    CelsiusTemperatureMeasure(CelsiusTemperatureMeasure),
    ContextDependentMeasure(ContextDependentMeasure),
    CountMeasure(CountMeasure),
    DescriptiveMeasure(DescriptiveMeasure),
    CapacitanceMeasure(CapacitanceMeasure),
    ElectricChargeMeasure(ElectricChargeMeasure),
    ConductanceMeasure(ConductanceMeasure),
    ElectricCurrentMeasure(ElectricCurrentMeasure),
    ElectricPotentialMeasure(ElectricPotentialMeasure),
    EnergyMeasure(EnergyMeasure),
    MagneticFluxDensityMeasure(MagneticFluxDensityMeasure),
    ForceMeasure(ForceMeasure),
    FrequencyMeasure(FrequencyMeasure),
    IlluminanceMeasure(IlluminanceMeasure),
    InductanceMeasure(InductanceMeasure),
    LengthMeasure(LengthMeasure),
    LuminousFluxMeasure(LuminousFluxMeasure),
    LuminousIntensityMeasure(LuminousIntensityMeasure),
    MagneticFluxMeasure(MagneticFluxMeasure),
    MassMeasure(MassMeasure),
    NumericMeasure(NumericMeasure),
    NonNegativeLengthMeasure(NonNegativeLengthMeasure),
    ParameterValue(ParameterValue),
    PlaneAngleMeasure(PlaneAngleMeasure),
    PositiveLengthMeasure(PositiveLengthMeasure),
    PositivePlaneAngleMeasure(PositivePlaneAngleMeasure),
    PositiveRatioMeasure(PositiveRatioMeasure),
    PowerMeasure(PowerMeasure),
    PressureMeasure(PressureMeasure),
    RatioMeasure(RatioMeasure),
    ResistanceMeasure(ResistanceMeasure),
    SolidAngleMeasure(SolidAngleMeasure),
    ThermodynamicTemperatureMeasure(ThermodynamicTemperatureMeasure),
    TimeMeasure(TimeMeasure),
    VelocityMeasure(VelocityMeasure),
    VolumeMeasure(VolumeMeasure),
}
impl Default for MeasureValue {
    fn default() -> Self {
        MeasureValue::AbsorbedDoseMeasure(AbsorbedDoseMeasure::default())
    }
}
impl From<Parameter> for MeasureValue {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::TypedParameter(typed_parameter) => match typed_parameter.type_name.as_str() {
                "ABSORBED_DOSE_MEASURE" => {
                    MeasureValue::AbsorbedDoseMeasure(typed_parameter.parameters.into_iter().next().unwrap().into())
                }
                "DOSE_EQUIVALENT_MEASURE" => {
                    MeasureValue::DoseEquivalentMeasure(typed_parameter.parameters.into_iter().next().unwrap().into())
                }
                "RADIOACTIVITY_MEASURE" => {
                    MeasureValue::RadioactivityMeasure(typed_parameter.parameters.into_iter().next().unwrap().into())
                }
                "ACCELERATION_MEASURE" => {
                    MeasureValue::AccelerationMeasure(typed_parameter.parameters.into_iter().next().unwrap().into())
                }
                "AMOUNT_OF_SUBSTANCE_MEASURE" => MeasureValue::AmountOfSubstanceMeasure(
                    typed_parameter.parameters.into_iter().next().unwrap().into(),
                ),
                "AREA_MEASURE" => {
                    MeasureValue::AreaMeasure(typed_parameter.parameters.into_iter().next().unwrap().into())
                }
                "CELSIUS_TEMPERATURE_MEASURE" => MeasureValue::CelsiusTemperatureMeasure(
                    typed_parameter.parameters.into_iter().next().unwrap().into(),
                ),
                "CONTEXT_DEPENDENT_MEASURE" => {
                    MeasureValue::ContextDependentMeasure(typed_parameter.parameters.into_iter().next().unwrap().into())
                }
                "COUNT_MEASURE" => {
                    MeasureValue::CountMeasure(typed_parameter.parameters.into_iter().next().unwrap().into())
                }
                "DESCRIPTIVE_MEASURE" => {
                    MeasureValue::DescriptiveMeasure(typed_parameter.parameters.into_iter().next().unwrap().into())
                }
                "CAPACITANCE_MEASURE" => {
                    MeasureValue::CapacitanceMeasure(typed_parameter.parameters.into_iter().next().unwrap().into())
                }
                "ELECTRIC_CHARGE_MEASURE" => {
                    MeasureValue::ElectricChargeMeasure(typed_parameter.parameters.into_iter().next().unwrap().into())
                }
                "CONDUCTANCE_MEASURE" => {
                    MeasureValue::ConductanceMeasure(typed_parameter.parameters.into_iter().next().unwrap().into())
                }
                "ELECTRIC_CURRENT_MEASURE" => {
                    MeasureValue::ElectricCurrentMeasure(typed_parameter.parameters.into_iter().next().unwrap().into())
                }
                "ELECTRIC_POTENTIAL_MEASURE" => MeasureValue::ElectricPotentialMeasure(
                    typed_parameter.parameters.into_iter().next().unwrap().into(),
                ),
                "ENERGY_MEASURE" => {
                    MeasureValue::EnergyMeasure(typed_parameter.parameters.into_iter().next().unwrap().into())
                }
                "MAGNETIC_FLUX_DENSITY_MEASURE" => MeasureValue::MagneticFluxDensityMeasure(
                    typed_parameter.parameters.into_iter().next().unwrap().into(),
                ),
                "FORCE_MEASURE" => {
                    MeasureValue::ForceMeasure(typed_parameter.parameters.into_iter().next().unwrap().into())
                }
                "FREQUENCY_MEASURE" => {
                    MeasureValue::FrequencyMeasure(typed_parameter.parameters.into_iter().next().unwrap().into())
                }
                "ILLUMINANCE_MEASURE" => {
                    MeasureValue::IlluminanceMeasure(typed_parameter.parameters.into_iter().next().unwrap().into())
                }
                "INDUCTANCE_MEASURE" => {
                    MeasureValue::InductanceMeasure(typed_parameter.parameters.into_iter().next().unwrap().into())
                }
                "LENGTH_MEASURE" => {
                    MeasureValue::LengthMeasure(typed_parameter.parameters.into_iter().next().unwrap().into())
                }
                "LUMINOUS_FLUX_MEASURE" => {
                    MeasureValue::LuminousFluxMeasure(typed_parameter.parameters.into_iter().next().unwrap().into())
                }
                "LUMINOUS_INTENSITY_MEASURE" => MeasureValue::LuminousIntensityMeasure(
                    typed_parameter.parameters.into_iter().next().unwrap().into(),
                ),
                "MAGNETIC_FLUX_MEASURE" => {
                    MeasureValue::MagneticFluxMeasure(typed_parameter.parameters.into_iter().next().unwrap().into())
                }
                "MASS_MEASURE" => {
                    MeasureValue::MassMeasure(typed_parameter.parameters.into_iter().next().unwrap().into())
                }
                "NUMERIC_MEASURE" => {
                    MeasureValue::NumericMeasure(typed_parameter.parameters.into_iter().next().unwrap().into())
                }
                "NON_NEGATIVE_LENGTH_MEASURE" => MeasureValue::NonNegativeLengthMeasure(
                    typed_parameter.parameters.into_iter().next().unwrap().into(),
                ),
                "PARAMETER_VALUE" => {
                    MeasureValue::ParameterValue(typed_parameter.parameters.into_iter().next().unwrap().into())
                }
                "PLANE_ANGLE_MEASURE" => {
                    MeasureValue::PlaneAngleMeasure(typed_parameter.parameters.into_iter().next().unwrap().into())
                }
                "POSITIVE_LENGTH_MEASURE" => {
                    MeasureValue::PositiveLengthMeasure(typed_parameter.parameters.into_iter().next().unwrap().into())
                }
                "POSITIVE_PLANE_ANGLE_MEASURE" => MeasureValue::PositivePlaneAngleMeasure(
                    typed_parameter.parameters.into_iter().next().unwrap().into(),
                ),
                "POSITIVE_RATIO_MEASURE" => {
                    MeasureValue::PositiveRatioMeasure(typed_parameter.parameters.into_iter().next().unwrap().into())
                }
                "POWER_MEASURE" => {
                    MeasureValue::PowerMeasure(typed_parameter.parameters.into_iter().next().unwrap().into())
                }
                "PRESSURE_MEASURE" => {
                    MeasureValue::PressureMeasure(typed_parameter.parameters.into_iter().next().unwrap().into())
                }
                "RATIO_MEASURE" => {
                    MeasureValue::RatioMeasure(typed_parameter.parameters.into_iter().next().unwrap().into())
                }
                "RESISTANCE_MEASURE" => {
                    MeasureValue::ResistanceMeasure(typed_parameter.parameters.into_iter().next().unwrap().into())
                }
                "SOLID_ANGLE_MEASURE" => {
                    MeasureValue::SolidAngleMeasure(typed_parameter.parameters.into_iter().next().unwrap().into())
                }
                "THERMODYNAMIC_TEMPERATURE_MEASURE" => MeasureValue::ThermodynamicTemperatureMeasure(
                    typed_parameter.parameters.into_iter().next().unwrap().into(),
                ),
                "TIME_MEASURE" => {
                    MeasureValue::TimeMeasure(typed_parameter.parameters.into_iter().next().unwrap().into())
                }
                "VELOCITY_MEASURE" => {
                    MeasureValue::VelocityMeasure(typed_parameter.parameters.into_iter().next().unwrap().into())
                }
                "VOLUME_MEASURE" => {
                    MeasureValue::VolumeMeasure(typed_parameter.parameters.into_iter().next().unwrap().into())
                }
                _ => panic!("parameter type is not recognized: {}", typed_parameter.type_name),
            },
            _ => panic!("parameter is not recognized"),
        }
    }
}
#[derive(Debug)]
pub enum MechanicalDesignAndDraughtingRelationshipSelect {
    EntityRef(EntityRef),
    DraughtingModel(EntityRef),
    MechanicalDesignGeometricPresentationRepresentation(EntityRef),
    MechanicalDesignPresentationRepresentationWithDraughting(EntityRef),
    MechanicalDesignShadedPresentationRepresentation(EntityRef),
    ShapeRepresentation(EntityRef),
}
impl Default for MechanicalDesignAndDraughtingRelationshipSelect {
    fn default() -> Self {
        MechanicalDesignAndDraughtingRelationshipSelect::DraughtingModel(EntityRef::default())
    }
}
impl From<Parameter> for MechanicalDesignAndDraughtingRelationshipSelect {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EntityRef(id) => {
                    MechanicalDesignAndDraughtingRelationshipSelect::EntityRef(EntityRef(id))
                }
                _ => panic!("parameter is not an instance"),
            },
            _ => panic!("parameter is not recognized"),
        }
    }
}
#[derive(Eq, PartialEq, Hash, Debug)]
pub enum MechanicalDesignGeometricPresentationAreaItems {
    Axis2Placement(Axis2Placement),
    MappedItem(EntityRef),
}
impl Default for MechanicalDesignGeometricPresentationAreaItems {
    fn default() -> Self {
        MechanicalDesignGeometricPresentationAreaItems::Axis2Placement(Axis2Placement::default())
    }
}
impl From<Parameter> for MechanicalDesignGeometricPresentationAreaItems {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::TypedParameter(typed_parameter) => match typed_parameter.type_name.as_str() {
                "AXIS2_PLACEMENT" => MechanicalDesignGeometricPresentationAreaItems::Axis2Placement(
                    typed_parameter.parameters.into_iter().next().unwrap().into(),
                ),
                _ => panic!("parameter type is not recognized: {}", typed_parameter.type_name),
            },
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EntityRef(id) => {
                    MechanicalDesignGeometricPresentationAreaItems::MappedItem(EntityRef(id))
                }
                _ => panic!("parameter is not an instance"),
            },
            _ => panic!("parameter is not recognized"),
        }
    }
}
#[derive(Eq, PartialEq, Hash, Debug)]
pub enum MechanicalDesignGeometricPresentationRepresentationItems {
    EntityRef(EntityRef),
    Axis2Placement(Axis2Placement),
    CameraModelD3(EntityRef),
    MappedItem(EntityRef),
    StyledItem(EntityRef),
}
impl Default for MechanicalDesignGeometricPresentationRepresentationItems {
    fn default() -> Self {
        MechanicalDesignGeometricPresentationRepresentationItems::Axis2Placement(Axis2Placement::default())
    }
}
impl From<Parameter> for MechanicalDesignGeometricPresentationRepresentationItems {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::TypedParameter(typed_parameter) => match typed_parameter.type_name.as_str() {
                "AXIS2_PLACEMENT" => MechanicalDesignGeometricPresentationRepresentationItems::Axis2Placement(
                    typed_parameter.parameters.into_iter().next().unwrap().into(),
                ),
                _ => panic!("parameter type is not recognized: {}", typed_parameter.type_name),
            },
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EntityRef(id) => {
                    MechanicalDesignGeometricPresentationRepresentationItems::EntityRef(EntityRef(id))
                }
                _ => panic!("parameter is not an instance"),
            },
            _ => panic!("parameter is not recognized"),
        }
    }
}
type Message = String;
type MinuteInHour = i64;
type MonthInYearNumber = i64;
#[derive(Eq, PartialEq, Hash, Debug)]
pub enum MultiLanguageAttributeItem {
    EntityRef(EntityRef),
    AlternateProductRelationship(EntityRef),
    ApplicationContext(EntityRef),
    AppliedCertificationAssignment(EntityRef),
    AppliedDocumentReference(EntityRef),
    AppliedDocumentUsageConstraintAssignment(EntityRef),
    AppliedExternalIdentificationAssignment(EntityRef),
    AppliedIdentificationAssignment(EntityRef),
    AppliedOrganizationalProjectAssignment(EntityRef),
    Approval(EntityRef),
    ApprovalRelationship(EntityRef),
    ApprovalStatus(EntityRef),
    AssemblyComponentUsageSubstitute(EntityRef),
    AttributeValueAssignment(EntityRef),
    Certification(EntityRef),
    CertificationType(EntityRef),
    Colour(EntityRef),
    ConfigurationDesign(EntityRef),
    ConfigurationItem(EntityRef),
    Contract(EntityRef),
    DateRole(EntityRef),
    DateTimeRole(EntityRef),
    DescriptiveRepresentationItem(EntityRef),
    DocumentRelationship(EntityRef),
    DocumentUsageRole(EntityRef),
    Effectivity(EntityRef),
    EffectivityRelationship(EntityRef),
    EventOccurrence(EntityRef),
    ExternalSource(EntityRef),
    GeneralProperty(EntityRef),
    GeneralPropertyRelationship(EntityRef),
    GeometricRepresentationItem(EntityRef),
    GeometricTolerance(EntityRef),
    IdentificationRole(EntityRef),
    InformationRight(EntityRef),
    InformationUsageRight(EntityRef),
    MakeFromUsageOption(EntityRef),
    MappedItem(EntityRef),
    ObjectRole(EntityRef),
    OrganizationRelationship(EntityRef),
    OrganizationRole(EntityRef),
    OrganizationalProject(EntityRef),
    OrganizationalProjectRelationship(EntityRef),
    OrganizationalProjectRole(EntityRef),
    PersonAndOrganization(EntityRef),
    PersonAndOrganizationRole(EntityRef),
    Product(EntityRef),
    ProductCategory(EntityRef),
    ProductConcept(EntityRef),
    ProductConceptRelationship(EntityRef),
    ProductDefinition(EntityRef),
    ProductDefinitionContext(EntityRef),
    ProductDefinitionFormation(EntityRef),
    ProductDefinitionFormationRelationship(EntityRef),
    ProductDefinitionRelationship(EntityRef),
    ProductDefinitionShape(EntityRef),
    ProductRelatedProductCategory(EntityRef),
    PropertyDefinition(EntityRef),
    Representation(EntityRef),
    RepresentationRelationship(EntityRef),
    SecurityClassification(EntityRef),
    SecurityClassificationAssignment(EntityRef),
    ShapeAspect(EntityRef),
    ShapeAspectRelationship(EntityRef),
    ShapeRepresentation(EntityRef),
    TimeIntervalRole(EntityRef),
    TopologicalRepresentationItem(EntityRef),
    UncertaintyMeasureWithUnit(EntityRef),
    UsageAssociation(EntityRef),
}
impl Default for MultiLanguageAttributeItem {
    fn default() -> Self {
        MultiLanguageAttributeItem::AlternateProductRelationship(EntityRef::default())
    }
}
impl From<Parameter> for MultiLanguageAttributeItem {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EntityRef(id) => MultiLanguageAttributeItem::EntityRef(EntityRef(id)),
                _ => panic!("parameter is not an instance"),
            },
            _ => panic!("parameter is not recognized"),
        }
    }
}
#[derive(Debug)]
pub enum NameAttributeSelect {
    EntityRef(EntityRef),
    ActionRequestSolution(EntityRef),
    Address(EntityRef),
    ConfigurationDesign(EntityRef),
    ContextDependentShapeRepresentation(EntityRef),
    DerivedUnit(EntityRef),
    Effectivity(EntityRef),
    PersonAndOrganization(EntityRef),
    ProductDefinition(EntityRef),
    ProductDefinitionSubstitute(EntityRef),
    PropertyDefinitionRepresentation(EntityRef),
}
impl Default for NameAttributeSelect {
    fn default() -> Self {
        NameAttributeSelect::ActionRequestSolution(EntityRef::default())
    }
}
impl From<Parameter> for NameAttributeSelect {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EntityRef(id) => NameAttributeSelect::EntityRef(EntityRef(id)),
                _ => panic!("parameter is not an instance"),
            },
            _ => panic!("parameter is not recognized"),
        }
    }
}
#[derive(Debug)]
pub enum NameItem {
    EntityRef(EntityRef),
    AssemblyComponentUsage(EntityRef),
    ExternalClassLibrary(EntityRef),
    Group(EntityRef),
    GroupRelationship(EntityRef),
    Product(EntityRef),
    ProductDefinition(EntityRef),
}
impl Default for NameItem {
    fn default() -> Self {
        NameItem::AssemblyComponentUsage(EntityRef::default())
    }
}
impl From<Parameter> for NameItem {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EntityRef(id) => NameItem::EntityRef(EntityRef(id)),
                _ => panic!("parameter is not an instance"),
            },
            _ => panic!("parameter is not recognized"),
        }
    }
}
type NonNegativeLengthMeasure = LengthMeasure;
type NonnegativeInteger = i64;
#[derive(Eq, PartialEq, Hash, Debug)]
pub enum NullStyle {
    Null,
}
impl Default for NullStyle {
    fn default() -> Self {
        NullStyle::Null
    }
}
impl From<String> for NullStyle {
    fn from(value: String) -> Self {
        match value.as_str() {
            "NULL" => NullStyle::Null,
            _ => panic!("{} is not a valid value", value),
        }
    }
}
impl From<Parameter> for NullStyle {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EnumValue(value) => value.into(),
                _ => panic!("parameter is not an enum value"),
            },
            Parameter::OmittedParameter => NullStyle::default(),
            _ => panic!("parameter is not an enum value"),
        }
    }
}
type NumericMeasure = Real;
#[derive(Eq, PartialEq, Hash, Debug)]
pub enum OrganizationItem {
    EntityRef(EntityRef),
    Action(EntityRef),
    ActionDirective(EntityRef),
    AlternateProductRelationship(EntityRef),
    AppliedActionAssignment(EntityRef),
    AppliedClassificationAssignment(EntityRef),
    AppliedIdentificationAssignment(EntityRef),
    AppliedSecurityClassificationAssignment(EntityRef),
    Approval(EntityRef),
    AssemblyComponentUsageSubstitute(EntityRef),
    Certification(EntityRef),
    Class(EntityRef),
    ConfigurationItem(EntityRef),
    Contract(EntityRef),
    DocumentFile(EntityRef),
    ExecutedAction(EntityRef),
    GeneralProperty(EntityRef),
    InformationUsageRight(EntityRef),
    OrganizationalProject(EntityRef),
    Product(EntityRef),
    ProductDefinition(EntityRef),
    ProductDefinitionFormation(EntityRef),
    ProductDefinitionFormationRelationship(EntityRef),
    PropertyDefinition(EntityRef),
    RuleAction(EntityRef),
    SecurityClassification(EntityRef),
    ShapeRepresentation(EntityRef),
    VersionedActionRequest(EntityRef),
}
impl Default for OrganizationItem {
    fn default() -> Self {
        OrganizationItem::Action(EntityRef::default())
    }
}
impl From<Parameter> for OrganizationItem {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EntityRef(id) => OrganizationItem::EntityRef(EntityRef(id)),
                _ => panic!("parameter is not an instance"),
            },
            _ => panic!("parameter is not recognized"),
        }
    }
}
#[derive(Debug)]
pub enum OrientationBasisSelect {
    EntityRef(EntityRef),
    Axis2Placement3d(EntityRef),
    MinAndMajorPlyOrientationBasis(EntityRef),
}
impl Default for OrientationBasisSelect {
    fn default() -> Self {
        OrientationBasisSelect::Axis2Placement3d(EntityRef::default())
    }
}
impl From<Parameter> for OrientationBasisSelect {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EntityRef(id) => OrientationBasisSelect::EntityRef(EntityRef(id)),
                _ => panic!("parameter is not an instance"),
            },
            _ => panic!("parameter is not recognized"),
        }
    }
}
type ParameterValue = Real;
#[derive(Debug)]
pub enum PcurveOrSurface {
    EntityRef(EntityRef),
    Pcurve(EntityRef),
    Surface(EntityRef),
}
impl Default for PcurveOrSurface {
    fn default() -> Self {
        PcurveOrSurface::Pcurve(EntityRef::default())
    }
}
impl From<Parameter> for PcurveOrSurface {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EntityRef(id) => PcurveOrSurface::EntityRef(EntityRef(id)),
                _ => panic!("parameter is not an instance"),
            },
            _ => panic!("parameter is not recognized"),
        }
    }
}
type PdmCertificationItem = EntityRef;
type PdmClassificationItem = EntityRef;
type PdmDocumentReferenceItem = EntityRef;
#[derive(Eq, PartialEq, Hash, Debug)]
pub enum PersonAndOrganizationItem {
    EntityRef(EntityRef),
    Action(EntityRef),
    ActionDirective(EntityRef),
    AlternateProductRelationship(EntityRef),
    AppliedActionAssignment(EntityRef),
    AppliedClassificationAssignment(EntityRef),
    AppliedIdentificationAssignment(EntityRef),
    AppliedSecurityClassificationAssignment(EntityRef),
    Approval(EntityRef),
    AssemblyComponentUsageSubstitute(EntityRef),
    Certification(EntityRef),
    ConfigurationItem(EntityRef),
    Contract(EntityRef),
    DocumentFile(EntityRef),
    ExecutedAction(EntityRef),
    GeneralProperty(EntityRef),
    InformationUsageRight(EntityRef),
    OrganizationalProject(EntityRef),
    PersonAndOrganization(EntityRef),
    Product(EntityRef),
    ProductDefinition(EntityRef),
    ProductDefinitionFormation(EntityRef),
    ProductDefinitionFormationRelationship(EntityRef),
    PropertyDefinition(EntityRef),
    RuleAction(EntityRef),
    SecurityClassification(EntityRef),
    ShapeRepresentation(EntityRef),
    VersionedActionRequest(EntityRef),
}
impl Default for PersonAndOrganizationItem {
    fn default() -> Self {
        PersonAndOrganizationItem::Action(EntityRef::default())
    }
}
impl From<Parameter> for PersonAndOrganizationItem {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EntityRef(id) => PersonAndOrganizationItem::EntityRef(EntityRef(id)),
                _ => panic!("parameter is not an instance"),
            },
            _ => panic!("parameter is not recognized"),
        }
    }
}
#[derive(Debug)]
pub enum PersonOrganizationSelect {
    EntityRef(EntityRef),
    Person(EntityRef),
    Organization(EntityRef),
    PersonAndOrganization(EntityRef),
}
impl Default for PersonOrganizationSelect {
    fn default() -> Self {
        PersonOrganizationSelect::Person(EntityRef::default())
    }
}
impl From<Parameter> for PersonOrganizationSelect {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EntityRef(id) => PersonOrganizationSelect::EntityRef(EntityRef(id)),
                _ => panic!("parameter is not an instance"),
            },
            _ => panic!("parameter is not recognized"),
        }
    }
}
#[derive(Eq, PartialEq, Hash, Debug)]
pub enum PictureRepresentationItemSelect {
    EntityRef(EntityRef),
    StyledItem(EntityRef),
    PictureRepresentationItem(EntityRef),
    PlanarBox(EntityRef),
    Axis2Placement2d(EntityRef),
}
impl Default for PictureRepresentationItemSelect {
    fn default() -> Self {
        PictureRepresentationItemSelect::StyledItem(EntityRef::default())
    }
}
impl From<Parameter> for PictureRepresentationItemSelect {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EntityRef(id) => PictureRepresentationItemSelect::EntityRef(EntityRef(id)),
                _ => panic!("parameter is not an instance"),
            },
            _ => panic!("parameter is not recognized"),
        }
    }
}
type PlaneAngleMeasure = Real;
#[derive(Debug)]
pub enum PlaneOrPlanarBox {
    EntityRef(EntityRef),
    Plane(EntityRef),
    PlanarBox(EntityRef),
}
impl Default for PlaneOrPlanarBox {
    fn default() -> Self {
        PlaneOrPlanarBox::Plane(EntityRef::default())
    }
}
impl From<Parameter> for PlaneOrPlanarBox {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EntityRef(id) => PlaneOrPlanarBox::EntityRef(EntityRef(id)),
                _ => panic!("parameter is not an instance"),
            },
            _ => panic!("parameter is not recognized"),
        }
    }
}
#[derive(Debug)]
pub enum PointAndVectorMember {
    EntityRef(EntityRef),
    Point(EntityRef),
    Direction(EntityRef),
}
impl Default for PointAndVectorMember {
    fn default() -> Self {
        PointAndVectorMember::Point(EntityRef::default())
    }
}
impl From<Parameter> for PointAndVectorMember {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EntityRef(id) => PointAndVectorMember::EntityRef(EntityRef(id)),
                _ => panic!("parameter is not an instance"),
            },
            _ => panic!("parameter is not recognized"),
        }
    }
}
type PointAndVectorMembers = Vec<EntityRef>;
type PointPathMembers = Vec<EntityRef>;
type PositiveInteger = NonnegativeInteger;
type PositiveLengthMeasure = NonNegativeLengthMeasure;
type PositivePlaneAngleMeasure = PlaneAngleMeasure;
type PositiveRatioMeasure = RatioMeasure;
type PowerMeasure = Real;
#[derive(Eq, PartialEq, Hash, Debug)]
pub enum PreferredSurfaceCurveRepresentation {
    Curve3d,
    PcurveS1,
    PcurveS2,
}
impl Default for PreferredSurfaceCurveRepresentation {
    fn default() -> Self {
        PreferredSurfaceCurveRepresentation::Curve3d
    }
}
impl From<String> for PreferredSurfaceCurveRepresentation {
    fn from(value: String) -> Self {
        match value.as_str() {
            "CURVE_3D" => PreferredSurfaceCurveRepresentation::Curve3d,
            "PCURVE_S1" => PreferredSurfaceCurveRepresentation::PcurveS1,
            "PCURVE_S2" => PreferredSurfaceCurveRepresentation::PcurveS2,
            _ => panic!("{} is not a valid value", value),
        }
    }
}
impl From<Parameter> for PreferredSurfaceCurveRepresentation {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EnumValue(value) => value.into(),
                _ => panic!("parameter is not an enum value"),
            },
            Parameter::OmittedParameter => PreferredSurfaceCurveRepresentation::default(),
            _ => panic!("parameter is not an enum value"),
        }
    }
}
type PresentableText = String;
#[derive(Debug)]
pub enum PresentationRepresentationSelect {
    EntityRef(EntityRef),
    PresentationRepresentation(EntityRef),
    PresentationSet(EntityRef),
}
impl Default for PresentationRepresentationSelect {
    fn default() -> Self {
        PresentationRepresentationSelect::PresentationRepresentation(EntityRef::default())
    }
}
impl From<Parameter> for PresentationRepresentationSelect {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EntityRef(id) => PresentationRepresentationSelect::EntityRef(EntityRef(id)),
                _ => panic!("parameter is not an instance"),
            },
            _ => panic!("parameter is not recognized"),
        }
    }
}
#[derive(Debug)]
pub enum PresentationSizeAssignmentSelect {
    EntityRef(EntityRef),
    PresentationView(EntityRef),
    PresentationArea(EntityRef),
    AreaInSet(EntityRef),
}
impl Default for PresentationSizeAssignmentSelect {
    fn default() -> Self {
        PresentationSizeAssignmentSelect::PresentationView(EntityRef::default())
    }
}
impl From<Parameter> for PresentationSizeAssignmentSelect {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EntityRef(id) => PresentationSizeAssignmentSelect::EntityRef(EntityRef(id)),
                _ => panic!("parameter is not an instance"),
            },
            _ => panic!("parameter is not recognized"),
        }
    }
}
#[derive(Eq, PartialEq, Hash, Debug)]
pub enum PresentationStyleSelect {
    EntityRef(EntityRef),
    PointStyle(EntityRef),
    CurveStyle(EntityRef),
    SurfaceStyleUsage(EntityRef),
    SymbolStyle(EntityRef),
    FillAreaStyle(EntityRef),
    TextStyle(EntityRef),
    NullStyle(NullStyle),
}
impl Default for PresentationStyleSelect {
    fn default() -> Self {
        PresentationStyleSelect::PointStyle(EntityRef::default())
    }
}
impl From<Parameter> for PresentationStyleSelect {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::TypedParameter(typed_parameter) => match typed_parameter.type_name.as_str() {
                "NULL_STYLE" => {
                    PresentationStyleSelect::NullStyle(typed_parameter.parameters.into_iter().next().unwrap().into())
                }
                _ => panic!("parameter type is not recognized: {}", typed_parameter.type_name),
            },
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EntityRef(id) => PresentationStyleSelect::EntityRef(EntityRef(id)),
                _ => panic!("parameter is not an instance"),
            },
            _ => panic!("parameter is not recognized"),
        }
    }
}
#[derive(Eq, PartialEq, Hash, Debug)]
pub enum PresentedItemSelect {
    EntityRef(EntityRef),
    Action(EntityRef),
    ActionMethod(EntityRef),
    ActionRelationship(EntityRef),
    ProductConcept(EntityRef),
    ProductConceptFeature(EntityRef),
    ProductConceptFeatureCategory(EntityRef),
    ProductDefinition(EntityRef),
    ProductDefinitionFormation(EntityRef),
    ProductDefinitionRelationship(EntityRef),
}
impl Default for PresentedItemSelect {
    fn default() -> Self {
        PresentedItemSelect::Action(EntityRef::default())
    }
}
impl From<Parameter> for PresentedItemSelect {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EntityRef(id) => PresentedItemSelect::EntityRef(EntityRef(id)),
                _ => panic!("parameter is not an instance"),
            },
            _ => panic!("parameter is not recognized"),
        }
    }
}
type PressureMeasure = Real;
#[derive(Debug)]
pub enum ProductDefinitionOrAssemblyRelationship {
    EntityRef(EntityRef),
    AssemblyComponentUsage(EntityRef),
    ProductDefinition(EntityRef),
}
impl Default for ProductDefinitionOrAssemblyRelationship {
    fn default() -> Self {
        ProductDefinitionOrAssemblyRelationship::AssemblyComponentUsage(EntityRef::default())
    }
}
impl From<Parameter> for ProductDefinitionOrAssemblyRelationship {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EntityRef(id) => ProductDefinitionOrAssemblyRelationship::EntityRef(EntityRef(id)),
                _ => panic!("parameter is not an instance"),
            },
            _ => panic!("parameter is not recognized"),
        }
    }
}
#[derive(Eq, PartialEq, Hash, Debug)]
pub enum ProductDefinitionOrBreakdownElementUsage {
    EntityRef(EntityRef),
    ProductDefinition(EntityRef),
    ProductDefinitionUsage(EntityRef),
}
impl Default for ProductDefinitionOrBreakdownElementUsage {
    fn default() -> Self {
        ProductDefinitionOrBreakdownElementUsage::ProductDefinition(EntityRef::default())
    }
}
impl From<Parameter> for ProductDefinitionOrBreakdownElementUsage {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EntityRef(id) => ProductDefinitionOrBreakdownElementUsage::EntityRef(EntityRef(id)),
                _ => panic!("parameter is not an instance"),
            },
            _ => panic!("parameter is not recognized"),
        }
    }
}
#[derive(Eq, PartialEq, Hash, Debug)]
pub enum ProductDefinitionOrProductDefinitionRelationship {
    EntityRef(EntityRef),
    ProductDefinition(EntityRef),
    ProductDefinitionUsage(EntityRef),
}
impl Default for ProductDefinitionOrProductDefinitionRelationship {
    fn default() -> Self {
        ProductDefinitionOrProductDefinitionRelationship::ProductDefinition(EntityRef::default())
    }
}
impl From<Parameter> for ProductDefinitionOrProductDefinitionRelationship {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EntityRef(id) => {
                    ProductDefinitionOrProductDefinitionRelationship::EntityRef(EntityRef(id))
                }
                _ => panic!("parameter is not an instance"),
            },
            _ => panic!("parameter is not recognized"),
        }
    }
}
#[derive(Debug)]
pub enum ProductOrFormationOrDefinition {
    EntityRef(EntityRef),
    Product(EntityRef),
    ProductDefinitionFormation(EntityRef),
    ProductDefinition(EntityRef),
}
impl Default for ProductOrFormationOrDefinition {
    fn default() -> Self {
        ProductOrFormationOrDefinition::Product(EntityRef::default())
    }
}
impl From<Parameter> for ProductOrFormationOrDefinition {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EntityRef(id) => ProductOrFormationOrDefinition::EntityRef(EntityRef(id)),
                _ => panic!("parameter is not an instance"),
            },
            _ => panic!("parameter is not recognized"),
        }
    }
}
#[derive(Eq, PartialEq, Hash, Debug)]
pub enum ProjectItem {
    EntityRef(EntityRef),
    ExecutedAction(EntityRef),
    ProductConcept(EntityRef),
}
impl Default for ProjectItem {
    fn default() -> Self {
        ProjectItem::ExecutedAction(EntityRef::default())
    }
}
impl From<Parameter> for ProjectItem {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EntityRef(id) => ProjectItem::EntityRef(EntityRef(id)),
                _ => panic!("parameter is not an instance"),
            },
            _ => panic!("parameter is not recognized"),
        }
    }
}
type RadioactivityMeasure = Real;
type RatioMeasure = Real;
#[derive(Eq, PartialEq, Hash, Debug)]
pub enum RenderingPropertiesSelect {
    EntityRef(EntityRef),
    SurfaceStyleReflectanceAmbient(EntityRef),
    SurfaceStyleTransparent(EntityRef),
}
impl Default for RenderingPropertiesSelect {
    fn default() -> Self {
        RenderingPropertiesSelect::SurfaceStyleReflectanceAmbient(EntityRef::default())
    }
}
impl From<Parameter> for RenderingPropertiesSelect {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EntityRef(id) => RenderingPropertiesSelect::EntityRef(EntityRef(id)),
                _ => panic!("parameter is not an instance"),
            },
            _ => panic!("parameter is not recognized"),
        }
    }
}
#[derive(Debug)]
pub enum RepresentedDefinition {
    EntityRef(EntityRef),
    GeneralProperty(EntityRef),
    PropertyDefinition(EntityRef),
    PropertyDefinitionRelationship(EntityRef),
    ShapeAspect(EntityRef),
    ShapeAspectRelationship(EntityRef),
}
impl Default for RepresentedDefinition {
    fn default() -> Self {
        RepresentedDefinition::GeneralProperty(EntityRef::default())
    }
}
impl From<Parameter> for RepresentedDefinition {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EntityRef(id) => RepresentedDefinition::EntityRef(EntityRef(id)),
                _ => panic!("parameter is not an instance"),
            },
            _ => panic!("parameter is not recognized"),
        }
    }
}
#[derive(Eq, PartialEq, Hash, Debug)]
pub enum RequirementAssignedItem {
    EntityRef(EntityRef),
    ConfigurationItem(EntityRef),
    DescriptiveRepresentationItem(EntityRef),
    Product(EntityRef),
    ProductClass(EntityRef),
    ProductDefinition(EntityRef),
    ProductDefinitionFormation(EntityRef),
    ProductDefinitionRelationship(EntityRef),
    Representation(EntityRef),
    ShapeAspect(EntityRef),
}
impl Default for RequirementAssignedItem {
    fn default() -> Self {
        RequirementAssignedItem::ConfigurationItem(EntityRef::default())
    }
}
impl From<Parameter> for RequirementAssignedItem {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EntityRef(id) => RequirementAssignedItem::EntityRef(EntityRef(id)),
                _ => panic!("parameter is not an instance"),
            },
            _ => panic!("parameter is not recognized"),
        }
    }
}
#[derive(Eq, PartialEq, Hash, Debug)]
pub enum RequirementSourceItem {
    EntityRef(EntityRef),
    CharacterizedObject(EntityRef),
    Group(EntityRef),
    GroupRelationship(EntityRef),
    Product(EntityRef),
    ProductDefinition(EntityRef),
    ProductDefinitionFormation(EntityRef),
    ProductDefinitionRelationship(EntityRef),
    ShapeAspect(EntityRef),
}
impl Default for RequirementSourceItem {
    fn default() -> Self {
        RequirementSourceItem::CharacterizedObject(EntityRef::default())
    }
}
impl From<Parameter> for RequirementSourceItem {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EntityRef(id) => RequirementSourceItem::EntityRef(EntityRef(id)),
                _ => panic!("parameter is not an instance"),
            },
            _ => panic!("parameter is not recognized"),
        }
    }
}
type ResistanceMeasure = Real;
#[derive(Debug)]
pub enum ReversibleTopology {
    ReversibleTopologyItem(ReversibleTopologyItem),
    ListOfReversibleTopologyItem(ListOfReversibleTopologyItem),
    SetOfReversibleTopologyItem(SetOfReversibleTopologyItem),
}
impl Default for ReversibleTopology {
    fn default() -> Self {
        ReversibleTopology::ReversibleTopologyItem(ReversibleTopologyItem::default())
    }
}
impl From<Parameter> for ReversibleTopology {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::TypedParameter(typed_parameter) => match typed_parameter.type_name.as_str() {
                "REVERSIBLE_TOPOLOGY_ITEM" => ReversibleTopology::ReversibleTopologyItem(
                    typed_parameter.parameters.into_iter().next().unwrap().into(),
                ),
                "LIST_OF_REVERSIBLE_TOPOLOGY_ITEM" => ReversibleTopology::ListOfReversibleTopologyItem(
                    typed_parameter.parameters.into_iter().next().unwrap().into(),
                ),
                "SET_OF_REVERSIBLE_TOPOLOGY_ITEM" => ReversibleTopology::SetOfReversibleTopologyItem(
                    typed_parameter.parameters.into_iter().next().unwrap().into(),
                ),
                _ => panic!("parameter type is not recognized: {}", typed_parameter.type_name),
            },
            _ => panic!("parameter is not recognized"),
        }
    }
}
#[derive(Debug)]
pub enum ReversibleTopologyItem {
    EntityRef(EntityRef),
    Edge(EntityRef),
    Path(EntityRef),
    Face(EntityRef),
    FaceBound(EntityRef),
    ClosedShell(EntityRef),
    OpenShell(EntityRef),
}
impl Default for ReversibleTopologyItem {
    fn default() -> Self {
        ReversibleTopologyItem::Edge(EntityRef::default())
    }
}
impl From<Parameter> for ReversibleTopologyItem {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EntityRef(id) => ReversibleTopologyItem::EntityRef(EntityRef(id)),
                _ => panic!("parameter is not an instance"),
            },
            _ => panic!("parameter is not recognized"),
        }
    }
}
#[derive(Debug)]
pub enum RoleSelect {
    EntityRef(EntityRef),
    ActionAssignment(EntityRef),
    ActionRequestAssignment(EntityRef),
    ApprovalAssignment(EntityRef),
    ApprovalDateTime(EntityRef),
    CertificationAssignment(EntityRef),
    ContractAssignment(EntityRef),
    DocumentReference(EntityRef),
    EffectivityAssignment(EntityRef),
    GroupAssignment(EntityRef),
    NameAssignment(EntityRef),
    SecurityClassificationAssignment(EntityRef),
}
impl Default for RoleSelect {
    fn default() -> Self {
        RoleSelect::ActionAssignment(EntityRef::default())
    }
}
impl From<Parameter> for RoleSelect {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EntityRef(id) => RoleSelect::EntityRef(EntityRef(id)),
                _ => panic!("parameter is not an instance"),
            },
            _ => panic!("parameter is not recognized"),
        }
    }
}
#[derive(Eq, PartialEq, Hash, Debug)]
pub enum RuleSupersededItem {
    ProductDefinitionFormation(EntityRef),
}
impl Default for RuleSupersededItem {
    fn default() -> Self {
        RuleSupersededItem::ProductDefinitionFormation(EntityRef::default())
    }
}
impl From<Parameter> for RuleSupersededItem {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EntityRef(id) => RuleSupersededItem::ProductDefinitionFormation(EntityRef(id)),
                _ => panic!("parameter is not an instance"),
            },
            _ => panic!("parameter is not recognized"),
        }
    }
}
type SecondInMinute = Real;
#[derive(Eq, PartialEq, Hash, Debug)]
pub enum SecurityClassificationItem {
    EntityRef(EntityRef),
    AssemblyComponentUsage(EntityRef),
    Document(EntityRef),
    DocumentFile(EntityRef),
    MakeFromUsageOption(EntityRef),
    Product(EntityRef),
    ProductDefinition(EntityRef),
    ProductDefinitionFormation(EntityRef),
    ProductDefinitionUsage(EntityRef),
}
impl Default for SecurityClassificationItem {
    fn default() -> Self {
        SecurityClassificationItem::AssemblyComponentUsage(EntityRef::default())
    }
}
impl From<Parameter> for SecurityClassificationItem {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EntityRef(id) => SecurityClassificationItem::EntityRef(EntityRef(id)),
                _ => panic!("parameter is not an instance"),
            },
            _ => panic!("parameter is not recognized"),
        }
    }
}
type SetOfReversibleTopologyItem = HashSet<EntityRef>;
type SetRepresentationItem = HashSet<EntityRef>;
#[derive(Eq, PartialEq, Hash, Debug)]
pub enum ShadingCurveMethod {
    ConstantColour,
    LinearColour,
}
impl Default for ShadingCurveMethod {
    fn default() -> Self {
        ShadingCurveMethod::ConstantColour
    }
}
impl From<String> for ShadingCurveMethod {
    fn from(value: String) -> Self {
        match value.as_str() {
            "CONSTANT_COLOUR" => ShadingCurveMethod::ConstantColour,
            "LINEAR_COLOUR" => ShadingCurveMethod::LinearColour,
            _ => panic!("{} is not a valid value", value),
        }
    }
}
impl From<Parameter> for ShadingCurveMethod {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EnumValue(value) => value.into(),
                _ => panic!("parameter is not an enum value"),
            },
            Parameter::OmittedParameter => ShadingCurveMethod::default(),
            _ => panic!("parameter is not an enum value"),
        }
    }
}
#[derive(Eq, PartialEq, Hash, Debug)]
pub enum ShadingSurfaceMethod {
    ConstantShading,
    ColourShading,
    DotShading,
    NormalShading,
}
impl Default for ShadingSurfaceMethod {
    fn default() -> Self {
        ShadingSurfaceMethod::ConstantShading
    }
}
impl From<String> for ShadingSurfaceMethod {
    fn from(value: String) -> Self {
        match value.as_str() {
            "CONSTANT_SHADING" => ShadingSurfaceMethod::ConstantShading,
            "COLOUR_SHADING" => ShadingSurfaceMethod::ColourShading,
            "DOT_SHADING" => ShadingSurfaceMethod::DotShading,
            "NORMAL_SHADING" => ShadingSurfaceMethod::NormalShading,
            _ => panic!("{} is not a valid value", value),
        }
    }
}
impl From<Parameter> for ShadingSurfaceMethod {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EnumValue(value) => value.into(),
                _ => panic!("parameter is not an enum value"),
            },
            Parameter::OmittedParameter => ShadingSurfaceMethod::default(),
            _ => panic!("parameter is not an enum value"),
        }
    }
}
#[derive(Eq, PartialEq, Hash, Debug)]
pub enum ShapeDefinition {
    EntityRef(EntityRef),
    ProductDefinitionShape(EntityRef),
    ShapeAspect(EntityRef),
    ShapeAspectRelationship(EntityRef),
}
impl Default for ShapeDefinition {
    fn default() -> Self {
        ShapeDefinition::ProductDefinitionShape(EntityRef::default())
    }
}
impl From<Parameter> for ShapeDefinition {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EntityRef(id) => ShapeDefinition::EntityRef(EntityRef(id)),
                _ => panic!("parameter is not an instance"),
            },
            _ => panic!("parameter is not recognized"),
        }
    }
}
#[derive(Eq, PartialEq, Hash, Debug)]
pub enum Shell {
    EntityRef(EntityRef),
    VertexShell(EntityRef),
    WireShell(EntityRef),
    OpenShell(EntityRef),
    ClosedShell(EntityRef),
}
impl Default for Shell {
    fn default() -> Self {
        Shell::VertexShell(EntityRef::default())
    }
}
impl From<Parameter> for Shell {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EntityRef(id) => Shell::EntityRef(EntityRef(id)),
                _ => panic!("parameter is not an instance"),
            },
            _ => panic!("parameter is not recognized"),
        }
    }
}
#[derive(Eq, PartialEq, Hash, Debug)]
pub enum SiPrefix {
    Exa,
    Peta,
    Tera,
    Giga,
    Mega,
    Kilo,
    Hecto,
    Deca,
    Deci,
    Centi,
    Milli,
    Micro,
    Nano,
    Pico,
    Femto,
    Atto,
}
impl Default for SiPrefix {
    fn default() -> Self {
        SiPrefix::Exa
    }
}
impl From<String> for SiPrefix {
    fn from(value: String) -> Self {
        match value.as_str() {
            "EXA" => SiPrefix::Exa,
            "PETA" => SiPrefix::Peta,
            "TERA" => SiPrefix::Tera,
            "GIGA" => SiPrefix::Giga,
            "MEGA" => SiPrefix::Mega,
            "KILO" => SiPrefix::Kilo,
            "HECTO" => SiPrefix::Hecto,
            "DECA" => SiPrefix::Deca,
            "DECI" => SiPrefix::Deci,
            "CENTI" => SiPrefix::Centi,
            "MILLI" => SiPrefix::Milli,
            "MICRO" => SiPrefix::Micro,
            "NANO" => SiPrefix::Nano,
            "PICO" => SiPrefix::Pico,
            "FEMTO" => SiPrefix::Femto,
            "ATTO" => SiPrefix::Atto,
            _ => panic!("{} is not a valid value", value),
        }
    }
}
impl From<Parameter> for SiPrefix {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EnumValue(value) => value.into(),
                _ => panic!("parameter is not an enum value"),
            },
            Parameter::OmittedParameter => SiPrefix::default(),
            _ => panic!("parameter is not an enum value"),
        }
    }
}
#[derive(Eq, PartialEq, Hash, Debug)]
pub enum SiUnitName {
    Metre,
    Gram,
    Second,
    Ampere,
    Kelvin,
    Mole,
    Candela,
    Radian,
    Steradian,
    Hertz,
    Newton,
    Pascal,
    Joule,
    Watt,
    Coulomb,
    Volt,
    Farad,
    Ohm,
    Siemens,
    Weber,
    Tesla,
    Henry,
    DegreeCelsius,
    Lumen,
    Lux,
    Becquerel,
    Gray,
    Sievert,
}
impl Default for SiUnitName {
    fn default() -> Self {
        SiUnitName::Metre
    }
}
impl From<String> for SiUnitName {
    fn from(value: String) -> Self {
        match value.as_str() {
            "METRE" => SiUnitName::Metre,
            "GRAM" => SiUnitName::Gram,
            "SECOND" => SiUnitName::Second,
            "AMPERE" => SiUnitName::Ampere,
            "KELVIN" => SiUnitName::Kelvin,
            "MOLE" => SiUnitName::Mole,
            "CANDELA" => SiUnitName::Candela,
            "RADIAN" => SiUnitName::Radian,
            "STERADIAN" => SiUnitName::Steradian,
            "HERTZ" => SiUnitName::Hertz,
            "NEWTON" => SiUnitName::Newton,
            "PASCAL" => SiUnitName::Pascal,
            "JOULE" => SiUnitName::Joule,
            "WATT" => SiUnitName::Watt,
            "COULOMB" => SiUnitName::Coulomb,
            "VOLT" => SiUnitName::Volt,
            "FARAD" => SiUnitName::Farad,
            "OHM" => SiUnitName::Ohm,
            "SIEMENS" => SiUnitName::Siemens,
            "WEBER" => SiUnitName::Weber,
            "TESLA" => SiUnitName::Tesla,
            "HENRY" => SiUnitName::Henry,
            "DEGREE_CELSIUS" => SiUnitName::DegreeCelsius,
            "LUMEN" => SiUnitName::Lumen,
            "LUX" => SiUnitName::Lux,
            "BECQUEREL" => SiUnitName::Becquerel,
            "GRAY" => SiUnitName::Gray,
            "SIEVERT" => SiUnitName::Sievert,
            _ => panic!("{} is not a valid value", value),
        }
    }
}
impl From<Parameter> for SiUnitName {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EnumValue(value) => value.into(),
                _ => panic!("parameter is not an enum value"),
            },
            Parameter::OmittedParameter => SiUnitName::default(),
            _ => panic!("parameter is not an enum value"),
        }
    }
}
#[derive(Debug)]
pub enum SizeSelect {
    PositiveLengthMeasure(PositiveLengthMeasure),
    MeasureWithUnit(EntityRef),
    DescriptiveMeasure(DescriptiveMeasure),
}
impl Default for SizeSelect {
    fn default() -> Self {
        SizeSelect::PositiveLengthMeasure(PositiveLengthMeasure::default())
    }
}
impl From<Parameter> for SizeSelect {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::TypedParameter(typed_parameter) => match typed_parameter.type_name.as_str() {
                "POSITIVE_LENGTH_MEASURE" => {
                    SizeSelect::PositiveLengthMeasure(typed_parameter.parameters.into_iter().next().unwrap().into())
                }
                "DESCRIPTIVE_MEASURE" => {
                    SizeSelect::DescriptiveMeasure(typed_parameter.parameters.into_iter().next().unwrap().into())
                }
                _ => panic!("parameter type is not recognized: {}", typed_parameter.type_name),
            },
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EntityRef(id) => SizeSelect::MeasureWithUnit(EntityRef(id)),
                _ => panic!("parameter is not an instance"),
            },
            _ => panic!("parameter is not recognized"),
        }
    }
}
#[derive(Debug)]
pub enum SketchBasisSelect {
    EntityRef(EntityRef),
    CurveBoundedSurface(EntityRef),
    FaceSurface(EntityRef),
}
impl Default for SketchBasisSelect {
    fn default() -> Self {
        SketchBasisSelect::CurveBoundedSurface(EntityRef::default())
    }
}
impl From<Parameter> for SketchBasisSelect {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EntityRef(id) => SketchBasisSelect::EntityRef(EntityRef(id)),
                _ => panic!("parameter is not an instance"),
            },
            _ => panic!("parameter is not recognized"),
        }
    }
}
type SolidAngleMeasure = Real;
#[derive(Eq, PartialEq, Hash, Debug)]
pub enum Source {
    Made,
    Bought,
    NotKnown,
}
impl Default for Source {
    fn default() -> Self {
        Source::Made
    }
}
impl From<String> for Source {
    fn from(value: String) -> Self {
        match value.as_str() {
            "MADE" => Source::Made,
            "BOUGHT" => Source::Bought,
            "NOT_KNOWN" => Source::NotKnown,
            _ => panic!("{} is not a valid value", value),
        }
    }
}
impl From<Parameter> for Source {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EnumValue(value) => value.into(),
                _ => panic!("parameter is not an enum value"),
            },
            Parameter::OmittedParameter => Source::default(),
            _ => panic!("parameter is not an enum value"),
        }
    }
}
#[derive(Debug)]
pub enum SourceItem {
    Identifier(Identifier),
    Message(Message),
}
impl Default for SourceItem {
    fn default() -> Self {
        SourceItem::Identifier(Identifier::default())
    }
}
impl From<Parameter> for SourceItem {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::TypedParameter(typed_parameter) => match typed_parameter.type_name.as_str() {
                "IDENTIFIER" => SourceItem::Identifier(typed_parameter.parameters.into_iter().next().unwrap().into()),
                "MESSAGE" => SourceItem::Message(typed_parameter.parameters.into_iter().next().unwrap().into()),
                _ => panic!("parameter type is not recognized: {}", typed_parameter.type_name),
            },
            _ => panic!("parameter is not recognized"),
        }
    }
}
#[derive(Eq, PartialEq, Hash, Debug)]
pub enum StartRequestItem {
    ProductDefinitionFormation(EntityRef),
}
impl Default for StartRequestItem {
    fn default() -> Self {
        StartRequestItem::ProductDefinitionFormation(EntityRef::default())
    }
}
impl From<Parameter> for StartRequestItem {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EntityRef(id) => StartRequestItem::ProductDefinitionFormation(EntityRef(id)),
                _ => panic!("parameter is not an instance"),
            },
            _ => panic!("parameter is not recognized"),
        }
    }
}
#[derive(Eq, PartialEq, Hash, Debug)]
pub enum StringRepresentationItemSelect {
    EntityRef(EntityRef),
    DescriptiveRepresentationItem(EntityRef),
    IncludedTextBlock(EntityRef),
    StructuredTextComposition(EntityRef),
}
impl Default for StringRepresentationItemSelect {
    fn default() -> Self {
        StringRepresentationItemSelect::DescriptiveRepresentationItem(EntityRef::default())
    }
}
impl From<Parameter> for StringRepresentationItemSelect {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EntityRef(id) => StringRepresentationItemSelect::EntityRef(EntityRef(id)),
                _ => panic!("parameter is not an instance"),
            },
            _ => panic!("parameter is not recognized"),
        }
    }
}
#[derive(Debug)]
pub enum StyleContextSelect {
    EntityRef(EntityRef),
    Group(EntityRef),
    PresentationLayerAssignment(EntityRef),
    PresentationSet(EntityRef),
    Representation(EntityRef),
    RepresentationItem(EntityRef),
    ShapeRepresentationRelationship(EntityRef),
}
impl Default for StyleContextSelect {
    fn default() -> Self {
        StyleContextSelect::Group(EntityRef::default())
    }
}
impl From<Parameter> for StyleContextSelect {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EntityRef(id) => StyleContextSelect::EntityRef(EntityRef(id)),
                _ => panic!("parameter is not an instance"),
            },
            _ => panic!("parameter is not recognized"),
        }
    }
}
#[derive(Eq, PartialEq, Hash, Debug)]
pub enum SurfaceSide {
    Positive,
    Negative,
    Both,
}
impl Default for SurfaceSide {
    fn default() -> Self {
        SurfaceSide::Positive
    }
}
impl From<String> for SurfaceSide {
    fn from(value: String) -> Self {
        match value.as_str() {
            "POSITIVE" => SurfaceSide::Positive,
            "NEGATIVE" => SurfaceSide::Negative,
            "BOTH" => SurfaceSide::Both,
            _ => panic!("{} is not a valid value", value),
        }
    }
}
impl From<Parameter> for SurfaceSide {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EnumValue(value) => value.into(),
                _ => panic!("parameter is not an enum value"),
            },
            Parameter::OmittedParameter => SurfaceSide::default(),
            _ => panic!("parameter is not an enum value"),
        }
    }
}
#[derive(Debug)]
pub enum SurfaceSideStyleSelect {
    EntityRef(EntityRef),
    SurfaceSideStyle(EntityRef),
    PreDefinedSurfaceSideStyle(EntityRef),
}
impl Default for SurfaceSideStyleSelect {
    fn default() -> Self {
        SurfaceSideStyleSelect::SurfaceSideStyle(EntityRef::default())
    }
}
impl From<Parameter> for SurfaceSideStyleSelect {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EntityRef(id) => SurfaceSideStyleSelect::EntityRef(EntityRef(id)),
                _ => panic!("parameter is not an instance"),
            },
            _ => panic!("parameter is not recognized"),
        }
    }
}
#[derive(Eq, PartialEq, Hash, Debug)]
pub enum SurfaceStyleElementSelect {
    EntityRef(EntityRef),
    SurfaceStyleFillArea(EntityRef),
    SurfaceStyleBoundary(EntityRef),
    SurfaceStyleSilhouette(EntityRef),
    SurfaceStyleSegmentationCurve(EntityRef),
    SurfaceStyleControlGrid(EntityRef),
    SurfaceStyleParameterLine(EntityRef),
    SurfaceStyleRendering(EntityRef),
}
impl Default for SurfaceStyleElementSelect {
    fn default() -> Self {
        SurfaceStyleElementSelect::SurfaceStyleFillArea(EntityRef::default())
    }
}
impl From<Parameter> for SurfaceStyleElementSelect {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EntityRef(id) => SurfaceStyleElementSelect::EntityRef(EntityRef(id)),
                _ => panic!("parameter is not an instance"),
            },
            _ => panic!("parameter is not recognized"),
        }
    }
}
#[derive(Debug)]
pub enum SymbolStyleSelect {
    SymbolColour(EntityRef),
}
impl Default for SymbolStyleSelect {
    fn default() -> Self {
        SymbolStyleSelect::SymbolColour(EntityRef::default())
    }
}
impl From<Parameter> for SymbolStyleSelect {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EntityRef(id) => SymbolStyleSelect::SymbolColour(EntityRef(id)),
                _ => panic!("parameter is not an instance"),
            },
            _ => panic!("parameter is not recognized"),
        }
    }
}
type Text = String;
type TextAlignment = Label;
type TextDelineation = Label;
#[derive(Eq, PartialEq, Hash, Debug)]
pub enum TextOrCharacter {
    EntityRef(EntityRef),
    AnnotationText(EntityRef),
    AnnotationTextCharacter(EntityRef),
    CompositeText(EntityRef),
    TextLiteral(EntityRef),
}
impl Default for TextOrCharacter {
    fn default() -> Self {
        TextOrCharacter::AnnotationText(EntityRef::default())
    }
}
impl From<Parameter> for TextOrCharacter {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EntityRef(id) => TextOrCharacter::EntityRef(EntityRef(id)),
                _ => panic!("parameter is not an instance"),
            },
            _ => panic!("parameter is not recognized"),
        }
    }
}
#[derive(Eq, PartialEq, Hash, Debug)]
pub enum TextPath {
    Left,
    Right,
    Up,
    Down,
}
impl Default for TextPath {
    fn default() -> Self {
        TextPath::Left
    }
}
impl From<String> for TextPath {
    fn from(value: String) -> Self {
        match value.as_str() {
            "LEFT" => TextPath::Left,
            "RIGHT" => TextPath::Right,
            "UP" => TextPath::Up,
            "DOWN" => TextPath::Down,
            _ => panic!("{} is not a valid value", value),
        }
    }
}
impl From<Parameter> for TextPath {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EnumValue(value) => value.into(),
                _ => panic!("parameter is not an enum value"),
            },
            Parameter::OmittedParameter => TextPath::default(),
            _ => panic!("parameter is not an enum value"),
        }
    }
}
#[derive(Eq, PartialEq, Hash, Debug)]
pub enum TextStringRepresentationItem {
    EntityRef(EntityRef),
    TextLiteral(EntityRef),
    AnnotationText(EntityRef),
    AnnotationTextCharacter(EntityRef),
    CompositeText(EntityRef),
    Axis2Placement(Axis2Placement),
}
impl Default for TextStringRepresentationItem {
    fn default() -> Self {
        TextStringRepresentationItem::TextLiteral(EntityRef::default())
    }
}
impl From<Parameter> for TextStringRepresentationItem {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::TypedParameter(typed_parameter) => match typed_parameter.type_name.as_str() {
                "AXIS2_PLACEMENT" => TextStringRepresentationItem::Axis2Placement(
                    typed_parameter.parameters.into_iter().next().unwrap().into(),
                ),
                _ => panic!("parameter type is not recognized: {}", typed_parameter.type_name),
            },
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EntityRef(id) => TextStringRepresentationItem::EntityRef(EntityRef(id)),
                _ => panic!("parameter is not an instance"),
            },
            _ => panic!("parameter is not recognized"),
        }
    }
}
type ThermodynamicTemperatureMeasure = Real;
#[derive(Eq, PartialEq, Hash, Debug)]
pub enum TimeIntervalItem {
    EntityRef(EntityRef),
    Action(EntityRef),
    TimeIntervalBasedEffectivity(EntityRef),
}
impl Default for TimeIntervalItem {
    fn default() -> Self {
        TimeIntervalItem::Action(EntityRef::default())
    }
}
impl From<Parameter> for TimeIntervalItem {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EntityRef(id) => TimeIntervalItem::EntityRef(EntityRef(id)),
                _ => panic!("parameter is not an instance"),
            },
            _ => panic!("parameter is not recognized"),
        }
    }
}
type TimeMeasure = Real;
#[derive(Debug)]
pub enum ToleranceMethodDefinition {
    EntityRef(EntityRef),
    ToleranceValue(EntityRef),
    LimitsAndFits(EntityRef),
}
impl Default for ToleranceMethodDefinition {
    fn default() -> Self {
        ToleranceMethodDefinition::ToleranceValue(EntityRef::default())
    }
}
impl From<Parameter> for ToleranceMethodDefinition {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EntityRef(id) => ToleranceMethodDefinition::EntityRef(EntityRef(id)),
                _ => panic!("parameter is not an instance"),
            },
            _ => panic!("parameter is not recognized"),
        }
    }
}
#[derive(Debug)]
pub enum Transformation {
    EntityRef(EntityRef),
    ItemDefinedTransformation(EntityRef),
    FunctionallyDefinedTransformation(EntityRef),
}
impl Default for Transformation {
    fn default() -> Self {
        Transformation::ItemDefinedTransformation(EntityRef::default())
    }
}
impl From<Parameter> for Transformation {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EntityRef(id) => Transformation::EntityRef(EntityRef(id)),
                _ => panic!("parameter is not an instance"),
            },
            _ => panic!("parameter is not recognized"),
        }
    }
}
#[derive(Eq, PartialEq, Hash, Debug)]
pub enum TransitionCode {
    Discontinuous,
    Continuous,
    ContSameGradient,
    ContSameGradientSameCurvature,
}
impl Default for TransitionCode {
    fn default() -> Self {
        TransitionCode::Discontinuous
    }
}
impl From<String> for TransitionCode {
    fn from(value: String) -> Self {
        match value.as_str() {
            "DISCONTINUOUS" => TransitionCode::Discontinuous,
            "CONTINUOUS" => TransitionCode::Continuous,
            "CONT_SAME_GRADIENT" => TransitionCode::ContSameGradient,
            "CONT_SAME_GRADIENT_SAME_CURVATURE" => TransitionCode::ContSameGradientSameCurvature,
            _ => panic!("{} is not a valid value", value),
        }
    }
}
impl From<Parameter> for TransitionCode {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EnumValue(value) => value.into(),
                _ => panic!("parameter is not an enum value"),
            },
            Parameter::OmittedParameter => TransitionCode::default(),
            _ => panic!("parameter is not an enum value"),
        }
    }
}
#[derive(Debug)]
pub enum TrimConditionSelect {
    LengthMeasure(LengthMeasure),
    PlaneAngleMeasure(PlaneAngleMeasure),
    GeneralizedSurfaceSelect(GeneralizedSurfaceSelect),
    SolidModel(EntityRef),
}
impl Default for TrimConditionSelect {
    fn default() -> Self {
        TrimConditionSelect::LengthMeasure(LengthMeasure::default())
    }
}
impl From<Parameter> for TrimConditionSelect {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::TypedParameter(typed_parameter) => match typed_parameter.type_name.as_str() {
                "LENGTH_MEASURE" => {
                    TrimConditionSelect::LengthMeasure(typed_parameter.parameters.into_iter().next().unwrap().into())
                }
                "PLANE_ANGLE_MEASURE" => TrimConditionSelect::PlaneAngleMeasure(
                    typed_parameter.parameters.into_iter().next().unwrap().into(),
                ),
                "GENERALIZED_SURFACE_SELECT" => TrimConditionSelect::GeneralizedSurfaceSelect(
                    typed_parameter.parameters.into_iter().next().unwrap().into(),
                ),
                _ => panic!("parameter type is not recognized: {}", typed_parameter.type_name),
            },
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EntityRef(id) => TrimConditionSelect::SolidModel(EntityRef(id)),
                _ => panic!("parameter is not an instance"),
            },
            _ => panic!("parameter is not recognized"),
        }
    }
}
#[derive(Eq, PartialEq, Hash, Debug)]
pub enum TrimIntent {
    Blind,
    Offset,
    ThroughAll,
    Unspecified,
    UpToNext,
}
impl Default for TrimIntent {
    fn default() -> Self {
        TrimIntent::Blind
    }
}
impl From<String> for TrimIntent {
    fn from(value: String) -> Self {
        match value.as_str() {
            "BLIND" => TrimIntent::Blind,
            "OFFSET" => TrimIntent::Offset,
            "THROUGH_ALL" => TrimIntent::ThroughAll,
            "UNSPECIFIED" => TrimIntent::Unspecified,
            "UP_TO_NEXT" => TrimIntent::UpToNext,
            _ => panic!("{} is not a valid value", value),
        }
    }
}
impl From<Parameter> for TrimIntent {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EnumValue(value) => value.into(),
                _ => panic!("parameter is not an enum value"),
            },
            Parameter::OmittedParameter => TrimIntent::default(),
            _ => panic!("parameter is not an enum value"),
        }
    }
}
#[derive(Eq, PartialEq, Hash, Debug)]
pub enum TrimmingPreference {
    Cartesian,
    Parameter,
    Unspecified,
}
impl Default for TrimmingPreference {
    fn default() -> Self {
        TrimmingPreference::Cartesian
    }
}
impl From<String> for TrimmingPreference {
    fn from(value: String) -> Self {
        match value.as_str() {
            "CARTESIAN" => TrimmingPreference::Cartesian,
            "PARAMETER" => TrimmingPreference::Parameter,
            "UNSPECIFIED" => TrimmingPreference::Unspecified,
            _ => panic!("{} is not a valid value", value),
        }
    }
}
impl From<Parameter> for TrimmingPreference {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EnumValue(value) => value.into(),
                _ => panic!("parameter is not an enum value"),
            },
            Parameter::OmittedParameter => TrimmingPreference::default(),
            _ => panic!("parameter is not an enum value"),
        }
    }
}
#[derive(Eq, PartialEq, Hash, Debug)]
pub enum TrimmingSelect {
    CartesianPoint(EntityRef),
    ParameterValue(ParameterValue),
}
impl Default for TrimmingSelect {
    fn default() -> Self {
        TrimmingSelect::CartesianPoint(EntityRef::default())
    }
}
impl From<Parameter> for TrimmingSelect {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::TypedParameter(typed_parameter) => match typed_parameter.type_name.as_str() {
                "PARAMETER_VALUE" => {
                    TrimmingSelect::ParameterValue(typed_parameter.parameters.into_iter().next().unwrap().into())
                }
                _ => panic!("parameter type is not recognized: {}", typed_parameter.type_name),
            },
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EntityRef(id) => TrimmingSelect::CartesianPoint(EntityRef(id)),
                _ => panic!("parameter is not an instance"),
            },
            _ => panic!("parameter is not recognized"),
        }
    }
}
type UDirectionCount = i64;
#[derive(Eq, PartialEq, Hash, Debug)]
pub enum Unit {
    EntityRef(EntityRef),
    DerivedUnit(EntityRef),
    NamedUnit(EntityRef),
}
impl Default for Unit {
    fn default() -> Self {
        Unit::DerivedUnit(EntityRef::default())
    }
}
impl From<Parameter> for Unit {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EntityRef(id) => Unit::EntityRef(EntityRef(id)),
                _ => panic!("parameter is not an instance"),
            },
            _ => panic!("parameter is not recognized"),
        }
    }
}
type VDirectionCount = i64;
#[derive(Eq, PartialEq, Hash, Debug)]
pub enum ValueQualifier {
    EntityRef(EntityRef),
    PrecisionQualifier(EntityRef),
    TypeQualifier(EntityRef),
    UncertaintyQualifier(EntityRef),
}
impl Default for ValueQualifier {
    fn default() -> Self {
        ValueQualifier::PrecisionQualifier(EntityRef::default())
    }
}
impl From<Parameter> for ValueQualifier {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EntityRef(id) => ValueQualifier::EntityRef(EntityRef(id)),
                _ => panic!("parameter is not an instance"),
            },
            _ => panic!("parameter is not recognized"),
        }
    }
}
#[derive(Debug)]
pub enum VectorOrDirection {
    EntityRef(EntityRef),
    Vector(EntityRef),
    Direction(EntityRef),
}
impl Default for VectorOrDirection {
    fn default() -> Self {
        VectorOrDirection::Vector(EntityRef::default())
    }
}
impl From<Parameter> for VectorOrDirection {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EntityRef(id) => VectorOrDirection::EntityRef(EntityRef(id)),
                _ => panic!("parameter is not an instance"),
            },
            _ => panic!("parameter is not recognized"),
        }
    }
}
type VelocityMeasure = Real;
#[derive(Eq, PartialEq, Hash, Debug)]
pub enum ViewDependentAnnotationRepresentationItem {
    AnnotationOccurrence(EntityRef),
    Axis2Placement(Axis2Placement),
}
impl Default for ViewDependentAnnotationRepresentationItem {
    fn default() -> Self {
        ViewDependentAnnotationRepresentationItem::AnnotationOccurrence(EntityRef::default())
    }
}
impl From<Parameter> for ViewDependentAnnotationRepresentationItem {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::TypedParameter(typed_parameter) => match typed_parameter.type_name.as_str() {
                "AXIS2_PLACEMENT" => ViewDependentAnnotationRepresentationItem::Axis2Placement(
                    typed_parameter.parameters.into_iter().next().unwrap().into(),
                ),
                _ => panic!("parameter type is not recognized: {}", typed_parameter.type_name),
            },
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EntityRef(id) => {
                    ViewDependentAnnotationRepresentationItem::AnnotationOccurrence(EntityRef(id))
                }
                _ => panic!("parameter is not an instance"),
            },
            _ => panic!("parameter is not recognized"),
        }
    }
}
type VolumeMeasure = Real;
type WeekInYearNumber = i64;
#[derive(Eq, PartialEq, Hash, Debug)]
pub enum WorkItem {
    ProductDefinitionFormation(EntityRef),
}
impl Default for WorkItem {
    fn default() -> Self {
        WorkItem::ProductDefinitionFormation(EntityRef::default())
    }
}
impl From<Parameter> for WorkItem {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EntityRef(id) => WorkItem::ProductDefinitionFormation(EntityRef(id)),
                _ => panic!("parameter is not an instance"),
            },
            _ => panic!("parameter is not recognized"),
        }
    }
}
type YearNumber = i64;
pub trait IAbsorbedDoseMeasureWithUnit: IMeasureWithUnit {}
#[derive(Default, Debug)]
pub struct AbsorbedDoseMeasureWithUnit {
    value_component: MeasureValue,
    unit_component: EntityRef,
}
impl IMeasureWithUnit for AbsorbedDoseMeasureWithUnit {
    fn value_component(&self) -> &MeasureValue {
        &self.value_component
    }
    fn unit_component(&self) -> &EntityRef {
        &self.unit_component
    }
}
impl IAbsorbedDoseMeasureWithUnit for AbsorbedDoseMeasureWithUnit {}
impl AbsorbedDoseMeasureWithUnit {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = AbsorbedDoseMeasureWithUnit::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.value_component = parameter.into(),
                1usize => entity.unit_component = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IAbsorbedDoseUnit: IDerivedUnit {}
#[derive(Default, Debug)]
pub struct AbsorbedDoseUnit {
    elements: HashSet<EntityRef>,
}
impl IDerivedUnit for AbsorbedDoseUnit {
    fn elements(&self) -> &HashSet<EntityRef> {
        &self.elements
    }
}
impl IAbsorbedDoseUnit for AbsorbedDoseUnit {}
impl AbsorbedDoseUnit {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = AbsorbedDoseUnit::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.elements = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IAbstractVariable:
    IPropertyDefinition + IPropertyDefinitionRepresentation + IRepresentation + IRepresentationItem
{
}
#[derive(Default, Debug)]
pub struct AbstractVariable {
    name: Label,
    description: Option<Text>,
    definition: EntityRef,
    used_representation: EntityRef,
    items: HashSet<EntityRef>,
    context_of_items: EntityRef,
}
impl IPropertyDefinition for AbstractVariable {
    fn name(&self) -> &Label {
        &self.name
    }
    fn description(&self) -> &Option<Text> {
        &self.description
    }
    fn definition(&self) -> &EntityRef {
        &self.definition
    }
}
impl IPropertyDefinitionRepresentation for AbstractVariable {
    fn definition(&self) -> &EntityRef {
        &self.definition
    }
    fn used_representation(&self) -> &EntityRef {
        &self.used_representation
    }
}
impl IRepresentation for AbstractVariable {
    fn name(&self) -> &Label {
        &self.name
    }
    fn items(&self) -> &HashSet<EntityRef> {
        &self.items
    }
    fn context_of_items(&self) -> &EntityRef {
        &self.context_of_items
    }
}
impl IRepresentationItem for AbstractVariable {
    fn name(&self) -> &Label {
        &self.name
    }
}
impl IAbstractVariable for AbstractVariable {}
impl AbstractVariable {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = AbstractVariable::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => entity.definition = parameter.into(),
                3usize => entity.used_representation = parameter.into(),
                4usize => entity.items = parameter.into(),
                5usize => entity.context_of_items = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IAccelerationMeasureWithUnit: IMeasureWithUnit {}
#[derive(Default, Debug)]
pub struct AccelerationMeasureWithUnit {
    value_component: MeasureValue,
    unit_component: EntityRef,
}
impl IMeasureWithUnit for AccelerationMeasureWithUnit {
    fn value_component(&self) -> &MeasureValue {
        &self.value_component
    }
    fn unit_component(&self) -> &EntityRef {
        &self.unit_component
    }
}
impl IAccelerationMeasureWithUnit for AccelerationMeasureWithUnit {}
impl AccelerationMeasureWithUnit {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = AccelerationMeasureWithUnit::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.value_component = parameter.into(),
                1usize => entity.unit_component = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IAccelerationUnit: IDerivedUnit {}
#[derive(Default, Debug)]
pub struct AccelerationUnit {
    elements: HashSet<EntityRef>,
}
impl IDerivedUnit for AccelerationUnit {
    fn elements(&self) -> &HashSet<EntityRef> {
        &self.elements
    }
}
impl IAccelerationUnit for AccelerationUnit {}
impl AccelerationUnit {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = AccelerationUnit::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.elements = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IAction {
    fn name(&self) -> &Label;
    fn description(&self) -> &Option<Text>;
    fn chosen_method(&self) -> &EntityRef;
}
#[derive(Default, Debug)]
pub struct Action {
    name: Label,
    description: Option<Text>,
    chosen_method: EntityRef,
}
impl IAction for Action {
    fn name(&self) -> &Label {
        &self.name
    }
    fn description(&self) -> &Option<Text> {
        &self.description
    }
    fn chosen_method(&self) -> &EntityRef {
        &self.chosen_method
    }
}
impl Action {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = Action::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => entity.chosen_method = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IActionAssignment {
    fn assigned_action(&self) -> &EntityRef;
}
pub trait IActionDirective {
    fn name(&self) -> &Label;
    fn description(&self) -> &Option<Text>;
    fn analysis(&self) -> &Text;
    fn comment(&self) -> &Text;
    fn requests(&self) -> &HashSet<EntityRef>;
}
#[derive(Default, Debug)]
pub struct ActionDirective {
    name: Label,
    description: Option<Text>,
    analysis: Text,
    comment: Text,
    requests: HashSet<EntityRef>,
}
impl IActionDirective for ActionDirective {
    fn name(&self) -> &Label {
        &self.name
    }
    fn description(&self) -> &Option<Text> {
        &self.description
    }
    fn analysis(&self) -> &Text {
        &self.analysis
    }
    fn comment(&self) -> &Text {
        &self.comment
    }
    fn requests(&self) -> &HashSet<EntityRef> {
        &self.requests
    }
}
impl ActionDirective {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = ActionDirective::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => entity.analysis = parameter.into(),
                3usize => entity.comment = parameter.into(),
                4usize => entity.requests = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IActionMethod {
    fn name(&self) -> &Label;
    fn description(&self) -> &Option<Text>;
    fn consequence(&self) -> &Text;
    fn purpose(&self) -> &Text;
}
#[derive(Default, Debug)]
pub struct ActionMethod {
    name: Label,
    description: Option<Text>,
    consequence: Text,
    purpose: Text,
}
impl IActionMethod for ActionMethod {
    fn name(&self) -> &Label {
        &self.name
    }
    fn description(&self) -> &Option<Text> {
        &self.description
    }
    fn consequence(&self) -> &Text {
        &self.consequence
    }
    fn purpose(&self) -> &Text {
        &self.purpose
    }
}
impl ActionMethod {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = ActionMethod::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => entity.consequence = parameter.into(),
                3usize => entity.purpose = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IActionMethodAssignment {
    fn assigned_action_method(&self) -> &EntityRef;
    fn role(&self) -> &EntityRef;
}
pub trait IActionMethodRelationship {
    fn name(&self) -> &Label;
    fn description(&self) -> &Option<Text>;
    fn relating_method(&self) -> &EntityRef;
    fn related_method(&self) -> &EntityRef;
}
#[derive(Default, Debug)]
pub struct ActionMethodRelationship {
    name: Label,
    description: Option<Text>,
    relating_method: EntityRef,
    related_method: EntityRef,
}
impl IActionMethodRelationship for ActionMethodRelationship {
    fn name(&self) -> &Label {
        &self.name
    }
    fn description(&self) -> &Option<Text> {
        &self.description
    }
    fn relating_method(&self) -> &EntityRef {
        &self.relating_method
    }
    fn related_method(&self) -> &EntityRef {
        &self.related_method
    }
}
impl ActionMethodRelationship {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = ActionMethodRelationship::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => entity.relating_method = parameter.into(),
                3usize => entity.related_method = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IActionMethodRole {
    fn name(&self) -> &Label;
    fn description(&self) -> &Option<Text>;
}
#[derive(Default, Debug)]
pub struct ActionMethodRole {
    name: Label,
    description: Option<Text>,
}
impl IActionMethodRole for ActionMethodRole {
    fn name(&self) -> &Label {
        &self.name
    }
    fn description(&self) -> &Option<Text> {
        &self.description
    }
}
impl ActionMethodRole {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = ActionMethodRole::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
}
pub trait IActionProperty {
    fn name(&self) -> &Label;
    fn description(&self) -> &Text;
    fn definition(&self) -> &EntityRef;
}
#[derive(Default, Debug)]
pub struct ActionProperty {
    name: Label,
    description: Text,
    definition: EntityRef,
}
impl IActionProperty for ActionProperty {
    fn name(&self) -> &Label {
        &self.name
    }
    fn description(&self) -> &Text {
        &self.description
    }
    fn definition(&self) -> &EntityRef {
        &self.definition
    }
}
impl ActionProperty {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = ActionProperty::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => entity.description = parameter.into(),
                2usize => entity.definition = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IActionPropertyRepresentation {
    fn name(&self) -> &Label;
    fn description(&self) -> &Text;
    fn property(&self) -> &EntityRef;
    fn representation(&self) -> &EntityRef;
}
#[derive(Default, Debug)]
pub struct ActionPropertyRepresentation {
    name: Label,
    description: Text,
    property: EntityRef,
    representation: EntityRef,
}
impl IActionPropertyRepresentation for ActionPropertyRepresentation {
    fn name(&self) -> &Label {
        &self.name
    }
    fn description(&self) -> &Text {
        &self.description
    }
    fn property(&self) -> &EntityRef {
        &self.property
    }
    fn representation(&self) -> &EntityRef {
        &self.representation
    }
}
impl ActionPropertyRepresentation {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = ActionPropertyRepresentation::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => entity.description = parameter.into(),
                2usize => entity.property = parameter.into(),
                3usize => entity.representation = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IActionRelationship {
    fn name(&self) -> &Label;
    fn description(&self) -> &Option<Text>;
    fn relating_action(&self) -> &EntityRef;
    fn related_action(&self) -> &EntityRef;
}
#[derive(Default, Debug)]
pub struct ActionRelationship {
    name: Label,
    description: Option<Text>,
    relating_action: EntityRef,
    related_action: EntityRef,
}
impl IActionRelationship for ActionRelationship {
    fn name(&self) -> &Label {
        &self.name
    }
    fn description(&self) -> &Option<Text> {
        &self.description
    }
    fn relating_action(&self) -> &EntityRef {
        &self.relating_action
    }
    fn related_action(&self) -> &EntityRef {
        &self.related_action
    }
}
impl ActionRelationship {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = ActionRelationship::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => entity.relating_action = parameter.into(),
                3usize => entity.related_action = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IActionRequestAssignment {
    fn assigned_action_request(&self) -> &EntityRef;
}
pub trait IActionRequestSolution {
    fn method(&self) -> &EntityRef;
    fn request(&self) -> &EntityRef;
}
#[derive(Default, Debug)]
pub struct ActionRequestSolution {
    method: EntityRef,
    request: EntityRef,
}
impl IActionRequestSolution for ActionRequestSolution {
    fn method(&self) -> &EntityRef {
        &self.method
    }
    fn request(&self) -> &EntityRef {
        &self.request
    }
}
impl ActionRequestSolution {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = ActionRequestSolution::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.method = parameter.into(),
                1usize => entity.request = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IActionRequestStatus {
    fn status(&self) -> &Label;
    fn assigned_request(&self) -> &EntityRef;
}
#[derive(Default, Debug)]
pub struct ActionRequestStatus {
    status: Label,
    assigned_request: EntityRef,
}
impl IActionRequestStatus for ActionRequestStatus {
    fn status(&self) -> &Label {
        &self.status
    }
    fn assigned_request(&self) -> &EntityRef {
        &self.assigned_request
    }
}
impl ActionRequestStatus {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = ActionRequestStatus::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.status = parameter.into(),
                1usize => entity.assigned_request = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IActionStatus {
    fn status(&self) -> &Label;
    fn assigned_action(&self) -> &EntityRef;
}
#[derive(Default, Debug)]
pub struct ActionStatus {
    status: Label,
    assigned_action: EntityRef,
}
impl IActionStatus for ActionStatus {
    fn status(&self) -> &Label {
        &self.status
    }
    fn assigned_action(&self) -> &EntityRef {
        &self.assigned_action
    }
}
impl ActionStatus {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = ActionStatus::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.status = parameter.into(),
                1usize => entity.assigned_action = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IAddress {
    fn internal_location(&self) -> &Option<Label>;
    fn street_number(&self) -> &Option<Label>;
    fn street(&self) -> &Option<Label>;
    fn postal_box(&self) -> &Option<Label>;
    fn town(&self) -> &Option<Label>;
    fn region(&self) -> &Option<Label>;
    fn postal_code(&self) -> &Option<Label>;
    fn country(&self) -> &Option<Label>;
    fn facsimile_number(&self) -> &Option<Label>;
    fn telephone_number(&self) -> &Option<Label>;
    fn electronic_mail_address(&self) -> &Option<Label>;
    fn telex_number(&self) -> &Option<Label>;
}
#[derive(Default, Debug)]
pub struct Address {
    internal_location: Option<Label>,
    street_number: Option<Label>,
    street: Option<Label>,
    postal_box: Option<Label>,
    town: Option<Label>,
    region: Option<Label>,
    postal_code: Option<Label>,
    country: Option<Label>,
    facsimile_number: Option<Label>,
    telephone_number: Option<Label>,
    electronic_mail_address: Option<Label>,
    telex_number: Option<Label>,
}
impl IAddress for Address {
    fn internal_location(&self) -> &Option<Label> {
        &self.internal_location
    }
    fn street_number(&self) -> &Option<Label> {
        &self.street_number
    }
    fn street(&self) -> &Option<Label> {
        &self.street
    }
    fn postal_box(&self) -> &Option<Label> {
        &self.postal_box
    }
    fn town(&self) -> &Option<Label> {
        &self.town
    }
    fn region(&self) -> &Option<Label> {
        &self.region
    }
    fn postal_code(&self) -> &Option<Label> {
        &self.postal_code
    }
    fn country(&self) -> &Option<Label> {
        &self.country
    }
    fn facsimile_number(&self) -> &Option<Label> {
        &self.facsimile_number
    }
    fn telephone_number(&self) -> &Option<Label> {
        &self.telephone_number
    }
    fn electronic_mail_address(&self) -> &Option<Label> {
        &self.electronic_mail_address
    }
    fn telex_number(&self) -> &Option<Label> {
        &self.telex_number
    }
}
impl Address {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = Address::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => {
                    entity.internal_location = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                1usize => {
                    entity.street_number = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => {
                    entity.street = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.postal_box = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => {
                    entity.town = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                5usize => {
                    entity.region = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                6usize => {
                    entity.postal_code = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                7usize => {
                    entity.country = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                8usize => {
                    entity.facsimile_number = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                9usize => {
                    entity.telephone_number = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                10usize => {
                    entity.electronic_mail_address = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                11usize => {
                    entity.telex_number = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
}
pub trait IAdvancedBrepShapeRepresentation: IShapeRepresentation {}
#[derive(Default, Debug)]
pub struct AdvancedBrepShapeRepresentation {
    name: Label,
    items: HashSet<EntityRef>,
    context_of_items: EntityRef,
}
impl IRepresentation for AdvancedBrepShapeRepresentation {
    fn name(&self) -> &Label {
        &self.name
    }
    fn items(&self) -> &HashSet<EntityRef> {
        &self.items
    }
    fn context_of_items(&self) -> &EntityRef {
        &self.context_of_items
    }
}
impl IShapeRepresentation for AdvancedBrepShapeRepresentation {}
impl IAdvancedBrepShapeRepresentation for AdvancedBrepShapeRepresentation {}
impl AdvancedBrepShapeRepresentation {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = AdvancedBrepShapeRepresentation::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => entity.items = parameter.into(),
                2usize => entity.context_of_items = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IAdvancedFace: IFaceSurface {}
#[derive(Default, Debug)]
pub struct AdvancedFace {
    name: Label,
    bounds: HashSet<EntityRef>,
    face_geometry: EntityRef,
    same_sense: bool,
}
impl IRepresentationItem for AdvancedFace {
    fn name(&self) -> &Label {
        &self.name
    }
}
impl ITopologicalRepresentationItem for AdvancedFace {}
impl IFace for AdvancedFace {
    fn bounds(&self) -> &HashSet<EntityRef> {
        &self.bounds
    }
}
impl IFaceSurface for AdvancedFace {
    fn face_geometry(&self) -> &EntityRef {
        &self.face_geometry
    }
    fn same_sense(&self) -> bool {
        self.same_sense
    }
}
impl IGeometricRepresentationItem for AdvancedFace {}
impl IAdvancedFace for AdvancedFace {}
impl AdvancedFace {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = AdvancedFace::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => entity.bounds = parameter.into(),
                2usize => entity.face_geometry = parameter.into(),
                3usize => entity.same_sense = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IAlternateProductRelationship {
    fn name(&self) -> &Label;
    fn definition(&self) -> &Option<Text>;
    fn alternate(&self) -> &EntityRef;
    fn base(&self) -> &EntityRef;
    fn basis(&self) -> &Text;
}
#[derive(Default, Debug)]
pub struct AlternateProductRelationship {
    name: Label,
    definition: Option<Text>,
    alternate: EntityRef,
    base: EntityRef,
    basis: Text,
}
impl IAlternateProductRelationship for AlternateProductRelationship {
    fn name(&self) -> &Label {
        &self.name
    }
    fn definition(&self) -> &Option<Text> {
        &self.definition
    }
    fn alternate(&self) -> &EntityRef {
        &self.alternate
    }
    fn base(&self) -> &EntityRef {
        &self.base
    }
    fn basis(&self) -> &Text {
        &self.basis
    }
}
impl AlternateProductRelationship {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = AlternateProductRelationship::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => {
                    entity.definition = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => entity.alternate = parameter.into(),
                3usize => entity.base = parameter.into(),
                4usize => entity.basis = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IAmountOfSubstanceMeasureWithUnit: IMeasureWithUnit {}
#[derive(Default, Debug)]
pub struct AmountOfSubstanceMeasureWithUnit {
    value_component: MeasureValue,
    unit_component: EntityRef,
}
impl IMeasureWithUnit for AmountOfSubstanceMeasureWithUnit {
    fn value_component(&self) -> &MeasureValue {
        &self.value_component
    }
    fn unit_component(&self) -> &EntityRef {
        &self.unit_component
    }
}
impl IAmountOfSubstanceMeasureWithUnit for AmountOfSubstanceMeasureWithUnit {}
impl AmountOfSubstanceMeasureWithUnit {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = AmountOfSubstanceMeasureWithUnit::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.value_component = parameter.into(),
                1usize => entity.unit_component = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IAmountOfSubstanceUnit: INamedUnit {}
#[derive(Default, Debug)]
pub struct AmountOfSubstanceUnit {
    dimensions: EntityRef,
}
impl INamedUnit for AmountOfSubstanceUnit {
    fn dimensions(&self) -> &EntityRef {
        &self.dimensions
    }
}
impl IAmountOfSubstanceUnit for AmountOfSubstanceUnit {}
impl AmountOfSubstanceUnit {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = AmountOfSubstanceUnit::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.dimensions = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IAngleDirectionReference: IRepresentationItemRelationship + IGeometricRepresentationItem {
    fn related_representation_item(&self) -> &EntityRef;
    fn relating_representation_item(&self) -> &EntityRef;
}
#[derive(Default, Debug)]
pub struct AngleDirectionReference {
    name: Label,
    description: Option<Text>,
    related_representation_item: EntityRef,
    relating_representation_item: EntityRef,
}
impl IRepresentationItemRelationship for AngleDirectionReference {
    fn name(&self) -> &Label {
        &self.name
    }
    fn description(&self) -> &Option<Text> {
        &self.description
    }
    fn relating_representation_item(&self) -> &EntityRef {
        &self.relating_representation_item
    }
    fn related_representation_item(&self) -> &EntityRef {
        &self.related_representation_item
    }
}
impl IRepresentationItem for AngleDirectionReference {
    fn name(&self) -> &Label {
        &self.name
    }
}
impl IGeometricRepresentationItem for AngleDirectionReference {}
impl IAngleDirectionReference for AngleDirectionReference {
    fn related_representation_item(&self) -> &EntityRef {
        &self.related_representation_item
    }
    fn relating_representation_item(&self) -> &EntityRef {
        &self.relating_representation_item
    }
}
impl AngleDirectionReference {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = AngleDirectionReference::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => entity.related_representation_item = parameter.into(),
                3usize => entity.relating_representation_item = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IAngularDimension: IDimensionCurveDirectedCallout {}
#[derive(Default, Debug)]
pub struct AngularDimension {
    name: Label,
    contents: HashSet<EntityRef>,
}
impl IRepresentationItem for AngularDimension {
    fn name(&self) -> &Label {
        &self.name
    }
}
impl IGeometricRepresentationItem for AngularDimension {}
impl IDraughtingCallout for AngularDimension {
    fn contents(&self) -> &HashSet<EntityRef> {
        &self.contents
    }
}
impl IDimensionCurveDirectedCallout for AngularDimension {}
impl IAngularDimension for AngularDimension {}
impl AngularDimension {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = AngularDimension::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => entity.contents = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IAngularLocation: IDimensionalLocation {
    fn angle_selection(&self) -> &AngleRelator;
}
#[derive(Default, Debug)]
pub struct AngularLocation {
    name: Label,
    description: Option<Text>,
    relating_shape_aspect: EntityRef,
    related_shape_aspect: EntityRef,
    angle_selection: AngleRelator,
}
impl IShapeAspectRelationship for AngularLocation {
    fn name(&self) -> &Label {
        &self.name
    }
    fn description(&self) -> &Option<Text> {
        &self.description
    }
    fn relating_shape_aspect(&self) -> &EntityRef {
        &self.relating_shape_aspect
    }
    fn related_shape_aspect(&self) -> &EntityRef {
        &self.related_shape_aspect
    }
}
impl IDimensionalLocation for AngularLocation {}
impl IAngularLocation for AngularLocation {
    fn angle_selection(&self) -> &AngleRelator {
        &self.angle_selection
    }
}
impl AngularLocation {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = AngularLocation::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => entity.relating_shape_aspect = parameter.into(),
                3usize => entity.related_shape_aspect = parameter.into(),
                4usize => entity.angle_selection = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IAngularSize: IDimensionalSize {
    fn angle_selection(&self) -> &AngleRelator;
}
#[derive(Default, Debug)]
pub struct AngularSize {
    applies_to: EntityRef,
    name: Label,
    angle_selection: AngleRelator,
}
impl IDimensionalSize for AngularSize {
    fn applies_to(&self) -> &EntityRef {
        &self.applies_to
    }
    fn name(&self) -> &Label {
        &self.name
    }
}
impl IAngularSize for AngularSize {
    fn angle_selection(&self) -> &AngleRelator {
        &self.angle_selection
    }
}
impl AngularSize {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = AngularSize::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.applies_to = parameter.into(),
                1usize => entity.name = parameter.into(),
                2usize => entity.angle_selection = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IAngularityTolerance: IGeometricToleranceWithDatumReference {}
#[derive(Default, Debug)]
pub struct AngularityTolerance {
    name: Label,
    description: Text,
    magnitude: EntityRef,
    toleranced_shape_aspect: EntityRef,
    datum_system: HashSet<EntityRef>,
}
impl IGeometricTolerance for AngularityTolerance {
    fn name(&self) -> &Label {
        &self.name
    }
    fn description(&self) -> &Text {
        &self.description
    }
    fn magnitude(&self) -> &EntityRef {
        &self.magnitude
    }
    fn toleranced_shape_aspect(&self) -> &EntityRef {
        &self.toleranced_shape_aspect
    }
}
impl IGeometricToleranceWithDatumReference for AngularityTolerance {
    fn datum_system(&self) -> &HashSet<EntityRef> {
        &self.datum_system
    }
}
impl IAngularityTolerance for AngularityTolerance {}
impl AngularityTolerance {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = AngularityTolerance::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => entity.description = parameter.into(),
                2usize => entity.magnitude = parameter.into(),
                3usize => entity.toleranced_shape_aspect = parameter.into(),
                4usize => entity.datum_system = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IAnnotationCurveOccurrence: IAnnotationOccurrence {
    fn item(&self) -> &EntityRef;
}
#[derive(Default, Debug)]
pub struct AnnotationCurveOccurrence {
    name: Label,
    styles: HashSet<EntityRef>,
    item: EntityRef,
}
impl IRepresentationItem for AnnotationCurveOccurrence {
    fn name(&self) -> &Label {
        &self.name
    }
}
impl IStyledItem for AnnotationCurveOccurrence {
    fn styles(&self) -> &HashSet<EntityRef> {
        &self.styles
    }
    fn item(&self) -> &EntityRef {
        &self.item
    }
}
impl IAnnotationOccurrence for AnnotationCurveOccurrence {}
impl IAnnotationCurveOccurrence for AnnotationCurveOccurrence {
    fn item(&self) -> &EntityRef {
        &self.item
    }
}
impl AnnotationCurveOccurrence {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = AnnotationCurveOccurrence::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => entity.styles = parameter.into(),
                2usize => entity.item = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IAnnotationFillArea: IGeometricRepresentationItem {
    fn boundaries(&self) -> &HashSet<EntityRef>;
}
#[derive(Default, Debug)]
pub struct AnnotationFillArea {
    name: Label,
    boundaries: HashSet<EntityRef>,
}
impl IRepresentationItem for AnnotationFillArea {
    fn name(&self) -> &Label {
        &self.name
    }
}
impl IGeometricRepresentationItem for AnnotationFillArea {}
impl IAnnotationFillArea for AnnotationFillArea {
    fn boundaries(&self) -> &HashSet<EntityRef> {
        &self.boundaries
    }
}
impl AnnotationFillArea {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = AnnotationFillArea::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => entity.boundaries = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IAnnotationFillAreaOccurrence: IAnnotationOccurrence {
    fn fill_style_target(&self) -> &EntityRef;
    fn item(&self) -> &EntityRef;
}
#[derive(Default, Debug)]
pub struct AnnotationFillAreaOccurrence {
    name: Label,
    styles: HashSet<EntityRef>,
    fill_style_target: EntityRef,
    item: EntityRef,
}
impl IRepresentationItem for AnnotationFillAreaOccurrence {
    fn name(&self) -> &Label {
        &self.name
    }
}
impl IStyledItem for AnnotationFillAreaOccurrence {
    fn styles(&self) -> &HashSet<EntityRef> {
        &self.styles
    }
    fn item(&self) -> &EntityRef {
        &self.item
    }
}
impl IAnnotationOccurrence for AnnotationFillAreaOccurrence {}
impl IAnnotationFillAreaOccurrence for AnnotationFillAreaOccurrence {
    fn fill_style_target(&self) -> &EntityRef {
        &self.fill_style_target
    }
    fn item(&self) -> &EntityRef {
        &self.item
    }
}
impl AnnotationFillAreaOccurrence {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = AnnotationFillAreaOccurrence::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => entity.styles = parameter.into(),
                2usize => entity.fill_style_target = parameter.into(),
                3usize => entity.item = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IAnnotationOccurrence: IStyledItem {}
#[derive(Default, Debug)]
pub struct AnnotationOccurrence {
    name: Label,
    styles: HashSet<EntityRef>,
    item: EntityRef,
}
impl IRepresentationItem for AnnotationOccurrence {
    fn name(&self) -> &Label {
        &self.name
    }
}
impl IStyledItem for AnnotationOccurrence {
    fn styles(&self) -> &HashSet<EntityRef> {
        &self.styles
    }
    fn item(&self) -> &EntityRef {
        &self.item
    }
}
impl IAnnotationOccurrence for AnnotationOccurrence {}
impl AnnotationOccurrence {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = AnnotationOccurrence::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => entity.styles = parameter.into(),
                2usize => entity.item = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IAnnotationOccurrenceAssociativity: IAnnotationOccurrenceRelationship {}
#[derive(Default, Debug)]
pub struct AnnotationOccurrenceAssociativity {
    name: Label,
    description: Text,
    relating_annotation_occurrence: EntityRef,
    related_annotation_occurrence: EntityRef,
}
impl IAnnotationOccurrenceRelationship for AnnotationOccurrenceAssociativity {
    fn name(&self) -> &Label {
        &self.name
    }
    fn description(&self) -> &Text {
        &self.description
    }
    fn relating_annotation_occurrence(&self) -> &EntityRef {
        &self.relating_annotation_occurrence
    }
    fn related_annotation_occurrence(&self) -> &EntityRef {
        &self.related_annotation_occurrence
    }
}
impl IAnnotationOccurrenceAssociativity for AnnotationOccurrenceAssociativity {}
impl AnnotationOccurrenceAssociativity {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = AnnotationOccurrenceAssociativity::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => entity.description = parameter.into(),
                2usize => entity.relating_annotation_occurrence = parameter.into(),
                3usize => entity.related_annotation_occurrence = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IAnnotationOccurrenceRelationship {
    fn name(&self) -> &Label;
    fn description(&self) -> &Text;
    fn relating_annotation_occurrence(&self) -> &EntityRef;
    fn related_annotation_occurrence(&self) -> &EntityRef;
}
#[derive(Default, Debug)]
pub struct AnnotationOccurrenceRelationship {
    name: Label,
    description: Text,
    relating_annotation_occurrence: EntityRef,
    related_annotation_occurrence: EntityRef,
}
impl IAnnotationOccurrenceRelationship for AnnotationOccurrenceRelationship {
    fn name(&self) -> &Label {
        &self.name
    }
    fn description(&self) -> &Text {
        &self.description
    }
    fn relating_annotation_occurrence(&self) -> &EntityRef {
        &self.relating_annotation_occurrence
    }
    fn related_annotation_occurrence(&self) -> &EntityRef {
        &self.related_annotation_occurrence
    }
}
impl AnnotationOccurrenceRelationship {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = AnnotationOccurrenceRelationship::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => entity.description = parameter.into(),
                2usize => entity.relating_annotation_occurrence = parameter.into(),
                3usize => entity.related_annotation_occurrence = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IAnnotationPlane: IAnnotationOccurrence + IGeometricRepresentationItem {
    fn elements(&self) -> &Option<HashSet<EntityRef>>;
    fn item(&self) -> &EntityRef;
}
#[derive(Default, Debug)]
pub struct AnnotationPlane {
    name: Label,
    styles: HashSet<EntityRef>,
    elements: Option<HashSet<EntityRef>>,
    item: EntityRef,
}
impl IRepresentationItem for AnnotationPlane {
    fn name(&self) -> &Label {
        &self.name
    }
}
impl IStyledItem for AnnotationPlane {
    fn styles(&self) -> &HashSet<EntityRef> {
        &self.styles
    }
    fn item(&self) -> &EntityRef {
        &self.item
    }
}
impl IAnnotationOccurrence for AnnotationPlane {}
impl IAnnotationPlane for AnnotationPlane {
    fn elements(&self) -> &Option<HashSet<EntityRef>> {
        &self.elements
    }
    fn item(&self) -> &EntityRef {
        &self.item
    }
}
impl IGeometricRepresentationItem for AnnotationPlane {}
impl AnnotationPlane {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = AnnotationPlane::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => entity.styles = parameter.into(),
                2usize => {
                    entity.elements = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => entity.item = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IAnnotationSubfigureOccurrence: IAnnotationSymbolOccurrence {}
#[derive(Default, Debug)]
pub struct AnnotationSubfigureOccurrence {
    name: Label,
    styles: HashSet<EntityRef>,
    item: EntityRef,
}
impl IRepresentationItem for AnnotationSubfigureOccurrence {
    fn name(&self) -> &Label {
        &self.name
    }
}
impl IStyledItem for AnnotationSubfigureOccurrence {
    fn styles(&self) -> &HashSet<EntityRef> {
        &self.styles
    }
    fn item(&self) -> &EntityRef {
        &self.item
    }
}
impl IAnnotationOccurrence for AnnotationSubfigureOccurrence {}
impl IAnnotationSymbolOccurrence for AnnotationSubfigureOccurrence {
    fn item(&self) -> &EntityRef {
        &self.item
    }
}
impl IAnnotationSubfigureOccurrence for AnnotationSubfigureOccurrence {}
impl AnnotationSubfigureOccurrence {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = AnnotationSubfigureOccurrence::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => entity.styles = parameter.into(),
                2usize => entity.item = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IAnnotationSymbol: IMappedItem {
    fn mapping_source(&self) -> &EntityRef;
    fn mapping_target(&self) -> &EntityRef;
}
#[derive(Default, Debug)]
pub struct AnnotationSymbol {
    name: Label,
    mapping_source: EntityRef,
    mapping_target: EntityRef,
}
impl IRepresentationItem for AnnotationSymbol {
    fn name(&self) -> &Label {
        &self.name
    }
}
impl IMappedItem for AnnotationSymbol {
    fn mapping_source(&self) -> &EntityRef {
        &self.mapping_source
    }
    fn mapping_target(&self) -> &EntityRef {
        &self.mapping_target
    }
}
impl IAnnotationSymbol for AnnotationSymbol {
    fn mapping_source(&self) -> &EntityRef {
        &self.mapping_source
    }
    fn mapping_target(&self) -> &EntityRef {
        &self.mapping_target
    }
}
impl AnnotationSymbol {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = AnnotationSymbol::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => entity.mapping_source = parameter.into(),
                2usize => entity.mapping_target = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IAnnotationSymbolOccurrence: IAnnotationOccurrence {
    fn item(&self) -> &EntityRef;
}
#[derive(Default, Debug)]
pub struct AnnotationSymbolOccurrence {
    name: Label,
    styles: HashSet<EntityRef>,
    item: EntityRef,
}
impl IRepresentationItem for AnnotationSymbolOccurrence {
    fn name(&self) -> &Label {
        &self.name
    }
}
impl IStyledItem for AnnotationSymbolOccurrence {
    fn styles(&self) -> &HashSet<EntityRef> {
        &self.styles
    }
    fn item(&self) -> &EntityRef {
        &self.item
    }
}
impl IAnnotationOccurrence for AnnotationSymbolOccurrence {}
impl IAnnotationSymbolOccurrence for AnnotationSymbolOccurrence {
    fn item(&self) -> &EntityRef {
        &self.item
    }
}
impl AnnotationSymbolOccurrence {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = AnnotationSymbolOccurrence::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => entity.styles = parameter.into(),
                2usize => entity.item = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IAnnotationText: IMappedItem {
    fn mapping_target(&self) -> &EntityRef;
}
#[derive(Default, Debug)]
pub struct AnnotationText {
    name: Label,
    mapping_source: EntityRef,
    mapping_target: EntityRef,
}
impl IRepresentationItem for AnnotationText {
    fn name(&self) -> &Label {
        &self.name
    }
}
impl IMappedItem for AnnotationText {
    fn mapping_source(&self) -> &EntityRef {
        &self.mapping_source
    }
    fn mapping_target(&self) -> &EntityRef {
        &self.mapping_target
    }
}
impl IAnnotationText for AnnotationText {
    fn mapping_target(&self) -> &EntityRef {
        &self.mapping_target
    }
}
impl AnnotationText {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = AnnotationText::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => entity.mapping_source = parameter.into(),
                2usize => entity.mapping_target = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IAnnotationTextCharacter: IMappedItem {
    fn alignment(&self) -> &TextAlignment;
    fn mapping_target(&self) -> &EntityRef;
}
#[derive(Default, Debug)]
pub struct AnnotationTextCharacter {
    name: Label,
    mapping_source: EntityRef,
    alignment: TextAlignment,
    mapping_target: EntityRef,
}
impl IRepresentationItem for AnnotationTextCharacter {
    fn name(&self) -> &Label {
        &self.name
    }
}
impl IMappedItem for AnnotationTextCharacter {
    fn mapping_source(&self) -> &EntityRef {
        &self.mapping_source
    }
    fn mapping_target(&self) -> &EntityRef {
        &self.mapping_target
    }
}
impl IAnnotationTextCharacter for AnnotationTextCharacter {
    fn alignment(&self) -> &TextAlignment {
        &self.alignment
    }
    fn mapping_target(&self) -> &EntityRef {
        &self.mapping_target
    }
}
impl AnnotationTextCharacter {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = AnnotationTextCharacter::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => entity.mapping_source = parameter.into(),
                2usize => entity.alignment = parameter.into(),
                3usize => entity.mapping_target = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IAnnotationTextOccurrence: IAnnotationOccurrence {
    fn item(&self) -> &EntityRef;
}
#[derive(Default, Debug)]
pub struct AnnotationTextOccurrence {
    name: Label,
    styles: HashSet<EntityRef>,
    item: EntityRef,
}
impl IRepresentationItem for AnnotationTextOccurrence {
    fn name(&self) -> &Label {
        &self.name
    }
}
impl IStyledItem for AnnotationTextOccurrence {
    fn styles(&self) -> &HashSet<EntityRef> {
        &self.styles
    }
    fn item(&self) -> &EntityRef {
        &self.item
    }
}
impl IAnnotationOccurrence for AnnotationTextOccurrence {}
impl IAnnotationTextOccurrence for AnnotationTextOccurrence {
    fn item(&self) -> &EntityRef {
        &self.item
    }
}
impl AnnotationTextOccurrence {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = AnnotationTextOccurrence::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => entity.styles = parameter.into(),
                2usize => entity.item = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IApex: IDerivedShapeAspect {}
#[derive(Default, Debug)]
pub struct Apex {
    name: Label,
    description: Option<Text>,
    of_shape: EntityRef,
    product_definitional: Option<bool>,
}
impl IShapeAspect for Apex {
    fn name(&self) -> &Label {
        &self.name
    }
    fn description(&self) -> &Option<Text> {
        &self.description
    }
    fn of_shape(&self) -> &EntityRef {
        &self.of_shape
    }
    fn product_definitional(&self) -> Option<bool> {
        self.product_definitional
    }
}
impl IDerivedShapeAspect for Apex {}
impl IApex for Apex {}
impl Apex {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = Apex::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => entity.of_shape = parameter.into(),
                3usize => entity.product_definitional = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IApplicationContext {
    fn application(&self) -> &Label;
}
#[derive(Default, Debug)]
pub struct ApplicationContext {
    application: Label,
}
impl IApplicationContext for ApplicationContext {
    fn application(&self) -> &Label {
        &self.application
    }
}
impl ApplicationContext {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = ApplicationContext::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.application = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IApplicationContextElement {
    fn name(&self) -> &Label;
    fn frame_of_reference(&self) -> &EntityRef;
}
#[derive(Default, Debug)]
pub struct ApplicationContextElement {
    name: Label,
    frame_of_reference: EntityRef,
}
impl IApplicationContextElement for ApplicationContextElement {
    fn name(&self) -> &Label {
        &self.name
    }
    fn frame_of_reference(&self) -> &EntityRef {
        &self.frame_of_reference
    }
}
impl ApplicationContextElement {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = ApplicationContextElement::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => entity.frame_of_reference = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IApplicationProtocolDefinition {
    fn status(&self) -> &Label;
    fn application_interpreted_model_schema_name(&self) -> &Label;
    fn application_protocol_year(&self) -> &YearNumber;
    fn application(&self) -> &EntityRef;
}
#[derive(Default, Debug)]
pub struct ApplicationProtocolDefinition {
    status: Label,
    application_interpreted_model_schema_name: Label,
    application_protocol_year: YearNumber,
    application: EntityRef,
}
impl IApplicationProtocolDefinition for ApplicationProtocolDefinition {
    fn status(&self) -> &Label {
        &self.status
    }
    fn application_interpreted_model_schema_name(&self) -> &Label {
        &self.application_interpreted_model_schema_name
    }
    fn application_protocol_year(&self) -> &YearNumber {
        &self.application_protocol_year
    }
    fn application(&self) -> &EntityRef {
        &self.application
    }
}
impl ApplicationProtocolDefinition {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = ApplicationProtocolDefinition::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.status = parameter.into(),
                1usize => entity.application_interpreted_model_schema_name = parameter.into(),
                2usize => entity.application_protocol_year = parameter.into(),
                3usize => entity.application = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IAppliedActionAssignment: IActionAssignment {
    fn items(&self) -> &HashSet<ActionItems>;
}
#[derive(Default, Debug)]
pub struct AppliedActionAssignment {
    assigned_action: EntityRef,
    items: HashSet<ActionItems>,
}
impl IActionAssignment for AppliedActionAssignment {
    fn assigned_action(&self) -> &EntityRef {
        &self.assigned_action
    }
}
impl IAppliedActionAssignment for AppliedActionAssignment {
    fn items(&self) -> &HashSet<ActionItems> {
        &self.items
    }
}
impl AppliedActionAssignment {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = AppliedActionAssignment::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.assigned_action = parameter.into(),
                1usize => entity.items = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IAppliedActionMethodAssignment: IActionMethodAssignment {
    fn items(&self) -> &HashSet<EntityRef>;
}
#[derive(Default, Debug)]
pub struct AppliedActionMethodAssignment {
    assigned_action_method: EntityRef,
    role: EntityRef,
    items: HashSet<EntityRef>,
}
impl IActionMethodAssignment for AppliedActionMethodAssignment {
    fn assigned_action_method(&self) -> &EntityRef {
        &self.assigned_action_method
    }
    fn role(&self) -> &EntityRef {
        &self.role
    }
}
impl IAppliedActionMethodAssignment for AppliedActionMethodAssignment {
    fn items(&self) -> &HashSet<EntityRef> {
        &self.items
    }
}
impl AppliedActionMethodAssignment {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = AppliedActionMethodAssignment::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.assigned_action_method = parameter.into(),
                1usize => entity.role = parameter.into(),
                2usize => entity.items = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IAppliedActionRequestAssignment: IActionRequestAssignment {
    fn items(&self) -> &HashSet<EntityRef>;
}
#[derive(Default, Debug)]
pub struct AppliedActionRequestAssignment {
    assigned_action_request: EntityRef,
    items: HashSet<EntityRef>,
}
impl IActionRequestAssignment for AppliedActionRequestAssignment {
    fn assigned_action_request(&self) -> &EntityRef {
        &self.assigned_action_request
    }
}
impl IAppliedActionRequestAssignment for AppliedActionRequestAssignment {
    fn items(&self) -> &HashSet<EntityRef> {
        &self.items
    }
}
impl AppliedActionRequestAssignment {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = AppliedActionRequestAssignment::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.assigned_action_request = parameter.into(),
                1usize => entity.items = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IAppliedApprovalAssignment: IApprovalAssignment {
    fn items(&self) -> &HashSet<EntityRef>;
}
#[derive(Default, Debug)]
pub struct AppliedApprovalAssignment {
    assigned_approval: EntityRef,
    items: HashSet<EntityRef>,
}
impl IApprovalAssignment for AppliedApprovalAssignment {
    fn assigned_approval(&self) -> &EntityRef {
        &self.assigned_approval
    }
}
impl IAppliedApprovalAssignment for AppliedApprovalAssignment {
    fn items(&self) -> &HashSet<EntityRef> {
        &self.items
    }
}
impl AppliedApprovalAssignment {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = AppliedApprovalAssignment::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.assigned_approval = parameter.into(),
                1usize => entity.items = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IAppliedAttributeClassificationAssignment: IAttributeClassificationAssignment {
    fn items(&self) -> &HashSet<EntityRef>;
    fn assigned_class(&self) -> &EntityRef;
}
#[derive(Default, Debug)]
pub struct AppliedAttributeClassificationAssignment {
    attribute_name: Label,
    role: EntityRef,
    items: HashSet<EntityRef>,
    assigned_class: EntityRef,
}
impl IAttributeClassificationAssignment for AppliedAttributeClassificationAssignment {
    fn assigned_class(&self) -> &EntityRef {
        &self.assigned_class
    }
    fn attribute_name(&self) -> &Label {
        &self.attribute_name
    }
    fn role(&self) -> &EntityRef {
        &self.role
    }
}
impl IAppliedAttributeClassificationAssignment for AppliedAttributeClassificationAssignment {
    fn items(&self) -> &HashSet<EntityRef> {
        &self.items
    }
    fn assigned_class(&self) -> &EntityRef {
        &self.assigned_class
    }
}
impl AppliedAttributeClassificationAssignment {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = AppliedAttributeClassificationAssignment::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.attribute_name = parameter.into(),
                1usize => entity.role = parameter.into(),
                2usize => entity.items = parameter.into(),
                3usize => entity.assigned_class = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IAppliedCertificationAssignment: ICertificationAssignment {
    fn items(&self) -> &HashSet<EntityRef>;
}
#[derive(Default, Debug)]
pub struct AppliedCertificationAssignment {
    assigned_certification: EntityRef,
    items: HashSet<EntityRef>,
}
impl ICertificationAssignment for AppliedCertificationAssignment {
    fn assigned_certification(&self) -> &EntityRef {
        &self.assigned_certification
    }
}
impl IAppliedCertificationAssignment for AppliedCertificationAssignment {
    fn items(&self) -> &HashSet<EntityRef> {
        &self.items
    }
}
impl AppliedCertificationAssignment {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = AppliedCertificationAssignment::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.assigned_certification = parameter.into(),
                1usize => entity.items = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IAppliedClassificationAssignment: IClassificationAssignment {
    fn items(&self) -> &HashSet<EntityRef>;
}
#[derive(Default, Debug)]
pub struct AppliedClassificationAssignment {
    assigned_class: EntityRef,
    role: EntityRef,
    items: HashSet<EntityRef>,
}
impl IClassificationAssignment for AppliedClassificationAssignment {
    fn assigned_class(&self) -> &EntityRef {
        &self.assigned_class
    }
    fn role(&self) -> &EntityRef {
        &self.role
    }
}
impl IAppliedClassificationAssignment for AppliedClassificationAssignment {
    fn items(&self) -> &HashSet<EntityRef> {
        &self.items
    }
}
impl AppliedClassificationAssignment {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = AppliedClassificationAssignment::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.assigned_class = parameter.into(),
                1usize => entity.role = parameter.into(),
                2usize => entity.items = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IAppliedContractAssignment: IContractAssignment {
    fn items(&self) -> &HashSet<EntityRef>;
}
#[derive(Default, Debug)]
pub struct AppliedContractAssignment {
    assigned_contract: EntityRef,
    items: HashSet<EntityRef>,
}
impl IContractAssignment for AppliedContractAssignment {
    fn assigned_contract(&self) -> &EntityRef {
        &self.assigned_contract
    }
}
impl IAppliedContractAssignment for AppliedContractAssignment {
    fn items(&self) -> &HashSet<EntityRef> {
        &self.items
    }
}
impl AppliedContractAssignment {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = AppliedContractAssignment::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.assigned_contract = parameter.into(),
                1usize => entity.items = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IAppliedDateAndTimeAssignment: IDateAndTimeAssignment {
    fn items(&self) -> &HashSet<EntityRef>;
}
#[derive(Default, Debug)]
pub struct AppliedDateAndTimeAssignment {
    assigned_date_and_time: EntityRef,
    role: EntityRef,
    items: HashSet<EntityRef>,
}
impl IDateAndTimeAssignment for AppliedDateAndTimeAssignment {
    fn assigned_date_and_time(&self) -> &EntityRef {
        &self.assigned_date_and_time
    }
    fn role(&self) -> &EntityRef {
        &self.role
    }
}
impl IAppliedDateAndTimeAssignment for AppliedDateAndTimeAssignment {
    fn items(&self) -> &HashSet<EntityRef> {
        &self.items
    }
}
impl AppliedDateAndTimeAssignment {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = AppliedDateAndTimeAssignment::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.assigned_date_and_time = parameter.into(),
                1usize => entity.role = parameter.into(),
                2usize => entity.items = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IAppliedDateAssignment: IDateAssignment {
    fn items(&self) -> &HashSet<EntityRef>;
}
#[derive(Default, Debug)]
pub struct AppliedDateAssignment {
    assigned_date: EntityRef,
    role: EntityRef,
    items: HashSet<EntityRef>,
}
impl IDateAssignment for AppliedDateAssignment {
    fn assigned_date(&self) -> &EntityRef {
        &self.assigned_date
    }
    fn role(&self) -> &EntityRef {
        &self.role
    }
}
impl IAppliedDateAssignment for AppliedDateAssignment {
    fn items(&self) -> &HashSet<EntityRef> {
        &self.items
    }
}
impl AppliedDateAssignment {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = AppliedDateAssignment::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.assigned_date = parameter.into(),
                1usize => entity.role = parameter.into(),
                2usize => entity.items = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IAppliedDocumentReference: IDocumentReference {
    fn items(&self) -> &HashSet<EntityRef>;
}
#[derive(Default, Debug)]
pub struct AppliedDocumentReference {
    assigned_document: EntityRef,
    source: Label,
    items: HashSet<EntityRef>,
}
impl IDocumentReference for AppliedDocumentReference {
    fn assigned_document(&self) -> &EntityRef {
        &self.assigned_document
    }
    fn source(&self) -> &Label {
        &self.source
    }
}
impl IAppliedDocumentReference for AppliedDocumentReference {
    fn items(&self) -> &HashSet<EntityRef> {
        &self.items
    }
}
impl AppliedDocumentReference {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = AppliedDocumentReference::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.assigned_document = parameter.into(),
                1usize => entity.source = parameter.into(),
                2usize => entity.items = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IAppliedDocumentUsageConstraintAssignment: IDocumentUsageConstraintAssignment {
    fn items(&self) -> &HashSet<EntityRef>;
}
#[derive(Default, Debug)]
pub struct AppliedDocumentUsageConstraintAssignment {
    assigned_document_usage: EntityRef,
    role: EntityRef,
    items: HashSet<EntityRef>,
}
impl IDocumentUsageConstraintAssignment for AppliedDocumentUsageConstraintAssignment {
    fn assigned_document_usage(&self) -> &EntityRef {
        &self.assigned_document_usage
    }
    fn role(&self) -> &EntityRef {
        &self.role
    }
}
impl IAppliedDocumentUsageConstraintAssignment for AppliedDocumentUsageConstraintAssignment {
    fn items(&self) -> &HashSet<EntityRef> {
        &self.items
    }
}
impl AppliedDocumentUsageConstraintAssignment {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = AppliedDocumentUsageConstraintAssignment::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.assigned_document_usage = parameter.into(),
                1usize => entity.role = parameter.into(),
                2usize => entity.items = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IAppliedEffectivityAssignment: IEffectivityAssignment {
    fn items(&self) -> &HashSet<EntityRef>;
}
#[derive(Default, Debug)]
pub struct AppliedEffectivityAssignment {
    assigned_effectivity: EntityRef,
    items: HashSet<EntityRef>,
}
impl IEffectivityAssignment for AppliedEffectivityAssignment {
    fn assigned_effectivity(&self) -> &EntityRef {
        &self.assigned_effectivity
    }
}
impl IAppliedEffectivityAssignment for AppliedEffectivityAssignment {
    fn items(&self) -> &HashSet<EntityRef> {
        &self.items
    }
}
impl AppliedEffectivityAssignment {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = AppliedEffectivityAssignment::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.assigned_effectivity = parameter.into(),
                1usize => entity.items = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IAppliedEventOccurrenceAssignment: IEventOccurrenceAssignment {
    fn items(&self) -> &HashSet<EntityRef>;
}
#[derive(Default, Debug)]
pub struct AppliedEventOccurrenceAssignment {
    assigned_event_occurrence: EntityRef,
    role: EntityRef,
    items: HashSet<EntityRef>,
}
impl IEventOccurrenceAssignment for AppliedEventOccurrenceAssignment {
    fn assigned_event_occurrence(&self) -> &EntityRef {
        &self.assigned_event_occurrence
    }
    fn role(&self) -> &EntityRef {
        &self.role
    }
}
impl IAppliedEventOccurrenceAssignment for AppliedEventOccurrenceAssignment {
    fn items(&self) -> &HashSet<EntityRef> {
        &self.items
    }
}
impl AppliedEventOccurrenceAssignment {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = AppliedEventOccurrenceAssignment::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.assigned_event_occurrence = parameter.into(),
                1usize => entity.role = parameter.into(),
                2usize => entity.items = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IAppliedExternalIdentificationAssignment: IExternalIdentificationAssignment {
    fn items(&self) -> &HashSet<EntityRef>;
}
#[derive(Default, Debug)]
pub struct AppliedExternalIdentificationAssignment {
    assigned_id: Identifier,
    role: EntityRef,
    source: EntityRef,
    items: HashSet<EntityRef>,
}
impl IIdentificationAssignment for AppliedExternalIdentificationAssignment {
    fn assigned_id(&self) -> &Identifier {
        &self.assigned_id
    }
    fn role(&self) -> &EntityRef {
        &self.role
    }
}
impl IExternalIdentificationAssignment for AppliedExternalIdentificationAssignment {
    fn source(&self) -> &EntityRef {
        &self.source
    }
}
impl IAppliedExternalIdentificationAssignment for AppliedExternalIdentificationAssignment {
    fn items(&self) -> &HashSet<EntityRef> {
        &self.items
    }
}
impl AppliedExternalIdentificationAssignment {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = AppliedExternalIdentificationAssignment::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.assigned_id = parameter.into(),
                1usize => entity.role = parameter.into(),
                2usize => entity.source = parameter.into(),
                3usize => entity.items = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IAppliedGroupAssignment: IGroupAssignment {
    fn items(&self) -> &HashSet<EntityRef>;
}
#[derive(Default, Debug)]
pub struct AppliedGroupAssignment {
    assigned_group: EntityRef,
    items: HashSet<EntityRef>,
}
impl IGroupAssignment for AppliedGroupAssignment {
    fn assigned_group(&self) -> &EntityRef {
        &self.assigned_group
    }
}
impl IAppliedGroupAssignment for AppliedGroupAssignment {
    fn items(&self) -> &HashSet<EntityRef> {
        &self.items
    }
}
impl AppliedGroupAssignment {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = AppliedGroupAssignment::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.assigned_group = parameter.into(),
                1usize => entity.items = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IAppliedIdentificationAssignment: IIdentificationAssignment {
    fn items(&self) -> &HashSet<EntityRef>;
}
#[derive(Default, Debug)]
pub struct AppliedIdentificationAssignment {
    assigned_id: Identifier,
    role: EntityRef,
    items: HashSet<EntityRef>,
}
impl IIdentificationAssignment for AppliedIdentificationAssignment {
    fn assigned_id(&self) -> &Identifier {
        &self.assigned_id
    }
    fn role(&self) -> &EntityRef {
        &self.role
    }
}
impl IAppliedIdentificationAssignment for AppliedIdentificationAssignment {
    fn items(&self) -> &HashSet<EntityRef> {
        &self.items
    }
}
impl AppliedIdentificationAssignment {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = AppliedIdentificationAssignment::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.assigned_id = parameter.into(),
                1usize => entity.role = parameter.into(),
                2usize => entity.items = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IAppliedNameAssignment: INameAssignment {
    fn item(&self) -> &EntityRef;
}
#[derive(Default, Debug)]
pub struct AppliedNameAssignment {
    assigned_name: Label,
    item: EntityRef,
}
impl INameAssignment for AppliedNameAssignment {
    fn assigned_name(&self) -> &Label {
        &self.assigned_name
    }
}
impl IAppliedNameAssignment for AppliedNameAssignment {
    fn item(&self) -> &EntityRef {
        &self.item
    }
}
impl AppliedNameAssignment {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = AppliedNameAssignment::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.assigned_name = parameter.into(),
                1usize => entity.item = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IAppliedOrganizationAssignment: IOrganizationAssignment {
    fn items(&self) -> &HashSet<EntityRef>;
}
#[derive(Default, Debug)]
pub struct AppliedOrganizationAssignment {
    assigned_organization: EntityRef,
    role: EntityRef,
    items: HashSet<EntityRef>,
}
impl IOrganizationAssignment for AppliedOrganizationAssignment {
    fn assigned_organization(&self) -> &EntityRef {
        &self.assigned_organization
    }
    fn role(&self) -> &EntityRef {
        &self.role
    }
}
impl IAppliedOrganizationAssignment for AppliedOrganizationAssignment {
    fn items(&self) -> &HashSet<EntityRef> {
        &self.items
    }
}
impl AppliedOrganizationAssignment {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = AppliedOrganizationAssignment::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.assigned_organization = parameter.into(),
                1usize => entity.role = parameter.into(),
                2usize => entity.items = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IAppliedOrganizationalProjectAssignment: IOrganizationalProjectAssignment {
    fn items(&self) -> &HashSet<EntityRef>;
}
#[derive(Default, Debug)]
pub struct AppliedOrganizationalProjectAssignment {
    assigned_organizational_project: EntityRef,
    role: EntityRef,
    items: HashSet<EntityRef>,
}
impl IOrganizationalProjectAssignment for AppliedOrganizationalProjectAssignment {
    fn assigned_organizational_project(&self) -> &EntityRef {
        &self.assigned_organizational_project
    }
    fn role(&self) -> &EntityRef {
        &self.role
    }
}
impl IAppliedOrganizationalProjectAssignment for AppliedOrganizationalProjectAssignment {
    fn items(&self) -> &HashSet<EntityRef> {
        &self.items
    }
}
impl AppliedOrganizationalProjectAssignment {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = AppliedOrganizationalProjectAssignment::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.assigned_organizational_project = parameter.into(),
                1usize => entity.role = parameter.into(),
                2usize => entity.items = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IAppliedPersonAndOrganizationAssignment: IPersonAndOrganizationAssignment {
    fn items(&self) -> &HashSet<EntityRef>;
}
#[derive(Default, Debug)]
pub struct AppliedPersonAndOrganizationAssignment {
    assigned_person_and_organization: EntityRef,
    role: EntityRef,
    items: HashSet<EntityRef>,
}
impl IPersonAndOrganizationAssignment for AppliedPersonAndOrganizationAssignment {
    fn assigned_person_and_organization(&self) -> &EntityRef {
        &self.assigned_person_and_organization
    }
    fn role(&self) -> &EntityRef {
        &self.role
    }
}
impl IAppliedPersonAndOrganizationAssignment for AppliedPersonAndOrganizationAssignment {
    fn items(&self) -> &HashSet<EntityRef> {
        &self.items
    }
}
impl AppliedPersonAndOrganizationAssignment {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = AppliedPersonAndOrganizationAssignment::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.assigned_person_and_organization = parameter.into(),
                1usize => entity.role = parameter.into(),
                2usize => entity.items = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IAppliedPresentedItem: IPresentedItem {
    fn items(&self) -> &HashSet<EntityRef>;
}
#[derive(Default, Debug)]
pub struct AppliedPresentedItem {
    items: HashSet<EntityRef>,
}
impl IPresentedItem for AppliedPresentedItem {}
impl IAppliedPresentedItem for AppliedPresentedItem {
    fn items(&self) -> &HashSet<EntityRef> {
        &self.items
    }
}
impl AppliedPresentedItem {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = AppliedPresentedItem::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.items = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IAppliedSecurityClassificationAssignment: ISecurityClassificationAssignment {
    fn items(&self) -> &HashSet<EntityRef>;
}
#[derive(Default, Debug)]
pub struct AppliedSecurityClassificationAssignment {
    assigned_security_classification: EntityRef,
    items: HashSet<EntityRef>,
}
impl ISecurityClassificationAssignment for AppliedSecurityClassificationAssignment {
    fn assigned_security_classification(&self) -> &EntityRef {
        &self.assigned_security_classification
    }
}
impl IAppliedSecurityClassificationAssignment for AppliedSecurityClassificationAssignment {
    fn items(&self) -> &HashSet<EntityRef> {
        &self.items
    }
}
impl AppliedSecurityClassificationAssignment {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = AppliedSecurityClassificationAssignment::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.assigned_security_classification = parameter.into(),
                1usize => entity.items = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IAppliedTimeIntervalAssignment: ITimeIntervalAssignment {
    fn items(&self) -> &HashSet<EntityRef>;
}
#[derive(Default, Debug)]
pub struct AppliedTimeIntervalAssignment {
    assigned_time_interval: EntityRef,
    role: EntityRef,
    items: HashSet<EntityRef>,
}
impl ITimeIntervalAssignment for AppliedTimeIntervalAssignment {
    fn assigned_time_interval(&self) -> &EntityRef {
        &self.assigned_time_interval
    }
    fn role(&self) -> &EntityRef {
        &self.role
    }
}
impl IAppliedTimeIntervalAssignment for AppliedTimeIntervalAssignment {
    fn items(&self) -> &HashSet<EntityRef> {
        &self.items
    }
}
impl AppliedTimeIntervalAssignment {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = AppliedTimeIntervalAssignment::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.assigned_time_interval = parameter.into(),
                1usize => entity.role = parameter.into(),
                2usize => entity.items = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IAppliedUsageRight: IAppliedActionAssignment {
    fn items(&self) -> &HashSet<IrUsageItem>;
}
#[derive(Default, Debug)]
pub struct AppliedUsageRight {
    assigned_action: EntityRef,
    items: HashSet<IrUsageItem>,
}
impl IActionAssignment for AppliedUsageRight {
    fn assigned_action(&self) -> &EntityRef {
        &self.assigned_action
    }
}
impl IAppliedActionAssignment for AppliedUsageRight {
    fn items(&self) -> &HashSet<ActionItems> {
        unimplemented!()
    }
}
impl IAppliedUsageRight for AppliedUsageRight {
    fn items(&self) -> &HashSet<IrUsageItem> {
        &self.items
    }
}
impl AppliedUsageRight {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = AppliedUsageRight::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.assigned_action = parameter.into(),
                1usize => entity.items = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IApproval {
    fn status(&self) -> &EntityRef;
    fn level(&self) -> &Label;
}
#[derive(Default, Debug)]
pub struct Approval {
    status: EntityRef,
    level: Label,
}
impl IApproval for Approval {
    fn status(&self) -> &EntityRef {
        &self.status
    }
    fn level(&self) -> &Label {
        &self.level
    }
}
impl Approval {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = Approval::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.status = parameter.into(),
                1usize => entity.level = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IApprovalAssignment {
    fn assigned_approval(&self) -> &EntityRef;
}
pub trait IApprovalDateTime {
    fn date_time(&self) -> &EntityRef;
    fn dated_approval(&self) -> &EntityRef;
}
#[derive(Default, Debug)]
pub struct ApprovalDateTime {
    date_time: EntityRef,
    dated_approval: EntityRef,
}
impl IApprovalDateTime for ApprovalDateTime {
    fn date_time(&self) -> &EntityRef {
        &self.date_time
    }
    fn dated_approval(&self) -> &EntityRef {
        &self.dated_approval
    }
}
impl ApprovalDateTime {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = ApprovalDateTime::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.date_time = parameter.into(),
                1usize => entity.dated_approval = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IApprovalPersonOrganization {
    fn person_organization(&self) -> &EntityRef;
    fn authorized_approval(&self) -> &EntityRef;
    fn role(&self) -> &EntityRef;
}
#[derive(Default, Debug)]
pub struct ApprovalPersonOrganization {
    person_organization: EntityRef,
    authorized_approval: EntityRef,
    role: EntityRef,
}
impl IApprovalPersonOrganization for ApprovalPersonOrganization {
    fn person_organization(&self) -> &EntityRef {
        &self.person_organization
    }
    fn authorized_approval(&self) -> &EntityRef {
        &self.authorized_approval
    }
    fn role(&self) -> &EntityRef {
        &self.role
    }
}
impl ApprovalPersonOrganization {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = ApprovalPersonOrganization::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.person_organization = parameter.into(),
                1usize => entity.authorized_approval = parameter.into(),
                2usize => entity.role = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IApprovalRelationship {
    fn name(&self) -> &Label;
    fn description(&self) -> &Option<Text>;
    fn relating_approval(&self) -> &EntityRef;
    fn related_approval(&self) -> &EntityRef;
}
#[derive(Default, Debug)]
pub struct ApprovalRelationship {
    name: Label,
    description: Option<Text>,
    relating_approval: EntityRef,
    related_approval: EntityRef,
}
impl IApprovalRelationship for ApprovalRelationship {
    fn name(&self) -> &Label {
        &self.name
    }
    fn description(&self) -> &Option<Text> {
        &self.description
    }
    fn relating_approval(&self) -> &EntityRef {
        &self.relating_approval
    }
    fn related_approval(&self) -> &EntityRef {
        &self.related_approval
    }
}
impl ApprovalRelationship {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = ApprovalRelationship::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => entity.relating_approval = parameter.into(),
                3usize => entity.related_approval = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IApprovalRole {
    fn role(&self) -> &Label;
}
#[derive(Default, Debug)]
pub struct ApprovalRole {
    role: Label,
}
impl IApprovalRole for ApprovalRole {
    fn role(&self) -> &Label {
        &self.role
    }
}
impl ApprovalRole {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = ApprovalRole::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.role = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IApprovalStatus {
    fn name(&self) -> &Label;
}
#[derive(Default, Debug)]
pub struct ApprovalStatus {
    name: Label,
}
impl IApprovalStatus for ApprovalStatus {
    fn name(&self) -> &Label {
        &self.name
    }
}
impl ApprovalStatus {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = ApprovalStatus::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IAreaDependentAnnotationRepresentation: IPresentationRepresentation {
    fn items(&self) -> &HashSet<EntityRef>;
}
#[derive(Default, Debug)]
pub struct AreaDependentAnnotationRepresentation {
    name: Label,
    context_of_items: EntityRef,
    items: HashSet<EntityRef>,
}
impl IRepresentation for AreaDependentAnnotationRepresentation {
    fn name(&self) -> &Label {
        &self.name
    }
    fn items(&self) -> &HashSet<EntityRef> {
        &self.items
    }
    fn context_of_items(&self) -> &EntityRef {
        &self.context_of_items
    }
}
impl IPresentationRepresentation for AreaDependentAnnotationRepresentation {
    fn context_of_items(&self) -> &EntityRef {
        &self.context_of_items
    }
}
impl IAreaDependentAnnotationRepresentation for AreaDependentAnnotationRepresentation {
    fn items(&self) -> &HashSet<EntityRef> {
        &self.items
    }
}
impl AreaDependentAnnotationRepresentation {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = AreaDependentAnnotationRepresentation::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => entity.context_of_items = parameter.into(),
                2usize => entity.items = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IAreaInSet {
    fn area(&self) -> &EntityRef;
    fn in_set(&self) -> &EntityRef;
}
#[derive(Default, Debug)]
pub struct AreaInSet {
    area: EntityRef,
    in_set: EntityRef,
}
impl IAreaInSet for AreaInSet {
    fn area(&self) -> &EntityRef {
        &self.area
    }
    fn in_set(&self) -> &EntityRef {
        &self.in_set
    }
}
impl AreaInSet {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = AreaInSet::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.area = parameter.into(),
                1usize => entity.in_set = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IAreaMeasureWithUnit: IMeasureWithUnit {}
#[derive(Default, Debug)]
pub struct AreaMeasureWithUnit {
    value_component: MeasureValue,
    unit_component: EntityRef,
}
impl IMeasureWithUnit for AreaMeasureWithUnit {
    fn value_component(&self) -> &MeasureValue {
        &self.value_component
    }
    fn unit_component(&self) -> &EntityRef {
        &self.unit_component
    }
}
impl IAreaMeasureWithUnit for AreaMeasureWithUnit {}
impl AreaMeasureWithUnit {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = AreaMeasureWithUnit::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.value_component = parameter.into(),
                1usize => entity.unit_component = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IAreaUnit: IDerivedUnit {}
#[derive(Default, Debug)]
pub struct AreaUnit {
    elements: HashSet<EntityRef>,
}
impl IDerivedUnit for AreaUnit {
    fn elements(&self) -> &HashSet<EntityRef> {
        &self.elements
    }
}
impl IAreaUnit for AreaUnit {}
impl AreaUnit {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = AreaUnit::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.elements = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IAssemblyComponentUsage: IProductDefinitionUsage {
    fn reference_designator(&self) -> &Option<Identifier>;
}
#[derive(Default, Debug)]
pub struct AssemblyComponentUsage {
    id: Identifier,
    name: Label,
    description: Option<Text>,
    relating_product_definition: EntityRef,
    related_product_definition: EntityRef,
    reference_designator: Option<Identifier>,
}
impl IProductDefinitionRelationship for AssemblyComponentUsage {
    fn id(&self) -> &Identifier {
        &self.id
    }
    fn name(&self) -> &Label {
        &self.name
    }
    fn description(&self) -> &Option<Text> {
        &self.description
    }
    fn relating_product_definition(&self) -> &EntityRef {
        &self.relating_product_definition
    }
    fn related_product_definition(&self) -> &EntityRef {
        &self.related_product_definition
    }
}
impl IProductDefinitionUsage for AssemblyComponentUsage {}
impl IAssemblyComponentUsage for AssemblyComponentUsage {
    fn reference_designator(&self) -> &Option<Identifier> {
        &self.reference_designator
    }
}
impl AssemblyComponentUsage {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = AssemblyComponentUsage::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.id = parameter.into(),
                1usize => entity.name = parameter.into(),
                2usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => entity.relating_product_definition = parameter.into(),
                4usize => entity.related_product_definition = parameter.into(),
                5usize => {
                    entity.reference_designator = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
}
pub trait IAssemblyComponentUsageSubstitute {
    fn name(&self) -> &Label;
    fn definition(&self) -> &Option<Text>;
    fn base(&self) -> &EntityRef;
    fn substitute(&self) -> &EntityRef;
}
#[derive(Default, Debug)]
pub struct AssemblyComponentUsageSubstitute {
    name: Label,
    definition: Option<Text>,
    base: EntityRef,
    substitute: EntityRef,
}
impl IAssemblyComponentUsageSubstitute for AssemblyComponentUsageSubstitute {
    fn name(&self) -> &Label {
        &self.name
    }
    fn definition(&self) -> &Option<Text> {
        &self.definition
    }
    fn base(&self) -> &EntityRef {
        &self.base
    }
    fn substitute(&self) -> &EntityRef {
        &self.substitute
    }
}
impl AssemblyComponentUsageSubstitute {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = AssemblyComponentUsageSubstitute::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => {
                    entity.definition = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => entity.base = parameter.into(),
                3usize => entity.substitute = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IAssignedRequirement: IGroupAssignment {
    fn items(&self) -> &HashSet<EntityRef>;
    fn assigned_group(&self) -> &EntityRef;
}
#[derive(Default, Debug)]
pub struct AssignedRequirement {
    items: HashSet<EntityRef>,
    assigned_group: EntityRef,
}
impl IGroupAssignment for AssignedRequirement {
    fn assigned_group(&self) -> &EntityRef {
        &self.assigned_group
    }
}
impl IAssignedRequirement for AssignedRequirement {
    fn items(&self) -> &HashSet<EntityRef> {
        &self.items
    }
    fn assigned_group(&self) -> &EntityRef {
        &self.assigned_group
    }
}
impl AssignedRequirement {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = AssignedRequirement::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.items = parameter.into(),
                1usize => entity.assigned_group = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IAtomicFormula: ICompoundRepresentationItem {}
#[derive(Default, Debug)]
pub struct AtomicFormula {
    name: Label,
    item_element: CompoundItemDefinition,
}
impl IRepresentationItem for AtomicFormula {
    fn name(&self) -> &Label {
        &self.name
    }
}
impl ICompoundRepresentationItem for AtomicFormula {
    fn item_element(&self) -> &CompoundItemDefinition {
        &self.item_element
    }
}
impl IAtomicFormula for AtomicFormula {}
impl AtomicFormula {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = AtomicFormula::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => entity.item_element = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IAttributeAssertion: IFactType + IPropertyDefinitionRepresentation + IRepresentation {}
#[derive(Default, Debug)]
pub struct AttributeAssertion {
    name: Label,
    description: Option<Text>,
    definition: EntityRef,
    used_representation: EntityRef,
    items: HashSet<EntityRef>,
    context_of_items: EntityRef,
}
impl IPropertyDefinition for AttributeAssertion {
    fn name(&self) -> &Label {
        &self.name
    }
    fn description(&self) -> &Option<Text> {
        &self.description
    }
    fn definition(&self) -> &EntityRef {
        &self.definition
    }
}
impl IFactType for AttributeAssertion {}
impl IPropertyDefinitionRepresentation for AttributeAssertion {
    fn definition(&self) -> &EntityRef {
        &self.definition
    }
    fn used_representation(&self) -> &EntityRef {
        &self.used_representation
    }
}
impl IRepresentation for AttributeAssertion {
    fn name(&self) -> &Label {
        &self.name
    }
    fn items(&self) -> &HashSet<EntityRef> {
        &self.items
    }
    fn context_of_items(&self) -> &EntityRef {
        &self.context_of_items
    }
}
impl IAttributeAssertion for AttributeAssertion {}
impl AttributeAssertion {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = AttributeAssertion::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => entity.definition = parameter.into(),
                3usize => entity.used_representation = parameter.into(),
                4usize => entity.items = parameter.into(),
                5usize => entity.context_of_items = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IAttributeClassificationAssignment {
    fn assigned_class(&self) -> &EntityRef;
    fn attribute_name(&self) -> &Label;
    fn role(&self) -> &EntityRef;
}
pub trait IAttributeLanguageAssignment: IAttributeClassificationAssignment {
    fn items(&self) -> &HashSet<EntityRef>;
    fn assigned_class(&self) -> &EntityRef;
}
#[derive(Default, Debug)]
pub struct AttributeLanguageAssignment {
    attribute_name: Label,
    role: EntityRef,
    items: HashSet<EntityRef>,
    assigned_class: EntityRef,
}
impl IAttributeClassificationAssignment for AttributeLanguageAssignment {
    fn assigned_class(&self) -> &EntityRef {
        &self.assigned_class
    }
    fn attribute_name(&self) -> &Label {
        &self.attribute_name
    }
    fn role(&self) -> &EntityRef {
        &self.role
    }
}
impl IAttributeLanguageAssignment for AttributeLanguageAssignment {
    fn items(&self) -> &HashSet<EntityRef> {
        &self.items
    }
    fn assigned_class(&self) -> &EntityRef {
        &self.assigned_class
    }
}
impl AttributeLanguageAssignment {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = AttributeLanguageAssignment::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.attribute_name = parameter.into(),
                1usize => entity.role = parameter.into(),
                2usize => entity.items = parameter.into(),
                3usize => entity.assigned_class = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IAttributeValueAssignment {
    fn attribute_name(&self) -> &Label;
    fn attribute_value(&self) -> &AttributeType;
    fn role(&self) -> &EntityRef;
}
pub trait IAttributeValueRole {
    fn name(&self) -> &Label;
    fn description(&self) -> &Option<Text>;
}
#[derive(Default, Debug)]
pub struct AttributeValueRole {
    name: Label,
    description: Option<Text>,
}
impl IAttributeValueRole for AttributeValueRole {
    fn name(&self) -> &Label {
        &self.name
    }
    fn description(&self) -> &Option<Text> {
        &self.description
    }
}
impl AttributeValueRole {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = AttributeValueRole::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
}
pub trait IAuxiliaryGeometricRepresentationItem: IGeometricRepresentationItem + IVariationalRepresentationItem {}
#[derive(Default, Debug)]
pub struct AuxiliaryGeometricRepresentationItem {
    name: Label,
}
impl IRepresentationItem for AuxiliaryGeometricRepresentationItem {
    fn name(&self) -> &Label {
        &self.name
    }
}
impl IGeometricRepresentationItem for AuxiliaryGeometricRepresentationItem {}
impl IAuxiliaryGeometricRepresentationItem for AuxiliaryGeometricRepresentationItem {}
impl IVariationalRepresentationItem for AuxiliaryGeometricRepresentationItem {}
impl AuxiliaryGeometricRepresentationItem {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = AuxiliaryGeometricRepresentationItem::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IAxis1Placement: IPlacement {
    fn axis(&self) -> &Option<EntityRef>;
}
#[derive(Default, Debug)]
pub struct Axis1Placement {
    name: Label,
    location: EntityRef,
    axis: Option<EntityRef>,
}
impl IRepresentationItem for Axis1Placement {
    fn name(&self) -> &Label {
        &self.name
    }
}
impl IGeometricRepresentationItem for Axis1Placement {}
impl IPlacement for Axis1Placement {
    fn location(&self) -> &EntityRef {
        &self.location
    }
}
impl IAxis1Placement for Axis1Placement {
    fn axis(&self) -> &Option<EntityRef> {
        &self.axis
    }
}
impl Axis1Placement {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = Axis1Placement::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => entity.location = parameter.into(),
                2usize => {
                    entity.axis = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
}
pub trait IAxis2Placement2d: IPlacement {
    fn ref_direction(&self) -> &Option<EntityRef>;
}
#[derive(Default, Debug)]
pub struct Axis2Placement2d {
    name: Label,
    location: EntityRef,
    ref_direction: Option<EntityRef>,
}
impl IRepresentationItem for Axis2Placement2d {
    fn name(&self) -> &Label {
        &self.name
    }
}
impl IGeometricRepresentationItem for Axis2Placement2d {}
impl IPlacement for Axis2Placement2d {
    fn location(&self) -> &EntityRef {
        &self.location
    }
}
impl IAxis2Placement2d for Axis2Placement2d {
    fn ref_direction(&self) -> &Option<EntityRef> {
        &self.ref_direction
    }
}
impl Axis2Placement2d {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = Axis2Placement2d::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => entity.location = parameter.into(),
                2usize => {
                    entity.ref_direction = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
}
pub trait IAxis2Placement3d: IPlacement {
    fn axis(&self) -> &Option<EntityRef>;
    fn ref_direction(&self) -> &Option<EntityRef>;
}
#[derive(Default, Debug)]
pub struct Axis2Placement3d {
    name: Label,
    location: EntityRef,
    axis: Option<EntityRef>,
    ref_direction: Option<EntityRef>,
}
impl IRepresentationItem for Axis2Placement3d {
    fn name(&self) -> &Label {
        &self.name
    }
}
impl IGeometricRepresentationItem for Axis2Placement3d {}
impl IPlacement for Axis2Placement3d {
    fn location(&self) -> &EntityRef {
        &self.location
    }
}
impl IAxis2Placement3d for Axis2Placement3d {
    fn axis(&self) -> &Option<EntityRef> {
        &self.axis
    }
    fn ref_direction(&self) -> &Option<EntityRef> {
        &self.ref_direction
    }
}
impl Axis2Placement3d {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = Axis2Placement3d::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => entity.location = parameter.into(),
                2usize => {
                    entity.axis = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.ref_direction = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
}
pub trait IBSplineCurve: IBoundedCurve {
    fn degree(&self) -> i64;
    fn control_points_list(&self) -> &Vec<EntityRef>;
    fn curve_form(&self) -> &BSplineCurveForm;
    fn closed_curve(&self) -> Option<bool>;
    fn self_intersect(&self) -> Option<bool>;
}
#[derive(Default, Debug)]
pub struct BSplineCurve {
    name: Label,
    degree: i64,
    control_points_list: Vec<EntityRef>,
    curve_form: BSplineCurveForm,
    closed_curve: Option<bool>,
    self_intersect: Option<bool>,
}
impl IRepresentationItem for BSplineCurve {
    fn name(&self) -> &Label {
        &self.name
    }
}
impl IGeometricRepresentationItem for BSplineCurve {}
impl ICurve for BSplineCurve {}
impl IBoundedCurve for BSplineCurve {}
impl IBSplineCurve for BSplineCurve {
    fn degree(&self) -> i64 {
        self.degree
    }
    fn control_points_list(&self) -> &Vec<EntityRef> {
        &self.control_points_list
    }
    fn curve_form(&self) -> &BSplineCurveForm {
        &self.curve_form
    }
    fn closed_curve(&self) -> Option<bool> {
        self.closed_curve
    }
    fn self_intersect(&self) -> Option<bool> {
        self.self_intersect
    }
}
impl BSplineCurve {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = BSplineCurve::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => entity.degree = parameter.into(),
                2usize => entity.control_points_list = parameter.into(),
                3usize => entity.curve_form = parameter.into(),
                4usize => entity.closed_curve = parameter.into(),
                5usize => entity.self_intersect = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IBSplineCurveWithKnots: IBSplineCurve {
    fn knot_multiplicities(&self) -> &Vec<i64>;
    fn knots(&self) -> &Vec<ParameterValue>;
    fn knot_spec(&self) -> &KnotType;
}
#[derive(Default, Debug)]
pub struct BSplineCurveWithKnots {
    name: Label,
    degree: i64,
    control_points_list: Vec<EntityRef>,
    curve_form: BSplineCurveForm,
    closed_curve: Option<bool>,
    self_intersect: Option<bool>,
    knot_multiplicities: Vec<i64>,
    knots: Vec<ParameterValue>,
    knot_spec: KnotType,
}
impl IRepresentationItem for BSplineCurveWithKnots {
    fn name(&self) -> &Label {
        &self.name
    }
}
impl IGeometricRepresentationItem for BSplineCurveWithKnots {}
impl ICurve for BSplineCurveWithKnots {}
impl IBoundedCurve for BSplineCurveWithKnots {}
impl IBSplineCurve for BSplineCurveWithKnots {
    fn degree(&self) -> i64 {
        self.degree
    }
    fn control_points_list(&self) -> &Vec<EntityRef> {
        &self.control_points_list
    }
    fn curve_form(&self) -> &BSplineCurveForm {
        &self.curve_form
    }
    fn closed_curve(&self) -> Option<bool> {
        self.closed_curve
    }
    fn self_intersect(&self) -> Option<bool> {
        self.self_intersect
    }
}
impl IBSplineCurveWithKnots for BSplineCurveWithKnots {
    fn knot_multiplicities(&self) -> &Vec<i64> {
        &self.knot_multiplicities
    }
    fn knots(&self) -> &Vec<ParameterValue> {
        &self.knots
    }
    fn knot_spec(&self) -> &KnotType {
        &self.knot_spec
    }
}
impl BSplineCurveWithKnots {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = BSplineCurveWithKnots::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => entity.degree = parameter.into(),
                2usize => entity.control_points_list = parameter.into(),
                3usize => entity.curve_form = parameter.into(),
                4usize => entity.closed_curve = parameter.into(),
                5usize => entity.self_intersect = parameter.into(),
                6usize => entity.knot_multiplicities = parameter.into(),
                7usize => entity.knots = parameter.into(),
                8usize => entity.knot_spec = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IBSplineSurface: IBoundedSurface {
    fn u_degree(&self) -> i64;
    fn v_degree(&self) -> i64;
    fn control_points_list(&self) -> &Vec<Vec<EntityRef>>;
    fn surface_form(&self) -> &BSplineSurfaceForm;
    fn u_closed(&self) -> Option<bool>;
    fn v_closed(&self) -> Option<bool>;
    fn self_intersect(&self) -> Option<bool>;
}
#[derive(Default, Debug)]
pub struct BSplineSurface {
    name: Label,
    u_degree: i64,
    v_degree: i64,
    control_points_list: Vec<Vec<EntityRef>>,
    surface_form: BSplineSurfaceForm,
    u_closed: Option<bool>,
    v_closed: Option<bool>,
    self_intersect: Option<bool>,
}
impl IRepresentationItem for BSplineSurface {
    fn name(&self) -> &Label {
        &self.name
    }
}
impl IGeometricRepresentationItem for BSplineSurface {}
impl ISurface for BSplineSurface {}
impl IBoundedSurface for BSplineSurface {}
impl IBSplineSurface for BSplineSurface {
    fn u_degree(&self) -> i64 {
        self.u_degree
    }
    fn v_degree(&self) -> i64 {
        self.v_degree
    }
    fn control_points_list(&self) -> &Vec<Vec<EntityRef>> {
        &self.control_points_list
    }
    fn surface_form(&self) -> &BSplineSurfaceForm {
        &self.surface_form
    }
    fn u_closed(&self) -> Option<bool> {
        self.u_closed
    }
    fn v_closed(&self) -> Option<bool> {
        self.v_closed
    }
    fn self_intersect(&self) -> Option<bool> {
        self.self_intersect
    }
}
impl BSplineSurface {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = BSplineSurface::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => entity.u_degree = parameter.into(),
                2usize => entity.v_degree = parameter.into(),
                3usize => entity.control_points_list = parameter.into(),
                4usize => entity.surface_form = parameter.into(),
                5usize => entity.u_closed = parameter.into(),
                6usize => entity.v_closed = parameter.into(),
                7usize => entity.self_intersect = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IBSplineSurfaceWithKnots: IBSplineSurface {
    fn u_multiplicities(&self) -> &Vec<i64>;
    fn v_multiplicities(&self) -> &Vec<i64>;
    fn u_knots(&self) -> &Vec<ParameterValue>;
    fn v_knots(&self) -> &Vec<ParameterValue>;
    fn knot_spec(&self) -> &KnotType;
}
#[derive(Default, Debug)]
pub struct BSplineSurfaceWithKnots {
    name: Label,
    u_degree: i64,
    v_degree: i64,
    control_points_list: Vec<Vec<EntityRef>>,
    surface_form: BSplineSurfaceForm,
    u_closed: Option<bool>,
    v_closed: Option<bool>,
    self_intersect: Option<bool>,
    u_multiplicities: Vec<i64>,
    v_multiplicities: Vec<i64>,
    u_knots: Vec<ParameterValue>,
    v_knots: Vec<ParameterValue>,
    knot_spec: KnotType,
}
impl IRepresentationItem for BSplineSurfaceWithKnots {
    fn name(&self) -> &Label {
        &self.name
    }
}
impl IGeometricRepresentationItem for BSplineSurfaceWithKnots {}
impl ISurface for BSplineSurfaceWithKnots {}
impl IBoundedSurface for BSplineSurfaceWithKnots {}
impl IBSplineSurface for BSplineSurfaceWithKnots {
    fn u_degree(&self) -> i64 {
        self.u_degree
    }
    fn v_degree(&self) -> i64 {
        self.v_degree
    }
    fn control_points_list(&self) -> &Vec<Vec<EntityRef>> {
        &self.control_points_list
    }
    fn surface_form(&self) -> &BSplineSurfaceForm {
        &self.surface_form
    }
    fn u_closed(&self) -> Option<bool> {
        self.u_closed
    }
    fn v_closed(&self) -> Option<bool> {
        self.v_closed
    }
    fn self_intersect(&self) -> Option<bool> {
        self.self_intersect
    }
}
impl IBSplineSurfaceWithKnots for BSplineSurfaceWithKnots {
    fn u_multiplicities(&self) -> &Vec<i64> {
        &self.u_multiplicities
    }
    fn v_multiplicities(&self) -> &Vec<i64> {
        &self.v_multiplicities
    }
    fn u_knots(&self) -> &Vec<ParameterValue> {
        &self.u_knots
    }
    fn v_knots(&self) -> &Vec<ParameterValue> {
        &self.v_knots
    }
    fn knot_spec(&self) -> &KnotType {
        &self.knot_spec
    }
}
impl BSplineSurfaceWithKnots {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = BSplineSurfaceWithKnots::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => entity.u_degree = parameter.into(),
                2usize => entity.v_degree = parameter.into(),
                3usize => entity.control_points_list = parameter.into(),
                4usize => entity.surface_form = parameter.into(),
                5usize => entity.u_closed = parameter.into(),
                6usize => entity.v_closed = parameter.into(),
                7usize => entity.self_intersect = parameter.into(),
                8usize => entity.u_multiplicities = parameter.into(),
                9usize => entity.v_multiplicities = parameter.into(),
                10usize => entity.u_knots = parameter.into(),
                11usize => entity.v_knots = parameter.into(),
                12usize => entity.knot_spec = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IBackChainingRule: IRuleDefinition {}
#[derive(Default, Debug)]
pub struct BackChainingRule {
    id: Identifier,
    description: Option<Text>,
    formation: EntityRef,
    frame_of_reference: EntityRef,
}
impl IProductDefinition for BackChainingRule {
    fn id(&self) -> &Identifier {
        &self.id
    }
    fn description(&self) -> &Option<Text> {
        &self.description
    }
    fn formation(&self) -> &EntityRef {
        &self.formation
    }
    fn frame_of_reference(&self) -> &EntityRef {
        &self.frame_of_reference
    }
}
impl IRuleSoftwareDefinition for BackChainingRule {}
impl IRuleDefinition for BackChainingRule {}
impl IBackChainingRule for BackChainingRule {}
impl BackChainingRule {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = BackChainingRule::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.id = parameter.into(),
                1usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => entity.formation = parameter.into(),
                3usize => entity.frame_of_reference = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IBackChainingRuleBody: IPropertyDefinition + IPropertyDefinitionRepresentation + IRepresentation {}
#[derive(Default, Debug)]
pub struct BackChainingRuleBody {
    name: Label,
    description: Option<Text>,
    definition: EntityRef,
    used_representation: EntityRef,
    items: HashSet<EntityRef>,
    context_of_items: EntityRef,
}
impl IPropertyDefinition for BackChainingRuleBody {
    fn name(&self) -> &Label {
        &self.name
    }
    fn description(&self) -> &Option<Text> {
        &self.description
    }
    fn definition(&self) -> &EntityRef {
        &self.definition
    }
}
impl IPropertyDefinitionRepresentation for BackChainingRuleBody {
    fn definition(&self) -> &EntityRef {
        &self.definition
    }
    fn used_representation(&self) -> &EntityRef {
        &self.used_representation
    }
}
impl IRepresentation for BackChainingRuleBody {
    fn name(&self) -> &Label {
        &self.name
    }
    fn items(&self) -> &HashSet<EntityRef> {
        &self.items
    }
    fn context_of_items(&self) -> &EntityRef {
        &self.context_of_items
    }
}
impl IBackChainingRuleBody for BackChainingRuleBody {}
impl BackChainingRuleBody {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = BackChainingRuleBody::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => entity.definition = parameter.into(),
                3usize => entity.used_representation = parameter.into(),
                4usize => entity.items = parameter.into(),
                5usize => entity.context_of_items = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IBackgroundColour: IColour {
    fn presentation(&self) -> &EntityRef;
}
#[derive(Default, Debug)]
pub struct BackgroundColour {
    presentation: EntityRef,
}
impl IColour for BackgroundColour {}
impl IBackgroundColour for BackgroundColour {
    fn presentation(&self) -> &EntityRef {
        &self.presentation
    }
}
impl BackgroundColour {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = BackgroundColour::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.presentation = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IBeveledSheetRepresentation: IShapeRepresentation {}
#[derive(Default, Debug)]
pub struct BeveledSheetRepresentation {
    name: Label,
    items: HashSet<EntityRef>,
    context_of_items: EntityRef,
}
impl IRepresentation for BeveledSheetRepresentation {
    fn name(&self) -> &Label {
        &self.name
    }
    fn items(&self) -> &HashSet<EntityRef> {
        &self.items
    }
    fn context_of_items(&self) -> &EntityRef {
        &self.context_of_items
    }
}
impl IShapeRepresentation for BeveledSheetRepresentation {}
impl IBeveledSheetRepresentation for BeveledSheetRepresentation {}
impl BeveledSheetRepresentation {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = BeveledSheetRepresentation::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => entity.items = parameter.into(),
                2usize => entity.context_of_items = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IBezierCurve: IBSplineCurve {}
#[derive(Default, Debug)]
pub struct BezierCurve {
    name: Label,
    degree: i64,
    control_points_list: Vec<EntityRef>,
    curve_form: BSplineCurveForm,
    closed_curve: Option<bool>,
    self_intersect: Option<bool>,
}
impl IRepresentationItem for BezierCurve {
    fn name(&self) -> &Label {
        &self.name
    }
}
impl IGeometricRepresentationItem for BezierCurve {}
impl ICurve for BezierCurve {}
impl IBoundedCurve for BezierCurve {}
impl IBSplineCurve for BezierCurve {
    fn degree(&self) -> i64 {
        self.degree
    }
    fn control_points_list(&self) -> &Vec<EntityRef> {
        &self.control_points_list
    }
    fn curve_form(&self) -> &BSplineCurveForm {
        &self.curve_form
    }
    fn closed_curve(&self) -> Option<bool> {
        self.closed_curve
    }
    fn self_intersect(&self) -> Option<bool> {
        self.self_intersect
    }
}
impl IBezierCurve for BezierCurve {}
impl BezierCurve {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = BezierCurve::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => entity.degree = parameter.into(),
                2usize => entity.control_points_list = parameter.into(),
                3usize => entity.curve_form = parameter.into(),
                4usize => entity.closed_curve = parameter.into(),
                5usize => entity.self_intersect = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IBezierSurface: IBSplineSurface {}
#[derive(Default, Debug)]
pub struct BezierSurface {
    name: Label,
    u_degree: i64,
    v_degree: i64,
    control_points_list: Vec<Vec<EntityRef>>,
    surface_form: BSplineSurfaceForm,
    u_closed: Option<bool>,
    v_closed: Option<bool>,
    self_intersect: Option<bool>,
}
impl IRepresentationItem for BezierSurface {
    fn name(&self) -> &Label {
        &self.name
    }
}
impl IGeometricRepresentationItem for BezierSurface {}
impl ISurface for BezierSurface {}
impl IBoundedSurface for BezierSurface {}
impl IBSplineSurface for BezierSurface {
    fn u_degree(&self) -> i64 {
        self.u_degree
    }
    fn v_degree(&self) -> i64 {
        self.v_degree
    }
    fn control_points_list(&self) -> &Vec<Vec<EntityRef>> {
        &self.control_points_list
    }
    fn surface_form(&self) -> &BSplineSurfaceForm {
        &self.surface_form
    }
    fn u_closed(&self) -> Option<bool> {
        self.u_closed
    }
    fn v_closed(&self) -> Option<bool> {
        self.v_closed
    }
    fn self_intersect(&self) -> Option<bool> {
        self.self_intersect
    }
}
impl IBezierSurface for BezierSurface {}
impl BezierSurface {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = BezierSurface::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => entity.u_degree = parameter.into(),
                2usize => entity.v_degree = parameter.into(),
                3usize => entity.control_points_list = parameter.into(),
                4usize => entity.surface_form = parameter.into(),
                5usize => entity.u_closed = parameter.into(),
                6usize => entity.v_closed = parameter.into(),
                7usize => entity.self_intersect = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IBinaryGenericExpression: IGenericExpression {
    fn operands(&self) -> &Vec<EntityRef>;
}
pub trait IBinaryNumericExpression: INumericExpression + IBinaryGenericExpression {
    fn operands(&self) -> &Vec<EntityRef>;
}
pub trait IBinaryRepresentationItem: IRepresentationItem {
    fn binary_value(&self) -> &Unimplemented;
}
#[derive(Default, Debug)]
pub struct BinaryRepresentationItem {
    name: Label,
    binary_value: Unimplemented,
}
impl IRepresentationItem for BinaryRepresentationItem {
    fn name(&self) -> &Label {
        &self.name
    }
}
impl IBinaryRepresentationItem for BinaryRepresentationItem {
    fn binary_value(&self) -> &Unimplemented {
        &self.binary_value
    }
}
impl BinaryRepresentationItem {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = BinaryRepresentationItem::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => entity.binary_value = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IBlock: IGeometricRepresentationItem {
    fn position(&self) -> &EntityRef;
    fn x(&self) -> &PositiveLengthMeasure;
    fn y(&self) -> &PositiveLengthMeasure;
    fn z(&self) -> &PositiveLengthMeasure;
}
#[derive(Default, Debug)]
pub struct Block {
    name: Label,
    position: EntityRef,
    x: PositiveLengthMeasure,
    y: PositiveLengthMeasure,
    z: PositiveLengthMeasure,
}
impl IRepresentationItem for Block {
    fn name(&self) -> &Label {
        &self.name
    }
}
impl IGeometricRepresentationItem for Block {}
impl IBlock for Block {
    fn position(&self) -> &EntityRef {
        &self.position
    }
    fn x(&self) -> &PositiveLengthMeasure {
        &self.x
    }
    fn y(&self) -> &PositiveLengthMeasure {
        &self.y
    }
    fn z(&self) -> &PositiveLengthMeasure {
        &self.z
    }
}
impl Block {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = Block::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => entity.position = parameter.into(),
                2usize => entity.x = parameter.into(),
                3usize => entity.y = parameter.into(),
                4usize => entity.z = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IBooleanExpression: IExpression {}
pub trait IBooleanLiteral: ISimpleBooleanExpression + IGenericLiteral {
    fn the_value(&self) -> bool;
}
#[derive(Default, Debug)]
pub struct BooleanLiteral {
    the_value: bool,
}
impl IGenericExpression for BooleanLiteral {}
impl IExpression for BooleanLiteral {}
impl IBooleanExpression for BooleanLiteral {}
impl ISimpleBooleanExpression for BooleanLiteral {}
impl ISimpleGenericExpression for BooleanLiteral {}
impl IBooleanLiteral for BooleanLiteral {
    fn the_value(&self) -> bool {
        self.the_value
    }
}
impl IGenericLiteral for BooleanLiteral {}
impl BooleanLiteral {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = BooleanLiteral::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.the_value = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IBooleanRepresentationItem: IRepresentationItem + IBooleanLiteral {}
#[derive(Default, Debug)]
pub struct BooleanRepresentationItem {
    name: Label,
    the_value: bool,
}
impl IRepresentationItem for BooleanRepresentationItem {
    fn name(&self) -> &Label {
        &self.name
    }
}
impl IGenericExpression for BooleanRepresentationItem {}
impl IExpression for BooleanRepresentationItem {}
impl IBooleanExpression for BooleanRepresentationItem {}
impl ISimpleBooleanExpression for BooleanRepresentationItem {}
impl ISimpleGenericExpression for BooleanRepresentationItem {}
impl IBooleanLiteral for BooleanRepresentationItem {
    fn the_value(&self) -> bool {
        self.the_value
    }
}
impl IGenericLiteral for BooleanRepresentationItem {}
impl IBooleanRepresentationItem for BooleanRepresentationItem {}
impl BooleanRepresentationItem {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = BooleanRepresentationItem::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => entity.the_value = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IBooleanResult: IGeometricRepresentationItem {
    fn operator(&self) -> &BooleanOperator;
    fn first_operand(&self) -> &EntityRef;
    fn second_operand(&self) -> &EntityRef;
}
#[derive(Default, Debug)]
pub struct BooleanResult {
    name: Label,
    operator: BooleanOperator,
    first_operand: EntityRef,
    second_operand: EntityRef,
}
impl IRepresentationItem for BooleanResult {
    fn name(&self) -> &Label {
        &self.name
    }
}
impl IGeometricRepresentationItem for BooleanResult {}
impl IBooleanResult for BooleanResult {
    fn operator(&self) -> &BooleanOperator {
        &self.operator
    }
    fn first_operand(&self) -> &EntityRef {
        &self.first_operand
    }
    fn second_operand(&self) -> &EntityRef {
        &self.second_operand
    }
}
impl BooleanResult {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = BooleanResult::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => entity.operator = parameter.into(),
                2usize => entity.first_operand = parameter.into(),
                3usize => entity.second_operand = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IBoundaryCurve: ICompositeCurveOnSurface {}
#[derive(Default, Debug)]
pub struct BoundaryCurve {
    name: Label,
    segments: Vec<EntityRef>,
    self_intersect: Option<bool>,
}
impl IRepresentationItem for BoundaryCurve {
    fn name(&self) -> &Label {
        &self.name
    }
}
impl IGeometricRepresentationItem for BoundaryCurve {}
impl ICurve for BoundaryCurve {}
impl IBoundedCurve for BoundaryCurve {}
impl ICompositeCurve for BoundaryCurve {
    fn segments(&self) -> &Vec<EntityRef> {
        &self.segments
    }
    fn self_intersect(&self) -> Option<bool> {
        self.self_intersect
    }
}
impl ICompositeCurveOnSurface for BoundaryCurve {}
impl IBoundaryCurve for BoundaryCurve {}
impl BoundaryCurve {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = BoundaryCurve::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => entity.segments = parameter.into(),
                2usize => entity.self_intersect = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IBoundedCurve: ICurve {}
#[derive(Default, Debug)]
pub struct BoundedCurve {
    name: Label,
}
impl IRepresentationItem for BoundedCurve {
    fn name(&self) -> &Label {
        &self.name
    }
}
impl IGeometricRepresentationItem for BoundedCurve {}
impl ICurve for BoundedCurve {}
impl IBoundedCurve for BoundedCurve {}
impl BoundedCurve {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = BoundedCurve::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IBoundedPcurve: IPcurve + IBoundedCurve {}
#[derive(Default, Debug)]
pub struct BoundedPcurve {
    name: Label,
    basis_surface: EntityRef,
    reference_to_curve: EntityRef,
}
impl IRepresentationItem for BoundedPcurve {
    fn name(&self) -> &Label {
        &self.name
    }
}
impl IGeometricRepresentationItem for BoundedPcurve {}
impl ICurve for BoundedPcurve {}
impl IPcurve for BoundedPcurve {
    fn basis_surface(&self) -> &EntityRef {
        &self.basis_surface
    }
    fn reference_to_curve(&self) -> &EntityRef {
        &self.reference_to_curve
    }
}
impl IBoundedPcurve for BoundedPcurve {}
impl IBoundedCurve for BoundedPcurve {}
impl BoundedPcurve {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = BoundedPcurve::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => entity.basis_surface = parameter.into(),
                2usize => entity.reference_to_curve = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IBoundedSurface: ISurface {}
#[derive(Default, Debug)]
pub struct BoundedSurface {
    name: Label,
}
impl IRepresentationItem for BoundedSurface {
    fn name(&self) -> &Label {
        &self.name
    }
}
impl IGeometricRepresentationItem for BoundedSurface {}
impl ISurface for BoundedSurface {}
impl IBoundedSurface for BoundedSurface {}
impl BoundedSurface {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = BoundedSurface::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IBoundedSurfaceCurve: ISurfaceCurve + IBoundedCurve {}
#[derive(Default, Debug)]
pub struct BoundedSurfaceCurve {
    name: Label,
    curve_3d: EntityRef,
    associated_geometry: Vec<EntityRef>,
    master_representation: PreferredSurfaceCurveRepresentation,
}
impl IRepresentationItem for BoundedSurfaceCurve {
    fn name(&self) -> &Label {
        &self.name
    }
}
impl IGeometricRepresentationItem for BoundedSurfaceCurve {}
impl ICurve for BoundedSurfaceCurve {}
impl ISurfaceCurve for BoundedSurfaceCurve {
    fn curve_3d(&self) -> &EntityRef {
        &self.curve_3d
    }
    fn associated_geometry(&self) -> &Vec<EntityRef> {
        &self.associated_geometry
    }
    fn master_representation(&self) -> &PreferredSurfaceCurveRepresentation {
        &self.master_representation
    }
}
impl IBoundedSurfaceCurve for BoundedSurfaceCurve {}
impl IBoundedCurve for BoundedSurfaceCurve {}
impl BoundedSurfaceCurve {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = BoundedSurfaceCurve::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => entity.curve_3d = parameter.into(),
                2usize => entity.associated_geometry = parameter.into(),
                3usize => entity.master_representation = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IBoxDomain: IFoundedItem {
    fn corner(&self) -> &EntityRef;
    fn xlength(&self) -> &PositiveLengthMeasure;
    fn ylength(&self) -> &PositiveLengthMeasure;
    fn zlength(&self) -> &PositiveLengthMeasure;
}
#[derive(Default, Debug)]
pub struct BoxDomain {
    corner: EntityRef,
    xlength: PositiveLengthMeasure,
    ylength: PositiveLengthMeasure,
    zlength: PositiveLengthMeasure,
}
impl IFoundedItem for BoxDomain {}
impl IBoxDomain for BoxDomain {
    fn corner(&self) -> &EntityRef {
        &self.corner
    }
    fn xlength(&self) -> &PositiveLengthMeasure {
        &self.xlength
    }
    fn ylength(&self) -> &PositiveLengthMeasure {
        &self.ylength
    }
    fn zlength(&self) -> &PositiveLengthMeasure {
        &self.zlength
    }
}
impl BoxDomain {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = BoxDomain::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.corner = parameter.into(),
                1usize => entity.xlength = parameter.into(),
                2usize => entity.ylength = parameter.into(),
                3usize => entity.zlength = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IBoxedHalfSpace: IHalfSpaceSolid {
    fn enclosure(&self) -> &EntityRef;
}
#[derive(Default, Debug)]
pub struct BoxedHalfSpace {
    name: Label,
    base_surface: EntityRef,
    agreement_flag: bool,
    enclosure: EntityRef,
}
impl IRepresentationItem for BoxedHalfSpace {
    fn name(&self) -> &Label {
        &self.name
    }
}
impl IGeometricRepresentationItem for BoxedHalfSpace {}
impl IHalfSpaceSolid for BoxedHalfSpace {
    fn base_surface(&self) -> &EntityRef {
        &self.base_surface
    }
    fn agreement_flag(&self) -> bool {
        self.agreement_flag
    }
}
impl IBoxedHalfSpace for BoxedHalfSpace {
    fn enclosure(&self) -> &EntityRef {
        &self.enclosure
    }
}
impl BoxedHalfSpace {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = BoxedHalfSpace::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => entity.base_surface = parameter.into(),
                2usize => entity.agreement_flag = parameter.into(),
                3usize => entity.enclosure = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IBreakdownContext: IProductDefinitionRelationship {}
#[derive(Default, Debug)]
pub struct BreakdownContext {
    id: Identifier,
    name: Label,
    description: Option<Text>,
    relating_product_definition: EntityRef,
    related_product_definition: EntityRef,
}
impl IProductDefinitionRelationship for BreakdownContext {
    fn id(&self) -> &Identifier {
        &self.id
    }
    fn name(&self) -> &Label {
        &self.name
    }
    fn description(&self) -> &Option<Text> {
        &self.description
    }
    fn relating_product_definition(&self) -> &EntityRef {
        &self.relating_product_definition
    }
    fn related_product_definition(&self) -> &EntityRef {
        &self.related_product_definition
    }
}
impl IBreakdownContext for BreakdownContext {}
impl BreakdownContext {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = BreakdownContext::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.id = parameter.into(),
                1usize => entity.name = parameter.into(),
                2usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => entity.relating_product_definition = parameter.into(),
                4usize => entity.related_product_definition = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IBreakdownElementGroupAssignment: IGroupAssignment {
    fn items(&self) -> &HashSet<EntityRef>;
    fn assigned_group(&self) -> &EntityRef;
}
#[derive(Default, Debug)]
pub struct BreakdownElementGroupAssignment {
    items: HashSet<EntityRef>,
    assigned_group: EntityRef,
}
impl IGroupAssignment for BreakdownElementGroupAssignment {
    fn assigned_group(&self) -> &EntityRef {
        &self.assigned_group
    }
}
impl IBreakdownElementGroupAssignment for BreakdownElementGroupAssignment {
    fn items(&self) -> &HashSet<EntityRef> {
        &self.items
    }
    fn assigned_group(&self) -> &EntityRef {
        &self.assigned_group
    }
}
impl BreakdownElementGroupAssignment {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = BreakdownElementGroupAssignment::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.items = parameter.into(),
                1usize => entity.assigned_group = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IBreakdownElementRealization: ICharacterizedObject + IProductDefinitionElementRelationship {}
#[derive(Default, Debug)]
pub struct BreakdownElementRealization {
    name: Label,
    description: Option<Text>,
}
impl ICharacterizedObject for BreakdownElementRealization {
    fn name(&self) -> &Label {
        &self.name
    }
    fn description(&self) -> &Option<Text> {
        &self.description
    }
}
impl IGroup for BreakdownElementRealization {
    fn name(&self) -> &Label {
        &self.name
    }
    fn description(&self) -> &Option<Text> {
        &self.description
    }
}
impl IProductDefinitionElementRelationship for BreakdownElementRealization {}
impl IBreakdownElementRealization for BreakdownElementRealization {}
impl BreakdownElementRealization {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = BreakdownElementRealization::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
}
pub trait IBreakdownElementUsage: IProductDefinitionRelationship {}
#[derive(Default, Debug)]
pub struct BreakdownElementUsage {
    id: Identifier,
    name: Label,
    description: Option<Text>,
    relating_product_definition: EntityRef,
    related_product_definition: EntityRef,
}
impl IProductDefinitionRelationship for BreakdownElementUsage {
    fn id(&self) -> &Identifier {
        &self.id
    }
    fn name(&self) -> &Label {
        &self.name
    }
    fn description(&self) -> &Option<Text> {
        &self.description
    }
    fn relating_product_definition(&self) -> &EntityRef {
        &self.relating_product_definition
    }
    fn related_product_definition(&self) -> &EntityRef {
        &self.related_product_definition
    }
}
impl IBreakdownElementUsage for BreakdownElementUsage {}
impl BreakdownElementUsage {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = BreakdownElementUsage::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.id = parameter.into(),
                1usize => entity.name = parameter.into(),
                2usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => entity.relating_product_definition = parameter.into(),
                4usize => entity.related_product_definition = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IBreakdownOf: IProductDefinitionRelationship {}
#[derive(Default, Debug)]
pub struct BreakdownOf {
    id: Identifier,
    name: Label,
    description: Option<Text>,
    relating_product_definition: EntityRef,
    related_product_definition: EntityRef,
}
impl IProductDefinitionRelationship for BreakdownOf {
    fn id(&self) -> &Identifier {
        &self.id
    }
    fn name(&self) -> &Label {
        &self.name
    }
    fn description(&self) -> &Option<Text> {
        &self.description
    }
    fn relating_product_definition(&self) -> &EntityRef {
        &self.relating_product_definition
    }
    fn related_product_definition(&self) -> &EntityRef {
        &self.related_product_definition
    }
}
impl IBreakdownOf for BreakdownOf {}
impl BreakdownOf {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = BreakdownOf::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.id = parameter.into(),
                1usize => entity.name = parameter.into(),
                2usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => entity.relating_product_definition = parameter.into(),
                4usize => entity.related_product_definition = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IBrepWithVoids: IManifoldSolidBrep {
    fn voids(&self) -> &HashSet<EntityRef>;
}
#[derive(Default, Debug)]
pub struct BrepWithVoids {
    name: Label,
    outer: EntityRef,
    voids: HashSet<EntityRef>,
}
impl IRepresentationItem for BrepWithVoids {
    fn name(&self) -> &Label {
        &self.name
    }
}
impl IGeometricRepresentationItem for BrepWithVoids {}
impl ISolidModel for BrepWithVoids {}
impl IManifoldSolidBrep for BrepWithVoids {
    fn outer(&self) -> &EntityRef {
        &self.outer
    }
}
impl IBrepWithVoids for BrepWithVoids {
    fn voids(&self) -> &HashSet<EntityRef> {
        &self.voids
    }
}
impl BrepWithVoids {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = BrepWithVoids::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => entity.outer = parameter.into(),
                2usize => entity.voids = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IBytesRepresentationItem: IBinaryRepresentationItem {}
#[derive(Default, Debug)]
pub struct BytesRepresentationItem {
    name: Label,
    binary_value: Unimplemented,
}
impl IRepresentationItem for BytesRepresentationItem {
    fn name(&self) -> &Label {
        &self.name
    }
}
impl IBinaryRepresentationItem for BytesRepresentationItem {
    fn binary_value(&self) -> &Unimplemented {
        &self.binary_value
    }
}
impl IBytesRepresentationItem for BytesRepresentationItem {}
impl BytesRepresentationItem {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = BytesRepresentationItem::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => entity.binary_value = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait ICalendarDate: IDate {
    fn day_component(&self) -> &DayInMonthNumber;
    fn month_component(&self) -> &MonthInYearNumber;
}
#[derive(Default, Debug)]
pub struct CalendarDate {
    year_component: YearNumber,
    day_component: DayInMonthNumber,
    month_component: MonthInYearNumber,
}
impl IDate for CalendarDate {
    fn year_component(&self) -> &YearNumber {
        &self.year_component
    }
}
impl ICalendarDate for CalendarDate {
    fn day_component(&self) -> &DayInMonthNumber {
        &self.day_component
    }
    fn month_component(&self) -> &MonthInYearNumber {
        &self.month_component
    }
}
impl CalendarDate {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = CalendarDate::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.year_component = parameter.into(),
                1usize => entity.day_component = parameter.into(),
                2usize => entity.month_component = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait ICameraImage: IMappedItem {
    fn mapping_source(&self) -> &EntityRef;
    fn mapping_target(&self) -> &EntityRef;
}
#[derive(Default, Debug)]
pub struct CameraImage {
    name: Label,
    mapping_source: EntityRef,
    mapping_target: EntityRef,
}
impl IRepresentationItem for CameraImage {
    fn name(&self) -> &Label {
        &self.name
    }
}
impl IMappedItem for CameraImage {
    fn mapping_source(&self) -> &EntityRef {
        &self.mapping_source
    }
    fn mapping_target(&self) -> &EntityRef {
        &self.mapping_target
    }
}
impl ICameraImage for CameraImage {
    fn mapping_source(&self) -> &EntityRef {
        &self.mapping_source
    }
    fn mapping_target(&self) -> &EntityRef {
        &self.mapping_target
    }
}
impl CameraImage {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = CameraImage::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => entity.mapping_source = parameter.into(),
                2usize => entity.mapping_target = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait ICameraImage3dWithScale: ICameraImage {}
#[derive(Default, Debug)]
pub struct CameraImage3dWithScale {
    name: Label,
    mapping_source: EntityRef,
    mapping_target: EntityRef,
}
impl IRepresentationItem for CameraImage3dWithScale {
    fn name(&self) -> &Label {
        &self.name
    }
}
impl IMappedItem for CameraImage3dWithScale {
    fn mapping_source(&self) -> &EntityRef {
        &self.mapping_source
    }
    fn mapping_target(&self) -> &EntityRef {
        &self.mapping_target
    }
}
impl ICameraImage for CameraImage3dWithScale {
    fn mapping_source(&self) -> &EntityRef {
        &self.mapping_source
    }
    fn mapping_target(&self) -> &EntityRef {
        &self.mapping_target
    }
}
impl ICameraImage3dWithScale for CameraImage3dWithScale {}
impl CameraImage3dWithScale {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = CameraImage3dWithScale::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => entity.mapping_source = parameter.into(),
                2usize => entity.mapping_target = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait ICameraModel: IGeometricRepresentationItem {}
pub trait ICameraModelD3: ICameraModel {
    fn view_reference_system(&self) -> &EntityRef;
    fn perspective_of_volume(&self) -> &EntityRef;
}
#[derive(Default, Debug)]
pub struct CameraModelD3 {
    name: Label,
    view_reference_system: EntityRef,
    perspective_of_volume: EntityRef,
}
impl IRepresentationItem for CameraModelD3 {
    fn name(&self) -> &Label {
        &self.name
    }
}
impl IGeometricRepresentationItem for CameraModelD3 {}
impl ICameraModel for CameraModelD3 {}
impl ICameraModelD3 for CameraModelD3 {
    fn view_reference_system(&self) -> &EntityRef {
        &self.view_reference_system
    }
    fn perspective_of_volume(&self) -> &EntityRef {
        &self.perspective_of_volume
    }
}
impl CameraModelD3 {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = CameraModelD3::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => entity.view_reference_system = parameter.into(),
                2usize => entity.perspective_of_volume = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait ICameraModelD3MultiClipping: ICameraModelD3 {
    fn shape_clipping(&self) -> &HashSet<EntityRef>;
}
#[derive(Default, Debug)]
pub struct CameraModelD3MultiClipping {
    name: Label,
    view_reference_system: EntityRef,
    perspective_of_volume: EntityRef,
    shape_clipping: HashSet<EntityRef>,
}
impl IRepresentationItem for CameraModelD3MultiClipping {
    fn name(&self) -> &Label {
        &self.name
    }
}
impl IGeometricRepresentationItem for CameraModelD3MultiClipping {}
impl ICameraModel for CameraModelD3MultiClipping {}
impl ICameraModelD3 for CameraModelD3MultiClipping {
    fn view_reference_system(&self) -> &EntityRef {
        &self.view_reference_system
    }
    fn perspective_of_volume(&self) -> &EntityRef {
        &self.perspective_of_volume
    }
}
impl ICameraModelD3MultiClipping for CameraModelD3MultiClipping {
    fn shape_clipping(&self) -> &HashSet<EntityRef> {
        &self.shape_clipping
    }
}
impl CameraModelD3MultiClipping {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = CameraModelD3MultiClipping::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => entity.view_reference_system = parameter.into(),
                2usize => entity.perspective_of_volume = parameter.into(),
                3usize => entity.shape_clipping = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait ICameraModelD3MultiClippingIntersection: IGeometricRepresentationItem {
    fn shape_clipping(&self) -> &HashSet<EntityRef>;
}
#[derive(Default, Debug)]
pub struct CameraModelD3MultiClippingIntersection {
    name: Label,
    shape_clipping: HashSet<EntityRef>,
}
impl IRepresentationItem for CameraModelD3MultiClippingIntersection {
    fn name(&self) -> &Label {
        &self.name
    }
}
impl IGeometricRepresentationItem for CameraModelD3MultiClippingIntersection {}
impl ICameraModelD3MultiClippingIntersection for CameraModelD3MultiClippingIntersection {
    fn shape_clipping(&self) -> &HashSet<EntityRef> {
        &self.shape_clipping
    }
}
impl CameraModelD3MultiClippingIntersection {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = CameraModelD3MultiClippingIntersection::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => entity.shape_clipping = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait ICameraModelD3MultiClippingUnion: IGeometricRepresentationItem {
    fn shape_clipping(&self) -> &HashSet<EntityRef>;
}
#[derive(Default, Debug)]
pub struct CameraModelD3MultiClippingUnion {
    name: Label,
    shape_clipping: HashSet<EntityRef>,
}
impl IRepresentationItem for CameraModelD3MultiClippingUnion {
    fn name(&self) -> &Label {
        &self.name
    }
}
impl IGeometricRepresentationItem for CameraModelD3MultiClippingUnion {}
impl ICameraModelD3MultiClippingUnion for CameraModelD3MultiClippingUnion {
    fn shape_clipping(&self) -> &HashSet<EntityRef> {
        &self.shape_clipping
    }
}
impl CameraModelD3MultiClippingUnion {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = CameraModelD3MultiClippingUnion::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => entity.shape_clipping = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait ICameraModelD3WithHlhsr: ICameraModelD3 {
    fn hidden_line_surface_removal(&self) -> bool;
}
#[derive(Default, Debug)]
pub struct CameraModelD3WithHlhsr {
    name: Label,
    view_reference_system: EntityRef,
    perspective_of_volume: EntityRef,
    hidden_line_surface_removal: bool,
}
impl IRepresentationItem for CameraModelD3WithHlhsr {
    fn name(&self) -> &Label {
        &self.name
    }
}
impl IGeometricRepresentationItem for CameraModelD3WithHlhsr {}
impl ICameraModel for CameraModelD3WithHlhsr {}
impl ICameraModelD3 for CameraModelD3WithHlhsr {
    fn view_reference_system(&self) -> &EntityRef {
        &self.view_reference_system
    }
    fn perspective_of_volume(&self) -> &EntityRef {
        &self.perspective_of_volume
    }
}
impl ICameraModelD3WithHlhsr for CameraModelD3WithHlhsr {
    fn hidden_line_surface_removal(&self) -> bool {
        self.hidden_line_surface_removal
    }
}
impl CameraModelD3WithHlhsr {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = CameraModelD3WithHlhsr::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => entity.view_reference_system = parameter.into(),
                2usize => entity.perspective_of_volume = parameter.into(),
                3usize => entity.hidden_line_surface_removal = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait ICameraModelWithLightSources: ICameraModelD3 {
    fn sources(&self) -> &HashSet<EntityRef>;
}
#[derive(Default, Debug)]
pub struct CameraModelWithLightSources {
    name: Label,
    view_reference_system: EntityRef,
    perspective_of_volume: EntityRef,
    sources: HashSet<EntityRef>,
}
impl IRepresentationItem for CameraModelWithLightSources {
    fn name(&self) -> &Label {
        &self.name
    }
}
impl IGeometricRepresentationItem for CameraModelWithLightSources {}
impl ICameraModel for CameraModelWithLightSources {}
impl ICameraModelD3 for CameraModelWithLightSources {
    fn view_reference_system(&self) -> &EntityRef {
        &self.view_reference_system
    }
    fn perspective_of_volume(&self) -> &EntityRef {
        &self.perspective_of_volume
    }
}
impl ICameraModelWithLightSources for CameraModelWithLightSources {
    fn sources(&self) -> &HashSet<EntityRef> {
        &self.sources
    }
}
impl CameraModelWithLightSources {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = CameraModelWithLightSources::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => entity.view_reference_system = parameter.into(),
                2usize => entity.perspective_of_volume = parameter.into(),
                3usize => entity.sources = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait ICameraUsage: IRepresentationMap {
    fn mapping_origin(&self) -> &EntityRef;
}
#[derive(Default, Debug)]
pub struct CameraUsage {
    mapped_representation: EntityRef,
    mapping_origin: EntityRef,
}
impl IRepresentationMap for CameraUsage {
    fn mapping_origin(&self) -> &EntityRef {
        &self.mapping_origin
    }
    fn mapped_representation(&self) -> &EntityRef {
        &self.mapped_representation
    }
}
impl ICameraUsage for CameraUsage {
    fn mapping_origin(&self) -> &EntityRef {
        &self.mapping_origin
    }
}
impl CameraUsage {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = CameraUsage::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.mapped_representation = parameter.into(),
                1usize => entity.mapping_origin = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait ICapacitanceMeasureWithUnit: IMeasureWithUnit {}
#[derive(Default, Debug)]
pub struct CapacitanceMeasureWithUnit {
    value_component: MeasureValue,
    unit_component: EntityRef,
}
impl IMeasureWithUnit for CapacitanceMeasureWithUnit {
    fn value_component(&self) -> &MeasureValue {
        &self.value_component
    }
    fn unit_component(&self) -> &EntityRef {
        &self.unit_component
    }
}
impl ICapacitanceMeasureWithUnit for CapacitanceMeasureWithUnit {}
impl CapacitanceMeasureWithUnit {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = CapacitanceMeasureWithUnit::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.value_component = parameter.into(),
                1usize => entity.unit_component = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait ICapacitanceUnit: IDerivedUnit {}
#[derive(Default, Debug)]
pub struct CapacitanceUnit {
    elements: HashSet<EntityRef>,
}
impl IDerivedUnit for CapacitanceUnit {
    fn elements(&self) -> &HashSet<EntityRef> {
        &self.elements
    }
}
impl ICapacitanceUnit for CapacitanceUnit {}
impl CapacitanceUnit {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = CapacitanceUnit::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.elements = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait ICartesianPoint: IPoint {
    fn coordinates(&self) -> &Vec<LengthMeasure>;
}
#[derive(Default, Debug)]
pub struct CartesianPoint {
    name: Label,
    coordinates: Vec<LengthMeasure>,
}
impl IRepresentationItem for CartesianPoint {
    fn name(&self) -> &Label {
        &self.name
    }
}
impl IGeometricRepresentationItem for CartesianPoint {}
impl IPoint for CartesianPoint {}
impl ICartesianPoint for CartesianPoint {
    fn coordinates(&self) -> &Vec<LengthMeasure> {
        &self.coordinates
    }
}
impl CartesianPoint {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = CartesianPoint::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => entity.coordinates = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait ICartesianTransformationOperator: IGeometricRepresentationItem + IFunctionallyDefinedTransformation {
    fn axis1(&self) -> &Option<EntityRef>;
    fn axis2(&self) -> &Option<EntityRef>;
    fn local_origin(&self) -> &EntityRef;
    fn scale(&self) -> Option<Real>;
}
#[derive(Default, Debug)]
pub struct CartesianTransformationOperator {
    name: Label,
    description: Option<Text>,
    axis1: Option<EntityRef>,
    axis2: Option<EntityRef>,
    local_origin: EntityRef,
    scale: Option<Real>,
}
impl IRepresentationItem for CartesianTransformationOperator {
    fn name(&self) -> &Label {
        &self.name
    }
}
impl IGeometricRepresentationItem for CartesianTransformationOperator {}
impl IFunctionallyDefinedTransformation for CartesianTransformationOperator {
    fn name(&self) -> &Label {
        &self.name
    }
    fn description(&self) -> &Option<Text> {
        &self.description
    }
}
impl ICartesianTransformationOperator for CartesianTransformationOperator {
    fn axis1(&self) -> &Option<EntityRef> {
        &self.axis1
    }
    fn axis2(&self) -> &Option<EntityRef> {
        &self.axis2
    }
    fn local_origin(&self) -> &EntityRef {
        &self.local_origin
    }
    fn scale(&self) -> Option<Real> {
        self.scale
    }
}
impl CartesianTransformationOperator {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = CartesianTransformationOperator::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => {
                    entity.axis1 = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.axis2 = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => entity.local_origin = parameter.into(),
                5usize => {
                    entity.scale = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
}
pub trait ICartesianTransformationOperator2d: ICartesianTransformationOperator {}
#[derive(Default, Debug)]
pub struct CartesianTransformationOperator2d {
    name: Label,
    description: Option<Text>,
    axis1: Option<EntityRef>,
    axis2: Option<EntityRef>,
    local_origin: EntityRef,
    scale: Option<Real>,
}
impl IRepresentationItem for CartesianTransformationOperator2d {
    fn name(&self) -> &Label {
        &self.name
    }
}
impl IGeometricRepresentationItem for CartesianTransformationOperator2d {}
impl IFunctionallyDefinedTransformation for CartesianTransformationOperator2d {
    fn name(&self) -> &Label {
        &self.name
    }
    fn description(&self) -> &Option<Text> {
        &self.description
    }
}
impl ICartesianTransformationOperator for CartesianTransformationOperator2d {
    fn axis1(&self) -> &Option<EntityRef> {
        &self.axis1
    }
    fn axis2(&self) -> &Option<EntityRef> {
        &self.axis2
    }
    fn local_origin(&self) -> &EntityRef {
        &self.local_origin
    }
    fn scale(&self) -> Option<Real> {
        self.scale
    }
}
impl ICartesianTransformationOperator2d for CartesianTransformationOperator2d {}
impl CartesianTransformationOperator2d {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = CartesianTransformationOperator2d::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => {
                    entity.axis1 = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.axis2 = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => entity.local_origin = parameter.into(),
                5usize => {
                    entity.scale = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
}
pub trait ICartesianTransformationOperator3d: ICartesianTransformationOperator {
    fn axis3(&self) -> &Option<EntityRef>;
}
#[derive(Default, Debug)]
pub struct CartesianTransformationOperator3d {
    name: Label,
    description: Option<Text>,
    axis1: Option<EntityRef>,
    axis2: Option<EntityRef>,
    local_origin: EntityRef,
    scale: Option<Real>,
    axis3: Option<EntityRef>,
}
impl IRepresentationItem for CartesianTransformationOperator3d {
    fn name(&self) -> &Label {
        &self.name
    }
}
impl IGeometricRepresentationItem for CartesianTransformationOperator3d {}
impl IFunctionallyDefinedTransformation for CartesianTransformationOperator3d {
    fn name(&self) -> &Label {
        &self.name
    }
    fn description(&self) -> &Option<Text> {
        &self.description
    }
}
impl ICartesianTransformationOperator for CartesianTransformationOperator3d {
    fn axis1(&self) -> &Option<EntityRef> {
        &self.axis1
    }
    fn axis2(&self) -> &Option<EntityRef> {
        &self.axis2
    }
    fn local_origin(&self) -> &EntityRef {
        &self.local_origin
    }
    fn scale(&self) -> Option<Real> {
        self.scale
    }
}
impl ICartesianTransformationOperator3d for CartesianTransformationOperator3d {
    fn axis3(&self) -> &Option<EntityRef> {
        &self.axis3
    }
}
impl CartesianTransformationOperator3d {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = CartesianTransformationOperator3d::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => {
                    entity.axis1 = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.axis2 = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => entity.local_origin = parameter.into(),
                5usize => {
                    entity.scale = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                6usize => {
                    entity.axis3 = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
}
pub trait ICcDesignApproval: IApprovalAssignment {
    fn items(&self) -> &HashSet<EntityRef>;
}
#[derive(Default, Debug)]
pub struct CcDesignApproval {
    assigned_approval: EntityRef,
    items: HashSet<EntityRef>,
}
impl IApprovalAssignment for CcDesignApproval {
    fn assigned_approval(&self) -> &EntityRef {
        &self.assigned_approval
    }
}
impl ICcDesignApproval for CcDesignApproval {
    fn items(&self) -> &HashSet<EntityRef> {
        &self.items
    }
}
impl CcDesignApproval {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = CcDesignApproval::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.assigned_approval = parameter.into(),
                1usize => entity.items = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait ICcDesignCertification: ICertificationAssignment {
    fn items(&self) -> &HashSet<EntityRef>;
}
#[derive(Default, Debug)]
pub struct CcDesignCertification {
    assigned_certification: EntityRef,
    items: HashSet<EntityRef>,
}
impl ICertificationAssignment for CcDesignCertification {
    fn assigned_certification(&self) -> &EntityRef {
        &self.assigned_certification
    }
}
impl ICcDesignCertification for CcDesignCertification {
    fn items(&self) -> &HashSet<EntityRef> {
        &self.items
    }
}
impl CcDesignCertification {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = CcDesignCertification::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.assigned_certification = parameter.into(),
                1usize => entity.items = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait ICcDesignContract: IContractAssignment {
    fn items(&self) -> &HashSet<EntityRef>;
}
#[derive(Default, Debug)]
pub struct CcDesignContract {
    assigned_contract: EntityRef,
    items: HashSet<EntityRef>,
}
impl IContractAssignment for CcDesignContract {
    fn assigned_contract(&self) -> &EntityRef {
        &self.assigned_contract
    }
}
impl ICcDesignContract for CcDesignContract {
    fn items(&self) -> &HashSet<EntityRef> {
        &self.items
    }
}
impl CcDesignContract {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = CcDesignContract::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.assigned_contract = parameter.into(),
                1usize => entity.items = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait ICcDesignDateAndTimeAssignment: IDateAndTimeAssignment {
    fn items(&self) -> &HashSet<EntityRef>;
}
#[derive(Default, Debug)]
pub struct CcDesignDateAndTimeAssignment {
    assigned_date_and_time: EntityRef,
    role: EntityRef,
    items: HashSet<EntityRef>,
}
impl IDateAndTimeAssignment for CcDesignDateAndTimeAssignment {
    fn assigned_date_and_time(&self) -> &EntityRef {
        &self.assigned_date_and_time
    }
    fn role(&self) -> &EntityRef {
        &self.role
    }
}
impl ICcDesignDateAndTimeAssignment for CcDesignDateAndTimeAssignment {
    fn items(&self) -> &HashSet<EntityRef> {
        &self.items
    }
}
impl CcDesignDateAndTimeAssignment {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = CcDesignDateAndTimeAssignment::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.assigned_date_and_time = parameter.into(),
                1usize => entity.role = parameter.into(),
                2usize => entity.items = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait ICcDesignPersonAndOrganizationAssignment: IPersonAndOrganizationAssignment {
    fn items(&self) -> &HashSet<EntityRef>;
}
#[derive(Default, Debug)]
pub struct CcDesignPersonAndOrganizationAssignment {
    assigned_person_and_organization: EntityRef,
    role: EntityRef,
    items: HashSet<EntityRef>,
}
impl IPersonAndOrganizationAssignment for CcDesignPersonAndOrganizationAssignment {
    fn assigned_person_and_organization(&self) -> &EntityRef {
        &self.assigned_person_and_organization
    }
    fn role(&self) -> &EntityRef {
        &self.role
    }
}
impl ICcDesignPersonAndOrganizationAssignment for CcDesignPersonAndOrganizationAssignment {
    fn items(&self) -> &HashSet<EntityRef> {
        &self.items
    }
}
impl CcDesignPersonAndOrganizationAssignment {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = CcDesignPersonAndOrganizationAssignment::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.assigned_person_and_organization = parameter.into(),
                1usize => entity.role = parameter.into(),
                2usize => entity.items = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait ICcDesignSecurityClassification: ISecurityClassificationAssignment {
    fn items(&self) -> &HashSet<EntityRef>;
}
#[derive(Default, Debug)]
pub struct CcDesignSecurityClassification {
    assigned_security_classification: EntityRef,
    items: HashSet<EntityRef>,
}
impl ISecurityClassificationAssignment for CcDesignSecurityClassification {
    fn assigned_security_classification(&self) -> &EntityRef {
        &self.assigned_security_classification
    }
}
impl ICcDesignSecurityClassification for CcDesignSecurityClassification {
    fn items(&self) -> &HashSet<EntityRef> {
        &self.items
    }
}
impl CcDesignSecurityClassification {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = CcDesignSecurityClassification::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.assigned_security_classification = parameter.into(),
                1usize => entity.items = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait ICcDesignSpecificationReference: IDocumentReference {
    fn items(&self) -> &HashSet<EntityRef>;
}
#[derive(Default, Debug)]
pub struct CcDesignSpecificationReference {
    assigned_document: EntityRef,
    source: Label,
    items: HashSet<EntityRef>,
}
impl IDocumentReference for CcDesignSpecificationReference {
    fn assigned_document(&self) -> &EntityRef {
        &self.assigned_document
    }
    fn source(&self) -> &Label {
        &self.source
    }
}
impl ICcDesignSpecificationReference for CcDesignSpecificationReference {
    fn items(&self) -> &HashSet<EntityRef> {
        &self.items
    }
}
impl CcDesignSpecificationReference {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = CcDesignSpecificationReference::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.assigned_document = parameter.into(),
                1usize => entity.source = parameter.into(),
                2usize => entity.items = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait ICelsiusTemperatureMeasureWithUnit: IMeasureWithUnit {}
#[derive(Default, Debug)]
pub struct CelsiusTemperatureMeasureWithUnit {
    value_component: MeasureValue,
    unit_component: EntityRef,
}
impl IMeasureWithUnit for CelsiusTemperatureMeasureWithUnit {
    fn value_component(&self) -> &MeasureValue {
        &self.value_component
    }
    fn unit_component(&self) -> &EntityRef {
        &self.unit_component
    }
}
impl ICelsiusTemperatureMeasureWithUnit for CelsiusTemperatureMeasureWithUnit {}
impl CelsiusTemperatureMeasureWithUnit {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = CelsiusTemperatureMeasureWithUnit::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.value_component = parameter.into(),
                1usize => entity.unit_component = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait ICentreOfSymmetry: IDerivedShapeAspect {}
#[derive(Default, Debug)]
pub struct CentreOfSymmetry {
    name: Label,
    description: Option<Text>,
    of_shape: EntityRef,
    product_definitional: Option<bool>,
}
impl IShapeAspect for CentreOfSymmetry {
    fn name(&self) -> &Label {
        &self.name
    }
    fn description(&self) -> &Option<Text> {
        &self.description
    }
    fn of_shape(&self) -> &EntityRef {
        &self.of_shape
    }
    fn product_definitional(&self) -> Option<bool> {
        self.product_definitional
    }
}
impl IDerivedShapeAspect for CentreOfSymmetry {}
impl ICentreOfSymmetry for CentreOfSymmetry {}
impl CentreOfSymmetry {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = CentreOfSymmetry::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => entity.of_shape = parameter.into(),
                3usize => entity.product_definitional = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait ICertification {
    fn name(&self) -> &Label;
    fn purpose(&self) -> &Text;
    fn kind(&self) -> &EntityRef;
}
#[derive(Default, Debug)]
pub struct Certification {
    name: Label,
    purpose: Text,
    kind: EntityRef,
}
impl ICertification for Certification {
    fn name(&self) -> &Label {
        &self.name
    }
    fn purpose(&self) -> &Text {
        &self.purpose
    }
    fn kind(&self) -> &EntityRef {
        &self.kind
    }
}
impl Certification {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = Certification::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => entity.purpose = parameter.into(),
                2usize => entity.kind = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait ICertificationAssignment {
    fn assigned_certification(&self) -> &EntityRef;
}
pub trait ICertificationType {
    fn description(&self) -> &Label;
}
#[derive(Default, Debug)]
pub struct CertificationType {
    description: Label,
}
impl ICertificationType for CertificationType {
    fn description(&self) -> &Label {
        &self.description
    }
}
impl CertificationType {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = CertificationType::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.description = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IChange: IActionAssignment {
    fn items(&self) -> &HashSet<EntityRef>;
}
#[derive(Default, Debug)]
pub struct Change {
    assigned_action: EntityRef,
    items: HashSet<EntityRef>,
}
impl IActionAssignment for Change {
    fn assigned_action(&self) -> &EntityRef {
        &self.assigned_action
    }
}
impl IChange for Change {
    fn items(&self) -> &HashSet<EntityRef> {
        &self.items
    }
}
impl Change {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = Change::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.assigned_action = parameter.into(),
                1usize => entity.items = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IChangeRequest: IActionRequestAssignment {
    fn items(&self) -> &HashSet<EntityRef>;
}
#[derive(Default, Debug)]
pub struct ChangeRequest {
    assigned_action_request: EntityRef,
    items: HashSet<EntityRef>,
}
impl IActionRequestAssignment for ChangeRequest {
    fn assigned_action_request(&self) -> &EntityRef {
        &self.assigned_action_request
    }
}
impl IChangeRequest for ChangeRequest {
    fn items(&self) -> &HashSet<EntityRef> {
        &self.items
    }
}
impl ChangeRequest {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = ChangeRequest::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.assigned_action_request = parameter.into(),
                1usize => entity.items = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait ICharacterGlyphFontUsage {
    fn character(&self) -> &EntityRef;
    fn font(&self) -> &EntityRef;
}
#[derive(Default, Debug)]
pub struct CharacterGlyphFontUsage {
    character: EntityRef,
    font: EntityRef,
}
impl ICharacterGlyphFontUsage for CharacterGlyphFontUsage {
    fn character(&self) -> &EntityRef {
        &self.character
    }
    fn font(&self) -> &EntityRef {
        &self.font
    }
}
impl CharacterGlyphFontUsage {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = CharacterGlyphFontUsage::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.character = parameter.into(),
                1usize => entity.font = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait ICharacterGlyphStyleOutline: IFoundedItem {
    fn outline_style(&self) -> &EntityRef;
}
#[derive(Default, Debug)]
pub struct CharacterGlyphStyleOutline {
    outline_style: EntityRef,
}
impl IFoundedItem for CharacterGlyphStyleOutline {}
impl ICharacterGlyphStyleOutline for CharacterGlyphStyleOutline {
    fn outline_style(&self) -> &EntityRef {
        &self.outline_style
    }
}
impl CharacterGlyphStyleOutline {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = CharacterGlyphStyleOutline::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.outline_style = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait ICharacterGlyphStyleStroke: IFoundedItem {
    fn stroke_style(&self) -> &EntityRef;
}
#[derive(Default, Debug)]
pub struct CharacterGlyphStyleStroke {
    stroke_style: EntityRef,
}
impl IFoundedItem for CharacterGlyphStyleStroke {}
impl ICharacterGlyphStyleStroke for CharacterGlyphStyleStroke {
    fn stroke_style(&self) -> &EntityRef {
        &self.stroke_style
    }
}
impl CharacterGlyphStyleStroke {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = CharacterGlyphStyleStroke::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.stroke_style = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait ICharacterGlyphSymbol: IGenericCharacterGlyphSymbol {
    fn character_box(&self) -> &EntityRef;
    fn baseline_ratio(&self) -> &RatioMeasure;
}
#[derive(Default, Debug)]
pub struct CharacterGlyphSymbol {
    name: Label,
    items: HashSet<EntityRef>,
    context_of_items: EntityRef,
    character_box: EntityRef,
    baseline_ratio: RatioMeasure,
}
impl IRepresentation for CharacterGlyphSymbol {
    fn name(&self) -> &Label {
        &self.name
    }
    fn items(&self) -> &HashSet<EntityRef> {
        &self.items
    }
    fn context_of_items(&self) -> &EntityRef {
        &self.context_of_items
    }
}
impl ISymbolRepresentation for CharacterGlyphSymbol {}
impl IGenericCharacterGlyphSymbol for CharacterGlyphSymbol {}
impl ICharacterGlyphSymbol for CharacterGlyphSymbol {
    fn character_box(&self) -> &EntityRef {
        &self.character_box
    }
    fn baseline_ratio(&self) -> &RatioMeasure {
        &self.baseline_ratio
    }
}
impl CharacterGlyphSymbol {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = CharacterGlyphSymbol::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => entity.items = parameter.into(),
                2usize => entity.context_of_items = parameter.into(),
                3usize => entity.character_box = parameter.into(),
                4usize => entity.baseline_ratio = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait ICharacterGlyphSymbolOutline: ICharacterGlyphSymbol {
    fn outlines(&self) -> &HashSet<EntityRef>;
}
#[derive(Default, Debug)]
pub struct CharacterGlyphSymbolOutline {
    name: Label,
    items: HashSet<EntityRef>,
    context_of_items: EntityRef,
    character_box: EntityRef,
    baseline_ratio: RatioMeasure,
    outlines: HashSet<EntityRef>,
}
impl IRepresentation for CharacterGlyphSymbolOutline {
    fn name(&self) -> &Label {
        &self.name
    }
    fn items(&self) -> &HashSet<EntityRef> {
        &self.items
    }
    fn context_of_items(&self) -> &EntityRef {
        &self.context_of_items
    }
}
impl ISymbolRepresentation for CharacterGlyphSymbolOutline {}
impl IGenericCharacterGlyphSymbol for CharacterGlyphSymbolOutline {}
impl ICharacterGlyphSymbol for CharacterGlyphSymbolOutline {
    fn character_box(&self) -> &EntityRef {
        &self.character_box
    }
    fn baseline_ratio(&self) -> &RatioMeasure {
        &self.baseline_ratio
    }
}
impl ICharacterGlyphSymbolOutline for CharacterGlyphSymbolOutline {
    fn outlines(&self) -> &HashSet<EntityRef> {
        &self.outlines
    }
}
impl CharacterGlyphSymbolOutline {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = CharacterGlyphSymbolOutline::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => entity.items = parameter.into(),
                2usize => entity.context_of_items = parameter.into(),
                3usize => entity.character_box = parameter.into(),
                4usize => entity.baseline_ratio = parameter.into(),
                5usize => entity.outlines = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait ICharacterGlyphSymbolStroke: ICharacterGlyphSymbol {
    fn strokes(&self) -> &HashSet<EntityRef>;
}
#[derive(Default, Debug)]
pub struct CharacterGlyphSymbolStroke {
    name: Label,
    items: HashSet<EntityRef>,
    context_of_items: EntityRef,
    character_box: EntityRef,
    baseline_ratio: RatioMeasure,
    strokes: HashSet<EntityRef>,
}
impl IRepresentation for CharacterGlyphSymbolStroke {
    fn name(&self) -> &Label {
        &self.name
    }
    fn items(&self) -> &HashSet<EntityRef> {
        &self.items
    }
    fn context_of_items(&self) -> &EntityRef {
        &self.context_of_items
    }
}
impl ISymbolRepresentation for CharacterGlyphSymbolStroke {}
impl IGenericCharacterGlyphSymbol for CharacterGlyphSymbolStroke {}
impl ICharacterGlyphSymbol for CharacterGlyphSymbolStroke {
    fn character_box(&self) -> &EntityRef {
        &self.character_box
    }
    fn baseline_ratio(&self) -> &RatioMeasure {
        &self.baseline_ratio
    }
}
impl ICharacterGlyphSymbolStroke for CharacterGlyphSymbolStroke {
    fn strokes(&self) -> &HashSet<EntityRef> {
        &self.strokes
    }
}
impl CharacterGlyphSymbolStroke {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = CharacterGlyphSymbolStroke::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => entity.items = parameter.into(),
                2usize => entity.context_of_items = parameter.into(),
                3usize => entity.character_box = parameter.into(),
                4usize => entity.baseline_ratio = parameter.into(),
                5usize => entity.strokes = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait ICharacteristicDataColumnHeader: IGeneralProperty {}
#[derive(Default, Debug)]
pub struct CharacteristicDataColumnHeader {
    id: Identifier,
    name: Label,
    description: Option<Text>,
}
impl IGeneralProperty for CharacteristicDataColumnHeader {
    fn id(&self) -> &Identifier {
        &self.id
    }
    fn name(&self) -> &Label {
        &self.name
    }
    fn description(&self) -> &Option<Text> {
        &self.description
    }
}
impl ICharacteristicDataColumnHeader for CharacteristicDataColumnHeader {}
impl CharacteristicDataColumnHeader {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = CharacteristicDataColumnHeader::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.id = parameter.into(),
                1usize => entity.name = parameter.into(),
                2usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
}
pub trait ICharacteristicDataColumnHeaderLink: IGeneralPropertyRelationship {}
#[derive(Default, Debug)]
pub struct CharacteristicDataColumnHeaderLink {
    name: Label,
    description: Option<Text>,
    relating_property: EntityRef,
    related_property: EntityRef,
}
impl IGeneralPropertyRelationship for CharacteristicDataColumnHeaderLink {
    fn name(&self) -> &Label {
        &self.name
    }
    fn description(&self) -> &Option<Text> {
        &self.description
    }
    fn relating_property(&self) -> &EntityRef {
        &self.relating_property
    }
    fn related_property(&self) -> &EntityRef {
        &self.related_property
    }
}
impl ICharacteristicDataColumnHeaderLink for CharacteristicDataColumnHeaderLink {}
impl CharacteristicDataColumnHeaderLink {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = CharacteristicDataColumnHeaderLink::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => entity.relating_property = parameter.into(),
                3usize => entity.related_property = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait ICharacteristicDataTableHeader: IGeneralProperty {}
#[derive(Default, Debug)]
pub struct CharacteristicDataTableHeader {
    id: Identifier,
    name: Label,
    description: Option<Text>,
}
impl IGeneralProperty for CharacteristicDataTableHeader {
    fn id(&self) -> &Identifier {
        &self.id
    }
    fn name(&self) -> &Label {
        &self.name
    }
    fn description(&self) -> &Option<Text> {
        &self.description
    }
}
impl ICharacteristicDataTableHeader for CharacteristicDataTableHeader {}
impl CharacteristicDataTableHeader {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = CharacteristicDataTableHeader::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.id = parameter.into(),
                1usize => entity.name = parameter.into(),
                2usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
}
pub trait ICharacteristicDataTableHeaderDecomposition: IGeneralPropertyRelationship {}
#[derive(Default, Debug)]
pub struct CharacteristicDataTableHeaderDecomposition {
    name: Label,
    description: Option<Text>,
    relating_property: EntityRef,
    related_property: EntityRef,
}
impl IGeneralPropertyRelationship for CharacteristicDataTableHeaderDecomposition {
    fn name(&self) -> &Label {
        &self.name
    }
    fn description(&self) -> &Option<Text> {
        &self.description
    }
    fn relating_property(&self) -> &EntityRef {
        &self.relating_property
    }
    fn related_property(&self) -> &EntityRef {
        &self.related_property
    }
}
impl ICharacteristicDataTableHeaderDecomposition for CharacteristicDataTableHeaderDecomposition {}
impl CharacteristicDataTableHeaderDecomposition {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = CharacteristicDataTableHeaderDecomposition::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => entity.relating_property = parameter.into(),
                3usize => entity.related_property = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait ICharacteristicType: IGroup {}
#[derive(Default, Debug)]
pub struct CharacteristicType {
    name: Label,
    description: Option<Text>,
}
impl IGroup for CharacteristicType {
    fn name(&self) -> &Label {
        &self.name
    }
    fn description(&self) -> &Option<Text> {
        &self.description
    }
}
impl ICharacteristicType for CharacteristicType {}
impl CharacteristicType {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = CharacteristicType::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
}
pub trait ICharacterizedClass: ICharacterizedObject + IClass {}
#[derive(Default, Debug)]
pub struct CharacterizedClass {
    name: Label,
    description: Option<Text>,
}
impl ICharacterizedObject for CharacterizedClass {
    fn name(&self) -> &Label {
        &self.name
    }
    fn description(&self) -> &Option<Text> {
        &self.description
    }
}
impl IGroup for CharacterizedClass {
    fn name(&self) -> &Label {
        &self.name
    }
    fn description(&self) -> &Option<Text> {
        &self.description
    }
}
impl IClass for CharacterizedClass {}
impl ICharacterizedClass for CharacterizedClass {}
impl CharacterizedClass {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = CharacterizedClass::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
}
pub trait ICharacterizedObject {
    fn name(&self) -> &Label;
    fn description(&self) -> &Option<Text>;
}
#[derive(Default, Debug)]
pub struct CharacterizedObject {
    name: Label,
    description: Option<Text>,
}
impl ICharacterizedObject for CharacterizedObject {
    fn name(&self) -> &Label {
        &self.name
    }
    fn description(&self) -> &Option<Text> {
        &self.description
    }
}
impl CharacterizedObject {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = CharacterizedObject::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
}
pub trait ICircle: IConic {
    fn radius(&self) -> &PositiveLengthMeasure;
}
#[derive(Default, Debug)]
pub struct Circle {
    name: Label,
    position: EntityRef,
    radius: PositiveLengthMeasure,
}
impl IRepresentationItem for Circle {
    fn name(&self) -> &Label {
        &self.name
    }
}
impl IGeometricRepresentationItem for Circle {}
impl ICurve for Circle {}
impl IConic for Circle {
    fn position(&self) -> &EntityRef {
        &self.position
    }
}
impl ICircle for Circle {
    fn radius(&self) -> &PositiveLengthMeasure {
        &self.radius
    }
}
impl Circle {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = Circle::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => entity.position = parameter.into(),
                2usize => entity.radius = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait ICircularRunoutTolerance: IGeometricToleranceWithDatumReference {}
#[derive(Default, Debug)]
pub struct CircularRunoutTolerance {
    name: Label,
    description: Text,
    magnitude: EntityRef,
    toleranced_shape_aspect: EntityRef,
    datum_system: HashSet<EntityRef>,
}
impl IGeometricTolerance for CircularRunoutTolerance {
    fn name(&self) -> &Label {
        &self.name
    }
    fn description(&self) -> &Text {
        &self.description
    }
    fn magnitude(&self) -> &EntityRef {
        &self.magnitude
    }
    fn toleranced_shape_aspect(&self) -> &EntityRef {
        &self.toleranced_shape_aspect
    }
}
impl IGeometricToleranceWithDatumReference for CircularRunoutTolerance {
    fn datum_system(&self) -> &HashSet<EntityRef> {
        &self.datum_system
    }
}
impl ICircularRunoutTolerance for CircularRunoutTolerance {}
impl CircularRunoutTolerance {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = CircularRunoutTolerance::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => entity.description = parameter.into(),
                2usize => entity.magnitude = parameter.into(),
                3usize => entity.toleranced_shape_aspect = parameter.into(),
                4usize => entity.datum_system = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IClass: IGroup {}
#[derive(Default, Debug)]
pub struct Class {
    name: Label,
    description: Option<Text>,
}
impl IGroup for Class {
    fn name(&self) -> &Label {
        &self.name
    }
    fn description(&self) -> &Option<Text> {
        &self.description
    }
}
impl IClass for Class {}
impl Class {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = Class::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
}
pub trait IClassByExtension: IClass {}
#[derive(Default, Debug)]
pub struct ClassByExtension {
    name: Label,
    description: Option<Text>,
}
impl IGroup for ClassByExtension {
    fn name(&self) -> &Label {
        &self.name
    }
    fn description(&self) -> &Option<Text> {
        &self.description
    }
}
impl IClass for ClassByExtension {}
impl IClassByExtension for ClassByExtension {}
impl ClassByExtension {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = ClassByExtension::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
}
pub trait IClassByIntension: IClass {}
#[derive(Default, Debug)]
pub struct ClassByIntension {
    name: Label,
    description: Option<Text>,
}
impl IGroup for ClassByIntension {
    fn name(&self) -> &Label {
        &self.name
    }
    fn description(&self) -> &Option<Text> {
        &self.description
    }
}
impl IClass for ClassByIntension {}
impl IClassByIntension for ClassByIntension {}
impl ClassByIntension {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = ClassByIntension::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
}
pub trait IClassSystem: IGroup {}
#[derive(Default, Debug)]
pub struct ClassSystem {
    name: Label,
    description: Option<Text>,
}
impl IGroup for ClassSystem {
    fn name(&self) -> &Label {
        &self.name
    }
    fn description(&self) -> &Option<Text> {
        &self.description
    }
}
impl IClassSystem for ClassSystem {}
impl ClassSystem {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = ClassSystem::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
}
pub trait IClassUsageEffectivityContextAssignment: IEffectivityContextAssignment {
    fn items(&self) -> &HashSet<EntityRef>;
}
#[derive(Default, Debug)]
pub struct ClassUsageEffectivityContextAssignment {
    assigned_effectivity_assignment: EntityRef,
    role: EntityRef,
    items: HashSet<EntityRef>,
}
impl IEffectivityContextAssignment for ClassUsageEffectivityContextAssignment {
    fn assigned_effectivity_assignment(&self) -> &EntityRef {
        &self.assigned_effectivity_assignment
    }
    fn role(&self) -> &EntityRef {
        &self.role
    }
}
impl IClassUsageEffectivityContextAssignment for ClassUsageEffectivityContextAssignment {
    fn items(&self) -> &HashSet<EntityRef> {
        &self.items
    }
}
impl ClassUsageEffectivityContextAssignment {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = ClassUsageEffectivityContextAssignment::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.assigned_effectivity_assignment = parameter.into(),
                1usize => entity.role = parameter.into(),
                2usize => entity.items = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IClassificationAssignment {
    fn assigned_class(&self) -> &EntityRef;
    fn role(&self) -> &EntityRef;
}
pub trait IClassificationRole {
    fn name(&self) -> &Label;
    fn description(&self) -> &Option<Text>;
}
#[derive(Default, Debug)]
pub struct ClassificationRole {
    name: Label,
    description: Option<Text>,
}
impl IClassificationRole for ClassificationRole {
    fn name(&self) -> &Label {
        &self.name
    }
    fn description(&self) -> &Option<Text> {
        &self.description
    }
}
impl ClassificationRole {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = ClassificationRole::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
}
pub trait IClosedShell: IConnectedFaceSet {}
#[derive(Default, Debug)]
pub struct ClosedShell {
    name: Label,
    cfs_faces: HashSet<EntityRef>,
}
impl IRepresentationItem for ClosedShell {
    fn name(&self) -> &Label {
        &self.name
    }
}
impl ITopologicalRepresentationItem for ClosedShell {}
impl IConnectedFaceSet for ClosedShell {
    fn cfs_faces(&self) -> &HashSet<EntityRef> {
        &self.cfs_faces
    }
}
impl IClosedShell for ClosedShell {}
impl ClosedShell {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = ClosedShell::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => entity.cfs_faces = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait ICoaxialityTolerance: IGeometricToleranceWithDatumReference {}
#[derive(Default, Debug)]
pub struct CoaxialityTolerance {
    name: Label,
    description: Text,
    magnitude: EntityRef,
    toleranced_shape_aspect: EntityRef,
    datum_system: HashSet<EntityRef>,
}
impl IGeometricTolerance for CoaxialityTolerance {
    fn name(&self) -> &Label {
        &self.name
    }
    fn description(&self) -> &Text {
        &self.description
    }
    fn magnitude(&self) -> &EntityRef {
        &self.magnitude
    }
    fn toleranced_shape_aspect(&self) -> &EntityRef {
        &self.toleranced_shape_aspect
    }
}
impl IGeometricToleranceWithDatumReference for CoaxialityTolerance {
    fn datum_system(&self) -> &HashSet<EntityRef> {
        &self.datum_system
    }
}
impl ICoaxialityTolerance for CoaxialityTolerance {}
impl CoaxialityTolerance {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = CoaxialityTolerance::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => entity.description = parameter.into(),
                2usize => entity.magnitude = parameter.into(),
                3usize => entity.toleranced_shape_aspect = parameter.into(),
                4usize => entity.datum_system = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IColour {}
#[derive(Default, Debug)]
pub struct Colour {}
impl IColour for Colour {}
impl Colour {
    pub fn form_parameters(_parameters: Vec<Parameter>) -> Self {
        Colour::default()
    }
}
pub trait IColourRgb: IColourSpecification {
    fn red(&self) -> Real;
    fn green(&self) -> Real;
    fn blue(&self) -> Real;
}
#[derive(Default, Debug)]
pub struct ColourRgb {
    name: Label,
    red: Real,
    green: Real,
    blue: Real,
}
impl IColour for ColourRgb {}
impl IColourSpecification for ColourRgb {
    fn name(&self) -> &Label {
        &self.name
    }
}
impl IColourRgb for ColourRgb {
    fn red(&self) -> Real {
        self.red
    }
    fn green(&self) -> Real {
        self.green
    }
    fn blue(&self) -> Real {
        self.blue
    }
}
impl ColourRgb {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = ColourRgb::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => entity.red = parameter.into(),
                2usize => entity.green = parameter.into(),
                3usize => entity.blue = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IColourSpecification: IColour {
    fn name(&self) -> &Label;
}
#[derive(Default, Debug)]
pub struct ColourSpecification {
    name: Label,
}
impl IColour for ColourSpecification {}
impl IColourSpecification for ColourSpecification {
    fn name(&self) -> &Label {
        &self.name
    }
}
impl ColourSpecification {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = ColourSpecification::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait ICommonDatum: ICompositeShapeAspect + IDatum {}
#[derive(Default, Debug)]
pub struct CommonDatum {
    name: Label,
    description: Option<Text>,
    of_shape: EntityRef,
    product_definitional: Option<bool>,
    identification: Identifier,
}
impl IShapeAspect for CommonDatum {
    fn name(&self) -> &Label {
        &self.name
    }
    fn description(&self) -> &Option<Text> {
        &self.description
    }
    fn of_shape(&self) -> &EntityRef {
        &self.of_shape
    }
    fn product_definitional(&self) -> Option<bool> {
        self.product_definitional
    }
}
impl ICompositeShapeAspect for CommonDatum {}
impl ICommonDatum for CommonDatum {}
impl IDatum for CommonDatum {
    fn identification(&self) -> &Identifier {
        &self.identification
    }
}
impl CommonDatum {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = CommonDatum::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => entity.of_shape = parameter.into(),
                3usize => entity.product_definitional = parameter.into(),
                4usize => entity.identification = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IComparisonExpression: IBooleanExpression + IBinaryGenericExpression {
    fn operands(&self) -> &Vec<EntityRef>;
}
pub trait IComplexClause: ICompoundRepresentationItem {}
#[derive(Default, Debug)]
pub struct ComplexClause {
    name: Label,
    item_element: CompoundItemDefinition,
}
impl IRepresentationItem for ComplexClause {
    fn name(&self) -> &Label {
        &self.name
    }
}
impl ICompoundRepresentationItem for ComplexClause {
    fn item_element(&self) -> &CompoundItemDefinition {
        &self.item_element
    }
}
impl IComplexClause for ComplexClause {}
impl ComplexClause {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = ComplexClause::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => entity.item_element = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IComplexConjunctiveClause: IComplexClause {}
#[derive(Default, Debug)]
pub struct ComplexConjunctiveClause {
    name: Label,
    item_element: CompoundItemDefinition,
}
impl IRepresentationItem for ComplexConjunctiveClause {
    fn name(&self) -> &Label {
        &self.name
    }
}
impl ICompoundRepresentationItem for ComplexConjunctiveClause {
    fn item_element(&self) -> &CompoundItemDefinition {
        &self.item_element
    }
}
impl IComplexClause for ComplexConjunctiveClause {}
impl IComplexConjunctiveClause for ComplexConjunctiveClause {}
impl ComplexConjunctiveClause {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = ComplexConjunctiveClause::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => entity.item_element = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IComplexDisjunctiveClause: IComplexClause {}
#[derive(Default, Debug)]
pub struct ComplexDisjunctiveClause {
    name: Label,
    item_element: CompoundItemDefinition,
}
impl IRepresentationItem for ComplexDisjunctiveClause {
    fn name(&self) -> &Label {
        &self.name
    }
}
impl ICompoundRepresentationItem for ComplexDisjunctiveClause {
    fn item_element(&self) -> &CompoundItemDefinition {
        &self.item_element
    }
}
impl IComplexClause for ComplexDisjunctiveClause {}
impl IComplexDisjunctiveClause for ComplexDisjunctiveClause {}
impl ComplexDisjunctiveClause {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = ComplexDisjunctiveClause::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => entity.item_element = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IComplexShelledSolid: IShelledSolid {
    fn thickened_face_list(&self) -> &Vec<HashSet<EntityRef>>;
    fn thickness_list(&self) -> &Vec<LengthMeasure>;
}
#[derive(Default, Debug)]
pub struct ComplexShelledSolid {
    name: Label,
    rationale: Text,
    base_solid: EntityRef,
    deleted_face_set: HashSet<EntityRef>,
    thickness: LengthMeasure,
    thickened_face_list: Vec<HashSet<EntityRef>>,
    thickness_list: Vec<LengthMeasure>,
}
impl IRepresentationItem for ComplexShelledSolid {
    fn name(&self) -> &Label {
        &self.name
    }
}
impl IGeometricRepresentationItem for ComplexShelledSolid {}
impl ISolidModel for ComplexShelledSolid {}
impl IModifiedSolid for ComplexShelledSolid {
    fn rationale(&self) -> &Text {
        &self.rationale
    }
    fn base_solid(&self) -> &EntityRef {
        &self.base_solid
    }
}
impl IShelledSolid for ComplexShelledSolid {
    fn deleted_face_set(&self) -> &HashSet<EntityRef> {
        &self.deleted_face_set
    }
    fn thickness(&self) -> &LengthMeasure {
        &self.thickness
    }
}
impl IComplexShelledSolid for ComplexShelledSolid {
    fn thickened_face_list(&self) -> &Vec<HashSet<EntityRef>> {
        &self.thickened_face_list
    }
    fn thickness_list(&self) -> &Vec<LengthMeasure> {
        &self.thickness_list
    }
}
impl ComplexShelledSolid {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = ComplexShelledSolid::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => entity.rationale = parameter.into(),
                2usize => entity.base_solid = parameter.into(),
                3usize => entity.deleted_face_set = parameter.into(),
                4usize => entity.thickness = parameter.into(),
                5usize => entity.thickened_face_list = parameter.into(),
                6usize => entity.thickness_list = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait ICompositeAssemblyDefinition: IProductDefinition {}
#[derive(Default, Debug)]
pub struct CompositeAssemblyDefinition {
    id: Identifier,
    description: Option<Text>,
    formation: EntityRef,
    frame_of_reference: EntityRef,
}
impl IProductDefinition for CompositeAssemblyDefinition {
    fn id(&self) -> &Identifier {
        &self.id
    }
    fn description(&self) -> &Option<Text> {
        &self.description
    }
    fn formation(&self) -> &EntityRef {
        &self.formation
    }
    fn frame_of_reference(&self) -> &EntityRef {
        &self.frame_of_reference
    }
}
impl ICompositeAssemblyDefinition for CompositeAssemblyDefinition {}
impl CompositeAssemblyDefinition {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = CompositeAssemblyDefinition::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.id = parameter.into(),
                1usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => entity.formation = parameter.into(),
                3usize => entity.frame_of_reference = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait ICompositeAssemblySequenceDefinition: IProductDefinition {}
#[derive(Default, Debug)]
pub struct CompositeAssemblySequenceDefinition {
    id: Identifier,
    description: Option<Text>,
    formation: EntityRef,
    frame_of_reference: EntityRef,
}
impl IProductDefinition for CompositeAssemblySequenceDefinition {
    fn id(&self) -> &Identifier {
        &self.id
    }
    fn description(&self) -> &Option<Text> {
        &self.description
    }
    fn formation(&self) -> &EntityRef {
        &self.formation
    }
    fn frame_of_reference(&self) -> &EntityRef {
        &self.frame_of_reference
    }
}
impl ICompositeAssemblySequenceDefinition for CompositeAssemblySequenceDefinition {}
impl CompositeAssemblySequenceDefinition {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = CompositeAssemblySequenceDefinition::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.id = parameter.into(),
                1usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => entity.formation = parameter.into(),
                3usize => entity.frame_of_reference = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait ICompositeAssemblyTable: IPartLaminateTable {}
#[derive(Default, Debug)]
pub struct CompositeAssemblyTable {
    id: Identifier,
    description: Option<Text>,
    formation: EntityRef,
    frame_of_reference: EntityRef,
}
impl IProductDefinition for CompositeAssemblyTable {
    fn id(&self) -> &Identifier {
        &self.id
    }
    fn description(&self) -> &Option<Text> {
        &self.description
    }
    fn formation(&self) -> &EntityRef {
        &self.formation
    }
    fn frame_of_reference(&self) -> &EntityRef {
        &self.frame_of_reference
    }
}
impl ILaminateTable for CompositeAssemblyTable {}
impl IPartLaminateTable for CompositeAssemblyTable {}
impl ICompositeAssemblyTable for CompositeAssemblyTable {}
impl CompositeAssemblyTable {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = CompositeAssemblyTable::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.id = parameter.into(),
                1usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => entity.formation = parameter.into(),
                3usize => entity.frame_of_reference = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait ICompositeCurve: IBoundedCurve {
    fn segments(&self) -> &Vec<EntityRef>;
    fn self_intersect(&self) -> Option<bool>;
}
#[derive(Default, Debug)]
pub struct CompositeCurve {
    name: Label,
    segments: Vec<EntityRef>,
    self_intersect: Option<bool>,
}
impl IRepresentationItem for CompositeCurve {
    fn name(&self) -> &Label {
        &self.name
    }
}
impl IGeometricRepresentationItem for CompositeCurve {}
impl ICurve for CompositeCurve {}
impl IBoundedCurve for CompositeCurve {}
impl ICompositeCurve for CompositeCurve {
    fn segments(&self) -> &Vec<EntityRef> {
        &self.segments
    }
    fn self_intersect(&self) -> Option<bool> {
        self.self_intersect
    }
}
impl CompositeCurve {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = CompositeCurve::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => entity.segments = parameter.into(),
                2usize => entity.self_intersect = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait ICompositeCurveOnSurface: ICompositeCurve {}
#[derive(Default, Debug)]
pub struct CompositeCurveOnSurface {
    name: Label,
    segments: Vec<EntityRef>,
    self_intersect: Option<bool>,
}
impl IRepresentationItem for CompositeCurveOnSurface {
    fn name(&self) -> &Label {
        &self.name
    }
}
impl IGeometricRepresentationItem for CompositeCurveOnSurface {}
impl ICurve for CompositeCurveOnSurface {}
impl IBoundedCurve for CompositeCurveOnSurface {}
impl ICompositeCurve for CompositeCurveOnSurface {
    fn segments(&self) -> &Vec<EntityRef> {
        &self.segments
    }
    fn self_intersect(&self) -> Option<bool> {
        self.self_intersect
    }
}
impl ICompositeCurveOnSurface for CompositeCurveOnSurface {}
impl CompositeCurveOnSurface {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = CompositeCurveOnSurface::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => entity.segments = parameter.into(),
                2usize => entity.self_intersect = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait ICompositeCurveSegment: IFoundedItem {
    fn transition(&self) -> &TransitionCode;
    fn same_sense(&self) -> bool;
    fn parent_curve(&self) -> &EntityRef;
}
#[derive(Default, Debug)]
pub struct CompositeCurveSegment {
    transition: TransitionCode,
    same_sense: bool,
    parent_curve: EntityRef,
}
impl IFoundedItem for CompositeCurveSegment {}
impl ICompositeCurveSegment for CompositeCurveSegment {
    fn transition(&self) -> &TransitionCode {
        &self.transition
    }
    fn same_sense(&self) -> bool {
        self.same_sense
    }
    fn parent_curve(&self) -> &EntityRef {
        &self.parent_curve
    }
}
impl CompositeCurveSegment {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = CompositeCurveSegment::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.transition = parameter.into(),
                1usize => entity.same_sense = parameter.into(),
                2usize => entity.parent_curve = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait ICompositeMaterialDesignation: IMaterialDesignation {}
#[derive(Default, Debug)]
pub struct CompositeMaterialDesignation {
    name: Label,
    definitions: HashSet<EntityRef>,
}
impl IMaterialDesignation for CompositeMaterialDesignation {
    fn name(&self) -> &Label {
        &self.name
    }
    fn definitions(&self) -> &HashSet<EntityRef> {
        &self.definitions
    }
}
impl ICompositeMaterialDesignation for CompositeMaterialDesignation {}
impl CompositeMaterialDesignation {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = CompositeMaterialDesignation::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => entity.definitions = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait ICompositeShapeAspect: IShapeAspect {}
#[derive(Default, Debug)]
pub struct CompositeShapeAspect {
    name: Label,
    description: Option<Text>,
    of_shape: EntityRef,
    product_definitional: Option<bool>,
}
impl IShapeAspect for CompositeShapeAspect {
    fn name(&self) -> &Label {
        &self.name
    }
    fn description(&self) -> &Option<Text> {
        &self.description
    }
    fn of_shape(&self) -> &EntityRef {
        &self.of_shape
    }
    fn product_definitional(&self) -> Option<bool> {
        self.product_definitional
    }
}
impl ICompositeShapeAspect for CompositeShapeAspect {}
impl CompositeShapeAspect {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = CompositeShapeAspect::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => entity.of_shape = parameter.into(),
                3usize => entity.product_definitional = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait ICompositeSheetRepresentation: IShapeRepresentation {}
#[derive(Default, Debug)]
pub struct CompositeSheetRepresentation {
    name: Label,
    items: HashSet<EntityRef>,
    context_of_items: EntityRef,
}
impl IRepresentation for CompositeSheetRepresentation {
    fn name(&self) -> &Label {
        &self.name
    }
    fn items(&self) -> &HashSet<EntityRef> {
        &self.items
    }
    fn context_of_items(&self) -> &EntityRef {
        &self.context_of_items
    }
}
impl IShapeRepresentation for CompositeSheetRepresentation {}
impl ICompositeSheetRepresentation for CompositeSheetRepresentation {}
impl CompositeSheetRepresentation {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = CompositeSheetRepresentation::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => entity.items = parameter.into(),
                2usize => entity.context_of_items = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait ICompositeText: IGeometricRepresentationItem {
    fn collected_text(&self) -> &HashSet<EntityRef>;
}
#[derive(Default, Debug)]
pub struct CompositeText {
    name: Label,
    collected_text: HashSet<EntityRef>,
}
impl IRepresentationItem for CompositeText {
    fn name(&self) -> &Label {
        &self.name
    }
}
impl IGeometricRepresentationItem for CompositeText {}
impl ICompositeText for CompositeText {
    fn collected_text(&self) -> &HashSet<EntityRef> {
        &self.collected_text
    }
}
impl CompositeText {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = CompositeText::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => entity.collected_text = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait ICompositeTextWithAssociatedCurves: ICompositeText {
    fn associated_curves(&self) -> &HashSet<EntityRef>;
}
#[derive(Default, Debug)]
pub struct CompositeTextWithAssociatedCurves {
    name: Label,
    collected_text: HashSet<EntityRef>,
    associated_curves: HashSet<EntityRef>,
}
impl IRepresentationItem for CompositeTextWithAssociatedCurves {
    fn name(&self) -> &Label {
        &self.name
    }
}
impl IGeometricRepresentationItem for CompositeTextWithAssociatedCurves {}
impl ICompositeText for CompositeTextWithAssociatedCurves {
    fn collected_text(&self) -> &HashSet<EntityRef> {
        &self.collected_text
    }
}
impl ICompositeTextWithAssociatedCurves for CompositeTextWithAssociatedCurves {
    fn associated_curves(&self) -> &HashSet<EntityRef> {
        &self.associated_curves
    }
}
impl CompositeTextWithAssociatedCurves {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = CompositeTextWithAssociatedCurves::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => entity.collected_text = parameter.into(),
                2usize => entity.associated_curves = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait ICompositeTextWithBlankingBox: ICompositeText {
    fn blanking(&self) -> &EntityRef;
}
#[derive(Default, Debug)]
pub struct CompositeTextWithBlankingBox {
    name: Label,
    collected_text: HashSet<EntityRef>,
    blanking: EntityRef,
}
impl IRepresentationItem for CompositeTextWithBlankingBox {
    fn name(&self) -> &Label {
        &self.name
    }
}
impl IGeometricRepresentationItem for CompositeTextWithBlankingBox {}
impl ICompositeText for CompositeTextWithBlankingBox {
    fn collected_text(&self) -> &HashSet<EntityRef> {
        &self.collected_text
    }
}
impl ICompositeTextWithBlankingBox for CompositeTextWithBlankingBox {
    fn blanking(&self) -> &EntityRef {
        &self.blanking
    }
}
impl CompositeTextWithBlankingBox {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = CompositeTextWithBlankingBox::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => entity.collected_text = parameter.into(),
                2usize => entity.blanking = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait ICompositeTextWithDelineation: ICompositeText {
    fn delineation(&self) -> &TextDelineation;
}
#[derive(Default, Debug)]
pub struct CompositeTextWithDelineation {
    name: Label,
    collected_text: HashSet<EntityRef>,
    delineation: TextDelineation,
}
impl IRepresentationItem for CompositeTextWithDelineation {
    fn name(&self) -> &Label {
        &self.name
    }
}
impl IGeometricRepresentationItem for CompositeTextWithDelineation {}
impl ICompositeText for CompositeTextWithDelineation {
    fn collected_text(&self) -> &HashSet<EntityRef> {
        &self.collected_text
    }
}
impl ICompositeTextWithDelineation for CompositeTextWithDelineation {
    fn delineation(&self) -> &TextDelineation {
        &self.delineation
    }
}
impl CompositeTextWithDelineation {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = CompositeTextWithDelineation::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => entity.collected_text = parameter.into(),
                2usize => entity.delineation = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait ICompositeTextWithExtent: ICompositeText {
    fn extent(&self) -> &EntityRef;
}
#[derive(Default, Debug)]
pub struct CompositeTextWithExtent {
    name: Label,
    collected_text: HashSet<EntityRef>,
    extent: EntityRef,
}
impl IRepresentationItem for CompositeTextWithExtent {
    fn name(&self) -> &Label {
        &self.name
    }
}
impl IGeometricRepresentationItem for CompositeTextWithExtent {}
impl ICompositeText for CompositeTextWithExtent {
    fn collected_text(&self) -> &HashSet<EntityRef> {
        &self.collected_text
    }
}
impl ICompositeTextWithExtent for CompositeTextWithExtent {
    fn extent(&self) -> &EntityRef {
        &self.extent
    }
}
impl CompositeTextWithExtent {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = CompositeTextWithExtent::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => entity.collected_text = parameter.into(),
                2usize => entity.extent = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait ICompoundRepresentationItem: IRepresentationItem {
    fn item_element(&self) -> &CompoundItemDefinition;
}
#[derive(Default, Debug)]
pub struct CompoundRepresentationItem {
    name: Label,
    item_element: CompoundItemDefinition,
}
impl IRepresentationItem for CompoundRepresentationItem {
    fn name(&self) -> &Label {
        &self.name
    }
}
impl ICompoundRepresentationItem for CompoundRepresentationItem {
    fn item_element(&self) -> &CompoundItemDefinition {
        &self.item_element
    }
}
impl CompoundRepresentationItem {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = CompoundRepresentationItem::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => entity.item_element = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait ICompoundShapeRepresentation: IShapeRepresentation {}
#[derive(Default, Debug)]
pub struct CompoundShapeRepresentation {
    name: Label,
    items: HashSet<EntityRef>,
    context_of_items: EntityRef,
}
impl IRepresentation for CompoundShapeRepresentation {
    fn name(&self) -> &Label {
        &self.name
    }
    fn items(&self) -> &HashSet<EntityRef> {
        &self.items
    }
    fn context_of_items(&self) -> &EntityRef {
        &self.context_of_items
    }
}
impl IShapeRepresentation for CompoundShapeRepresentation {}
impl ICompoundShapeRepresentation for CompoundShapeRepresentation {}
impl CompoundShapeRepresentation {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = CompoundShapeRepresentation::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => entity.items = parameter.into(),
                2usize => entity.context_of_items = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IConcentricityTolerance: IGeometricToleranceWithDatumReference {}
#[derive(Default, Debug)]
pub struct ConcentricityTolerance {
    name: Label,
    description: Text,
    magnitude: EntityRef,
    toleranced_shape_aspect: EntityRef,
    datum_system: HashSet<EntityRef>,
}
impl IGeometricTolerance for ConcentricityTolerance {
    fn name(&self) -> &Label {
        &self.name
    }
    fn description(&self) -> &Text {
        &self.description
    }
    fn magnitude(&self) -> &EntityRef {
        &self.magnitude
    }
    fn toleranced_shape_aspect(&self) -> &EntityRef {
        &self.toleranced_shape_aspect
    }
}
impl IGeometricToleranceWithDatumReference for ConcentricityTolerance {
    fn datum_system(&self) -> &HashSet<EntityRef> {
        &self.datum_system
    }
}
impl IConcentricityTolerance for ConcentricityTolerance {}
impl ConcentricityTolerance {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = ConcentricityTolerance::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => entity.description = parameter.into(),
                2usize => entity.magnitude = parameter.into(),
                3usize => entity.toleranced_shape_aspect = parameter.into(),
                4usize => entity.datum_system = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IConceptFeatureOperator {
    fn name(&self) -> &Label;
    fn description(&self) -> &Option<Text>;
}
#[derive(Default, Debug)]
pub struct ConceptFeatureOperator {
    name: Label,
    description: Option<Text>,
}
impl IConceptFeatureOperator for ConceptFeatureOperator {
    fn name(&self) -> &Label {
        &self.name
    }
    fn description(&self) -> &Option<Text> {
        &self.description
    }
}
impl ConceptFeatureOperator {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = ConceptFeatureOperator::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
}
pub trait IConceptFeatureRelationship {
    fn name(&self) -> &Label;
    fn description(&self) -> &Option<Text>;
    fn relating_product_concept_feature(&self) -> &EntityRef;
    fn related_product_concept_feature(&self) -> &EntityRef;
}
#[derive(Default, Debug)]
pub struct ConceptFeatureRelationship {
    name: Label,
    description: Option<Text>,
    relating_product_concept_feature: EntityRef,
    related_product_concept_feature: EntityRef,
}
impl IConceptFeatureRelationship for ConceptFeatureRelationship {
    fn name(&self) -> &Label {
        &self.name
    }
    fn description(&self) -> &Option<Text> {
        &self.description
    }
    fn relating_product_concept_feature(&self) -> &EntityRef {
        &self.relating_product_concept_feature
    }
    fn related_product_concept_feature(&self) -> &EntityRef {
        &self.related_product_concept_feature
    }
}
impl ConceptFeatureRelationship {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = ConceptFeatureRelationship::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => entity.relating_product_concept_feature = parameter.into(),
                3usize => entity.related_product_concept_feature = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IConceptFeatureRelationshipWithCondition: IConceptFeatureRelationship {
    fn conditional_operator(&self) -> &EntityRef;
}
#[derive(Default, Debug)]
pub struct ConceptFeatureRelationshipWithCondition {
    name: Label,
    description: Option<Text>,
    relating_product_concept_feature: EntityRef,
    related_product_concept_feature: EntityRef,
    conditional_operator: EntityRef,
}
impl IConceptFeatureRelationship for ConceptFeatureRelationshipWithCondition {
    fn name(&self) -> &Label {
        &self.name
    }
    fn description(&self) -> &Option<Text> {
        &self.description
    }
    fn relating_product_concept_feature(&self) -> &EntityRef {
        &self.relating_product_concept_feature
    }
    fn related_product_concept_feature(&self) -> &EntityRef {
        &self.related_product_concept_feature
    }
}
impl IConceptFeatureRelationshipWithCondition for ConceptFeatureRelationshipWithCondition {
    fn conditional_operator(&self) -> &EntityRef {
        &self.conditional_operator
    }
}
impl ConceptFeatureRelationshipWithCondition {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = ConceptFeatureRelationshipWithCondition::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => entity.relating_product_concept_feature = parameter.into(),
                3usize => entity.related_product_concept_feature = parameter.into(),
                4usize => entity.conditional_operator = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IConditionalConceptFeature: IProductConceptFeature {
    fn condition(&self) -> &EntityRef;
}
#[derive(Default, Debug)]
pub struct ConditionalConceptFeature {
    id: Identifier,
    name: Label,
    description: Option<Text>,
    condition: EntityRef,
}
impl IProductConceptFeature for ConditionalConceptFeature {
    fn id(&self) -> &Identifier {
        &self.id
    }
    fn name(&self) -> &Label {
        &self.name
    }
    fn description(&self) -> &Option<Text> {
        &self.description
    }
}
impl IConditionalConceptFeature for ConditionalConceptFeature {
    fn condition(&self) -> &EntityRef {
        &self.condition
    }
}
impl ConditionalConceptFeature {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = ConditionalConceptFeature::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.id = parameter.into(),
                1usize => entity.name = parameter.into(),
                2usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => entity.condition = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IConductanceMeasureWithUnit: IMeasureWithUnit {}
#[derive(Default, Debug)]
pub struct ConductanceMeasureWithUnit {
    value_component: MeasureValue,
    unit_component: EntityRef,
}
impl IMeasureWithUnit for ConductanceMeasureWithUnit {
    fn value_component(&self) -> &MeasureValue {
        &self.value_component
    }
    fn unit_component(&self) -> &EntityRef {
        &self.unit_component
    }
}
impl IConductanceMeasureWithUnit for ConductanceMeasureWithUnit {}
impl ConductanceMeasureWithUnit {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = ConductanceMeasureWithUnit::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.value_component = parameter.into(),
                1usize => entity.unit_component = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IConductanceUnit: IDerivedUnit {}
#[derive(Default, Debug)]
pub struct ConductanceUnit {
    elements: HashSet<EntityRef>,
}
impl IDerivedUnit for ConductanceUnit {
    fn elements(&self) -> &HashSet<EntityRef> {
        &self.elements
    }
}
impl IConductanceUnit for ConductanceUnit {}
impl ConductanceUnit {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = ConductanceUnit::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.elements = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IConfigurableItem: IConfigurationItem {
    fn item_concept_feature(&self) -> &HashSet<EntityRef>;
}
#[derive(Default, Debug)]
pub struct ConfigurableItem {
    id: Identifier,
    name: Label,
    description: Option<Text>,
    item_concept: EntityRef,
    purpose: Option<Label>,
    item_concept_feature: HashSet<EntityRef>,
}
impl IConfigurationItem for ConfigurableItem {
    fn id(&self) -> &Identifier {
        &self.id
    }
    fn name(&self) -> &Label {
        &self.name
    }
    fn description(&self) -> &Option<Text> {
        &self.description
    }
    fn item_concept(&self) -> &EntityRef {
        &self.item_concept
    }
    fn purpose(&self) -> &Option<Label> {
        &self.purpose
    }
}
impl IConfigurableItem for ConfigurableItem {
    fn item_concept_feature(&self) -> &HashSet<EntityRef> {
        &self.item_concept_feature
    }
}
impl ConfigurableItem {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = ConfigurableItem::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.id = parameter.into(),
                1usize => entity.name = parameter.into(),
                2usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => entity.item_concept = parameter.into(),
                4usize => {
                    entity.purpose = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                5usize => entity.item_concept_feature = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IConfigurationDesign {
    fn configuration(&self) -> &EntityRef;
    fn design(&self) -> &EntityRef;
}
#[derive(Default, Debug)]
pub struct ConfigurationDesign {
    configuration: EntityRef,
    design: EntityRef,
}
impl IConfigurationDesign for ConfigurationDesign {
    fn configuration(&self) -> &EntityRef {
        &self.configuration
    }
    fn design(&self) -> &EntityRef {
        &self.design
    }
}
impl ConfigurationDesign {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = ConfigurationDesign::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.configuration = parameter.into(),
                1usize => entity.design = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IConfigurationEffectivity: IProductDefinitionEffectivity {
    fn configuration(&self) -> &EntityRef;
}
#[derive(Default, Debug)]
pub struct ConfigurationEffectivity {
    id: Identifier,
    usage: EntityRef,
    configuration: EntityRef,
}
impl IEffectivity for ConfigurationEffectivity {
    fn id(&self) -> &Identifier {
        &self.id
    }
}
impl IProductDefinitionEffectivity for ConfigurationEffectivity {
    fn usage(&self) -> &EntityRef {
        &self.usage
    }
}
impl IConfigurationEffectivity for ConfigurationEffectivity {
    fn configuration(&self) -> &EntityRef {
        &self.configuration
    }
}
impl ConfigurationEffectivity {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = ConfigurationEffectivity::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.id = parameter.into(),
                1usize => entity.usage = parameter.into(),
                2usize => entity.configuration = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IConfigurationItem {
    fn id(&self) -> &Identifier;
    fn name(&self) -> &Label;
    fn description(&self) -> &Option<Text>;
    fn item_concept(&self) -> &EntityRef;
    fn purpose(&self) -> &Option<Label>;
}
#[derive(Default, Debug)]
pub struct ConfigurationItem {
    id: Identifier,
    name: Label,
    description: Option<Text>,
    item_concept: EntityRef,
    purpose: Option<Label>,
}
impl IConfigurationItem for ConfigurationItem {
    fn id(&self) -> &Identifier {
        &self.id
    }
    fn name(&self) -> &Label {
        &self.name
    }
    fn description(&self) -> &Option<Text> {
        &self.description
    }
    fn item_concept(&self) -> &EntityRef {
        &self.item_concept
    }
    fn purpose(&self) -> &Option<Label> {
        &self.purpose
    }
}
impl ConfigurationItem {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = ConfigurationItem::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.id = parameter.into(),
                1usize => entity.name = parameter.into(),
                2usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => entity.item_concept = parameter.into(),
                4usize => {
                    entity.purpose = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
}
pub trait IConfiguredEffectivityAssignment: IEffectivityAssignment {
    fn items(&self) -> &HashSet<EntityRef>;
}
#[derive(Default, Debug)]
pub struct ConfiguredEffectivityAssignment {
    assigned_effectivity: EntityRef,
    items: HashSet<EntityRef>,
}
impl IEffectivityAssignment for ConfiguredEffectivityAssignment {
    fn assigned_effectivity(&self) -> &EntityRef {
        &self.assigned_effectivity
    }
}
impl IConfiguredEffectivityAssignment for ConfiguredEffectivityAssignment {
    fn items(&self) -> &HashSet<EntityRef> {
        &self.items
    }
}
impl ConfiguredEffectivityAssignment {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = ConfiguredEffectivityAssignment::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.assigned_effectivity = parameter.into(),
                1usize => entity.items = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IConfiguredEffectivityContextAssignment: IEffectivityContextAssignment {
    fn items(&self) -> &HashSet<EntityRef>;
    fn assigned_effectivity_assignment(&self) -> &EntityRef;
}
#[derive(Default, Debug)]
pub struct ConfiguredEffectivityContextAssignment {
    role: EntityRef,
    items: HashSet<EntityRef>,
    assigned_effectivity_assignment: EntityRef,
}
impl IEffectivityContextAssignment for ConfiguredEffectivityContextAssignment {
    fn assigned_effectivity_assignment(&self) -> &EntityRef {
        &self.assigned_effectivity_assignment
    }
    fn role(&self) -> &EntityRef {
        &self.role
    }
}
impl IConfiguredEffectivityContextAssignment for ConfiguredEffectivityContextAssignment {
    fn items(&self) -> &HashSet<EntityRef> {
        &self.items
    }
    fn assigned_effectivity_assignment(&self) -> &EntityRef {
        &self.assigned_effectivity_assignment
    }
}
impl ConfiguredEffectivityContextAssignment {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = ConfiguredEffectivityContextAssignment::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.role = parameter.into(),
                1usize => entity.items = parameter.into(),
                2usize => entity.assigned_effectivity_assignment = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IConic: ICurve {
    fn position(&self) -> &EntityRef;
}
#[derive(Default, Debug)]
pub struct Conic {
    name: Label,
    position: EntityRef,
}
impl IRepresentationItem for Conic {
    fn name(&self) -> &Label {
        &self.name
    }
}
impl IGeometricRepresentationItem for Conic {}
impl ICurve for Conic {}
impl IConic for Conic {
    fn position(&self) -> &EntityRef {
        &self.position
    }
}
impl Conic {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = Conic::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => entity.position = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IConicalSteppedHoleTransition: IGeometricRepresentationItem {
    fn transition_number(&self) -> &PositiveInteger;
    fn cone_apex_angle(&self) -> &PlaneAngleMeasure;
    fn cone_base_radius(&self) -> &PositiveLengthMeasure;
}
#[derive(Default, Debug)]
pub struct ConicalSteppedHoleTransition {
    name: Label,
    transition_number: PositiveInteger,
    cone_apex_angle: PlaneAngleMeasure,
    cone_base_radius: PositiveLengthMeasure,
}
impl IRepresentationItem for ConicalSteppedHoleTransition {
    fn name(&self) -> &Label {
        &self.name
    }
}
impl IGeometricRepresentationItem for ConicalSteppedHoleTransition {}
impl IConicalSteppedHoleTransition for ConicalSteppedHoleTransition {
    fn transition_number(&self) -> &PositiveInteger {
        &self.transition_number
    }
    fn cone_apex_angle(&self) -> &PlaneAngleMeasure {
        &self.cone_apex_angle
    }
    fn cone_base_radius(&self) -> &PositiveLengthMeasure {
        &self.cone_base_radius
    }
}
impl ConicalSteppedHoleTransition {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = ConicalSteppedHoleTransition::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => entity.transition_number = parameter.into(),
                2usize => entity.cone_apex_angle = parameter.into(),
                3usize => entity.cone_base_radius = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IConicalSurface: IElementarySurface {
    fn radius(&self) -> &LengthMeasure;
    fn semi_angle(&self) -> &PlaneAngleMeasure;
}
#[derive(Default, Debug)]
pub struct ConicalSurface {
    name: Label,
    position: EntityRef,
    radius: LengthMeasure,
    semi_angle: PlaneAngleMeasure,
}
impl IRepresentationItem for ConicalSurface {
    fn name(&self) -> &Label {
        &self.name
    }
}
impl IGeometricRepresentationItem for ConicalSurface {}
impl ISurface for ConicalSurface {}
impl IElementarySurface for ConicalSurface {
    fn position(&self) -> &EntityRef {
        &self.position
    }
}
impl IConicalSurface for ConicalSurface {
    fn radius(&self) -> &LengthMeasure {
        &self.radius
    }
    fn semi_angle(&self) -> &PlaneAngleMeasure {
        &self.semi_angle
    }
}
impl ConicalSurface {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = ConicalSurface::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => entity.position = parameter.into(),
                2usize => entity.radius = parameter.into(),
                3usize => entity.semi_angle = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IConnectedEdgeSet: ITopologicalRepresentationItem {
    fn ces_edges(&self) -> &HashSet<EntityRef>;
}
#[derive(Default, Debug)]
pub struct ConnectedEdgeSet {
    name: Label,
    ces_edges: HashSet<EntityRef>,
}
impl IRepresentationItem for ConnectedEdgeSet {
    fn name(&self) -> &Label {
        &self.name
    }
}
impl ITopologicalRepresentationItem for ConnectedEdgeSet {}
impl IConnectedEdgeSet for ConnectedEdgeSet {
    fn ces_edges(&self) -> &HashSet<EntityRef> {
        &self.ces_edges
    }
}
impl ConnectedEdgeSet {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = ConnectedEdgeSet::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => entity.ces_edges = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IConnectedFaceSet: ITopologicalRepresentationItem {
    fn cfs_faces(&self) -> &HashSet<EntityRef>;
}
#[derive(Default, Debug)]
pub struct ConnectedFaceSet {
    name: Label,
    cfs_faces: HashSet<EntityRef>,
}
impl IRepresentationItem for ConnectedFaceSet {
    fn name(&self) -> &Label {
        &self.name
    }
}
impl ITopologicalRepresentationItem for ConnectedFaceSet {}
impl IConnectedFaceSet for ConnectedFaceSet {
    fn cfs_faces(&self) -> &HashSet<EntityRef> {
        &self.cfs_faces
    }
}
impl ConnectedFaceSet {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = ConnectedFaceSet::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => entity.cfs_faces = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IConnectedFaceSubSet: IConnectedFaceSet {
    fn parent_face_set(&self) -> &EntityRef;
}
#[derive(Default, Debug)]
pub struct ConnectedFaceSubSet {
    name: Label,
    cfs_faces: HashSet<EntityRef>,
    parent_face_set: EntityRef,
}
impl IRepresentationItem for ConnectedFaceSubSet {
    fn name(&self) -> &Label {
        &self.name
    }
}
impl ITopologicalRepresentationItem for ConnectedFaceSubSet {}
impl IConnectedFaceSet for ConnectedFaceSubSet {
    fn cfs_faces(&self) -> &HashSet<EntityRef> {
        &self.cfs_faces
    }
}
impl IConnectedFaceSubSet for ConnectedFaceSubSet {
    fn parent_face_set(&self) -> &EntityRef {
        &self.parent_face_set
    }
}
impl ConnectedFaceSubSet {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = ConnectedFaceSubSet::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => entity.cfs_faces = parameter.into(),
                2usize => entity.parent_face_set = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IConstructiveGeometryRepresentation: IRepresentation {}
#[derive(Default, Debug)]
pub struct ConstructiveGeometryRepresentation {
    name: Label,
    items: HashSet<EntityRef>,
    context_of_items: EntityRef,
}
impl IRepresentation for ConstructiveGeometryRepresentation {
    fn name(&self) -> &Label {
        &self.name
    }
    fn items(&self) -> &HashSet<EntityRef> {
        &self.items
    }
    fn context_of_items(&self) -> &EntityRef {
        &self.context_of_items
    }
}
impl IConstructiveGeometryRepresentation for ConstructiveGeometryRepresentation {}
impl ConstructiveGeometryRepresentation {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = ConstructiveGeometryRepresentation::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => entity.items = parameter.into(),
                2usize => entity.context_of_items = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IConstructiveGeometryRepresentationRelationship: IRepresentationRelationship {
    fn rep_1(&self) -> &EntityRef;
    fn rep_2(&self) -> &EntityRef;
}
#[derive(Default, Debug)]
pub struct ConstructiveGeometryRepresentationRelationship {
    name: Label,
    description: Option<Text>,
    rep_1: EntityRef,
    rep_2: EntityRef,
}
impl IRepresentationRelationship for ConstructiveGeometryRepresentationRelationship {
    fn name(&self) -> &Label {
        &self.name
    }
    fn description(&self) -> &Option<Text> {
        &self.description
    }
    fn rep_1(&self) -> &EntityRef {
        &self.rep_1
    }
    fn rep_2(&self) -> &EntityRef {
        &self.rep_2
    }
}
impl IConstructiveGeometryRepresentationRelationship for ConstructiveGeometryRepresentationRelationship {
    fn rep_1(&self) -> &EntityRef {
        &self.rep_1
    }
    fn rep_2(&self) -> &EntityRef {
        &self.rep_2
    }
}
impl ConstructiveGeometryRepresentationRelationship {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = ConstructiveGeometryRepresentationRelationship::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => entity.rep_1 = parameter.into(),
                3usize => entity.rep_2 = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IContactRatioRepresentation: IRepresentation {}
#[derive(Default, Debug)]
pub struct ContactRatioRepresentation {
    name: Label,
    items: HashSet<EntityRef>,
    context_of_items: EntityRef,
}
impl IRepresentation for ContactRatioRepresentation {
    fn name(&self) -> &Label {
        &self.name
    }
    fn items(&self) -> &HashSet<EntityRef> {
        &self.items
    }
    fn context_of_items(&self) -> &EntityRef {
        &self.context_of_items
    }
}
impl IContactRatioRepresentation for ContactRatioRepresentation {}
impl ContactRatioRepresentation {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = ContactRatioRepresentation::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => entity.items = parameter.into(),
                2usize => entity.context_of_items = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IContextDependentInvisibility: IInvisibility {
    fn presentation_context(&self) -> &EntityRef;
}
#[derive(Default, Debug)]
pub struct ContextDependentInvisibility {
    invisible_items: HashSet<EntityRef>,
    presentation_context: EntityRef,
}
impl IInvisibility for ContextDependentInvisibility {
    fn invisible_items(&self) -> &HashSet<EntityRef> {
        &self.invisible_items
    }
}
impl IContextDependentInvisibility for ContextDependentInvisibility {
    fn presentation_context(&self) -> &EntityRef {
        &self.presentation_context
    }
}
impl ContextDependentInvisibility {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = ContextDependentInvisibility::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.invisible_items = parameter.into(),
                1usize => entity.presentation_context = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IContextDependentOverRidingStyledItem: IOverRidingStyledItem {
    fn style_context(&self) -> &Vec<EntityRef>;
}
#[derive(Default, Debug)]
pub struct ContextDependentOverRidingStyledItem {
    name: Label,
    styles: HashSet<EntityRef>,
    item: EntityRef,
    over_ridden_style: EntityRef,
    style_context: Vec<EntityRef>,
}
impl IRepresentationItem for ContextDependentOverRidingStyledItem {
    fn name(&self) -> &Label {
        &self.name
    }
}
impl IStyledItem for ContextDependentOverRidingStyledItem {
    fn styles(&self) -> &HashSet<EntityRef> {
        &self.styles
    }
    fn item(&self) -> &EntityRef {
        &self.item
    }
}
impl IOverRidingStyledItem for ContextDependentOverRidingStyledItem {
    fn over_ridden_style(&self) -> &EntityRef {
        &self.over_ridden_style
    }
}
impl IContextDependentOverRidingStyledItem for ContextDependentOverRidingStyledItem {
    fn style_context(&self) -> &Vec<EntityRef> {
        &self.style_context
    }
}
impl ContextDependentOverRidingStyledItem {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = ContextDependentOverRidingStyledItem::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => entity.styles = parameter.into(),
                2usize => entity.item = parameter.into(),
                3usize => entity.over_ridden_style = parameter.into(),
                4usize => entity.style_context = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IContextDependentShapeRepresentation {
    fn representation_relation(&self) -> &EntityRef;
    fn represented_product_relation(&self) -> &EntityRef;
}
#[derive(Default, Debug)]
pub struct ContextDependentShapeRepresentation {
    representation_relation: EntityRef,
    represented_product_relation: EntityRef,
}
impl IContextDependentShapeRepresentation for ContextDependentShapeRepresentation {
    fn representation_relation(&self) -> &EntityRef {
        &self.representation_relation
    }
    fn represented_product_relation(&self) -> &EntityRef {
        &self.represented_product_relation
    }
}
impl ContextDependentShapeRepresentation {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = ContextDependentShapeRepresentation::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.representation_relation = parameter.into(),
                1usize => entity.represented_product_relation = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IContextDependentUnit: INamedUnit {
    fn name(&self) -> &Label;
}
#[derive(Default, Debug)]
pub struct ContextDependentUnit {
    dimensions: EntityRef,
    name: Label,
}
impl INamedUnit for ContextDependentUnit {
    fn dimensions(&self) -> &EntityRef {
        &self.dimensions
    }
}
impl IContextDependentUnit for ContextDependentUnit {
    fn name(&self) -> &Label {
        &self.name
    }
}
impl ContextDependentUnit {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = ContextDependentUnit::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.dimensions = parameter.into(),
                1usize => entity.name = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IContract {
    fn name(&self) -> &Label;
    fn purpose(&self) -> &Text;
    fn kind(&self) -> &EntityRef;
}
#[derive(Default, Debug)]
pub struct Contract {
    name: Label,
    purpose: Text,
    kind: EntityRef,
}
impl IContract for Contract {
    fn name(&self) -> &Label {
        &self.name
    }
    fn purpose(&self) -> &Text {
        &self.purpose
    }
    fn kind(&self) -> &EntityRef {
        &self.kind
    }
}
impl Contract {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = Contract::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => entity.purpose = parameter.into(),
                2usize => entity.kind = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IContractAssignment {
    fn assigned_contract(&self) -> &EntityRef;
}
pub trait IContractType {
    fn description(&self) -> &Label;
}
#[derive(Default, Debug)]
pub struct ContractType {
    description: Label,
}
impl IContractType for ContractType {
    fn description(&self) -> &Label {
        &self.description
    }
}
impl ContractType {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = ContractType::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.description = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IConversionBasedUnit: INamedUnit {
    fn name(&self) -> &Label;
    fn conversion_factor(&self) -> &EntityRef;
}
#[derive(Default, Debug)]
pub struct ConversionBasedUnit {
    dimensions: EntityRef,
    name: Label,
    conversion_factor: EntityRef,
}
impl INamedUnit for ConversionBasedUnit {
    fn dimensions(&self) -> &EntityRef {
        &self.dimensions
    }
}
impl IConversionBasedUnit for ConversionBasedUnit {
    fn name(&self) -> &Label {
        &self.name
    }
    fn conversion_factor(&self) -> &EntityRef {
        &self.conversion_factor
    }
}
impl ConversionBasedUnit {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = ConversionBasedUnit::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.dimensions = parameter.into(),
                1usize => entity.name = parameter.into(),
                2usize => entity.conversion_factor = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait ICoordinatedUniversalTimeOffset {
    fn hour_offset(&self) -> i64;
    fn minute_offset(&self) -> Option<i64>;
    fn sense(&self) -> &AheadOrBehind;
}
#[derive(Default, Debug)]
pub struct CoordinatedUniversalTimeOffset {
    hour_offset: i64,
    minute_offset: Option<i64>,
    sense: AheadOrBehind,
}
impl ICoordinatedUniversalTimeOffset for CoordinatedUniversalTimeOffset {
    fn hour_offset(&self) -> i64 {
        self.hour_offset
    }
    fn minute_offset(&self) -> Option<i64> {
        self.minute_offset
    }
    fn sense(&self) -> &AheadOrBehind {
        &self.sense
    }
}
impl CoordinatedUniversalTimeOffset {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = CoordinatedUniversalTimeOffset::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.hour_offset = parameter.into(),
                1usize => {
                    entity.minute_offset = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => entity.sense = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait ICsgShapeRepresentation: IShapeRepresentation {}
#[derive(Default, Debug)]
pub struct CsgShapeRepresentation {
    name: Label,
    items: HashSet<EntityRef>,
    context_of_items: EntityRef,
}
impl IRepresentation for CsgShapeRepresentation {
    fn name(&self) -> &Label {
        &self.name
    }
    fn items(&self) -> &HashSet<EntityRef> {
        &self.items
    }
    fn context_of_items(&self) -> &EntityRef {
        &self.context_of_items
    }
}
impl IShapeRepresentation for CsgShapeRepresentation {}
impl ICsgShapeRepresentation for CsgShapeRepresentation {}
impl CsgShapeRepresentation {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = CsgShapeRepresentation::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => entity.items = parameter.into(),
                2usize => entity.context_of_items = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait ICsgSolid: ISolidModel {
    fn tree_root_expression(&self) -> &EntityRef;
}
#[derive(Default, Debug)]
pub struct CsgSolid {
    name: Label,
    tree_root_expression: EntityRef,
}
impl IRepresentationItem for CsgSolid {
    fn name(&self) -> &Label {
        &self.name
    }
}
impl IGeometricRepresentationItem for CsgSolid {}
impl ISolidModel for CsgSolid {}
impl ICsgSolid for CsgSolid {
    fn tree_root_expression(&self) -> &EntityRef {
        &self.tree_root_expression
    }
}
impl CsgSolid {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = CsgSolid::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => entity.tree_root_expression = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait ICurrency: IContextDependentUnit {}
pub trait ICurrencyMeasureWithUnit: IMeasureWithUnit {
    fn unit_component(&self) -> &EntityRef;
}
#[derive(Default, Debug)]
pub struct CurrencyMeasureWithUnit {
    value_component: MeasureValue,
    unit_component: EntityRef,
}
impl IMeasureWithUnit for CurrencyMeasureWithUnit {
    fn value_component(&self) -> &MeasureValue {
        &self.value_component
    }
    fn unit_component(&self) -> &EntityRef {
        &self.unit_component
    }
}
impl ICurrencyMeasureWithUnit for CurrencyMeasureWithUnit {
    fn unit_component(&self) -> &EntityRef {
        &self.unit_component
    }
}
impl CurrencyMeasureWithUnit {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = CurrencyMeasureWithUnit::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.value_component = parameter.into(),
                1usize => entity.unit_component = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait ICurve: IGeometricRepresentationItem {}
#[derive(Default, Debug)]
pub struct Curve {
    name: Label,
}
impl IRepresentationItem for Curve {
    fn name(&self) -> &Label {
        &self.name
    }
}
impl IGeometricRepresentationItem for Curve {}
impl ICurve for Curve {}
impl Curve {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = Curve::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait ICurveBoundedSurface: IBoundedSurface {
    fn basis_surface(&self) -> &EntityRef;
    fn boundaries(&self) -> &HashSet<EntityRef>;
    fn implicit_outer(&self) -> bool;
}
#[derive(Default, Debug)]
pub struct CurveBoundedSurface {
    name: Label,
    basis_surface: EntityRef,
    boundaries: HashSet<EntityRef>,
    implicit_outer: bool,
}
impl IRepresentationItem for CurveBoundedSurface {
    fn name(&self) -> &Label {
        &self.name
    }
}
impl IGeometricRepresentationItem for CurveBoundedSurface {}
impl ISurface for CurveBoundedSurface {}
impl IBoundedSurface for CurveBoundedSurface {}
impl ICurveBoundedSurface for CurveBoundedSurface {
    fn basis_surface(&self) -> &EntityRef {
        &self.basis_surface
    }
    fn boundaries(&self) -> &HashSet<EntityRef> {
        &self.boundaries
    }
    fn implicit_outer(&self) -> bool {
        self.implicit_outer
    }
}
impl CurveBoundedSurface {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = CurveBoundedSurface::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => entity.basis_surface = parameter.into(),
                2usize => entity.boundaries = parameter.into(),
                3usize => entity.implicit_outer = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait ICurveDimension: IDimensionCurveDirectedCallout {}
#[derive(Default, Debug)]
pub struct CurveDimension {
    name: Label,
    contents: HashSet<EntityRef>,
}
impl IRepresentationItem for CurveDimension {
    fn name(&self) -> &Label {
        &self.name
    }
}
impl IGeometricRepresentationItem for CurveDimension {}
impl IDraughtingCallout for CurveDimension {
    fn contents(&self) -> &HashSet<EntityRef> {
        &self.contents
    }
}
impl IDimensionCurveDirectedCallout for CurveDimension {}
impl ICurveDimension for CurveDimension {}
impl CurveDimension {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = CurveDimension::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => entity.contents = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait ICurveReplica: ICurve {
    fn parent_curve(&self) -> &EntityRef;
    fn transformation(&self) -> &EntityRef;
}
#[derive(Default, Debug)]
pub struct CurveReplica {
    name: Label,
    parent_curve: EntityRef,
    transformation: EntityRef,
}
impl IRepresentationItem for CurveReplica {
    fn name(&self) -> &Label {
        &self.name
    }
}
impl IGeometricRepresentationItem for CurveReplica {}
impl ICurve for CurveReplica {}
impl ICurveReplica for CurveReplica {
    fn parent_curve(&self) -> &EntityRef {
        &self.parent_curve
    }
    fn transformation(&self) -> &EntityRef {
        &self.transformation
    }
}
impl CurveReplica {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = CurveReplica::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => entity.parent_curve = parameter.into(),
                2usize => entity.transformation = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait ICurveStyle: IFoundedItem {
    fn name(&self) -> &Label;
    fn curve_font(&self) -> &EntityRef;
    fn curve_width(&self) -> &SizeSelect;
    fn curve_colour(&self) -> &EntityRef;
}
#[derive(Default, Debug)]
pub struct CurveStyle {
    name: Label,
    curve_font: EntityRef,
    curve_width: SizeSelect,
    curve_colour: EntityRef,
}
impl IFoundedItem for CurveStyle {}
impl ICurveStyle for CurveStyle {
    fn name(&self) -> &Label {
        &self.name
    }
    fn curve_font(&self) -> &EntityRef {
        &self.curve_font
    }
    fn curve_width(&self) -> &SizeSelect {
        &self.curve_width
    }
    fn curve_colour(&self) -> &EntityRef {
        &self.curve_colour
    }
}
impl CurveStyle {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = CurveStyle::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => entity.curve_font = parameter.into(),
                2usize => entity.curve_width = parameter.into(),
                3usize => entity.curve_colour = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait ICurveStyleFont: IFoundedItem {
    fn name(&self) -> &Label;
    fn pattern_list(&self) -> &Vec<EntityRef>;
}
#[derive(Default, Debug)]
pub struct CurveStyleFont {
    name: Label,
    pattern_list: Vec<EntityRef>,
}
impl IFoundedItem for CurveStyleFont {}
impl ICurveStyleFont for CurveStyleFont {
    fn name(&self) -> &Label {
        &self.name
    }
    fn pattern_list(&self) -> &Vec<EntityRef> {
        &self.pattern_list
    }
}
impl CurveStyleFont {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = CurveStyleFont::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => entity.pattern_list = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait ICurveStyleFontAndScaling: IFoundedItem {
    fn name(&self) -> &Label;
    fn curve_font(&self) -> &EntityRef;
    fn curve_font_scaling(&self) -> Real;
}
#[derive(Default, Debug)]
pub struct CurveStyleFontAndScaling {
    name: Label,
    curve_font: EntityRef,
    curve_font_scaling: Real,
}
impl IFoundedItem for CurveStyleFontAndScaling {}
impl ICurveStyleFontAndScaling for CurveStyleFontAndScaling {
    fn name(&self) -> &Label {
        &self.name
    }
    fn curve_font(&self) -> &EntityRef {
        &self.curve_font
    }
    fn curve_font_scaling(&self) -> Real {
        self.curve_font_scaling
    }
}
impl CurveStyleFontAndScaling {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = CurveStyleFontAndScaling::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => entity.curve_font = parameter.into(),
                2usize => entity.curve_font_scaling = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait ICurveStyleFontPattern: IFoundedItem {
    fn visible_segment_length(&self) -> &PositiveLengthMeasure;
    fn invisible_segment_length(&self) -> &PositiveLengthMeasure;
}
#[derive(Default, Debug)]
pub struct CurveStyleFontPattern {
    visible_segment_length: PositiveLengthMeasure,
    invisible_segment_length: PositiveLengthMeasure,
}
impl IFoundedItem for CurveStyleFontPattern {}
impl ICurveStyleFontPattern for CurveStyleFontPattern {
    fn visible_segment_length(&self) -> &PositiveLengthMeasure {
        &self.visible_segment_length
    }
    fn invisible_segment_length(&self) -> &PositiveLengthMeasure {
        &self.invisible_segment_length
    }
}
impl CurveStyleFontPattern {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = CurveStyleFontPattern::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.visible_segment_length = parameter.into(),
                1usize => entity.invisible_segment_length = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait ICurveStyleRendering {
    fn rendering_method(&self) -> &ShadingCurveMethod;
    fn rendering_properties(&self) -> &EntityRef;
}
#[derive(Default, Debug)]
pub struct CurveStyleRendering {
    rendering_method: ShadingCurveMethod,
    rendering_properties: EntityRef,
}
impl ICurveStyleRendering for CurveStyleRendering {
    fn rendering_method(&self) -> &ShadingCurveMethod {
        &self.rendering_method
    }
    fn rendering_properties(&self) -> &EntityRef {
        &self.rendering_properties
    }
}
impl CurveStyleRendering {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = CurveStyleRendering::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.rendering_method = parameter.into(),
                1usize => entity.rendering_properties = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait ICurveSweptSolidShapeRepresentation: IShapeRepresentation {}
#[derive(Default, Debug)]
pub struct CurveSweptSolidShapeRepresentation {
    name: Label,
    items: HashSet<EntityRef>,
    context_of_items: EntityRef,
}
impl IRepresentation for CurveSweptSolidShapeRepresentation {
    fn name(&self) -> &Label {
        &self.name
    }
    fn items(&self) -> &HashSet<EntityRef> {
        &self.items
    }
    fn context_of_items(&self) -> &EntityRef {
        &self.context_of_items
    }
}
impl IShapeRepresentation for CurveSweptSolidShapeRepresentation {}
impl ICurveSweptSolidShapeRepresentation for CurveSweptSolidShapeRepresentation {}
impl CurveSweptSolidShapeRepresentation {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = CurveSweptSolidShapeRepresentation::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => entity.items = parameter.into(),
                2usize => entity.context_of_items = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait ICylindricalSurface: IElementarySurface {
    fn radius(&self) -> &PositiveLengthMeasure;
}
#[derive(Default, Debug)]
pub struct CylindricalSurface {
    name: Label,
    position: EntityRef,
    radius: PositiveLengthMeasure,
}
impl IRepresentationItem for CylindricalSurface {
    fn name(&self) -> &Label {
        &self.name
    }
}
impl IGeometricRepresentationItem for CylindricalSurface {}
impl ISurface for CylindricalSurface {}
impl IElementarySurface for CylindricalSurface {
    fn position(&self) -> &EntityRef {
        &self.position
    }
}
impl ICylindricalSurface for CylindricalSurface {
    fn radius(&self) -> &PositiveLengthMeasure {
        &self.radius
    }
}
impl CylindricalSurface {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = CylindricalSurface::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => entity.position = parameter.into(),
                2usize => entity.radius = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait ICylindricityTolerance: IGeometricTolerance {}
#[derive(Default, Debug)]
pub struct CylindricityTolerance {
    name: Label,
    description: Text,
    magnitude: EntityRef,
    toleranced_shape_aspect: EntityRef,
}
impl IGeometricTolerance for CylindricityTolerance {
    fn name(&self) -> &Label {
        &self.name
    }
    fn description(&self) -> &Text {
        &self.description
    }
    fn magnitude(&self) -> &EntityRef {
        &self.magnitude
    }
    fn toleranced_shape_aspect(&self) -> &EntityRef {
        &self.toleranced_shape_aspect
    }
}
impl ICylindricityTolerance for CylindricityTolerance {}
impl CylindricityTolerance {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = CylindricityTolerance::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => entity.description = parameter.into(),
                2usize => entity.magnitude = parameter.into(),
                3usize => entity.toleranced_shape_aspect = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IDataEnvironment {
    fn name(&self) -> &Label;
    fn description(&self) -> &Text;
    fn elements(&self) -> &HashSet<EntityRef>;
}
#[derive(Default, Debug)]
pub struct DataEnvironment {
    name: Label,
    description: Text,
    elements: HashSet<EntityRef>,
}
impl IDataEnvironment for DataEnvironment {
    fn name(&self) -> &Label {
        &self.name
    }
    fn description(&self) -> &Text {
        &self.description
    }
    fn elements(&self) -> &HashSet<EntityRef> {
        &self.elements
    }
}
impl DataEnvironment {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = DataEnvironment::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => entity.description = parameter.into(),
                2usize => entity.elements = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IDate {
    fn year_component(&self) -> &YearNumber;
}
#[derive(Default, Debug)]
pub struct Date {
    year_component: YearNumber,
}
impl IDate for Date {
    fn year_component(&self) -> &YearNumber {
        &self.year_component
    }
}
impl Date {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = Date::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.year_component = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IDateAndTime {
    fn date_component(&self) -> &EntityRef;
    fn time_component(&self) -> &EntityRef;
}
#[derive(Default, Debug)]
pub struct DateAndTime {
    date_component: EntityRef,
    time_component: EntityRef,
}
impl IDateAndTime for DateAndTime {
    fn date_component(&self) -> &EntityRef {
        &self.date_component
    }
    fn time_component(&self) -> &EntityRef {
        &self.time_component
    }
}
impl DateAndTime {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = DateAndTime::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.date_component = parameter.into(),
                1usize => entity.time_component = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IDateAndTimeAssignment {
    fn assigned_date_and_time(&self) -> &EntityRef;
    fn role(&self) -> &EntityRef;
}
pub trait IDateAssignment {
    fn assigned_date(&self) -> &EntityRef;
    fn role(&self) -> &EntityRef;
}
pub trait IDateRepresentationItem: IRepresentationItem + IDate {}
#[derive(Default, Debug)]
pub struct DateRepresentationItem {
    name: Label,
    year_component: YearNumber,
}
impl IRepresentationItem for DateRepresentationItem {
    fn name(&self) -> &Label {
        &self.name
    }
}
impl IDate for DateRepresentationItem {
    fn year_component(&self) -> &YearNumber {
        &self.year_component
    }
}
impl IDateRepresentationItem for DateRepresentationItem {}
impl DateRepresentationItem {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = DateRepresentationItem::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => entity.year_component = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IDateRole {
    fn name(&self) -> &Label;
}
#[derive(Default, Debug)]
pub struct DateRole {
    name: Label,
}
impl IDateRole for DateRole {
    fn name(&self) -> &Label {
        &self.name
    }
}
impl DateRole {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = DateRole::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IDateTimeRepresentationItem: IRepresentationItem + IDateAndTime {}
#[derive(Default, Debug)]
pub struct DateTimeRepresentationItem {
    name: Label,
    date_component: EntityRef,
    time_component: EntityRef,
}
impl IRepresentationItem for DateTimeRepresentationItem {
    fn name(&self) -> &Label {
        &self.name
    }
}
impl IDateAndTime for DateTimeRepresentationItem {
    fn date_component(&self) -> &EntityRef {
        &self.date_component
    }
    fn time_component(&self) -> &EntityRef {
        &self.time_component
    }
}
impl IDateTimeRepresentationItem for DateTimeRepresentationItem {}
impl DateTimeRepresentationItem {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = DateTimeRepresentationItem::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => entity.date_component = parameter.into(),
                2usize => entity.time_component = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IDateTimeRole {
    fn name(&self) -> &Label;
}
#[derive(Default, Debug)]
pub struct DateTimeRole {
    name: Label,
}
impl IDateTimeRole for DateTimeRole {
    fn name(&self) -> &Label {
        &self.name
    }
}
impl DateTimeRole {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = DateTimeRole::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IDatedEffectivity: IEffectivity {
    fn effectivity_end_date(&self) -> &Option<EntityRef>;
    fn effectivity_start_date(&self) -> &EntityRef;
}
#[derive(Default, Debug)]
pub struct DatedEffectivity {
    id: Identifier,
    effectivity_end_date: Option<EntityRef>,
    effectivity_start_date: EntityRef,
}
impl IEffectivity for DatedEffectivity {
    fn id(&self) -> &Identifier {
        &self.id
    }
}
impl IDatedEffectivity for DatedEffectivity {
    fn effectivity_end_date(&self) -> &Option<EntityRef> {
        &self.effectivity_end_date
    }
    fn effectivity_start_date(&self) -> &EntityRef {
        &self.effectivity_start_date
    }
}
impl DatedEffectivity {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = DatedEffectivity::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.id = parameter.into(),
                1usize => {
                    entity.effectivity_end_date = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => entity.effectivity_start_date = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IDatum: IShapeAspect {
    fn identification(&self) -> &Identifier;
}
#[derive(Default, Debug)]
pub struct Datum {
    name: Label,
    description: Option<Text>,
    of_shape: EntityRef,
    product_definitional: Option<bool>,
    identification: Identifier,
}
impl IShapeAspect for Datum {
    fn name(&self) -> &Label {
        &self.name
    }
    fn description(&self) -> &Option<Text> {
        &self.description
    }
    fn of_shape(&self) -> &EntityRef {
        &self.of_shape
    }
    fn product_definitional(&self) -> Option<bool> {
        self.product_definitional
    }
}
impl IDatum for Datum {
    fn identification(&self) -> &Identifier {
        &self.identification
    }
}
impl Datum {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = Datum::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => entity.of_shape = parameter.into(),
                3usize => entity.product_definitional = parameter.into(),
                4usize => entity.identification = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IDatumFeature: IShapeAspect {}
#[derive(Default, Debug)]
pub struct DatumFeature {
    name: Label,
    description: Option<Text>,
    of_shape: EntityRef,
    product_definitional: Option<bool>,
}
impl IShapeAspect for DatumFeature {
    fn name(&self) -> &Label {
        &self.name
    }
    fn description(&self) -> &Option<Text> {
        &self.description
    }
    fn of_shape(&self) -> &EntityRef {
        &self.of_shape
    }
    fn product_definitional(&self) -> Option<bool> {
        self.product_definitional
    }
}
impl IDatumFeature for DatumFeature {}
impl DatumFeature {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = DatumFeature::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => entity.of_shape = parameter.into(),
                3usize => entity.product_definitional = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IDatumFeatureCallout: IDraughtingCallout {}
#[derive(Default, Debug)]
pub struct DatumFeatureCallout {
    name: Label,
    contents: HashSet<EntityRef>,
}
impl IRepresentationItem for DatumFeatureCallout {
    fn name(&self) -> &Label {
        &self.name
    }
}
impl IGeometricRepresentationItem for DatumFeatureCallout {}
impl IDraughtingCallout for DatumFeatureCallout {
    fn contents(&self) -> &HashSet<EntityRef> {
        &self.contents
    }
}
impl IDatumFeatureCallout for DatumFeatureCallout {}
impl DatumFeatureCallout {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = DatumFeatureCallout::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => entity.contents = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IDatumReference {
    fn precedence(&self) -> i64;
    fn referenced_datum(&self) -> &EntityRef;
}
#[derive(Default, Debug)]
pub struct DatumReference {
    precedence: i64,
    referenced_datum: EntityRef,
}
impl IDatumReference for DatumReference {
    fn precedence(&self) -> i64 {
        self.precedence
    }
    fn referenced_datum(&self) -> &EntityRef {
        &self.referenced_datum
    }
}
impl DatumReference {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = DatumReference::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.precedence = parameter.into(),
                1usize => entity.referenced_datum = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IDatumTarget: IShapeAspect {
    fn target_id(&self) -> &Identifier;
}
#[derive(Default, Debug)]
pub struct DatumTarget {
    name: Label,
    description: Option<Text>,
    of_shape: EntityRef,
    product_definitional: Option<bool>,
    target_id: Identifier,
}
impl IShapeAspect for DatumTarget {
    fn name(&self) -> &Label {
        &self.name
    }
    fn description(&self) -> &Option<Text> {
        &self.description
    }
    fn of_shape(&self) -> &EntityRef {
        &self.of_shape
    }
    fn product_definitional(&self) -> Option<bool> {
        self.product_definitional
    }
}
impl IDatumTarget for DatumTarget {
    fn target_id(&self) -> &Identifier {
        &self.target_id
    }
}
impl DatumTarget {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = DatumTarget::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => entity.of_shape = parameter.into(),
                3usize => entity.product_definitional = parameter.into(),
                4usize => entity.target_id = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IDatumTargetCallout: IDraughtingCallout {}
#[derive(Default, Debug)]
pub struct DatumTargetCallout {
    name: Label,
    contents: HashSet<EntityRef>,
}
impl IRepresentationItem for DatumTargetCallout {
    fn name(&self) -> &Label {
        &self.name
    }
}
impl IGeometricRepresentationItem for DatumTargetCallout {}
impl IDraughtingCallout for DatumTargetCallout {
    fn contents(&self) -> &HashSet<EntityRef> {
        &self.contents
    }
}
impl IDatumTargetCallout for DatumTargetCallout {}
impl DatumTargetCallout {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = DatumTargetCallout::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => entity.contents = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IDefaultToleranceTable: IRepresentation {}
#[derive(Default, Debug)]
pub struct DefaultToleranceTable {
    name: Label,
    items: HashSet<EntityRef>,
    context_of_items: EntityRef,
}
impl IRepresentation for DefaultToleranceTable {
    fn name(&self) -> &Label {
        &self.name
    }
    fn items(&self) -> &HashSet<EntityRef> {
        &self.items
    }
    fn context_of_items(&self) -> &EntityRef {
        &self.context_of_items
    }
}
impl IDefaultToleranceTable for DefaultToleranceTable {}
impl DefaultToleranceTable {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = DefaultToleranceTable::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => entity.items = parameter.into(),
                2usize => entity.context_of_items = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IDefaultToleranceTableCell: ICompoundRepresentationItem {}
#[derive(Default, Debug)]
pub struct DefaultToleranceTableCell {
    name: Label,
    item_element: CompoundItemDefinition,
}
impl IRepresentationItem for DefaultToleranceTableCell {
    fn name(&self) -> &Label {
        &self.name
    }
}
impl ICompoundRepresentationItem for DefaultToleranceTableCell {
    fn item_element(&self) -> &CompoundItemDefinition {
        &self.item_element
    }
}
impl IDefaultToleranceTableCell for DefaultToleranceTableCell {}
impl DefaultToleranceTableCell {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = DefaultToleranceTableCell::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => entity.item_element = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IDefinedSymbol: IGeometricRepresentationItem {
    fn definition(&self) -> &EntityRef;
    fn target(&self) -> &EntityRef;
}
#[derive(Default, Debug)]
pub struct DefinedSymbol {
    name: Label,
    definition: EntityRef,
    target: EntityRef,
}
impl IRepresentationItem for DefinedSymbol {
    fn name(&self) -> &Label {
        &self.name
    }
}
impl IGeometricRepresentationItem for DefinedSymbol {}
impl IDefinedSymbol for DefinedSymbol {
    fn definition(&self) -> &EntityRef {
        &self.definition
    }
    fn target(&self) -> &EntityRef {
        &self.target
    }
}
impl DefinedSymbol {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = DefinedSymbol::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => entity.definition = parameter.into(),
                2usize => entity.target = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IDefinitionalRepresentation: IRepresentation {}
#[derive(Default, Debug)]
pub struct DefinitionalRepresentation {
    name: Label,
    items: HashSet<EntityRef>,
    context_of_items: EntityRef,
}
impl IRepresentation for DefinitionalRepresentation {
    fn name(&self) -> &Label {
        &self.name
    }
    fn items(&self) -> &HashSet<EntityRef> {
        &self.items
    }
    fn context_of_items(&self) -> &EntityRef {
        &self.context_of_items
    }
}
impl IDefinitionalRepresentation for DefinitionalRepresentation {}
impl DefinitionalRepresentation {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = DefinitionalRepresentation::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => entity.items = parameter.into(),
                2usize => entity.context_of_items = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IDefinitionalRepresentationRelationship: IRepresentationRelationship {}
#[derive(Default, Debug)]
pub struct DefinitionalRepresentationRelationship {
    name: Label,
    description: Option<Text>,
    rep_1: EntityRef,
    rep_2: EntityRef,
}
impl IRepresentationRelationship for DefinitionalRepresentationRelationship {
    fn name(&self) -> &Label {
        &self.name
    }
    fn description(&self) -> &Option<Text> {
        &self.description
    }
    fn rep_1(&self) -> &EntityRef {
        &self.rep_1
    }
    fn rep_2(&self) -> &EntityRef {
        &self.rep_2
    }
}
impl IDefinitionalRepresentationRelationship for DefinitionalRepresentationRelationship {}
impl DefinitionalRepresentationRelationship {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = DefinitionalRepresentationRelationship::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => entity.rep_1 = parameter.into(),
                3usize => entity.rep_2 = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IDefinitionalRepresentationRelationshipWithSameContext: IDefinitionalRepresentationRelationship {}
#[derive(Default, Debug)]
pub struct DefinitionalRepresentationRelationshipWithSameContext {
    name: Label,
    description: Option<Text>,
    rep_1: EntityRef,
    rep_2: EntityRef,
}
impl IRepresentationRelationship for DefinitionalRepresentationRelationshipWithSameContext {
    fn name(&self) -> &Label {
        &self.name
    }
    fn description(&self) -> &Option<Text> {
        &self.description
    }
    fn rep_1(&self) -> &EntityRef {
        &self.rep_1
    }
    fn rep_2(&self) -> &EntityRef {
        &self.rep_2
    }
}
impl IDefinitionalRepresentationRelationship for DefinitionalRepresentationRelationshipWithSameContext {}
impl IDefinitionalRepresentationRelationshipWithSameContext for DefinitionalRepresentationRelationshipWithSameContext {}
impl DefinitionalRepresentationRelationshipWithSameContext {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = DefinitionalRepresentationRelationshipWithSameContext::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => entity.rep_1 = parameter.into(),
                3usize => entity.rep_2 = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IDegeneratePcurve: IPoint {
    fn basis_surface(&self) -> &EntityRef;
    fn reference_to_curve(&self) -> &EntityRef;
}
#[derive(Default, Debug)]
pub struct DegeneratePcurve {
    name: Label,
    basis_surface: EntityRef,
    reference_to_curve: EntityRef,
}
impl IRepresentationItem for DegeneratePcurve {
    fn name(&self) -> &Label {
        &self.name
    }
}
impl IGeometricRepresentationItem for DegeneratePcurve {}
impl IPoint for DegeneratePcurve {}
impl IDegeneratePcurve for DegeneratePcurve {
    fn basis_surface(&self) -> &EntityRef {
        &self.basis_surface
    }
    fn reference_to_curve(&self) -> &EntityRef {
        &self.reference_to_curve
    }
}
impl DegeneratePcurve {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = DegeneratePcurve::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => entity.basis_surface = parameter.into(),
                2usize => entity.reference_to_curve = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IDegenerateToroidalSurface: IToroidalSurface {
    fn select_outer(&self) -> bool;
}
#[derive(Default, Debug)]
pub struct DegenerateToroidalSurface {
    name: Label,
    position: EntityRef,
    major_radius: PositiveLengthMeasure,
    minor_radius: PositiveLengthMeasure,
    select_outer: bool,
}
impl IRepresentationItem for DegenerateToroidalSurface {
    fn name(&self) -> &Label {
        &self.name
    }
}
impl IGeometricRepresentationItem for DegenerateToroidalSurface {}
impl ISurface for DegenerateToroidalSurface {}
impl IElementarySurface for DegenerateToroidalSurface {
    fn position(&self) -> &EntityRef {
        &self.position
    }
}
impl IToroidalSurface for DegenerateToroidalSurface {
    fn major_radius(&self) -> &PositiveLengthMeasure {
        &self.major_radius
    }
    fn minor_radius(&self) -> &PositiveLengthMeasure {
        &self.minor_radius
    }
}
impl IDegenerateToroidalSurface for DegenerateToroidalSurface {
    fn select_outer(&self) -> bool {
        self.select_outer
    }
}
impl DegenerateToroidalSurface {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = DegenerateToroidalSurface::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => entity.position = parameter.into(),
                2usize => entity.major_radius = parameter.into(),
                3usize => entity.minor_radius = parameter.into(),
                4usize => entity.select_outer = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IDerivedShapeAspect: IShapeAspect {}
#[derive(Default, Debug)]
pub struct DerivedShapeAspect {
    name: Label,
    description: Option<Text>,
    of_shape: EntityRef,
    product_definitional: Option<bool>,
}
impl IShapeAspect for DerivedShapeAspect {
    fn name(&self) -> &Label {
        &self.name
    }
    fn description(&self) -> &Option<Text> {
        &self.description
    }
    fn of_shape(&self) -> &EntityRef {
        &self.of_shape
    }
    fn product_definitional(&self) -> Option<bool> {
        self.product_definitional
    }
}
impl IDerivedShapeAspect for DerivedShapeAspect {}
impl DerivedShapeAspect {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = DerivedShapeAspect::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => entity.of_shape = parameter.into(),
                3usize => entity.product_definitional = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IDerivedUnit {
    fn elements(&self) -> &HashSet<EntityRef>;
}
#[derive(Default, Debug)]
pub struct DerivedUnit {
    elements: HashSet<EntityRef>,
}
impl IDerivedUnit for DerivedUnit {
    fn elements(&self) -> &HashSet<EntityRef> {
        &self.elements
    }
}
impl DerivedUnit {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = DerivedUnit::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.elements = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IDerivedUnitElement {
    fn unit(&self) -> &EntityRef;
    fn exponent(&self) -> Real;
}
#[derive(Default, Debug)]
pub struct DerivedUnitElement {
    unit: EntityRef,
    exponent: Real,
}
impl IDerivedUnitElement for DerivedUnitElement {
    fn unit(&self) -> &EntityRef {
        &self.unit
    }
    fn exponent(&self) -> Real {
        self.exponent
    }
}
impl DerivedUnitElement {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = DerivedUnitElement::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.unit = parameter.into(),
                1usize => entity.exponent = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IDescriptionAttribute {
    fn attribute_value(&self) -> &Text;
    fn described_item(&self) -> &EntityRef;
}
#[derive(Default, Debug)]
pub struct DescriptionAttribute {
    attribute_value: Text,
    described_item: EntityRef,
}
impl IDescriptionAttribute for DescriptionAttribute {
    fn attribute_value(&self) -> &Text {
        &self.attribute_value
    }
    fn described_item(&self) -> &EntityRef {
        &self.described_item
    }
}
impl DescriptionAttribute {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = DescriptionAttribute::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.attribute_value = parameter.into(),
                1usize => entity.described_item = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IDescriptiveRepresentationItem: IRepresentationItem {
    fn description(&self) -> &Text;
}
#[derive(Default, Debug)]
pub struct DescriptiveRepresentationItem {
    name: Label,
    description: Text,
}
impl IRepresentationItem for DescriptiveRepresentationItem {
    fn name(&self) -> &Label {
        &self.name
    }
}
impl IDescriptiveRepresentationItem for DescriptiveRepresentationItem {
    fn description(&self) -> &Text {
        &self.description
    }
}
impl DescriptiveRepresentationItem {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = DescriptiveRepresentationItem::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => entity.description = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IDesignContext: IProductDefinitionContext {}
#[derive(Default, Debug)]
pub struct DesignContext {
    name: Label,
    frame_of_reference: EntityRef,
    life_cycle_stage: Label,
}
impl IApplicationContextElement for DesignContext {
    fn name(&self) -> &Label {
        &self.name
    }
    fn frame_of_reference(&self) -> &EntityRef {
        &self.frame_of_reference
    }
}
impl IProductDefinitionContext for DesignContext {
    fn life_cycle_stage(&self) -> &Label {
        &self.life_cycle_stage
    }
}
impl IDesignContext for DesignContext {}
impl DesignContext {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = DesignContext::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => entity.frame_of_reference = parameter.into(),
                2usize => entity.life_cycle_stage = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IDesignMakeFromRelationship: IProductDefinitionRelationship {}
#[derive(Default, Debug)]
pub struct DesignMakeFromRelationship {
    id: Identifier,
    name: Label,
    description: Option<Text>,
    relating_product_definition: EntityRef,
    related_product_definition: EntityRef,
}
impl IProductDefinitionRelationship for DesignMakeFromRelationship {
    fn id(&self) -> &Identifier {
        &self.id
    }
    fn name(&self) -> &Label {
        &self.name
    }
    fn description(&self) -> &Option<Text> {
        &self.description
    }
    fn relating_product_definition(&self) -> &EntityRef {
        &self.relating_product_definition
    }
    fn related_product_definition(&self) -> &EntityRef {
        &self.related_product_definition
    }
}
impl IDesignMakeFromRelationship for DesignMakeFromRelationship {}
impl DesignMakeFromRelationship {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = DesignMakeFromRelationship::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.id = parameter.into(),
                1usize => entity.name = parameter.into(),
                2usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => entity.relating_product_definition = parameter.into(),
                4usize => entity.related_product_definition = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IDiameterDimension: IDimensionCurveDirectedCallout {}
#[derive(Default, Debug)]
pub struct DiameterDimension {
    name: Label,
    contents: HashSet<EntityRef>,
}
impl IRepresentationItem for DiameterDimension {
    fn name(&self) -> &Label {
        &self.name
    }
}
impl IGeometricRepresentationItem for DiameterDimension {}
impl IDraughtingCallout for DiameterDimension {
    fn contents(&self) -> &HashSet<EntityRef> {
        &self.contents
    }
}
impl IDimensionCurveDirectedCallout for DiameterDimension {}
impl IDiameterDimension for DiameterDimension {}
impl DiameterDimension {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = DiameterDimension::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => entity.contents = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IDielectricConstantMeasureWithUnit: IRatioMeasureWithUnit {}
#[derive(Default, Debug)]
pub struct DielectricConstantMeasureWithUnit {
    value_component: MeasureValue,
    unit_component: EntityRef,
}
impl IMeasureWithUnit for DielectricConstantMeasureWithUnit {
    fn value_component(&self) -> &MeasureValue {
        &self.value_component
    }
    fn unit_component(&self) -> &EntityRef {
        &self.unit_component
    }
}
impl IRatioMeasureWithUnit for DielectricConstantMeasureWithUnit {}
impl IDielectricConstantMeasureWithUnit for DielectricConstantMeasureWithUnit {}
impl DielectricConstantMeasureWithUnit {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = DielectricConstantMeasureWithUnit::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.value_component = parameter.into(),
                1usize => entity.unit_component = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IDimensionCallout: IDraughtingCallout {}
#[derive(Default, Debug)]
pub struct DimensionCallout {
    name: Label,
    contents: HashSet<EntityRef>,
}
impl IRepresentationItem for DimensionCallout {
    fn name(&self) -> &Label {
        &self.name
    }
}
impl IGeometricRepresentationItem for DimensionCallout {}
impl IDraughtingCallout for DimensionCallout {
    fn contents(&self) -> &HashSet<EntityRef> {
        &self.contents
    }
}
impl IDimensionCallout for DimensionCallout {}
impl DimensionCallout {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = DimensionCallout::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => entity.contents = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IDimensionCalloutComponentRelationship: IDraughtingCalloutRelationship {}
#[derive(Default, Debug)]
pub struct DimensionCalloutComponentRelationship {
    name: Label,
    description: Text,
    relating_draughting_callout: EntityRef,
    related_draughting_callout: EntityRef,
}
impl IDraughtingCalloutRelationship for DimensionCalloutComponentRelationship {
    fn name(&self) -> &Label {
        &self.name
    }
    fn description(&self) -> &Text {
        &self.description
    }
    fn relating_draughting_callout(&self) -> &EntityRef {
        &self.relating_draughting_callout
    }
    fn related_draughting_callout(&self) -> &EntityRef {
        &self.related_draughting_callout
    }
}
impl IDimensionCalloutComponentRelationship for DimensionCalloutComponentRelationship {}
impl DimensionCalloutComponentRelationship {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = DimensionCalloutComponentRelationship::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => entity.description = parameter.into(),
                2usize => entity.relating_draughting_callout = parameter.into(),
                3usize => entity.related_draughting_callout = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IDimensionCalloutRelationship: IDraughtingCalloutRelationship {}
#[derive(Default, Debug)]
pub struct DimensionCalloutRelationship {
    name: Label,
    description: Text,
    relating_draughting_callout: EntityRef,
    related_draughting_callout: EntityRef,
}
impl IDraughtingCalloutRelationship for DimensionCalloutRelationship {
    fn name(&self) -> &Label {
        &self.name
    }
    fn description(&self) -> &Text {
        &self.description
    }
    fn relating_draughting_callout(&self) -> &EntityRef {
        &self.relating_draughting_callout
    }
    fn related_draughting_callout(&self) -> &EntityRef {
        &self.related_draughting_callout
    }
}
impl IDimensionCalloutRelationship for DimensionCalloutRelationship {}
impl DimensionCalloutRelationship {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = DimensionCalloutRelationship::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => entity.description = parameter.into(),
                2usize => entity.relating_draughting_callout = parameter.into(),
                3usize => entity.related_draughting_callout = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IDimensionCurve: IAnnotationCurveOccurrence {}
#[derive(Default, Debug)]
pub struct DimensionCurve {
    name: Label,
    styles: HashSet<EntityRef>,
    item: EntityRef,
}
impl IRepresentationItem for DimensionCurve {
    fn name(&self) -> &Label {
        &self.name
    }
}
impl IStyledItem for DimensionCurve {
    fn styles(&self) -> &HashSet<EntityRef> {
        &self.styles
    }
    fn item(&self) -> &EntityRef {
        &self.item
    }
}
impl IAnnotationOccurrence for DimensionCurve {}
impl IAnnotationCurveOccurrence for DimensionCurve {
    fn item(&self) -> &EntityRef {
        &self.item
    }
}
impl IDimensionCurve for DimensionCurve {}
impl DimensionCurve {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = DimensionCurve::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => entity.styles = parameter.into(),
                2usize => entity.item = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IDimensionCurveDirectedCallout: IDraughtingCallout {}
#[derive(Default, Debug)]
pub struct DimensionCurveDirectedCallout {
    name: Label,
    contents: HashSet<EntityRef>,
}
impl IRepresentationItem for DimensionCurveDirectedCallout {
    fn name(&self) -> &Label {
        &self.name
    }
}
impl IGeometricRepresentationItem for DimensionCurveDirectedCallout {}
impl IDraughtingCallout for DimensionCurveDirectedCallout {
    fn contents(&self) -> &HashSet<EntityRef> {
        &self.contents
    }
}
impl IDimensionCurveDirectedCallout for DimensionCurveDirectedCallout {}
impl DimensionCurveDirectedCallout {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = DimensionCurveDirectedCallout::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => entity.contents = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IDimensionCurveTerminator: ITerminatorSymbol {
    fn role(&self) -> &DimensionExtentUsage;
}
#[derive(Default, Debug)]
pub struct DimensionCurveTerminator {
    name: Label,
    styles: HashSet<EntityRef>,
    item: EntityRef,
    annotated_curve: EntityRef,
    role: DimensionExtentUsage,
}
impl IRepresentationItem for DimensionCurveTerminator {
    fn name(&self) -> &Label {
        &self.name
    }
}
impl IStyledItem for DimensionCurveTerminator {
    fn styles(&self) -> &HashSet<EntityRef> {
        &self.styles
    }
    fn item(&self) -> &EntityRef {
        &self.item
    }
}
impl IAnnotationOccurrence for DimensionCurveTerminator {}
impl IAnnotationSymbolOccurrence for DimensionCurveTerminator {
    fn item(&self) -> &EntityRef {
        &self.item
    }
}
impl ITerminatorSymbol for DimensionCurveTerminator {
    fn annotated_curve(&self) -> &EntityRef {
        &self.annotated_curve
    }
}
impl IDimensionCurveTerminator for DimensionCurveTerminator {
    fn role(&self) -> &DimensionExtentUsage {
        &self.role
    }
}
impl DimensionCurveTerminator {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = DimensionCurveTerminator::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => entity.styles = parameter.into(),
                2usize => entity.item = parameter.into(),
                3usize => entity.annotated_curve = parameter.into(),
                4usize => entity.role = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IDimensionCurveTerminatorToProjectionCurveAssociativity: IAnnotationOccurrenceAssociativity {
    fn related_annotation_occurrence(&self) -> &EntityRef;
    fn relating_annotation_occurrence(&self) -> &EntityRef;
}
#[derive(Default, Debug)]
pub struct DimensionCurveTerminatorToProjectionCurveAssociativity {
    name: Label,
    description: Text,
    related_annotation_occurrence: EntityRef,
    relating_annotation_occurrence: EntityRef,
}
impl IAnnotationOccurrenceRelationship for DimensionCurveTerminatorToProjectionCurveAssociativity {
    fn name(&self) -> &Label {
        &self.name
    }
    fn description(&self) -> &Text {
        &self.description
    }
    fn relating_annotation_occurrence(&self) -> &EntityRef {
        &self.relating_annotation_occurrence
    }
    fn related_annotation_occurrence(&self) -> &EntityRef {
        &self.related_annotation_occurrence
    }
}
impl IAnnotationOccurrenceAssociativity for DimensionCurveTerminatorToProjectionCurveAssociativity {}
impl IDimensionCurveTerminatorToProjectionCurveAssociativity
    for DimensionCurveTerminatorToProjectionCurveAssociativity
{
    fn related_annotation_occurrence(&self) -> &EntityRef {
        &self.related_annotation_occurrence
    }
    fn relating_annotation_occurrence(&self) -> &EntityRef {
        &self.relating_annotation_occurrence
    }
}
impl DimensionCurveTerminatorToProjectionCurveAssociativity {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = DimensionCurveTerminatorToProjectionCurveAssociativity::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => entity.description = parameter.into(),
                2usize => entity.related_annotation_occurrence = parameter.into(),
                3usize => entity.relating_annotation_occurrence = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IDimensionPair: IDraughtingCalloutRelationship {}
#[derive(Default, Debug)]
pub struct DimensionPair {
    name: Label,
    description: Text,
    relating_draughting_callout: EntityRef,
    related_draughting_callout: EntityRef,
}
impl IDraughtingCalloutRelationship for DimensionPair {
    fn name(&self) -> &Label {
        &self.name
    }
    fn description(&self) -> &Text {
        &self.description
    }
    fn relating_draughting_callout(&self) -> &EntityRef {
        &self.relating_draughting_callout
    }
    fn related_draughting_callout(&self) -> &EntityRef {
        &self.related_draughting_callout
    }
}
impl IDimensionPair for DimensionPair {}
impl DimensionPair {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = DimensionPair::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => entity.description = parameter.into(),
                2usize => entity.relating_draughting_callout = parameter.into(),
                3usize => entity.related_draughting_callout = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IDimensionRelatedToleranceZoneElement {
    fn related_dimension(&self) -> &EntityRef;
    fn related_element(&self) -> &EntityRef;
}
#[derive(Default, Debug)]
pub struct DimensionRelatedToleranceZoneElement {
    related_dimension: EntityRef,
    related_element: EntityRef,
}
impl IDimensionRelatedToleranceZoneElement for DimensionRelatedToleranceZoneElement {
    fn related_dimension(&self) -> &EntityRef {
        &self.related_dimension
    }
    fn related_element(&self) -> &EntityRef {
        &self.related_element
    }
}
impl DimensionRelatedToleranceZoneElement {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = DimensionRelatedToleranceZoneElement::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.related_dimension = parameter.into(),
                1usize => entity.related_element = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IDimensionTextAssociativity: ITextLiteral + IMappedItem {}
#[derive(Default, Debug)]
pub struct DimensionTextAssociativity {
    name: Label,
    literal: PresentableText,
    placement: EntityRef,
    alignment: TextAlignment,
    path: TextPath,
    font: EntityRef,
    mapping_source: EntityRef,
    mapping_target: EntityRef,
}
impl IRepresentationItem for DimensionTextAssociativity {
    fn name(&self) -> &Label {
        &self.name
    }
}
impl IGeometricRepresentationItem for DimensionTextAssociativity {}
impl ITextLiteral for DimensionTextAssociativity {
    fn literal(&self) -> &PresentableText {
        &self.literal
    }
    fn placement(&self) -> &EntityRef {
        &self.placement
    }
    fn alignment(&self) -> &TextAlignment {
        &self.alignment
    }
    fn path(&self) -> &TextPath {
        &self.path
    }
    fn font(&self) -> &EntityRef {
        &self.font
    }
}
impl IDimensionTextAssociativity for DimensionTextAssociativity {}
impl IMappedItem for DimensionTextAssociativity {
    fn mapping_source(&self) -> &EntityRef {
        &self.mapping_source
    }
    fn mapping_target(&self) -> &EntityRef {
        &self.mapping_target
    }
}
impl DimensionTextAssociativity {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = DimensionTextAssociativity::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => entity.literal = parameter.into(),
                2usize => entity.placement = parameter.into(),
                3usize => entity.alignment = parameter.into(),
                4usize => entity.path = parameter.into(),
                5usize => entity.font = parameter.into(),
                6usize => entity.mapping_source = parameter.into(),
                7usize => entity.mapping_target = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IDimensionalCharacteristicRepresentation {
    fn dimension(&self) -> &EntityRef;
    fn representation(&self) -> &EntityRef;
}
#[derive(Default, Debug)]
pub struct DimensionalCharacteristicRepresentation {
    dimension: EntityRef,
    representation: EntityRef,
}
impl IDimensionalCharacteristicRepresentation for DimensionalCharacteristicRepresentation {
    fn dimension(&self) -> &EntityRef {
        &self.dimension
    }
    fn representation(&self) -> &EntityRef {
        &self.representation
    }
}
impl DimensionalCharacteristicRepresentation {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = DimensionalCharacteristicRepresentation::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.dimension = parameter.into(),
                1usize => entity.representation = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IDimensionalExponents {
    fn length_exponent(&self) -> Real;
    fn mass_exponent(&self) -> Real;
    fn time_exponent(&self) -> Real;
    fn electric_current_exponent(&self) -> Real;
    fn thermodynamic_temperature_exponent(&self) -> Real;
    fn amount_of_substance_exponent(&self) -> Real;
    fn luminous_intensity_exponent(&self) -> Real;
}
#[derive(Default, Debug)]
pub struct DimensionalExponents {
    length_exponent: Real,
    mass_exponent: Real,
    time_exponent: Real,
    electric_current_exponent: Real,
    thermodynamic_temperature_exponent: Real,
    amount_of_substance_exponent: Real,
    luminous_intensity_exponent: Real,
}
impl IDimensionalExponents for DimensionalExponents {
    fn length_exponent(&self) -> Real {
        self.length_exponent
    }
    fn mass_exponent(&self) -> Real {
        self.mass_exponent
    }
    fn time_exponent(&self) -> Real {
        self.time_exponent
    }
    fn electric_current_exponent(&self) -> Real {
        self.electric_current_exponent
    }
    fn thermodynamic_temperature_exponent(&self) -> Real {
        self.thermodynamic_temperature_exponent
    }
    fn amount_of_substance_exponent(&self) -> Real {
        self.amount_of_substance_exponent
    }
    fn luminous_intensity_exponent(&self) -> Real {
        self.luminous_intensity_exponent
    }
}
impl DimensionalExponents {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = DimensionalExponents::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.length_exponent = parameter.into(),
                1usize => entity.mass_exponent = parameter.into(),
                2usize => entity.time_exponent = parameter.into(),
                3usize => entity.electric_current_exponent = parameter.into(),
                4usize => entity.thermodynamic_temperature_exponent = parameter.into(),
                5usize => entity.amount_of_substance_exponent = parameter.into(),
                6usize => entity.luminous_intensity_exponent = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IDimensionalLocation: IShapeAspectRelationship {}
#[derive(Default, Debug)]
pub struct DimensionalLocation {
    name: Label,
    description: Option<Text>,
    relating_shape_aspect: EntityRef,
    related_shape_aspect: EntityRef,
}
impl IShapeAspectRelationship for DimensionalLocation {
    fn name(&self) -> &Label {
        &self.name
    }
    fn description(&self) -> &Option<Text> {
        &self.description
    }
    fn relating_shape_aspect(&self) -> &EntityRef {
        &self.relating_shape_aspect
    }
    fn related_shape_aspect(&self) -> &EntityRef {
        &self.related_shape_aspect
    }
}
impl IDimensionalLocation for DimensionalLocation {}
impl DimensionalLocation {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = DimensionalLocation::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => entity.relating_shape_aspect = parameter.into(),
                3usize => entity.related_shape_aspect = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IDimensionalLocationWithPath: IDimensionalLocation {
    fn path(&self) -> &EntityRef;
}
#[derive(Default, Debug)]
pub struct DimensionalLocationWithPath {
    name: Label,
    description: Option<Text>,
    relating_shape_aspect: EntityRef,
    related_shape_aspect: EntityRef,
    path: EntityRef,
}
impl IShapeAspectRelationship for DimensionalLocationWithPath {
    fn name(&self) -> &Label {
        &self.name
    }
    fn description(&self) -> &Option<Text> {
        &self.description
    }
    fn relating_shape_aspect(&self) -> &EntityRef {
        &self.relating_shape_aspect
    }
    fn related_shape_aspect(&self) -> &EntityRef {
        &self.related_shape_aspect
    }
}
impl IDimensionalLocation for DimensionalLocationWithPath {}
impl IDimensionalLocationWithPath for DimensionalLocationWithPath {
    fn path(&self) -> &EntityRef {
        &self.path
    }
}
impl DimensionalLocationWithPath {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = DimensionalLocationWithPath::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => entity.relating_shape_aspect = parameter.into(),
                3usize => entity.related_shape_aspect = parameter.into(),
                4usize => entity.path = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IDimensionalSize {
    fn applies_to(&self) -> &EntityRef;
    fn name(&self) -> &Label;
}
#[derive(Default, Debug)]
pub struct DimensionalSize {
    applies_to: EntityRef,
    name: Label,
}
impl IDimensionalSize for DimensionalSize {
    fn applies_to(&self) -> &EntityRef {
        &self.applies_to
    }
    fn name(&self) -> &Label {
        &self.name
    }
}
impl DimensionalSize {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = DimensionalSize::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.applies_to = parameter.into(),
                1usize => entity.name = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IDimensionalSizeWithPath: IDimensionalSize {
    fn path(&self) -> &EntityRef;
}
#[derive(Default, Debug)]
pub struct DimensionalSizeWithPath {
    applies_to: EntityRef,
    name: Label,
    path: EntityRef,
}
impl IDimensionalSize for DimensionalSizeWithPath {
    fn applies_to(&self) -> &EntityRef {
        &self.applies_to
    }
    fn name(&self) -> &Label {
        &self.name
    }
}
impl IDimensionalSizeWithPath for DimensionalSizeWithPath {
    fn path(&self) -> &EntityRef {
        &self.path
    }
}
impl DimensionalSizeWithPath {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = DimensionalSizeWithPath::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.applies_to = parameter.into(),
                1usize => entity.name = parameter.into(),
                2usize => entity.path = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IDirectedAction: IExecutedAction {
    fn directive(&self) -> &EntityRef;
}
#[derive(Default, Debug)]
pub struct DirectedAction {
    name: Label,
    description: Option<Text>,
    chosen_method: EntityRef,
    directive: EntityRef,
}
impl IAction for DirectedAction {
    fn name(&self) -> &Label {
        &self.name
    }
    fn description(&self) -> &Option<Text> {
        &self.description
    }
    fn chosen_method(&self) -> &EntityRef {
        &self.chosen_method
    }
}
impl IExecutedAction for DirectedAction {}
impl IDirectedAction for DirectedAction {
    fn directive(&self) -> &EntityRef {
        &self.directive
    }
}
impl DirectedAction {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = DirectedAction::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => entity.chosen_method = parameter.into(),
                3usize => entity.directive = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IDirectedDimensionalLocation: IDimensionalLocation {}
#[derive(Default, Debug)]
pub struct DirectedDimensionalLocation {
    name: Label,
    description: Option<Text>,
    relating_shape_aspect: EntityRef,
    related_shape_aspect: EntityRef,
}
impl IShapeAspectRelationship for DirectedDimensionalLocation {
    fn name(&self) -> &Label {
        &self.name
    }
    fn description(&self) -> &Option<Text> {
        &self.description
    }
    fn relating_shape_aspect(&self) -> &EntityRef {
        &self.relating_shape_aspect
    }
    fn related_shape_aspect(&self) -> &EntityRef {
        &self.related_shape_aspect
    }
}
impl IDimensionalLocation for DirectedDimensionalLocation {}
impl IDirectedDimensionalLocation for DirectedDimensionalLocation {}
impl DirectedDimensionalLocation {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = DirectedDimensionalLocation::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => entity.relating_shape_aspect = parameter.into(),
                3usize => entity.related_shape_aspect = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IDirection: IGeometricRepresentationItem {
    fn direction_ratios(&self) -> &Vec<Real>;
}
#[derive(Default, Debug)]
pub struct Direction {
    name: Label,
    direction_ratios: Vec<Real>,
}
impl IRepresentationItem for Direction {
    fn name(&self) -> &Label {
        &self.name
    }
}
impl IGeometricRepresentationItem for Direction {}
impl IDirection for Direction {
    fn direction_ratios(&self) -> &Vec<Real> {
        &self.direction_ratios
    }
}
impl Direction {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = Direction::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => entity.direction_ratios = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IDocument {
    fn id(&self) -> &Identifier;
    fn name(&self) -> &Label;
    fn description(&self) -> &Option<Text>;
    fn kind(&self) -> &EntityRef;
}
#[derive(Default, Debug)]
pub struct Document {
    id: Identifier,
    name: Label,
    description: Option<Text>,
    kind: EntityRef,
}
impl IDocument for Document {
    fn id(&self) -> &Identifier {
        &self.id
    }
    fn name(&self) -> &Label {
        &self.name
    }
    fn description(&self) -> &Option<Text> {
        &self.description
    }
    fn kind(&self) -> &EntityRef {
        &self.kind
    }
}
impl Document {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = Document::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.id = parameter.into(),
                1usize => entity.name = parameter.into(),
                2usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => entity.kind = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IDocumentFile: IDocument + ICharacterizedObject {}
#[derive(Default, Debug)]
pub struct DocumentFile {
    id: Identifier,
    name: Label,
    description: Option<Text>,
    kind: EntityRef,
}
impl IDocument for DocumentFile {
    fn id(&self) -> &Identifier {
        &self.id
    }
    fn name(&self) -> &Label {
        &self.name
    }
    fn description(&self) -> &Option<Text> {
        &self.description
    }
    fn kind(&self) -> &EntityRef {
        &self.kind
    }
}
impl ICharacterizedObject for DocumentFile {
    fn name(&self) -> &Label {
        &self.name
    }
    fn description(&self) -> &Option<Text> {
        &self.description
    }
}
impl IDocumentFile for DocumentFile {}
impl DocumentFile {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = DocumentFile::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.id = parameter.into(),
                1usize => entity.name = parameter.into(),
                2usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => entity.kind = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IDocumentIdentifier: IGroup {}
#[derive(Default, Debug)]
pub struct DocumentIdentifier {
    name: Label,
    description: Option<Text>,
}
impl IGroup for DocumentIdentifier {
    fn name(&self) -> &Label {
        &self.name
    }
    fn description(&self) -> &Option<Text> {
        &self.description
    }
}
impl IDocumentIdentifier for DocumentIdentifier {}
impl DocumentIdentifier {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = DocumentIdentifier::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
}
pub trait IDocumentIdentifierAssignment: IGroupAssignment {
    fn items(&self) -> &HashSet<EntityRef>;
    fn assigned_group(&self) -> &EntityRef;
}
#[derive(Default, Debug)]
pub struct DocumentIdentifierAssignment {
    items: HashSet<EntityRef>,
    assigned_group: EntityRef,
}
impl IGroupAssignment for DocumentIdentifierAssignment {
    fn assigned_group(&self) -> &EntityRef {
        &self.assigned_group
    }
}
impl IDocumentIdentifierAssignment for DocumentIdentifierAssignment {
    fn items(&self) -> &HashSet<EntityRef> {
        &self.items
    }
    fn assigned_group(&self) -> &EntityRef {
        &self.assigned_group
    }
}
impl DocumentIdentifierAssignment {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = DocumentIdentifierAssignment::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.items = parameter.into(),
                1usize => entity.assigned_group = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IDocumentProductAssociation {
    fn name(&self) -> &Label;
    fn description(&self) -> &Option<Text>;
    fn relating_document(&self) -> &EntityRef;
    fn related_product(&self) -> &EntityRef;
}
#[derive(Default, Debug)]
pub struct DocumentProductAssociation {
    name: Label,
    description: Option<Text>,
    relating_document: EntityRef,
    related_product: EntityRef,
}
impl IDocumentProductAssociation for DocumentProductAssociation {
    fn name(&self) -> &Label {
        &self.name
    }
    fn description(&self) -> &Option<Text> {
        &self.description
    }
    fn relating_document(&self) -> &EntityRef {
        &self.relating_document
    }
    fn related_product(&self) -> &EntityRef {
        &self.related_product
    }
}
impl DocumentProductAssociation {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = DocumentProductAssociation::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => entity.relating_document = parameter.into(),
                3usize => entity.related_product = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IDocumentProductEquivalence: IDocumentProductAssociation {}
#[derive(Default, Debug)]
pub struct DocumentProductEquivalence {
    name: Label,
    description: Option<Text>,
    relating_document: EntityRef,
    related_product: EntityRef,
}
impl IDocumentProductAssociation for DocumentProductEquivalence {
    fn name(&self) -> &Label {
        &self.name
    }
    fn description(&self) -> &Option<Text> {
        &self.description
    }
    fn relating_document(&self) -> &EntityRef {
        &self.relating_document
    }
    fn related_product(&self) -> &EntityRef {
        &self.related_product
    }
}
impl IDocumentProductEquivalence for DocumentProductEquivalence {}
impl DocumentProductEquivalence {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = DocumentProductEquivalence::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => entity.relating_document = parameter.into(),
                3usize => entity.related_product = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IDocumentReference {
    fn assigned_document(&self) -> &EntityRef;
    fn source(&self) -> &Label;
}
pub trait IDocumentRelationship {
    fn name(&self) -> &Label;
    fn description(&self) -> &Option<Text>;
    fn relating_document(&self) -> &EntityRef;
    fn related_document(&self) -> &EntityRef;
}
#[derive(Default, Debug)]
pub struct DocumentRelationship {
    name: Label,
    description: Option<Text>,
    relating_document: EntityRef,
    related_document: EntityRef,
}
impl IDocumentRelationship for DocumentRelationship {
    fn name(&self) -> &Label {
        &self.name
    }
    fn description(&self) -> &Option<Text> {
        &self.description
    }
    fn relating_document(&self) -> &EntityRef {
        &self.relating_document
    }
    fn related_document(&self) -> &EntityRef {
        &self.related_document
    }
}
impl DocumentRelationship {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = DocumentRelationship::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => entity.relating_document = parameter.into(),
                3usize => entity.related_document = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IDocumentRepresentationType {
    fn name(&self) -> &Label;
    fn represented_document(&self) -> &EntityRef;
}
#[derive(Default, Debug)]
pub struct DocumentRepresentationType {
    name: Label,
    represented_document: EntityRef,
}
impl IDocumentRepresentationType for DocumentRepresentationType {
    fn name(&self) -> &Label {
        &self.name
    }
    fn represented_document(&self) -> &EntityRef {
        &self.represented_document
    }
}
impl DocumentRepresentationType {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = DocumentRepresentationType::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => entity.represented_document = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IDocumentType {
    fn product_data_type(&self) -> &Label;
}
#[derive(Default, Debug)]
pub struct DocumentType {
    product_data_type: Label,
}
impl IDocumentType for DocumentType {
    fn product_data_type(&self) -> &Label {
        &self.product_data_type
    }
}
impl DocumentType {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = DocumentType::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.product_data_type = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IDocumentUsageConstraint {
    fn source(&self) -> &EntityRef;
    fn subject_element(&self) -> &Label;
    fn subject_element_value(&self) -> &Text;
}
#[derive(Default, Debug)]
pub struct DocumentUsageConstraint {
    source: EntityRef,
    subject_element: Label,
    subject_element_value: Text,
}
impl IDocumentUsageConstraint for DocumentUsageConstraint {
    fn source(&self) -> &EntityRef {
        &self.source
    }
    fn subject_element(&self) -> &Label {
        &self.subject_element
    }
    fn subject_element_value(&self) -> &Text {
        &self.subject_element_value
    }
}
impl DocumentUsageConstraint {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = DocumentUsageConstraint::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.source = parameter.into(),
                1usize => entity.subject_element = parameter.into(),
                2usize => entity.subject_element_value = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IDocumentUsageConstraintAssignment {
    fn assigned_document_usage(&self) -> &EntityRef;
    fn role(&self) -> &EntityRef;
}
pub trait IDocumentUsageRole {
    fn name(&self) -> &Label;
    fn description(&self) -> &Option<Text>;
}
#[derive(Default, Debug)]
pub struct DocumentUsageRole {
    name: Label,
    description: Option<Text>,
}
impl IDocumentUsageRole for DocumentUsageRole {
    fn name(&self) -> &Label {
        &self.name
    }
    fn description(&self) -> &Option<Text> {
        &self.description
    }
}
impl DocumentUsageRole {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = DocumentUsageRole::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
}
pub trait IDoseEquivalentMeasureWithUnit: IMeasureWithUnit {}
#[derive(Default, Debug)]
pub struct DoseEquivalentMeasureWithUnit {
    value_component: MeasureValue,
    unit_component: EntityRef,
}
impl IMeasureWithUnit for DoseEquivalentMeasureWithUnit {
    fn value_component(&self) -> &MeasureValue {
        &self.value_component
    }
    fn unit_component(&self) -> &EntityRef {
        &self.unit_component
    }
}
impl IDoseEquivalentMeasureWithUnit for DoseEquivalentMeasureWithUnit {}
impl DoseEquivalentMeasureWithUnit {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = DoseEquivalentMeasureWithUnit::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.value_component = parameter.into(),
                1usize => entity.unit_component = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IDoseEquivalentUnit: IDerivedUnit {}
#[derive(Default, Debug)]
pub struct DoseEquivalentUnit {
    elements: HashSet<EntityRef>,
}
impl IDerivedUnit for DoseEquivalentUnit {
    fn elements(&self) -> &HashSet<EntityRef> {
        &self.elements
    }
}
impl IDoseEquivalentUnit for DoseEquivalentUnit {}
impl DoseEquivalentUnit {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = DoseEquivalentUnit::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.elements = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IDoubleOffsetShelledSolid: IShelledSolid {
    fn thickness2(&self) -> &LengthMeasure;
}
#[derive(Default, Debug)]
pub struct DoubleOffsetShelledSolid {
    name: Label,
    rationale: Text,
    base_solid: EntityRef,
    deleted_face_set: HashSet<EntityRef>,
    thickness: LengthMeasure,
    thickness2: LengthMeasure,
}
impl IRepresentationItem for DoubleOffsetShelledSolid {
    fn name(&self) -> &Label {
        &self.name
    }
}
impl IGeometricRepresentationItem for DoubleOffsetShelledSolid {}
impl ISolidModel for DoubleOffsetShelledSolid {}
impl IModifiedSolid for DoubleOffsetShelledSolid {
    fn rationale(&self) -> &Text {
        &self.rationale
    }
    fn base_solid(&self) -> &EntityRef {
        &self.base_solid
    }
}
impl IShelledSolid for DoubleOffsetShelledSolid {
    fn deleted_face_set(&self) -> &HashSet<EntityRef> {
        &self.deleted_face_set
    }
    fn thickness(&self) -> &LengthMeasure {
        &self.thickness
    }
}
impl IDoubleOffsetShelledSolid for DoubleOffsetShelledSolid {
    fn thickness2(&self) -> &LengthMeasure {
        &self.thickness2
    }
}
impl DoubleOffsetShelledSolid {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = DoubleOffsetShelledSolid::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => entity.rationale = parameter.into(),
                2usize => entity.base_solid = parameter.into(),
                3usize => entity.deleted_face_set = parameter.into(),
                4usize => entity.thickness = parameter.into(),
                5usize => entity.thickness2 = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IDrapedDefinedTransformation: ITransformationWithDerivedAngle {}
#[derive(Default, Debug)]
pub struct DrapedDefinedTransformation {
    name: Label,
    description: Option<Text>,
    transform_item_1: EntityRef,
    transform_item_2: EntityRef,
}
impl IItemDefinedTransformation for DrapedDefinedTransformation {
    fn name(&self) -> &Label {
        &self.name
    }
    fn description(&self) -> &Option<Text> {
        &self.description
    }
    fn transform_item_1(&self) -> &EntityRef {
        &self.transform_item_1
    }
    fn transform_item_2(&self) -> &EntityRef {
        &self.transform_item_2
    }
}
impl ITransformationWithDerivedAngle for DrapedDefinedTransformation {
    fn transform_item_1(&self) -> &EntityRef {
        &self.transform_item_1
    }
    fn transform_item_2(&self) -> &EntityRef {
        &self.transform_item_2
    }
}
impl IDrapedDefinedTransformation for DrapedDefinedTransformation {}
impl DrapedDefinedTransformation {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = DrapedDefinedTransformation::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => entity.transform_item_1 = parameter.into(),
                3usize => entity.transform_item_2 = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IDraughtingAnnotationOccurrence: IAnnotationOccurrence {}
#[derive(Default, Debug)]
pub struct DraughtingAnnotationOccurrence {
    name: Label,
    styles: HashSet<EntityRef>,
    item: EntityRef,
}
impl IRepresentationItem for DraughtingAnnotationOccurrence {
    fn name(&self) -> &Label {
        &self.name
    }
}
impl IStyledItem for DraughtingAnnotationOccurrence {
    fn styles(&self) -> &HashSet<EntityRef> {
        &self.styles
    }
    fn item(&self) -> &EntityRef {
        &self.item
    }
}
impl IAnnotationOccurrence for DraughtingAnnotationOccurrence {}
impl IDraughtingAnnotationOccurrence for DraughtingAnnotationOccurrence {}
impl DraughtingAnnotationOccurrence {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = DraughtingAnnotationOccurrence::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => entity.styles = parameter.into(),
                2usize => entity.item = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IDraughtingCallout: IGeometricRepresentationItem {
    fn contents(&self) -> &HashSet<EntityRef>;
}
#[derive(Default, Debug)]
pub struct DraughtingCallout {
    name: Label,
    contents: HashSet<EntityRef>,
}
impl IRepresentationItem for DraughtingCallout {
    fn name(&self) -> &Label {
        &self.name
    }
}
impl IGeometricRepresentationItem for DraughtingCallout {}
impl IDraughtingCallout for DraughtingCallout {
    fn contents(&self) -> &HashSet<EntityRef> {
        &self.contents
    }
}
impl DraughtingCallout {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = DraughtingCallout::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => entity.contents = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IDraughtingCalloutRelationship {
    fn name(&self) -> &Label;
    fn description(&self) -> &Text;
    fn relating_draughting_callout(&self) -> &EntityRef;
    fn related_draughting_callout(&self) -> &EntityRef;
}
#[derive(Default, Debug)]
pub struct DraughtingCalloutRelationship {
    name: Label,
    description: Text,
    relating_draughting_callout: EntityRef,
    related_draughting_callout: EntityRef,
}
impl IDraughtingCalloutRelationship for DraughtingCalloutRelationship {
    fn name(&self) -> &Label {
        &self.name
    }
    fn description(&self) -> &Text {
        &self.description
    }
    fn relating_draughting_callout(&self) -> &EntityRef {
        &self.relating_draughting_callout
    }
    fn related_draughting_callout(&self) -> &EntityRef {
        &self.related_draughting_callout
    }
}
impl DraughtingCalloutRelationship {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = DraughtingCalloutRelationship::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => entity.description = parameter.into(),
                2usize => entity.relating_draughting_callout = parameter.into(),
                3usize => entity.related_draughting_callout = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IDraughtingElements: IDraughtingCallout {}
#[derive(Default, Debug)]
pub struct DraughtingElements {
    name: Label,
    contents: HashSet<EntityRef>,
}
impl IRepresentationItem for DraughtingElements {
    fn name(&self) -> &Label {
        &self.name
    }
}
impl IGeometricRepresentationItem for DraughtingElements {}
impl IDraughtingCallout for DraughtingElements {
    fn contents(&self) -> &HashSet<EntityRef> {
        &self.contents
    }
}
impl IDraughtingElements for DraughtingElements {}
impl DraughtingElements {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = DraughtingElements::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => entity.contents = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IDraughtingModel: IRepresentation {
    fn items(&self) -> &HashSet<EntityRef>;
}
#[derive(Default, Debug)]
pub struct DraughtingModel {
    name: Label,
    context_of_items: EntityRef,
    items: HashSet<EntityRef>,
}
impl IRepresentation for DraughtingModel {
    fn name(&self) -> &Label {
        &self.name
    }
    fn items(&self) -> &HashSet<EntityRef> {
        &self.items
    }
    fn context_of_items(&self) -> &EntityRef {
        &self.context_of_items
    }
}
impl IDraughtingModel for DraughtingModel {
    fn items(&self) -> &HashSet<EntityRef> {
        &self.items
    }
}
impl DraughtingModel {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = DraughtingModel::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => entity.context_of_items = parameter.into(),
                2usize => entity.items = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IDraughtingModelItemAssociation: IItemIdentifiedRepresentationUsage {
    fn definition(&self) -> &EntityRef;
    fn identified_item(&self) -> &EntityRef;
    fn used_representation(&self) -> &EntityRef;
}
#[derive(Default, Debug)]
pub struct DraughtingModelItemAssociation {
    name: Label,
    description: Option<Text>,
    definition: EntityRef,
    identified_item: EntityRef,
    used_representation: EntityRef,
}
impl IItemIdentifiedRepresentationUsage for DraughtingModelItemAssociation {
    fn name(&self) -> &Label {
        &self.name
    }
    fn description(&self) -> &Option<Text> {
        &self.description
    }
    fn definition(&self) -> &EntityRef {
        &self.definition
    }
    fn used_representation(&self) -> &EntityRef {
        &self.used_representation
    }
    fn identified_item(&self) -> &EntityRef {
        &self.identified_item
    }
}
impl IDraughtingModelItemAssociation for DraughtingModelItemAssociation {
    fn definition(&self) -> &EntityRef {
        &self.definition
    }
    fn identified_item(&self) -> &EntityRef {
        &self.identified_item
    }
    fn used_representation(&self) -> &EntityRef {
        &self.used_representation
    }
}
impl DraughtingModelItemAssociation {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = DraughtingModelItemAssociation::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => entity.definition = parameter.into(),
                3usize => entity.identified_item = parameter.into(),
                4usize => entity.used_representation = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IDraughtingPreDefinedColour: IPreDefinedColour {}
#[derive(Default, Debug)]
pub struct DraughtingPreDefinedColour {
    name: Label,
}
impl IPreDefinedItem for DraughtingPreDefinedColour {
    fn name(&self) -> &Label {
        &self.name
    }
}
impl IColour for DraughtingPreDefinedColour {}
impl IPreDefinedColour for DraughtingPreDefinedColour {}
impl IDraughtingPreDefinedColour for DraughtingPreDefinedColour {}
impl DraughtingPreDefinedColour {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = DraughtingPreDefinedColour::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IDraughtingPreDefinedCurveFont: IPreDefinedCurveFont {}
#[derive(Default, Debug)]
pub struct DraughtingPreDefinedCurveFont {
    name: Label,
}
impl IPreDefinedItem for DraughtingPreDefinedCurveFont {
    fn name(&self) -> &Label {
        &self.name
    }
}
impl IPreDefinedCurveFont for DraughtingPreDefinedCurveFont {}
impl IDraughtingPreDefinedCurveFont for DraughtingPreDefinedCurveFont {}
impl DraughtingPreDefinedCurveFont {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = DraughtingPreDefinedCurveFont::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IDraughtingPreDefinedTextFont: IPreDefinedTextFont {}
#[derive(Default, Debug)]
pub struct DraughtingPreDefinedTextFont {
    name: Label,
}
impl IPreDefinedItem for DraughtingPreDefinedTextFont {
    fn name(&self) -> &Label {
        &self.name
    }
}
impl IPreDefinedTextFont for DraughtingPreDefinedTextFont {}
impl IDraughtingPreDefinedTextFont for DraughtingPreDefinedTextFont {}
impl DraughtingPreDefinedTextFont {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = DraughtingPreDefinedTextFont::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IDraughtingSubfigureRepresentation: ISymbolRepresentation {}
#[derive(Default, Debug)]
pub struct DraughtingSubfigureRepresentation {
    name: Label,
    items: HashSet<EntityRef>,
    context_of_items: EntityRef,
}
impl IRepresentation for DraughtingSubfigureRepresentation {
    fn name(&self) -> &Label {
        &self.name
    }
    fn items(&self) -> &HashSet<EntityRef> {
        &self.items
    }
    fn context_of_items(&self) -> &EntityRef {
        &self.context_of_items
    }
}
impl ISymbolRepresentation for DraughtingSubfigureRepresentation {}
impl IDraughtingSubfigureRepresentation for DraughtingSubfigureRepresentation {}
impl DraughtingSubfigureRepresentation {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = DraughtingSubfigureRepresentation::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => entity.items = parameter.into(),
                2usize => entity.context_of_items = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IDraughtingSymbolRepresentation: ISymbolRepresentation {}
#[derive(Default, Debug)]
pub struct DraughtingSymbolRepresentation {
    name: Label,
    items: HashSet<EntityRef>,
    context_of_items: EntityRef,
}
impl IRepresentation for DraughtingSymbolRepresentation {
    fn name(&self) -> &Label {
        &self.name
    }
    fn items(&self) -> &HashSet<EntityRef> {
        &self.items
    }
    fn context_of_items(&self) -> &EntityRef {
        &self.context_of_items
    }
}
impl ISymbolRepresentation for DraughtingSymbolRepresentation {}
impl IDraughtingSymbolRepresentation for DraughtingSymbolRepresentation {}
impl DraughtingSymbolRepresentation {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = DraughtingSymbolRepresentation::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => entity.items = parameter.into(),
                2usize => entity.context_of_items = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IDraughtingTextLiteralWithDelineation: ITextLiteralWithDelineation {}
#[derive(Default, Debug)]
pub struct DraughtingTextLiteralWithDelineation {
    name: Label,
    literal: PresentableText,
    placement: EntityRef,
    alignment: TextAlignment,
    path: TextPath,
    font: EntityRef,
    delineation: TextDelineation,
}
impl IRepresentationItem for DraughtingTextLiteralWithDelineation {
    fn name(&self) -> &Label {
        &self.name
    }
}
impl IGeometricRepresentationItem for DraughtingTextLiteralWithDelineation {}
impl ITextLiteral for DraughtingTextLiteralWithDelineation {
    fn literal(&self) -> &PresentableText {
        &self.literal
    }
    fn placement(&self) -> &EntityRef {
        &self.placement
    }
    fn alignment(&self) -> &TextAlignment {
        &self.alignment
    }
    fn path(&self) -> &TextPath {
        &self.path
    }
    fn font(&self) -> &EntityRef {
        &self.font
    }
}
impl ITextLiteralWithDelineation for DraughtingTextLiteralWithDelineation {
    fn delineation(&self) -> &TextDelineation {
        &self.delineation
    }
}
impl IDraughtingTextLiteralWithDelineation for DraughtingTextLiteralWithDelineation {}
impl DraughtingTextLiteralWithDelineation {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = DraughtingTextLiteralWithDelineation::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => entity.literal = parameter.into(),
                2usize => entity.placement = parameter.into(),
                3usize => entity.alignment = parameter.into(),
                4usize => entity.path = parameter.into(),
                5usize => entity.font = parameter.into(),
                6usize => entity.delineation = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IDraughtingTitle {
    fn items(&self) -> &HashSet<EntityRef>;
    fn language(&self) -> &Label;
    fn contents(&self) -> &Text;
}
#[derive(Default, Debug)]
pub struct DraughtingTitle {
    items: HashSet<EntityRef>,
    language: Label,
    contents: Text,
}
impl IDraughtingTitle for DraughtingTitle {
    fn items(&self) -> &HashSet<EntityRef> {
        &self.items
    }
    fn language(&self) -> &Label {
        &self.language
    }
    fn contents(&self) -> &Text {
        &self.contents
    }
}
impl DraughtingTitle {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = DraughtingTitle::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.items = parameter.into(),
                1usize => entity.language = parameter.into(),
                2usize => entity.contents = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IDrawingDefinition {
    fn drawing_number(&self) -> &Identifier;
    fn drawing_type(&self) -> &Option<Label>;
}
#[derive(Default, Debug)]
pub struct DrawingDefinition {
    drawing_number: Identifier,
    drawing_type: Option<Label>,
}
impl IDrawingDefinition for DrawingDefinition {
    fn drawing_number(&self) -> &Identifier {
        &self.drawing_number
    }
    fn drawing_type(&self) -> &Option<Label> {
        &self.drawing_type
    }
}
impl DrawingDefinition {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = DrawingDefinition::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.drawing_number = parameter.into(),
                1usize => {
                    entity.drawing_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
}
pub trait IDrawingRevision: IPresentationSet {
    fn revision_identifier(&self) -> &Identifier;
    fn drawing_identifier(&self) -> &EntityRef;
    fn intended_scale(&self) -> &Option<Text>;
}
#[derive(Default, Debug)]
pub struct DrawingRevision {
    revision_identifier: Identifier,
    drawing_identifier: EntityRef,
    intended_scale: Option<Text>,
}
impl IPresentationSet for DrawingRevision {}
impl IDrawingRevision for DrawingRevision {
    fn revision_identifier(&self) -> &Identifier {
        &self.revision_identifier
    }
    fn drawing_identifier(&self) -> &EntityRef {
        &self.drawing_identifier
    }
    fn intended_scale(&self) -> &Option<Text> {
        &self.intended_scale
    }
}
impl DrawingRevision {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = DrawingRevision::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.revision_identifier = parameter.into(),
                1usize => entity.drawing_identifier = parameter.into(),
                2usize => {
                    entity.intended_scale = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
}
pub trait IDrawingRevisionSequence {
    fn predecessor(&self) -> &EntityRef;
    fn successor(&self) -> &EntityRef;
}
#[derive(Default, Debug)]
pub struct DrawingRevisionSequence {
    predecessor: EntityRef,
    successor: EntityRef,
}
impl IDrawingRevisionSequence for DrawingRevisionSequence {
    fn predecessor(&self) -> &EntityRef {
        &self.predecessor
    }
    fn successor(&self) -> &EntityRef {
        &self.successor
    }
}
impl DrawingRevisionSequence {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = DrawingRevisionSequence::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.predecessor = parameter.into(),
                1usize => entity.successor = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IDrawingSheetRevision: IPresentationArea {
    fn revision_identifier(&self) -> &Identifier;
}
#[derive(Default, Debug)]
pub struct DrawingSheetRevision {
    name: Label,
    items: HashSet<EntityRef>,
    context_of_items: EntityRef,
    revision_identifier: Identifier,
}
impl IRepresentation for DrawingSheetRevision {
    fn name(&self) -> &Label {
        &self.name
    }
    fn items(&self) -> &HashSet<EntityRef> {
        &self.items
    }
    fn context_of_items(&self) -> &EntityRef {
        &self.context_of_items
    }
}
impl IPresentationRepresentation for DrawingSheetRevision {
    fn context_of_items(&self) -> &EntityRef {
        &self.context_of_items
    }
}
impl IPresentationArea for DrawingSheetRevision {}
impl IDrawingSheetRevision for DrawingSheetRevision {
    fn revision_identifier(&self) -> &Identifier {
        &self.revision_identifier
    }
}
impl DrawingSheetRevision {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = DrawingSheetRevision::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => entity.items = parameter.into(),
                2usize => entity.context_of_items = parameter.into(),
                3usize => entity.revision_identifier = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IDrawingSheetRevisionSequence: IRepresentationRelationship {}
#[derive(Default, Debug)]
pub struct DrawingSheetRevisionSequence {
    name: Label,
    description: Option<Text>,
    rep_1: EntityRef,
    rep_2: EntityRef,
}
impl IRepresentationRelationship for DrawingSheetRevisionSequence {
    fn name(&self) -> &Label {
        &self.name
    }
    fn description(&self) -> &Option<Text> {
        &self.description
    }
    fn rep_1(&self) -> &EntityRef {
        &self.rep_1
    }
    fn rep_2(&self) -> &EntityRef {
        &self.rep_2
    }
}
impl IDrawingSheetRevisionSequence for DrawingSheetRevisionSequence {}
impl DrawingSheetRevisionSequence {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = DrawingSheetRevisionSequence::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => entity.rep_1 = parameter.into(),
                3usize => entity.rep_2 = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IDrawingSheetRevisionUsage: IAreaInSet {
    fn sheet_number(&self) -> &Identifier;
}
#[derive(Default, Debug)]
pub struct DrawingSheetRevisionUsage {
    area: EntityRef,
    in_set: EntityRef,
    sheet_number: Identifier,
}
impl IAreaInSet for DrawingSheetRevisionUsage {
    fn area(&self) -> &EntityRef {
        &self.area
    }
    fn in_set(&self) -> &EntityRef {
        &self.in_set
    }
}
impl IDrawingSheetRevisionUsage for DrawingSheetRevisionUsage {
    fn sheet_number(&self) -> &Identifier {
        &self.sheet_number
    }
}
impl DrawingSheetRevisionUsage {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = DrawingSheetRevisionUsage::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.area = parameter.into(),
                1usize => entity.in_set = parameter.into(),
                2usize => entity.sheet_number = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IEdge: ITopologicalRepresentationItem {
    fn edge_start(&self) -> &EntityRef;
    fn edge_end(&self) -> &EntityRef;
}
#[derive(Default, Debug)]
pub struct Edge {
    name: Label,
    edge_start: EntityRef,
    edge_end: EntityRef,
}
impl IRepresentationItem for Edge {
    fn name(&self) -> &Label {
        &self.name
    }
}
impl ITopologicalRepresentationItem for Edge {}
impl IEdge for Edge {
    fn edge_start(&self) -> &EntityRef {
        &self.edge_start
    }
    fn edge_end(&self) -> &EntityRef {
        &self.edge_end
    }
}
impl Edge {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = Edge::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => entity.edge_start = parameter.into(),
                2usize => entity.edge_end = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IEdgeBasedWireframeModel: IGeometricRepresentationItem {
    fn ebwm_boundary(&self) -> &HashSet<EntityRef>;
}
#[derive(Default, Debug)]
pub struct EdgeBasedWireframeModel {
    name: Label,
    ebwm_boundary: HashSet<EntityRef>,
}
impl IRepresentationItem for EdgeBasedWireframeModel {
    fn name(&self) -> &Label {
        &self.name
    }
}
impl IGeometricRepresentationItem for EdgeBasedWireframeModel {}
impl IEdgeBasedWireframeModel for EdgeBasedWireframeModel {
    fn ebwm_boundary(&self) -> &HashSet<EntityRef> {
        &self.ebwm_boundary
    }
}
impl EdgeBasedWireframeModel {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = EdgeBasedWireframeModel::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => entity.ebwm_boundary = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IEdgeBasedWireframeShapeRepresentation: IShapeRepresentation {}
#[derive(Default, Debug)]
pub struct EdgeBasedWireframeShapeRepresentation {
    name: Label,
    items: HashSet<EntityRef>,
    context_of_items: EntityRef,
}
impl IRepresentation for EdgeBasedWireframeShapeRepresentation {
    fn name(&self) -> &Label {
        &self.name
    }
    fn items(&self) -> &HashSet<EntityRef> {
        &self.items
    }
    fn context_of_items(&self) -> &EntityRef {
        &self.context_of_items
    }
}
impl IShapeRepresentation for EdgeBasedWireframeShapeRepresentation {}
impl IEdgeBasedWireframeShapeRepresentation for EdgeBasedWireframeShapeRepresentation {}
impl EdgeBasedWireframeShapeRepresentation {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = EdgeBasedWireframeShapeRepresentation::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => entity.items = parameter.into(),
                2usize => entity.context_of_items = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IEdgeBlendedSolid: IModifiedSolid {
    fn blended_edges(&self) -> &Vec<EntityRef>;
}
pub trait IEdgeCurve: IEdge + IGeometricRepresentationItem {
    fn edge_geometry(&self) -> &EntityRef;
    fn same_sense(&self) -> bool;
}
#[derive(Default, Debug)]
pub struct EdgeCurve {
    name: Label,
    edge_start: EntityRef,
    edge_end: EntityRef,
    edge_geometry: EntityRef,
    same_sense: bool,
}
impl IRepresentationItem for EdgeCurve {
    fn name(&self) -> &Label {
        &self.name
    }
}
impl ITopologicalRepresentationItem for EdgeCurve {}
impl IEdge for EdgeCurve {
    fn edge_start(&self) -> &EntityRef {
        &self.edge_start
    }
    fn edge_end(&self) -> &EntityRef {
        &self.edge_end
    }
}
impl IEdgeCurve for EdgeCurve {
    fn edge_geometry(&self) -> &EntityRef {
        &self.edge_geometry
    }
    fn same_sense(&self) -> bool {
        self.same_sense
    }
}
impl IGeometricRepresentationItem for EdgeCurve {}
impl EdgeCurve {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = EdgeCurve::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => entity.edge_start = parameter.into(),
                2usize => entity.edge_end = parameter.into(),
                3usize => entity.edge_geometry = parameter.into(),
                4usize => entity.same_sense = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IEdgeLoop: ILoop + IPath {}
#[derive(Default, Debug)]
pub struct EdgeLoop {
    name: Label,
    edge_list: Vec<EntityRef>,
}
impl IRepresentationItem for EdgeLoop {
    fn name(&self) -> &Label {
        &self.name
    }
}
impl ITopologicalRepresentationItem for EdgeLoop {}
impl ILoop for EdgeLoop {}
impl IEdgeLoop for EdgeLoop {}
impl IPath for EdgeLoop {
    fn edge_list(&self) -> &Vec<EntityRef> {
        &self.edge_list
    }
}
impl EdgeLoop {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = EdgeLoop::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => entity.edge_list = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IEffectivity {
    fn id(&self) -> &Identifier;
}
#[derive(Default, Debug)]
pub struct Effectivity {
    id: Identifier,
}
impl IEffectivity for Effectivity {
    fn id(&self) -> &Identifier {
        &self.id
    }
}
impl Effectivity {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = Effectivity::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.id = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IEffectivityAssignment {
    fn assigned_effectivity(&self) -> &EntityRef;
}
pub trait IEffectivityContextAssignment {
    fn assigned_effectivity_assignment(&self) -> &EntityRef;
    fn role(&self) -> &EntityRef;
}
pub trait IEffectivityContextRole {
    fn name(&self) -> &Label;
    fn description(&self) -> &Option<Text>;
}
#[derive(Default, Debug)]
pub struct EffectivityContextRole {
    name: Label,
    description: Option<Text>,
}
impl IEffectivityContextRole for EffectivityContextRole {
    fn name(&self) -> &Label {
        &self.name
    }
    fn description(&self) -> &Option<Text> {
        &self.description
    }
}
impl EffectivityContextRole {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = EffectivityContextRole::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
}
pub trait IEffectivityRelationship {
    fn name(&self) -> &Label;
    fn description(&self) -> &Option<Text>;
    fn related_effectivity(&self) -> &EntityRef;
    fn relating_effectivity(&self) -> &EntityRef;
}
#[derive(Default, Debug)]
pub struct EffectivityRelationship {
    name: Label,
    description: Option<Text>,
    related_effectivity: EntityRef,
    relating_effectivity: EntityRef,
}
impl IEffectivityRelationship for EffectivityRelationship {
    fn name(&self) -> &Label {
        &self.name
    }
    fn description(&self) -> &Option<Text> {
        &self.description
    }
    fn related_effectivity(&self) -> &EntityRef {
        &self.related_effectivity
    }
    fn relating_effectivity(&self) -> &EntityRef {
        &self.relating_effectivity
    }
}
impl EffectivityRelationship {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = EffectivityRelationship::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => entity.related_effectivity = parameter.into(),
                3usize => entity.relating_effectivity = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IElectricChargeMeasureWithUnit: IMeasureWithUnit {}
#[derive(Default, Debug)]
pub struct ElectricChargeMeasureWithUnit {
    value_component: MeasureValue,
    unit_component: EntityRef,
}
impl IMeasureWithUnit for ElectricChargeMeasureWithUnit {
    fn value_component(&self) -> &MeasureValue {
        &self.value_component
    }
    fn unit_component(&self) -> &EntityRef {
        &self.unit_component
    }
}
impl IElectricChargeMeasureWithUnit for ElectricChargeMeasureWithUnit {}
impl ElectricChargeMeasureWithUnit {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = ElectricChargeMeasureWithUnit::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.value_component = parameter.into(),
                1usize => entity.unit_component = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IElectricChargeUnit: IDerivedUnit {}
#[derive(Default, Debug)]
pub struct ElectricChargeUnit {
    elements: HashSet<EntityRef>,
}
impl IDerivedUnit for ElectricChargeUnit {
    fn elements(&self) -> &HashSet<EntityRef> {
        &self.elements
    }
}
impl IElectricChargeUnit for ElectricChargeUnit {}
impl ElectricChargeUnit {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = ElectricChargeUnit::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.elements = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IElectricCurrentMeasureWithUnit: IMeasureWithUnit {}
#[derive(Default, Debug)]
pub struct ElectricCurrentMeasureWithUnit {
    value_component: MeasureValue,
    unit_component: EntityRef,
}
impl IMeasureWithUnit for ElectricCurrentMeasureWithUnit {
    fn value_component(&self) -> &MeasureValue {
        &self.value_component
    }
    fn unit_component(&self) -> &EntityRef {
        &self.unit_component
    }
}
impl IElectricCurrentMeasureWithUnit for ElectricCurrentMeasureWithUnit {}
impl ElectricCurrentMeasureWithUnit {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = ElectricCurrentMeasureWithUnit::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.value_component = parameter.into(),
                1usize => entity.unit_component = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IElectricCurrentUnit: INamedUnit {}
#[derive(Default, Debug)]
pub struct ElectricCurrentUnit {
    dimensions: EntityRef,
}
impl INamedUnit for ElectricCurrentUnit {
    fn dimensions(&self) -> &EntityRef {
        &self.dimensions
    }
}
impl IElectricCurrentUnit for ElectricCurrentUnit {}
impl ElectricCurrentUnit {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = ElectricCurrentUnit::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.dimensions = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IElectricPotentialMeasureWithUnit: IMeasureWithUnit {}
#[derive(Default, Debug)]
pub struct ElectricPotentialMeasureWithUnit {
    value_component: MeasureValue,
    unit_component: EntityRef,
}
impl IMeasureWithUnit for ElectricPotentialMeasureWithUnit {
    fn value_component(&self) -> &MeasureValue {
        &self.value_component
    }
    fn unit_component(&self) -> &EntityRef {
        &self.unit_component
    }
}
impl IElectricPotentialMeasureWithUnit for ElectricPotentialMeasureWithUnit {}
impl ElectricPotentialMeasureWithUnit {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = ElectricPotentialMeasureWithUnit::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.value_component = parameter.into(),
                1usize => entity.unit_component = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IElectricPotentialUnit: IDerivedUnit {}
#[derive(Default, Debug)]
pub struct ElectricPotentialUnit {
    elements: HashSet<EntityRef>,
}
impl IDerivedUnit for ElectricPotentialUnit {
    fn elements(&self) -> &HashSet<EntityRef> {
        &self.elements
    }
}
impl IElectricPotentialUnit for ElectricPotentialUnit {}
impl ElectricPotentialUnit {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = ElectricPotentialUnit::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.elements = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IElementaryBrepShapeRepresentation: IShapeRepresentation {}
#[derive(Default, Debug)]
pub struct ElementaryBrepShapeRepresentation {
    name: Label,
    items: HashSet<EntityRef>,
    context_of_items: EntityRef,
}
impl IRepresentation for ElementaryBrepShapeRepresentation {
    fn name(&self) -> &Label {
        &self.name
    }
    fn items(&self) -> &HashSet<EntityRef> {
        &self.items
    }
    fn context_of_items(&self) -> &EntityRef {
        &self.context_of_items
    }
}
impl IShapeRepresentation for ElementaryBrepShapeRepresentation {}
impl IElementaryBrepShapeRepresentation for ElementaryBrepShapeRepresentation {}
impl ElementaryBrepShapeRepresentation {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = ElementaryBrepShapeRepresentation::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => entity.items = parameter.into(),
                2usize => entity.context_of_items = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IElementarySurface: ISurface {
    fn position(&self) -> &EntityRef;
}
#[derive(Default, Debug)]
pub struct ElementarySurface {
    name: Label,
    position: EntityRef,
}
impl IRepresentationItem for ElementarySurface {
    fn name(&self) -> &Label {
        &self.name
    }
}
impl IGeometricRepresentationItem for ElementarySurface {}
impl ISurface for ElementarySurface {}
impl IElementarySurface for ElementarySurface {
    fn position(&self) -> &EntityRef {
        &self.position
    }
}
impl ElementarySurface {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = ElementarySurface::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => entity.position = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IEllipse: IConic {
    fn semi_axis_1(&self) -> &PositiveLengthMeasure;
    fn semi_axis_2(&self) -> &PositiveLengthMeasure;
}
#[derive(Default, Debug)]
pub struct Ellipse {
    name: Label,
    position: EntityRef,
    semi_axis_1: PositiveLengthMeasure,
    semi_axis_2: PositiveLengthMeasure,
}
impl IRepresentationItem for Ellipse {
    fn name(&self) -> &Label {
        &self.name
    }
}
impl IGeometricRepresentationItem for Ellipse {}
impl ICurve for Ellipse {}
impl IConic for Ellipse {
    fn position(&self) -> &EntityRef {
        &self.position
    }
}
impl IEllipse for Ellipse {
    fn semi_axis_1(&self) -> &PositiveLengthMeasure {
        &self.semi_axis_1
    }
    fn semi_axis_2(&self) -> &PositiveLengthMeasure {
        &self.semi_axis_2
    }
}
impl Ellipse {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = Ellipse::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => entity.position = parameter.into(),
                2usize => entity.semi_axis_1 = parameter.into(),
                3usize => entity.semi_axis_2 = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IEnergyMeasureWithUnit: IMeasureWithUnit {}
#[derive(Default, Debug)]
pub struct EnergyMeasureWithUnit {
    value_component: MeasureValue,
    unit_component: EntityRef,
}
impl IMeasureWithUnit for EnergyMeasureWithUnit {
    fn value_component(&self) -> &MeasureValue {
        &self.value_component
    }
    fn unit_component(&self) -> &EntityRef {
        &self.unit_component
    }
}
impl IEnergyMeasureWithUnit for EnergyMeasureWithUnit {}
impl EnergyMeasureWithUnit {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = EnergyMeasureWithUnit::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.value_component = parameter.into(),
                1usize => entity.unit_component = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IEnergyUnit: IDerivedUnit {}
#[derive(Default, Debug)]
pub struct EnergyUnit {
    elements: HashSet<EntityRef>,
}
impl IDerivedUnit for EnergyUnit {
    fn elements(&self) -> &HashSet<EntityRef> {
        &self.elements
    }
}
impl IEnergyUnit for EnergyUnit {}
impl EnergyUnit {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = EnergyUnit::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.elements = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IEntityAssertion: IFactType {}
#[derive(Default, Debug)]
pub struct EntityAssertion {
    name: Label,
    description: Option<Text>,
    definition: EntityRef,
}
impl IPropertyDefinition for EntityAssertion {
    fn name(&self) -> &Label {
        &self.name
    }
    fn description(&self) -> &Option<Text> {
        &self.description
    }
    fn definition(&self) -> &EntityRef {
        &self.definition
    }
}
impl IFactType for EntityAssertion {}
impl IEntityAssertion for EntityAssertion {}
impl EntityAssertion {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = EntityAssertion::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => entity.definition = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IEnumReferencePrefix: IDescriptiveRepresentationItem {}
#[derive(Default, Debug)]
pub struct EnumReferencePrefix {
    name: Label,
    description: Text,
}
impl IRepresentationItem for EnumReferencePrefix {
    fn name(&self) -> &Label {
        &self.name
    }
}
impl IDescriptiveRepresentationItem for EnumReferencePrefix {
    fn description(&self) -> &Text {
        &self.description
    }
}
impl IEnumReferencePrefix for EnumReferencePrefix {}
impl EnumReferencePrefix {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = EnumReferencePrefix::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => entity.description = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IEnvironment {
    fn syntactic_representation(&self) -> &EntityRef;
    fn semantics(&self) -> &EntityRef;
}
#[derive(Default, Debug)]
pub struct Environment {
    syntactic_representation: EntityRef,
    semantics: EntityRef,
}
impl IEnvironment for Environment {
    fn syntactic_representation(&self) -> &EntityRef {
        &self.syntactic_representation
    }
    fn semantics(&self) -> &EntityRef {
        &self.semantics
    }
}
impl Environment {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = Environment::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.syntactic_representation = parameter.into(),
                1usize => entity.semantics = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IEvaluatedCharacteristic: IRepresentation + IRepresentationRelationship {}
#[derive(Default, Debug)]
pub struct EvaluatedCharacteristic {
    name: Label,
    items: HashSet<EntityRef>,
    context_of_items: EntityRef,
    description: Option<Text>,
    rep_1: EntityRef,
    rep_2: EntityRef,
}
impl IRepresentation for EvaluatedCharacteristic {
    fn name(&self) -> &Label {
        &self.name
    }
    fn items(&self) -> &HashSet<EntityRef> {
        &self.items
    }
    fn context_of_items(&self) -> &EntityRef {
        &self.context_of_items
    }
}
impl IRepresentationRelationship for EvaluatedCharacteristic {
    fn name(&self) -> &Label {
        &self.name
    }
    fn description(&self) -> &Option<Text> {
        &self.description
    }
    fn rep_1(&self) -> &EntityRef {
        &self.rep_1
    }
    fn rep_2(&self) -> &EntityRef {
        &self.rep_2
    }
}
impl IEvaluatedCharacteristic for EvaluatedCharacteristic {}
impl EvaluatedCharacteristic {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = EvaluatedCharacteristic::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => entity.items = parameter.into(),
                2usize => entity.context_of_items = parameter.into(),
                3usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => entity.rep_1 = parameter.into(),
                5usize => entity.rep_2 = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IEvaluatedDegeneratePcurve: IDegeneratePcurve {
    fn equivalent_point(&self) -> &EntityRef;
}
#[derive(Default, Debug)]
pub struct EvaluatedDegeneratePcurve {
    name: Label,
    basis_surface: EntityRef,
    reference_to_curve: EntityRef,
    equivalent_point: EntityRef,
}
impl IRepresentationItem for EvaluatedDegeneratePcurve {
    fn name(&self) -> &Label {
        &self.name
    }
}
impl IGeometricRepresentationItem for EvaluatedDegeneratePcurve {}
impl IPoint for EvaluatedDegeneratePcurve {}
impl IDegeneratePcurve for EvaluatedDegeneratePcurve {
    fn basis_surface(&self) -> &EntityRef {
        &self.basis_surface
    }
    fn reference_to_curve(&self) -> &EntityRef {
        &self.reference_to_curve
    }
}
impl IEvaluatedDegeneratePcurve for EvaluatedDegeneratePcurve {
    fn equivalent_point(&self) -> &EntityRef {
        &self.equivalent_point
    }
}
impl EvaluatedDegeneratePcurve {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = EvaluatedDegeneratePcurve::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => entity.basis_surface = parameter.into(),
                2usize => entity.reference_to_curve = parameter.into(),
                3usize => entity.equivalent_point = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IEvaluationProductDefinition: IProductDefinition {}
#[derive(Default, Debug)]
pub struct EvaluationProductDefinition {
    id: Identifier,
    description: Option<Text>,
    formation: EntityRef,
    frame_of_reference: EntityRef,
}
impl IProductDefinition for EvaluationProductDefinition {
    fn id(&self) -> &Identifier {
        &self.id
    }
    fn description(&self) -> &Option<Text> {
        &self.description
    }
    fn formation(&self) -> &EntityRef {
        &self.formation
    }
    fn frame_of_reference(&self) -> &EntityRef {
        &self.frame_of_reference
    }
}
impl IEvaluationProductDefinition for EvaluationProductDefinition {}
impl EvaluationProductDefinition {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = EvaluationProductDefinition::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.id = parameter.into(),
                1usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => entity.formation = parameter.into(),
                3usize => entity.frame_of_reference = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IEventOccurrence {
    fn id(&self) -> &Identifier;
    fn name(&self) -> &Label;
    fn description(&self) -> &Option<Text>;
}
#[derive(Default, Debug)]
pub struct EventOccurrence {
    id: Identifier,
    name: Label,
    description: Option<Text>,
}
impl IEventOccurrence for EventOccurrence {
    fn id(&self) -> &Identifier {
        &self.id
    }
    fn name(&self) -> &Label {
        &self.name
    }
    fn description(&self) -> &Option<Text> {
        &self.description
    }
}
impl EventOccurrence {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = EventOccurrence::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.id = parameter.into(),
                1usize => entity.name = parameter.into(),
                2usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
}
pub trait IEventOccurrenceAssignment {
    fn assigned_event_occurrence(&self) -> &EntityRef;
    fn role(&self) -> &EntityRef;
}
pub trait IEventOccurrenceRelationship {
    fn name(&self) -> &Label;
    fn description(&self) -> &Option<Text>;
    fn relating_event(&self) -> &EntityRef;
    fn related_event(&self) -> &EntityRef;
}
#[derive(Default, Debug)]
pub struct EventOccurrenceRelationship {
    name: Label,
    description: Option<Text>,
    relating_event: EntityRef,
    related_event: EntityRef,
}
impl IEventOccurrenceRelationship for EventOccurrenceRelationship {
    fn name(&self) -> &Label {
        &self.name
    }
    fn description(&self) -> &Option<Text> {
        &self.description
    }
    fn relating_event(&self) -> &EntityRef {
        &self.relating_event
    }
    fn related_event(&self) -> &EntityRef {
        &self.related_event
    }
}
impl EventOccurrenceRelationship {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = EventOccurrenceRelationship::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => entity.relating_event = parameter.into(),
                3usize => entity.related_event = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IEventOccurrenceRole {
    fn name(&self) -> &Label;
    fn description(&self) -> &Option<Text>;
}
#[derive(Default, Debug)]
pub struct EventOccurrenceRole {
    name: Label,
    description: Option<Text>,
}
impl IEventOccurrenceRole for EventOccurrenceRole {
    fn name(&self) -> &Label {
        &self.name
    }
    fn description(&self) -> &Option<Text> {
        &self.description
    }
}
impl EventOccurrenceRole {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = EventOccurrenceRole::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
}
pub trait IExclusiveProductConceptFeatureCategory: IProductConceptFeatureCategory {}
#[derive(Default, Debug)]
pub struct ExclusiveProductConceptFeatureCategory {
    name: Label,
    description: Option<Text>,
}
impl IGroup for ExclusiveProductConceptFeatureCategory {
    fn name(&self) -> &Label {
        &self.name
    }
    fn description(&self) -> &Option<Text> {
        &self.description
    }
}
impl IProductConceptFeatureCategory for ExclusiveProductConceptFeatureCategory {}
impl IExclusiveProductConceptFeatureCategory for ExclusiveProductConceptFeatureCategory {}
impl ExclusiveProductConceptFeatureCategory {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = ExclusiveProductConceptFeatureCategory::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
}
pub trait IExecutedAction: IAction {}
#[derive(Default, Debug)]
pub struct ExecutedAction {
    name: Label,
    description: Option<Text>,
    chosen_method: EntityRef,
}
impl IAction for ExecutedAction {
    fn name(&self) -> &Label {
        &self.name
    }
    fn description(&self) -> &Option<Text> {
        &self.description
    }
    fn chosen_method(&self) -> &EntityRef {
        &self.chosen_method
    }
}
impl IExecutedAction for ExecutedAction {}
impl ExecutedAction {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = ExecutedAction::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => entity.chosen_method = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IExpandedUncertainty: IStandardUncertainty {
    fn coverage_factor(&self) -> Real;
}
#[derive(Default, Debug)]
pub struct ExpandedUncertainty {
    measure_name: Label,
    description: Text,
    uncertainty_value: Real,
    coverage_factor: Real,
}
impl IUncertaintyQualifier for ExpandedUncertainty {
    fn measure_name(&self) -> &Label {
        &self.measure_name
    }
    fn description(&self) -> &Text {
        &self.description
    }
}
impl IStandardUncertainty for ExpandedUncertainty {
    fn uncertainty_value(&self) -> Real {
        self.uncertainty_value
    }
}
impl IExpandedUncertainty for ExpandedUncertainty {
    fn coverage_factor(&self) -> Real {
        self.coverage_factor
    }
}
impl ExpandedUncertainty {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = ExpandedUncertainty::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.measure_name = parameter.into(),
                1usize => entity.description = parameter.into(),
                2usize => entity.uncertainty_value = parameter.into(),
                3usize => entity.coverage_factor = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IExplicitProceduralGeometricRepresentationItemRelationship:
    IExplicitProceduralRepresentationItemRelationship
{
    fn related_representation_item(&self) -> &EntityRef;
    fn relating_representation_item(&self) -> &EntityRef;
}
#[derive(Default, Debug)]
pub struct ExplicitProceduralGeometricRepresentationItemRelationship {
    name: Label,
    description: Option<Text>,
    related_representation_item: EntityRef,
    relating_representation_item: EntityRef,
}
impl IRepresentationItemRelationship for ExplicitProceduralGeometricRepresentationItemRelationship {
    fn name(&self) -> &Label {
        &self.name
    }
    fn description(&self) -> &Option<Text> {
        &self.description
    }
    fn relating_representation_item(&self) -> &EntityRef {
        &self.relating_representation_item
    }
    fn related_representation_item(&self) -> &EntityRef {
        &self.related_representation_item
    }
}
impl IExplicitProceduralRepresentationItemRelationship for ExplicitProceduralGeometricRepresentationItemRelationship {
    fn relating_representation_item(&self) -> &EntityRef {
        &self.relating_representation_item
    }
}
impl IExplicitProceduralGeometricRepresentationItemRelationship
    for ExplicitProceduralGeometricRepresentationItemRelationship
{
    fn related_representation_item(&self) -> &EntityRef {
        &self.related_representation_item
    }
    fn relating_representation_item(&self) -> &EntityRef {
        &self.relating_representation_item
    }
}
impl ExplicitProceduralGeometricRepresentationItemRelationship {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = ExplicitProceduralGeometricRepresentationItemRelationship::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => entity.related_representation_item = parameter.into(),
                3usize => entity.relating_representation_item = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IExplicitProceduralRepresentationItemRelationship: IRepresentationItemRelationship {
    fn relating_representation_item(&self) -> &EntityRef;
}
#[derive(Default, Debug)]
pub struct ExplicitProceduralRepresentationItemRelationship {
    name: Label,
    description: Option<Text>,
    related_representation_item: EntityRef,
    relating_representation_item: EntityRef,
}
impl IRepresentationItemRelationship for ExplicitProceduralRepresentationItemRelationship {
    fn name(&self) -> &Label {
        &self.name
    }
    fn description(&self) -> &Option<Text> {
        &self.description
    }
    fn relating_representation_item(&self) -> &EntityRef {
        &self.relating_representation_item
    }
    fn related_representation_item(&self) -> &EntityRef {
        &self.related_representation_item
    }
}
impl IExplicitProceduralRepresentationItemRelationship for ExplicitProceduralRepresentationItemRelationship {
    fn relating_representation_item(&self) -> &EntityRef {
        &self.relating_representation_item
    }
}
impl ExplicitProceduralRepresentationItemRelationship {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = ExplicitProceduralRepresentationItemRelationship::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => entity.related_representation_item = parameter.into(),
                3usize => entity.relating_representation_item = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IExplicitProceduralRepresentationRelationship: IRepresentationRelationship {
    fn rep_1(&self) -> &EntityRef;
}
#[derive(Default, Debug)]
pub struct ExplicitProceduralRepresentationRelationship {
    name: Label,
    description: Option<Text>,
    rep_2: EntityRef,
    rep_1: EntityRef,
}
impl IRepresentationRelationship for ExplicitProceduralRepresentationRelationship {
    fn name(&self) -> &Label {
        &self.name
    }
    fn description(&self) -> &Option<Text> {
        &self.description
    }
    fn rep_1(&self) -> &EntityRef {
        &self.rep_1
    }
    fn rep_2(&self) -> &EntityRef {
        &self.rep_2
    }
}
impl IExplicitProceduralRepresentationRelationship for ExplicitProceduralRepresentationRelationship {
    fn rep_1(&self) -> &EntityRef {
        &self.rep_1
    }
}
impl ExplicitProceduralRepresentationRelationship {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = ExplicitProceduralRepresentationRelationship::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => entity.rep_2 = parameter.into(),
                3usize => entity.rep_1 = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IExplicitProceduralShapeRepresentationRelationship: IExplicitProceduralRepresentationRelationship {
    fn rep_1(&self) -> &EntityRef;
    fn rep_2(&self) -> &EntityRef;
}
#[derive(Default, Debug)]
pub struct ExplicitProceduralShapeRepresentationRelationship {
    name: Label,
    description: Option<Text>,
    rep_1: EntityRef,
    rep_2: EntityRef,
}
impl IRepresentationRelationship for ExplicitProceduralShapeRepresentationRelationship {
    fn name(&self) -> &Label {
        &self.name
    }
    fn description(&self) -> &Option<Text> {
        &self.description
    }
    fn rep_1(&self) -> &EntityRef {
        &self.rep_1
    }
    fn rep_2(&self) -> &EntityRef {
        &self.rep_2
    }
}
impl IExplicitProceduralRepresentationRelationship for ExplicitProceduralShapeRepresentationRelationship {
    fn rep_1(&self) -> &EntityRef {
        &self.rep_1
    }
}
impl IExplicitProceduralShapeRepresentationRelationship for ExplicitProceduralShapeRepresentationRelationship {
    fn rep_1(&self) -> &EntityRef {
        &self.rep_1
    }
    fn rep_2(&self) -> &EntityRef {
        &self.rep_2
    }
}
impl ExplicitProceduralShapeRepresentationRelationship {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = ExplicitProceduralShapeRepresentationRelationship::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => entity.rep_1 = parameter.into(),
                3usize => entity.rep_2 = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IExpression: IGenericExpression {}
pub trait IExpressionConversionBasedUnit: IContextDependentUnit + IVariableSemantics {}
#[derive(Default, Debug)]
pub struct ExpressionConversionBasedUnit {
    dimensions: EntityRef,
    name: Label,
}
impl INamedUnit for ExpressionConversionBasedUnit {
    fn dimensions(&self) -> &EntityRef {
        &self.dimensions
    }
}
impl IContextDependentUnit for ExpressionConversionBasedUnit {
    fn name(&self) -> &Label {
        &self.name
    }
}
impl IVariableSemantics for ExpressionConversionBasedUnit {}
impl IExpressionConversionBasedUnit for ExpressionConversionBasedUnit {}
impl ExpressionConversionBasedUnit {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = ExpressionConversionBasedUnit::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.dimensions = parameter.into(),
                1usize => entity.name = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IExtension: IDerivedShapeAspect {}
#[derive(Default, Debug)]
pub struct Extension {
    name: Label,
    description: Option<Text>,
    of_shape: EntityRef,
    product_definitional: Option<bool>,
}
impl IShapeAspect for Extension {
    fn name(&self) -> &Label {
        &self.name
    }
    fn description(&self) -> &Option<Text> {
        &self.description
    }
    fn of_shape(&self) -> &EntityRef {
        &self.of_shape
    }
    fn product_definitional(&self) -> Option<bool> {
        self.product_definitional
    }
}
impl IDerivedShapeAspect for Extension {}
impl IExtension for Extension {}
impl Extension {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = Extension::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => entity.of_shape = parameter.into(),
                3usize => entity.product_definitional = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IExtent: ICharacterizedObject {}
#[derive(Default, Debug)]
pub struct Extent {
    name: Label,
    description: Option<Text>,
}
impl ICharacterizedObject for Extent {
    fn name(&self) -> &Label {
        &self.name
    }
    fn description(&self) -> &Option<Text> {
        &self.description
    }
}
impl IExtent for Extent {}
impl Extent {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = Extent::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
}
pub trait IExternalClassLibrary: IExternalSource {}
#[derive(Default, Debug)]
pub struct ExternalClassLibrary {
    source_id: SourceItem,
}
impl IExternalSource for ExternalClassLibrary {
    fn source_id(&self) -> &SourceItem {
        &self.source_id
    }
}
impl IExternalClassLibrary for ExternalClassLibrary {}
impl ExternalClassLibrary {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = ExternalClassLibrary::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.source_id = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IExternalIdentificationAssignment: IIdentificationAssignment {
    fn source(&self) -> &EntityRef;
}
pub trait IExternalSource {
    fn source_id(&self) -> &SourceItem;
}
#[derive(Default, Debug)]
pub struct ExternalSource {
    source_id: SourceItem,
}
impl IExternalSource for ExternalSource {
    fn source_id(&self) -> &SourceItem {
        &self.source_id
    }
}
impl ExternalSource {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = ExternalSource::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.source_id = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IExternalSourceRelationship {
    fn name(&self) -> &Label;
    fn description(&self) -> &Option<Text>;
    fn relating_source(&self) -> &EntityRef;
    fn related_source(&self) -> &EntityRef;
}
#[derive(Default, Debug)]
pub struct ExternalSourceRelationship {
    name: Label,
    description: Option<Text>,
    relating_source: EntityRef,
    related_source: EntityRef,
}
impl IExternalSourceRelationship for ExternalSourceRelationship {
    fn name(&self) -> &Label {
        &self.name
    }
    fn description(&self) -> &Option<Text> {
        &self.description
    }
    fn relating_source(&self) -> &EntityRef {
        &self.relating_source
    }
    fn related_source(&self) -> &EntityRef {
        &self.related_source
    }
}
impl ExternalSourceRelationship {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = ExternalSourceRelationship::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => entity.relating_source = parameter.into(),
                3usize => entity.related_source = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IExternallyDefinedClass: IClass + IExternallyDefinedItem {}
#[derive(Default, Debug)]
pub struct ExternallyDefinedClass {
    name: Label,
    description: Option<Text>,
    item_id: SourceItem,
    source: EntityRef,
}
impl IGroup for ExternallyDefinedClass {
    fn name(&self) -> &Label {
        &self.name
    }
    fn description(&self) -> &Option<Text> {
        &self.description
    }
}
impl IClass for ExternallyDefinedClass {}
impl IExternallyDefinedItem for ExternallyDefinedClass {
    fn item_id(&self) -> &SourceItem {
        &self.item_id
    }
    fn source(&self) -> &EntityRef {
        &self.source
    }
}
impl IExternallyDefinedClass for ExternallyDefinedClass {}
impl ExternallyDefinedClass {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = ExternallyDefinedClass::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => entity.item_id = parameter.into(),
                3usize => entity.source = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IExternallyDefinedColour: IColourSpecification + IExternallyDefinedItem {}
#[derive(Default, Debug)]
pub struct ExternallyDefinedColour {
    name: Label,
    item_id: SourceItem,
    source: EntityRef,
}
impl IColour for ExternallyDefinedColour {}
impl IColourSpecification for ExternallyDefinedColour {
    fn name(&self) -> &Label {
        &self.name
    }
}
impl IExternallyDefinedItem for ExternallyDefinedColour {
    fn item_id(&self) -> &SourceItem {
        &self.item_id
    }
    fn source(&self) -> &EntityRef {
        &self.source
    }
}
impl IExternallyDefinedColour for ExternallyDefinedColour {}
impl ExternallyDefinedColour {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = ExternallyDefinedColour::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => entity.item_id = parameter.into(),
                2usize => entity.source = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IExternallyDefinedContextDependentUnit: IContextDependentUnit + IExternallyDefinedItem {}
#[derive(Default, Debug)]
pub struct ExternallyDefinedContextDependentUnit {
    dimensions: EntityRef,
    name: Label,
    item_id: SourceItem,
    source: EntityRef,
}
impl INamedUnit for ExternallyDefinedContextDependentUnit {
    fn dimensions(&self) -> &EntityRef {
        &self.dimensions
    }
}
impl IContextDependentUnit for ExternallyDefinedContextDependentUnit {
    fn name(&self) -> &Label {
        &self.name
    }
}
impl IExternallyDefinedItem for ExternallyDefinedContextDependentUnit {
    fn item_id(&self) -> &SourceItem {
        &self.item_id
    }
    fn source(&self) -> &EntityRef {
        &self.source
    }
}
impl IExternallyDefinedContextDependentUnit for ExternallyDefinedContextDependentUnit {}
impl ExternallyDefinedContextDependentUnit {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = ExternallyDefinedContextDependentUnit::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.dimensions = parameter.into(),
                1usize => entity.name = parameter.into(),
                2usize => entity.item_id = parameter.into(),
                3usize => entity.source = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IExternallyDefinedConversionBasedUnit: IConversionBasedUnit + IExternallyDefinedItem {}
#[derive(Default, Debug)]
pub struct ExternallyDefinedConversionBasedUnit {
    dimensions: EntityRef,
    name: Label,
    conversion_factor: EntityRef,
    item_id: SourceItem,
    source: EntityRef,
}
impl INamedUnit for ExternallyDefinedConversionBasedUnit {
    fn dimensions(&self) -> &EntityRef {
        &self.dimensions
    }
}
impl IConversionBasedUnit for ExternallyDefinedConversionBasedUnit {
    fn name(&self) -> &Label {
        &self.name
    }
    fn conversion_factor(&self) -> &EntityRef {
        &self.conversion_factor
    }
}
impl IExternallyDefinedItem for ExternallyDefinedConversionBasedUnit {
    fn item_id(&self) -> &SourceItem {
        &self.item_id
    }
    fn source(&self) -> &EntityRef {
        &self.source
    }
}
impl IExternallyDefinedConversionBasedUnit for ExternallyDefinedConversionBasedUnit {}
impl ExternallyDefinedConversionBasedUnit {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = ExternallyDefinedConversionBasedUnit::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.dimensions = parameter.into(),
                1usize => entity.name = parameter.into(),
                2usize => entity.conversion_factor = parameter.into(),
                3usize => entity.item_id = parameter.into(),
                4usize => entity.source = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IExternallyDefinedCurrency: ICurrency + IExternallyDefinedContextDependentUnit {}
#[derive(Default, Debug)]
pub struct ExternallyDefinedCurrency {
    dimensions: EntityRef,
    name: Label,
    item_id: SourceItem,
    source: EntityRef,
}
impl INamedUnit for ExternallyDefinedCurrency {
    fn dimensions(&self) -> &EntityRef {
        &self.dimensions
    }
}
impl IContextDependentUnit for ExternallyDefinedCurrency {
    fn name(&self) -> &Label {
        &self.name
    }
}
impl ICurrency for ExternallyDefinedCurrency {}
impl IExternallyDefinedCurrency for ExternallyDefinedCurrency {}
impl IExternallyDefinedContextDependentUnit for ExternallyDefinedCurrency {}
impl IExternallyDefinedItem for ExternallyDefinedCurrency {
    fn item_id(&self) -> &SourceItem {
        &self.item_id
    }
    fn source(&self) -> &EntityRef {
        &self.source
    }
}
impl ExternallyDefinedCurrency {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = ExternallyDefinedCurrency::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.dimensions = parameter.into(),
                1usize => entity.name = parameter.into(),
                2usize => entity.item_id = parameter.into(),
                3usize => entity.source = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IExternallyDefinedCurveFont: IExternallyDefinedItem {}
#[derive(Default, Debug)]
pub struct ExternallyDefinedCurveFont {
    item_id: SourceItem,
    source: EntityRef,
}
impl IExternallyDefinedItem for ExternallyDefinedCurveFont {
    fn item_id(&self) -> &SourceItem {
        &self.item_id
    }
    fn source(&self) -> &EntityRef {
        &self.source
    }
}
impl IExternallyDefinedCurveFont for ExternallyDefinedCurveFont {}
impl ExternallyDefinedCurveFont {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = ExternallyDefinedCurveFont::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.item_id = parameter.into(),
                1usize => entity.source = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IExternallyDefinedDimensionDefinition: IDimensionalSize + IExternallyDefinedItem {}
#[derive(Default, Debug)]
pub struct ExternallyDefinedDimensionDefinition {
    applies_to: EntityRef,
    name: Label,
    item_id: SourceItem,
    source: EntityRef,
}
impl IDimensionalSize for ExternallyDefinedDimensionDefinition {
    fn applies_to(&self) -> &EntityRef {
        &self.applies_to
    }
    fn name(&self) -> &Label {
        &self.name
    }
}
impl IExternallyDefinedItem for ExternallyDefinedDimensionDefinition {
    fn item_id(&self) -> &SourceItem {
        &self.item_id
    }
    fn source(&self) -> &EntityRef {
        &self.source
    }
}
impl IExternallyDefinedDimensionDefinition for ExternallyDefinedDimensionDefinition {}
impl ExternallyDefinedDimensionDefinition {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = ExternallyDefinedDimensionDefinition::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.applies_to = parameter.into(),
                1usize => entity.name = parameter.into(),
                2usize => entity.item_id = parameter.into(),
                3usize => entity.source = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IExternallyDefinedGeneralProperty: IGeneralProperty + IExternallyDefinedItem {}
#[derive(Default, Debug)]
pub struct ExternallyDefinedGeneralProperty {
    id: Identifier,
    name: Label,
    description: Option<Text>,
    item_id: SourceItem,
    source: EntityRef,
}
impl IGeneralProperty for ExternallyDefinedGeneralProperty {
    fn id(&self) -> &Identifier {
        &self.id
    }
    fn name(&self) -> &Label {
        &self.name
    }
    fn description(&self) -> &Option<Text> {
        &self.description
    }
}
impl IExternallyDefinedItem for ExternallyDefinedGeneralProperty {
    fn item_id(&self) -> &SourceItem {
        &self.item_id
    }
    fn source(&self) -> &EntityRef {
        &self.source
    }
}
impl IExternallyDefinedGeneralProperty for ExternallyDefinedGeneralProperty {}
impl ExternallyDefinedGeneralProperty {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = ExternallyDefinedGeneralProperty::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.id = parameter.into(),
                1usize => entity.name = parameter.into(),
                2usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => entity.item_id = parameter.into(),
                4usize => entity.source = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IExternallyDefinedHatchStyle: IExternallyDefinedItem + IGeometricRepresentationItem {}
#[derive(Default, Debug)]
pub struct ExternallyDefinedHatchStyle {
    item_id: SourceItem,
    source: EntityRef,
    name: Label,
}
impl IExternallyDefinedItem for ExternallyDefinedHatchStyle {
    fn item_id(&self) -> &SourceItem {
        &self.item_id
    }
    fn source(&self) -> &EntityRef {
        &self.source
    }
}
impl IRepresentationItem for ExternallyDefinedHatchStyle {
    fn name(&self) -> &Label {
        &self.name
    }
}
impl IGeometricRepresentationItem for ExternallyDefinedHatchStyle {}
impl IExternallyDefinedHatchStyle for ExternallyDefinedHatchStyle {}
impl ExternallyDefinedHatchStyle {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = ExternallyDefinedHatchStyle::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.item_id = parameter.into(),
                1usize => entity.source = parameter.into(),
                2usize => entity.name = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IExternallyDefinedItem {
    fn item_id(&self) -> &SourceItem;
    fn source(&self) -> &EntityRef;
}
#[derive(Default, Debug)]
pub struct ExternallyDefinedItem {
    item_id: SourceItem,
    source: EntityRef,
}
impl IExternallyDefinedItem for ExternallyDefinedItem {
    fn item_id(&self) -> &SourceItem {
        &self.item_id
    }
    fn source(&self) -> &EntityRef {
        &self.source
    }
}
impl ExternallyDefinedItem {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = ExternallyDefinedItem::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.item_id = parameter.into(),
                1usize => entity.source = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IExternallyDefinedItemRelationship {
    fn name(&self) -> &Label;
    fn description(&self) -> &Option<Text>;
    fn relating_item(&self) -> &EntityRef;
    fn related_item(&self) -> &EntityRef;
}
#[derive(Default, Debug)]
pub struct ExternallyDefinedItemRelationship {
    name: Label,
    description: Option<Text>,
    relating_item: EntityRef,
    related_item: EntityRef,
}
impl IExternallyDefinedItemRelationship for ExternallyDefinedItemRelationship {
    fn name(&self) -> &Label {
        &self.name
    }
    fn description(&self) -> &Option<Text> {
        &self.description
    }
    fn relating_item(&self) -> &EntityRef {
        &self.relating_item
    }
    fn related_item(&self) -> &EntityRef {
        &self.related_item
    }
}
impl ExternallyDefinedItemRelationship {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = ExternallyDefinedItemRelationship::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => entity.relating_item = parameter.into(),
                3usize => entity.related_item = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IExternallyDefinedMarker: IExternallyDefinedSymbol + IPreDefinedMarker {}
#[derive(Default, Debug)]
pub struct ExternallyDefinedMarker {
    item_id: SourceItem,
    source: EntityRef,
    name: Label,
}
impl IExternallyDefinedItem for ExternallyDefinedMarker {
    fn item_id(&self) -> &SourceItem {
        &self.item_id
    }
    fn source(&self) -> &EntityRef {
        &self.source
    }
}
impl IExternallyDefinedSymbol for ExternallyDefinedMarker {}
impl IPreDefinedItem for ExternallyDefinedMarker {
    fn name(&self) -> &Label {
        &self.name
    }
}
impl IPreDefinedMarker for ExternallyDefinedMarker {}
impl IExternallyDefinedMarker for ExternallyDefinedMarker {}
impl ExternallyDefinedMarker {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = ExternallyDefinedMarker::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.item_id = parameter.into(),
                1usize => entity.source = parameter.into(),
                2usize => entity.name = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IExternallyDefinedPictureRepresentationItem: IPictureRepresentationItem {}
#[derive(Default, Debug)]
pub struct ExternallyDefinedPictureRepresentationItem {
    name: Label,
    binary_value: Unimplemented,
}
impl IRepresentationItem for ExternallyDefinedPictureRepresentationItem {
    fn name(&self) -> &Label {
        &self.name
    }
}
impl IBinaryRepresentationItem for ExternallyDefinedPictureRepresentationItem {
    fn binary_value(&self) -> &Unimplemented {
        &self.binary_value
    }
}
impl IBytesRepresentationItem for ExternallyDefinedPictureRepresentationItem {}
impl IPictureRepresentationItem for ExternallyDefinedPictureRepresentationItem {}
impl IExternallyDefinedPictureRepresentationItem for ExternallyDefinedPictureRepresentationItem {}
impl ExternallyDefinedPictureRepresentationItem {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = ExternallyDefinedPictureRepresentationItem::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => entity.binary_value = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IExternallyDefinedRepresentationItem: IRepresentationItem + IExternallyDefinedItem {}
#[derive(Default, Debug)]
pub struct ExternallyDefinedRepresentationItem {
    name: Label,
    item_id: SourceItem,
    source: EntityRef,
}
impl IRepresentationItem for ExternallyDefinedRepresentationItem {
    fn name(&self) -> &Label {
        &self.name
    }
}
impl IExternallyDefinedItem for ExternallyDefinedRepresentationItem {
    fn item_id(&self) -> &SourceItem {
        &self.item_id
    }
    fn source(&self) -> &EntityRef {
        &self.source
    }
}
impl IExternallyDefinedRepresentationItem for ExternallyDefinedRepresentationItem {}
impl ExternallyDefinedRepresentationItem {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = ExternallyDefinedRepresentationItem::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => entity.item_id = parameter.into(),
                2usize => entity.source = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IExternallyDefinedString: IExternallyDefinedRepresentationItem {}
#[derive(Default, Debug)]
pub struct ExternallyDefinedString {
    name: Label,
    item_id: SourceItem,
    source: EntityRef,
}
impl IRepresentationItem for ExternallyDefinedString {
    fn name(&self) -> &Label {
        &self.name
    }
}
impl IExternallyDefinedItem for ExternallyDefinedString {
    fn item_id(&self) -> &SourceItem {
        &self.item_id
    }
    fn source(&self) -> &EntityRef {
        &self.source
    }
}
impl IExternallyDefinedRepresentationItem for ExternallyDefinedString {}
impl IExternallyDefinedString for ExternallyDefinedString {}
impl ExternallyDefinedString {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = ExternallyDefinedString::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => entity.item_id = parameter.into(),
                2usize => entity.source = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IExternallyDefinedSymbol: IExternallyDefinedItem {}
#[derive(Default, Debug)]
pub struct ExternallyDefinedSymbol {
    item_id: SourceItem,
    source: EntityRef,
}
impl IExternallyDefinedItem for ExternallyDefinedSymbol {
    fn item_id(&self) -> &SourceItem {
        &self.item_id
    }
    fn source(&self) -> &EntityRef {
        &self.source
    }
}
impl IExternallyDefinedSymbol for ExternallyDefinedSymbol {}
impl ExternallyDefinedSymbol {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = ExternallyDefinedSymbol::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.item_id = parameter.into(),
                1usize => entity.source = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IExternallyDefinedTerminatorSymbol: IExternallyDefinedSymbol {}
#[derive(Default, Debug)]
pub struct ExternallyDefinedTerminatorSymbol {
    item_id: SourceItem,
    source: EntityRef,
}
impl IExternallyDefinedItem for ExternallyDefinedTerminatorSymbol {
    fn item_id(&self) -> &SourceItem {
        &self.item_id
    }
    fn source(&self) -> &EntityRef {
        &self.source
    }
}
impl IExternallyDefinedSymbol for ExternallyDefinedTerminatorSymbol {}
impl IExternallyDefinedTerminatorSymbol for ExternallyDefinedTerminatorSymbol {}
impl ExternallyDefinedTerminatorSymbol {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = ExternallyDefinedTerminatorSymbol::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.item_id = parameter.into(),
                1usize => entity.source = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IExternallyDefinedTextFont: IExternallyDefinedItem {}
#[derive(Default, Debug)]
pub struct ExternallyDefinedTextFont {
    item_id: SourceItem,
    source: EntityRef,
}
impl IExternallyDefinedItem for ExternallyDefinedTextFont {
    fn item_id(&self) -> &SourceItem {
        &self.item_id
    }
    fn source(&self) -> &EntityRef {
        &self.source
    }
}
impl IExternallyDefinedTextFont for ExternallyDefinedTextFont {}
impl ExternallyDefinedTextFont {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = ExternallyDefinedTextFont::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.item_id = parameter.into(),
                1usize => entity.source = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IExternallyDefinedTile: IExternallyDefinedItem {}
#[derive(Default, Debug)]
pub struct ExternallyDefinedTile {
    item_id: SourceItem,
    source: EntityRef,
}
impl IExternallyDefinedItem for ExternallyDefinedTile {
    fn item_id(&self) -> &SourceItem {
        &self.item_id
    }
    fn source(&self) -> &EntityRef {
        &self.source
    }
}
impl IExternallyDefinedTile for ExternallyDefinedTile {}
impl ExternallyDefinedTile {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = ExternallyDefinedTile::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.item_id = parameter.into(),
                1usize => entity.source = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IExternallyDefinedTileStyle: IExternallyDefinedItem + IGeometricRepresentationItem {}
#[derive(Default, Debug)]
pub struct ExternallyDefinedTileStyle {
    item_id: SourceItem,
    source: EntityRef,
    name: Label,
}
impl IExternallyDefinedItem for ExternallyDefinedTileStyle {
    fn item_id(&self) -> &SourceItem {
        &self.item_id
    }
    fn source(&self) -> &EntityRef {
        &self.source
    }
}
impl IRepresentationItem for ExternallyDefinedTileStyle {
    fn name(&self) -> &Label {
        &self.name
    }
}
impl IGeometricRepresentationItem for ExternallyDefinedTileStyle {}
impl IExternallyDefinedTileStyle for ExternallyDefinedTileStyle {}
impl ExternallyDefinedTileStyle {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = ExternallyDefinedTileStyle::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.item_id = parameter.into(),
                1usize => entity.source = parameter.into(),
                2usize => entity.name = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IExtrudedAreaSolid: ISweptAreaSolid {
    fn extruded_direction(&self) -> &EntityRef;
    fn depth(&self) -> &PositiveLengthMeasure;
}
#[derive(Default, Debug)]
pub struct ExtrudedAreaSolid {
    name: Label,
    swept_area: EntityRef,
    extruded_direction: EntityRef,
    depth: PositiveLengthMeasure,
}
impl IRepresentationItem for ExtrudedAreaSolid {
    fn name(&self) -> &Label {
        &self.name
    }
}
impl IGeometricRepresentationItem for ExtrudedAreaSolid {}
impl ISolidModel for ExtrudedAreaSolid {}
impl ISweptAreaSolid for ExtrudedAreaSolid {
    fn swept_area(&self) -> &EntityRef {
        &self.swept_area
    }
}
impl IExtrudedAreaSolid for ExtrudedAreaSolid {
    fn extruded_direction(&self) -> &EntityRef {
        &self.extruded_direction
    }
    fn depth(&self) -> &PositiveLengthMeasure {
        &self.depth
    }
}
impl ExtrudedAreaSolid {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = ExtrudedAreaSolid::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => entity.swept_area = parameter.into(),
                2usize => entity.extruded_direction = parameter.into(),
                3usize => entity.depth = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IExtrudedFaceSolid: ISweptFaceSolid {
    fn extruded_direction(&self) -> &EntityRef;
    fn depth(&self) -> &PositiveLengthMeasure;
}
#[derive(Default, Debug)]
pub struct ExtrudedFaceSolid {
    name: Label,
    swept_face: EntityRef,
    extruded_direction: EntityRef,
    depth: PositiveLengthMeasure,
}
impl IRepresentationItem for ExtrudedFaceSolid {
    fn name(&self) -> &Label {
        &self.name
    }
}
impl IGeometricRepresentationItem for ExtrudedFaceSolid {}
impl ISolidModel for ExtrudedFaceSolid {}
impl ISweptFaceSolid for ExtrudedFaceSolid {
    fn swept_face(&self) -> &EntityRef {
        &self.swept_face
    }
}
impl IExtrudedFaceSolid for ExtrudedFaceSolid {
    fn extruded_direction(&self) -> &EntityRef {
        &self.extruded_direction
    }
    fn depth(&self) -> &PositiveLengthMeasure {
        &self.depth
    }
}
impl ExtrudedFaceSolid {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = ExtrudedFaceSolid::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => entity.swept_face = parameter.into(),
                2usize => entity.extruded_direction = parameter.into(),
                3usize => entity.depth = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IExtrudedFaceSolidWithDraftAngle: IExtrudedFaceSolidWithTrimConditions {
    fn draft_angle(&self) -> &PlaneAngleMeasure;
}
#[derive(Default, Debug)]
pub struct ExtrudedFaceSolidWithDraftAngle {
    name: Label,
    swept_face: EntityRef,
    extruded_direction: EntityRef,
    depth: PositiveLengthMeasure,
    first_trim_condition: TrimConditionSelect,
    second_trim_condition: TrimConditionSelect,
    first_trim_intent: TrimIntent,
    second_trim_intent: TrimIntent,
    first_offset: NonNegativeLengthMeasure,
    second_offset: NonNegativeLengthMeasure,
    draft_angle: PlaneAngleMeasure,
}
impl IRepresentationItem for ExtrudedFaceSolidWithDraftAngle {
    fn name(&self) -> &Label {
        &self.name
    }
}
impl IGeometricRepresentationItem for ExtrudedFaceSolidWithDraftAngle {}
impl ISolidModel for ExtrudedFaceSolidWithDraftAngle {}
impl ISweptFaceSolid for ExtrudedFaceSolidWithDraftAngle {
    fn swept_face(&self) -> &EntityRef {
        &self.swept_face
    }
}
impl IExtrudedFaceSolid for ExtrudedFaceSolidWithDraftAngle {
    fn extruded_direction(&self) -> &EntityRef {
        &self.extruded_direction
    }
    fn depth(&self) -> &PositiveLengthMeasure {
        &self.depth
    }
}
impl IExtrudedFaceSolidWithTrimConditions for ExtrudedFaceSolidWithDraftAngle {
    fn first_trim_condition(&self) -> &TrimConditionSelect {
        &self.first_trim_condition
    }
    fn second_trim_condition(&self) -> &TrimConditionSelect {
        &self.second_trim_condition
    }
    fn first_trim_intent(&self) -> &TrimIntent {
        &self.first_trim_intent
    }
    fn second_trim_intent(&self) -> &TrimIntent {
        &self.second_trim_intent
    }
    fn first_offset(&self) -> &NonNegativeLengthMeasure {
        &self.first_offset
    }
    fn second_offset(&self) -> &NonNegativeLengthMeasure {
        &self.second_offset
    }
}
impl IExtrudedFaceSolidWithDraftAngle for ExtrudedFaceSolidWithDraftAngle {
    fn draft_angle(&self) -> &PlaneAngleMeasure {
        &self.draft_angle
    }
}
impl ExtrudedFaceSolidWithDraftAngle {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = ExtrudedFaceSolidWithDraftAngle::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => entity.swept_face = parameter.into(),
                2usize => entity.extruded_direction = parameter.into(),
                3usize => entity.depth = parameter.into(),
                4usize => entity.first_trim_condition = parameter.into(),
                5usize => entity.second_trim_condition = parameter.into(),
                6usize => entity.first_trim_intent = parameter.into(),
                7usize => entity.second_trim_intent = parameter.into(),
                8usize => entity.first_offset = parameter.into(),
                9usize => entity.second_offset = parameter.into(),
                10usize => entity.draft_angle = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IExtrudedFaceSolidWithMultipleDraftAngles: IExtrudedFaceSolidWithTrimConditions {
    fn drafted_edges(&self) -> &Vec<HashSet<EntityRef>>;
    fn draft_angles(&self) -> &Vec<PlaneAngleMeasure>;
}
#[derive(Default, Debug)]
pub struct ExtrudedFaceSolidWithMultipleDraftAngles {
    name: Label,
    swept_face: EntityRef,
    extruded_direction: EntityRef,
    depth: PositiveLengthMeasure,
    first_trim_condition: TrimConditionSelect,
    second_trim_condition: TrimConditionSelect,
    first_trim_intent: TrimIntent,
    second_trim_intent: TrimIntent,
    first_offset: NonNegativeLengthMeasure,
    second_offset: NonNegativeLengthMeasure,
    drafted_edges: Vec<HashSet<EntityRef>>,
    draft_angles: Vec<PlaneAngleMeasure>,
}
impl IRepresentationItem for ExtrudedFaceSolidWithMultipleDraftAngles {
    fn name(&self) -> &Label {
        &self.name
    }
}
impl IGeometricRepresentationItem for ExtrudedFaceSolidWithMultipleDraftAngles {}
impl ISolidModel for ExtrudedFaceSolidWithMultipleDraftAngles {}
impl ISweptFaceSolid for ExtrudedFaceSolidWithMultipleDraftAngles {
    fn swept_face(&self) -> &EntityRef {
        &self.swept_face
    }
}
impl IExtrudedFaceSolid for ExtrudedFaceSolidWithMultipleDraftAngles {
    fn extruded_direction(&self) -> &EntityRef {
        &self.extruded_direction
    }
    fn depth(&self) -> &PositiveLengthMeasure {
        &self.depth
    }
}
impl IExtrudedFaceSolidWithTrimConditions for ExtrudedFaceSolidWithMultipleDraftAngles {
    fn first_trim_condition(&self) -> &TrimConditionSelect {
        &self.first_trim_condition
    }
    fn second_trim_condition(&self) -> &TrimConditionSelect {
        &self.second_trim_condition
    }
    fn first_trim_intent(&self) -> &TrimIntent {
        &self.first_trim_intent
    }
    fn second_trim_intent(&self) -> &TrimIntent {
        &self.second_trim_intent
    }
    fn first_offset(&self) -> &NonNegativeLengthMeasure {
        &self.first_offset
    }
    fn second_offset(&self) -> &NonNegativeLengthMeasure {
        &self.second_offset
    }
}
impl IExtrudedFaceSolidWithMultipleDraftAngles for ExtrudedFaceSolidWithMultipleDraftAngles {
    fn drafted_edges(&self) -> &Vec<HashSet<EntityRef>> {
        &self.drafted_edges
    }
    fn draft_angles(&self) -> &Vec<PlaneAngleMeasure> {
        &self.draft_angles
    }
}
impl ExtrudedFaceSolidWithMultipleDraftAngles {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = ExtrudedFaceSolidWithMultipleDraftAngles::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => entity.swept_face = parameter.into(),
                2usize => entity.extruded_direction = parameter.into(),
                3usize => entity.depth = parameter.into(),
                4usize => entity.first_trim_condition = parameter.into(),
                5usize => entity.second_trim_condition = parameter.into(),
                6usize => entity.first_trim_intent = parameter.into(),
                7usize => entity.second_trim_intent = parameter.into(),
                8usize => entity.first_offset = parameter.into(),
                9usize => entity.second_offset = parameter.into(),
                10usize => entity.drafted_edges = parameter.into(),
                11usize => entity.draft_angles = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IExtrudedFaceSolidWithTrimConditions: IExtrudedFaceSolid {
    fn first_trim_condition(&self) -> &TrimConditionSelect;
    fn second_trim_condition(&self) -> &TrimConditionSelect;
    fn first_trim_intent(&self) -> &TrimIntent;
    fn second_trim_intent(&self) -> &TrimIntent;
    fn first_offset(&self) -> &NonNegativeLengthMeasure;
    fn second_offset(&self) -> &NonNegativeLengthMeasure;
}
#[derive(Default, Debug)]
pub struct ExtrudedFaceSolidWithTrimConditions {
    name: Label,
    swept_face: EntityRef,
    extruded_direction: EntityRef,
    depth: PositiveLengthMeasure,
    first_trim_condition: TrimConditionSelect,
    second_trim_condition: TrimConditionSelect,
    first_trim_intent: TrimIntent,
    second_trim_intent: TrimIntent,
    first_offset: NonNegativeLengthMeasure,
    second_offset: NonNegativeLengthMeasure,
}
impl IRepresentationItem for ExtrudedFaceSolidWithTrimConditions {
    fn name(&self) -> &Label {
        &self.name
    }
}
impl IGeometricRepresentationItem for ExtrudedFaceSolidWithTrimConditions {}
impl ISolidModel for ExtrudedFaceSolidWithTrimConditions {}
impl ISweptFaceSolid for ExtrudedFaceSolidWithTrimConditions {
    fn swept_face(&self) -> &EntityRef {
        &self.swept_face
    }
}
impl IExtrudedFaceSolid for ExtrudedFaceSolidWithTrimConditions {
    fn extruded_direction(&self) -> &EntityRef {
        &self.extruded_direction
    }
    fn depth(&self) -> &PositiveLengthMeasure {
        &self.depth
    }
}
impl IExtrudedFaceSolidWithTrimConditions for ExtrudedFaceSolidWithTrimConditions {
    fn first_trim_condition(&self) -> &TrimConditionSelect {
        &self.first_trim_condition
    }
    fn second_trim_condition(&self) -> &TrimConditionSelect {
        &self.second_trim_condition
    }
    fn first_trim_intent(&self) -> &TrimIntent {
        &self.first_trim_intent
    }
    fn second_trim_intent(&self) -> &TrimIntent {
        &self.second_trim_intent
    }
    fn first_offset(&self) -> &NonNegativeLengthMeasure {
        &self.first_offset
    }
    fn second_offset(&self) -> &NonNegativeLengthMeasure {
        &self.second_offset
    }
}
impl ExtrudedFaceSolidWithTrimConditions {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = ExtrudedFaceSolidWithTrimConditions::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => entity.swept_face = parameter.into(),
                2usize => entity.extruded_direction = parameter.into(),
                3usize => entity.depth = parameter.into(),
                4usize => entity.first_trim_condition = parameter.into(),
                5usize => entity.second_trim_condition = parameter.into(),
                6usize => entity.first_trim_intent = parameter.into(),
                7usize => entity.second_trim_intent = parameter.into(),
                8usize => entity.first_offset = parameter.into(),
                9usize => entity.second_offset = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IFace: ITopologicalRepresentationItem {
    fn bounds(&self) -> &HashSet<EntityRef>;
}
#[derive(Default, Debug)]
pub struct Face {
    name: Label,
    bounds: HashSet<EntityRef>,
}
impl IRepresentationItem for Face {
    fn name(&self) -> &Label {
        &self.name
    }
}
impl ITopologicalRepresentationItem for Face {}
impl IFace for Face {
    fn bounds(&self) -> &HashSet<EntityRef> {
        &self.bounds
    }
}
impl Face {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = Face::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => entity.bounds = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IFaceBasedSurfaceModel: IGeometricRepresentationItem {
    fn fbsm_faces(&self) -> &HashSet<EntityRef>;
}
#[derive(Default, Debug)]
pub struct FaceBasedSurfaceModel {
    name: Label,
    fbsm_faces: HashSet<EntityRef>,
}
impl IRepresentationItem for FaceBasedSurfaceModel {
    fn name(&self) -> &Label {
        &self.name
    }
}
impl IGeometricRepresentationItem for FaceBasedSurfaceModel {}
impl IFaceBasedSurfaceModel for FaceBasedSurfaceModel {
    fn fbsm_faces(&self) -> &HashSet<EntityRef> {
        &self.fbsm_faces
    }
}
impl FaceBasedSurfaceModel {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = FaceBasedSurfaceModel::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => entity.fbsm_faces = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IFaceBound: ITopologicalRepresentationItem {
    fn bound(&self) -> &EntityRef;
    fn orientation(&self) -> bool;
}
#[derive(Default, Debug)]
pub struct FaceBound {
    name: Label,
    bound: EntityRef,
    orientation: bool,
}
impl IRepresentationItem for FaceBound {
    fn name(&self) -> &Label {
        &self.name
    }
}
impl ITopologicalRepresentationItem for FaceBound {}
impl IFaceBound for FaceBound {
    fn bound(&self) -> &EntityRef {
        &self.bound
    }
    fn orientation(&self) -> bool {
        self.orientation
    }
}
impl FaceBound {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = FaceBound::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => entity.bound = parameter.into(),
                2usize => entity.orientation = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IFaceOuterBound: IFaceBound {}
#[derive(Default, Debug)]
pub struct FaceOuterBound {
    name: Label,
    bound: EntityRef,
    orientation: bool,
}
impl IRepresentationItem for FaceOuterBound {
    fn name(&self) -> &Label {
        &self.name
    }
}
impl ITopologicalRepresentationItem for FaceOuterBound {}
impl IFaceBound for FaceOuterBound {
    fn bound(&self) -> &EntityRef {
        &self.bound
    }
    fn orientation(&self) -> bool {
        self.orientation
    }
}
impl IFaceOuterBound for FaceOuterBound {}
impl FaceOuterBound {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = FaceOuterBound::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => entity.bound = parameter.into(),
                2usize => entity.orientation = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IFaceSurface: IFace + IGeometricRepresentationItem {
    fn face_geometry(&self) -> &EntityRef;
    fn same_sense(&self) -> bool;
}
#[derive(Default, Debug)]
pub struct FaceSurface {
    name: Label,
    bounds: HashSet<EntityRef>,
    face_geometry: EntityRef,
    same_sense: bool,
}
impl IRepresentationItem for FaceSurface {
    fn name(&self) -> &Label {
        &self.name
    }
}
impl ITopologicalRepresentationItem for FaceSurface {}
impl IFace for FaceSurface {
    fn bounds(&self) -> &HashSet<EntityRef> {
        &self.bounds
    }
}
impl IFaceSurface for FaceSurface {
    fn face_geometry(&self) -> &EntityRef {
        &self.face_geometry
    }
    fn same_sense(&self) -> bool {
        self.same_sense
    }
}
impl IGeometricRepresentationItem for FaceSurface {}
impl FaceSurface {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = FaceSurface::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => entity.bounds = parameter.into(),
                2usize => entity.face_geometry = parameter.into(),
                3usize => entity.same_sense = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IFacetedBrep: IManifoldSolidBrep {}
#[derive(Default, Debug)]
pub struct FacetedBrep {
    name: Label,
    outer: EntityRef,
}
impl IRepresentationItem for FacetedBrep {
    fn name(&self) -> &Label {
        &self.name
    }
}
impl IGeometricRepresentationItem for FacetedBrep {}
impl ISolidModel for FacetedBrep {}
impl IManifoldSolidBrep for FacetedBrep {
    fn outer(&self) -> &EntityRef {
        &self.outer
    }
}
impl IFacetedBrep for FacetedBrep {}
impl FacetedBrep {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = FacetedBrep::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => entity.outer = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IFacetedBrepShapeRepresentation: IShapeRepresentation {}
#[derive(Default, Debug)]
pub struct FacetedBrepShapeRepresentation {
    name: Label,
    items: HashSet<EntityRef>,
    context_of_items: EntityRef,
}
impl IRepresentation for FacetedBrepShapeRepresentation {
    fn name(&self) -> &Label {
        &self.name
    }
    fn items(&self) -> &HashSet<EntityRef> {
        &self.items
    }
    fn context_of_items(&self) -> &EntityRef {
        &self.context_of_items
    }
}
impl IShapeRepresentation for FacetedBrepShapeRepresentation {}
impl IFacetedBrepShapeRepresentation for FacetedBrepShapeRepresentation {}
impl FacetedBrepShapeRepresentation {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = FacetedBrepShapeRepresentation::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => entity.items = parameter.into(),
                2usize => entity.context_of_items = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IFactType: IPropertyDefinition {}
#[derive(Default, Debug)]
pub struct FactType {
    name: Label,
    description: Option<Text>,
    definition: EntityRef,
}
impl IPropertyDefinition for FactType {
    fn name(&self) -> &Label {
        &self.name
    }
    fn description(&self) -> &Option<Text> {
        &self.description
    }
    fn definition(&self) -> &EntityRef {
        &self.definition
    }
}
impl IFactType for FactType {}
impl FactType {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = FactType::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => entity.definition = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IFillAreaStyle: IFoundedItem {
    fn name(&self) -> &Label;
    fn fill_styles(&self) -> &HashSet<EntityRef>;
}
#[derive(Default, Debug)]
pub struct FillAreaStyle {
    name: Label,
    fill_styles: HashSet<EntityRef>,
}
impl IFoundedItem for FillAreaStyle {}
impl IFillAreaStyle for FillAreaStyle {
    fn name(&self) -> &Label {
        &self.name
    }
    fn fill_styles(&self) -> &HashSet<EntityRef> {
        &self.fill_styles
    }
}
impl FillAreaStyle {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = FillAreaStyle::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => entity.fill_styles = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IFillAreaStyleColour {
    fn name(&self) -> &Label;
    fn fill_colour(&self) -> &EntityRef;
}
#[derive(Default, Debug)]
pub struct FillAreaStyleColour {
    name: Label,
    fill_colour: EntityRef,
}
impl IFillAreaStyleColour for FillAreaStyleColour {
    fn name(&self) -> &Label {
        &self.name
    }
    fn fill_colour(&self) -> &EntityRef {
        &self.fill_colour
    }
}
impl FillAreaStyleColour {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = FillAreaStyleColour::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => entity.fill_colour = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IFillAreaStyleHatching: IGeometricRepresentationItem {
    fn hatch_line_appearance(&self) -> &EntityRef;
    fn start_of_next_hatch_line(&self) -> &EntityRef;
    fn point_of_reference_hatch_line(&self) -> &EntityRef;
    fn pattern_start(&self) -> &EntityRef;
    fn hatch_line_angle(&self) -> &PlaneAngleMeasure;
}
#[derive(Default, Debug)]
pub struct FillAreaStyleHatching {
    name: Label,
    hatch_line_appearance: EntityRef,
    start_of_next_hatch_line: EntityRef,
    point_of_reference_hatch_line: EntityRef,
    pattern_start: EntityRef,
    hatch_line_angle: PlaneAngleMeasure,
}
impl IRepresentationItem for FillAreaStyleHatching {
    fn name(&self) -> &Label {
        &self.name
    }
}
impl IGeometricRepresentationItem for FillAreaStyleHatching {}
impl IFillAreaStyleHatching for FillAreaStyleHatching {
    fn hatch_line_appearance(&self) -> &EntityRef {
        &self.hatch_line_appearance
    }
    fn start_of_next_hatch_line(&self) -> &EntityRef {
        &self.start_of_next_hatch_line
    }
    fn point_of_reference_hatch_line(&self) -> &EntityRef {
        &self.point_of_reference_hatch_line
    }
    fn pattern_start(&self) -> &EntityRef {
        &self.pattern_start
    }
    fn hatch_line_angle(&self) -> &PlaneAngleMeasure {
        &self.hatch_line_angle
    }
}
impl FillAreaStyleHatching {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = FillAreaStyleHatching::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => entity.hatch_line_appearance = parameter.into(),
                2usize => entity.start_of_next_hatch_line = parameter.into(),
                3usize => entity.point_of_reference_hatch_line = parameter.into(),
                4usize => entity.pattern_start = parameter.into(),
                5usize => entity.hatch_line_angle = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IFillAreaStyleTileColouredRegion: IGeometricRepresentationItem {
    fn closed_curve(&self) -> &EntityRef;
    fn region_colour(&self) -> &EntityRef;
}
#[derive(Default, Debug)]
pub struct FillAreaStyleTileColouredRegion {
    name: Label,
    closed_curve: EntityRef,
    region_colour: EntityRef,
}
impl IRepresentationItem for FillAreaStyleTileColouredRegion {
    fn name(&self) -> &Label {
        &self.name
    }
}
impl IGeometricRepresentationItem for FillAreaStyleTileColouredRegion {}
impl IFillAreaStyleTileColouredRegion for FillAreaStyleTileColouredRegion {
    fn closed_curve(&self) -> &EntityRef {
        &self.closed_curve
    }
    fn region_colour(&self) -> &EntityRef {
        &self.region_colour
    }
}
impl FillAreaStyleTileColouredRegion {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = FillAreaStyleTileColouredRegion::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => entity.closed_curve = parameter.into(),
                2usize => entity.region_colour = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IFillAreaStyleTileCurveWithStyle: IGeometricRepresentationItem {
    fn styled_curve(&self) -> &EntityRef;
}
#[derive(Default, Debug)]
pub struct FillAreaStyleTileCurveWithStyle {
    name: Label,
    styled_curve: EntityRef,
}
impl IRepresentationItem for FillAreaStyleTileCurveWithStyle {
    fn name(&self) -> &Label {
        &self.name
    }
}
impl IGeometricRepresentationItem for FillAreaStyleTileCurveWithStyle {}
impl IFillAreaStyleTileCurveWithStyle for FillAreaStyleTileCurveWithStyle {
    fn styled_curve(&self) -> &EntityRef {
        &self.styled_curve
    }
}
impl FillAreaStyleTileCurveWithStyle {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = FillAreaStyleTileCurveWithStyle::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => entity.styled_curve = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IFillAreaStyleTileSymbolWithStyle: IGeometricRepresentationItem {
    fn symbol(&self) -> &EntityRef;
}
#[derive(Default, Debug)]
pub struct FillAreaStyleTileSymbolWithStyle {
    name: Label,
    symbol: EntityRef,
}
impl IRepresentationItem for FillAreaStyleTileSymbolWithStyle {
    fn name(&self) -> &Label {
        &self.name
    }
}
impl IGeometricRepresentationItem for FillAreaStyleTileSymbolWithStyle {}
impl IFillAreaStyleTileSymbolWithStyle for FillAreaStyleTileSymbolWithStyle {
    fn symbol(&self) -> &EntityRef {
        &self.symbol
    }
}
impl FillAreaStyleTileSymbolWithStyle {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = FillAreaStyleTileSymbolWithStyle::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => entity.symbol = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IFillAreaStyleTiles: IGeometricRepresentationItem {
    fn tiling_pattern(&self) -> &EntityRef;
    fn tiles(&self) -> &HashSet<EntityRef>;
    fn tiling_scale(&self) -> &PositiveRatioMeasure;
}
#[derive(Default, Debug)]
pub struct FillAreaStyleTiles {
    name: Label,
    tiling_pattern: EntityRef,
    tiles: HashSet<EntityRef>,
    tiling_scale: PositiveRatioMeasure,
}
impl IRepresentationItem for FillAreaStyleTiles {
    fn name(&self) -> &Label {
        &self.name
    }
}
impl IGeometricRepresentationItem for FillAreaStyleTiles {}
impl IFillAreaStyleTiles for FillAreaStyleTiles {
    fn tiling_pattern(&self) -> &EntityRef {
        &self.tiling_pattern
    }
    fn tiles(&self) -> &HashSet<EntityRef> {
        &self.tiles
    }
    fn tiling_scale(&self) -> &PositiveRatioMeasure {
        &self.tiling_scale
    }
}
impl FillAreaStyleTiles {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = FillAreaStyleTiles::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => entity.tiling_pattern = parameter.into(),
                2usize => entity.tiles = parameter.into(),
                3usize => entity.tiling_scale = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IFlatPatternPlyRepresentationRelationship: IShapeRepresentationRelationship {}
#[derive(Default, Debug)]
pub struct FlatPatternPlyRepresentationRelationship {
    name: Label,
    description: Option<Text>,
    rep_1: EntityRef,
    rep_2: EntityRef,
}
impl IRepresentationRelationship for FlatPatternPlyRepresentationRelationship {
    fn name(&self) -> &Label {
        &self.name
    }
    fn description(&self) -> &Option<Text> {
        &self.description
    }
    fn rep_1(&self) -> &EntityRef {
        &self.rep_1
    }
    fn rep_2(&self) -> &EntityRef {
        &self.rep_2
    }
}
impl IShapeRepresentationRelationship for FlatPatternPlyRepresentationRelationship {}
impl IFlatPatternPlyRepresentationRelationship for FlatPatternPlyRepresentationRelationship {}
impl FlatPatternPlyRepresentationRelationship {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = FlatPatternPlyRepresentationRelationship::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => entity.rep_1 = parameter.into(),
                3usize => entity.rep_2 = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IFlatnessTolerance: IGeometricTolerance {}
#[derive(Default, Debug)]
pub struct FlatnessTolerance {
    name: Label,
    description: Text,
    magnitude: EntityRef,
    toleranced_shape_aspect: EntityRef,
}
impl IGeometricTolerance for FlatnessTolerance {
    fn name(&self) -> &Label {
        &self.name
    }
    fn description(&self) -> &Text {
        &self.description
    }
    fn magnitude(&self) -> &EntityRef {
        &self.magnitude
    }
    fn toleranced_shape_aspect(&self) -> &EntityRef {
        &self.toleranced_shape_aspect
    }
}
impl IFlatnessTolerance for FlatnessTolerance {}
impl FlatnessTolerance {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = FlatnessTolerance::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => entity.description = parameter.into(),
                2usize => entity.magnitude = parameter.into(),
                3usize => entity.toleranced_shape_aspect = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IForceMeasureWithUnit: IMeasureWithUnit {}
#[derive(Default, Debug)]
pub struct ForceMeasureWithUnit {
    value_component: MeasureValue,
    unit_component: EntityRef,
}
impl IMeasureWithUnit for ForceMeasureWithUnit {
    fn value_component(&self) -> &MeasureValue {
        &self.value_component
    }
    fn unit_component(&self) -> &EntityRef {
        &self.unit_component
    }
}
impl IForceMeasureWithUnit for ForceMeasureWithUnit {}
impl ForceMeasureWithUnit {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = ForceMeasureWithUnit::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.value_component = parameter.into(),
                1usize => entity.unit_component = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IForceUnit: IDerivedUnit {}
#[derive(Default, Debug)]
pub struct ForceUnit {
    elements: HashSet<EntityRef>,
}
impl IDerivedUnit for ForceUnit {
    fn elements(&self) -> &HashSet<EntityRef> {
        &self.elements
    }
}
impl IForceUnit for ForceUnit {}
impl ForceUnit {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = ForceUnit::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.elements = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IForwardChainingRule: IRuleDefinition {}
#[derive(Default, Debug)]
pub struct ForwardChainingRule {
    id: Identifier,
    description: Option<Text>,
    formation: EntityRef,
    frame_of_reference: EntityRef,
}
impl IProductDefinition for ForwardChainingRule {
    fn id(&self) -> &Identifier {
        &self.id
    }
    fn description(&self) -> &Option<Text> {
        &self.description
    }
    fn formation(&self) -> &EntityRef {
        &self.formation
    }
    fn frame_of_reference(&self) -> &EntityRef {
        &self.frame_of_reference
    }
}
impl IRuleSoftwareDefinition for ForwardChainingRule {}
impl IRuleDefinition for ForwardChainingRule {}
impl IForwardChainingRule for ForwardChainingRule {}
impl ForwardChainingRule {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = ForwardChainingRule::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.id = parameter.into(),
                1usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => entity.formation = parameter.into(),
                3usize => entity.frame_of_reference = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IForwardChainingRulePremise:
    IPropertyDefinition + IPropertyDefinitionRepresentation + IRepresentation
{
}
#[derive(Default, Debug)]
pub struct ForwardChainingRulePremise {
    name: Label,
    description: Option<Text>,
    definition: EntityRef,
    used_representation: EntityRef,
    items: HashSet<EntityRef>,
    context_of_items: EntityRef,
}
impl IPropertyDefinition for ForwardChainingRulePremise {
    fn name(&self) -> &Label {
        &self.name
    }
    fn description(&self) -> &Option<Text> {
        &self.description
    }
    fn definition(&self) -> &EntityRef {
        &self.definition
    }
}
impl IPropertyDefinitionRepresentation for ForwardChainingRulePremise {
    fn definition(&self) -> &EntityRef {
        &self.definition
    }
    fn used_representation(&self) -> &EntityRef {
        &self.used_representation
    }
}
impl IRepresentation for ForwardChainingRulePremise {
    fn name(&self) -> &Label {
        &self.name
    }
    fn items(&self) -> &HashSet<EntityRef> {
        &self.items
    }
    fn context_of_items(&self) -> &EntityRef {
        &self.context_of_items
    }
}
impl IForwardChainingRulePremise for ForwardChainingRulePremise {}
impl ForwardChainingRulePremise {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = ForwardChainingRulePremise::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => entity.definition = parameter.into(),
                3usize => entity.used_representation = parameter.into(),
                4usize => entity.items = parameter.into(),
                5usize => entity.context_of_items = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IFoundedItem {}
#[derive(Default, Debug)]
pub struct FoundedItem {}
impl IFoundedItem for FoundedItem {}
impl FoundedItem {
    pub fn form_parameters(_parameters: Vec<Parameter>) -> Self {
        FoundedItem::default()
    }
}
pub trait IFrequencyMeasureWithUnit: IMeasureWithUnit {}
#[derive(Default, Debug)]
pub struct FrequencyMeasureWithUnit {
    value_component: MeasureValue,
    unit_component: EntityRef,
}
impl IMeasureWithUnit for FrequencyMeasureWithUnit {
    fn value_component(&self) -> &MeasureValue {
        &self.value_component
    }
    fn unit_component(&self) -> &EntityRef {
        &self.unit_component
    }
}
impl IFrequencyMeasureWithUnit for FrequencyMeasureWithUnit {}
impl FrequencyMeasureWithUnit {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = FrequencyMeasureWithUnit::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.value_component = parameter.into(),
                1usize => entity.unit_component = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IFrequencyUnit: IDerivedUnit {}
#[derive(Default, Debug)]
pub struct FrequencyUnit {
    elements: HashSet<EntityRef>,
}
impl IDerivedUnit for FrequencyUnit {
    fn elements(&self) -> &HashSet<EntityRef> {
        &self.elements
    }
}
impl IFrequencyUnit for FrequencyUnit {}
impl FrequencyUnit {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = FrequencyUnit::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.elements = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IFunc: ICompoundRepresentationItem {}
#[derive(Default, Debug)]
pub struct Func {
    name: Label,
    item_element: CompoundItemDefinition,
}
impl IRepresentationItem for Func {
    fn name(&self) -> &Label {
        &self.name
    }
}
impl ICompoundRepresentationItem for Func {
    fn item_element(&self) -> &CompoundItemDefinition {
        &self.item_element
    }
}
impl IFunc for Func {}
impl Func {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = Func::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => entity.item_element = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IFunctionalBreakdownContext: IBreakdownContext {}
#[derive(Default, Debug)]
pub struct FunctionalBreakdownContext {
    id: Identifier,
    name: Label,
    description: Option<Text>,
    relating_product_definition: EntityRef,
    related_product_definition: EntityRef,
}
impl IProductDefinitionRelationship for FunctionalBreakdownContext {
    fn id(&self) -> &Identifier {
        &self.id
    }
    fn name(&self) -> &Label {
        &self.name
    }
    fn description(&self) -> &Option<Text> {
        &self.description
    }
    fn relating_product_definition(&self) -> &EntityRef {
        &self.relating_product_definition
    }
    fn related_product_definition(&self) -> &EntityRef {
        &self.related_product_definition
    }
}
impl IBreakdownContext for FunctionalBreakdownContext {}
impl IFunctionalBreakdownContext for FunctionalBreakdownContext {}
impl FunctionalBreakdownContext {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = FunctionalBreakdownContext::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.id = parameter.into(),
                1usize => entity.name = parameter.into(),
                2usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => entity.relating_product_definition = parameter.into(),
                4usize => entity.related_product_definition = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IFunctionalElementUsage: IBreakdownElementUsage {}
#[derive(Default, Debug)]
pub struct FunctionalElementUsage {
    id: Identifier,
    name: Label,
    description: Option<Text>,
    relating_product_definition: EntityRef,
    related_product_definition: EntityRef,
}
impl IProductDefinitionRelationship for FunctionalElementUsage {
    fn id(&self) -> &Identifier {
        &self.id
    }
    fn name(&self) -> &Label {
        &self.name
    }
    fn description(&self) -> &Option<Text> {
        &self.description
    }
    fn relating_product_definition(&self) -> &EntityRef {
        &self.relating_product_definition
    }
    fn related_product_definition(&self) -> &EntityRef {
        &self.related_product_definition
    }
}
impl IBreakdownElementUsage for FunctionalElementUsage {}
impl IFunctionalElementUsage for FunctionalElementUsage {}
impl FunctionalElementUsage {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = FunctionalElementUsage::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.id = parameter.into(),
                1usize => entity.name = parameter.into(),
                2usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => entity.relating_product_definition = parameter.into(),
                4usize => entity.related_product_definition = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IFunctionallyDefinedTransformation {
    fn name(&self) -> &Label;
    fn description(&self) -> &Option<Text>;
}
#[derive(Default, Debug)]
pub struct FunctionallyDefinedTransformation {
    name: Label,
    description: Option<Text>,
}
impl IFunctionallyDefinedTransformation for FunctionallyDefinedTransformation {
    fn name(&self) -> &Label {
        &self.name
    }
    fn description(&self) -> &Option<Text> {
        &self.description
    }
}
impl FunctionallyDefinedTransformation {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = FunctionallyDefinedTransformation::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
}
pub trait IGeneralMaterialProperty: IGeneralProperty {}
#[derive(Default, Debug)]
pub struct GeneralMaterialProperty {
    id: Identifier,
    name: Label,
    description: Option<Text>,
}
impl IGeneralProperty for GeneralMaterialProperty {
    fn id(&self) -> &Identifier {
        &self.id
    }
    fn name(&self) -> &Label {
        &self.name
    }
    fn description(&self) -> &Option<Text> {
        &self.description
    }
}
impl IGeneralMaterialProperty for GeneralMaterialProperty {}
impl GeneralMaterialProperty {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = GeneralMaterialProperty::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.id = parameter.into(),
                1usize => entity.name = parameter.into(),
                2usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
}
pub trait IGeneralProperty {
    fn id(&self) -> &Identifier;
    fn name(&self) -> &Label;
    fn description(&self) -> &Option<Text>;
}
#[derive(Default, Debug)]
pub struct GeneralProperty {
    id: Identifier,
    name: Label,
    description: Option<Text>,
}
impl IGeneralProperty for GeneralProperty {
    fn id(&self) -> &Identifier {
        &self.id
    }
    fn name(&self) -> &Label {
        &self.name
    }
    fn description(&self) -> &Option<Text> {
        &self.description
    }
}
impl GeneralProperty {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = GeneralProperty::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.id = parameter.into(),
                1usize => entity.name = parameter.into(),
                2usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
}
pub trait IGeneralPropertyAssociation {
    fn name(&self) -> &Label;
    fn description(&self) -> &Option<Text>;
    fn base_definition(&self) -> &EntityRef;
    fn derived_definition(&self) -> &EntityRef;
}
#[derive(Default, Debug)]
pub struct GeneralPropertyAssociation {
    name: Label,
    description: Option<Text>,
    base_definition: EntityRef,
    derived_definition: EntityRef,
}
impl IGeneralPropertyAssociation for GeneralPropertyAssociation {
    fn name(&self) -> &Label {
        &self.name
    }
    fn description(&self) -> &Option<Text> {
        &self.description
    }
    fn base_definition(&self) -> &EntityRef {
        &self.base_definition
    }
    fn derived_definition(&self) -> &EntityRef {
        &self.derived_definition
    }
}
impl GeneralPropertyAssociation {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = GeneralPropertyAssociation::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => entity.base_definition = parameter.into(),
                3usize => entity.derived_definition = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IGeneralPropertyRelationship {
    fn name(&self) -> &Label;
    fn description(&self) -> &Option<Text>;
    fn relating_property(&self) -> &EntityRef;
    fn related_property(&self) -> &EntityRef;
}
#[derive(Default, Debug)]
pub struct GeneralPropertyRelationship {
    name: Label,
    description: Option<Text>,
    relating_property: EntityRef,
    related_property: EntityRef,
}
impl IGeneralPropertyRelationship for GeneralPropertyRelationship {
    fn name(&self) -> &Label {
        &self.name
    }
    fn description(&self) -> &Option<Text> {
        &self.description
    }
    fn relating_property(&self) -> &EntityRef {
        &self.relating_property
    }
    fn related_property(&self) -> &EntityRef {
        &self.related_property
    }
}
impl GeneralPropertyRelationship {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = GeneralPropertyRelationship::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => entity.relating_property = parameter.into(),
                3usize => entity.related_property = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IGenericCharacterGlyphSymbol: ISymbolRepresentation {}
pub trait IGenericExpression {}
pub trait IGenericLiteral: ISimpleGenericExpression {}
pub trait IGenericVariable: ISimpleGenericExpression {}
pub trait IGeometricAlignment: IDerivedShapeAspect {}
#[derive(Default, Debug)]
pub struct GeometricAlignment {
    name: Label,
    description: Option<Text>,
    of_shape: EntityRef,
    product_definitional: Option<bool>,
}
impl IShapeAspect for GeometricAlignment {
    fn name(&self) -> &Label {
        &self.name
    }
    fn description(&self) -> &Option<Text> {
        &self.description
    }
    fn of_shape(&self) -> &EntityRef {
        &self.of_shape
    }
    fn product_definitional(&self) -> Option<bool> {
        self.product_definitional
    }
}
impl IDerivedShapeAspect for GeometricAlignment {}
impl IGeometricAlignment for GeometricAlignment {}
impl GeometricAlignment {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = GeometricAlignment::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => entity.of_shape = parameter.into(),
                3usize => entity.product_definitional = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IGeometricCurveSet: IGeometricSet {}
#[derive(Default, Debug)]
pub struct GeometricCurveSet {
    name: Label,
    elements: HashSet<EntityRef>,
}
impl IRepresentationItem for GeometricCurveSet {
    fn name(&self) -> &Label {
        &self.name
    }
}
impl IGeometricRepresentationItem for GeometricCurveSet {}
impl IGeometricSet for GeometricCurveSet {
    fn elements(&self) -> &HashSet<EntityRef> {
        &self.elements
    }
}
impl IGeometricCurveSet for GeometricCurveSet {}
impl GeometricCurveSet {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = GeometricCurveSet::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => entity.elements = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IGeometricIntersection: IDerivedShapeAspect {}
#[derive(Default, Debug)]
pub struct GeometricIntersection {
    name: Label,
    description: Option<Text>,
    of_shape: EntityRef,
    product_definitional: Option<bool>,
}
impl IShapeAspect for GeometricIntersection {
    fn name(&self) -> &Label {
        &self.name
    }
    fn description(&self) -> &Option<Text> {
        &self.description
    }
    fn of_shape(&self) -> &EntityRef {
        &self.of_shape
    }
    fn product_definitional(&self) -> Option<bool> {
        self.product_definitional
    }
}
impl IDerivedShapeAspect for GeometricIntersection {}
impl IGeometricIntersection for GeometricIntersection {}
impl GeometricIntersection {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = GeometricIntersection::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => entity.of_shape = parameter.into(),
                3usize => entity.product_definitional = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IGeometricItemSpecificUsage: IItemIdentifiedRepresentationUsage {
    fn definition(&self) -> &EntityRef;
    fn identified_item(&self) -> &EntityRef;
    fn used_representation(&self) -> &EntityRef;
}
#[derive(Default, Debug)]
pub struct GeometricItemSpecificUsage {
    name: Label,
    description: Option<Text>,
    definition: EntityRef,
    identified_item: EntityRef,
    used_representation: EntityRef,
}
impl IItemIdentifiedRepresentationUsage for GeometricItemSpecificUsage {
    fn name(&self) -> &Label {
        &self.name
    }
    fn description(&self) -> &Option<Text> {
        &self.description
    }
    fn definition(&self) -> &EntityRef {
        &self.definition
    }
    fn used_representation(&self) -> &EntityRef {
        &self.used_representation
    }
    fn identified_item(&self) -> &EntityRef {
        &self.identified_item
    }
}
impl IGeometricItemSpecificUsage for GeometricItemSpecificUsage {
    fn definition(&self) -> &EntityRef {
        &self.definition
    }
    fn identified_item(&self) -> &EntityRef {
        &self.identified_item
    }
    fn used_representation(&self) -> &EntityRef {
        &self.used_representation
    }
}
impl GeometricItemSpecificUsage {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = GeometricItemSpecificUsage::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => entity.definition = parameter.into(),
                3usize => entity.identified_item = parameter.into(),
                4usize => entity.used_representation = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IGeometricModelElementRelationship: IGeometricRepresentationItem + IRepresentationItemRelationship {
    fn related_representation_item(&self) -> &EntityRef;
    fn relating_representation_item(&self) -> &EntityRef;
}
#[derive(Default, Debug)]
pub struct GeometricModelElementRelationship {
    name: Label,
    description: Option<Text>,
    related_representation_item: EntityRef,
    relating_representation_item: EntityRef,
}
impl IRepresentationItem for GeometricModelElementRelationship {
    fn name(&self) -> &Label {
        &self.name
    }
}
impl IGeometricRepresentationItem for GeometricModelElementRelationship {}
impl IRepresentationItemRelationship for GeometricModelElementRelationship {
    fn name(&self) -> &Label {
        &self.name
    }
    fn description(&self) -> &Option<Text> {
        &self.description
    }
    fn relating_representation_item(&self) -> &EntityRef {
        &self.relating_representation_item
    }
    fn related_representation_item(&self) -> &EntityRef {
        &self.related_representation_item
    }
}
impl IGeometricModelElementRelationship for GeometricModelElementRelationship {
    fn related_representation_item(&self) -> &EntityRef {
        &self.related_representation_item
    }
    fn relating_representation_item(&self) -> &EntityRef {
        &self.relating_representation_item
    }
}
impl GeometricModelElementRelationship {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = GeometricModelElementRelationship::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => entity.related_representation_item = parameter.into(),
                3usize => entity.relating_representation_item = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IGeometricRepresentationContext: IRepresentationContext {
    fn coordinate_space_dimension(&self) -> &DimensionCount;
}
#[derive(Default, Debug)]
pub struct GeometricRepresentationContext {
    context_identifier: Identifier,
    context_type: Text,
    coordinate_space_dimension: DimensionCount,
}
impl IRepresentationContext for GeometricRepresentationContext {
    fn context_identifier(&self) -> &Identifier {
        &self.context_identifier
    }
    fn context_type(&self) -> &Text {
        &self.context_type
    }
}
impl IGeometricRepresentationContext for GeometricRepresentationContext {
    fn coordinate_space_dimension(&self) -> &DimensionCount {
        &self.coordinate_space_dimension
    }
}
impl GeometricRepresentationContext {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = GeometricRepresentationContext::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.context_identifier = parameter.into(),
                1usize => entity.context_type = parameter.into(),
                2usize => entity.coordinate_space_dimension = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IGeometricRepresentationItem: IRepresentationItem {}
#[derive(Default, Debug)]
pub struct GeometricRepresentationItem {
    name: Label,
}
impl IRepresentationItem for GeometricRepresentationItem {
    fn name(&self) -> &Label {
        &self.name
    }
}
impl IGeometricRepresentationItem for GeometricRepresentationItem {}
impl GeometricRepresentationItem {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = GeometricRepresentationItem::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IGeometricSet: IGeometricRepresentationItem {
    fn elements(&self) -> &HashSet<EntityRef>;
}
#[derive(Default, Debug)]
pub struct GeometricSet {
    name: Label,
    elements: HashSet<EntityRef>,
}
impl IRepresentationItem for GeometricSet {
    fn name(&self) -> &Label {
        &self.name
    }
}
impl IGeometricRepresentationItem for GeometricSet {}
impl IGeometricSet for GeometricSet {
    fn elements(&self) -> &HashSet<EntityRef> {
        &self.elements
    }
}
impl GeometricSet {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = GeometricSet::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => entity.elements = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IGeometricTolerance {
    fn name(&self) -> &Label;
    fn description(&self) -> &Text;
    fn magnitude(&self) -> &EntityRef;
    fn toleranced_shape_aspect(&self) -> &EntityRef;
}
#[derive(Default, Debug)]
pub struct GeometricTolerance {
    name: Label,
    description: Text,
    magnitude: EntityRef,
    toleranced_shape_aspect: EntityRef,
}
impl IGeometricTolerance for GeometricTolerance {
    fn name(&self) -> &Label {
        &self.name
    }
    fn description(&self) -> &Text {
        &self.description
    }
    fn magnitude(&self) -> &EntityRef {
        &self.magnitude
    }
    fn toleranced_shape_aspect(&self) -> &EntityRef {
        &self.toleranced_shape_aspect
    }
}
impl GeometricTolerance {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = GeometricTolerance::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => entity.description = parameter.into(),
                2usize => entity.magnitude = parameter.into(),
                3usize => entity.toleranced_shape_aspect = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IGeometricToleranceRelationship {
    fn name(&self) -> &Label;
    fn description(&self) -> &Text;
    fn relating_geometric_tolerance(&self) -> &EntityRef;
    fn related_geometric_tolerance(&self) -> &EntityRef;
}
#[derive(Default, Debug)]
pub struct GeometricToleranceRelationship {
    name: Label,
    description: Text,
    relating_geometric_tolerance: EntityRef,
    related_geometric_tolerance: EntityRef,
}
impl IGeometricToleranceRelationship for GeometricToleranceRelationship {
    fn name(&self) -> &Label {
        &self.name
    }
    fn description(&self) -> &Text {
        &self.description
    }
    fn relating_geometric_tolerance(&self) -> &EntityRef {
        &self.relating_geometric_tolerance
    }
    fn related_geometric_tolerance(&self) -> &EntityRef {
        &self.related_geometric_tolerance
    }
}
impl GeometricToleranceRelationship {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = GeometricToleranceRelationship::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => entity.description = parameter.into(),
                2usize => entity.relating_geometric_tolerance = parameter.into(),
                3usize => entity.related_geometric_tolerance = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IGeometricToleranceWithDatumReference: IGeometricTolerance {
    fn datum_system(&self) -> &HashSet<EntityRef>;
}
#[derive(Default, Debug)]
pub struct GeometricToleranceWithDatumReference {
    name: Label,
    description: Text,
    magnitude: EntityRef,
    toleranced_shape_aspect: EntityRef,
    datum_system: HashSet<EntityRef>,
}
impl IGeometricTolerance for GeometricToleranceWithDatumReference {
    fn name(&self) -> &Label {
        &self.name
    }
    fn description(&self) -> &Text {
        &self.description
    }
    fn magnitude(&self) -> &EntityRef {
        &self.magnitude
    }
    fn toleranced_shape_aspect(&self) -> &EntityRef {
        &self.toleranced_shape_aspect
    }
}
impl IGeometricToleranceWithDatumReference for GeometricToleranceWithDatumReference {
    fn datum_system(&self) -> &HashSet<EntityRef> {
        &self.datum_system
    }
}
impl GeometricToleranceWithDatumReference {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = GeometricToleranceWithDatumReference::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => entity.description = parameter.into(),
                2usize => entity.magnitude = parameter.into(),
                3usize => entity.toleranced_shape_aspect = parameter.into(),
                4usize => entity.datum_system = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IGeometricToleranceWithDefinedUnit: IGeometricTolerance {
    fn unit_size(&self) -> &EntityRef;
}
#[derive(Default, Debug)]
pub struct GeometricToleranceWithDefinedUnit {
    name: Label,
    description: Text,
    magnitude: EntityRef,
    toleranced_shape_aspect: EntityRef,
    unit_size: EntityRef,
}
impl IGeometricTolerance for GeometricToleranceWithDefinedUnit {
    fn name(&self) -> &Label {
        &self.name
    }
    fn description(&self) -> &Text {
        &self.description
    }
    fn magnitude(&self) -> &EntityRef {
        &self.magnitude
    }
    fn toleranced_shape_aspect(&self) -> &EntityRef {
        &self.toleranced_shape_aspect
    }
}
impl IGeometricToleranceWithDefinedUnit for GeometricToleranceWithDefinedUnit {
    fn unit_size(&self) -> &EntityRef {
        &self.unit_size
    }
}
impl GeometricToleranceWithDefinedUnit {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = GeometricToleranceWithDefinedUnit::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => entity.description = parameter.into(),
                2usize => entity.magnitude = parameter.into(),
                3usize => entity.toleranced_shape_aspect = parameter.into(),
                4usize => entity.unit_size = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IGeometricalToleranceCallout: IDraughtingCallout {}
#[derive(Default, Debug)]
pub struct GeometricalToleranceCallout {
    name: Label,
    contents: HashSet<EntityRef>,
}
impl IRepresentationItem for GeometricalToleranceCallout {
    fn name(&self) -> &Label {
        &self.name
    }
}
impl IGeometricRepresentationItem for GeometricalToleranceCallout {}
impl IDraughtingCallout for GeometricalToleranceCallout {
    fn contents(&self) -> &HashSet<EntityRef> {
        &self.contents
    }
}
impl IGeometricalToleranceCallout for GeometricalToleranceCallout {}
impl GeometricalToleranceCallout {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = GeometricalToleranceCallout::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => entity.contents = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IGeometricallyBounded2dWireframeRepresentation: IShapeRepresentation {}
#[derive(Default, Debug)]
pub struct GeometricallyBounded2dWireframeRepresentation {
    name: Label,
    items: HashSet<EntityRef>,
    context_of_items: EntityRef,
}
impl IRepresentation for GeometricallyBounded2dWireframeRepresentation {
    fn name(&self) -> &Label {
        &self.name
    }
    fn items(&self) -> &HashSet<EntityRef> {
        &self.items
    }
    fn context_of_items(&self) -> &EntityRef {
        &self.context_of_items
    }
}
impl IShapeRepresentation for GeometricallyBounded2dWireframeRepresentation {}
impl IGeometricallyBounded2dWireframeRepresentation for GeometricallyBounded2dWireframeRepresentation {}
impl GeometricallyBounded2dWireframeRepresentation {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = GeometricallyBounded2dWireframeRepresentation::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => entity.items = parameter.into(),
                2usize => entity.context_of_items = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IGeometricallyBoundedSurfaceShapeRepresentation: IShapeRepresentation {}
#[derive(Default, Debug)]
pub struct GeometricallyBoundedSurfaceShapeRepresentation {
    name: Label,
    items: HashSet<EntityRef>,
    context_of_items: EntityRef,
}
impl IRepresentation for GeometricallyBoundedSurfaceShapeRepresentation {
    fn name(&self) -> &Label {
        &self.name
    }
    fn items(&self) -> &HashSet<EntityRef> {
        &self.items
    }
    fn context_of_items(&self) -> &EntityRef {
        &self.context_of_items
    }
}
impl IShapeRepresentation for GeometricallyBoundedSurfaceShapeRepresentation {}
impl IGeometricallyBoundedSurfaceShapeRepresentation for GeometricallyBoundedSurfaceShapeRepresentation {}
impl GeometricallyBoundedSurfaceShapeRepresentation {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = GeometricallyBoundedSurfaceShapeRepresentation::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => entity.items = parameter.into(),
                2usize => entity.context_of_items = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IGeometricallyBoundedWireframeShapeRepresentation: IShapeRepresentation {}
#[derive(Default, Debug)]
pub struct GeometricallyBoundedWireframeShapeRepresentation {
    name: Label,
    items: HashSet<EntityRef>,
    context_of_items: EntityRef,
}
impl IRepresentation for GeometricallyBoundedWireframeShapeRepresentation {
    fn name(&self) -> &Label {
        &self.name
    }
    fn items(&self) -> &HashSet<EntityRef> {
        &self.items
    }
    fn context_of_items(&self) -> &EntityRef {
        &self.context_of_items
    }
}
impl IShapeRepresentation for GeometricallyBoundedWireframeShapeRepresentation {}
impl IGeometricallyBoundedWireframeShapeRepresentation for GeometricallyBoundedWireframeShapeRepresentation {}
impl GeometricallyBoundedWireframeShapeRepresentation {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = GeometricallyBoundedWireframeShapeRepresentation::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => entity.items = parameter.into(),
                2usize => entity.context_of_items = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IGlobalAssignment: IRepresentationItemRelationship {}
#[derive(Default, Debug)]
pub struct GlobalAssignment {
    name: Label,
    description: Option<Text>,
    relating_representation_item: EntityRef,
    related_representation_item: EntityRef,
}
impl IRepresentationItemRelationship for GlobalAssignment {
    fn name(&self) -> &Label {
        &self.name
    }
    fn description(&self) -> &Option<Text> {
        &self.description
    }
    fn relating_representation_item(&self) -> &EntityRef {
        &self.relating_representation_item
    }
    fn related_representation_item(&self) -> &EntityRef {
        &self.related_representation_item
    }
}
impl IGlobalAssignment for GlobalAssignment {}
impl GlobalAssignment {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = GlobalAssignment::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => entity.relating_representation_item = parameter.into(),
                3usize => entity.related_representation_item = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IGlobalUncertaintyAssignedContext: IRepresentationContext {
    fn uncertainty(&self) -> &HashSet<EntityRef>;
}
#[derive(Default, Debug)]
pub struct GlobalUncertaintyAssignedContext {
    context_identifier: Identifier,
    context_type: Text,
    uncertainty: HashSet<EntityRef>,
}
impl IRepresentationContext for GlobalUncertaintyAssignedContext {
    fn context_identifier(&self) -> &Identifier {
        &self.context_identifier
    }
    fn context_type(&self) -> &Text {
        &self.context_type
    }
}
impl IGlobalUncertaintyAssignedContext for GlobalUncertaintyAssignedContext {
    fn uncertainty(&self) -> &HashSet<EntityRef> {
        &self.uncertainty
    }
}
impl GlobalUncertaintyAssignedContext {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = GlobalUncertaintyAssignedContext::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.context_identifier = parameter.into(),
                1usize => entity.context_type = parameter.into(),
                2usize => entity.uncertainty = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IGlobalUnitAssignedContext: IRepresentationContext {
    fn units(&self) -> &HashSet<EntityRef>;
}
#[derive(Default, Debug)]
pub struct GlobalUnitAssignedContext {
    context_identifier: Identifier,
    context_type: Text,
    units: HashSet<EntityRef>,
}
impl IRepresentationContext for GlobalUnitAssignedContext {
    fn context_identifier(&self) -> &Identifier {
        &self.context_identifier
    }
    fn context_type(&self) -> &Text {
        &self.context_type
    }
}
impl IGlobalUnitAssignedContext for GlobalUnitAssignedContext {
    fn units(&self) -> &HashSet<EntityRef> {
        &self.units
    }
}
impl GlobalUnitAssignedContext {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = GlobalUnitAssignedContext::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.context_identifier = parameter.into(),
                1usize => entity.context_type = parameter.into(),
                2usize => entity.units = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IGroundFact: IAtomicFormula {}
#[derive(Default, Debug)]
pub struct GroundFact {
    name: Label,
    item_element: CompoundItemDefinition,
}
impl IRepresentationItem for GroundFact {
    fn name(&self) -> &Label {
        &self.name
    }
}
impl ICompoundRepresentationItem for GroundFact {
    fn item_element(&self) -> &CompoundItemDefinition {
        &self.item_element
    }
}
impl IAtomicFormula for GroundFact {}
impl IGroundFact for GroundFact {}
impl GroundFact {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = GroundFact::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => entity.item_element = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IGroup {
    fn name(&self) -> &Label;
    fn description(&self) -> &Option<Text>;
}
#[derive(Default, Debug)]
pub struct Group {
    name: Label,
    description: Option<Text>,
}
impl IGroup for Group {
    fn name(&self) -> &Label {
        &self.name
    }
    fn description(&self) -> &Option<Text> {
        &self.description
    }
}
impl Group {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = Group::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
}
pub trait IGroupAssignment {
    fn assigned_group(&self) -> &EntityRef;
}
pub trait IGroupRelationship {
    fn name(&self) -> &Label;
    fn description(&self) -> &Option<Text>;
    fn relating_group(&self) -> &EntityRef;
    fn related_group(&self) -> &EntityRef;
}
#[derive(Default, Debug)]
pub struct GroupRelationship {
    name: Label,
    description: Option<Text>,
    relating_group: EntityRef,
    related_group: EntityRef,
}
impl IGroupRelationship for GroupRelationship {
    fn name(&self) -> &Label {
        &self.name
    }
    fn description(&self) -> &Option<Text> {
        &self.description
    }
    fn relating_group(&self) -> &EntityRef {
        &self.relating_group
    }
    fn related_group(&self) -> &EntityRef {
        &self.related_group
    }
}
impl GroupRelationship {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = GroupRelationship::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => entity.relating_group = parameter.into(),
                3usize => entity.related_group = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IHalfSpaceSolid: IGeometricRepresentationItem {
    fn base_surface(&self) -> &EntityRef;
    fn agreement_flag(&self) -> bool;
}
#[derive(Default, Debug)]
pub struct HalfSpaceSolid {
    name: Label,
    base_surface: EntityRef,
    agreement_flag: bool,
}
impl IRepresentationItem for HalfSpaceSolid {
    fn name(&self) -> &Label {
        &self.name
    }
}
impl IGeometricRepresentationItem for HalfSpaceSolid {}
impl IHalfSpaceSolid for HalfSpaceSolid {
    fn base_surface(&self) -> &EntityRef {
        &self.base_surface
    }
    fn agreement_flag(&self) -> bool {
        self.agreement_flag
    }
}
impl HalfSpaceSolid {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = HalfSpaceSolid::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => entity.base_surface = parameter.into(),
                2usize => entity.agreement_flag = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IHardnessRepresentation: IRepresentation {}
#[derive(Default, Debug)]
pub struct HardnessRepresentation {
    name: Label,
    items: HashSet<EntityRef>,
    context_of_items: EntityRef,
}
impl IRepresentation for HardnessRepresentation {
    fn name(&self) -> &Label {
        &self.name
    }
    fn items(&self) -> &HashSet<EntityRef> {
        &self.items
    }
    fn context_of_items(&self) -> &EntityRef {
        &self.context_of_items
    }
}
impl IHardnessRepresentation for HardnessRepresentation {}
impl HardnessRepresentation {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = HardnessRepresentation::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => entity.items = parameter.into(),
                2usize => entity.context_of_items = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IHiddenElementOverRidingStyledItem: IContextDependentOverRidingStyledItem {
    fn item(&self) -> &EntityRef;
    fn style_context(&self) -> &Vec<EntityRef>;
}
#[derive(Default, Debug)]
pub struct HiddenElementOverRidingStyledItem {
    name: Label,
    styles: HashSet<EntityRef>,
    over_ridden_style: EntityRef,
    item: EntityRef,
    style_context: Vec<EntityRef>,
}
impl IRepresentationItem for HiddenElementOverRidingStyledItem {
    fn name(&self) -> &Label {
        &self.name
    }
}
impl IStyledItem for HiddenElementOverRidingStyledItem {
    fn styles(&self) -> &HashSet<EntityRef> {
        &self.styles
    }
    fn item(&self) -> &EntityRef {
        &self.item
    }
}
impl IOverRidingStyledItem for HiddenElementOverRidingStyledItem {
    fn over_ridden_style(&self) -> &EntityRef {
        &self.over_ridden_style
    }
}
impl IContextDependentOverRidingStyledItem for HiddenElementOverRidingStyledItem {
    fn style_context(&self) -> &Vec<EntityRef> {
        &self.style_context
    }
}
impl IHiddenElementOverRidingStyledItem for HiddenElementOverRidingStyledItem {
    fn item(&self) -> &EntityRef {
        &self.item
    }
    fn style_context(&self) -> &Vec<EntityRef> {
        &self.style_context
    }
}
impl HiddenElementOverRidingStyledItem {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = HiddenElementOverRidingStyledItem::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => entity.styles = parameter.into(),
                2usize => entity.over_ridden_style = parameter.into(),
                3usize => entity.item = parameter.into(),
                4usize => entity.style_context = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IHyperbola: IConic {
    fn semi_axis(&self) -> &PositiveLengthMeasure;
    fn semi_imag_axis(&self) -> &PositiveLengthMeasure;
}
#[derive(Default, Debug)]
pub struct Hyperbola {
    name: Label,
    position: EntityRef,
    semi_axis: PositiveLengthMeasure,
    semi_imag_axis: PositiveLengthMeasure,
}
impl IRepresentationItem for Hyperbola {
    fn name(&self) -> &Label {
        &self.name
    }
}
impl IGeometricRepresentationItem for Hyperbola {}
impl ICurve for Hyperbola {}
impl IConic for Hyperbola {
    fn position(&self) -> &EntityRef {
        &self.position
    }
}
impl IHyperbola for Hyperbola {
    fn semi_axis(&self) -> &PositiveLengthMeasure {
        &self.semi_axis
    }
    fn semi_imag_axis(&self) -> &PositiveLengthMeasure {
        &self.semi_imag_axis
    }
}
impl Hyperbola {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = Hyperbola::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => entity.position = parameter.into(),
                2usize => entity.semi_axis = parameter.into(),
                3usize => entity.semi_imag_axis = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IIdAttribute {
    fn attribute_value(&self) -> &Identifier;
    fn identified_item(&self) -> &EntityRef;
}
#[derive(Default, Debug)]
pub struct IdAttribute {
    attribute_value: Identifier,
    identified_item: EntityRef,
}
impl IIdAttribute for IdAttribute {
    fn attribute_value(&self) -> &Identifier {
        &self.attribute_value
    }
    fn identified_item(&self) -> &EntityRef {
        &self.identified_item
    }
}
impl IdAttribute {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IdAttribute::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.attribute_value = parameter.into(),
                1usize => entity.identified_item = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IIdentificationAssignment {
    fn assigned_id(&self) -> &Identifier;
    fn role(&self) -> &EntityRef;
}
pub trait IIdentificationRole {
    fn name(&self) -> &Label;
    fn description(&self) -> &Option<Text>;
}
#[derive(Default, Debug)]
pub struct IdentificationRole {
    name: Label,
    description: Option<Text>,
}
impl IIdentificationRole for IdentificationRole {
    fn name(&self) -> &Label {
        &self.name
    }
    fn description(&self) -> &Option<Text> {
        &self.description
    }
}
impl IdentificationRole {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IdentificationRole::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
}
pub trait IIlluminanceMeasureWithUnit: IMeasureWithUnit {}
#[derive(Default, Debug)]
pub struct IlluminanceMeasureWithUnit {
    value_component: MeasureValue,
    unit_component: EntityRef,
}
impl IMeasureWithUnit for IlluminanceMeasureWithUnit {
    fn value_component(&self) -> &MeasureValue {
        &self.value_component
    }
    fn unit_component(&self) -> &EntityRef {
        &self.unit_component
    }
}
impl IIlluminanceMeasureWithUnit for IlluminanceMeasureWithUnit {}
impl IlluminanceMeasureWithUnit {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IlluminanceMeasureWithUnit::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.value_component = parameter.into(),
                1usize => entity.unit_component = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IIlluminanceUnit: IDerivedUnit {}
#[derive(Default, Debug)]
pub struct IlluminanceUnit {
    elements: HashSet<EntityRef>,
}
impl IDerivedUnit for IlluminanceUnit {
    fn elements(&self) -> &HashSet<EntityRef> {
        &self.elements
    }
}
impl IIlluminanceUnit for IlluminanceUnit {}
impl IlluminanceUnit {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IlluminanceUnit::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.elements = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IIncludedTextBlock: IMappedItem {}
#[derive(Default, Debug)]
pub struct IncludedTextBlock {
    name: Label,
    mapping_source: EntityRef,
    mapping_target: EntityRef,
}
impl IRepresentationItem for IncludedTextBlock {
    fn name(&self) -> &Label {
        &self.name
    }
}
impl IMappedItem for IncludedTextBlock {
    fn mapping_source(&self) -> &EntityRef {
        &self.mapping_source
    }
    fn mapping_target(&self) -> &EntityRef {
        &self.mapping_target
    }
}
impl IIncludedTextBlock for IncludedTextBlock {}
impl IncludedTextBlock {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IncludedTextBlock::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => entity.mapping_source = parameter.into(),
                2usize => entity.mapping_target = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IInclusionProductConceptFeature: IConditionalConceptFeature {}
#[derive(Default, Debug)]
pub struct InclusionProductConceptFeature {
    id: Identifier,
    name: Label,
    description: Option<Text>,
    condition: EntityRef,
}
impl IProductConceptFeature for InclusionProductConceptFeature {
    fn id(&self) -> &Identifier {
        &self.id
    }
    fn name(&self) -> &Label {
        &self.name
    }
    fn description(&self) -> &Option<Text> {
        &self.description
    }
}
impl IConditionalConceptFeature for InclusionProductConceptFeature {
    fn condition(&self) -> &EntityRef {
        &self.condition
    }
}
impl IInclusionProductConceptFeature for InclusionProductConceptFeature {}
impl InclusionProductConceptFeature {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = InclusionProductConceptFeature::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.id = parameter.into(),
                1usize => entity.name = parameter.into(),
                2usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => entity.condition = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IIndirectlySelectedElements: IUserSelectedElements {
    fn indirectly_picked_items(&self) -> &HashSet<EntityRef>;
}
#[derive(Default, Debug)]
pub struct IndirectlySelectedElements {
    name: Label,
    picked_items: HashSet<EntityRef>,
    indirectly_picked_items: HashSet<EntityRef>,
}
impl IRepresentationItem for IndirectlySelectedElements {
    fn name(&self) -> &Label {
        &self.name
    }
}
impl IUserSelectedElements for IndirectlySelectedElements {
    fn picked_items(&self) -> &HashSet<EntityRef> {
        &self.picked_items
    }
}
impl IIndirectlySelectedElements for IndirectlySelectedElements {
    fn indirectly_picked_items(&self) -> &HashSet<EntityRef> {
        &self.indirectly_picked_items
    }
}
impl IndirectlySelectedElements {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IndirectlySelectedElements::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => entity.picked_items = parameter.into(),
                2usize => entity.indirectly_picked_items = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IIndirectlySelectedShapeElements: IIndirectlySelectedElements + IUserSelectedShapeElements {}
#[derive(Default, Debug)]
pub struct IndirectlySelectedShapeElements {
    name: Label,
    picked_items: HashSet<EntityRef>,
    indirectly_picked_items: HashSet<EntityRef>,
}
impl IRepresentationItem for IndirectlySelectedShapeElements {
    fn name(&self) -> &Label {
        &self.name
    }
}
impl IUserSelectedElements for IndirectlySelectedShapeElements {
    fn picked_items(&self) -> &HashSet<EntityRef> {
        &self.picked_items
    }
}
impl IIndirectlySelectedElements for IndirectlySelectedShapeElements {
    fn indirectly_picked_items(&self) -> &HashSet<EntityRef> {
        &self.indirectly_picked_items
    }
}
impl IIndirectlySelectedShapeElements for IndirectlySelectedShapeElements {}
impl IUserSelectedShapeElements for IndirectlySelectedShapeElements {}
impl IndirectlySelectedShapeElements {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IndirectlySelectedShapeElements::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => entity.picked_items = parameter.into(),
                2usize => entity.indirectly_picked_items = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IInductanceMeasureWithUnit: IMeasureWithUnit {}
#[derive(Default, Debug)]
pub struct InductanceMeasureWithUnit {
    value_component: MeasureValue,
    unit_component: EntityRef,
}
impl IMeasureWithUnit for InductanceMeasureWithUnit {
    fn value_component(&self) -> &MeasureValue {
        &self.value_component
    }
    fn unit_component(&self) -> &EntityRef {
        &self.unit_component
    }
}
impl IInductanceMeasureWithUnit for InductanceMeasureWithUnit {}
impl InductanceMeasureWithUnit {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = InductanceMeasureWithUnit::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.value_component = parameter.into(),
                1usize => entity.unit_component = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IInductanceUnit: IDerivedUnit {}
#[derive(Default, Debug)]
pub struct InductanceUnit {
    elements: HashSet<EntityRef>,
}
impl IDerivedUnit for InductanceUnit {
    fn elements(&self) -> &HashSet<EntityRef> {
        &self.elements
    }
}
impl IInductanceUnit for InductanceUnit {}
impl InductanceUnit {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = InductanceUnit::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.elements = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IInformationRight: IActionMethod {}
#[derive(Default, Debug)]
pub struct InformationRight {
    name: Label,
    description: Option<Text>,
    consequence: Text,
    purpose: Text,
}
impl IActionMethod for InformationRight {
    fn name(&self) -> &Label {
        &self.name
    }
    fn description(&self) -> &Option<Text> {
        &self.description
    }
    fn consequence(&self) -> &Text {
        &self.consequence
    }
    fn purpose(&self) -> &Text {
        &self.purpose
    }
}
impl IInformationRight for InformationRight {}
impl InformationRight {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = InformationRight::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => entity.consequence = parameter.into(),
                3usize => entity.purpose = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IInformationUsageRight: IActionMethod {}
#[derive(Default, Debug)]
pub struct InformationUsageRight {
    name: Label,
    description: Option<Text>,
    consequence: Text,
    purpose: Text,
}
impl IActionMethod for InformationUsageRight {
    fn name(&self) -> &Label {
        &self.name
    }
    fn description(&self) -> &Option<Text> {
        &self.description
    }
    fn consequence(&self) -> &Text {
        &self.consequence
    }
    fn purpose(&self) -> &Text {
        &self.purpose
    }
}
impl IInformationUsageRight for InformationUsageRight {}
impl InformationUsageRight {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = InformationUsageRight::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => entity.consequence = parameter.into(),
                3usize => entity.purpose = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IInstanceUsageContextAssignment: IProductDefinitionContext {
    fn items(&self) -> &HashSet<EntityRef>;
}
#[derive(Default, Debug)]
pub struct InstanceUsageContextAssignment {
    name: Label,
    frame_of_reference: EntityRef,
    life_cycle_stage: Label,
    items: HashSet<EntityRef>,
}
impl IApplicationContextElement for InstanceUsageContextAssignment {
    fn name(&self) -> &Label {
        &self.name
    }
    fn frame_of_reference(&self) -> &EntityRef {
        &self.frame_of_reference
    }
}
impl IProductDefinitionContext for InstanceUsageContextAssignment {
    fn life_cycle_stage(&self) -> &Label {
        &self.life_cycle_stage
    }
}
impl IInstanceUsageContextAssignment for InstanceUsageContextAssignment {
    fn items(&self) -> &HashSet<EntityRef> {
        &self.items
    }
}
impl InstanceUsageContextAssignment {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = InstanceUsageContextAssignment::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => entity.frame_of_reference = parameter.into(),
                2usize => entity.life_cycle_stage = parameter.into(),
                3usize => entity.items = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IInstancedFeature: IShapeAspect + IShapeFeatureDefinition {}
#[derive(Default, Debug)]
pub struct InstancedFeature {
    name: Label,
    description: Option<Text>,
    of_shape: EntityRef,
    product_definitional: Option<bool>,
}
impl IShapeAspect for InstancedFeature {
    fn name(&self) -> &Label {
        &self.name
    }
    fn description(&self) -> &Option<Text> {
        &self.description
    }
    fn of_shape(&self) -> &EntityRef {
        &self.of_shape
    }
    fn product_definitional(&self) -> Option<bool> {
        self.product_definitional
    }
}
impl ICharacterizedObject for InstancedFeature {
    fn name(&self) -> &Label {
        &self.name
    }
    fn description(&self) -> &Option<Text> {
        &self.description
    }
}
impl IShapeFeatureDefinition for InstancedFeature {}
impl IInstancedFeature for InstancedFeature {}
impl InstancedFeature {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = InstancedFeature::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => entity.of_shape = parameter.into(),
                3usize => entity.product_definitional = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IIntLiteral: ILiteralNumber {
    fn the_value(&self) -> i64;
}
#[derive(Default, Debug)]
pub struct IntLiteral {
    the_value: i64,
}
impl IGenericExpression for IntLiteral {}
impl IExpression for IntLiteral {}
impl INumericExpression for IntLiteral {}
impl ISimpleNumericExpression for IntLiteral {}
impl ISimpleGenericExpression for IntLiteral {}
impl ILiteralNumber for IntLiteral {
    fn the_value(&self) -> Real {
        Real(self.the_value as f64)
    }
}
impl IGenericLiteral for IntLiteral {}
impl IIntLiteral for IntLiteral {
    fn the_value(&self) -> i64 {
        self.the_value
    }
}
impl IntLiteral {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IntLiteral::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.the_value = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IIntegerRepresentationItem: IRepresentationItem + IIntLiteral {}
#[derive(Default, Debug)]
pub struct IntegerRepresentationItem {
    name: Label,
    the_value: i64,
}
impl IRepresentationItem for IntegerRepresentationItem {
    fn name(&self) -> &Label {
        &self.name
    }
}
impl IGenericExpression for IntegerRepresentationItem {}
impl IExpression for IntegerRepresentationItem {}
impl INumericExpression for IntegerRepresentationItem {}
impl ISimpleNumericExpression for IntegerRepresentationItem {}
impl ISimpleGenericExpression for IntegerRepresentationItem {}
impl ILiteralNumber for IntegerRepresentationItem {
    fn the_value(&self) -> Real {
        Real(self.the_value as f64)
    }
}
impl IGenericLiteral for IntegerRepresentationItem {}
impl IIntLiteral for IntegerRepresentationItem {
    fn the_value(&self) -> i64 {
        self.the_value
    }
}
impl IIntegerRepresentationItem for IntegerRepresentationItem {}
impl IntegerRepresentationItem {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IntegerRepresentationItem::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => entity.the_value = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IIntersectionCurve: ISurfaceCurve {}
#[derive(Default, Debug)]
pub struct IntersectionCurve {
    name: Label,
    curve_3d: EntityRef,
    associated_geometry: Vec<EntityRef>,
    master_representation: PreferredSurfaceCurveRepresentation,
}
impl IRepresentationItem for IntersectionCurve {
    fn name(&self) -> &Label {
        &self.name
    }
}
impl IGeometricRepresentationItem for IntersectionCurve {}
impl ICurve for IntersectionCurve {}
impl ISurfaceCurve for IntersectionCurve {
    fn curve_3d(&self) -> &EntityRef {
        &self.curve_3d
    }
    fn associated_geometry(&self) -> &Vec<EntityRef> {
        &self.associated_geometry
    }
    fn master_representation(&self) -> &PreferredSurfaceCurveRepresentation {
        &self.master_representation
    }
}
impl IIntersectionCurve for IntersectionCurve {}
impl IntersectionCurve {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IntersectionCurve::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => entity.curve_3d = parameter.into(),
                2usize => entity.associated_geometry = parameter.into(),
                3usize => entity.master_representation = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IIntervalExpression: IBooleanExpression + IMultipleArityGenericExpression {}
#[derive(Default, Debug)]
pub struct IntervalExpression {
    operands: Vec<EntityRef>,
}
impl IGenericExpression for IntervalExpression {}
impl IExpression for IntervalExpression {}
impl IBooleanExpression for IntervalExpression {}
impl IIntervalExpression for IntervalExpression {}
impl IMultipleArityGenericExpression for IntervalExpression {
    fn operands(&self) -> &Vec<EntityRef> {
        &self.operands
    }
}
impl IntervalExpression {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IntervalExpression::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.operands = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IInvisibility {
    fn invisible_items(&self) -> &HashSet<EntityRef>;
}
#[derive(Default, Debug)]
pub struct Invisibility {
    invisible_items: HashSet<EntityRef>,
}
impl IInvisibility for Invisibility {
    fn invisible_items(&self) -> &HashSet<EntityRef> {
        &self.invisible_items
    }
}
impl Invisibility {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = Invisibility::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.invisible_items = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IIso4217Currency: ICurrency {}
#[derive(Default, Debug)]
pub struct Iso4217Currency {
    dimensions: EntityRef,
    name: Label,
}
impl INamedUnit for Iso4217Currency {
    fn dimensions(&self) -> &EntityRef {
        &self.dimensions
    }
}
impl IContextDependentUnit for Iso4217Currency {
    fn name(&self) -> &Label {
        &self.name
    }
}
impl ICurrency for Iso4217Currency {}
impl IIso4217Currency for Iso4217Currency {}
impl Iso4217Currency {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = Iso4217Currency::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.dimensions = parameter.into(),
                1usize => entity.name = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IItemDefinedTransformation {
    fn name(&self) -> &Label;
    fn description(&self) -> &Option<Text>;
    fn transform_item_1(&self) -> &EntityRef;
    fn transform_item_2(&self) -> &EntityRef;
}
#[derive(Default, Debug)]
pub struct ItemDefinedTransformation {
    name: Label,
    description: Option<Text>,
    transform_item_1: EntityRef,
    transform_item_2: EntityRef,
}
impl IItemDefinedTransformation for ItemDefinedTransformation {
    fn name(&self) -> &Label {
        &self.name
    }
    fn description(&self) -> &Option<Text> {
        &self.description
    }
    fn transform_item_1(&self) -> &EntityRef {
        &self.transform_item_1
    }
    fn transform_item_2(&self) -> &EntityRef {
        &self.transform_item_2
    }
}
impl ItemDefinedTransformation {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = ItemDefinedTransformation::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => entity.transform_item_1 = parameter.into(),
                3usize => entity.transform_item_2 = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IItemIdentifiedRepresentationUsage {
    fn name(&self) -> &Label;
    fn description(&self) -> &Option<Text>;
    fn definition(&self) -> &EntityRef;
    fn used_representation(&self) -> &EntityRef;
    fn identified_item(&self) -> &EntityRef;
}
#[derive(Default, Debug)]
pub struct ItemIdentifiedRepresentationUsage {
    name: Label,
    description: Option<Text>,
    definition: EntityRef,
    used_representation: EntityRef,
    identified_item: EntityRef,
}
impl IItemIdentifiedRepresentationUsage for ItemIdentifiedRepresentationUsage {
    fn name(&self) -> &Label {
        &self.name
    }
    fn description(&self) -> &Option<Text> {
        &self.description
    }
    fn definition(&self) -> &EntityRef {
        &self.definition
    }
    fn used_representation(&self) -> &EntityRef {
        &self.used_representation
    }
    fn identified_item(&self) -> &EntityRef {
        &self.identified_item
    }
}
impl ItemIdentifiedRepresentationUsage {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = ItemIdentifiedRepresentationUsage::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => entity.definition = parameter.into(),
                3usize => entity.used_representation = parameter.into(),
                4usize => entity.identified_item = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IKnownSource: IExternalSource + IPreDefinedItem {}
#[derive(Default, Debug)]
pub struct KnownSource {
    source_id: SourceItem,
    name: Label,
}
impl IExternalSource for KnownSource {
    fn source_id(&self) -> &SourceItem {
        &self.source_id
    }
}
impl IPreDefinedItem for KnownSource {
    fn name(&self) -> &Label {
        &self.name
    }
}
impl IKnownSource for KnownSource {}
impl KnownSource {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = KnownSource::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.source_id = parameter.into(),
                1usize => entity.name = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait ILaidDefinedTransformation: ITransformationWithDerivedAngle {}
#[derive(Default, Debug)]
pub struct LaidDefinedTransformation {
    name: Label,
    description: Option<Text>,
    transform_item_1: EntityRef,
    transform_item_2: EntityRef,
}
impl IItemDefinedTransformation for LaidDefinedTransformation {
    fn name(&self) -> &Label {
        &self.name
    }
    fn description(&self) -> &Option<Text> {
        &self.description
    }
    fn transform_item_1(&self) -> &EntityRef {
        &self.transform_item_1
    }
    fn transform_item_2(&self) -> &EntityRef {
        &self.transform_item_2
    }
}
impl ITransformationWithDerivedAngle for LaidDefinedTransformation {
    fn transform_item_1(&self) -> &EntityRef {
        &self.transform_item_1
    }
    fn transform_item_2(&self) -> &EntityRef {
        &self.transform_item_2
    }
}
impl ILaidDefinedTransformation for LaidDefinedTransformation {}
impl LaidDefinedTransformation {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = LaidDefinedTransformation::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => entity.transform_item_1 = parameter.into(),
                3usize => entity.transform_item_2 = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait ILaminateTable: IProductDefinition {}
#[derive(Default, Debug)]
pub struct LaminateTable {
    id: Identifier,
    description: Option<Text>,
    formation: EntityRef,
    frame_of_reference: EntityRef,
}
impl IProductDefinition for LaminateTable {
    fn id(&self) -> &Identifier {
        &self.id
    }
    fn description(&self) -> &Option<Text> {
        &self.description
    }
    fn formation(&self) -> &EntityRef {
        &self.formation
    }
    fn frame_of_reference(&self) -> &EntityRef {
        &self.frame_of_reference
    }
}
impl ILaminateTable for LaminateTable {}
impl LaminateTable {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = LaminateTable::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.id = parameter.into(),
                1usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => entity.formation = parameter.into(),
                3usize => entity.frame_of_reference = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait ILanguage: IGroup {}
#[derive(Default, Debug)]
pub struct Language {
    name: Label,
    description: Option<Text>,
}
impl IGroup for Language {
    fn name(&self) -> &Label {
        &self.name
    }
    fn description(&self) -> &Option<Text> {
        &self.description
    }
}
impl ILanguage for Language {}
impl Language {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = Language::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
}
pub trait ILeaderCurve: IAnnotationCurveOccurrence {}
#[derive(Default, Debug)]
pub struct LeaderCurve {
    name: Label,
    styles: HashSet<EntityRef>,
    item: EntityRef,
}
impl IRepresentationItem for LeaderCurve {
    fn name(&self) -> &Label {
        &self.name
    }
}
impl IStyledItem for LeaderCurve {
    fn styles(&self) -> &HashSet<EntityRef> {
        &self.styles
    }
    fn item(&self) -> &EntityRef {
        &self.item
    }
}
impl IAnnotationOccurrence for LeaderCurve {}
impl IAnnotationCurveOccurrence for LeaderCurve {
    fn item(&self) -> &EntityRef {
        &self.item
    }
}
impl ILeaderCurve for LeaderCurve {}
impl LeaderCurve {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = LeaderCurve::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => entity.styles = parameter.into(),
                2usize => entity.item = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait ILeaderDirectedCallout: IDraughtingCallout {}
#[derive(Default, Debug)]
pub struct LeaderDirectedCallout {
    name: Label,
    contents: HashSet<EntityRef>,
}
impl IRepresentationItem for LeaderDirectedCallout {
    fn name(&self) -> &Label {
        &self.name
    }
}
impl IGeometricRepresentationItem for LeaderDirectedCallout {}
impl IDraughtingCallout for LeaderDirectedCallout {
    fn contents(&self) -> &HashSet<EntityRef> {
        &self.contents
    }
}
impl ILeaderDirectedCallout for LeaderDirectedCallout {}
impl LeaderDirectedCallout {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = LeaderDirectedCallout::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => entity.contents = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait ILeaderDirectedDimension: ILeaderDirectedCallout {}
#[derive(Default, Debug)]
pub struct LeaderDirectedDimension {
    name: Label,
    contents: HashSet<EntityRef>,
}
impl IRepresentationItem for LeaderDirectedDimension {
    fn name(&self) -> &Label {
        &self.name
    }
}
impl IGeometricRepresentationItem for LeaderDirectedDimension {}
impl IDraughtingCallout for LeaderDirectedDimension {
    fn contents(&self) -> &HashSet<EntityRef> {
        &self.contents
    }
}
impl ILeaderDirectedCallout for LeaderDirectedDimension {}
impl ILeaderDirectedDimension for LeaderDirectedDimension {}
impl LeaderDirectedDimension {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = LeaderDirectedDimension::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => entity.contents = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait ILeaderTerminator: ITerminatorSymbol {}
#[derive(Default, Debug)]
pub struct LeaderTerminator {
    name: Label,
    styles: HashSet<EntityRef>,
    item: EntityRef,
    annotated_curve: EntityRef,
}
impl IRepresentationItem for LeaderTerminator {
    fn name(&self) -> &Label {
        &self.name
    }
}
impl IStyledItem for LeaderTerminator {
    fn styles(&self) -> &HashSet<EntityRef> {
        &self.styles
    }
    fn item(&self) -> &EntityRef {
        &self.item
    }
}
impl IAnnotationOccurrence for LeaderTerminator {}
impl IAnnotationSymbolOccurrence for LeaderTerminator {
    fn item(&self) -> &EntityRef {
        &self.item
    }
}
impl ITerminatorSymbol for LeaderTerminator {
    fn annotated_curve(&self) -> &EntityRef {
        &self.annotated_curve
    }
}
impl ILeaderTerminator for LeaderTerminator {}
impl LeaderTerminator {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = LeaderTerminator::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => entity.styles = parameter.into(),
                2usize => entity.item = parameter.into(),
                3usize => entity.annotated_curve = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait ILengthMeasureWithUnit: IMeasureWithUnit {}
#[derive(Default, Debug)]
pub struct LengthMeasureWithUnit {
    value_component: MeasureValue,
    unit_component: EntityRef,
}
impl IMeasureWithUnit for LengthMeasureWithUnit {
    fn value_component(&self) -> &MeasureValue {
        &self.value_component
    }
    fn unit_component(&self) -> &EntityRef {
        &self.unit_component
    }
}
impl ILengthMeasureWithUnit for LengthMeasureWithUnit {}
impl LengthMeasureWithUnit {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = LengthMeasureWithUnit::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.value_component = parameter.into(),
                1usize => entity.unit_component = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait ILengthUnit: INamedUnit {}
#[derive(Default, Debug)]
pub struct LengthUnit {
    dimensions: EntityRef,
}
impl INamedUnit for LengthUnit {
    fn dimensions(&self) -> &EntityRef {
        &self.dimensions
    }
}
impl ILengthUnit for LengthUnit {}
impl LengthUnit {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = LengthUnit::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.dimensions = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait ILightSource: IGeometricRepresentationItem {
    fn light_colour(&self) -> &EntityRef;
}
#[derive(Default, Debug)]
pub struct LightSource {
    name: Label,
    light_colour: EntityRef,
}
impl IRepresentationItem for LightSource {
    fn name(&self) -> &Label {
        &self.name
    }
}
impl IGeometricRepresentationItem for LightSource {}
impl ILightSource for LightSource {
    fn light_colour(&self) -> &EntityRef {
        &self.light_colour
    }
}
impl LightSource {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = LightSource::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => entity.light_colour = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait ILightSourceAmbient: ILightSource {}
#[derive(Default, Debug)]
pub struct LightSourceAmbient {
    name: Label,
    light_colour: EntityRef,
}
impl IRepresentationItem for LightSourceAmbient {
    fn name(&self) -> &Label {
        &self.name
    }
}
impl IGeometricRepresentationItem for LightSourceAmbient {}
impl ILightSource for LightSourceAmbient {
    fn light_colour(&self) -> &EntityRef {
        &self.light_colour
    }
}
impl ILightSourceAmbient for LightSourceAmbient {}
impl LightSourceAmbient {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = LightSourceAmbient::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => entity.light_colour = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait ILightSourceDirectional: ILightSource {
    fn orientation(&self) -> &EntityRef;
}
#[derive(Default, Debug)]
pub struct LightSourceDirectional {
    name: Label,
    light_colour: EntityRef,
    orientation: EntityRef,
}
impl IRepresentationItem for LightSourceDirectional {
    fn name(&self) -> &Label {
        &self.name
    }
}
impl IGeometricRepresentationItem for LightSourceDirectional {}
impl ILightSource for LightSourceDirectional {
    fn light_colour(&self) -> &EntityRef {
        &self.light_colour
    }
}
impl ILightSourceDirectional for LightSourceDirectional {
    fn orientation(&self) -> &EntityRef {
        &self.orientation
    }
}
impl LightSourceDirectional {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = LightSourceDirectional::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => entity.light_colour = parameter.into(),
                2usize => entity.orientation = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait ILightSourcePositional: ILightSource {
    fn position(&self) -> &EntityRef;
    fn constant_attenuation(&self) -> Real;
    fn distance_attenuation(&self) -> Real;
}
#[derive(Default, Debug)]
pub struct LightSourcePositional {
    name: Label,
    light_colour: EntityRef,
    position: EntityRef,
    constant_attenuation: Real,
    distance_attenuation: Real,
}
impl IRepresentationItem for LightSourcePositional {
    fn name(&self) -> &Label {
        &self.name
    }
}
impl IGeometricRepresentationItem for LightSourcePositional {}
impl ILightSource for LightSourcePositional {
    fn light_colour(&self) -> &EntityRef {
        &self.light_colour
    }
}
impl ILightSourcePositional for LightSourcePositional {
    fn position(&self) -> &EntityRef {
        &self.position
    }
    fn constant_attenuation(&self) -> Real {
        self.constant_attenuation
    }
    fn distance_attenuation(&self) -> Real {
        self.distance_attenuation
    }
}
impl LightSourcePositional {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = LightSourcePositional::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => entity.light_colour = parameter.into(),
                2usize => entity.position = parameter.into(),
                3usize => entity.constant_attenuation = parameter.into(),
                4usize => entity.distance_attenuation = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait ILightSourceSpot: ILightSource {
    fn position(&self) -> &EntityRef;
    fn orientation(&self) -> &EntityRef;
    fn concentration_exponent(&self) -> Real;
    fn constant_attenuation(&self) -> Real;
    fn distance_attenuation(&self) -> Real;
    fn spread_angle(&self) -> &PositivePlaneAngleMeasure;
}
#[derive(Default, Debug)]
pub struct LightSourceSpot {
    name: Label,
    light_colour: EntityRef,
    position: EntityRef,
    orientation: EntityRef,
    concentration_exponent: Real,
    constant_attenuation: Real,
    distance_attenuation: Real,
    spread_angle: PositivePlaneAngleMeasure,
}
impl IRepresentationItem for LightSourceSpot {
    fn name(&self) -> &Label {
        &self.name
    }
}
impl IGeometricRepresentationItem for LightSourceSpot {}
impl ILightSource for LightSourceSpot {
    fn light_colour(&self) -> &EntityRef {
        &self.light_colour
    }
}
impl ILightSourceSpot for LightSourceSpot {
    fn position(&self) -> &EntityRef {
        &self.position
    }
    fn orientation(&self) -> &EntityRef {
        &self.orientation
    }
    fn concentration_exponent(&self) -> Real {
        self.concentration_exponent
    }
    fn constant_attenuation(&self) -> Real {
        self.constant_attenuation
    }
    fn distance_attenuation(&self) -> Real {
        self.distance_attenuation
    }
    fn spread_angle(&self) -> &PositivePlaneAngleMeasure {
        &self.spread_angle
    }
}
impl LightSourceSpot {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = LightSourceSpot::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => entity.light_colour = parameter.into(),
                2usize => entity.position = parameter.into(),
                3usize => entity.orientation = parameter.into(),
                4usize => entity.concentration_exponent = parameter.into(),
                5usize => entity.constant_attenuation = parameter.into(),
                6usize => entity.distance_attenuation = parameter.into(),
                7usize => entity.spread_angle = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait ILimitsAndFits {
    fn form_variance(&self) -> &Label;
    fn zone_variance(&self) -> &Label;
    fn grade(&self) -> &Label;
    fn source(&self) -> &Text;
}
#[derive(Default, Debug)]
pub struct LimitsAndFits {
    form_variance: Label,
    zone_variance: Label,
    grade: Label,
    source: Text,
}
impl ILimitsAndFits for LimitsAndFits {
    fn form_variance(&self) -> &Label {
        &self.form_variance
    }
    fn zone_variance(&self) -> &Label {
        &self.zone_variance
    }
    fn grade(&self) -> &Label {
        &self.grade
    }
    fn source(&self) -> &Text {
        &self.source
    }
}
impl LimitsAndFits {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = LimitsAndFits::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.form_variance = parameter.into(),
                1usize => entity.zone_variance = parameter.into(),
                2usize => entity.grade = parameter.into(),
                3usize => entity.source = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait ILine: ICurve {
    fn pnt(&self) -> &EntityRef;
    fn dir(&self) -> &EntityRef;
}
#[derive(Default, Debug)]
pub struct Line {
    name: Label,
    pnt: EntityRef,
    dir: EntityRef,
}
impl IRepresentationItem for Line {
    fn name(&self) -> &Label {
        &self.name
    }
}
impl IGeometricRepresentationItem for Line {}
impl ICurve for Line {}
impl ILine for Line {
    fn pnt(&self) -> &EntityRef {
        &self.pnt
    }
    fn dir(&self) -> &EntityRef {
        &self.dir
    }
}
impl Line {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = Line::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => entity.pnt = parameter.into(),
                2usize => entity.dir = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait ILineProfileTolerance: IGeometricTolerance {}
#[derive(Default, Debug)]
pub struct LineProfileTolerance {
    name: Label,
    description: Text,
    magnitude: EntityRef,
    toleranced_shape_aspect: EntityRef,
}
impl IGeometricTolerance for LineProfileTolerance {
    fn name(&self) -> &Label {
        &self.name
    }
    fn description(&self) -> &Text {
        &self.description
    }
    fn magnitude(&self) -> &EntityRef {
        &self.magnitude
    }
    fn toleranced_shape_aspect(&self) -> &EntityRef {
        &self.toleranced_shape_aspect
    }
}
impl ILineProfileTolerance for LineProfileTolerance {}
impl LineProfileTolerance {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = LineProfileTolerance::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => entity.description = parameter.into(),
                2usize => entity.magnitude = parameter.into(),
                3usize => entity.toleranced_shape_aspect = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait ILinearDimension: IDimensionCurveDirectedCallout {}
#[derive(Default, Debug)]
pub struct LinearDimension {
    name: Label,
    contents: HashSet<EntityRef>,
}
impl IRepresentationItem for LinearDimension {
    fn name(&self) -> &Label {
        &self.name
    }
}
impl IGeometricRepresentationItem for LinearDimension {}
impl IDraughtingCallout for LinearDimension {
    fn contents(&self) -> &HashSet<EntityRef> {
        &self.contents
    }
}
impl IDimensionCurveDirectedCallout for LinearDimension {}
impl ILinearDimension for LinearDimension {}
impl LinearDimension {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = LinearDimension::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => entity.contents = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait ILiteralConjunction: ISimpleClause {}
#[derive(Default, Debug)]
pub struct LiteralConjunction {
    name: Label,
    item_element: CompoundItemDefinition,
}
impl IRepresentationItem for LiteralConjunction {
    fn name(&self) -> &Label {
        &self.name
    }
}
impl ICompoundRepresentationItem for LiteralConjunction {
    fn item_element(&self) -> &CompoundItemDefinition {
        &self.item_element
    }
}
impl ISimpleClause for LiteralConjunction {}
impl ILiteralConjunction for LiteralConjunction {}
impl LiteralConjunction {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = LiteralConjunction::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => entity.item_element = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait ILiteralDisjunction: ISimpleClause {}
#[derive(Default, Debug)]
pub struct LiteralDisjunction {
    name: Label,
    item_element: CompoundItemDefinition,
}
impl IRepresentationItem for LiteralDisjunction {
    fn name(&self) -> &Label {
        &self.name
    }
}
impl ICompoundRepresentationItem for LiteralDisjunction {
    fn item_element(&self) -> &CompoundItemDefinition {
        &self.item_element
    }
}
impl ISimpleClause for LiteralDisjunction {}
impl ILiteralDisjunction for LiteralDisjunction {}
impl LiteralDisjunction {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = LiteralDisjunction::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => entity.item_element = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait ILiteralNumber: ISimpleNumericExpression + IGenericLiteral {
    fn the_value(&self) -> Real;
}
pub trait ILocalTime {
    fn hour_component(&self) -> &HourInDay;
    fn minute_component(&self) -> &Option<MinuteInHour>;
    fn second_component(&self) -> &Option<SecondInMinute>;
    fn zone(&self) -> &EntityRef;
}
#[derive(Default, Debug)]
pub struct LocalTime {
    hour_component: HourInDay,
    minute_component: Option<MinuteInHour>,
    second_component: Option<SecondInMinute>,
    zone: EntityRef,
}
impl ILocalTime for LocalTime {
    fn hour_component(&self) -> &HourInDay {
        &self.hour_component
    }
    fn minute_component(&self) -> &Option<MinuteInHour> {
        &self.minute_component
    }
    fn second_component(&self) -> &Option<SecondInMinute> {
        &self.second_component
    }
    fn zone(&self) -> &EntityRef {
        &self.zone
    }
}
impl LocalTime {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = LocalTime::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.hour_component = parameter.into(),
                1usize => {
                    entity.minute_component = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => {
                    entity.second_component = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => entity.zone = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait ILogicalLiteral: IGenericLiteral {
    fn lit_value(&self) -> Option<bool>;
}
#[derive(Default, Debug)]
pub struct LogicalLiteral {
    lit_value: Option<bool>,
}
impl IGenericExpression for LogicalLiteral {}
impl ISimpleGenericExpression for LogicalLiteral {}
impl IGenericLiteral for LogicalLiteral {}
impl ILogicalLiteral for LogicalLiteral {
    fn lit_value(&self) -> Option<bool> {
        self.lit_value
    }
}
impl LogicalLiteral {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = LogicalLiteral::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.lit_value = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait ILogicalRepresentationItem: IRepresentationItem + ILogicalLiteral {}
#[derive(Default, Debug)]
pub struct LogicalRepresentationItem {
    name: Label,
    lit_value: Option<bool>,
}
impl IRepresentationItem for LogicalRepresentationItem {
    fn name(&self) -> &Label {
        &self.name
    }
}
impl IGenericExpression for LogicalRepresentationItem {}
impl ISimpleGenericExpression for LogicalRepresentationItem {}
impl IGenericLiteral for LogicalRepresentationItem {}
impl ILogicalLiteral for LogicalRepresentationItem {
    fn lit_value(&self) -> Option<bool> {
        self.lit_value
    }
}
impl ILogicalRepresentationItem for LogicalRepresentationItem {}
impl LogicalRepresentationItem {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = LogicalRepresentationItem::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => entity.lit_value = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait ILoop: ITopologicalRepresentationItem {}
#[derive(Default, Debug)]
pub struct Loop {
    name: Label,
}
impl IRepresentationItem for Loop {
    fn name(&self) -> &Label {
        &self.name
    }
}
impl ITopologicalRepresentationItem for Loop {}
impl ILoop for Loop {}
impl Loop {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = Loop::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait ILossTangentMeasureWithUnit: IRatioMeasureWithUnit {}
#[derive(Default, Debug)]
pub struct LossTangentMeasureWithUnit {
    value_component: MeasureValue,
    unit_component: EntityRef,
}
impl IMeasureWithUnit for LossTangentMeasureWithUnit {
    fn value_component(&self) -> &MeasureValue {
        &self.value_component
    }
    fn unit_component(&self) -> &EntityRef {
        &self.unit_component
    }
}
impl IRatioMeasureWithUnit for LossTangentMeasureWithUnit {}
impl ILossTangentMeasureWithUnit for LossTangentMeasureWithUnit {}
impl LossTangentMeasureWithUnit {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = LossTangentMeasureWithUnit::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.value_component = parameter.into(),
                1usize => entity.unit_component = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait ILotEffectivity: IEffectivity {
    fn effectivity_lot_id(&self) -> &Identifier;
    fn effectivity_lot_size(&self) -> &EntityRef;
}
#[derive(Default, Debug)]
pub struct LotEffectivity {
    id: Identifier,
    effectivity_lot_id: Identifier,
    effectivity_lot_size: EntityRef,
}
impl IEffectivity for LotEffectivity {
    fn id(&self) -> &Identifier {
        &self.id
    }
}
impl ILotEffectivity for LotEffectivity {
    fn effectivity_lot_id(&self) -> &Identifier {
        &self.effectivity_lot_id
    }
    fn effectivity_lot_size(&self) -> &EntityRef {
        &self.effectivity_lot_size
    }
}
impl LotEffectivity {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = LotEffectivity::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.id = parameter.into(),
                1usize => entity.effectivity_lot_id = parameter.into(),
                2usize => entity.effectivity_lot_size = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait ILuminousFluxMeasureWithUnit: IMeasureWithUnit {}
#[derive(Default, Debug)]
pub struct LuminousFluxMeasureWithUnit {
    value_component: MeasureValue,
    unit_component: EntityRef,
}
impl IMeasureWithUnit for LuminousFluxMeasureWithUnit {
    fn value_component(&self) -> &MeasureValue {
        &self.value_component
    }
    fn unit_component(&self) -> &EntityRef {
        &self.unit_component
    }
}
impl ILuminousFluxMeasureWithUnit for LuminousFluxMeasureWithUnit {}
impl LuminousFluxMeasureWithUnit {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = LuminousFluxMeasureWithUnit::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.value_component = parameter.into(),
                1usize => entity.unit_component = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait ILuminousFluxUnit: INamedUnit {}
#[derive(Default, Debug)]
pub struct LuminousFluxUnit {
    dimensions: EntityRef,
}
impl INamedUnit for LuminousFluxUnit {
    fn dimensions(&self) -> &EntityRef {
        &self.dimensions
    }
}
impl ILuminousFluxUnit for LuminousFluxUnit {}
impl LuminousFluxUnit {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = LuminousFluxUnit::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.dimensions = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait ILuminousIntensityMeasureWithUnit: IMeasureWithUnit {}
#[derive(Default, Debug)]
pub struct LuminousIntensityMeasureWithUnit {
    value_component: MeasureValue,
    unit_component: EntityRef,
}
impl IMeasureWithUnit for LuminousIntensityMeasureWithUnit {
    fn value_component(&self) -> &MeasureValue {
        &self.value_component
    }
    fn unit_component(&self) -> &EntityRef {
        &self.unit_component
    }
}
impl ILuminousIntensityMeasureWithUnit for LuminousIntensityMeasureWithUnit {}
impl LuminousIntensityMeasureWithUnit {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = LuminousIntensityMeasureWithUnit::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.value_component = parameter.into(),
                1usize => entity.unit_component = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait ILuminousIntensityUnit: INamedUnit {}
#[derive(Default, Debug)]
pub struct LuminousIntensityUnit {
    dimensions: EntityRef,
}
impl INamedUnit for LuminousIntensityUnit {
    fn dimensions(&self) -> &EntityRef {
        &self.dimensions
    }
}
impl ILuminousIntensityUnit for LuminousIntensityUnit {}
impl LuminousIntensityUnit {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = LuminousIntensityUnit::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.dimensions = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IMagneticFluxDensityMeasureWithUnit: IMeasureWithUnit {}
#[derive(Default, Debug)]
pub struct MagneticFluxDensityMeasureWithUnit {
    value_component: MeasureValue,
    unit_component: EntityRef,
}
impl IMeasureWithUnit for MagneticFluxDensityMeasureWithUnit {
    fn value_component(&self) -> &MeasureValue {
        &self.value_component
    }
    fn unit_component(&self) -> &EntityRef {
        &self.unit_component
    }
}
impl IMagneticFluxDensityMeasureWithUnit for MagneticFluxDensityMeasureWithUnit {}
impl MagneticFluxDensityMeasureWithUnit {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = MagneticFluxDensityMeasureWithUnit::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.value_component = parameter.into(),
                1usize => entity.unit_component = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IMagneticFluxDensityUnit: IDerivedUnit {}
#[derive(Default, Debug)]
pub struct MagneticFluxDensityUnit {
    elements: HashSet<EntityRef>,
}
impl IDerivedUnit for MagneticFluxDensityUnit {
    fn elements(&self) -> &HashSet<EntityRef> {
        &self.elements
    }
}
impl IMagneticFluxDensityUnit for MagneticFluxDensityUnit {}
impl MagneticFluxDensityUnit {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = MagneticFluxDensityUnit::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.elements = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IMagneticFluxMeasureWithUnit: IMeasureWithUnit {}
#[derive(Default, Debug)]
pub struct MagneticFluxMeasureWithUnit {
    value_component: MeasureValue,
    unit_component: EntityRef,
}
impl IMeasureWithUnit for MagneticFluxMeasureWithUnit {
    fn value_component(&self) -> &MeasureValue {
        &self.value_component
    }
    fn unit_component(&self) -> &EntityRef {
        &self.unit_component
    }
}
impl IMagneticFluxMeasureWithUnit for MagneticFluxMeasureWithUnit {}
impl MagneticFluxMeasureWithUnit {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = MagneticFluxMeasureWithUnit::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.value_component = parameter.into(),
                1usize => entity.unit_component = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IMagneticFluxUnit: IDerivedUnit {}
#[derive(Default, Debug)]
pub struct MagneticFluxUnit {
    elements: HashSet<EntityRef>,
}
impl IDerivedUnit for MagneticFluxUnit {
    fn elements(&self) -> &HashSet<EntityRef> {
        &self.elements
    }
}
impl IMagneticFluxUnit for MagneticFluxUnit {}
impl MagneticFluxUnit {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = MagneticFluxUnit::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.elements = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IMakeFromUsageOption: IProductDefinitionUsage {
    fn ranking(&self) -> i64;
    fn ranking_rationale(&self) -> &Text;
    fn quantity(&self) -> &EntityRef;
}
#[derive(Default, Debug)]
pub struct MakeFromUsageOption {
    id: Identifier,
    name: Label,
    description: Option<Text>,
    relating_product_definition: EntityRef,
    related_product_definition: EntityRef,
    ranking: i64,
    ranking_rationale: Text,
    quantity: EntityRef,
}
impl IProductDefinitionRelationship for MakeFromUsageOption {
    fn id(&self) -> &Identifier {
        &self.id
    }
    fn name(&self) -> &Label {
        &self.name
    }
    fn description(&self) -> &Option<Text> {
        &self.description
    }
    fn relating_product_definition(&self) -> &EntityRef {
        &self.relating_product_definition
    }
    fn related_product_definition(&self) -> &EntityRef {
        &self.related_product_definition
    }
}
impl IProductDefinitionUsage for MakeFromUsageOption {}
impl IMakeFromUsageOption for MakeFromUsageOption {
    fn ranking(&self) -> i64 {
        self.ranking
    }
    fn ranking_rationale(&self) -> &Text {
        &self.ranking_rationale
    }
    fn quantity(&self) -> &EntityRef {
        &self.quantity
    }
}
impl MakeFromUsageOption {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = MakeFromUsageOption::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.id = parameter.into(),
                1usize => entity.name = parameter.into(),
                2usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => entity.relating_product_definition = parameter.into(),
                4usize => entity.related_product_definition = parameter.into(),
                5usize => entity.ranking = parameter.into(),
                6usize => entity.ranking_rationale = parameter.into(),
                7usize => entity.quantity = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IManifoldSolidBrep: ISolidModel {
    fn outer(&self) -> &EntityRef;
}
#[derive(Default, Debug)]
pub struct ManifoldSolidBrep {
    name: Label,
    outer: EntityRef,
}
impl IRepresentationItem for ManifoldSolidBrep {
    fn name(&self) -> &Label {
        &self.name
    }
}
impl IGeometricRepresentationItem for ManifoldSolidBrep {}
impl ISolidModel for ManifoldSolidBrep {}
impl IManifoldSolidBrep for ManifoldSolidBrep {
    fn outer(&self) -> &EntityRef {
        &self.outer
    }
}
impl ManifoldSolidBrep {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = ManifoldSolidBrep::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => entity.outer = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IManifoldSubsurfaceShapeRepresentation: IShapeRepresentation {}
#[derive(Default, Debug)]
pub struct ManifoldSubsurfaceShapeRepresentation {
    name: Label,
    items: HashSet<EntityRef>,
    context_of_items: EntityRef,
}
impl IRepresentation for ManifoldSubsurfaceShapeRepresentation {
    fn name(&self) -> &Label {
        &self.name
    }
    fn items(&self) -> &HashSet<EntityRef> {
        &self.items
    }
    fn context_of_items(&self) -> &EntityRef {
        &self.context_of_items
    }
}
impl IShapeRepresentation for ManifoldSubsurfaceShapeRepresentation {}
impl IManifoldSubsurfaceShapeRepresentation for ManifoldSubsurfaceShapeRepresentation {}
impl ManifoldSubsurfaceShapeRepresentation {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = ManifoldSubsurfaceShapeRepresentation::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => entity.items = parameter.into(),
                2usize => entity.context_of_items = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IManifoldSurfaceShapeRepresentation: IShapeRepresentation {}
#[derive(Default, Debug)]
pub struct ManifoldSurfaceShapeRepresentation {
    name: Label,
    items: HashSet<EntityRef>,
    context_of_items: EntityRef,
}
impl IRepresentation for ManifoldSurfaceShapeRepresentation {
    fn name(&self) -> &Label {
        &self.name
    }
    fn items(&self) -> &HashSet<EntityRef> {
        &self.items
    }
    fn context_of_items(&self) -> &EntityRef {
        &self.context_of_items
    }
}
impl IShapeRepresentation for ManifoldSurfaceShapeRepresentation {}
impl IManifoldSurfaceShapeRepresentation for ManifoldSurfaceShapeRepresentation {}
impl ManifoldSurfaceShapeRepresentation {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = ManifoldSurfaceShapeRepresentation::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => entity.items = parameter.into(),
                2usize => entity.context_of_items = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IMappedItem: IRepresentationItem {
    fn mapping_source(&self) -> &EntityRef;
    fn mapping_target(&self) -> &EntityRef;
}
#[derive(Default, Debug)]
pub struct MappedItem {
    name: Label,
    mapping_source: EntityRef,
    mapping_target: EntityRef,
}
impl IRepresentationItem for MappedItem {
    fn name(&self) -> &Label {
        &self.name
    }
}
impl IMappedItem for MappedItem {
    fn mapping_source(&self) -> &EntityRef {
        &self.mapping_source
    }
    fn mapping_target(&self) -> &EntityRef {
        &self.mapping_target
    }
}
impl MappedItem {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = MappedItem::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => entity.mapping_source = parameter.into(),
                2usize => entity.mapping_target = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IMassMeasureWithUnit: IMeasureWithUnit {}
#[derive(Default, Debug)]
pub struct MassMeasureWithUnit {
    value_component: MeasureValue,
    unit_component: EntityRef,
}
impl IMeasureWithUnit for MassMeasureWithUnit {
    fn value_component(&self) -> &MeasureValue {
        &self.value_component
    }
    fn unit_component(&self) -> &EntityRef {
        &self.unit_component
    }
}
impl IMassMeasureWithUnit for MassMeasureWithUnit {}
impl MassMeasureWithUnit {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = MassMeasureWithUnit::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.value_component = parameter.into(),
                1usize => entity.unit_component = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IMassUnit: INamedUnit {}
#[derive(Default, Debug)]
pub struct MassUnit {
    dimensions: EntityRef,
}
impl INamedUnit for MassUnit {
    fn dimensions(&self) -> &EntityRef {
        &self.dimensions
    }
}
impl IMassUnit for MassUnit {}
impl MassUnit {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = MassUnit::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.dimensions = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IMaterialDesignation {
    fn name(&self) -> &Label;
    fn definitions(&self) -> &HashSet<EntityRef>;
}
#[derive(Default, Debug)]
pub struct MaterialDesignation {
    name: Label,
    definitions: HashSet<EntityRef>,
}
impl IMaterialDesignation for MaterialDesignation {
    fn name(&self) -> &Label {
        &self.name
    }
    fn definitions(&self) -> &HashSet<EntityRef> {
        &self.definitions
    }
}
impl MaterialDesignation {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = MaterialDesignation::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => entity.definitions = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IMaterialDesignationCharacterization {
    fn name(&self) -> &Label;
    fn description(&self) -> &Text;
    fn designation(&self) -> &EntityRef;
    fn property(&self) -> &EntityRef;
}
#[derive(Default, Debug)]
pub struct MaterialDesignationCharacterization {
    name: Label,
    description: Text,
    designation: EntityRef,
    property: EntityRef,
}
impl IMaterialDesignationCharacterization for MaterialDesignationCharacterization {
    fn name(&self) -> &Label {
        &self.name
    }
    fn description(&self) -> &Text {
        &self.description
    }
    fn designation(&self) -> &EntityRef {
        &self.designation
    }
    fn property(&self) -> &EntityRef {
        &self.property
    }
}
impl MaterialDesignationCharacterization {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = MaterialDesignationCharacterization::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => entity.description = parameter.into(),
                2usize => entity.designation = parameter.into(),
                3usize => entity.property = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IMaterialProperty: IPropertyDefinition {}
#[derive(Default, Debug)]
pub struct MaterialProperty {
    name: Label,
    description: Option<Text>,
    definition: EntityRef,
}
impl IPropertyDefinition for MaterialProperty {
    fn name(&self) -> &Label {
        &self.name
    }
    fn description(&self) -> &Option<Text> {
        &self.description
    }
    fn definition(&self) -> &EntityRef {
        &self.definition
    }
}
impl IMaterialProperty for MaterialProperty {}
impl MaterialProperty {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = MaterialProperty::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => entity.definition = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IMaterialPropertyRepresentation: IPropertyDefinitionRepresentation {
    fn dependent_environment(&self) -> &EntityRef;
}
#[derive(Default, Debug)]
pub struct MaterialPropertyRepresentation {
    definition: EntityRef,
    used_representation: EntityRef,
    dependent_environment: EntityRef,
}
impl IPropertyDefinitionRepresentation for MaterialPropertyRepresentation {
    fn definition(&self) -> &EntityRef {
        &self.definition
    }
    fn used_representation(&self) -> &EntityRef {
        &self.used_representation
    }
}
impl IMaterialPropertyRepresentation for MaterialPropertyRepresentation {
    fn dependent_environment(&self) -> &EntityRef {
        &self.dependent_environment
    }
}
impl MaterialPropertyRepresentation {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = MaterialPropertyRepresentation::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.definition = parameter.into(),
                1usize => entity.used_representation = parameter.into(),
                2usize => entity.dependent_environment = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IMeasureQualification {
    fn name(&self) -> &Label;
    fn description(&self) -> &Text;
    fn qualified_measure(&self) -> &EntityRef;
    fn qualifiers(&self) -> &HashSet<EntityRef>;
}
#[derive(Default, Debug)]
pub struct MeasureQualification {
    name: Label,
    description: Text,
    qualified_measure: EntityRef,
    qualifiers: HashSet<EntityRef>,
}
impl IMeasureQualification for MeasureQualification {
    fn name(&self) -> &Label {
        &self.name
    }
    fn description(&self) -> &Text {
        &self.description
    }
    fn qualified_measure(&self) -> &EntityRef {
        &self.qualified_measure
    }
    fn qualifiers(&self) -> &HashSet<EntityRef> {
        &self.qualifiers
    }
}
impl MeasureQualification {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = MeasureQualification::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => entity.description = parameter.into(),
                2usize => entity.qualified_measure = parameter.into(),
                3usize => entity.qualifiers = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IMeasureRepresentationItem: IRepresentationItem + IMeasureWithUnit {}
#[derive(Default, Debug)]
pub struct MeasureRepresentationItem {
    name: Label,
    value_component: MeasureValue,
    unit_component: EntityRef,
}
impl IRepresentationItem for MeasureRepresentationItem {
    fn name(&self) -> &Label {
        &self.name
    }
}
impl IMeasureWithUnit for MeasureRepresentationItem {
    fn value_component(&self) -> &MeasureValue {
        &self.value_component
    }
    fn unit_component(&self) -> &EntityRef {
        &self.unit_component
    }
}
impl IMeasureRepresentationItem for MeasureRepresentationItem {}
impl MeasureRepresentationItem {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = MeasureRepresentationItem::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => entity.value_component = parameter.into(),
                2usize => entity.unit_component = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IMeasureWithUnit {
    fn value_component(&self) -> &MeasureValue;
    fn unit_component(&self) -> &EntityRef;
}
#[derive(Default, Debug)]
pub struct MeasureWithUnit {
    value_component: MeasureValue,
    unit_component: EntityRef,
}
impl IMeasureWithUnit for MeasureWithUnit {
    fn value_component(&self) -> &MeasureValue {
        &self.value_component
    }
    fn unit_component(&self) -> &EntityRef {
        &self.unit_component
    }
}
impl MeasureWithUnit {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = MeasureWithUnit::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.value_component = parameter.into(),
                1usize => entity.unit_component = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IMechanicalContext: IProductContext {}
#[derive(Default, Debug)]
pub struct MechanicalContext {
    name: Label,
    frame_of_reference: EntityRef,
    discipline_type: Label,
}
impl IApplicationContextElement for MechanicalContext {
    fn name(&self) -> &Label {
        &self.name
    }
    fn frame_of_reference(&self) -> &EntityRef {
        &self.frame_of_reference
    }
}
impl IProductContext for MechanicalContext {
    fn discipline_type(&self) -> &Label {
        &self.discipline_type
    }
}
impl IMechanicalContext for MechanicalContext {}
impl MechanicalContext {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = MechanicalContext::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => entity.frame_of_reference = parameter.into(),
                2usize => entity.discipline_type = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IMechanicalDesignAndDraughtingRelationship: IDefinitionalRepresentationRelationshipWithSameContext {
    fn rep_1(&self) -> &EntityRef;
    fn rep_2(&self) -> &EntityRef;
}
#[derive(Default, Debug)]
pub struct MechanicalDesignAndDraughtingRelationship {
    name: Label,
    description: Option<Text>,
    rep_1: EntityRef,
    rep_2: EntityRef,
}
impl IRepresentationRelationship for MechanicalDesignAndDraughtingRelationship {
    fn name(&self) -> &Label {
        &self.name
    }
    fn description(&self) -> &Option<Text> {
        &self.description
    }
    fn rep_1(&self) -> &EntityRef {
        &self.rep_1
    }
    fn rep_2(&self) -> &EntityRef {
        &self.rep_2
    }
}
impl IDefinitionalRepresentationRelationship for MechanicalDesignAndDraughtingRelationship {}
impl IDefinitionalRepresentationRelationshipWithSameContext for MechanicalDesignAndDraughtingRelationship {}
impl IMechanicalDesignAndDraughtingRelationship for MechanicalDesignAndDraughtingRelationship {
    fn rep_1(&self) -> &EntityRef {
        &self.rep_1
    }
    fn rep_2(&self) -> &EntityRef {
        &self.rep_2
    }
}
impl MechanicalDesignAndDraughtingRelationship {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = MechanicalDesignAndDraughtingRelationship::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => entity.rep_1 = parameter.into(),
                3usize => entity.rep_2 = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IMechanicalDesignGeometricPresentationArea: IPresentationArea {
    fn items(&self) -> &HashSet<EntityRef>;
}
#[derive(Default, Debug)]
pub struct MechanicalDesignGeometricPresentationArea {
    name: Label,
    context_of_items: EntityRef,
    items: HashSet<EntityRef>,
}
impl IRepresentation for MechanicalDesignGeometricPresentationArea {
    fn name(&self) -> &Label {
        &self.name
    }
    fn items(&self) -> &HashSet<EntityRef> {
        &self.items
    }
    fn context_of_items(&self) -> &EntityRef {
        &self.context_of_items
    }
}
impl IPresentationRepresentation for MechanicalDesignGeometricPresentationArea {
    fn context_of_items(&self) -> &EntityRef {
        &self.context_of_items
    }
}
impl IPresentationArea for MechanicalDesignGeometricPresentationArea {}
impl IMechanicalDesignGeometricPresentationArea for MechanicalDesignGeometricPresentationArea {
    fn items(&self) -> &HashSet<EntityRef> {
        &self.items
    }
}
impl MechanicalDesignGeometricPresentationArea {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = MechanicalDesignGeometricPresentationArea::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => entity.context_of_items = parameter.into(),
                2usize => entity.items = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IMechanicalDesignGeometricPresentationRepresentation: IRepresentation {
    fn items(&self) -> &HashSet<EntityRef>;
}
#[derive(Default, Debug)]
pub struct MechanicalDesignGeometricPresentationRepresentation {
    name: Label,
    context_of_items: EntityRef,
    items: HashSet<EntityRef>,
}
impl IRepresentation for MechanicalDesignGeometricPresentationRepresentation {
    fn name(&self) -> &Label {
        &self.name
    }
    fn items(&self) -> &HashSet<EntityRef> {
        &self.items
    }
    fn context_of_items(&self) -> &EntityRef {
        &self.context_of_items
    }
}
impl IMechanicalDesignGeometricPresentationRepresentation for MechanicalDesignGeometricPresentationRepresentation {
    fn items(&self) -> &HashSet<EntityRef> {
        &self.items
    }
}
impl MechanicalDesignGeometricPresentationRepresentation {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = MechanicalDesignGeometricPresentationRepresentation::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => entity.context_of_items = parameter.into(),
                2usize => entity.items = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IMechanicalDesignPresentationRepresentationWithDraughting: IRepresentation {
    fn items(&self) -> &HashSet<EntityRef>;
}
#[derive(Default, Debug)]
pub struct MechanicalDesignPresentationRepresentationWithDraughting {
    name: Label,
    context_of_items: EntityRef,
    items: HashSet<EntityRef>,
}
impl IRepresentation for MechanicalDesignPresentationRepresentationWithDraughting {
    fn name(&self) -> &Label {
        &self.name
    }
    fn items(&self) -> &HashSet<EntityRef> {
        &self.items
    }
    fn context_of_items(&self) -> &EntityRef {
        &self.context_of_items
    }
}
impl IMechanicalDesignPresentationRepresentationWithDraughting
    for MechanicalDesignPresentationRepresentationWithDraughting
{
    fn items(&self) -> &HashSet<EntityRef> {
        &self.items
    }
}
impl MechanicalDesignPresentationRepresentationWithDraughting {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = MechanicalDesignPresentationRepresentationWithDraughting::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => entity.context_of_items = parameter.into(),
                2usize => entity.items = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IMechanicalDesignShadedPresentationArea: IPresentationArea {}
#[derive(Default, Debug)]
pub struct MechanicalDesignShadedPresentationArea {
    name: Label,
    items: HashSet<EntityRef>,
    context_of_items: EntityRef,
}
impl IRepresentation for MechanicalDesignShadedPresentationArea {
    fn name(&self) -> &Label {
        &self.name
    }
    fn items(&self) -> &HashSet<EntityRef> {
        &self.items
    }
    fn context_of_items(&self) -> &EntityRef {
        &self.context_of_items
    }
}
impl IPresentationRepresentation for MechanicalDesignShadedPresentationArea {
    fn context_of_items(&self) -> &EntityRef {
        &self.context_of_items
    }
}
impl IPresentationArea for MechanicalDesignShadedPresentationArea {}
impl IMechanicalDesignShadedPresentationArea for MechanicalDesignShadedPresentationArea {}
impl MechanicalDesignShadedPresentationArea {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = MechanicalDesignShadedPresentationArea::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => entity.items = parameter.into(),
                2usize => entity.context_of_items = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IMechanicalDesignShadedPresentationRepresentation: IRepresentation {}
#[derive(Default, Debug)]
pub struct MechanicalDesignShadedPresentationRepresentation {
    name: Label,
    items: HashSet<EntityRef>,
    context_of_items: EntityRef,
}
impl IRepresentation for MechanicalDesignShadedPresentationRepresentation {
    fn name(&self) -> &Label {
        &self.name
    }
    fn items(&self) -> &HashSet<EntityRef> {
        &self.items
    }
    fn context_of_items(&self) -> &EntityRef {
        &self.context_of_items
    }
}
impl IMechanicalDesignShadedPresentationRepresentation for MechanicalDesignShadedPresentationRepresentation {}
impl MechanicalDesignShadedPresentationRepresentation {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = MechanicalDesignShadedPresentationRepresentation::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => entity.items = parameter.into(),
                2usize => entity.context_of_items = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IMinAndMajorPlyOrientationBasis: IRepresentationItemRelationship + IGeometricRepresentationItem {
    fn related_representation_item(&self) -> &EntityRef;
    fn relating_representation_item(&self) -> &EntityRef;
}
#[derive(Default, Debug)]
pub struct MinAndMajorPlyOrientationBasis {
    name: Label,
    description: Option<Text>,
    related_representation_item: EntityRef,
    relating_representation_item: EntityRef,
}
impl IRepresentationItemRelationship for MinAndMajorPlyOrientationBasis {
    fn name(&self) -> &Label {
        &self.name
    }
    fn description(&self) -> &Option<Text> {
        &self.description
    }
    fn relating_representation_item(&self) -> &EntityRef {
        &self.relating_representation_item
    }
    fn related_representation_item(&self) -> &EntityRef {
        &self.related_representation_item
    }
}
impl IRepresentationItem for MinAndMajorPlyOrientationBasis {
    fn name(&self) -> &Label {
        &self.name
    }
}
impl IGeometricRepresentationItem for MinAndMajorPlyOrientationBasis {}
impl IMinAndMajorPlyOrientationBasis for MinAndMajorPlyOrientationBasis {
    fn related_representation_item(&self) -> &EntityRef {
        &self.related_representation_item
    }
    fn relating_representation_item(&self) -> &EntityRef {
        &self.relating_representation_item
    }
}
impl MinAndMajorPlyOrientationBasis {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = MinAndMajorPlyOrientationBasis::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => entity.related_representation_item = parameter.into(),
                3usize => entity.relating_representation_item = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IModifiedGeometricTolerance: IGeometricTolerance {
    fn modifier(&self) -> &LimitCondition;
}
#[derive(Default, Debug)]
pub struct ModifiedGeometricTolerance {
    name: Label,
    description: Text,
    magnitude: EntityRef,
    toleranced_shape_aspect: EntityRef,
    modifier: LimitCondition,
}
impl IGeometricTolerance for ModifiedGeometricTolerance {
    fn name(&self) -> &Label {
        &self.name
    }
    fn description(&self) -> &Text {
        &self.description
    }
    fn magnitude(&self) -> &EntityRef {
        &self.magnitude
    }
    fn toleranced_shape_aspect(&self) -> &EntityRef {
        &self.toleranced_shape_aspect
    }
}
impl IModifiedGeometricTolerance for ModifiedGeometricTolerance {
    fn modifier(&self) -> &LimitCondition {
        &self.modifier
    }
}
impl ModifiedGeometricTolerance {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = ModifiedGeometricTolerance::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => entity.description = parameter.into(),
                2usize => entity.magnitude = parameter.into(),
                3usize => entity.toleranced_shape_aspect = parameter.into(),
                4usize => entity.modifier = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IModifiedSolid: ISolidModel {
    fn rationale(&self) -> &Text;
    fn base_solid(&self) -> &EntityRef;
}
pub trait IModifiedSolidWithPlacedConfiguration: IModifiedSolid {
    fn placing(&self) -> &EntityRef;
}
pub trait IMomentsOfInertiaRepresentation: IRepresentation {}
#[derive(Default, Debug)]
pub struct MomentsOfInertiaRepresentation {
    name: Label,
    items: HashSet<EntityRef>,
    context_of_items: EntityRef,
}
impl IRepresentation for MomentsOfInertiaRepresentation {
    fn name(&self) -> &Label {
        &self.name
    }
    fn items(&self) -> &HashSet<EntityRef> {
        &self.items
    }
    fn context_of_items(&self) -> &EntityRef {
        &self.context_of_items
    }
}
impl IMomentsOfInertiaRepresentation for MomentsOfInertiaRepresentation {}
impl MomentsOfInertiaRepresentation {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = MomentsOfInertiaRepresentation::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => entity.items = parameter.into(),
                2usize => entity.context_of_items = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IMultiLanguageAttributeAssignment: IAttributeValueAssignment {
    fn items(&self) -> &HashSet<EntityRef>;
}
#[derive(Default, Debug)]
pub struct MultiLanguageAttributeAssignment {
    attribute_name: Label,
    attribute_value: AttributeType,
    role: EntityRef,
    items: HashSet<EntityRef>,
}
impl IAttributeValueAssignment for MultiLanguageAttributeAssignment {
    fn attribute_name(&self) -> &Label {
        &self.attribute_name
    }
    fn attribute_value(&self) -> &AttributeType {
        &self.attribute_value
    }
    fn role(&self) -> &EntityRef {
        &self.role
    }
}
impl IMultiLanguageAttributeAssignment for MultiLanguageAttributeAssignment {
    fn items(&self) -> &HashSet<EntityRef> {
        &self.items
    }
}
impl MultiLanguageAttributeAssignment {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = MultiLanguageAttributeAssignment::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.attribute_name = parameter.into(),
                1usize => entity.attribute_value = parameter.into(),
                2usize => entity.role = parameter.into(),
                3usize => entity.items = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IMultipleArityBooleanExpression: IBooleanExpression + IMultipleArityGenericExpression {
    fn operands(&self) -> &Vec<EntityRef>;
}
pub trait IMultipleArityGenericExpression: IGenericExpression {
    fn operands(&self) -> &Vec<EntityRef>;
}
pub trait IMultipleArityNumericExpression: INumericExpression + IMultipleArityGenericExpression {
    fn operands(&self) -> &Vec<EntityRef>;
}
pub trait INameAssignment {
    fn assigned_name(&self) -> &Label;
}
pub trait INameAttribute {
    fn attribute_value(&self) -> &Label;
    fn named_item(&self) -> &EntityRef;
}
#[derive(Default, Debug)]
pub struct NameAttribute {
    attribute_value: Label,
    named_item: EntityRef,
}
impl INameAttribute for NameAttribute {
    fn attribute_value(&self) -> &Label {
        &self.attribute_value
    }
    fn named_item(&self) -> &EntityRef {
        &self.named_item
    }
}
impl NameAttribute {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = NameAttribute::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.attribute_value = parameter.into(),
                1usize => entity.named_item = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait INamedUnit {
    fn dimensions(&self) -> &EntityRef;
}
#[derive(Default, Debug)]
pub struct NamedUnit {
    dimensions: EntityRef,
}
impl INamedUnit for NamedUnit {
    fn dimensions(&self) -> &EntityRef {
        &self.dimensions
    }
}
impl NamedUnit {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = NamedUnit::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.dimensions = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait INextAssemblyUsageOccurrence: IAssemblyComponentUsage {}
#[derive(Default, Debug)]
pub struct NextAssemblyUsageOccurrence {
    id: Identifier,
    name: Label,
    description: Option<Text>,
    relating_product_definition: EntityRef,
    related_product_definition: EntityRef,
    reference_designator: Option<Identifier>,
}
impl IProductDefinitionRelationship for NextAssemblyUsageOccurrence {
    fn id(&self) -> &Identifier {
        &self.id
    }
    fn name(&self) -> &Label {
        &self.name
    }
    fn description(&self) -> &Option<Text> {
        &self.description
    }
    fn relating_product_definition(&self) -> &EntityRef {
        &self.relating_product_definition
    }
    fn related_product_definition(&self) -> &EntityRef {
        &self.related_product_definition
    }
}
impl IProductDefinitionUsage for NextAssemblyUsageOccurrence {}
impl IAssemblyComponentUsage for NextAssemblyUsageOccurrence {
    fn reference_designator(&self) -> &Option<Identifier> {
        &self.reference_designator
    }
}
impl INextAssemblyUsageOccurrence for NextAssemblyUsageOccurrence {}
impl NextAssemblyUsageOccurrence {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = NextAssemblyUsageOccurrence::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.id = parameter.into(),
                1usize => entity.name = parameter.into(),
                2usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => entity.relating_product_definition = parameter.into(),
                4usize => entity.related_product_definition = parameter.into(),
                5usize => {
                    entity.reference_designator = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
}
pub trait INonManifoldSurfaceShapeRepresentation: IShapeRepresentation {}
#[derive(Default, Debug)]
pub struct NonManifoldSurfaceShapeRepresentation {
    name: Label,
    items: HashSet<EntityRef>,
    context_of_items: EntityRef,
}
impl IRepresentation for NonManifoldSurfaceShapeRepresentation {
    fn name(&self) -> &Label {
        &self.name
    }
    fn items(&self) -> &HashSet<EntityRef> {
        &self.items
    }
    fn context_of_items(&self) -> &EntityRef {
        &self.context_of_items
    }
}
impl IShapeRepresentation for NonManifoldSurfaceShapeRepresentation {}
impl INonManifoldSurfaceShapeRepresentation for NonManifoldSurfaceShapeRepresentation {}
impl NonManifoldSurfaceShapeRepresentation {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = NonManifoldSurfaceShapeRepresentation::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => entity.items = parameter.into(),
                2usize => entity.context_of_items = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait INullRepresentationItem: IRepresentationItem {}
#[derive(Default, Debug)]
pub struct NullRepresentationItem {
    name: Label,
}
impl IRepresentationItem for NullRepresentationItem {
    fn name(&self) -> &Label {
        &self.name
    }
}
impl INullRepresentationItem for NullRepresentationItem {}
impl NullRepresentationItem {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = NullRepresentationItem::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait INumericExpression: IExpression {}
pub trait IObjectRole {
    fn name(&self) -> &Label;
    fn description(&self) -> &Option<Text>;
}
#[derive(Default, Debug)]
pub struct ObjectRole {
    name: Label,
    description: Option<Text>,
}
impl IObjectRole for ObjectRole {
    fn name(&self) -> &Label {
        &self.name
    }
    fn description(&self) -> &Option<Text> {
        &self.description
    }
}
impl ObjectRole {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = ObjectRole::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
}
pub trait IOffsetCurve2d: ICurve {
    fn basis_curve(&self) -> &EntityRef;
    fn distance(&self) -> &LengthMeasure;
    fn self_intersect(&self) -> Option<bool>;
}
#[derive(Default, Debug)]
pub struct OffsetCurve2d {
    name: Label,
    basis_curve: EntityRef,
    distance: LengthMeasure,
    self_intersect: Option<bool>,
}
impl IRepresentationItem for OffsetCurve2d {
    fn name(&self) -> &Label {
        &self.name
    }
}
impl IGeometricRepresentationItem for OffsetCurve2d {}
impl ICurve for OffsetCurve2d {}
impl IOffsetCurve2d for OffsetCurve2d {
    fn basis_curve(&self) -> &EntityRef {
        &self.basis_curve
    }
    fn distance(&self) -> &LengthMeasure {
        &self.distance
    }
    fn self_intersect(&self) -> Option<bool> {
        self.self_intersect
    }
}
impl OffsetCurve2d {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = OffsetCurve2d::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => entity.basis_curve = parameter.into(),
                2usize => entity.distance = parameter.into(),
                3usize => entity.self_intersect = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IOffsetCurve3d: ICurve {
    fn basis_curve(&self) -> &EntityRef;
    fn distance(&self) -> &LengthMeasure;
    fn self_intersect(&self) -> Option<bool>;
    fn ref_direction(&self) -> &EntityRef;
}
#[derive(Default, Debug)]
pub struct OffsetCurve3d {
    name: Label,
    basis_curve: EntityRef,
    distance: LengthMeasure,
    self_intersect: Option<bool>,
    ref_direction: EntityRef,
}
impl IRepresentationItem for OffsetCurve3d {
    fn name(&self) -> &Label {
        &self.name
    }
}
impl IGeometricRepresentationItem for OffsetCurve3d {}
impl ICurve for OffsetCurve3d {}
impl IOffsetCurve3d for OffsetCurve3d {
    fn basis_curve(&self) -> &EntityRef {
        &self.basis_curve
    }
    fn distance(&self) -> &LengthMeasure {
        &self.distance
    }
    fn self_intersect(&self) -> Option<bool> {
        self.self_intersect
    }
    fn ref_direction(&self) -> &EntityRef {
        &self.ref_direction
    }
}
impl OffsetCurve3d {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = OffsetCurve3d::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => entity.basis_curve = parameter.into(),
                2usize => entity.distance = parameter.into(),
                3usize => entity.self_intersect = parameter.into(),
                4usize => entity.ref_direction = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IOffsetSurface: ISurface {
    fn basis_surface(&self) -> &EntityRef;
    fn distance(&self) -> &LengthMeasure;
    fn self_intersect(&self) -> Option<bool>;
}
#[derive(Default, Debug)]
pub struct OffsetSurface {
    name: Label,
    basis_surface: EntityRef,
    distance: LengthMeasure,
    self_intersect: Option<bool>,
}
impl IRepresentationItem for OffsetSurface {
    fn name(&self) -> &Label {
        &self.name
    }
}
impl IGeometricRepresentationItem for OffsetSurface {}
impl ISurface for OffsetSurface {}
impl IOffsetSurface for OffsetSurface {
    fn basis_surface(&self) -> &EntityRef {
        &self.basis_surface
    }
    fn distance(&self) -> &LengthMeasure {
        &self.distance
    }
    fn self_intersect(&self) -> Option<bool> {
        self.self_intersect
    }
}
impl OffsetSurface {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = OffsetSurface::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => entity.basis_surface = parameter.into(),
                2usize => entity.distance = parameter.into(),
                3usize => entity.self_intersect = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IOneDirectionRepeatFactor: IGeometricRepresentationItem {
    fn repeat_factor(&self) -> &EntityRef;
}
#[derive(Default, Debug)]
pub struct OneDirectionRepeatFactor {
    name: Label,
    repeat_factor: EntityRef,
}
impl IRepresentationItem for OneDirectionRepeatFactor {
    fn name(&self) -> &Label {
        &self.name
    }
}
impl IGeometricRepresentationItem for OneDirectionRepeatFactor {}
impl IOneDirectionRepeatFactor for OneDirectionRepeatFactor {
    fn repeat_factor(&self) -> &EntityRef {
        &self.repeat_factor
    }
}
impl OneDirectionRepeatFactor {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = OneDirectionRepeatFactor::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => entity.repeat_factor = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IOpenShell: IConnectedFaceSet {}
#[derive(Default, Debug)]
pub struct OpenShell {
    name: Label,
    cfs_faces: HashSet<EntityRef>,
}
impl IRepresentationItem for OpenShell {
    fn name(&self) -> &Label {
        &self.name
    }
}
impl ITopologicalRepresentationItem for OpenShell {}
impl IConnectedFaceSet for OpenShell {
    fn cfs_faces(&self) -> &HashSet<EntityRef> {
        &self.cfs_faces
    }
}
impl IOpenShell for OpenShell {}
impl OpenShell {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = OpenShell::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => entity.cfs_faces = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IOrdinalDate: IDate {
    fn day_component(&self) -> &DayInYearNumber;
}
#[derive(Default, Debug)]
pub struct OrdinalDate {
    year_component: YearNumber,
    day_component: DayInYearNumber,
}
impl IDate for OrdinalDate {
    fn year_component(&self) -> &YearNumber {
        &self.year_component
    }
}
impl IOrdinalDate for OrdinalDate {
    fn day_component(&self) -> &DayInYearNumber {
        &self.day_component
    }
}
impl OrdinalDate {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = OrdinalDate::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.year_component = parameter.into(),
                1usize => entity.day_component = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IOrdinateDimension: IProjectionDirectedCallout {}
#[derive(Default, Debug)]
pub struct OrdinateDimension {
    name: Label,
    contents: HashSet<EntityRef>,
}
impl IRepresentationItem for OrdinateDimension {
    fn name(&self) -> &Label {
        &self.name
    }
}
impl IGeometricRepresentationItem for OrdinateDimension {}
impl IDraughtingCallout for OrdinateDimension {
    fn contents(&self) -> &HashSet<EntityRef> {
        &self.contents
    }
}
impl IProjectionDirectedCallout for OrdinateDimension {}
impl IOrdinateDimension for OrdinateDimension {}
impl OrdinateDimension {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = OrdinateDimension::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => entity.contents = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IOrganization {
    fn id(&self) -> &Option<Identifier>;
    fn name(&self) -> &Label;
    fn description(&self) -> &Option<Text>;
}
#[derive(Default, Debug)]
pub struct Organization {
    id: Option<Identifier>,
    name: Label,
    description: Option<Text>,
}
impl IOrganization for Organization {
    fn id(&self) -> &Option<Identifier> {
        &self.id
    }
    fn name(&self) -> &Label {
        &self.name
    }
    fn description(&self) -> &Option<Text> {
        &self.description
    }
}
impl Organization {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = Organization::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => {
                    entity.id = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                1usize => entity.name = parameter.into(),
                2usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
}
pub trait IOrganizationAssignment {
    fn assigned_organization(&self) -> &EntityRef;
    fn role(&self) -> &EntityRef;
}
pub trait IOrganizationRelationship {
    fn name(&self) -> &Label;
    fn description(&self) -> &Option<Text>;
    fn relating_organization(&self) -> &EntityRef;
    fn related_organization(&self) -> &EntityRef;
}
#[derive(Default, Debug)]
pub struct OrganizationRelationship {
    name: Label,
    description: Option<Text>,
    relating_organization: EntityRef,
    related_organization: EntityRef,
}
impl IOrganizationRelationship for OrganizationRelationship {
    fn name(&self) -> &Label {
        &self.name
    }
    fn description(&self) -> &Option<Text> {
        &self.description
    }
    fn relating_organization(&self) -> &EntityRef {
        &self.relating_organization
    }
    fn related_organization(&self) -> &EntityRef {
        &self.related_organization
    }
}
impl OrganizationRelationship {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = OrganizationRelationship::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => entity.relating_organization = parameter.into(),
                3usize => entity.related_organization = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IOrganizationRole {
    fn name(&self) -> &Label;
}
#[derive(Default, Debug)]
pub struct OrganizationRole {
    name: Label,
}
impl IOrganizationRole for OrganizationRole {
    fn name(&self) -> &Label {
        &self.name
    }
}
impl OrganizationRole {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = OrganizationRole::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IOrganizationalAddress: IAddress {
    fn organizations(&self) -> &HashSet<EntityRef>;
    fn description(&self) -> &Option<Text>;
}
#[derive(Default, Debug)]
pub struct OrganizationalAddress {
    internal_location: Option<Label>,
    street_number: Option<Label>,
    street: Option<Label>,
    postal_box: Option<Label>,
    town: Option<Label>,
    region: Option<Label>,
    postal_code: Option<Label>,
    country: Option<Label>,
    facsimile_number: Option<Label>,
    telephone_number: Option<Label>,
    electronic_mail_address: Option<Label>,
    telex_number: Option<Label>,
    organizations: HashSet<EntityRef>,
    description: Option<Text>,
}
impl IAddress for OrganizationalAddress {
    fn internal_location(&self) -> &Option<Label> {
        &self.internal_location
    }
    fn street_number(&self) -> &Option<Label> {
        &self.street_number
    }
    fn street(&self) -> &Option<Label> {
        &self.street
    }
    fn postal_box(&self) -> &Option<Label> {
        &self.postal_box
    }
    fn town(&self) -> &Option<Label> {
        &self.town
    }
    fn region(&self) -> &Option<Label> {
        &self.region
    }
    fn postal_code(&self) -> &Option<Label> {
        &self.postal_code
    }
    fn country(&self) -> &Option<Label> {
        &self.country
    }
    fn facsimile_number(&self) -> &Option<Label> {
        &self.facsimile_number
    }
    fn telephone_number(&self) -> &Option<Label> {
        &self.telephone_number
    }
    fn electronic_mail_address(&self) -> &Option<Label> {
        &self.electronic_mail_address
    }
    fn telex_number(&self) -> &Option<Label> {
        &self.telex_number
    }
}
impl IOrganizationalAddress for OrganizationalAddress {
    fn organizations(&self) -> &HashSet<EntityRef> {
        &self.organizations
    }
    fn description(&self) -> &Option<Text> {
        &self.description
    }
}
impl OrganizationalAddress {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = OrganizationalAddress::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => {
                    entity.internal_location = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                1usize => {
                    entity.street_number = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => {
                    entity.street = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.postal_box = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => {
                    entity.town = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                5usize => {
                    entity.region = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                6usize => {
                    entity.postal_code = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                7usize => {
                    entity.country = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                8usize => {
                    entity.facsimile_number = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                9usize => {
                    entity.telephone_number = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                10usize => {
                    entity.electronic_mail_address = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                11usize => {
                    entity.telex_number = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                12usize => entity.organizations = parameter.into(),
                13usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
}
pub trait IOrganizationalProject {
    fn name(&self) -> &Label;
    fn description(&self) -> &Option<Text>;
    fn responsible_organizations(&self) -> &HashSet<EntityRef>;
}
#[derive(Default, Debug)]
pub struct OrganizationalProject {
    name: Label,
    description: Option<Text>,
    responsible_organizations: HashSet<EntityRef>,
}
impl IOrganizationalProject for OrganizationalProject {
    fn name(&self) -> &Label {
        &self.name
    }
    fn description(&self) -> &Option<Text> {
        &self.description
    }
    fn responsible_organizations(&self) -> &HashSet<EntityRef> {
        &self.responsible_organizations
    }
}
impl OrganizationalProject {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = OrganizationalProject::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => entity.responsible_organizations = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IOrganizationalProjectAssignment {
    fn assigned_organizational_project(&self) -> &EntityRef;
    fn role(&self) -> &EntityRef;
}
pub trait IOrganizationalProjectRelationship {
    fn name(&self) -> &Label;
    fn description(&self) -> &Option<Text>;
    fn relating_organizational_project(&self) -> &EntityRef;
    fn related_organizational_project(&self) -> &EntityRef;
}
#[derive(Default, Debug)]
pub struct OrganizationalProjectRelationship {
    name: Label,
    description: Option<Text>,
    relating_organizational_project: EntityRef,
    related_organizational_project: EntityRef,
}
impl IOrganizationalProjectRelationship for OrganizationalProjectRelationship {
    fn name(&self) -> &Label {
        &self.name
    }
    fn description(&self) -> &Option<Text> {
        &self.description
    }
    fn relating_organizational_project(&self) -> &EntityRef {
        &self.relating_organizational_project
    }
    fn related_organizational_project(&self) -> &EntityRef {
        &self.related_organizational_project
    }
}
impl OrganizationalProjectRelationship {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = OrganizationalProjectRelationship::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => entity.relating_organizational_project = parameter.into(),
                3usize => entity.related_organizational_project = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IOrganizationalProjectRole {
    fn name(&self) -> &Label;
    fn description(&self) -> &Option<Text>;
}
#[derive(Default, Debug)]
pub struct OrganizationalProjectRole {
    name: Label,
    description: Option<Text>,
}
impl IOrganizationalProjectRole for OrganizationalProjectRole {
    fn name(&self) -> &Label {
        &self.name
    }
    fn description(&self) -> &Option<Text> {
        &self.description
    }
}
impl OrganizationalProjectRole {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = OrganizationalProjectRole::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
}
pub trait IOrientedClosedShell: IClosedShell {
    fn closed_shell_element(&self) -> &EntityRef;
    fn orientation(&self) -> bool;
}
#[derive(Default, Debug)]
pub struct OrientedClosedShell {
    name: Label,
    cfs_faces: HashSet<EntityRef>,
    closed_shell_element: EntityRef,
    orientation: bool,
}
impl IRepresentationItem for OrientedClosedShell {
    fn name(&self) -> &Label {
        &self.name
    }
}
impl ITopologicalRepresentationItem for OrientedClosedShell {}
impl IConnectedFaceSet for OrientedClosedShell {
    fn cfs_faces(&self) -> &HashSet<EntityRef> {
        &self.cfs_faces
    }
}
impl IClosedShell for OrientedClosedShell {}
impl IOrientedClosedShell for OrientedClosedShell {
    fn closed_shell_element(&self) -> &EntityRef {
        &self.closed_shell_element
    }
    fn orientation(&self) -> bool {
        self.orientation
    }
}
impl OrientedClosedShell {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = OrientedClosedShell::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => entity.cfs_faces = parameter.into(),
                2usize => entity.closed_shell_element = parameter.into(),
                3usize => entity.orientation = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IOrientedEdge: IEdge {
    fn edge_element(&self) -> &EntityRef;
    fn orientation(&self) -> bool;
}
#[derive(Default, Debug)]
pub struct OrientedEdge {
    name: Label,
    edge_start: EntityRef,
    edge_end: EntityRef,
    edge_element: EntityRef,
    orientation: bool,
}
impl IRepresentationItem for OrientedEdge {
    fn name(&self) -> &Label {
        &self.name
    }
}
impl ITopologicalRepresentationItem for OrientedEdge {}
impl IEdge for OrientedEdge {
    fn edge_start(&self) -> &EntityRef {
        &self.edge_start
    }
    fn edge_end(&self) -> &EntityRef {
        &self.edge_end
    }
}
impl IOrientedEdge for OrientedEdge {
    fn edge_element(&self) -> &EntityRef {
        &self.edge_element
    }
    fn orientation(&self) -> bool {
        self.orientation
    }
}
impl OrientedEdge {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = OrientedEdge::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => entity.edge_start = parameter.into(),
                2usize => entity.edge_end = parameter.into(),
                3usize => entity.edge_element = parameter.into(),
                4usize => entity.orientation = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IOrientedFace: IFace {
    fn face_element(&self) -> &EntityRef;
    fn orientation(&self) -> bool;
}
#[derive(Default, Debug)]
pub struct OrientedFace {
    name: Label,
    bounds: HashSet<EntityRef>,
    face_element: EntityRef,
    orientation: bool,
}
impl IRepresentationItem for OrientedFace {
    fn name(&self) -> &Label {
        &self.name
    }
}
impl ITopologicalRepresentationItem for OrientedFace {}
impl IFace for OrientedFace {
    fn bounds(&self) -> &HashSet<EntityRef> {
        &self.bounds
    }
}
impl IOrientedFace for OrientedFace {
    fn face_element(&self) -> &EntityRef {
        &self.face_element
    }
    fn orientation(&self) -> bool {
        self.orientation
    }
}
impl OrientedFace {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = OrientedFace::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => entity.bounds = parameter.into(),
                2usize => entity.face_element = parameter.into(),
                3usize => entity.orientation = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IOrientedOpenShell: IOpenShell {
    fn open_shell_element(&self) -> &EntityRef;
    fn orientation(&self) -> bool;
}
#[derive(Default, Debug)]
pub struct OrientedOpenShell {
    name: Label,
    cfs_faces: HashSet<EntityRef>,
    open_shell_element: EntityRef,
    orientation: bool,
}
impl IRepresentationItem for OrientedOpenShell {
    fn name(&self) -> &Label {
        &self.name
    }
}
impl ITopologicalRepresentationItem for OrientedOpenShell {}
impl IConnectedFaceSet for OrientedOpenShell {
    fn cfs_faces(&self) -> &HashSet<EntityRef> {
        &self.cfs_faces
    }
}
impl IOpenShell for OrientedOpenShell {}
impl IOrientedOpenShell for OrientedOpenShell {
    fn open_shell_element(&self) -> &EntityRef {
        &self.open_shell_element
    }
    fn orientation(&self) -> bool {
        self.orientation
    }
}
impl OrientedOpenShell {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = OrientedOpenShell::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => entity.cfs_faces = parameter.into(),
                2usize => entity.open_shell_element = parameter.into(),
                3usize => entity.orientation = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IOrientedPath: IPath {
    fn path_element(&self) -> &EntityRef;
    fn orientation(&self) -> bool;
}
#[derive(Default, Debug)]
pub struct OrientedPath {
    name: Label,
    edge_list: Vec<EntityRef>,
    path_element: EntityRef,
    orientation: bool,
}
impl IRepresentationItem for OrientedPath {
    fn name(&self) -> &Label {
        &self.name
    }
}
impl ITopologicalRepresentationItem for OrientedPath {}
impl IPath for OrientedPath {
    fn edge_list(&self) -> &Vec<EntityRef> {
        &self.edge_list
    }
}
impl IOrientedPath for OrientedPath {
    fn path_element(&self) -> &EntityRef {
        &self.path_element
    }
    fn orientation(&self) -> bool {
        self.orientation
    }
}
impl OrientedPath {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = OrientedPath::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => entity.edge_list = parameter.into(),
                2usize => entity.path_element = parameter.into(),
                3usize => entity.orientation = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IOrientedSurface: ISurface {
    fn orientation(&self) -> bool;
}
#[derive(Default, Debug)]
pub struct OrientedSurface {
    name: Label,
    orientation: bool,
}
impl IRepresentationItem for OrientedSurface {
    fn name(&self) -> &Label {
        &self.name
    }
}
impl IGeometricRepresentationItem for OrientedSurface {}
impl ISurface for OrientedSurface {}
impl IOrientedSurface for OrientedSurface {
    fn orientation(&self) -> bool {
        self.orientation
    }
}
impl OrientedSurface {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = OrientedSurface::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => entity.orientation = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IOuterBoundaryCurve: IBoundaryCurve {}
#[derive(Default, Debug)]
pub struct OuterBoundaryCurve {
    name: Label,
    segments: Vec<EntityRef>,
    self_intersect: Option<bool>,
}
impl IRepresentationItem for OuterBoundaryCurve {
    fn name(&self) -> &Label {
        &self.name
    }
}
impl IGeometricRepresentationItem for OuterBoundaryCurve {}
impl ICurve for OuterBoundaryCurve {}
impl IBoundedCurve for OuterBoundaryCurve {}
impl ICompositeCurve for OuterBoundaryCurve {
    fn segments(&self) -> &Vec<EntityRef> {
        &self.segments
    }
    fn self_intersect(&self) -> Option<bool> {
        self.self_intersect
    }
}
impl ICompositeCurveOnSurface for OuterBoundaryCurve {}
impl IBoundaryCurve for OuterBoundaryCurve {}
impl IOuterBoundaryCurve for OuterBoundaryCurve {}
impl OuterBoundaryCurve {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = OuterBoundaryCurve::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => entity.segments = parameter.into(),
                2usize => entity.self_intersect = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IOverRidingStyledItem: IStyledItem {
    fn over_ridden_style(&self) -> &EntityRef;
}
#[derive(Default, Debug)]
pub struct OverRidingStyledItem {
    name: Label,
    styles: HashSet<EntityRef>,
    item: EntityRef,
    over_ridden_style: EntityRef,
}
impl IRepresentationItem for OverRidingStyledItem {
    fn name(&self) -> &Label {
        &self.name
    }
}
impl IStyledItem for OverRidingStyledItem {
    fn styles(&self) -> &HashSet<EntityRef> {
        &self.styles
    }
    fn item(&self) -> &EntityRef {
        &self.item
    }
}
impl IOverRidingStyledItem for OverRidingStyledItem {
    fn over_ridden_style(&self) -> &EntityRef {
        &self.over_ridden_style
    }
}
impl OverRidingStyledItem {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = OverRidingStyledItem::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => entity.styles = parameter.into(),
                2usize => entity.item = parameter.into(),
                3usize => entity.over_ridden_style = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IPackageProductConceptFeature: IProductConceptFeature {}
#[derive(Default, Debug)]
pub struct PackageProductConceptFeature {
    id: Identifier,
    name: Label,
    description: Option<Text>,
}
impl IProductConceptFeature for PackageProductConceptFeature {
    fn id(&self) -> &Identifier {
        &self.id
    }
    fn name(&self) -> &Label {
        &self.name
    }
    fn description(&self) -> &Option<Text> {
        &self.description
    }
}
impl IPackageProductConceptFeature for PackageProductConceptFeature {}
impl PackageProductConceptFeature {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = PackageProductConceptFeature::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.id = parameter.into(),
                1usize => entity.name = parameter.into(),
                2usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
}
pub trait IParabola: IConic {
    fn focal_dist(&self) -> &LengthMeasure;
}
#[derive(Default, Debug)]
pub struct Parabola {
    name: Label,
    position: EntityRef,
    focal_dist: LengthMeasure,
}
impl IRepresentationItem for Parabola {
    fn name(&self) -> &Label {
        &self.name
    }
}
impl IGeometricRepresentationItem for Parabola {}
impl ICurve for Parabola {}
impl IConic for Parabola {
    fn position(&self) -> &EntityRef {
        &self.position
    }
}
impl IParabola for Parabola {
    fn focal_dist(&self) -> &LengthMeasure {
        &self.focal_dist
    }
}
impl Parabola {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = Parabola::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => entity.position = parameter.into(),
                2usize => entity.focal_dist = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IParallelOffset: IDerivedShapeAspect {
    fn offset(&self) -> &EntityRef;
}
#[derive(Default, Debug)]
pub struct ParallelOffset {
    name: Label,
    description: Option<Text>,
    of_shape: EntityRef,
    product_definitional: Option<bool>,
    offset: EntityRef,
}
impl IShapeAspect for ParallelOffset {
    fn name(&self) -> &Label {
        &self.name
    }
    fn description(&self) -> &Option<Text> {
        &self.description
    }
    fn of_shape(&self) -> &EntityRef {
        &self.of_shape
    }
    fn product_definitional(&self) -> Option<bool> {
        self.product_definitional
    }
}
impl IDerivedShapeAspect for ParallelOffset {}
impl IParallelOffset for ParallelOffset {
    fn offset(&self) -> &EntityRef {
        &self.offset
    }
}
impl ParallelOffset {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = ParallelOffset::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => entity.of_shape = parameter.into(),
                3usize => entity.product_definitional = parameter.into(),
                4usize => entity.offset = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IParallelismTolerance: IGeometricToleranceWithDatumReference {}
#[derive(Default, Debug)]
pub struct ParallelismTolerance {
    name: Label,
    description: Text,
    magnitude: EntityRef,
    toleranced_shape_aspect: EntityRef,
    datum_system: HashSet<EntityRef>,
}
impl IGeometricTolerance for ParallelismTolerance {
    fn name(&self) -> &Label {
        &self.name
    }
    fn description(&self) -> &Text {
        &self.description
    }
    fn magnitude(&self) -> &EntityRef {
        &self.magnitude
    }
    fn toleranced_shape_aspect(&self) -> &EntityRef {
        &self.toleranced_shape_aspect
    }
}
impl IGeometricToleranceWithDatumReference for ParallelismTolerance {
    fn datum_system(&self) -> &HashSet<EntityRef> {
        &self.datum_system
    }
}
impl IParallelismTolerance for ParallelismTolerance {}
impl ParallelismTolerance {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = ParallelismTolerance::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => entity.description = parameter.into(),
                2usize => entity.magnitude = parameter.into(),
                3usize => entity.toleranced_shape_aspect = parameter.into(),
                4usize => entity.datum_system = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IParametricRepresentationContext: IRepresentationContext {}
#[derive(Default, Debug)]
pub struct ParametricRepresentationContext {
    context_identifier: Identifier,
    context_type: Text,
}
impl IRepresentationContext for ParametricRepresentationContext {
    fn context_identifier(&self) -> &Identifier {
        &self.context_identifier
    }
    fn context_type(&self) -> &Text {
        &self.context_type
    }
}
impl IParametricRepresentationContext for ParametricRepresentationContext {}
impl ParametricRepresentationContext {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = ParametricRepresentationContext::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.context_identifier = parameter.into(),
                1usize => entity.context_type = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IPartLaminateTable: ILaminateTable {}
#[derive(Default, Debug)]
pub struct PartLaminateTable {
    id: Identifier,
    description: Option<Text>,
    formation: EntityRef,
    frame_of_reference: EntityRef,
}
impl IProductDefinition for PartLaminateTable {
    fn id(&self) -> &Identifier {
        &self.id
    }
    fn description(&self) -> &Option<Text> {
        &self.description
    }
    fn formation(&self) -> &EntityRef {
        &self.formation
    }
    fn frame_of_reference(&self) -> &EntityRef {
        &self.frame_of_reference
    }
}
impl ILaminateTable for PartLaminateTable {}
impl IPartLaminateTable for PartLaminateTable {}
impl PartLaminateTable {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = PartLaminateTable::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.id = parameter.into(),
                1usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => entity.formation = parameter.into(),
                3usize => entity.frame_of_reference = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IPartialDocumentWithStructuredTextRepresentationAssignment:
    IAppliedDocumentUsageConstraintAssignment + ICharacterizedObject
{
}
#[derive(Default, Debug)]
pub struct PartialDocumentWithStructuredTextRepresentationAssignment {
    assigned_document_usage: EntityRef,
    role: EntityRef,
    items: HashSet<EntityRef>,
    name: Label,
    description: Option<Text>,
}
impl IDocumentUsageConstraintAssignment for PartialDocumentWithStructuredTextRepresentationAssignment {
    fn assigned_document_usage(&self) -> &EntityRef {
        &self.assigned_document_usage
    }
    fn role(&self) -> &EntityRef {
        &self.role
    }
}
impl IAppliedDocumentUsageConstraintAssignment for PartialDocumentWithStructuredTextRepresentationAssignment {
    fn items(&self) -> &HashSet<EntityRef> {
        &self.items
    }
}
impl ICharacterizedObject for PartialDocumentWithStructuredTextRepresentationAssignment {
    fn name(&self) -> &Label {
        &self.name
    }
    fn description(&self) -> &Option<Text> {
        &self.description
    }
}
impl IPartialDocumentWithStructuredTextRepresentationAssignment
    for PartialDocumentWithStructuredTextRepresentationAssignment
{
}
impl PartialDocumentWithStructuredTextRepresentationAssignment {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = PartialDocumentWithStructuredTextRepresentationAssignment::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.assigned_document_usage = parameter.into(),
                1usize => entity.role = parameter.into(),
                2usize => entity.items = parameter.into(),
                3usize => entity.name = parameter.into(),
                4usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
}
pub trait IPath: ITopologicalRepresentationItem {
    fn edge_list(&self) -> &Vec<EntityRef>;
}
#[derive(Default, Debug)]
pub struct Path {
    name: Label,
    edge_list: Vec<EntityRef>,
}
impl IRepresentationItem for Path {
    fn name(&self) -> &Label {
        &self.name
    }
}
impl ITopologicalRepresentationItem for Path {}
impl IPath for Path {
    fn edge_list(&self) -> &Vec<EntityRef> {
        &self.edge_list
    }
}
impl Path {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = Path::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => entity.edge_list = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IPcurve: ICurve {
    fn basis_surface(&self) -> &EntityRef;
    fn reference_to_curve(&self) -> &EntityRef;
}
#[derive(Default, Debug)]
pub struct Pcurve {
    name: Label,
    basis_surface: EntityRef,
    reference_to_curve: EntityRef,
}
impl IRepresentationItem for Pcurve {
    fn name(&self) -> &Label {
        &self.name
    }
}
impl IGeometricRepresentationItem for Pcurve {}
impl ICurve for Pcurve {}
impl IPcurve for Pcurve {
    fn basis_surface(&self) -> &EntityRef {
        &self.basis_surface
    }
    fn reference_to_curve(&self) -> &EntityRef {
        &self.reference_to_curve
    }
}
impl Pcurve {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = Pcurve::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => entity.basis_surface = parameter.into(),
                2usize => entity.reference_to_curve = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IPercentageLaminateDefinition: IProductDefinition {}
#[derive(Default, Debug)]
pub struct PercentageLaminateDefinition {
    id: Identifier,
    description: Option<Text>,
    formation: EntityRef,
    frame_of_reference: EntityRef,
}
impl IProductDefinition for PercentageLaminateDefinition {
    fn id(&self) -> &Identifier {
        &self.id
    }
    fn description(&self) -> &Option<Text> {
        &self.description
    }
    fn formation(&self) -> &EntityRef {
        &self.formation
    }
    fn frame_of_reference(&self) -> &EntityRef {
        &self.frame_of_reference
    }
}
impl IPercentageLaminateDefinition for PercentageLaminateDefinition {}
impl PercentageLaminateDefinition {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = PercentageLaminateDefinition::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.id = parameter.into(),
                1usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => entity.formation = parameter.into(),
                3usize => entity.frame_of_reference = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IPercentageLaminateTable: IZoneStructuralMakeup {}
#[derive(Default, Debug)]
pub struct PercentageLaminateTable {
    id: Identifier,
    description: Option<Text>,
    formation: EntityRef,
    frame_of_reference: EntityRef,
}
impl IProductDefinition for PercentageLaminateTable {
    fn id(&self) -> &Identifier {
        &self.id
    }
    fn description(&self) -> &Option<Text> {
        &self.description
    }
    fn formation(&self) -> &EntityRef {
        &self.formation
    }
    fn frame_of_reference(&self) -> &EntityRef {
        &self.frame_of_reference
    }
}
impl ILaminateTable for PercentageLaminateTable {}
impl IZoneStructuralMakeup for PercentageLaminateTable {}
impl IPercentageLaminateTable for PercentageLaminateTable {}
impl PercentageLaminateTable {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = PercentageLaminateTable::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.id = parameter.into(),
                1usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => entity.formation = parameter.into(),
                3usize => entity.frame_of_reference = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IPercentagePlyDefinition: IProductDefinition {}
#[derive(Default, Debug)]
pub struct PercentagePlyDefinition {
    id: Identifier,
    description: Option<Text>,
    formation: EntityRef,
    frame_of_reference: EntityRef,
}
impl IProductDefinition for PercentagePlyDefinition {
    fn id(&self) -> &Identifier {
        &self.id
    }
    fn description(&self) -> &Option<Text> {
        &self.description
    }
    fn formation(&self) -> &EntityRef {
        &self.formation
    }
    fn frame_of_reference(&self) -> &EntityRef {
        &self.frame_of_reference
    }
}
impl IPercentagePlyDefinition for PercentagePlyDefinition {}
impl PercentagePlyDefinition {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = PercentagePlyDefinition::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.id = parameter.into(),
                1usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => entity.formation = parameter.into(),
                3usize => entity.frame_of_reference = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IPerpendicularTo: IDerivedShapeAspect {}
#[derive(Default, Debug)]
pub struct PerpendicularTo {
    name: Label,
    description: Option<Text>,
    of_shape: EntityRef,
    product_definitional: Option<bool>,
}
impl IShapeAspect for PerpendicularTo {
    fn name(&self) -> &Label {
        &self.name
    }
    fn description(&self) -> &Option<Text> {
        &self.description
    }
    fn of_shape(&self) -> &EntityRef {
        &self.of_shape
    }
    fn product_definitional(&self) -> Option<bool> {
        self.product_definitional
    }
}
impl IDerivedShapeAspect for PerpendicularTo {}
impl IPerpendicularTo for PerpendicularTo {}
impl PerpendicularTo {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = PerpendicularTo::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => entity.of_shape = parameter.into(),
                3usize => entity.product_definitional = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IPerpendicularityTolerance: IGeometricToleranceWithDatumReference {}
#[derive(Default, Debug)]
pub struct PerpendicularityTolerance {
    name: Label,
    description: Text,
    magnitude: EntityRef,
    toleranced_shape_aspect: EntityRef,
    datum_system: HashSet<EntityRef>,
}
impl IGeometricTolerance for PerpendicularityTolerance {
    fn name(&self) -> &Label {
        &self.name
    }
    fn description(&self) -> &Text {
        &self.description
    }
    fn magnitude(&self) -> &EntityRef {
        &self.magnitude
    }
    fn toleranced_shape_aspect(&self) -> &EntityRef {
        &self.toleranced_shape_aspect
    }
}
impl IGeometricToleranceWithDatumReference for PerpendicularityTolerance {
    fn datum_system(&self) -> &HashSet<EntityRef> {
        &self.datum_system
    }
}
impl IPerpendicularityTolerance for PerpendicularityTolerance {}
impl PerpendicularityTolerance {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = PerpendicularityTolerance::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => entity.description = parameter.into(),
                2usize => entity.magnitude = parameter.into(),
                3usize => entity.toleranced_shape_aspect = parameter.into(),
                4usize => entity.datum_system = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IPerson {
    fn id(&self) -> &Identifier;
    fn last_name(&self) -> &Option<Label>;
    fn first_name(&self) -> &Option<Label>;
    fn middle_names(&self) -> &Option<Vec<Label>>;
    fn prefix_titles(&self) -> &Option<Vec<Label>>;
    fn suffix_titles(&self) -> &Option<Vec<Label>>;
}
#[derive(Default, Debug)]
pub struct Person {
    id: Identifier,
    last_name: Option<Label>,
    first_name: Option<Label>,
    middle_names: Option<Vec<Label>>,
    prefix_titles: Option<Vec<Label>>,
    suffix_titles: Option<Vec<Label>>,
}
impl IPerson for Person {
    fn id(&self) -> &Identifier {
        &self.id
    }
    fn last_name(&self) -> &Option<Label> {
        &self.last_name
    }
    fn first_name(&self) -> &Option<Label> {
        &self.first_name
    }
    fn middle_names(&self) -> &Option<Vec<Label>> {
        &self.middle_names
    }
    fn prefix_titles(&self) -> &Option<Vec<Label>> {
        &self.prefix_titles
    }
    fn suffix_titles(&self) -> &Option<Vec<Label>> {
        &self.suffix_titles
    }
}
impl Person {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = Person::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.id = parameter.into(),
                1usize => {
                    entity.last_name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => {
                    entity.first_name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.middle_names = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => {
                    entity.prefix_titles = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                5usize => {
                    entity.suffix_titles = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
}
pub trait IPersonAndOrganization {
    fn the_person(&self) -> &EntityRef;
    fn the_organization(&self) -> &EntityRef;
}
#[derive(Default, Debug)]
pub struct PersonAndOrganization {
    the_person: EntityRef,
    the_organization: EntityRef,
}
impl IPersonAndOrganization for PersonAndOrganization {
    fn the_person(&self) -> &EntityRef {
        &self.the_person
    }
    fn the_organization(&self) -> &EntityRef {
        &self.the_organization
    }
}
impl PersonAndOrganization {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = PersonAndOrganization::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.the_person = parameter.into(),
                1usize => entity.the_organization = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IPersonAndOrganizationAddress: IOrganizationalAddress + IPersonalAddress {
    fn organizations(&self) -> &HashSet<EntityRef>;
    fn people(&self) -> &HashSet<EntityRef>;
}
#[derive(Default, Debug)]
pub struct PersonAndOrganizationAddress {
    internal_location: Option<Label>,
    street_number: Option<Label>,
    street: Option<Label>,
    postal_box: Option<Label>,
    town: Option<Label>,
    region: Option<Label>,
    postal_code: Option<Label>,
    country: Option<Label>,
    facsimile_number: Option<Label>,
    telephone_number: Option<Label>,
    electronic_mail_address: Option<Label>,
    telex_number: Option<Label>,
    description: Option<Text>,
    organizations: HashSet<EntityRef>,
    people: HashSet<EntityRef>,
}
impl IAddress for PersonAndOrganizationAddress {
    fn internal_location(&self) -> &Option<Label> {
        &self.internal_location
    }
    fn street_number(&self) -> &Option<Label> {
        &self.street_number
    }
    fn street(&self) -> &Option<Label> {
        &self.street
    }
    fn postal_box(&self) -> &Option<Label> {
        &self.postal_box
    }
    fn town(&self) -> &Option<Label> {
        &self.town
    }
    fn region(&self) -> &Option<Label> {
        &self.region
    }
    fn postal_code(&self) -> &Option<Label> {
        &self.postal_code
    }
    fn country(&self) -> &Option<Label> {
        &self.country
    }
    fn facsimile_number(&self) -> &Option<Label> {
        &self.facsimile_number
    }
    fn telephone_number(&self) -> &Option<Label> {
        &self.telephone_number
    }
    fn electronic_mail_address(&self) -> &Option<Label> {
        &self.electronic_mail_address
    }
    fn telex_number(&self) -> &Option<Label> {
        &self.telex_number
    }
}
impl IOrganizationalAddress for PersonAndOrganizationAddress {
    fn organizations(&self) -> &HashSet<EntityRef> {
        &self.organizations
    }
    fn description(&self) -> &Option<Text> {
        &self.description
    }
}
impl IPersonAndOrganizationAddress for PersonAndOrganizationAddress {
    fn organizations(&self) -> &HashSet<EntityRef> {
        &self.organizations
    }
    fn people(&self) -> &HashSet<EntityRef> {
        &self.people
    }
}
impl IPersonalAddress for PersonAndOrganizationAddress {
    fn people(&self) -> &HashSet<EntityRef> {
        &self.people
    }
    fn description(&self) -> &Option<Text> {
        &self.description
    }
}
impl PersonAndOrganizationAddress {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = PersonAndOrganizationAddress::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => {
                    entity.internal_location = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                1usize => {
                    entity.street_number = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => {
                    entity.street = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.postal_box = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => {
                    entity.town = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                5usize => {
                    entity.region = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                6usize => {
                    entity.postal_code = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                7usize => {
                    entity.country = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                8usize => {
                    entity.facsimile_number = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                9usize => {
                    entity.telephone_number = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                10usize => {
                    entity.electronic_mail_address = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                11usize => {
                    entity.telex_number = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                12usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                13usize => entity.organizations = parameter.into(),
                14usize => entity.people = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IPersonAndOrganizationAssignment {
    fn assigned_person_and_organization(&self) -> &EntityRef;
    fn role(&self) -> &EntityRef;
}
pub trait IPersonAndOrganizationRole {
    fn name(&self) -> &Label;
}
#[derive(Default, Debug)]
pub struct PersonAndOrganizationRole {
    name: Label,
}
impl IPersonAndOrganizationRole for PersonAndOrganizationRole {
    fn name(&self) -> &Label {
        &self.name
    }
}
impl PersonAndOrganizationRole {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = PersonAndOrganizationRole::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IPersonalAddress: IAddress {
    fn people(&self) -> &HashSet<EntityRef>;
    fn description(&self) -> &Option<Text>;
}
#[derive(Default, Debug)]
pub struct PersonalAddress {
    internal_location: Option<Label>,
    street_number: Option<Label>,
    street: Option<Label>,
    postal_box: Option<Label>,
    town: Option<Label>,
    region: Option<Label>,
    postal_code: Option<Label>,
    country: Option<Label>,
    facsimile_number: Option<Label>,
    telephone_number: Option<Label>,
    electronic_mail_address: Option<Label>,
    telex_number: Option<Label>,
    people: HashSet<EntityRef>,
    description: Option<Text>,
}
impl IAddress for PersonalAddress {
    fn internal_location(&self) -> &Option<Label> {
        &self.internal_location
    }
    fn street_number(&self) -> &Option<Label> {
        &self.street_number
    }
    fn street(&self) -> &Option<Label> {
        &self.street
    }
    fn postal_box(&self) -> &Option<Label> {
        &self.postal_box
    }
    fn town(&self) -> &Option<Label> {
        &self.town
    }
    fn region(&self) -> &Option<Label> {
        &self.region
    }
    fn postal_code(&self) -> &Option<Label> {
        &self.postal_code
    }
    fn country(&self) -> &Option<Label> {
        &self.country
    }
    fn facsimile_number(&self) -> &Option<Label> {
        &self.facsimile_number
    }
    fn telephone_number(&self) -> &Option<Label> {
        &self.telephone_number
    }
    fn electronic_mail_address(&self) -> &Option<Label> {
        &self.electronic_mail_address
    }
    fn telex_number(&self) -> &Option<Label> {
        &self.telex_number
    }
}
impl IPersonalAddress for PersonalAddress {
    fn people(&self) -> &HashSet<EntityRef> {
        &self.people
    }
    fn description(&self) -> &Option<Text> {
        &self.description
    }
}
impl PersonalAddress {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = PersonalAddress::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => {
                    entity.internal_location = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                1usize => {
                    entity.street_number = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => {
                    entity.street = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.postal_box = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => {
                    entity.town = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                5usize => {
                    entity.region = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                6usize => {
                    entity.postal_code = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                7usize => {
                    entity.country = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                8usize => {
                    entity.facsimile_number = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                9usize => {
                    entity.telephone_number = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                10usize => {
                    entity.electronic_mail_address = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                11usize => {
                    entity.telex_number = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                12usize => entity.people = parameter.into(),
                13usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
}
pub trait IPhysicalBreakdownContext: IBreakdownContext {}
#[derive(Default, Debug)]
pub struct PhysicalBreakdownContext {
    id: Identifier,
    name: Label,
    description: Option<Text>,
    relating_product_definition: EntityRef,
    related_product_definition: EntityRef,
}
impl IProductDefinitionRelationship for PhysicalBreakdownContext {
    fn id(&self) -> &Identifier {
        &self.id
    }
    fn name(&self) -> &Label {
        &self.name
    }
    fn description(&self) -> &Option<Text> {
        &self.description
    }
    fn relating_product_definition(&self) -> &EntityRef {
        &self.relating_product_definition
    }
    fn related_product_definition(&self) -> &EntityRef {
        &self.related_product_definition
    }
}
impl IBreakdownContext for PhysicalBreakdownContext {}
impl IPhysicalBreakdownContext for PhysicalBreakdownContext {}
impl PhysicalBreakdownContext {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = PhysicalBreakdownContext::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.id = parameter.into(),
                1usize => entity.name = parameter.into(),
                2usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => entity.relating_product_definition = parameter.into(),
                4usize => entity.related_product_definition = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IPhysicalElementUsage: IBreakdownElementUsage {}
#[derive(Default, Debug)]
pub struct PhysicalElementUsage {
    id: Identifier,
    name: Label,
    description: Option<Text>,
    relating_product_definition: EntityRef,
    related_product_definition: EntityRef,
}
impl IProductDefinitionRelationship for PhysicalElementUsage {
    fn id(&self) -> &Identifier {
        &self.id
    }
    fn name(&self) -> &Label {
        &self.name
    }
    fn description(&self) -> &Option<Text> {
        &self.description
    }
    fn relating_product_definition(&self) -> &EntityRef {
        &self.relating_product_definition
    }
    fn related_product_definition(&self) -> &EntityRef {
        &self.related_product_definition
    }
}
impl IBreakdownElementUsage for PhysicalElementUsage {}
impl IPhysicalElementUsage for PhysicalElementUsage {}
impl PhysicalElementUsage {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = PhysicalElementUsage::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.id = parameter.into(),
                1usize => entity.name = parameter.into(),
                2usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => entity.relating_product_definition = parameter.into(),
                4usize => entity.related_product_definition = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IPictureRepresentation: IPresentationView {
    fn items(&self) -> &HashSet<EntityRef>;
}
#[derive(Default, Debug)]
pub struct PictureRepresentation {
    name: Label,
    context_of_items: EntityRef,
    items: HashSet<EntityRef>,
}
impl IRepresentation for PictureRepresentation {
    fn name(&self) -> &Label {
        &self.name
    }
    fn items(&self) -> &HashSet<EntityRef> {
        &self.items
    }
    fn context_of_items(&self) -> &EntityRef {
        &self.context_of_items
    }
}
impl IPresentationRepresentation for PictureRepresentation {
    fn context_of_items(&self) -> &EntityRef {
        &self.context_of_items
    }
}
impl IPresentationView for PictureRepresentation {}
impl IPictureRepresentation for PictureRepresentation {
    fn items(&self) -> &HashSet<EntityRef> {
        &self.items
    }
}
impl PictureRepresentation {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = PictureRepresentation::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => entity.context_of_items = parameter.into(),
                2usize => entity.items = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IPictureRepresentationItem: IBytesRepresentationItem {}
pub trait IPlacedDatumTargetFeature: IDatumTarget {}
#[derive(Default, Debug)]
pub struct PlacedDatumTargetFeature {
    name: Label,
    description: Option<Text>,
    of_shape: EntityRef,
    product_definitional: Option<bool>,
    target_id: Identifier,
}
impl IShapeAspect for PlacedDatumTargetFeature {
    fn name(&self) -> &Label {
        &self.name
    }
    fn description(&self) -> &Option<Text> {
        &self.description
    }
    fn of_shape(&self) -> &EntityRef {
        &self.of_shape
    }
    fn product_definitional(&self) -> Option<bool> {
        self.product_definitional
    }
}
impl IDatumTarget for PlacedDatumTargetFeature {
    fn target_id(&self) -> &Identifier {
        &self.target_id
    }
}
impl IPlacedDatumTargetFeature for PlacedDatumTargetFeature {}
impl PlacedDatumTargetFeature {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = PlacedDatumTargetFeature::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => entity.of_shape = parameter.into(),
                3usize => entity.product_definitional = parameter.into(),
                4usize => entity.target_id = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IPlacedFeature: IShapeAspect {}
#[derive(Default, Debug)]
pub struct PlacedFeature {
    name: Label,
    description: Option<Text>,
    of_shape: EntityRef,
    product_definitional: Option<bool>,
}
impl IShapeAspect for PlacedFeature {
    fn name(&self) -> &Label {
        &self.name
    }
    fn description(&self) -> &Option<Text> {
        &self.description
    }
    fn of_shape(&self) -> &EntityRef {
        &self.of_shape
    }
    fn product_definitional(&self) -> Option<bool> {
        self.product_definitional
    }
}
impl IPlacedFeature for PlacedFeature {}
impl PlacedFeature {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = PlacedFeature::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => entity.of_shape = parameter.into(),
                3usize => entity.product_definitional = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IPlacement: IGeometricRepresentationItem {
    fn location(&self) -> &EntityRef;
}
#[derive(Default, Debug)]
pub struct Placement {
    name: Label,
    location: EntityRef,
}
impl IRepresentationItem for Placement {
    fn name(&self) -> &Label {
        &self.name
    }
}
impl IGeometricRepresentationItem for Placement {}
impl IPlacement for Placement {
    fn location(&self) -> &EntityRef {
        &self.location
    }
}
impl Placement {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = Placement::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => entity.location = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IPlanarBox: IPlanarExtent {
    fn placement(&self) -> &EntityRef;
}
#[derive(Default, Debug)]
pub struct PlanarBox {
    name: Label,
    size_in_x: LengthMeasure,
    size_in_y: LengthMeasure,
    placement: EntityRef,
}
impl IRepresentationItem for PlanarBox {
    fn name(&self) -> &Label {
        &self.name
    }
}
impl IGeometricRepresentationItem for PlanarBox {}
impl IPlanarExtent for PlanarBox {
    fn size_in_x(&self) -> &LengthMeasure {
        &self.size_in_x
    }
    fn size_in_y(&self) -> &LengthMeasure {
        &self.size_in_y
    }
}
impl IPlanarBox for PlanarBox {
    fn placement(&self) -> &EntityRef {
        &self.placement
    }
}
impl PlanarBox {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = PlanarBox::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => entity.size_in_x = parameter.into(),
                2usize => entity.size_in_y = parameter.into(),
                3usize => entity.placement = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IPlanarExtent: IGeometricRepresentationItem {
    fn size_in_x(&self) -> &LengthMeasure;
    fn size_in_y(&self) -> &LengthMeasure;
}
#[derive(Default, Debug)]
pub struct PlanarExtent {
    name: Label,
    size_in_x: LengthMeasure,
    size_in_y: LengthMeasure,
}
impl IRepresentationItem for PlanarExtent {
    fn name(&self) -> &Label {
        &self.name
    }
}
impl IGeometricRepresentationItem for PlanarExtent {}
impl IPlanarExtent for PlanarExtent {
    fn size_in_x(&self) -> &LengthMeasure {
        &self.size_in_x
    }
    fn size_in_y(&self) -> &LengthMeasure {
        &self.size_in_y
    }
}
impl PlanarExtent {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = PlanarExtent::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => entity.size_in_x = parameter.into(),
                2usize => entity.size_in_y = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IPlane: IElementarySurface {}
#[derive(Default, Debug)]
pub struct Plane {
    name: Label,
    position: EntityRef,
}
impl IRepresentationItem for Plane {
    fn name(&self) -> &Label {
        &self.name
    }
}
impl IGeometricRepresentationItem for Plane {}
impl ISurface for Plane {}
impl IElementarySurface for Plane {
    fn position(&self) -> &EntityRef {
        &self.position
    }
}
impl IPlane for Plane {}
impl Plane {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = Plane::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => entity.position = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IPlaneAngleMeasureWithUnit: IMeasureWithUnit {}
#[derive(Default, Debug)]
pub struct PlaneAngleMeasureWithUnit {
    value_component: MeasureValue,
    unit_component: EntityRef,
}
impl IMeasureWithUnit for PlaneAngleMeasureWithUnit {
    fn value_component(&self) -> &MeasureValue {
        &self.value_component
    }
    fn unit_component(&self) -> &EntityRef {
        &self.unit_component
    }
}
impl IPlaneAngleMeasureWithUnit for PlaneAngleMeasureWithUnit {}
impl PlaneAngleMeasureWithUnit {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = PlaneAngleMeasureWithUnit::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.value_component = parameter.into(),
                1usize => entity.unit_component = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IPlaneAngleUnit: INamedUnit {}
#[derive(Default, Debug)]
pub struct PlaneAngleUnit {
    dimensions: EntityRef,
}
impl INamedUnit for PlaneAngleUnit {
    fn dimensions(&self) -> &EntityRef {
        &self.dimensions
    }
}
impl IPlaneAngleUnit for PlaneAngleUnit {}
impl PlaneAngleUnit {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = PlaneAngleUnit::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.dimensions = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IPlusMinusTolerance {
    fn range(&self) -> &EntityRef;
    fn toleranced_dimension(&self) -> &EntityRef;
}
#[derive(Default, Debug)]
pub struct PlusMinusTolerance {
    range: EntityRef,
    toleranced_dimension: EntityRef,
}
impl IPlusMinusTolerance for PlusMinusTolerance {
    fn range(&self) -> &EntityRef {
        &self.range
    }
    fn toleranced_dimension(&self) -> &EntityRef {
        &self.toleranced_dimension
    }
}
impl PlusMinusTolerance {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = PlusMinusTolerance::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.range = parameter.into(),
                1usize => entity.toleranced_dimension = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IPlyLaminateDefinition: IProductDefinition {}
#[derive(Default, Debug)]
pub struct PlyLaminateDefinition {
    id: Identifier,
    description: Option<Text>,
    formation: EntityRef,
    frame_of_reference: EntityRef,
}
impl IProductDefinition for PlyLaminateDefinition {
    fn id(&self) -> &Identifier {
        &self.id
    }
    fn description(&self) -> &Option<Text> {
        &self.description
    }
    fn formation(&self) -> &EntityRef {
        &self.formation
    }
    fn frame_of_reference(&self) -> &EntityRef {
        &self.frame_of_reference
    }
}
impl IPlyLaminateDefinition for PlyLaminateDefinition {}
impl PlyLaminateDefinition {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = PlyLaminateDefinition::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.id = parameter.into(),
                1usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => entity.formation = parameter.into(),
                3usize => entity.frame_of_reference = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IPlyLaminateSequenceDefinition: IProductDefinition {}
#[derive(Default, Debug)]
pub struct PlyLaminateSequenceDefinition {
    id: Identifier,
    description: Option<Text>,
    formation: EntityRef,
    frame_of_reference: EntityRef,
}
impl IProductDefinition for PlyLaminateSequenceDefinition {
    fn id(&self) -> &Identifier {
        &self.id
    }
    fn description(&self) -> &Option<Text> {
        &self.description
    }
    fn formation(&self) -> &EntityRef {
        &self.formation
    }
    fn frame_of_reference(&self) -> &EntityRef {
        &self.frame_of_reference
    }
}
impl IPlyLaminateSequenceDefinition for PlyLaminateSequenceDefinition {}
impl PlyLaminateSequenceDefinition {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = PlyLaminateSequenceDefinition::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.id = parameter.into(),
                1usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => entity.formation = parameter.into(),
                3usize => entity.frame_of_reference = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IPlyLaminateTable: IPartLaminateTable {}
#[derive(Default, Debug)]
pub struct PlyLaminateTable {
    id: Identifier,
    description: Option<Text>,
    formation: EntityRef,
    frame_of_reference: EntityRef,
}
impl IProductDefinition for PlyLaminateTable {
    fn id(&self) -> &Identifier {
        &self.id
    }
    fn description(&self) -> &Option<Text> {
        &self.description
    }
    fn formation(&self) -> &EntityRef {
        &self.formation
    }
    fn frame_of_reference(&self) -> &EntityRef {
        &self.frame_of_reference
    }
}
impl ILaminateTable for PlyLaminateTable {}
impl IPartLaminateTable for PlyLaminateTable {}
impl IPlyLaminateTable for PlyLaminateTable {}
impl PlyLaminateTable {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = PlyLaminateTable::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.id = parameter.into(),
                1usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => entity.formation = parameter.into(),
                3usize => entity.frame_of_reference = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IPoint: IGeometricRepresentationItem {}
#[derive(Default, Debug)]
pub struct Point {
    name: Label,
}
impl IRepresentationItem for Point {
    fn name(&self) -> &Label {
        &self.name
    }
}
impl IGeometricRepresentationItem for Point {}
impl IPoint for Point {}
impl Point {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = Point::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IPointAndVector: ICompoundRepresentationItem + IGeometricRepresentationItem {
    fn item_element(&self) -> &PointAndVectorMembers;
}
#[derive(Default, Debug)]
pub struct PointAndVector {
    name: Label,
    item_element: PointAndVectorMembers,
}
impl IRepresentationItem for PointAndVector {
    fn name(&self) -> &Label {
        &self.name
    }
}
impl ICompoundRepresentationItem for PointAndVector {
    fn item_element(&self) -> &CompoundItemDefinition {
        unimplemented!()
    }
}
impl IPointAndVector for PointAndVector {
    fn item_element(&self) -> &PointAndVectorMembers {
        &self.item_element
    }
}
impl IGeometricRepresentationItem for PointAndVector {}
impl PointAndVector {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = PointAndVector::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => entity.item_element = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IPointOnCurve: IPoint {
    fn basis_curve(&self) -> &EntityRef;
    fn point_parameter(&self) -> &ParameterValue;
}
#[derive(Default, Debug)]
pub struct PointOnCurve {
    name: Label,
    basis_curve: EntityRef,
    point_parameter: ParameterValue,
}
impl IRepresentationItem for PointOnCurve {
    fn name(&self) -> &Label {
        &self.name
    }
}
impl IGeometricRepresentationItem for PointOnCurve {}
impl IPoint for PointOnCurve {}
impl IPointOnCurve for PointOnCurve {
    fn basis_curve(&self) -> &EntityRef {
        &self.basis_curve
    }
    fn point_parameter(&self) -> &ParameterValue {
        &self.point_parameter
    }
}
impl PointOnCurve {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = PointOnCurve::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => entity.basis_curve = parameter.into(),
                2usize => entity.point_parameter = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IPointOnSurface: IPoint {
    fn basis_surface(&self) -> &EntityRef;
    fn point_parameter_u(&self) -> &ParameterValue;
    fn point_parameter_v(&self) -> &ParameterValue;
}
#[derive(Default, Debug)]
pub struct PointOnSurface {
    name: Label,
    basis_surface: EntityRef,
    point_parameter_u: ParameterValue,
    point_parameter_v: ParameterValue,
}
impl IRepresentationItem for PointOnSurface {
    fn name(&self) -> &Label {
        &self.name
    }
}
impl IGeometricRepresentationItem for PointOnSurface {}
impl IPoint for PointOnSurface {}
impl IPointOnSurface for PointOnSurface {
    fn basis_surface(&self) -> &EntityRef {
        &self.basis_surface
    }
    fn point_parameter_u(&self) -> &ParameterValue {
        &self.point_parameter_u
    }
    fn point_parameter_v(&self) -> &ParameterValue {
        &self.point_parameter_v
    }
}
impl PointOnSurface {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = PointOnSurface::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => entity.basis_surface = parameter.into(),
                2usize => entity.point_parameter_u = parameter.into(),
                3usize => entity.point_parameter_v = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IPointPath: ICompoundRepresentationItem + IGeometricRepresentationItem {
    fn item_element(&self) -> &PointPathMembers;
}
#[derive(Default, Debug)]
pub struct PointPath {
    name: Label,
    item_element: PointPathMembers,
}
impl IRepresentationItem for PointPath {
    fn name(&self) -> &Label {
        &self.name
    }
}
impl ICompoundRepresentationItem for PointPath {
    fn item_element(&self) -> &CompoundItemDefinition {
        unimplemented!()
    }
}
impl IPointPath for PointPath {
    fn item_element(&self) -> &PointPathMembers {
        &self.item_element
    }
}
impl IGeometricRepresentationItem for PointPath {}
impl PointPath {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = PointPath::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => entity.item_element = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IPointReplica: IPoint {
    fn parent_pt(&self) -> &EntityRef;
    fn transformation(&self) -> &EntityRef;
}
#[derive(Default, Debug)]
pub struct PointReplica {
    name: Label,
    parent_pt: EntityRef,
    transformation: EntityRef,
}
impl IRepresentationItem for PointReplica {
    fn name(&self) -> &Label {
        &self.name
    }
}
impl IGeometricRepresentationItem for PointReplica {}
impl IPoint for PointReplica {}
impl IPointReplica for PointReplica {
    fn parent_pt(&self) -> &EntityRef {
        &self.parent_pt
    }
    fn transformation(&self) -> &EntityRef {
        &self.transformation
    }
}
impl PointReplica {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = PointReplica::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => entity.parent_pt = parameter.into(),
                2usize => entity.transformation = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IPointStyle: IFoundedItem {
    fn name(&self) -> &Label;
    fn marker(&self) -> &MarkerSelect;
    fn marker_size(&self) -> &SizeSelect;
    fn marker_colour(&self) -> &EntityRef;
}
#[derive(Default, Debug)]
pub struct PointStyle {
    name: Label,
    marker: MarkerSelect,
    marker_size: SizeSelect,
    marker_colour: EntityRef,
}
impl IFoundedItem for PointStyle {}
impl IPointStyle for PointStyle {
    fn name(&self) -> &Label {
        &self.name
    }
    fn marker(&self) -> &MarkerSelect {
        &self.marker
    }
    fn marker_size(&self) -> &SizeSelect {
        &self.marker_size
    }
    fn marker_colour(&self) -> &EntityRef {
        &self.marker_colour
    }
}
impl PointStyle {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = PointStyle::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => entity.marker = parameter.into(),
                2usize => entity.marker_size = parameter.into(),
                3usize => entity.marker_colour = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IPolarComplexNumberLiteral: IGenericLiteral {
    fn radius(&self) -> Real;
    fn angle(&self) -> Real;
}
#[derive(Default, Debug)]
pub struct PolarComplexNumberLiteral {
    radius: Real,
    angle: Real,
}
impl IGenericExpression for PolarComplexNumberLiteral {}
impl ISimpleGenericExpression for PolarComplexNumberLiteral {}
impl IGenericLiteral for PolarComplexNumberLiteral {}
impl IPolarComplexNumberLiteral for PolarComplexNumberLiteral {
    fn radius(&self) -> Real {
        self.radius
    }
    fn angle(&self) -> Real {
        self.angle
    }
}
impl PolarComplexNumberLiteral {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = PolarComplexNumberLiteral::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.radius = parameter.into(),
                1usize => entity.angle = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IPolyLoop: ILoop + IGeometricRepresentationItem {
    fn polygon(&self) -> &Vec<EntityRef>;
}
#[derive(Default, Debug)]
pub struct PolyLoop {
    name: Label,
    polygon: Vec<EntityRef>,
}
impl IRepresentationItem for PolyLoop {
    fn name(&self) -> &Label {
        &self.name
    }
}
impl ITopologicalRepresentationItem for PolyLoop {}
impl ILoop for PolyLoop {}
impl IPolyLoop for PolyLoop {
    fn polygon(&self) -> &Vec<EntityRef> {
        &self.polygon
    }
}
impl IGeometricRepresentationItem for PolyLoop {}
impl PolyLoop {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = PolyLoop::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => entity.polygon = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IPolyline: IBoundedCurve {
    fn points(&self) -> &Vec<EntityRef>;
}
#[derive(Default, Debug)]
pub struct Polyline {
    name: Label,
    points: Vec<EntityRef>,
}
impl IRepresentationItem for Polyline {
    fn name(&self) -> &Label {
        &self.name
    }
}
impl IGeometricRepresentationItem for Polyline {}
impl ICurve for Polyline {}
impl IBoundedCurve for Polyline {}
impl IPolyline for Polyline {
    fn points(&self) -> &Vec<EntityRef> {
        &self.points
    }
}
impl Polyline {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = Polyline::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => entity.points = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IPositionTolerance: IGeometricTolerance {}
#[derive(Default, Debug)]
pub struct PositionTolerance {
    name: Label,
    description: Text,
    magnitude: EntityRef,
    toleranced_shape_aspect: EntityRef,
}
impl IGeometricTolerance for PositionTolerance {
    fn name(&self) -> &Label {
        &self.name
    }
    fn description(&self) -> &Text {
        &self.description
    }
    fn magnitude(&self) -> &EntityRef {
        &self.magnitude
    }
    fn toleranced_shape_aspect(&self) -> &EntityRef {
        &self.toleranced_shape_aspect
    }
}
impl IPositionTolerance for PositionTolerance {}
impl PositionTolerance {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = PositionTolerance::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => entity.description = parameter.into(),
                2usize => entity.magnitude = parameter.into(),
                3usize => entity.toleranced_shape_aspect = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IPositionedSketch: IGeometricRepresentationItem {
    fn sketch_basis(&self) -> &EntityRef;
    fn auxiliary_elements(&self) -> &HashSet<EntityRef>;
}
#[derive(Default, Debug)]
pub struct PositionedSketch {
    name: Label,
    sketch_basis: EntityRef,
    auxiliary_elements: HashSet<EntityRef>,
}
impl IRepresentationItem for PositionedSketch {
    fn name(&self) -> &Label {
        &self.name
    }
}
impl IGeometricRepresentationItem for PositionedSketch {}
impl IPositionedSketch for PositionedSketch {
    fn sketch_basis(&self) -> &EntityRef {
        &self.sketch_basis
    }
    fn auxiliary_elements(&self) -> &HashSet<EntityRef> {
        &self.auxiliary_elements
    }
}
impl PositionedSketch {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = PositionedSketch::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => entity.sketch_basis = parameter.into(),
                2usize => entity.auxiliary_elements = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IPowerMeasureWithUnit: IMeasureWithUnit {}
#[derive(Default, Debug)]
pub struct PowerMeasureWithUnit {
    value_component: MeasureValue,
    unit_component: EntityRef,
}
impl IMeasureWithUnit for PowerMeasureWithUnit {
    fn value_component(&self) -> &MeasureValue {
        &self.value_component
    }
    fn unit_component(&self) -> &EntityRef {
        &self.unit_component
    }
}
impl IPowerMeasureWithUnit for PowerMeasureWithUnit {}
impl PowerMeasureWithUnit {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = PowerMeasureWithUnit::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.value_component = parameter.into(),
                1usize => entity.unit_component = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IPowerUnit: IDerivedUnit {}
#[derive(Default, Debug)]
pub struct PowerUnit {
    elements: HashSet<EntityRef>,
}
impl IDerivedUnit for PowerUnit {
    fn elements(&self) -> &HashSet<EntityRef> {
        &self.elements
    }
}
impl IPowerUnit for PowerUnit {}
impl PowerUnit {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = PowerUnit::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.elements = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IPreDefinedColour: IPreDefinedItem + IColour {}
#[derive(Default, Debug)]
pub struct PreDefinedColour {
    name: Label,
}
impl IPreDefinedItem for PreDefinedColour {
    fn name(&self) -> &Label {
        &self.name
    }
}
impl IColour for PreDefinedColour {}
impl IPreDefinedColour for PreDefinedColour {}
impl PreDefinedColour {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = PreDefinedColour::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IPreDefinedCurveFont: IPreDefinedItem {}
#[derive(Default, Debug)]
pub struct PreDefinedCurveFont {
    name: Label,
}
impl IPreDefinedItem for PreDefinedCurveFont {
    fn name(&self) -> &Label {
        &self.name
    }
}
impl IPreDefinedCurveFont for PreDefinedCurveFont {}
impl PreDefinedCurveFont {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = PreDefinedCurveFont::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IPreDefinedDimensionSymbol: IPreDefinedSymbol {}
#[derive(Default, Debug)]
pub struct PreDefinedDimensionSymbol {
    name: Label,
}
impl IPreDefinedItem for PreDefinedDimensionSymbol {
    fn name(&self) -> &Label {
        &self.name
    }
}
impl IPreDefinedSymbol for PreDefinedDimensionSymbol {}
impl IPreDefinedDimensionSymbol for PreDefinedDimensionSymbol {}
impl PreDefinedDimensionSymbol {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = PreDefinedDimensionSymbol::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IPreDefinedGeometricalToleranceSymbol: IPreDefinedSymbol {}
#[derive(Default, Debug)]
pub struct PreDefinedGeometricalToleranceSymbol {
    name: Label,
}
impl IPreDefinedItem for PreDefinedGeometricalToleranceSymbol {
    fn name(&self) -> &Label {
        &self.name
    }
}
impl IPreDefinedSymbol for PreDefinedGeometricalToleranceSymbol {}
impl IPreDefinedGeometricalToleranceSymbol for PreDefinedGeometricalToleranceSymbol {}
impl PreDefinedGeometricalToleranceSymbol {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = PreDefinedGeometricalToleranceSymbol::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IPreDefinedItem {
    fn name(&self) -> &Label;
}
#[derive(Default, Debug)]
pub struct PreDefinedItem {
    name: Label,
}
impl IPreDefinedItem for PreDefinedItem {
    fn name(&self) -> &Label {
        &self.name
    }
}
impl PreDefinedItem {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = PreDefinedItem::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IPreDefinedMarker: IPreDefinedItem {}
#[derive(Default, Debug)]
pub struct PreDefinedMarker {
    name: Label,
}
impl IPreDefinedItem for PreDefinedMarker {
    fn name(&self) -> &Label {
        &self.name
    }
}
impl IPreDefinedMarker for PreDefinedMarker {}
impl PreDefinedMarker {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = PreDefinedMarker::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IPreDefinedPointMarkerSymbol: IPreDefinedMarker + IPreDefinedSymbol {}
#[derive(Default, Debug)]
pub struct PreDefinedPointMarkerSymbol {
    name: Label,
}
impl IPreDefinedItem for PreDefinedPointMarkerSymbol {
    fn name(&self) -> &Label {
        &self.name
    }
}
impl IPreDefinedMarker for PreDefinedPointMarkerSymbol {}
impl IPreDefinedPointMarkerSymbol for PreDefinedPointMarkerSymbol {}
impl IPreDefinedSymbol for PreDefinedPointMarkerSymbol {}
impl PreDefinedPointMarkerSymbol {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = PreDefinedPointMarkerSymbol::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IPreDefinedSurfaceConditionSymbol: IPreDefinedSymbol {}
#[derive(Default, Debug)]
pub struct PreDefinedSurfaceConditionSymbol {
    name: Label,
}
impl IPreDefinedItem for PreDefinedSurfaceConditionSymbol {
    fn name(&self) -> &Label {
        &self.name
    }
}
impl IPreDefinedSymbol for PreDefinedSurfaceConditionSymbol {}
impl IPreDefinedSurfaceConditionSymbol for PreDefinedSurfaceConditionSymbol {}
impl PreDefinedSurfaceConditionSymbol {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = PreDefinedSurfaceConditionSymbol::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IPreDefinedSurfaceSideStyle: IPreDefinedItem {}
#[derive(Default, Debug)]
pub struct PreDefinedSurfaceSideStyle {
    name: Label,
}
impl IPreDefinedItem for PreDefinedSurfaceSideStyle {
    fn name(&self) -> &Label {
        &self.name
    }
}
impl IPreDefinedSurfaceSideStyle for PreDefinedSurfaceSideStyle {}
impl PreDefinedSurfaceSideStyle {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = PreDefinedSurfaceSideStyle::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IPreDefinedSymbol: IPreDefinedItem {}
#[derive(Default, Debug)]
pub struct PreDefinedSymbol {
    name: Label,
}
impl IPreDefinedItem for PreDefinedSymbol {
    fn name(&self) -> &Label {
        &self.name
    }
}
impl IPreDefinedSymbol for PreDefinedSymbol {}
impl PreDefinedSymbol {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = PreDefinedSymbol::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IPreDefinedTerminatorSymbol: IPreDefinedSymbol {}
#[derive(Default, Debug)]
pub struct PreDefinedTerminatorSymbol {
    name: Label,
}
impl IPreDefinedItem for PreDefinedTerminatorSymbol {
    fn name(&self) -> &Label {
        &self.name
    }
}
impl IPreDefinedSymbol for PreDefinedTerminatorSymbol {}
impl IPreDefinedTerminatorSymbol for PreDefinedTerminatorSymbol {}
impl PreDefinedTerminatorSymbol {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = PreDefinedTerminatorSymbol::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IPreDefinedTextFont: IPreDefinedItem {}
#[derive(Default, Debug)]
pub struct PreDefinedTextFont {
    name: Label,
}
impl IPreDefinedItem for PreDefinedTextFont {
    fn name(&self) -> &Label {
        &self.name
    }
}
impl IPreDefinedTextFont for PreDefinedTextFont {}
impl PreDefinedTextFont {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = PreDefinedTextFont::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IPreDefinedTile: IPreDefinedItem {}
#[derive(Default, Debug)]
pub struct PreDefinedTile {
    name: Label,
}
impl IPreDefinedItem for PreDefinedTile {
    fn name(&self) -> &Label {
        &self.name
    }
}
impl IPreDefinedTile for PreDefinedTile {}
impl PreDefinedTile {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = PreDefinedTile::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IPrecisionQualifier {
    fn precision_value(&self) -> i64;
}
#[derive(Default, Debug)]
pub struct PrecisionQualifier {
    precision_value: i64,
}
impl IPrecisionQualifier for PrecisionQualifier {
    fn precision_value(&self) -> i64 {
        self.precision_value
    }
}
impl PrecisionQualifier {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = PrecisionQualifier::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.precision_value = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IPredefinedPictureRepresentationItem: IPictureRepresentationItem {}
#[derive(Default, Debug)]
pub struct PredefinedPictureRepresentationItem {
    name: Label,
    binary_value: Unimplemented,
}
impl IRepresentationItem for PredefinedPictureRepresentationItem {
    fn name(&self) -> &Label {
        &self.name
    }
}
impl IBinaryRepresentationItem for PredefinedPictureRepresentationItem {
    fn binary_value(&self) -> &Unimplemented {
        &self.binary_value
    }
}
impl IBytesRepresentationItem for PredefinedPictureRepresentationItem {}
impl IPictureRepresentationItem for PredefinedPictureRepresentationItem {}
impl IPredefinedPictureRepresentationItem for PredefinedPictureRepresentationItem {}
impl PredefinedPictureRepresentationItem {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = PredefinedPictureRepresentationItem::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => entity.binary_value = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IPresentationArea: IPresentationRepresentation {}
#[derive(Default, Debug)]
pub struct PresentationArea {
    name: Label,
    items: HashSet<EntityRef>,
    context_of_items: EntityRef,
}
impl IRepresentation for PresentationArea {
    fn name(&self) -> &Label {
        &self.name
    }
    fn items(&self) -> &HashSet<EntityRef> {
        &self.items
    }
    fn context_of_items(&self) -> &EntityRef {
        &self.context_of_items
    }
}
impl IPresentationRepresentation for PresentationArea {
    fn context_of_items(&self) -> &EntityRef {
        &self.context_of_items
    }
}
impl IPresentationArea for PresentationArea {}
impl PresentationArea {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = PresentationArea::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => entity.items = parameter.into(),
                2usize => entity.context_of_items = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IPresentationLayerAssignment {
    fn name(&self) -> &Label;
    fn description(&self) -> &Text;
    fn assigned_items(&self) -> &HashSet<EntityRef>;
}
#[derive(Default, Debug)]
pub struct PresentationLayerAssignment {
    name: Label,
    description: Text,
    assigned_items: HashSet<EntityRef>,
}
impl IPresentationLayerAssignment for PresentationLayerAssignment {
    fn name(&self) -> &Label {
        &self.name
    }
    fn description(&self) -> &Text {
        &self.description
    }
    fn assigned_items(&self) -> &HashSet<EntityRef> {
        &self.assigned_items
    }
}
impl PresentationLayerAssignment {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = PresentationLayerAssignment::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => entity.description = parameter.into(),
                2usize => entity.assigned_items = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IPresentationRepresentation: IRepresentation {
    fn context_of_items(&self) -> &EntityRef;
}
#[derive(Default, Debug)]
pub struct PresentationRepresentation {
    name: Label,
    items: HashSet<EntityRef>,
    context_of_items: EntityRef,
}
impl IRepresentation for PresentationRepresentation {
    fn name(&self) -> &Label {
        &self.name
    }
    fn items(&self) -> &HashSet<EntityRef> {
        &self.items
    }
    fn context_of_items(&self) -> &EntityRef {
        &self.context_of_items
    }
}
impl IPresentationRepresentation for PresentationRepresentation {
    fn context_of_items(&self) -> &EntityRef {
        &self.context_of_items
    }
}
impl PresentationRepresentation {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = PresentationRepresentation::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => entity.items = parameter.into(),
                2usize => entity.context_of_items = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IPresentationSet {}
#[derive(Default, Debug)]
pub struct PresentationSet {}
impl IPresentationSet for PresentationSet {}
impl PresentationSet {
    pub fn form_parameters(_parameters: Vec<Parameter>) -> Self {
        PresentationSet::default()
    }
}
pub trait IPresentationSize {
    fn unit(&self) -> &EntityRef;
    fn size(&self) -> &EntityRef;
}
#[derive(Default, Debug)]
pub struct PresentationSize {
    unit: EntityRef,
    size: EntityRef,
}
impl IPresentationSize for PresentationSize {
    fn unit(&self) -> &EntityRef {
        &self.unit
    }
    fn size(&self) -> &EntityRef {
        &self.size
    }
}
impl PresentationSize {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = PresentationSize::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.unit = parameter.into(),
                1usize => entity.size = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IPresentationStyleAssignment: IFoundedItem {
    fn styles(&self) -> &HashSet<PresentationStyleSelect>;
}
#[derive(Default, Debug)]
pub struct PresentationStyleAssignment {
    styles: HashSet<PresentationStyleSelect>,
}
impl IFoundedItem for PresentationStyleAssignment {}
impl IPresentationStyleAssignment for PresentationStyleAssignment {
    fn styles(&self) -> &HashSet<PresentationStyleSelect> {
        &self.styles
    }
}
impl PresentationStyleAssignment {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = PresentationStyleAssignment::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.styles = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IPresentationStyleByContext: IPresentationStyleAssignment {
    fn style_context(&self) -> &EntityRef;
}
#[derive(Default, Debug)]
pub struct PresentationStyleByContext {
    styles: HashSet<PresentationStyleSelect>,
    style_context: EntityRef,
}
impl IFoundedItem for PresentationStyleByContext {}
impl IPresentationStyleAssignment for PresentationStyleByContext {
    fn styles(&self) -> &HashSet<PresentationStyleSelect> {
        &self.styles
    }
}
impl IPresentationStyleByContext for PresentationStyleByContext {
    fn style_context(&self) -> &EntityRef {
        &self.style_context
    }
}
impl PresentationStyleByContext {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = PresentationStyleByContext::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.styles = parameter.into(),
                1usize => entity.style_context = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IPresentationView: IPresentationRepresentation {}
#[derive(Default, Debug)]
pub struct PresentationView {
    name: Label,
    items: HashSet<EntityRef>,
    context_of_items: EntityRef,
}
impl IRepresentation for PresentationView {
    fn name(&self) -> &Label {
        &self.name
    }
    fn items(&self) -> &HashSet<EntityRef> {
        &self.items
    }
    fn context_of_items(&self) -> &EntityRef {
        &self.context_of_items
    }
}
impl IPresentationRepresentation for PresentationView {
    fn context_of_items(&self) -> &EntityRef {
        &self.context_of_items
    }
}
impl IPresentationView for PresentationView {}
impl PresentationView {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = PresentationView::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => entity.items = parameter.into(),
                2usize => entity.context_of_items = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IPresentedItem {}
pub trait IPresentedItemRepresentation {
    fn presentation(&self) -> &EntityRef;
    fn item(&self) -> &EntityRef;
}
#[derive(Default, Debug)]
pub struct PresentedItemRepresentation {
    presentation: EntityRef,
    item: EntityRef,
}
impl IPresentedItemRepresentation for PresentedItemRepresentation {
    fn presentation(&self) -> &EntityRef {
        &self.presentation
    }
    fn item(&self) -> &EntityRef {
        &self.item
    }
}
impl PresentedItemRepresentation {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = PresentedItemRepresentation::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.presentation = parameter.into(),
                1usize => entity.item = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IPressureMeasureWithUnit: IMeasureWithUnit {}
#[derive(Default, Debug)]
pub struct PressureMeasureWithUnit {
    value_component: MeasureValue,
    unit_component: EntityRef,
}
impl IMeasureWithUnit for PressureMeasureWithUnit {
    fn value_component(&self) -> &MeasureValue {
        &self.value_component
    }
    fn unit_component(&self) -> &EntityRef {
        &self.unit_component
    }
}
impl IPressureMeasureWithUnit for PressureMeasureWithUnit {}
impl PressureMeasureWithUnit {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = PressureMeasureWithUnit::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.value_component = parameter.into(),
                1usize => entity.unit_component = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IPressureUnit: IDerivedUnit {}
#[derive(Default, Debug)]
pub struct PressureUnit {
    elements: HashSet<EntityRef>,
}
impl IDerivedUnit for PressureUnit {
    fn elements(&self) -> &HashSet<EntityRef> {
        &self.elements
    }
}
impl IPressureUnit for PressureUnit {}
impl PressureUnit {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = PressureUnit::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.elements = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IProceduralRepresentation: IRepresentation {
    fn items(&self) -> &HashSet<EntityRef>;
}
#[derive(Default, Debug)]
pub struct ProceduralRepresentation {
    name: Label,
    context_of_items: EntityRef,
    items: HashSet<EntityRef>,
}
impl IRepresentation for ProceduralRepresentation {
    fn name(&self) -> &Label {
        &self.name
    }
    fn items(&self) -> &HashSet<EntityRef> {
        &self.items
    }
    fn context_of_items(&self) -> &EntityRef {
        &self.context_of_items
    }
}
impl IProceduralRepresentation for ProceduralRepresentation {
    fn items(&self) -> &HashSet<EntityRef> {
        &self.items
    }
}
impl ProceduralRepresentation {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = ProceduralRepresentation::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => entity.context_of_items = parameter.into(),
                2usize => entity.items = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IProceduralRepresentationSequence: IRepresentationItem {
    fn elements(&self) -> &Vec<EntityRef>;
    fn suppressed_items(&self) -> &HashSet<EntityRef>;
    fn rationale(&self) -> &Text;
}
#[derive(Default, Debug)]
pub struct ProceduralRepresentationSequence {
    name: Label,
    elements: Vec<EntityRef>,
    suppressed_items: HashSet<EntityRef>,
    rationale: Text,
}
impl IRepresentationItem for ProceduralRepresentationSequence {
    fn name(&self) -> &Label {
        &self.name
    }
}
impl IProceduralRepresentationSequence for ProceduralRepresentationSequence {
    fn elements(&self) -> &Vec<EntityRef> {
        &self.elements
    }
    fn suppressed_items(&self) -> &HashSet<EntityRef> {
        &self.suppressed_items
    }
    fn rationale(&self) -> &Text {
        &self.rationale
    }
}
impl ProceduralRepresentationSequence {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = ProceduralRepresentationSequence::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => entity.elements = parameter.into(),
                2usize => entity.suppressed_items = parameter.into(),
                3usize => entity.rationale = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IProceduralShapeRepresentation: IProceduralRepresentation + IShapeRepresentation {
    fn items(&self) -> &HashSet<EntityRef>;
}
#[derive(Default, Debug)]
pub struct ProceduralShapeRepresentation {
    name: Label,
    context_of_items: EntityRef,
    items: HashSet<EntityRef>,
}
impl IRepresentation for ProceduralShapeRepresentation {
    fn name(&self) -> &Label {
        &self.name
    }
    fn items(&self) -> &HashSet<EntityRef> {
        &self.items
    }
    fn context_of_items(&self) -> &EntityRef {
        &self.context_of_items
    }
}
impl IProceduralRepresentation for ProceduralShapeRepresentation {
    fn items(&self) -> &HashSet<EntityRef> {
        &self.items
    }
}
impl IProceduralShapeRepresentation for ProceduralShapeRepresentation {
    fn items(&self) -> &HashSet<EntityRef> {
        &self.items
    }
}
impl IShapeRepresentation for ProceduralShapeRepresentation {}
impl ProceduralShapeRepresentation {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = ProceduralShapeRepresentation::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => entity.context_of_items = parameter.into(),
                2usize => entity.items = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IProceduralShapeRepresentationSequence:
    IGeometricRepresentationItem + IProceduralRepresentationSequence
{
}
#[derive(Default, Debug)]
pub struct ProceduralShapeRepresentationSequence {
    name: Label,
    elements: Vec<EntityRef>,
    suppressed_items: HashSet<EntityRef>,
    rationale: Text,
}
impl IRepresentationItem for ProceduralShapeRepresentationSequence {
    fn name(&self) -> &Label {
        &self.name
    }
}
impl IGeometricRepresentationItem for ProceduralShapeRepresentationSequence {}
impl IProceduralShapeRepresentationSequence for ProceduralShapeRepresentationSequence {}
impl IProceduralRepresentationSequence for ProceduralShapeRepresentationSequence {
    fn elements(&self) -> &Vec<EntityRef> {
        &self.elements
    }
    fn suppressed_items(&self) -> &HashSet<EntityRef> {
        &self.suppressed_items
    }
    fn rationale(&self) -> &Text {
        &self.rationale
    }
}
impl ProceduralShapeRepresentationSequence {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = ProceduralShapeRepresentationSequence::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => entity.elements = parameter.into(),
                2usize => entity.suppressed_items = parameter.into(),
                3usize => entity.rationale = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IProduct {
    fn id(&self) -> &Identifier;
    fn name(&self) -> &Label;
    fn description(&self) -> &Option<Text>;
    fn frame_of_reference(&self) -> &HashSet<EntityRef>;
}
#[derive(Default, Debug)]
pub struct Product {
    id: Identifier,
    name: Label,
    description: Option<Text>,
    frame_of_reference: HashSet<EntityRef>,
}
impl IProduct for Product {
    fn id(&self) -> &Identifier {
        &self.id
    }
    fn name(&self) -> &Label {
        &self.name
    }
    fn description(&self) -> &Option<Text> {
        &self.description
    }
    fn frame_of_reference(&self) -> &HashSet<EntityRef> {
        &self.frame_of_reference
    }
}
impl Product {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = Product::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.id = parameter.into(),
                1usize => entity.name = parameter.into(),
                2usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => entity.frame_of_reference = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IProductCategory {
    fn name(&self) -> &Label;
    fn description(&self) -> &Option<Text>;
}
#[derive(Default, Debug)]
pub struct ProductCategory {
    name: Label,
    description: Option<Text>,
}
impl IProductCategory for ProductCategory {
    fn name(&self) -> &Label {
        &self.name
    }
    fn description(&self) -> &Option<Text> {
        &self.description
    }
}
impl ProductCategory {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = ProductCategory::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
}
pub trait IProductCategoryRelationship {
    fn name(&self) -> &Label;
    fn description(&self) -> &Option<Text>;
    fn category(&self) -> &EntityRef;
    fn sub_category(&self) -> &EntityRef;
}
#[derive(Default, Debug)]
pub struct ProductCategoryRelationship {
    name: Label,
    description: Option<Text>,
    category: EntityRef,
    sub_category: EntityRef,
}
impl IProductCategoryRelationship for ProductCategoryRelationship {
    fn name(&self) -> &Label {
        &self.name
    }
    fn description(&self) -> &Option<Text> {
        &self.description
    }
    fn category(&self) -> &EntityRef {
        &self.category
    }
    fn sub_category(&self) -> &EntityRef {
        &self.sub_category
    }
}
impl ProductCategoryRelationship {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = ProductCategoryRelationship::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => entity.category = parameter.into(),
                3usize => entity.sub_category = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IProductClass: IProductConcept + ICharacterizedObject {}
#[derive(Default, Debug)]
pub struct ProductClass {
    id: Identifier,
    name: Label,
    description: Option<Text>,
    market_context: EntityRef,
}
impl IProductConcept for ProductClass {
    fn id(&self) -> &Identifier {
        &self.id
    }
    fn name(&self) -> &Label {
        &self.name
    }
    fn description(&self) -> &Option<Text> {
        &self.description
    }
    fn market_context(&self) -> &EntityRef {
        &self.market_context
    }
}
impl ICharacterizedObject for ProductClass {
    fn name(&self) -> &Label {
        &self.name
    }
    fn description(&self) -> &Option<Text> {
        &self.description
    }
}
impl IProductClass for ProductClass {}
impl ProductClass {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = ProductClass::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.id = parameter.into(),
                1usize => entity.name = parameter.into(),
                2usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => entity.market_context = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IProductConcept {
    fn id(&self) -> &Identifier;
    fn name(&self) -> &Label;
    fn description(&self) -> &Option<Text>;
    fn market_context(&self) -> &EntityRef;
}
#[derive(Default, Debug)]
pub struct ProductConcept {
    id: Identifier,
    name: Label,
    description: Option<Text>,
    market_context: EntityRef,
}
impl IProductConcept for ProductConcept {
    fn id(&self) -> &Identifier {
        &self.id
    }
    fn name(&self) -> &Label {
        &self.name
    }
    fn description(&self) -> &Option<Text> {
        &self.description
    }
    fn market_context(&self) -> &EntityRef {
        &self.market_context
    }
}
impl ProductConcept {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = ProductConcept::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.id = parameter.into(),
                1usize => entity.name = parameter.into(),
                2usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => entity.market_context = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IProductConceptContext: IApplicationContextElement {
    fn market_segment_type(&self) -> &Label;
}
#[derive(Default, Debug)]
pub struct ProductConceptContext {
    name: Label,
    frame_of_reference: EntityRef,
    market_segment_type: Label,
}
impl IApplicationContextElement for ProductConceptContext {
    fn name(&self) -> &Label {
        &self.name
    }
    fn frame_of_reference(&self) -> &EntityRef {
        &self.frame_of_reference
    }
}
impl IProductConceptContext for ProductConceptContext {
    fn market_segment_type(&self) -> &Label {
        &self.market_segment_type
    }
}
impl ProductConceptContext {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = ProductConceptContext::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => entity.frame_of_reference = parameter.into(),
                2usize => entity.market_segment_type = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IProductConceptFeature {
    fn id(&self) -> &Identifier;
    fn name(&self) -> &Label;
    fn description(&self) -> &Option<Text>;
}
#[derive(Default, Debug)]
pub struct ProductConceptFeature {
    id: Identifier,
    name: Label,
    description: Option<Text>,
}
impl IProductConceptFeature for ProductConceptFeature {
    fn id(&self) -> &Identifier {
        &self.id
    }
    fn name(&self) -> &Label {
        &self.name
    }
    fn description(&self) -> &Option<Text> {
        &self.description
    }
}
impl ProductConceptFeature {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = ProductConceptFeature::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.id = parameter.into(),
                1usize => entity.name = parameter.into(),
                2usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
}
pub trait IProductConceptFeatureAssociation {
    fn name(&self) -> &Label;
    fn description(&self) -> &Option<Text>;
    fn concept(&self) -> &EntityRef;
    fn feature(&self) -> &EntityRef;
}
#[derive(Default, Debug)]
pub struct ProductConceptFeatureAssociation {
    name: Label,
    description: Option<Text>,
    concept: EntityRef,
    feature: EntityRef,
}
impl IProductConceptFeatureAssociation for ProductConceptFeatureAssociation {
    fn name(&self) -> &Label {
        &self.name
    }
    fn description(&self) -> &Option<Text> {
        &self.description
    }
    fn concept(&self) -> &EntityRef {
        &self.concept
    }
    fn feature(&self) -> &EntityRef {
        &self.feature
    }
}
impl ProductConceptFeatureAssociation {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = ProductConceptFeatureAssociation::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => entity.concept = parameter.into(),
                3usize => entity.feature = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IProductConceptFeatureCategory: IGroup {}
#[derive(Default, Debug)]
pub struct ProductConceptFeatureCategory {
    name: Label,
    description: Option<Text>,
}
impl IGroup for ProductConceptFeatureCategory {
    fn name(&self) -> &Label {
        &self.name
    }
    fn description(&self) -> &Option<Text> {
        &self.description
    }
}
impl IProductConceptFeatureCategory for ProductConceptFeatureCategory {}
impl ProductConceptFeatureCategory {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = ProductConceptFeatureCategory::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
}
pub trait IProductConceptFeatureCategoryUsage: IGroupAssignment {
    fn items(&self) -> &HashSet<EntityRef>;
    fn assigned_group(&self) -> &EntityRef;
}
#[derive(Default, Debug)]
pub struct ProductConceptFeatureCategoryUsage {
    items: HashSet<EntityRef>,
    assigned_group: EntityRef,
}
impl IGroupAssignment for ProductConceptFeatureCategoryUsage {
    fn assigned_group(&self) -> &EntityRef {
        &self.assigned_group
    }
}
impl IProductConceptFeatureCategoryUsage for ProductConceptFeatureCategoryUsage {
    fn items(&self) -> &HashSet<EntityRef> {
        &self.items
    }
    fn assigned_group(&self) -> &EntityRef {
        &self.assigned_group
    }
}
impl ProductConceptFeatureCategoryUsage {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = ProductConceptFeatureCategoryUsage::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.items = parameter.into(),
                1usize => entity.assigned_group = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IProductConceptRelationship {
    fn name(&self) -> &Label;
    fn description(&self) -> &Option<Text>;
    fn relating_product_concept(&self) -> &EntityRef;
    fn related_product_concept(&self) -> &EntityRef;
}
#[derive(Default, Debug)]
pub struct ProductConceptRelationship {
    name: Label,
    description: Option<Text>,
    relating_product_concept: EntityRef,
    related_product_concept: EntityRef,
}
impl IProductConceptRelationship for ProductConceptRelationship {
    fn name(&self) -> &Label {
        &self.name
    }
    fn description(&self) -> &Option<Text> {
        &self.description
    }
    fn relating_product_concept(&self) -> &EntityRef {
        &self.relating_product_concept
    }
    fn related_product_concept(&self) -> &EntityRef {
        &self.related_product_concept
    }
}
impl ProductConceptRelationship {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = ProductConceptRelationship::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => entity.relating_product_concept = parameter.into(),
                3usize => entity.related_product_concept = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IProductContext: IApplicationContextElement {
    fn discipline_type(&self) -> &Label;
}
#[derive(Default, Debug)]
pub struct ProductContext {
    name: Label,
    frame_of_reference: EntityRef,
    discipline_type: Label,
}
impl IApplicationContextElement for ProductContext {
    fn name(&self) -> &Label {
        &self.name
    }
    fn frame_of_reference(&self) -> &EntityRef {
        &self.frame_of_reference
    }
}
impl IProductContext for ProductContext {
    fn discipline_type(&self) -> &Label {
        &self.discipline_type
    }
}
impl ProductContext {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = ProductContext::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => entity.frame_of_reference = parameter.into(),
                2usize => entity.discipline_type = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IProductDefinition {
    fn id(&self) -> &Identifier;
    fn description(&self) -> &Option<Text>;
    fn formation(&self) -> &EntityRef;
    fn frame_of_reference(&self) -> &EntityRef;
}
#[derive(Default, Debug)]
pub struct ProductDefinition {
    id: Identifier,
    description: Option<Text>,
    formation: EntityRef,
    frame_of_reference: EntityRef,
}
impl IProductDefinition for ProductDefinition {
    fn id(&self) -> &Identifier {
        &self.id
    }
    fn description(&self) -> &Option<Text> {
        &self.description
    }
    fn formation(&self) -> &EntityRef {
        &self.formation
    }
    fn frame_of_reference(&self) -> &EntityRef {
        &self.frame_of_reference
    }
}
impl ProductDefinition {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = ProductDefinition::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.id = parameter.into(),
                1usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => entity.formation = parameter.into(),
                3usize => entity.frame_of_reference = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IProductDefinitionContext: IApplicationContextElement {
    fn life_cycle_stage(&self) -> &Label;
}
#[derive(Default, Debug)]
pub struct ProductDefinitionContext {
    name: Label,
    frame_of_reference: EntityRef,
    life_cycle_stage: Label,
}
impl IApplicationContextElement for ProductDefinitionContext {
    fn name(&self) -> &Label {
        &self.name
    }
    fn frame_of_reference(&self) -> &EntityRef {
        &self.frame_of_reference
    }
}
impl IProductDefinitionContext for ProductDefinitionContext {
    fn life_cycle_stage(&self) -> &Label {
        &self.life_cycle_stage
    }
}
impl ProductDefinitionContext {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = ProductDefinitionContext::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => entity.frame_of_reference = parameter.into(),
                2usize => entity.life_cycle_stage = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IProductDefinitionContextAssociation {
    fn definition(&self) -> &EntityRef;
    fn frame_of_reference(&self) -> &EntityRef;
    fn role(&self) -> &EntityRef;
}
#[derive(Default, Debug)]
pub struct ProductDefinitionContextAssociation {
    definition: EntityRef,
    frame_of_reference: EntityRef,
    role: EntityRef,
}
impl IProductDefinitionContextAssociation for ProductDefinitionContextAssociation {
    fn definition(&self) -> &EntityRef {
        &self.definition
    }
    fn frame_of_reference(&self) -> &EntityRef {
        &self.frame_of_reference
    }
    fn role(&self) -> &EntityRef {
        &self.role
    }
}
impl ProductDefinitionContextAssociation {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = ProductDefinitionContextAssociation::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.definition = parameter.into(),
                1usize => entity.frame_of_reference = parameter.into(),
                2usize => entity.role = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IProductDefinitionContextRole {
    fn name(&self) -> &Label;
    fn description(&self) -> &Option<Text>;
}
#[derive(Default, Debug)]
pub struct ProductDefinitionContextRole {
    name: Label,
    description: Option<Text>,
}
impl IProductDefinitionContextRole for ProductDefinitionContextRole {
    fn name(&self) -> &Label {
        &self.name
    }
    fn description(&self) -> &Option<Text> {
        &self.description
    }
}
impl ProductDefinitionContextRole {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = ProductDefinitionContextRole::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
}
pub trait IProductDefinitionEffectivity: IEffectivity {
    fn usage(&self) -> &EntityRef;
}
#[derive(Default, Debug)]
pub struct ProductDefinitionEffectivity {
    id: Identifier,
    usage: EntityRef,
}
impl IEffectivity for ProductDefinitionEffectivity {
    fn id(&self) -> &Identifier {
        &self.id
    }
}
impl IProductDefinitionEffectivity for ProductDefinitionEffectivity {
    fn usage(&self) -> &EntityRef {
        &self.usage
    }
}
impl ProductDefinitionEffectivity {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = ProductDefinitionEffectivity::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.id = parameter.into(),
                1usize => entity.usage = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IProductDefinitionElementRelationship: IGroup {}
#[derive(Default, Debug)]
pub struct ProductDefinitionElementRelationship {
    name: Label,
    description: Option<Text>,
}
impl IGroup for ProductDefinitionElementRelationship {
    fn name(&self) -> &Label {
        &self.name
    }
    fn description(&self) -> &Option<Text> {
        &self.description
    }
}
impl IProductDefinitionElementRelationship for ProductDefinitionElementRelationship {}
impl ProductDefinitionElementRelationship {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = ProductDefinitionElementRelationship::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
}
pub trait IProductDefinitionFormation {
    fn id(&self) -> &Identifier;
    fn description(&self) -> &Option<Text>;
    fn of_product(&self) -> &EntityRef;
}
#[derive(Default, Debug)]
pub struct ProductDefinitionFormation {
    id: Identifier,
    description: Option<Text>,
    of_product: EntityRef,
}
impl IProductDefinitionFormation for ProductDefinitionFormation {
    fn id(&self) -> &Identifier {
        &self.id
    }
    fn description(&self) -> &Option<Text> {
        &self.description
    }
    fn of_product(&self) -> &EntityRef {
        &self.of_product
    }
}
impl ProductDefinitionFormation {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = ProductDefinitionFormation::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.id = parameter.into(),
                1usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => entity.of_product = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IProductDefinitionFormationRelationship {
    fn id(&self) -> &Identifier;
    fn name(&self) -> &Label;
    fn description(&self) -> &Option<Text>;
    fn relating_product_definition_formation(&self) -> &EntityRef;
    fn related_product_definition_formation(&self) -> &EntityRef;
}
#[derive(Default, Debug)]
pub struct ProductDefinitionFormationRelationship {
    id: Identifier,
    name: Label,
    description: Option<Text>,
    relating_product_definition_formation: EntityRef,
    related_product_definition_formation: EntityRef,
}
impl IProductDefinitionFormationRelationship for ProductDefinitionFormationRelationship {
    fn id(&self) -> &Identifier {
        &self.id
    }
    fn name(&self) -> &Label {
        &self.name
    }
    fn description(&self) -> &Option<Text> {
        &self.description
    }
    fn relating_product_definition_formation(&self) -> &EntityRef {
        &self.relating_product_definition_formation
    }
    fn related_product_definition_formation(&self) -> &EntityRef {
        &self.related_product_definition_formation
    }
}
impl ProductDefinitionFormationRelationship {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = ProductDefinitionFormationRelationship::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.id = parameter.into(),
                1usize => entity.name = parameter.into(),
                2usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => entity.relating_product_definition_formation = parameter.into(),
                4usize => entity.related_product_definition_formation = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IProductDefinitionFormationWithSpecifiedSource: IProductDefinitionFormation {
    fn make_or_buy(&self) -> &Source;
}
#[derive(Default, Debug)]
pub struct ProductDefinitionFormationWithSpecifiedSource {
    id: Identifier,
    description: Option<Text>,
    of_product: EntityRef,
    make_or_buy: Source,
}
impl IProductDefinitionFormation for ProductDefinitionFormationWithSpecifiedSource {
    fn id(&self) -> &Identifier {
        &self.id
    }
    fn description(&self) -> &Option<Text> {
        &self.description
    }
    fn of_product(&self) -> &EntityRef {
        &self.of_product
    }
}
impl IProductDefinitionFormationWithSpecifiedSource for ProductDefinitionFormationWithSpecifiedSource {
    fn make_or_buy(&self) -> &Source {
        &self.make_or_buy
    }
}
impl ProductDefinitionFormationWithSpecifiedSource {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = ProductDefinitionFormationWithSpecifiedSource::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.id = parameter.into(),
                1usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => entity.of_product = parameter.into(),
                3usize => entity.make_or_buy = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IProductDefinitionGroupAssignment: IGroupAssignment {
    fn items(&self) -> &HashSet<EntityRef>;
    fn assigned_group(&self) -> &EntityRef;
}
#[derive(Default, Debug)]
pub struct ProductDefinitionGroupAssignment {
    items: HashSet<EntityRef>,
    assigned_group: EntityRef,
}
impl IGroupAssignment for ProductDefinitionGroupAssignment {
    fn assigned_group(&self) -> &EntityRef {
        &self.assigned_group
    }
}
impl IProductDefinitionGroupAssignment for ProductDefinitionGroupAssignment {
    fn items(&self) -> &HashSet<EntityRef> {
        &self.items
    }
    fn assigned_group(&self) -> &EntityRef {
        &self.assigned_group
    }
}
impl ProductDefinitionGroupAssignment {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = ProductDefinitionGroupAssignment::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.items = parameter.into(),
                1usize => entity.assigned_group = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IProductDefinitionOccurrenceRelationship {
    fn name(&self) -> &Label;
    fn description(&self) -> &Option<Text>;
    fn occurrence(&self) -> &EntityRef;
    fn occurrence_usage(&self) -> &EntityRef;
}
#[derive(Default, Debug)]
pub struct ProductDefinitionOccurrenceRelationship {
    name: Label,
    description: Option<Text>,
    occurrence: EntityRef,
    occurrence_usage: EntityRef,
}
impl IProductDefinitionOccurrenceRelationship for ProductDefinitionOccurrenceRelationship {
    fn name(&self) -> &Label {
        &self.name
    }
    fn description(&self) -> &Option<Text> {
        &self.description
    }
    fn occurrence(&self) -> &EntityRef {
        &self.occurrence
    }
    fn occurrence_usage(&self) -> &EntityRef {
        &self.occurrence_usage
    }
}
impl ProductDefinitionOccurrenceRelationship {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = ProductDefinitionOccurrenceRelationship::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => entity.occurrence = parameter.into(),
                3usize => entity.occurrence_usage = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IProductDefinitionRelationship {
    fn id(&self) -> &Identifier;
    fn name(&self) -> &Label;
    fn description(&self) -> &Option<Text>;
    fn relating_product_definition(&self) -> &EntityRef;
    fn related_product_definition(&self) -> &EntityRef;
}
#[derive(Default, Debug)]
pub struct ProductDefinitionRelationship {
    id: Identifier,
    name: Label,
    description: Option<Text>,
    relating_product_definition: EntityRef,
    related_product_definition: EntityRef,
}
impl IProductDefinitionRelationship for ProductDefinitionRelationship {
    fn id(&self) -> &Identifier {
        &self.id
    }
    fn name(&self) -> &Label {
        &self.name
    }
    fn description(&self) -> &Option<Text> {
        &self.description
    }
    fn relating_product_definition(&self) -> &EntityRef {
        &self.relating_product_definition
    }
    fn related_product_definition(&self) -> &EntityRef {
        &self.related_product_definition
    }
}
impl ProductDefinitionRelationship {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = ProductDefinitionRelationship::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.id = parameter.into(),
                1usize => entity.name = parameter.into(),
                2usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => entity.relating_product_definition = parameter.into(),
                4usize => entity.related_product_definition = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IProductDefinitionShape: IPropertyDefinition {}
#[derive(Default, Debug)]
pub struct ProductDefinitionShape {
    name: Label,
    description: Option<Text>,
    definition: EntityRef,
}
impl IPropertyDefinition for ProductDefinitionShape {
    fn name(&self) -> &Label {
        &self.name
    }
    fn description(&self) -> &Option<Text> {
        &self.description
    }
    fn definition(&self) -> &EntityRef {
        &self.definition
    }
}
impl IProductDefinitionShape for ProductDefinitionShape {}
impl ProductDefinitionShape {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = ProductDefinitionShape::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => entity.definition = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IProductDefinitionSubstitute {
    fn description(&self) -> &Option<Text>;
    fn context_relationship(&self) -> &EntityRef;
    fn substitute_definition(&self) -> &EntityRef;
}
#[derive(Default, Debug)]
pub struct ProductDefinitionSubstitute {
    description: Option<Text>,
    context_relationship: EntityRef,
    substitute_definition: EntityRef,
}
impl IProductDefinitionSubstitute for ProductDefinitionSubstitute {
    fn description(&self) -> &Option<Text> {
        &self.description
    }
    fn context_relationship(&self) -> &EntityRef {
        &self.context_relationship
    }
    fn substitute_definition(&self) -> &EntityRef {
        &self.substitute_definition
    }
}
impl ProductDefinitionSubstitute {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = ProductDefinitionSubstitute::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                1usize => entity.context_relationship = parameter.into(),
                2usize => entity.substitute_definition = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IProductDefinitionUsage: IProductDefinitionRelationship {}
#[derive(Default, Debug)]
pub struct ProductDefinitionUsage {
    id: Identifier,
    name: Label,
    description: Option<Text>,
    relating_product_definition: EntityRef,
    related_product_definition: EntityRef,
}
impl IProductDefinitionRelationship for ProductDefinitionUsage {
    fn id(&self) -> &Identifier {
        &self.id
    }
    fn name(&self) -> &Label {
        &self.name
    }
    fn description(&self) -> &Option<Text> {
        &self.description
    }
    fn relating_product_definition(&self) -> &EntityRef {
        &self.relating_product_definition
    }
    fn related_product_definition(&self) -> &EntityRef {
        &self.related_product_definition
    }
}
impl IProductDefinitionUsage for ProductDefinitionUsage {}
impl ProductDefinitionUsage {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = ProductDefinitionUsage::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.id = parameter.into(),
                1usize => entity.name = parameter.into(),
                2usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => entity.relating_product_definition = parameter.into(),
                4usize => entity.related_product_definition = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IProductDefinitionWithAssociatedDocuments: IProductDefinition {
    fn documentation_ids(&self) -> &HashSet<EntityRef>;
}
#[derive(Default, Debug)]
pub struct ProductDefinitionWithAssociatedDocuments {
    id: Identifier,
    description: Option<Text>,
    formation: EntityRef,
    frame_of_reference: EntityRef,
    documentation_ids: HashSet<EntityRef>,
}
impl IProductDefinition for ProductDefinitionWithAssociatedDocuments {
    fn id(&self) -> &Identifier {
        &self.id
    }
    fn description(&self) -> &Option<Text> {
        &self.description
    }
    fn formation(&self) -> &EntityRef {
        &self.formation
    }
    fn frame_of_reference(&self) -> &EntityRef {
        &self.frame_of_reference
    }
}
impl IProductDefinitionWithAssociatedDocuments for ProductDefinitionWithAssociatedDocuments {
    fn documentation_ids(&self) -> &HashSet<EntityRef> {
        &self.documentation_ids
    }
}
impl ProductDefinitionWithAssociatedDocuments {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = ProductDefinitionWithAssociatedDocuments::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.id = parameter.into(),
                1usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => entity.formation = parameter.into(),
                3usize => entity.frame_of_reference = parameter.into(),
                4usize => entity.documentation_ids = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IProductIdentification: IConfigurationItem + ICharacterizedObject {
    fn item_concept(&self) -> &EntityRef;
}
#[derive(Default, Debug)]
pub struct ProductIdentification {
    id: Identifier,
    name: Label,
    description: Option<Text>,
    purpose: Option<Label>,
    item_concept: EntityRef,
}
impl IConfigurationItem for ProductIdentification {
    fn id(&self) -> &Identifier {
        &self.id
    }
    fn name(&self) -> &Label {
        &self.name
    }
    fn description(&self) -> &Option<Text> {
        &self.description
    }
    fn item_concept(&self) -> &EntityRef {
        &self.item_concept
    }
    fn purpose(&self) -> &Option<Label> {
        &self.purpose
    }
}
impl ICharacterizedObject for ProductIdentification {
    fn name(&self) -> &Label {
        &self.name
    }
    fn description(&self) -> &Option<Text> {
        &self.description
    }
}
impl IProductIdentification for ProductIdentification {
    fn item_concept(&self) -> &EntityRef {
        &self.item_concept
    }
}
impl ProductIdentification {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = ProductIdentification::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.id = parameter.into(),
                1usize => entity.name = parameter.into(),
                2usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.purpose = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => entity.item_concept = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IProductMaterialCompositionRelationship: IProductDefinitionRelationship {
    fn class(&self) -> &Label;
    fn constituent_amount(&self) -> &HashSet<EntityRef>;
    fn composition_basis(&self) -> &Label;
    fn determination_method(&self) -> &Text;
}
#[derive(Default, Debug)]
pub struct ProductMaterialCompositionRelationship {
    id: Identifier,
    name: Label,
    description: Option<Text>,
    relating_product_definition: EntityRef,
    related_product_definition: EntityRef,
    class: Label,
    constituent_amount: HashSet<EntityRef>,
    composition_basis: Label,
    determination_method: Text,
}
impl IProductDefinitionRelationship for ProductMaterialCompositionRelationship {
    fn id(&self) -> &Identifier {
        &self.id
    }
    fn name(&self) -> &Label {
        &self.name
    }
    fn description(&self) -> &Option<Text> {
        &self.description
    }
    fn relating_product_definition(&self) -> &EntityRef {
        &self.relating_product_definition
    }
    fn related_product_definition(&self) -> &EntityRef {
        &self.related_product_definition
    }
}
impl IProductMaterialCompositionRelationship for ProductMaterialCompositionRelationship {
    fn class(&self) -> &Label {
        &self.class
    }
    fn constituent_amount(&self) -> &HashSet<EntityRef> {
        &self.constituent_amount
    }
    fn composition_basis(&self) -> &Label {
        &self.composition_basis
    }
    fn determination_method(&self) -> &Text {
        &self.determination_method
    }
}
impl ProductMaterialCompositionRelationship {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = ProductMaterialCompositionRelationship::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.id = parameter.into(),
                1usize => entity.name = parameter.into(),
                2usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => entity.relating_product_definition = parameter.into(),
                4usize => entity.related_product_definition = parameter.into(),
                5usize => entity.class = parameter.into(),
                6usize => entity.constituent_amount = parameter.into(),
                7usize => entity.composition_basis = parameter.into(),
                8usize => entity.determination_method = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IProductRelatedProductCategory: IProductCategory {
    fn products(&self) -> &HashSet<EntityRef>;
}
#[derive(Default, Debug)]
pub struct ProductRelatedProductCategory {
    name: Label,
    description: Option<Text>,
    products: HashSet<EntityRef>,
}
impl IProductCategory for ProductRelatedProductCategory {
    fn name(&self) -> &Label {
        &self.name
    }
    fn description(&self) -> &Option<Text> {
        &self.description
    }
}
impl IProductRelatedProductCategory for ProductRelatedProductCategory {
    fn products(&self) -> &HashSet<EntityRef> {
        &self.products
    }
}
impl ProductRelatedProductCategory {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = ProductRelatedProductCategory::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => entity.products = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IProductSpecification: IProductIdentification + IConfigurableItem {}
#[derive(Default, Debug)]
pub struct ProductSpecification {
    id: Identifier,
    name: Label,
    description: Option<Text>,
    purpose: Option<Label>,
    item_concept: EntityRef,
    item_concept_feature: HashSet<EntityRef>,
}
impl IConfigurationItem for ProductSpecification {
    fn id(&self) -> &Identifier {
        &self.id
    }
    fn name(&self) -> &Label {
        &self.name
    }
    fn description(&self) -> &Option<Text> {
        &self.description
    }
    fn item_concept(&self) -> &EntityRef {
        &self.item_concept
    }
    fn purpose(&self) -> &Option<Label> {
        &self.purpose
    }
}
impl ICharacterizedObject for ProductSpecification {
    fn name(&self) -> &Label {
        &self.name
    }
    fn description(&self) -> &Option<Text> {
        &self.description
    }
}
impl IProductIdentification for ProductSpecification {
    fn item_concept(&self) -> &EntityRef {
        &self.item_concept
    }
}
impl IProductSpecification for ProductSpecification {}
impl IConfigurableItem for ProductSpecification {
    fn item_concept_feature(&self) -> &HashSet<EntityRef> {
        &self.item_concept_feature
    }
}
impl ProductSpecification {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = ProductSpecification::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.id = parameter.into(),
                1usize => entity.name = parameter.into(),
                2usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.purpose = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => entity.item_concept = parameter.into(),
                5usize => entity.item_concept_feature = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IProjectedZoneDefinition: IToleranceZoneDefinition {
    fn projection_end(&self) -> &EntityRef;
    fn projected_length(&self) -> &EntityRef;
}
#[derive(Default, Debug)]
pub struct ProjectedZoneDefinition {
    zone: EntityRef,
    boundaries: HashSet<EntityRef>,
    projection_end: EntityRef,
    projected_length: EntityRef,
}
impl IToleranceZoneDefinition for ProjectedZoneDefinition {
    fn zone(&self) -> &EntityRef {
        &self.zone
    }
    fn boundaries(&self) -> &HashSet<EntityRef> {
        &self.boundaries
    }
}
impl IProjectedZoneDefinition for ProjectedZoneDefinition {
    fn projection_end(&self) -> &EntityRef {
        &self.projection_end
    }
    fn projected_length(&self) -> &EntityRef {
        &self.projected_length
    }
}
impl ProjectedZoneDefinition {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = ProjectedZoneDefinition::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.zone = parameter.into(),
                1usize => entity.boundaries = parameter.into(),
                2usize => entity.projection_end = parameter.into(),
                3usize => entity.projected_length = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IProjectionCurve: IAnnotationCurveOccurrence {}
#[derive(Default, Debug)]
pub struct ProjectionCurve {
    name: Label,
    styles: HashSet<EntityRef>,
    item: EntityRef,
}
impl IRepresentationItem for ProjectionCurve {
    fn name(&self) -> &Label {
        &self.name
    }
}
impl IStyledItem for ProjectionCurve {
    fn styles(&self) -> &HashSet<EntityRef> {
        &self.styles
    }
    fn item(&self) -> &EntityRef {
        &self.item
    }
}
impl IAnnotationOccurrence for ProjectionCurve {}
impl IAnnotationCurveOccurrence for ProjectionCurve {
    fn item(&self) -> &EntityRef {
        &self.item
    }
}
impl IProjectionCurve for ProjectionCurve {}
impl ProjectionCurve {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = ProjectionCurve::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => entity.styles = parameter.into(),
                2usize => entity.item = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IProjectionDirectedCallout: IDraughtingCallout {}
#[derive(Default, Debug)]
pub struct ProjectionDirectedCallout {
    name: Label,
    contents: HashSet<EntityRef>,
}
impl IRepresentationItem for ProjectionDirectedCallout {
    fn name(&self) -> &Label {
        &self.name
    }
}
impl IGeometricRepresentationItem for ProjectionDirectedCallout {}
impl IDraughtingCallout for ProjectionDirectedCallout {
    fn contents(&self) -> &HashSet<EntityRef> {
        &self.contents
    }
}
impl IProjectionDirectedCallout for ProjectionDirectedCallout {}
impl ProjectionDirectedCallout {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = ProjectionDirectedCallout::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => entity.contents = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IPromissoryUsageOccurrence: IAssemblyComponentUsage {}
#[derive(Default, Debug)]
pub struct PromissoryUsageOccurrence {
    id: Identifier,
    name: Label,
    description: Option<Text>,
    relating_product_definition: EntityRef,
    related_product_definition: EntityRef,
    reference_designator: Option<Identifier>,
}
impl IProductDefinitionRelationship for PromissoryUsageOccurrence {
    fn id(&self) -> &Identifier {
        &self.id
    }
    fn name(&self) -> &Label {
        &self.name
    }
    fn description(&self) -> &Option<Text> {
        &self.description
    }
    fn relating_product_definition(&self) -> &EntityRef {
        &self.relating_product_definition
    }
    fn related_product_definition(&self) -> &EntityRef {
        &self.related_product_definition
    }
}
impl IProductDefinitionUsage for PromissoryUsageOccurrence {}
impl IAssemblyComponentUsage for PromissoryUsageOccurrence {
    fn reference_designator(&self) -> &Option<Identifier> {
        &self.reference_designator
    }
}
impl IPromissoryUsageOccurrence for PromissoryUsageOccurrence {}
impl PromissoryUsageOccurrence {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = PromissoryUsageOccurrence::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.id = parameter.into(),
                1usize => entity.name = parameter.into(),
                2usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => entity.relating_product_definition = parameter.into(),
                4usize => entity.related_product_definition = parameter.into(),
                5usize => {
                    entity.reference_designator = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
}
pub trait IPropertyDefinition {
    fn name(&self) -> &Label;
    fn description(&self) -> &Option<Text>;
    fn definition(&self) -> &EntityRef;
}
#[derive(Default, Debug)]
pub struct PropertyDefinition {
    name: Label,
    description: Option<Text>,
    definition: EntityRef,
}
impl IPropertyDefinition for PropertyDefinition {
    fn name(&self) -> &Label {
        &self.name
    }
    fn description(&self) -> &Option<Text> {
        &self.description
    }
    fn definition(&self) -> &EntityRef {
        &self.definition
    }
}
impl PropertyDefinition {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = PropertyDefinition::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => entity.definition = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IPropertyDefinitionRelationship {
    fn name(&self) -> &Label;
    fn description(&self) -> &Text;
    fn relating_property_definition(&self) -> &EntityRef;
    fn related_property_definition(&self) -> &EntityRef;
}
#[derive(Default, Debug)]
pub struct PropertyDefinitionRelationship {
    name: Label,
    description: Text,
    relating_property_definition: EntityRef,
    related_property_definition: EntityRef,
}
impl IPropertyDefinitionRelationship for PropertyDefinitionRelationship {
    fn name(&self) -> &Label {
        &self.name
    }
    fn description(&self) -> &Text {
        &self.description
    }
    fn relating_property_definition(&self) -> &EntityRef {
        &self.relating_property_definition
    }
    fn related_property_definition(&self) -> &EntityRef {
        &self.related_property_definition
    }
}
impl PropertyDefinitionRelationship {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = PropertyDefinitionRelationship::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => entity.description = parameter.into(),
                2usize => entity.relating_property_definition = parameter.into(),
                3usize => entity.related_property_definition = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IPropertyDefinitionRepresentation {
    fn definition(&self) -> &EntityRef;
    fn used_representation(&self) -> &EntityRef;
}
#[derive(Default, Debug)]
pub struct PropertyDefinitionRepresentation {
    definition: EntityRef,
    used_representation: EntityRef,
}
impl IPropertyDefinitionRepresentation for PropertyDefinitionRepresentation {
    fn definition(&self) -> &EntityRef {
        &self.definition
    }
    fn used_representation(&self) -> &EntityRef {
        &self.used_representation
    }
}
impl PropertyDefinitionRepresentation {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = PropertyDefinitionRepresentation::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.definition = parameter.into(),
                1usize => entity.used_representation = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IQualifiedRepresentationItem: IRepresentationItem {
    fn qualifiers(&self) -> &HashSet<EntityRef>;
}
#[derive(Default, Debug)]
pub struct QualifiedRepresentationItem {
    name: Label,
    qualifiers: HashSet<EntityRef>,
}
impl IRepresentationItem for QualifiedRepresentationItem {
    fn name(&self) -> &Label {
        &self.name
    }
}
impl IQualifiedRepresentationItem for QualifiedRepresentationItem {
    fn qualifiers(&self) -> &HashSet<EntityRef> {
        &self.qualifiers
    }
}
impl QualifiedRepresentationItem {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = QualifiedRepresentationItem::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => entity.qualifiers = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IQualitativeUncertainty: IUncertaintyQualifier {
    fn uncertainty_value(&self) -> &Text;
}
#[derive(Default, Debug)]
pub struct QualitativeUncertainty {
    measure_name: Label,
    description: Text,
    uncertainty_value: Text,
}
impl IUncertaintyQualifier for QualitativeUncertainty {
    fn measure_name(&self) -> &Label {
        &self.measure_name
    }
    fn description(&self) -> &Text {
        &self.description
    }
}
impl IQualitativeUncertainty for QualitativeUncertainty {
    fn uncertainty_value(&self) -> &Text {
        &self.uncertainty_value
    }
}
impl QualitativeUncertainty {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = QualitativeUncertainty::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.measure_name = parameter.into(),
                1usize => entity.description = parameter.into(),
                2usize => entity.uncertainty_value = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IQuantifiedAssemblyComponentUsage: IAssemblyComponentUsage {
    fn quantity(&self) -> &EntityRef;
}
#[derive(Default, Debug)]
pub struct QuantifiedAssemblyComponentUsage {
    id: Identifier,
    name: Label,
    description: Option<Text>,
    relating_product_definition: EntityRef,
    related_product_definition: EntityRef,
    reference_designator: Option<Identifier>,
    quantity: EntityRef,
}
impl IProductDefinitionRelationship for QuantifiedAssemblyComponentUsage {
    fn id(&self) -> &Identifier {
        &self.id
    }
    fn name(&self) -> &Label {
        &self.name
    }
    fn description(&self) -> &Option<Text> {
        &self.description
    }
    fn relating_product_definition(&self) -> &EntityRef {
        &self.relating_product_definition
    }
    fn related_product_definition(&self) -> &EntityRef {
        &self.related_product_definition
    }
}
impl IProductDefinitionUsage for QuantifiedAssemblyComponentUsage {}
impl IAssemblyComponentUsage for QuantifiedAssemblyComponentUsage {
    fn reference_designator(&self) -> &Option<Identifier> {
        &self.reference_designator
    }
}
impl IQuantifiedAssemblyComponentUsage for QuantifiedAssemblyComponentUsage {
    fn quantity(&self) -> &EntityRef {
        &self.quantity
    }
}
impl QuantifiedAssemblyComponentUsage {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = QuantifiedAssemblyComponentUsage::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.id = parameter.into(),
                1usize => entity.name = parameter.into(),
                2usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => entity.relating_product_definition = parameter.into(),
                4usize => entity.related_product_definition = parameter.into(),
                5usize => {
                    entity.reference_designator = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                6usize => entity.quantity = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IQuasiUniformCurve: IBSplineCurve {}
#[derive(Default, Debug)]
pub struct QuasiUniformCurve {
    name: Label,
    degree: i64,
    control_points_list: Vec<EntityRef>,
    curve_form: BSplineCurveForm,
    closed_curve: Option<bool>,
    self_intersect: Option<bool>,
}
impl IRepresentationItem for QuasiUniformCurve {
    fn name(&self) -> &Label {
        &self.name
    }
}
impl IGeometricRepresentationItem for QuasiUniformCurve {}
impl ICurve for QuasiUniformCurve {}
impl IBoundedCurve for QuasiUniformCurve {}
impl IBSplineCurve for QuasiUniformCurve {
    fn degree(&self) -> i64 {
        self.degree
    }
    fn control_points_list(&self) -> &Vec<EntityRef> {
        &self.control_points_list
    }
    fn curve_form(&self) -> &BSplineCurveForm {
        &self.curve_form
    }
    fn closed_curve(&self) -> Option<bool> {
        self.closed_curve
    }
    fn self_intersect(&self) -> Option<bool> {
        self.self_intersect
    }
}
impl IQuasiUniformCurve for QuasiUniformCurve {}
impl QuasiUniformCurve {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = QuasiUniformCurve::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => entity.degree = parameter.into(),
                2usize => entity.control_points_list = parameter.into(),
                3usize => entity.curve_form = parameter.into(),
                4usize => entity.closed_curve = parameter.into(),
                5usize => entity.self_intersect = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IQuasiUniformSurface: IBSplineSurface {}
#[derive(Default, Debug)]
pub struct QuasiUniformSurface {
    name: Label,
    u_degree: i64,
    v_degree: i64,
    control_points_list: Vec<Vec<EntityRef>>,
    surface_form: BSplineSurfaceForm,
    u_closed: Option<bool>,
    v_closed: Option<bool>,
    self_intersect: Option<bool>,
}
impl IRepresentationItem for QuasiUniformSurface {
    fn name(&self) -> &Label {
        &self.name
    }
}
impl IGeometricRepresentationItem for QuasiUniformSurface {}
impl ISurface for QuasiUniformSurface {}
impl IBoundedSurface for QuasiUniformSurface {}
impl IBSplineSurface for QuasiUniformSurface {
    fn u_degree(&self) -> i64 {
        self.u_degree
    }
    fn v_degree(&self) -> i64 {
        self.v_degree
    }
    fn control_points_list(&self) -> &Vec<Vec<EntityRef>> {
        &self.control_points_list
    }
    fn surface_form(&self) -> &BSplineSurfaceForm {
        &self.surface_form
    }
    fn u_closed(&self) -> Option<bool> {
        self.u_closed
    }
    fn v_closed(&self) -> Option<bool> {
        self.v_closed
    }
    fn self_intersect(&self) -> Option<bool> {
        self.self_intersect
    }
}
impl IQuasiUniformSurface for QuasiUniformSurface {}
impl QuasiUniformSurface {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = QuasiUniformSurface::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => entity.u_degree = parameter.into(),
                2usize => entity.v_degree = parameter.into(),
                3usize => entity.control_points_list = parameter.into(),
                4usize => entity.surface_form = parameter.into(),
                5usize => entity.u_closed = parameter.into(),
                6usize => entity.v_closed = parameter.into(),
                7usize => entity.self_intersect = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IRadioactivityMeasureWithUnit: IMeasureWithUnit {}
#[derive(Default, Debug)]
pub struct RadioactivityMeasureWithUnit {
    value_component: MeasureValue,
    unit_component: EntityRef,
}
impl IMeasureWithUnit for RadioactivityMeasureWithUnit {
    fn value_component(&self) -> &MeasureValue {
        &self.value_component
    }
    fn unit_component(&self) -> &EntityRef {
        &self.unit_component
    }
}
impl IRadioactivityMeasureWithUnit for RadioactivityMeasureWithUnit {}
impl RadioactivityMeasureWithUnit {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = RadioactivityMeasureWithUnit::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.value_component = parameter.into(),
                1usize => entity.unit_component = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IRadioactivityUnit: IDerivedUnit {}
#[derive(Default, Debug)]
pub struct RadioactivityUnit {
    elements: HashSet<EntityRef>,
}
impl IDerivedUnit for RadioactivityUnit {
    fn elements(&self) -> &HashSet<EntityRef> {
        &self.elements
    }
}
impl IRadioactivityUnit for RadioactivityUnit {}
impl RadioactivityUnit {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = RadioactivityUnit::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.elements = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IRadiusDimension: IDimensionCurveDirectedCallout {}
#[derive(Default, Debug)]
pub struct RadiusDimension {
    name: Label,
    contents: HashSet<EntityRef>,
}
impl IRepresentationItem for RadiusDimension {
    fn name(&self) -> &Label {
        &self.name
    }
}
impl IGeometricRepresentationItem for RadiusDimension {}
impl IDraughtingCallout for RadiusDimension {
    fn contents(&self) -> &HashSet<EntityRef> {
        &self.contents
    }
}
impl IDimensionCurveDirectedCallout for RadiusDimension {}
impl IRadiusDimension for RadiusDimension {}
impl RadiusDimension {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = RadiusDimension::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => entity.contents = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IRangeCharacteristic: IRepresentation + IDescriptiveRepresentationItem {}
#[derive(Default, Debug)]
pub struct RangeCharacteristic {
    name: Label,
    items: HashSet<EntityRef>,
    context_of_items: EntityRef,
    description: Text,
}
impl IRepresentation for RangeCharacteristic {
    fn name(&self) -> &Label {
        &self.name
    }
    fn items(&self) -> &HashSet<EntityRef> {
        &self.items
    }
    fn context_of_items(&self) -> &EntityRef {
        &self.context_of_items
    }
}
impl IRepresentationItem for RangeCharacteristic {
    fn name(&self) -> &Label {
        &self.name
    }
}
impl IDescriptiveRepresentationItem for RangeCharacteristic {
    fn description(&self) -> &Text {
        &self.description
    }
}
impl IRangeCharacteristic for RangeCharacteristic {}
impl RangeCharacteristic {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = RangeCharacteristic::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => entity.items = parameter.into(),
                2usize => entity.context_of_items = parameter.into(),
                3usize => entity.description = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IRatioMeasureWithUnit: IMeasureWithUnit {}
#[derive(Default, Debug)]
pub struct RatioMeasureWithUnit {
    value_component: MeasureValue,
    unit_component: EntityRef,
}
impl IMeasureWithUnit for RatioMeasureWithUnit {
    fn value_component(&self) -> &MeasureValue {
        &self.value_component
    }
    fn unit_component(&self) -> &EntityRef {
        &self.unit_component
    }
}
impl IRatioMeasureWithUnit for RatioMeasureWithUnit {}
impl RatioMeasureWithUnit {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = RatioMeasureWithUnit::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.value_component = parameter.into(),
                1usize => entity.unit_component = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IRatioUnit: INamedUnit {}
#[derive(Default, Debug)]
pub struct RatioUnit {
    dimensions: EntityRef,
}
impl INamedUnit for RatioUnit {
    fn dimensions(&self) -> &EntityRef {
        &self.dimensions
    }
}
impl IRatioUnit for RatioUnit {}
impl RatioUnit {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = RatioUnit::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.dimensions = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IRationalBSplineCurve: IBSplineCurve {
    fn weights_data(&self) -> &Vec<Real>;
}
#[derive(Default, Debug)]
pub struct RationalBSplineCurve {
    name: Label,
    degree: i64,
    control_points_list: Vec<EntityRef>,
    curve_form: BSplineCurveForm,
    closed_curve: Option<bool>,
    self_intersect: Option<bool>,
    weights_data: Vec<Real>,
}
impl IRepresentationItem for RationalBSplineCurve {
    fn name(&self) -> &Label {
        &self.name
    }
}
impl IGeometricRepresentationItem for RationalBSplineCurve {}
impl ICurve for RationalBSplineCurve {}
impl IBoundedCurve for RationalBSplineCurve {}
impl IBSplineCurve for RationalBSplineCurve {
    fn degree(&self) -> i64 {
        self.degree
    }
    fn control_points_list(&self) -> &Vec<EntityRef> {
        &self.control_points_list
    }
    fn curve_form(&self) -> &BSplineCurveForm {
        &self.curve_form
    }
    fn closed_curve(&self) -> Option<bool> {
        self.closed_curve
    }
    fn self_intersect(&self) -> Option<bool> {
        self.self_intersect
    }
}
impl IRationalBSplineCurve for RationalBSplineCurve {
    fn weights_data(&self) -> &Vec<Real> {
        &self.weights_data
    }
}
impl RationalBSplineCurve {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = RationalBSplineCurve::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => entity.degree = parameter.into(),
                2usize => entity.control_points_list = parameter.into(),
                3usize => entity.curve_form = parameter.into(),
                4usize => entity.closed_curve = parameter.into(),
                5usize => entity.self_intersect = parameter.into(),
                6usize => entity.weights_data = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IRationalBSplineSurface: IBSplineSurface {
    fn weights_data(&self) -> &Vec<Vec<Real>>;
}
#[derive(Default, Debug)]
pub struct RationalBSplineSurface {
    name: Label,
    u_degree: i64,
    v_degree: i64,
    control_points_list: Vec<Vec<EntityRef>>,
    surface_form: BSplineSurfaceForm,
    u_closed: Option<bool>,
    v_closed: Option<bool>,
    self_intersect: Option<bool>,
    weights_data: Vec<Vec<Real>>,
}
impl IRepresentationItem for RationalBSplineSurface {
    fn name(&self) -> &Label {
        &self.name
    }
}
impl IGeometricRepresentationItem for RationalBSplineSurface {}
impl ISurface for RationalBSplineSurface {}
impl IBoundedSurface for RationalBSplineSurface {}
impl IBSplineSurface for RationalBSplineSurface {
    fn u_degree(&self) -> i64 {
        self.u_degree
    }
    fn v_degree(&self) -> i64 {
        self.v_degree
    }
    fn control_points_list(&self) -> &Vec<Vec<EntityRef>> {
        &self.control_points_list
    }
    fn surface_form(&self) -> &BSplineSurfaceForm {
        &self.surface_form
    }
    fn u_closed(&self) -> Option<bool> {
        self.u_closed
    }
    fn v_closed(&self) -> Option<bool> {
        self.v_closed
    }
    fn self_intersect(&self) -> Option<bool> {
        self.self_intersect
    }
}
impl IRationalBSplineSurface for RationalBSplineSurface {
    fn weights_data(&self) -> &Vec<Vec<Real>> {
        &self.weights_data
    }
}
impl RationalBSplineSurface {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = RationalBSplineSurface::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => entity.u_degree = parameter.into(),
                2usize => entity.v_degree = parameter.into(),
                3usize => entity.control_points_list = parameter.into(),
                4usize => entity.surface_form = parameter.into(),
                5usize => entity.u_closed = parameter.into(),
                6usize => entity.v_closed = parameter.into(),
                7usize => entity.self_intersect = parameter.into(),
                8usize => entity.weights_data = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IRationalRepresentationItem: IRepresentationItem + ISlashExpression {}
#[derive(Default, Debug)]
pub struct RationalRepresentationItem {
    name: Label,
    operands: Vec<EntityRef>,
}
impl IRepresentationItem for RationalRepresentationItem {
    fn name(&self) -> &Label {
        &self.name
    }
}
impl IGenericExpression for RationalRepresentationItem {}
impl IExpression for RationalRepresentationItem {}
impl INumericExpression for RationalRepresentationItem {}
impl IBinaryNumericExpression for RationalRepresentationItem {
    fn operands(&self) -> &Vec<EntityRef> {
        &self.operands
    }
}
impl IBinaryGenericExpression for RationalRepresentationItem {
    fn operands(&self) -> &Vec<EntityRef> {
        &self.operands
    }
}
impl ISlashExpression for RationalRepresentationItem {}
impl IRationalRepresentationItem for RationalRepresentationItem {}
impl RationalRepresentationItem {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = RationalRepresentationItem::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => entity.operands = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IRealLiteral: ILiteralNumber {
    fn the_value(&self) -> Real;
}
#[derive(Default, Debug)]
pub struct RealLiteral {
    the_value: Real,
}
impl IGenericExpression for RealLiteral {}
impl IExpression for RealLiteral {}
impl INumericExpression for RealLiteral {}
impl ISimpleNumericExpression for RealLiteral {}
impl ISimpleGenericExpression for RealLiteral {}
impl ILiteralNumber for RealLiteral {
    fn the_value(&self) -> Real {
        self.the_value
    }
}
impl IGenericLiteral for RealLiteral {}
impl IRealLiteral for RealLiteral {
    fn the_value(&self) -> Real {
        self.the_value
    }
}
impl RealLiteral {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = RealLiteral::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.the_value = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IRealRepresentationItem: IRepresentationItem + IRealLiteral {}
#[derive(Default, Debug)]
pub struct RealRepresentationItem {
    name: Label,
    the_value: Real,
}
impl IRepresentationItem for RealRepresentationItem {
    fn name(&self) -> &Label {
        &self.name
    }
}
impl IGenericExpression for RealRepresentationItem {}
impl IExpression for RealRepresentationItem {}
impl INumericExpression for RealRepresentationItem {}
impl ISimpleNumericExpression for RealRepresentationItem {}
impl ISimpleGenericExpression for RealRepresentationItem {}
impl ILiteralNumber for RealRepresentationItem {
    fn the_value(&self) -> Real {
        self.the_value
    }
}
impl IGenericLiteral for RealRepresentationItem {}
impl IRealLiteral for RealRepresentationItem {
    fn the_value(&self) -> Real {
        self.the_value
    }
}
impl IRealRepresentationItem for RealRepresentationItem {}
impl RealRepresentationItem {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = RealRepresentationItem::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => entity.the_value = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IRectangularCompositeSurface: IBoundedSurface {
    fn segments(&self) -> &Vec<Vec<EntityRef>>;
}
#[derive(Default, Debug)]
pub struct RectangularCompositeSurface {
    name: Label,
    segments: Vec<Vec<EntityRef>>,
}
impl IRepresentationItem for RectangularCompositeSurface {
    fn name(&self) -> &Label {
        &self.name
    }
}
impl IGeometricRepresentationItem for RectangularCompositeSurface {}
impl ISurface for RectangularCompositeSurface {}
impl IBoundedSurface for RectangularCompositeSurface {}
impl IRectangularCompositeSurface for RectangularCompositeSurface {
    fn segments(&self) -> &Vec<Vec<EntityRef>> {
        &self.segments
    }
}
impl RectangularCompositeSurface {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = RectangularCompositeSurface::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => entity.segments = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IRectangularTrimmedSurface: IBoundedSurface {
    fn basis_surface(&self) -> &EntityRef;
    fn u1(&self) -> &ParameterValue;
    fn u2(&self) -> &ParameterValue;
    fn v1(&self) -> &ParameterValue;
    fn v2(&self) -> &ParameterValue;
    fn usense(&self) -> bool;
    fn vsense(&self) -> bool;
}
#[derive(Default, Debug)]
pub struct RectangularTrimmedSurface {
    name: Label,
    basis_surface: EntityRef,
    u1: ParameterValue,
    u2: ParameterValue,
    v1: ParameterValue,
    v2: ParameterValue,
    usense: bool,
    vsense: bool,
}
impl IRepresentationItem for RectangularTrimmedSurface {
    fn name(&self) -> &Label {
        &self.name
    }
}
impl IGeometricRepresentationItem for RectangularTrimmedSurface {}
impl ISurface for RectangularTrimmedSurface {}
impl IBoundedSurface for RectangularTrimmedSurface {}
impl IRectangularTrimmedSurface for RectangularTrimmedSurface {
    fn basis_surface(&self) -> &EntityRef {
        &self.basis_surface
    }
    fn u1(&self) -> &ParameterValue {
        &self.u1
    }
    fn u2(&self) -> &ParameterValue {
        &self.u2
    }
    fn v1(&self) -> &ParameterValue {
        &self.v1
    }
    fn v2(&self) -> &ParameterValue {
        &self.v2
    }
    fn usense(&self) -> bool {
        self.usense
    }
    fn vsense(&self) -> bool {
        self.vsense
    }
}
impl RectangularTrimmedSurface {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = RectangularTrimmedSurface::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => entity.basis_surface = parameter.into(),
                2usize => entity.u1 = parameter.into(),
                3usize => entity.u2 = parameter.into(),
                4usize => entity.v1 = parameter.into(),
                5usize => entity.v2 = parameter.into(),
                6usize => entity.usense = parameter.into(),
                7usize => entity.vsense = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IReferencedModifiedDatum: IDatumReference {
    fn modifier(&self) -> &LimitCondition;
}
#[derive(Default, Debug)]
pub struct ReferencedModifiedDatum {
    precedence: i64,
    referenced_datum: EntityRef,
    modifier: LimitCondition,
}
impl IDatumReference for ReferencedModifiedDatum {
    fn precedence(&self) -> i64 {
        self.precedence
    }
    fn referenced_datum(&self) -> &EntityRef {
        &self.referenced_datum
    }
}
impl IReferencedModifiedDatum for ReferencedModifiedDatum {
    fn modifier(&self) -> &LimitCondition {
        &self.modifier
    }
}
impl ReferencedModifiedDatum {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = ReferencedModifiedDatum::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.precedence = parameter.into(),
                1usize => entity.referenced_datum = parameter.into(),
                2usize => entity.modifier = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IRelativeEventOccurrence: IEventOccurrence {
    fn base_event(&self) -> &EntityRef;
    fn offset(&self) -> &EntityRef;
}
#[derive(Default, Debug)]
pub struct RelativeEventOccurrence {
    id: Identifier,
    name: Label,
    description: Option<Text>,
    base_event: EntityRef,
    offset: EntityRef,
}
impl IEventOccurrence for RelativeEventOccurrence {
    fn id(&self) -> &Identifier {
        &self.id
    }
    fn name(&self) -> &Label {
        &self.name
    }
    fn description(&self) -> &Option<Text> {
        &self.description
    }
}
impl IRelativeEventOccurrence for RelativeEventOccurrence {
    fn base_event(&self) -> &EntityRef {
        &self.base_event
    }
    fn offset(&self) -> &EntityRef {
        &self.offset
    }
}
impl RelativeEventOccurrence {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = RelativeEventOccurrence::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.id = parameter.into(),
                1usize => entity.name = parameter.into(),
                2usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => entity.base_event = parameter.into(),
                4usize => entity.offset = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IRepItemGroup: IGroup + IRepresentationItem {}
#[derive(Default, Debug)]
pub struct RepItemGroup {
    name: Label,
    description: Option<Text>,
}
impl IGroup for RepItemGroup {
    fn name(&self) -> &Label {
        &self.name
    }
    fn description(&self) -> &Option<Text> {
        &self.description
    }
}
impl IRepresentationItem for RepItemGroup {
    fn name(&self) -> &Label {
        &self.name
    }
}
impl IRepItemGroup for RepItemGroup {}
impl RepItemGroup {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = RepItemGroup::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
}
pub trait IReparametrisedCompositeCurveSegment: ICompositeCurveSegment {
    fn param_length(&self) -> &ParameterValue;
}
#[derive(Default, Debug)]
pub struct ReparametrisedCompositeCurveSegment {
    transition: TransitionCode,
    same_sense: bool,
    parent_curve: EntityRef,
    param_length: ParameterValue,
}
impl IFoundedItem for ReparametrisedCompositeCurveSegment {}
impl ICompositeCurveSegment for ReparametrisedCompositeCurveSegment {
    fn transition(&self) -> &TransitionCode {
        &self.transition
    }
    fn same_sense(&self) -> bool {
        self.same_sense
    }
    fn parent_curve(&self) -> &EntityRef {
        &self.parent_curve
    }
}
impl IReparametrisedCompositeCurveSegment for ReparametrisedCompositeCurveSegment {
    fn param_length(&self) -> &ParameterValue {
        &self.param_length
    }
}
impl ReparametrisedCompositeCurveSegment {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = ReparametrisedCompositeCurveSegment::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.transition = parameter.into(),
                1usize => entity.same_sense = parameter.into(),
                2usize => entity.parent_curve = parameter.into(),
                3usize => entity.param_length = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IRepresentation {
    fn name(&self) -> &Label;
    fn items(&self) -> &HashSet<EntityRef>;
    fn context_of_items(&self) -> &EntityRef;
}
#[derive(Default, Debug)]
pub struct Representation {
    name: Label,
    items: HashSet<EntityRef>,
    context_of_items: EntityRef,
}
impl IRepresentation for Representation {
    fn name(&self) -> &Label {
        &self.name
    }
    fn items(&self) -> &HashSet<EntityRef> {
        &self.items
    }
    fn context_of_items(&self) -> &EntityRef {
        &self.context_of_items
    }
}
impl Representation {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = Representation::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => entity.items = parameter.into(),
                2usize => entity.context_of_items = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IRepresentationContext {
    fn context_identifier(&self) -> &Identifier;
    fn context_type(&self) -> &Text;
}
#[derive(Default, Debug)]
pub struct RepresentationContext {
    context_identifier: Identifier,
    context_type: Text,
}
impl IRepresentationContext for RepresentationContext {
    fn context_identifier(&self) -> &Identifier {
        &self.context_identifier
    }
    fn context_type(&self) -> &Text {
        &self.context_type
    }
}
impl RepresentationContext {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = RepresentationContext::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.context_identifier = parameter.into(),
                1usize => entity.context_type = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IRepresentationItem {
    fn name(&self) -> &Label;
}
#[derive(Default, Debug)]
pub struct RepresentationItem {
    name: Label,
}
impl IRepresentationItem for RepresentationItem {
    fn name(&self) -> &Label {
        &self.name
    }
}
impl RepresentationItem {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = RepresentationItem::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IRepresentationItemRelationship {
    fn name(&self) -> &Label;
    fn description(&self) -> &Option<Text>;
    fn relating_representation_item(&self) -> &EntityRef;
    fn related_representation_item(&self) -> &EntityRef;
}
#[derive(Default, Debug)]
pub struct RepresentationItemRelationship {
    name: Label,
    description: Option<Text>,
    relating_representation_item: EntityRef,
    related_representation_item: EntityRef,
}
impl IRepresentationItemRelationship for RepresentationItemRelationship {
    fn name(&self) -> &Label {
        &self.name
    }
    fn description(&self) -> &Option<Text> {
        &self.description
    }
    fn relating_representation_item(&self) -> &EntityRef {
        &self.relating_representation_item
    }
    fn related_representation_item(&self) -> &EntityRef {
        &self.related_representation_item
    }
}
impl RepresentationItemRelationship {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = RepresentationItemRelationship::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => entity.relating_representation_item = parameter.into(),
                3usize => entity.related_representation_item = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IRepresentationMap {
    fn mapping_origin(&self) -> &EntityRef;
    fn mapped_representation(&self) -> &EntityRef;
}
#[derive(Default, Debug)]
pub struct RepresentationMap {
    mapping_origin: EntityRef,
    mapped_representation: EntityRef,
}
impl IRepresentationMap for RepresentationMap {
    fn mapping_origin(&self) -> &EntityRef {
        &self.mapping_origin
    }
    fn mapped_representation(&self) -> &EntityRef {
        &self.mapped_representation
    }
}
impl RepresentationMap {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = RepresentationMap::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.mapping_origin = parameter.into(),
                1usize => entity.mapped_representation = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IRepresentationRelationship {
    fn name(&self) -> &Label;
    fn description(&self) -> &Option<Text>;
    fn rep_1(&self) -> &EntityRef;
    fn rep_2(&self) -> &EntityRef;
}
#[derive(Default, Debug)]
pub struct RepresentationRelationship {
    name: Label,
    description: Option<Text>,
    rep_1: EntityRef,
    rep_2: EntityRef,
}
impl IRepresentationRelationship for RepresentationRelationship {
    fn name(&self) -> &Label {
        &self.name
    }
    fn description(&self) -> &Option<Text> {
        &self.description
    }
    fn rep_1(&self) -> &EntityRef {
        &self.rep_1
    }
    fn rep_2(&self) -> &EntityRef {
        &self.rep_2
    }
}
impl RepresentationRelationship {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = RepresentationRelationship::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => entity.rep_1 = parameter.into(),
                3usize => entity.rep_2 = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IRepresentationRelationshipWithTransformation: IRepresentationRelationship {
    fn transformation_operator(&self) -> &EntityRef;
}
#[derive(Default, Debug)]
pub struct RepresentationRelationshipWithTransformation {
    name: Label,
    description: Option<Text>,
    rep_1: EntityRef,
    rep_2: EntityRef,
    transformation_operator: EntityRef,
}
impl IRepresentationRelationship for RepresentationRelationshipWithTransformation {
    fn name(&self) -> &Label {
        &self.name
    }
    fn description(&self) -> &Option<Text> {
        &self.description
    }
    fn rep_1(&self) -> &EntityRef {
        &self.rep_1
    }
    fn rep_2(&self) -> &EntityRef {
        &self.rep_2
    }
}
impl IRepresentationRelationshipWithTransformation for RepresentationRelationshipWithTransformation {
    fn transformation_operator(&self) -> &EntityRef {
        &self.transformation_operator
    }
}
impl RepresentationRelationshipWithTransformation {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = RepresentationRelationshipWithTransformation::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => entity.rep_1 = parameter.into(),
                3usize => entity.rep_2 = parameter.into(),
                4usize => entity.transformation_operator = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IRequirementAssignedObject: IGroupAssignment {
    fn items(&self) -> &HashSet<EntityRef>;
    fn assigned_group(&self) -> &EntityRef;
}
#[derive(Default, Debug)]
pub struct RequirementAssignedObject {
    items: HashSet<EntityRef>,
    assigned_group: EntityRef,
}
impl IGroupAssignment for RequirementAssignedObject {
    fn assigned_group(&self) -> &EntityRef {
        &self.assigned_group
    }
}
impl IRequirementAssignedObject for RequirementAssignedObject {
    fn items(&self) -> &HashSet<EntityRef> {
        &self.items
    }
    fn assigned_group(&self) -> &EntityRef {
        &self.assigned_group
    }
}
impl RequirementAssignedObject {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = RequirementAssignedObject::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.items = parameter.into(),
                1usize => entity.assigned_group = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IRequirementAssignment: ICharacterizedObject + IGroup {}
#[derive(Default, Debug)]
pub struct RequirementAssignment {
    name: Label,
    description: Option<Text>,
}
impl ICharacterizedObject for RequirementAssignment {
    fn name(&self) -> &Label {
        &self.name
    }
    fn description(&self) -> &Option<Text> {
        &self.description
    }
}
impl IGroup for RequirementAssignment {
    fn name(&self) -> &Label {
        &self.name
    }
    fn description(&self) -> &Option<Text> {
        &self.description
    }
}
impl IRequirementAssignment for RequirementAssignment {}
impl RequirementAssignment {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = RequirementAssignment::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
}
pub trait IRequirementSource: IGroup {}
#[derive(Default, Debug)]
pub struct RequirementSource {
    name: Label,
    description: Option<Text>,
}
impl IGroup for RequirementSource {
    fn name(&self) -> &Label {
        &self.name
    }
    fn description(&self) -> &Option<Text> {
        &self.description
    }
}
impl IRequirementSource for RequirementSource {}
impl RequirementSource {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = RequirementSource::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
}
pub trait IResistanceMeasureWithUnit: IMeasureWithUnit {}
#[derive(Default, Debug)]
pub struct ResistanceMeasureWithUnit {
    value_component: MeasureValue,
    unit_component: EntityRef,
}
impl IMeasureWithUnit for ResistanceMeasureWithUnit {
    fn value_component(&self) -> &MeasureValue {
        &self.value_component
    }
    fn unit_component(&self) -> &EntityRef {
        &self.unit_component
    }
}
impl IResistanceMeasureWithUnit for ResistanceMeasureWithUnit {}
impl ResistanceMeasureWithUnit {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = ResistanceMeasureWithUnit::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.value_component = parameter.into(),
                1usize => entity.unit_component = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IResistanceUnit: IDerivedUnit {}
#[derive(Default, Debug)]
pub struct ResistanceUnit {
    elements: HashSet<EntityRef>,
}
impl IDerivedUnit for ResistanceUnit {
    fn elements(&self) -> &HashSet<EntityRef> {
        &self.elements
    }
}
impl IResistanceUnit for ResistanceUnit {}
impl ResistanceUnit {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = ResistanceUnit::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.elements = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IRevolvedAreaSolid: ISweptAreaSolid {
    fn axis(&self) -> &EntityRef;
    fn angle(&self) -> &PlaneAngleMeasure;
}
#[derive(Default, Debug)]
pub struct RevolvedAreaSolid {
    name: Label,
    swept_area: EntityRef,
    axis: EntityRef,
    angle: PlaneAngleMeasure,
}
impl IRepresentationItem for RevolvedAreaSolid {
    fn name(&self) -> &Label {
        &self.name
    }
}
impl IGeometricRepresentationItem for RevolvedAreaSolid {}
impl ISolidModel for RevolvedAreaSolid {}
impl ISweptAreaSolid for RevolvedAreaSolid {
    fn swept_area(&self) -> &EntityRef {
        &self.swept_area
    }
}
impl IRevolvedAreaSolid for RevolvedAreaSolid {
    fn axis(&self) -> &EntityRef {
        &self.axis
    }
    fn angle(&self) -> &PlaneAngleMeasure {
        &self.angle
    }
}
impl RevolvedAreaSolid {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = RevolvedAreaSolid::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => entity.swept_area = parameter.into(),
                2usize => entity.axis = parameter.into(),
                3usize => entity.angle = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IRevolvedFaceSolid: ISweptFaceSolid {
    fn axis(&self) -> &EntityRef;
    fn angle(&self) -> &PlaneAngleMeasure;
}
#[derive(Default, Debug)]
pub struct RevolvedFaceSolid {
    name: Label,
    swept_face: EntityRef,
    axis: EntityRef,
    angle: PlaneAngleMeasure,
}
impl IRepresentationItem for RevolvedFaceSolid {
    fn name(&self) -> &Label {
        &self.name
    }
}
impl IGeometricRepresentationItem for RevolvedFaceSolid {}
impl ISolidModel for RevolvedFaceSolid {}
impl ISweptFaceSolid for RevolvedFaceSolid {
    fn swept_face(&self) -> &EntityRef {
        &self.swept_face
    }
}
impl IRevolvedFaceSolid for RevolvedFaceSolid {
    fn axis(&self) -> &EntityRef {
        &self.axis
    }
    fn angle(&self) -> &PlaneAngleMeasure {
        &self.angle
    }
}
impl RevolvedFaceSolid {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = RevolvedFaceSolid::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => entity.swept_face = parameter.into(),
                2usize => entity.axis = parameter.into(),
                3usize => entity.angle = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IRevolvedFaceSolidWithTrimConditions: IRevolvedFaceSolid {
    fn first_trim_condition(&self) -> &TrimConditionSelect;
    fn second_trim_condition(&self) -> &TrimConditionSelect;
}
#[derive(Default, Debug)]
pub struct RevolvedFaceSolidWithTrimConditions {
    name: Label,
    swept_face: EntityRef,
    axis: EntityRef,
    angle: PlaneAngleMeasure,
    first_trim_condition: TrimConditionSelect,
    second_trim_condition: TrimConditionSelect,
}
impl IRepresentationItem for RevolvedFaceSolidWithTrimConditions {
    fn name(&self) -> &Label {
        &self.name
    }
}
impl IGeometricRepresentationItem for RevolvedFaceSolidWithTrimConditions {}
impl ISolidModel for RevolvedFaceSolidWithTrimConditions {}
impl ISweptFaceSolid for RevolvedFaceSolidWithTrimConditions {
    fn swept_face(&self) -> &EntityRef {
        &self.swept_face
    }
}
impl IRevolvedFaceSolid for RevolvedFaceSolidWithTrimConditions {
    fn axis(&self) -> &EntityRef {
        &self.axis
    }
    fn angle(&self) -> &PlaneAngleMeasure {
        &self.angle
    }
}
impl IRevolvedFaceSolidWithTrimConditions for RevolvedFaceSolidWithTrimConditions {
    fn first_trim_condition(&self) -> &TrimConditionSelect {
        &self.first_trim_condition
    }
    fn second_trim_condition(&self) -> &TrimConditionSelect {
        &self.second_trim_condition
    }
}
impl RevolvedFaceSolidWithTrimConditions {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = RevolvedFaceSolidWithTrimConditions::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => entity.swept_face = parameter.into(),
                2usize => entity.axis = parameter.into(),
                3usize => entity.angle = parameter.into(),
                4usize => entity.first_trim_condition = parameter.into(),
                5usize => entity.second_trim_condition = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IRightAngularWedge: IGeometricRepresentationItem {
    fn position(&self) -> &EntityRef;
    fn x(&self) -> &PositiveLengthMeasure;
    fn y(&self) -> &PositiveLengthMeasure;
    fn z(&self) -> &PositiveLengthMeasure;
    fn ltx(&self) -> &LengthMeasure;
}
#[derive(Default, Debug)]
pub struct RightAngularWedge {
    name: Label,
    position: EntityRef,
    x: PositiveLengthMeasure,
    y: PositiveLengthMeasure,
    z: PositiveLengthMeasure,
    ltx: LengthMeasure,
}
impl IRepresentationItem for RightAngularWedge {
    fn name(&self) -> &Label {
        &self.name
    }
}
impl IGeometricRepresentationItem for RightAngularWedge {}
impl IRightAngularWedge for RightAngularWedge {
    fn position(&self) -> &EntityRef {
        &self.position
    }
    fn x(&self) -> &PositiveLengthMeasure {
        &self.x
    }
    fn y(&self) -> &PositiveLengthMeasure {
        &self.y
    }
    fn z(&self) -> &PositiveLengthMeasure {
        &self.z
    }
    fn ltx(&self) -> &LengthMeasure {
        &self.ltx
    }
}
impl RightAngularWedge {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = RightAngularWedge::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => entity.position = parameter.into(),
                2usize => entity.x = parameter.into(),
                3usize => entity.y = parameter.into(),
                4usize => entity.z = parameter.into(),
                5usize => entity.ltx = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IRightCircularCone: IGeometricRepresentationItem {
    fn position(&self) -> &EntityRef;
    fn height(&self) -> &PositiveLengthMeasure;
    fn radius(&self) -> &LengthMeasure;
    fn semi_angle(&self) -> &PlaneAngleMeasure;
}
#[derive(Default, Debug)]
pub struct RightCircularCone {
    name: Label,
    position: EntityRef,
    height: PositiveLengthMeasure,
    radius: LengthMeasure,
    semi_angle: PlaneAngleMeasure,
}
impl IRepresentationItem for RightCircularCone {
    fn name(&self) -> &Label {
        &self.name
    }
}
impl IGeometricRepresentationItem for RightCircularCone {}
impl IRightCircularCone for RightCircularCone {
    fn position(&self) -> &EntityRef {
        &self.position
    }
    fn height(&self) -> &PositiveLengthMeasure {
        &self.height
    }
    fn radius(&self) -> &LengthMeasure {
        &self.radius
    }
    fn semi_angle(&self) -> &PlaneAngleMeasure {
        &self.semi_angle
    }
}
impl RightCircularCone {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = RightCircularCone::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => entity.position = parameter.into(),
                2usize => entity.height = parameter.into(),
                3usize => entity.radius = parameter.into(),
                4usize => entity.semi_angle = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IRightCircularCylinder: IGeometricRepresentationItem {
    fn position(&self) -> &EntityRef;
    fn height(&self) -> &PositiveLengthMeasure;
    fn radius(&self) -> &PositiveLengthMeasure;
}
#[derive(Default, Debug)]
pub struct RightCircularCylinder {
    name: Label,
    position: EntityRef,
    height: PositiveLengthMeasure,
    radius: PositiveLengthMeasure,
}
impl IRepresentationItem for RightCircularCylinder {
    fn name(&self) -> &Label {
        &self.name
    }
}
impl IGeometricRepresentationItem for RightCircularCylinder {}
impl IRightCircularCylinder for RightCircularCylinder {
    fn position(&self) -> &EntityRef {
        &self.position
    }
    fn height(&self) -> &PositiveLengthMeasure {
        &self.height
    }
    fn radius(&self) -> &PositiveLengthMeasure {
        &self.radius
    }
}
impl RightCircularCylinder {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = RightCircularCylinder::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => entity.position = parameter.into(),
                2usize => entity.height = parameter.into(),
                3usize => entity.radius = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IRightToUsageAssociation: IActionMethodRelationship {
    fn related_method(&self) -> &EntityRef;
    fn relating_method(&self) -> &EntityRef;
}
#[derive(Default, Debug)]
pub struct RightToUsageAssociation {
    name: Label,
    description: Option<Text>,
    related_method: EntityRef,
    relating_method: EntityRef,
}
impl IActionMethodRelationship for RightToUsageAssociation {
    fn name(&self) -> &Label {
        &self.name
    }
    fn description(&self) -> &Option<Text> {
        &self.description
    }
    fn relating_method(&self) -> &EntityRef {
        &self.relating_method
    }
    fn related_method(&self) -> &EntityRef {
        &self.related_method
    }
}
impl IRightToUsageAssociation for RightToUsageAssociation {
    fn related_method(&self) -> &EntityRef {
        &self.related_method
    }
    fn relating_method(&self) -> &EntityRef {
        &self.relating_method
    }
}
impl RightToUsageAssociation {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = RightToUsageAssociation::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => entity.related_method = parameter.into(),
                3usize => entity.relating_method = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IRoleAssociation {
    fn role(&self) -> &EntityRef;
    fn item_with_role(&self) -> &EntityRef;
}
#[derive(Default, Debug)]
pub struct RoleAssociation {
    role: EntityRef,
    item_with_role: EntityRef,
}
impl IRoleAssociation for RoleAssociation {
    fn role(&self) -> &EntityRef {
        &self.role
    }
    fn item_with_role(&self) -> &EntityRef {
        &self.item_with_role
    }
}
impl RoleAssociation {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = RoleAssociation::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.role = parameter.into(),
                1usize => entity.item_with_role = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IRoundnessTolerance: IGeometricTolerance {}
#[derive(Default, Debug)]
pub struct RoundnessTolerance {
    name: Label,
    description: Text,
    magnitude: EntityRef,
    toleranced_shape_aspect: EntityRef,
}
impl IGeometricTolerance for RoundnessTolerance {
    fn name(&self) -> &Label {
        &self.name
    }
    fn description(&self) -> &Text {
        &self.description
    }
    fn magnitude(&self) -> &EntityRef {
        &self.magnitude
    }
    fn toleranced_shape_aspect(&self) -> &EntityRef {
        &self.toleranced_shape_aspect
    }
}
impl IRoundnessTolerance for RoundnessTolerance {}
impl RoundnessTolerance {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = RoundnessTolerance::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => entity.description = parameter.into(),
                2usize => entity.magnitude = parameter.into(),
                3usize => entity.toleranced_shape_aspect = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IRowRepresentationItem: ICompoundRepresentationItem {
    fn item_element(&self) -> &ListRepresentationItem;
}
#[derive(Default, Debug)]
pub struct RowRepresentationItem {
    name: Label,
    item_element: ListRepresentationItem,
}
impl IRepresentationItem for RowRepresentationItem {
    fn name(&self) -> &Label {
        &self.name
    }
}
impl ICompoundRepresentationItem for RowRepresentationItem {
    fn item_element(&self) -> &CompoundItemDefinition {
        unimplemented!()
    }
}
impl IRowRepresentationItem for RowRepresentationItem {
    fn item_element(&self) -> &ListRepresentationItem {
        &self.item_element
    }
}
impl RowRepresentationItem {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = RowRepresentationItem::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => entity.item_element = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IRowValue: ICompoundRepresentationItem {}
#[derive(Default, Debug)]
pub struct RowValue {
    name: Label,
    item_element: CompoundItemDefinition,
}
impl IRepresentationItem for RowValue {
    fn name(&self) -> &Label {
        &self.name
    }
}
impl ICompoundRepresentationItem for RowValue {
    fn item_element(&self) -> &CompoundItemDefinition {
        &self.item_element
    }
}
impl IRowValue for RowValue {}
impl RowValue {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = RowValue::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => entity.item_element = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IRowVariable: IAbstractVariable {}
#[derive(Default, Debug)]
pub struct RowVariable {
    name: Label,
    description: Option<Text>,
    definition: EntityRef,
    used_representation: EntityRef,
    items: HashSet<EntityRef>,
    context_of_items: EntityRef,
}
impl IPropertyDefinition for RowVariable {
    fn name(&self) -> &Label {
        &self.name
    }
    fn description(&self) -> &Option<Text> {
        &self.description
    }
    fn definition(&self) -> &EntityRef {
        &self.definition
    }
}
impl IPropertyDefinitionRepresentation for RowVariable {
    fn definition(&self) -> &EntityRef {
        &self.definition
    }
    fn used_representation(&self) -> &EntityRef {
        &self.used_representation
    }
}
impl IRepresentation for RowVariable {
    fn name(&self) -> &Label {
        &self.name
    }
    fn items(&self) -> &HashSet<EntityRef> {
        &self.items
    }
    fn context_of_items(&self) -> &EntityRef {
        &self.context_of_items
    }
}
impl IRepresentationItem for RowVariable {
    fn name(&self) -> &Label {
        &self.name
    }
}
impl IAbstractVariable for RowVariable {}
impl IRowVariable for RowVariable {}
impl RowVariable {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = RowVariable::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => entity.definition = parameter.into(),
                3usize => entity.used_representation = parameter.into(),
                4usize => entity.items = parameter.into(),
                5usize => entity.context_of_items = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IRuleAction: IAction {}
#[derive(Default, Debug)]
pub struct RuleAction {
    name: Label,
    description: Option<Text>,
    chosen_method: EntityRef,
}
impl IAction for RuleAction {
    fn name(&self) -> &Label {
        &self.name
    }
    fn description(&self) -> &Option<Text> {
        &self.description
    }
    fn chosen_method(&self) -> &EntityRef {
        &self.chosen_method
    }
}
impl IRuleAction for RuleAction {}
impl RuleAction {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = RuleAction::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => entity.chosen_method = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IRuleCondition: IAtomicFormula {}
#[derive(Default, Debug)]
pub struct RuleCondition {
    name: Label,
    item_element: CompoundItemDefinition,
}
impl IRepresentationItem for RuleCondition {
    fn name(&self) -> &Label {
        &self.name
    }
}
impl ICompoundRepresentationItem for RuleCondition {
    fn item_element(&self) -> &CompoundItemDefinition {
        &self.item_element
    }
}
impl IAtomicFormula for RuleCondition {}
impl IRuleCondition for RuleCondition {}
impl RuleCondition {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = RuleCondition::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => entity.item_element = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IRuleDefinition: IRuleSoftwareDefinition {}
#[derive(Default, Debug)]
pub struct RuleDefinition {
    id: Identifier,
    description: Option<Text>,
    formation: EntityRef,
    frame_of_reference: EntityRef,
}
impl IProductDefinition for RuleDefinition {
    fn id(&self) -> &Identifier {
        &self.id
    }
    fn description(&self) -> &Option<Text> {
        &self.description
    }
    fn formation(&self) -> &EntityRef {
        &self.formation
    }
    fn frame_of_reference(&self) -> &EntityRef {
        &self.frame_of_reference
    }
}
impl IRuleSoftwareDefinition for RuleDefinition {}
impl IRuleDefinition for RuleDefinition {}
impl RuleDefinition {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = RuleDefinition::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.id = parameter.into(),
                1usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => entity.formation = parameter.into(),
                3usize => entity.frame_of_reference = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IRuleSet: IRuleSoftwareDefinition {}
#[derive(Default, Debug)]
pub struct RuleSet {
    id: Identifier,
    description: Option<Text>,
    formation: EntityRef,
    frame_of_reference: EntityRef,
}
impl IProductDefinition for RuleSet {
    fn id(&self) -> &Identifier {
        &self.id
    }
    fn description(&self) -> &Option<Text> {
        &self.description
    }
    fn formation(&self) -> &EntityRef {
        &self.formation
    }
    fn frame_of_reference(&self) -> &EntityRef {
        &self.frame_of_reference
    }
}
impl IRuleSoftwareDefinition for RuleSet {}
impl IRuleSet for RuleSet {}
impl RuleSet {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = RuleSet::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.id = parameter.into(),
                1usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => entity.formation = parameter.into(),
                3usize => entity.frame_of_reference = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IRuleSetGroup: IRuleSoftwareDefinition {}
#[derive(Default, Debug)]
pub struct RuleSetGroup {
    id: Identifier,
    description: Option<Text>,
    formation: EntityRef,
    frame_of_reference: EntityRef,
}
impl IProductDefinition for RuleSetGroup {
    fn id(&self) -> &Identifier {
        &self.id
    }
    fn description(&self) -> &Option<Text> {
        &self.description
    }
    fn formation(&self) -> &EntityRef {
        &self.formation
    }
    fn frame_of_reference(&self) -> &EntityRef {
        &self.frame_of_reference
    }
}
impl IRuleSoftwareDefinition for RuleSetGroup {}
impl IRuleSetGroup for RuleSetGroup {}
impl RuleSetGroup {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = RuleSetGroup::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.id = parameter.into(),
                1usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => entity.formation = parameter.into(),
                3usize => entity.frame_of_reference = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IRuleSoftwareDefinition: IProductDefinition {}
#[derive(Default, Debug)]
pub struct RuleSoftwareDefinition {
    id: Identifier,
    description: Option<Text>,
    formation: EntityRef,
    frame_of_reference: EntityRef,
}
impl IProductDefinition for RuleSoftwareDefinition {
    fn id(&self) -> &Identifier {
        &self.id
    }
    fn description(&self) -> &Option<Text> {
        &self.description
    }
    fn formation(&self) -> &EntityRef {
        &self.formation
    }
    fn frame_of_reference(&self) -> &EntityRef {
        &self.frame_of_reference
    }
}
impl IRuleSoftwareDefinition for RuleSoftwareDefinition {}
impl RuleSoftwareDefinition {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = RuleSoftwareDefinition::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.id = parameter.into(),
                1usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => entity.formation = parameter.into(),
                3usize => entity.frame_of_reference = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IRuleSupersededAssignment: IActionAssignment {
    fn items(&self) -> &HashSet<EntityRef>;
}
#[derive(Default, Debug)]
pub struct RuleSupersededAssignment {
    assigned_action: EntityRef,
    items: HashSet<EntityRef>,
}
impl IActionAssignment for RuleSupersededAssignment {
    fn assigned_action(&self) -> &EntityRef {
        &self.assigned_action
    }
}
impl IRuleSupersededAssignment for RuleSupersededAssignment {
    fn items(&self) -> &HashSet<EntityRef> {
        &self.items
    }
}
impl RuleSupersededAssignment {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = RuleSupersededAssignment::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.assigned_action = parameter.into(),
                1usize => entity.items = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IRuleSupersedence: IRuleAction {}
#[derive(Default, Debug)]
pub struct RuleSupersedence {
    name: Label,
    description: Option<Text>,
    chosen_method: EntityRef,
}
impl IAction for RuleSupersedence {
    fn name(&self) -> &Label {
        &self.name
    }
    fn description(&self) -> &Option<Text> {
        &self.description
    }
    fn chosen_method(&self) -> &EntityRef {
        &self.chosen_method
    }
}
impl IRuleAction for RuleSupersedence {}
impl IRuleSupersedence for RuleSupersedence {}
impl RuleSupersedence {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = RuleSupersedence::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => entity.chosen_method = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IRuledSurfaceSweptAreaSolid: ISurfaceCurveSweptAreaSolid {}
#[derive(Default, Debug)]
pub struct RuledSurfaceSweptAreaSolid {
    name: Label,
    swept_area: EntityRef,
    directrix: EntityRef,
    start_param: Real,
    end_param: Real,
    reference_surface: EntityRef,
}
impl IRepresentationItem for RuledSurfaceSweptAreaSolid {
    fn name(&self) -> &Label {
        &self.name
    }
}
impl IGeometricRepresentationItem for RuledSurfaceSweptAreaSolid {}
impl ISolidModel for RuledSurfaceSweptAreaSolid {}
impl ISweptAreaSolid for RuledSurfaceSweptAreaSolid {
    fn swept_area(&self) -> &EntityRef {
        &self.swept_area
    }
}
impl ISurfaceCurveSweptAreaSolid for RuledSurfaceSweptAreaSolid {
    fn directrix(&self) -> &EntityRef {
        &self.directrix
    }
    fn start_param(&self) -> Real {
        self.start_param
    }
    fn end_param(&self) -> Real {
        self.end_param
    }
    fn reference_surface(&self) -> &EntityRef {
        &self.reference_surface
    }
}
impl IRuledSurfaceSweptAreaSolid for RuledSurfaceSweptAreaSolid {}
impl RuledSurfaceSweptAreaSolid {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = RuledSurfaceSweptAreaSolid::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => entity.swept_area = parameter.into(),
                2usize => entity.directrix = parameter.into(),
                3usize => entity.start_param = parameter.into(),
                4usize => entity.end_param = parameter.into(),
                5usize => entity.reference_surface = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IRunoutZoneDefinition: IToleranceZoneDefinition {
    fn orientation(&self) -> &EntityRef;
}
#[derive(Default, Debug)]
pub struct RunoutZoneDefinition {
    zone: EntityRef,
    boundaries: HashSet<EntityRef>,
    orientation: EntityRef,
}
impl IToleranceZoneDefinition for RunoutZoneDefinition {
    fn zone(&self) -> &EntityRef {
        &self.zone
    }
    fn boundaries(&self) -> &HashSet<EntityRef> {
        &self.boundaries
    }
}
impl IRunoutZoneDefinition for RunoutZoneDefinition {
    fn orientation(&self) -> &EntityRef {
        &self.orientation
    }
}
impl RunoutZoneDefinition {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = RunoutZoneDefinition::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.zone = parameter.into(),
                1usize => entity.boundaries = parameter.into(),
                2usize => entity.orientation = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IRunoutZoneOrientation {
    fn angle(&self) -> &EntityRef;
}
#[derive(Default, Debug)]
pub struct RunoutZoneOrientation {
    angle: EntityRef,
}
impl IRunoutZoneOrientation for RunoutZoneOrientation {
    fn angle(&self) -> &EntityRef {
        &self.angle
    }
}
impl RunoutZoneOrientation {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = RunoutZoneOrientation::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.angle = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IRunoutZoneOrientationReferenceDirection: IRunoutZoneOrientation {
    fn orientation_defining_relationship(&self) -> &EntityRef;
}
#[derive(Default, Debug)]
pub struct RunoutZoneOrientationReferenceDirection {
    angle: EntityRef,
    orientation_defining_relationship: EntityRef,
}
impl IRunoutZoneOrientation for RunoutZoneOrientationReferenceDirection {
    fn angle(&self) -> &EntityRef {
        &self.angle
    }
}
impl IRunoutZoneOrientationReferenceDirection for RunoutZoneOrientationReferenceDirection {
    fn orientation_defining_relationship(&self) -> &EntityRef {
        &self.orientation_defining_relationship
    }
}
impl RunoutZoneOrientationReferenceDirection {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = RunoutZoneOrientationReferenceDirection::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.angle = parameter.into(),
                1usize => entity.orientation_defining_relationship = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IScalarVariable: IAbstractVariable {}
#[derive(Default, Debug)]
pub struct ScalarVariable {
    name: Label,
    description: Option<Text>,
    definition: EntityRef,
    used_representation: EntityRef,
    items: HashSet<EntityRef>,
    context_of_items: EntityRef,
}
impl IPropertyDefinition for ScalarVariable {
    fn name(&self) -> &Label {
        &self.name
    }
    fn description(&self) -> &Option<Text> {
        &self.description
    }
    fn definition(&self) -> &EntityRef {
        &self.definition
    }
}
impl IPropertyDefinitionRepresentation for ScalarVariable {
    fn definition(&self) -> &EntityRef {
        &self.definition
    }
    fn used_representation(&self) -> &EntityRef {
        &self.used_representation
    }
}
impl IRepresentation for ScalarVariable {
    fn name(&self) -> &Label {
        &self.name
    }
    fn items(&self) -> &HashSet<EntityRef> {
        &self.items
    }
    fn context_of_items(&self) -> &EntityRef {
        &self.context_of_items
    }
}
impl IRepresentationItem for ScalarVariable {
    fn name(&self) -> &Label {
        &self.name
    }
}
impl IAbstractVariable for ScalarVariable {}
impl IScalarVariable for ScalarVariable {}
impl ScalarVariable {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = ScalarVariable::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => entity.definition = parameter.into(),
                3usize => entity.used_representation = parameter.into(),
                4usize => entity.items = parameter.into(),
                5usize => entity.context_of_items = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IScatteringParameter: IPolarComplexNumberLiteral {}
#[derive(Default, Debug)]
pub struct ScatteringParameter {
    radius: Real,
    angle: Real,
}
impl IGenericExpression for ScatteringParameter {}
impl ISimpleGenericExpression for ScatteringParameter {}
impl IGenericLiteral for ScatteringParameter {}
impl IPolarComplexNumberLiteral for ScatteringParameter {
    fn radius(&self) -> Real {
        self.radius
    }
    fn angle(&self) -> Real {
        self.angle
    }
}
impl IScatteringParameter for ScatteringParameter {}
impl ScatteringParameter {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = ScatteringParameter::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.radius = parameter.into(),
                1usize => entity.angle = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait ISculpturedSolid: IModifiedSolid {
    fn sculpturing_element(&self) -> &EntityRef;
    fn positive_side(&self) -> bool;
}
#[derive(Default, Debug)]
pub struct SculpturedSolid {
    name: Label,
    rationale: Text,
    base_solid: EntityRef,
    sculpturing_element: EntityRef,
    positive_side: bool,
}
impl IRepresentationItem for SculpturedSolid {
    fn name(&self) -> &Label {
        &self.name
    }
}
impl IGeometricRepresentationItem for SculpturedSolid {}
impl ISolidModel for SculpturedSolid {}
impl IModifiedSolid for SculpturedSolid {
    fn rationale(&self) -> &Text {
        &self.rationale
    }
    fn base_solid(&self) -> &EntityRef {
        &self.base_solid
    }
}
impl ISculpturedSolid for SculpturedSolid {
    fn sculpturing_element(&self) -> &EntityRef {
        &self.sculpturing_element
    }
    fn positive_side(&self) -> bool {
        self.positive_side
    }
}
impl SculpturedSolid {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = SculpturedSolid::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => entity.rationale = parameter.into(),
                2usize => entity.base_solid = parameter.into(),
                3usize => entity.sculpturing_element = parameter.into(),
                4usize => entity.positive_side = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait ISeamCurve: ISurfaceCurve {}
#[derive(Default, Debug)]
pub struct SeamCurve {
    name: Label,
    curve_3d: EntityRef,
    associated_geometry: Vec<EntityRef>,
    master_representation: PreferredSurfaceCurveRepresentation,
}
impl IRepresentationItem for SeamCurve {
    fn name(&self) -> &Label {
        &self.name
    }
}
impl IGeometricRepresentationItem for SeamCurve {}
impl ICurve for SeamCurve {}
impl ISurfaceCurve for SeamCurve {
    fn curve_3d(&self) -> &EntityRef {
        &self.curve_3d
    }
    fn associated_geometry(&self) -> &Vec<EntityRef> {
        &self.associated_geometry
    }
    fn master_representation(&self) -> &PreferredSurfaceCurveRepresentation {
        &self.master_representation
    }
}
impl ISeamCurve for SeamCurve {}
impl SeamCurve {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = SeamCurve::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => entity.curve_3d = parameter.into(),
                2usize => entity.associated_geometry = parameter.into(),
                3usize => entity.master_representation = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait ISecurityClassification {
    fn name(&self) -> &Label;
    fn purpose(&self) -> &Text;
    fn security_level(&self) -> &EntityRef;
}
#[derive(Default, Debug)]
pub struct SecurityClassification {
    name: Label,
    purpose: Text,
    security_level: EntityRef,
}
impl ISecurityClassification for SecurityClassification {
    fn name(&self) -> &Label {
        &self.name
    }
    fn purpose(&self) -> &Text {
        &self.purpose
    }
    fn security_level(&self) -> &EntityRef {
        &self.security_level
    }
}
impl SecurityClassification {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = SecurityClassification::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => entity.purpose = parameter.into(),
                2usize => entity.security_level = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait ISecurityClassificationAssignment {
    fn assigned_security_classification(&self) -> &EntityRef;
}
pub trait ISecurityClassificationLevel {
    fn name(&self) -> &Label;
}
#[derive(Default, Debug)]
pub struct SecurityClassificationLevel {
    name: Label,
}
impl ISecurityClassificationLevel for SecurityClassificationLevel {
    fn name(&self) -> &Label {
        &self.name
    }
}
impl SecurityClassificationLevel {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = SecurityClassificationLevel::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait ISerialNumberedEffectivity: IEffectivity {
    fn effectivity_start_id(&self) -> &Identifier;
    fn effectivity_end_id(&self) -> &Option<Identifier>;
}
#[derive(Default, Debug)]
pub struct SerialNumberedEffectivity {
    id: Identifier,
    effectivity_start_id: Identifier,
    effectivity_end_id: Option<Identifier>,
}
impl IEffectivity for SerialNumberedEffectivity {
    fn id(&self) -> &Identifier {
        &self.id
    }
}
impl ISerialNumberedEffectivity for SerialNumberedEffectivity {
    fn effectivity_start_id(&self) -> &Identifier {
        &self.effectivity_start_id
    }
    fn effectivity_end_id(&self) -> &Option<Identifier> {
        &self.effectivity_end_id
    }
}
impl SerialNumberedEffectivity {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = SerialNumberedEffectivity::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.id = parameter.into(),
                1usize => entity.effectivity_start_id = parameter.into(),
                2usize => {
                    entity.effectivity_end_id = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
}
pub trait IShapeAspect {
    fn name(&self) -> &Label;
    fn description(&self) -> &Option<Text>;
    fn of_shape(&self) -> &EntityRef;
    fn product_definitional(&self) -> Option<bool>;
}
#[derive(Default, Debug)]
pub struct ShapeAspect {
    name: Label,
    description: Option<Text>,
    of_shape: EntityRef,
    product_definitional: Option<bool>,
}
impl IShapeAspect for ShapeAspect {
    fn name(&self) -> &Label {
        &self.name
    }
    fn description(&self) -> &Option<Text> {
        &self.description
    }
    fn of_shape(&self) -> &EntityRef {
        &self.of_shape
    }
    fn product_definitional(&self) -> Option<bool> {
        self.product_definitional
    }
}
impl ShapeAspect {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = ShapeAspect::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => entity.of_shape = parameter.into(),
                3usize => entity.product_definitional = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IShapeAspectAssociativity: IShapeAspectRelationship {}
#[derive(Default, Debug)]
pub struct ShapeAspectAssociativity {
    name: Label,
    description: Option<Text>,
    relating_shape_aspect: EntityRef,
    related_shape_aspect: EntityRef,
}
impl IShapeAspectRelationship for ShapeAspectAssociativity {
    fn name(&self) -> &Label {
        &self.name
    }
    fn description(&self) -> &Option<Text> {
        &self.description
    }
    fn relating_shape_aspect(&self) -> &EntityRef {
        &self.relating_shape_aspect
    }
    fn related_shape_aspect(&self) -> &EntityRef {
        &self.related_shape_aspect
    }
}
impl IShapeAspectAssociativity for ShapeAspectAssociativity {}
impl ShapeAspectAssociativity {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = ShapeAspectAssociativity::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => entity.relating_shape_aspect = parameter.into(),
                3usize => entity.related_shape_aspect = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IShapeAspectDerivingRelationship: IShapeAspectRelationship {}
#[derive(Default, Debug)]
pub struct ShapeAspectDerivingRelationship {
    name: Label,
    description: Option<Text>,
    relating_shape_aspect: EntityRef,
    related_shape_aspect: EntityRef,
}
impl IShapeAspectRelationship for ShapeAspectDerivingRelationship {
    fn name(&self) -> &Label {
        &self.name
    }
    fn description(&self) -> &Option<Text> {
        &self.description
    }
    fn relating_shape_aspect(&self) -> &EntityRef {
        &self.relating_shape_aspect
    }
    fn related_shape_aspect(&self) -> &EntityRef {
        &self.related_shape_aspect
    }
}
impl IShapeAspectDerivingRelationship for ShapeAspectDerivingRelationship {}
impl ShapeAspectDerivingRelationship {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = ShapeAspectDerivingRelationship::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => entity.relating_shape_aspect = parameter.into(),
                3usize => entity.related_shape_aspect = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IShapeAspectRelationship {
    fn name(&self) -> &Label;
    fn description(&self) -> &Option<Text>;
    fn relating_shape_aspect(&self) -> &EntityRef;
    fn related_shape_aspect(&self) -> &EntityRef;
}
#[derive(Default, Debug)]
pub struct ShapeAspectRelationship {
    name: Label,
    description: Option<Text>,
    relating_shape_aspect: EntityRef,
    related_shape_aspect: EntityRef,
}
impl IShapeAspectRelationship for ShapeAspectRelationship {
    fn name(&self) -> &Label {
        &self.name
    }
    fn description(&self) -> &Option<Text> {
        &self.description
    }
    fn relating_shape_aspect(&self) -> &EntityRef {
        &self.relating_shape_aspect
    }
    fn related_shape_aspect(&self) -> &EntityRef {
        &self.related_shape_aspect
    }
}
impl ShapeAspectRelationship {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = ShapeAspectRelationship::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => entity.relating_shape_aspect = parameter.into(),
                3usize => entity.related_shape_aspect = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IShapeDefinitionRepresentation: IPropertyDefinitionRepresentation {}
#[derive(Default, Debug)]
pub struct ShapeDefinitionRepresentation {
    definition: EntityRef,
    used_representation: EntityRef,
}
impl IPropertyDefinitionRepresentation for ShapeDefinitionRepresentation {
    fn definition(&self) -> &EntityRef {
        &self.definition
    }
    fn used_representation(&self) -> &EntityRef {
        &self.used_representation
    }
}
impl IShapeDefinitionRepresentation for ShapeDefinitionRepresentation {}
impl ShapeDefinitionRepresentation {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = ShapeDefinitionRepresentation::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.definition = parameter.into(),
                1usize => entity.used_representation = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IShapeDimensionRepresentation: IShapeRepresentation {}
#[derive(Default, Debug)]
pub struct ShapeDimensionRepresentation {
    name: Label,
    items: HashSet<EntityRef>,
    context_of_items: EntityRef,
}
impl IRepresentation for ShapeDimensionRepresentation {
    fn name(&self) -> &Label {
        &self.name
    }
    fn items(&self) -> &HashSet<EntityRef> {
        &self.items
    }
    fn context_of_items(&self) -> &EntityRef {
        &self.context_of_items
    }
}
impl IShapeRepresentation for ShapeDimensionRepresentation {}
impl IShapeDimensionRepresentation for ShapeDimensionRepresentation {}
impl ShapeDimensionRepresentation {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = ShapeDimensionRepresentation::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => entity.items = parameter.into(),
                2usize => entity.context_of_items = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IShapeFeatureDefinition: ICharacterizedObject {}
#[derive(Default, Debug)]
pub struct ShapeFeatureDefinition {
    name: Label,
    description: Option<Text>,
}
impl ICharacterizedObject for ShapeFeatureDefinition {
    fn name(&self) -> &Label {
        &self.name
    }
    fn description(&self) -> &Option<Text> {
        &self.description
    }
}
impl IShapeFeatureDefinition for ShapeFeatureDefinition {}
impl ShapeFeatureDefinition {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = ShapeFeatureDefinition::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
}
pub trait IShapeRepresentation: IRepresentation {}
#[derive(Default, Debug)]
pub struct ShapeRepresentation {
    name: Label,
    items: HashSet<EntityRef>,
    context_of_items: EntityRef,
}
impl IRepresentation for ShapeRepresentation {
    fn name(&self) -> &Label {
        &self.name
    }
    fn items(&self) -> &HashSet<EntityRef> {
        &self.items
    }
    fn context_of_items(&self) -> &EntityRef {
        &self.context_of_items
    }
}
impl IShapeRepresentation for ShapeRepresentation {}
impl ShapeRepresentation {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = ShapeRepresentation::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => entity.items = parameter.into(),
                2usize => entity.context_of_items = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IShapeRepresentationRelationship: IRepresentationRelationship {}
#[derive(Default, Debug)]
pub struct ShapeRepresentationRelationship {
    name: Label,
    description: Option<Text>,
    rep_1: EntityRef,
    rep_2: EntityRef,
}
impl IRepresentationRelationship for ShapeRepresentationRelationship {
    fn name(&self) -> &Label {
        &self.name
    }
    fn description(&self) -> &Option<Text> {
        &self.description
    }
    fn rep_1(&self) -> &EntityRef {
        &self.rep_1
    }
    fn rep_2(&self) -> &EntityRef {
        &self.rep_2
    }
}
impl IShapeRepresentationRelationship for ShapeRepresentationRelationship {}
impl ShapeRepresentationRelationship {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = ShapeRepresentationRelationship::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => entity.rep_1 = parameter.into(),
                3usize => entity.rep_2 = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IShapeRepresentationWithParameters: IShapeRepresentation {}
#[derive(Default, Debug)]
pub struct ShapeRepresentationWithParameters {
    name: Label,
    items: HashSet<EntityRef>,
    context_of_items: EntityRef,
}
impl IRepresentation for ShapeRepresentationWithParameters {
    fn name(&self) -> &Label {
        &self.name
    }
    fn items(&self) -> &HashSet<EntityRef> {
        &self.items
    }
    fn context_of_items(&self) -> &EntityRef {
        &self.context_of_items
    }
}
impl IShapeRepresentation for ShapeRepresentationWithParameters {}
impl IShapeRepresentationWithParameters for ShapeRepresentationWithParameters {}
impl ShapeRepresentationWithParameters {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = ShapeRepresentationWithParameters::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => entity.items = parameter.into(),
                2usize => entity.context_of_items = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IShellBasedSurfaceModel: IGeometricRepresentationItem {
    fn sbsm_boundary(&self) -> &HashSet<EntityRef>;
}
#[derive(Default, Debug)]
pub struct ShellBasedSurfaceModel {
    name: Label,
    sbsm_boundary: HashSet<EntityRef>,
}
impl IRepresentationItem for ShellBasedSurfaceModel {
    fn name(&self) -> &Label {
        &self.name
    }
}
impl IGeometricRepresentationItem for ShellBasedSurfaceModel {}
impl IShellBasedSurfaceModel for ShellBasedSurfaceModel {
    fn sbsm_boundary(&self) -> &HashSet<EntityRef> {
        &self.sbsm_boundary
    }
}
impl ShellBasedSurfaceModel {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = ShellBasedSurfaceModel::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => entity.sbsm_boundary = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IShellBasedWireframeModel: IGeometricRepresentationItem {
    fn sbwm_boundary(&self) -> &HashSet<EntityRef>;
}
#[derive(Default, Debug)]
pub struct ShellBasedWireframeModel {
    name: Label,
    sbwm_boundary: HashSet<EntityRef>,
}
impl IRepresentationItem for ShellBasedWireframeModel {
    fn name(&self) -> &Label {
        &self.name
    }
}
impl IGeometricRepresentationItem for ShellBasedWireframeModel {}
impl IShellBasedWireframeModel for ShellBasedWireframeModel {
    fn sbwm_boundary(&self) -> &HashSet<EntityRef> {
        &self.sbwm_boundary
    }
}
impl ShellBasedWireframeModel {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = ShellBasedWireframeModel::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => entity.sbwm_boundary = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IShellBasedWireframeShapeRepresentation: IShapeRepresentation {}
#[derive(Default, Debug)]
pub struct ShellBasedWireframeShapeRepresentation {
    name: Label,
    items: HashSet<EntityRef>,
    context_of_items: EntityRef,
}
impl IRepresentation for ShellBasedWireframeShapeRepresentation {
    fn name(&self) -> &Label {
        &self.name
    }
    fn items(&self) -> &HashSet<EntityRef> {
        &self.items
    }
    fn context_of_items(&self) -> &EntityRef {
        &self.context_of_items
    }
}
impl IShapeRepresentation for ShellBasedWireframeShapeRepresentation {}
impl IShellBasedWireframeShapeRepresentation for ShellBasedWireframeShapeRepresentation {}
impl ShellBasedWireframeShapeRepresentation {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = ShellBasedWireframeShapeRepresentation::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => entity.items = parameter.into(),
                2usize => entity.context_of_items = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IShelledSolid: IModifiedSolid {
    fn deleted_face_set(&self) -> &HashSet<EntityRef>;
    fn thickness(&self) -> &LengthMeasure;
}
#[derive(Default, Debug)]
pub struct ShelledSolid {
    name: Label,
    rationale: Text,
    base_solid: EntityRef,
    deleted_face_set: HashSet<EntityRef>,
    thickness: LengthMeasure,
}
impl IRepresentationItem for ShelledSolid {
    fn name(&self) -> &Label {
        &self.name
    }
}
impl IGeometricRepresentationItem for ShelledSolid {}
impl ISolidModel for ShelledSolid {}
impl IModifiedSolid for ShelledSolid {
    fn rationale(&self) -> &Text {
        &self.rationale
    }
    fn base_solid(&self) -> &EntityRef {
        &self.base_solid
    }
}
impl IShelledSolid for ShelledSolid {
    fn deleted_face_set(&self) -> &HashSet<EntityRef> {
        &self.deleted_face_set
    }
    fn thickness(&self) -> &LengthMeasure {
        &self.thickness
    }
}
impl ShelledSolid {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = ShelledSolid::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => entity.rationale = parameter.into(),
                2usize => entity.base_solid = parameter.into(),
                3usize => entity.deleted_face_set = parameter.into(),
                4usize => entity.thickness = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait ISiAbsorbedDoseUnit: IAbsorbedDoseUnit + ISiUnit {}
#[derive(Default, Debug)]
pub struct SiAbsorbedDoseUnit {
    elements: HashSet<EntityRef>,
    dimensions: EntityRef,
    prefix: Option<SiPrefix>,
    name: SiUnitName,
}
impl IDerivedUnit for SiAbsorbedDoseUnit {
    fn elements(&self) -> &HashSet<EntityRef> {
        &self.elements
    }
}
impl IAbsorbedDoseUnit for SiAbsorbedDoseUnit {}
impl INamedUnit for SiAbsorbedDoseUnit {
    fn dimensions(&self) -> &EntityRef {
        &self.dimensions
    }
}
impl ISiUnit for SiAbsorbedDoseUnit {
    fn prefix(&self) -> &Option<SiPrefix> {
        &self.prefix
    }
    fn name(&self) -> &SiUnitName {
        &self.name
    }
}
impl ISiAbsorbedDoseUnit for SiAbsorbedDoseUnit {}
impl SiAbsorbedDoseUnit {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = SiAbsorbedDoseUnit::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.elements = parameter.into(),
                1usize => entity.dimensions = parameter.into(),
                2usize => {
                    entity.prefix = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => entity.name = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait ISiCapacitanceUnit: ICapacitanceUnit + ISiUnit {}
#[derive(Default, Debug)]
pub struct SiCapacitanceUnit {
    elements: HashSet<EntityRef>,
    dimensions: EntityRef,
    prefix: Option<SiPrefix>,
    name: SiUnitName,
}
impl IDerivedUnit for SiCapacitanceUnit {
    fn elements(&self) -> &HashSet<EntityRef> {
        &self.elements
    }
}
impl ICapacitanceUnit for SiCapacitanceUnit {}
impl INamedUnit for SiCapacitanceUnit {
    fn dimensions(&self) -> &EntityRef {
        &self.dimensions
    }
}
impl ISiUnit for SiCapacitanceUnit {
    fn prefix(&self) -> &Option<SiPrefix> {
        &self.prefix
    }
    fn name(&self) -> &SiUnitName {
        &self.name
    }
}
impl ISiCapacitanceUnit for SiCapacitanceUnit {}
impl SiCapacitanceUnit {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = SiCapacitanceUnit::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.elements = parameter.into(),
                1usize => entity.dimensions = parameter.into(),
                2usize => {
                    entity.prefix = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => entity.name = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait ISiConductanceUnit: IConductanceUnit + ISiUnit {}
#[derive(Default, Debug)]
pub struct SiConductanceUnit {
    elements: HashSet<EntityRef>,
    dimensions: EntityRef,
    prefix: Option<SiPrefix>,
    name: SiUnitName,
}
impl IDerivedUnit for SiConductanceUnit {
    fn elements(&self) -> &HashSet<EntityRef> {
        &self.elements
    }
}
impl IConductanceUnit for SiConductanceUnit {}
impl INamedUnit for SiConductanceUnit {
    fn dimensions(&self) -> &EntityRef {
        &self.dimensions
    }
}
impl ISiUnit for SiConductanceUnit {
    fn prefix(&self) -> &Option<SiPrefix> {
        &self.prefix
    }
    fn name(&self) -> &SiUnitName {
        &self.name
    }
}
impl ISiConductanceUnit for SiConductanceUnit {}
impl SiConductanceUnit {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = SiConductanceUnit::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.elements = parameter.into(),
                1usize => entity.dimensions = parameter.into(),
                2usize => {
                    entity.prefix = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => entity.name = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait ISiDoseEquivalentUnit: IDoseEquivalentUnit + ISiUnit {}
#[derive(Default, Debug)]
pub struct SiDoseEquivalentUnit {
    elements: HashSet<EntityRef>,
    dimensions: EntityRef,
    prefix: Option<SiPrefix>,
    name: SiUnitName,
}
impl IDerivedUnit for SiDoseEquivalentUnit {
    fn elements(&self) -> &HashSet<EntityRef> {
        &self.elements
    }
}
impl IDoseEquivalentUnit for SiDoseEquivalentUnit {}
impl INamedUnit for SiDoseEquivalentUnit {
    fn dimensions(&self) -> &EntityRef {
        &self.dimensions
    }
}
impl ISiUnit for SiDoseEquivalentUnit {
    fn prefix(&self) -> &Option<SiPrefix> {
        &self.prefix
    }
    fn name(&self) -> &SiUnitName {
        &self.name
    }
}
impl ISiDoseEquivalentUnit for SiDoseEquivalentUnit {}
impl SiDoseEquivalentUnit {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = SiDoseEquivalentUnit::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.elements = parameter.into(),
                1usize => entity.dimensions = parameter.into(),
                2usize => {
                    entity.prefix = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => entity.name = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait ISiElectricChargeUnit: IElectricChargeUnit + ISiUnit {}
#[derive(Default, Debug)]
pub struct SiElectricChargeUnit {
    elements: HashSet<EntityRef>,
    dimensions: EntityRef,
    prefix: Option<SiPrefix>,
    name: SiUnitName,
}
impl IDerivedUnit for SiElectricChargeUnit {
    fn elements(&self) -> &HashSet<EntityRef> {
        &self.elements
    }
}
impl IElectricChargeUnit for SiElectricChargeUnit {}
impl INamedUnit for SiElectricChargeUnit {
    fn dimensions(&self) -> &EntityRef {
        &self.dimensions
    }
}
impl ISiUnit for SiElectricChargeUnit {
    fn prefix(&self) -> &Option<SiPrefix> {
        &self.prefix
    }
    fn name(&self) -> &SiUnitName {
        &self.name
    }
}
impl ISiElectricChargeUnit for SiElectricChargeUnit {}
impl SiElectricChargeUnit {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = SiElectricChargeUnit::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.elements = parameter.into(),
                1usize => entity.dimensions = parameter.into(),
                2usize => {
                    entity.prefix = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => entity.name = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait ISiElectricPotentialUnit: IElectricPotentialUnit + ISiUnit {}
#[derive(Default, Debug)]
pub struct SiElectricPotentialUnit {
    elements: HashSet<EntityRef>,
    dimensions: EntityRef,
    prefix: Option<SiPrefix>,
    name: SiUnitName,
}
impl IDerivedUnit for SiElectricPotentialUnit {
    fn elements(&self) -> &HashSet<EntityRef> {
        &self.elements
    }
}
impl IElectricPotentialUnit for SiElectricPotentialUnit {}
impl INamedUnit for SiElectricPotentialUnit {
    fn dimensions(&self) -> &EntityRef {
        &self.dimensions
    }
}
impl ISiUnit for SiElectricPotentialUnit {
    fn prefix(&self) -> &Option<SiPrefix> {
        &self.prefix
    }
    fn name(&self) -> &SiUnitName {
        &self.name
    }
}
impl ISiElectricPotentialUnit for SiElectricPotentialUnit {}
impl SiElectricPotentialUnit {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = SiElectricPotentialUnit::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.elements = parameter.into(),
                1usize => entity.dimensions = parameter.into(),
                2usize => {
                    entity.prefix = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => entity.name = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait ISiEnergyUnit: IEnergyUnit + ISiUnit {}
#[derive(Default, Debug)]
pub struct SiEnergyUnit {
    elements: HashSet<EntityRef>,
    dimensions: EntityRef,
    prefix: Option<SiPrefix>,
    name: SiUnitName,
}
impl IDerivedUnit for SiEnergyUnit {
    fn elements(&self) -> &HashSet<EntityRef> {
        &self.elements
    }
}
impl IEnergyUnit for SiEnergyUnit {}
impl INamedUnit for SiEnergyUnit {
    fn dimensions(&self) -> &EntityRef {
        &self.dimensions
    }
}
impl ISiUnit for SiEnergyUnit {
    fn prefix(&self) -> &Option<SiPrefix> {
        &self.prefix
    }
    fn name(&self) -> &SiUnitName {
        &self.name
    }
}
impl ISiEnergyUnit for SiEnergyUnit {}
impl SiEnergyUnit {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = SiEnergyUnit::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.elements = parameter.into(),
                1usize => entity.dimensions = parameter.into(),
                2usize => {
                    entity.prefix = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => entity.name = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait ISiForceUnit: IForceUnit + ISiUnit {}
#[derive(Default, Debug)]
pub struct SiForceUnit {
    elements: HashSet<EntityRef>,
    dimensions: EntityRef,
    prefix: Option<SiPrefix>,
    name: SiUnitName,
}
impl IDerivedUnit for SiForceUnit {
    fn elements(&self) -> &HashSet<EntityRef> {
        &self.elements
    }
}
impl IForceUnit for SiForceUnit {}
impl INamedUnit for SiForceUnit {
    fn dimensions(&self) -> &EntityRef {
        &self.dimensions
    }
}
impl ISiUnit for SiForceUnit {
    fn prefix(&self) -> &Option<SiPrefix> {
        &self.prefix
    }
    fn name(&self) -> &SiUnitName {
        &self.name
    }
}
impl ISiForceUnit for SiForceUnit {}
impl SiForceUnit {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = SiForceUnit::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.elements = parameter.into(),
                1usize => entity.dimensions = parameter.into(),
                2usize => {
                    entity.prefix = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => entity.name = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait ISiFrequencyUnit: IFrequencyUnit + ISiUnit {}
#[derive(Default, Debug)]
pub struct SiFrequencyUnit {
    elements: HashSet<EntityRef>,
    dimensions: EntityRef,
    prefix: Option<SiPrefix>,
    name: SiUnitName,
}
impl IDerivedUnit for SiFrequencyUnit {
    fn elements(&self) -> &HashSet<EntityRef> {
        &self.elements
    }
}
impl IFrequencyUnit for SiFrequencyUnit {}
impl INamedUnit for SiFrequencyUnit {
    fn dimensions(&self) -> &EntityRef {
        &self.dimensions
    }
}
impl ISiUnit for SiFrequencyUnit {
    fn prefix(&self) -> &Option<SiPrefix> {
        &self.prefix
    }
    fn name(&self) -> &SiUnitName {
        &self.name
    }
}
impl ISiFrequencyUnit for SiFrequencyUnit {}
impl SiFrequencyUnit {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = SiFrequencyUnit::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.elements = parameter.into(),
                1usize => entity.dimensions = parameter.into(),
                2usize => {
                    entity.prefix = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => entity.name = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait ISiIlluminanceUnit: IIlluminanceUnit + ISiUnit {}
#[derive(Default, Debug)]
pub struct SiIlluminanceUnit {
    elements: HashSet<EntityRef>,
    dimensions: EntityRef,
    prefix: Option<SiPrefix>,
    name: SiUnitName,
}
impl IDerivedUnit for SiIlluminanceUnit {
    fn elements(&self) -> &HashSet<EntityRef> {
        &self.elements
    }
}
impl IIlluminanceUnit for SiIlluminanceUnit {}
impl INamedUnit for SiIlluminanceUnit {
    fn dimensions(&self) -> &EntityRef {
        &self.dimensions
    }
}
impl ISiUnit for SiIlluminanceUnit {
    fn prefix(&self) -> &Option<SiPrefix> {
        &self.prefix
    }
    fn name(&self) -> &SiUnitName {
        &self.name
    }
}
impl ISiIlluminanceUnit for SiIlluminanceUnit {}
impl SiIlluminanceUnit {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = SiIlluminanceUnit::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.elements = parameter.into(),
                1usize => entity.dimensions = parameter.into(),
                2usize => {
                    entity.prefix = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => entity.name = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait ISiInductanceUnit: IInductanceUnit + ISiUnit {}
#[derive(Default, Debug)]
pub struct SiInductanceUnit {
    elements: HashSet<EntityRef>,
    dimensions: EntityRef,
    prefix: Option<SiPrefix>,
    name: SiUnitName,
}
impl IDerivedUnit for SiInductanceUnit {
    fn elements(&self) -> &HashSet<EntityRef> {
        &self.elements
    }
}
impl IInductanceUnit for SiInductanceUnit {}
impl INamedUnit for SiInductanceUnit {
    fn dimensions(&self) -> &EntityRef {
        &self.dimensions
    }
}
impl ISiUnit for SiInductanceUnit {
    fn prefix(&self) -> &Option<SiPrefix> {
        &self.prefix
    }
    fn name(&self) -> &SiUnitName {
        &self.name
    }
}
impl ISiInductanceUnit for SiInductanceUnit {}
impl SiInductanceUnit {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = SiInductanceUnit::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.elements = parameter.into(),
                1usize => entity.dimensions = parameter.into(),
                2usize => {
                    entity.prefix = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => entity.name = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait ISiMagneticFluxDensityUnit: IMagneticFluxDensityUnit + ISiUnit {}
#[derive(Default, Debug)]
pub struct SiMagneticFluxDensityUnit {
    elements: HashSet<EntityRef>,
    dimensions: EntityRef,
    prefix: Option<SiPrefix>,
    name: SiUnitName,
}
impl IDerivedUnit for SiMagneticFluxDensityUnit {
    fn elements(&self) -> &HashSet<EntityRef> {
        &self.elements
    }
}
impl IMagneticFluxDensityUnit for SiMagneticFluxDensityUnit {}
impl INamedUnit for SiMagneticFluxDensityUnit {
    fn dimensions(&self) -> &EntityRef {
        &self.dimensions
    }
}
impl ISiUnit for SiMagneticFluxDensityUnit {
    fn prefix(&self) -> &Option<SiPrefix> {
        &self.prefix
    }
    fn name(&self) -> &SiUnitName {
        &self.name
    }
}
impl ISiMagneticFluxDensityUnit for SiMagneticFluxDensityUnit {}
impl SiMagneticFluxDensityUnit {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = SiMagneticFluxDensityUnit::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.elements = parameter.into(),
                1usize => entity.dimensions = parameter.into(),
                2usize => {
                    entity.prefix = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => entity.name = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait ISiMagneticFluxUnit: IMagneticFluxUnit + ISiUnit {}
#[derive(Default, Debug)]
pub struct SiMagneticFluxUnit {
    elements: HashSet<EntityRef>,
    dimensions: EntityRef,
    prefix: Option<SiPrefix>,
    name: SiUnitName,
}
impl IDerivedUnit for SiMagneticFluxUnit {
    fn elements(&self) -> &HashSet<EntityRef> {
        &self.elements
    }
}
impl IMagneticFluxUnit for SiMagneticFluxUnit {}
impl INamedUnit for SiMagneticFluxUnit {
    fn dimensions(&self) -> &EntityRef {
        &self.dimensions
    }
}
impl ISiUnit for SiMagneticFluxUnit {
    fn prefix(&self) -> &Option<SiPrefix> {
        &self.prefix
    }
    fn name(&self) -> &SiUnitName {
        &self.name
    }
}
impl ISiMagneticFluxUnit for SiMagneticFluxUnit {}
impl SiMagneticFluxUnit {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = SiMagneticFluxUnit::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.elements = parameter.into(),
                1usize => entity.dimensions = parameter.into(),
                2usize => {
                    entity.prefix = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => entity.name = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait ISiPowerUnit: IPowerUnit + ISiUnit {}
#[derive(Default, Debug)]
pub struct SiPowerUnit {
    elements: HashSet<EntityRef>,
    dimensions: EntityRef,
    prefix: Option<SiPrefix>,
    name: SiUnitName,
}
impl IDerivedUnit for SiPowerUnit {
    fn elements(&self) -> &HashSet<EntityRef> {
        &self.elements
    }
}
impl IPowerUnit for SiPowerUnit {}
impl INamedUnit for SiPowerUnit {
    fn dimensions(&self) -> &EntityRef {
        &self.dimensions
    }
}
impl ISiUnit for SiPowerUnit {
    fn prefix(&self) -> &Option<SiPrefix> {
        &self.prefix
    }
    fn name(&self) -> &SiUnitName {
        &self.name
    }
}
impl ISiPowerUnit for SiPowerUnit {}
impl SiPowerUnit {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = SiPowerUnit::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.elements = parameter.into(),
                1usize => entity.dimensions = parameter.into(),
                2usize => {
                    entity.prefix = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => entity.name = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait ISiPressureUnit: IPressureUnit + ISiUnit {}
#[derive(Default, Debug)]
pub struct SiPressureUnit {
    elements: HashSet<EntityRef>,
    dimensions: EntityRef,
    prefix: Option<SiPrefix>,
    name: SiUnitName,
}
impl IDerivedUnit for SiPressureUnit {
    fn elements(&self) -> &HashSet<EntityRef> {
        &self.elements
    }
}
impl IPressureUnit for SiPressureUnit {}
impl INamedUnit for SiPressureUnit {
    fn dimensions(&self) -> &EntityRef {
        &self.dimensions
    }
}
impl ISiUnit for SiPressureUnit {
    fn prefix(&self) -> &Option<SiPrefix> {
        &self.prefix
    }
    fn name(&self) -> &SiUnitName {
        &self.name
    }
}
impl ISiPressureUnit for SiPressureUnit {}
impl SiPressureUnit {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = SiPressureUnit::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.elements = parameter.into(),
                1usize => entity.dimensions = parameter.into(),
                2usize => {
                    entity.prefix = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => entity.name = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait ISiRadioactivityUnit: IRadioactivityUnit + ISiUnit {}
#[derive(Default, Debug)]
pub struct SiRadioactivityUnit {
    elements: HashSet<EntityRef>,
    dimensions: EntityRef,
    prefix: Option<SiPrefix>,
    name: SiUnitName,
}
impl IDerivedUnit for SiRadioactivityUnit {
    fn elements(&self) -> &HashSet<EntityRef> {
        &self.elements
    }
}
impl IRadioactivityUnit for SiRadioactivityUnit {}
impl INamedUnit for SiRadioactivityUnit {
    fn dimensions(&self) -> &EntityRef {
        &self.dimensions
    }
}
impl ISiUnit for SiRadioactivityUnit {
    fn prefix(&self) -> &Option<SiPrefix> {
        &self.prefix
    }
    fn name(&self) -> &SiUnitName {
        &self.name
    }
}
impl ISiRadioactivityUnit for SiRadioactivityUnit {}
impl SiRadioactivityUnit {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = SiRadioactivityUnit::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.elements = parameter.into(),
                1usize => entity.dimensions = parameter.into(),
                2usize => {
                    entity.prefix = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => entity.name = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait ISiResistanceUnit: IResistanceUnit + ISiUnit {}
#[derive(Default, Debug)]
pub struct SiResistanceUnit {
    elements: HashSet<EntityRef>,
    dimensions: EntityRef,
    prefix: Option<SiPrefix>,
    name: SiUnitName,
}
impl IDerivedUnit for SiResistanceUnit {
    fn elements(&self) -> &HashSet<EntityRef> {
        &self.elements
    }
}
impl IResistanceUnit for SiResistanceUnit {}
impl INamedUnit for SiResistanceUnit {
    fn dimensions(&self) -> &EntityRef {
        &self.dimensions
    }
}
impl ISiUnit for SiResistanceUnit {
    fn prefix(&self) -> &Option<SiPrefix> {
        &self.prefix
    }
    fn name(&self) -> &SiUnitName {
        &self.name
    }
}
impl ISiResistanceUnit for SiResistanceUnit {}
impl SiResistanceUnit {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = SiResistanceUnit::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.elements = parameter.into(),
                1usize => entity.dimensions = parameter.into(),
                2usize => {
                    entity.prefix = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => entity.name = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait ISiUnit: INamedUnit {
    fn prefix(&self) -> &Option<SiPrefix>;
    fn name(&self) -> &SiUnitName;
}
#[derive(Default, Debug)]
pub struct SiUnit {
    dimensions: EntityRef,
    prefix: Option<SiPrefix>,
    name: SiUnitName,
}
impl INamedUnit for SiUnit {
    fn dimensions(&self) -> &EntityRef {
        &self.dimensions
    }
}
impl ISiUnit for SiUnit {
    fn prefix(&self) -> &Option<SiPrefix> {
        &self.prefix
    }
    fn name(&self) -> &SiUnitName {
        &self.name
    }
}
impl SiUnit {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = SiUnit::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.dimensions = parameter.into(),
                1usize => {
                    entity.prefix = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => entity.name = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait ISimpleBooleanExpression: IBooleanExpression + ISimpleGenericExpression {}
pub trait ISimpleClause: ICompoundRepresentationItem {}
#[derive(Default, Debug)]
pub struct SimpleClause {
    name: Label,
    item_element: CompoundItemDefinition,
}
impl IRepresentationItem for SimpleClause {
    fn name(&self) -> &Label {
        &self.name
    }
}
impl ICompoundRepresentationItem for SimpleClause {
    fn item_element(&self) -> &CompoundItemDefinition {
        &self.item_element
    }
}
impl ISimpleClause for SimpleClause {}
impl SimpleClause {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = SimpleClause::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => entity.item_element = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait ISimpleGenericExpression: IGenericExpression {}
pub trait ISimpleNumericExpression: INumericExpression + ISimpleGenericExpression {}
pub trait ISlashExpression: IBinaryNumericExpression {}
#[derive(Default, Debug)]
pub struct SlashExpression {
    operands: Vec<EntityRef>,
}
impl IGenericExpression for SlashExpression {}
impl IExpression for SlashExpression {}
impl INumericExpression for SlashExpression {}
impl IBinaryNumericExpression for SlashExpression {
    fn operands(&self) -> &Vec<EntityRef> {
        &self.operands
    }
}
impl IBinaryGenericExpression for SlashExpression {
    fn operands(&self) -> &Vec<EntityRef> {
        &self.operands
    }
}
impl ISlashExpression for SlashExpression {}
impl SlashExpression {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = SlashExpression::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.operands = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait ISmearedMaterialDefinition: IZoneStructuralMakeup {}
#[derive(Default, Debug)]
pub struct SmearedMaterialDefinition {
    id: Identifier,
    description: Option<Text>,
    formation: EntityRef,
    frame_of_reference: EntityRef,
}
impl IProductDefinition for SmearedMaterialDefinition {
    fn id(&self) -> &Identifier {
        &self.id
    }
    fn description(&self) -> &Option<Text> {
        &self.description
    }
    fn formation(&self) -> &EntityRef {
        &self.formation
    }
    fn frame_of_reference(&self) -> &EntityRef {
        &self.frame_of_reference
    }
}
impl ILaminateTable for SmearedMaterialDefinition {}
impl IZoneStructuralMakeup for SmearedMaterialDefinition {}
impl ISmearedMaterialDefinition for SmearedMaterialDefinition {}
impl SmearedMaterialDefinition {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = SmearedMaterialDefinition::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.id = parameter.into(),
                1usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => entity.formation = parameter.into(),
                3usize => entity.frame_of_reference = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait ISolidAngleMeasureWithUnit: IMeasureWithUnit {}
#[derive(Default, Debug)]
pub struct SolidAngleMeasureWithUnit {
    value_component: MeasureValue,
    unit_component: EntityRef,
}
impl IMeasureWithUnit for SolidAngleMeasureWithUnit {
    fn value_component(&self) -> &MeasureValue {
        &self.value_component
    }
    fn unit_component(&self) -> &EntityRef {
        &self.unit_component
    }
}
impl ISolidAngleMeasureWithUnit for SolidAngleMeasureWithUnit {}
impl SolidAngleMeasureWithUnit {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = SolidAngleMeasureWithUnit::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.value_component = parameter.into(),
                1usize => entity.unit_component = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait ISolidAngleUnit: INamedUnit {}
#[derive(Default, Debug)]
pub struct SolidAngleUnit {
    dimensions: EntityRef,
}
impl INamedUnit for SolidAngleUnit {
    fn dimensions(&self) -> &EntityRef {
        &self.dimensions
    }
}
impl ISolidAngleUnit for SolidAngleUnit {}
impl SolidAngleUnit {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = SolidAngleUnit::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.dimensions = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait ISolidCurveFont: IPreDefinedCurveFont {}
#[derive(Default, Debug)]
pub struct SolidCurveFont {
    name: Label,
}
impl IPreDefinedItem for SolidCurveFont {
    fn name(&self) -> &Label {
        &self.name
    }
}
impl IPreDefinedCurveFont for SolidCurveFont {}
impl ISolidCurveFont for SolidCurveFont {}
impl SolidCurveFont {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = SolidCurveFont::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait ISolidModel: IGeometricRepresentationItem {}
#[derive(Default, Debug)]
pub struct SolidModel {
    name: Label,
}
impl IRepresentationItem for SolidModel {
    fn name(&self) -> &Label {
        &self.name
    }
}
impl IGeometricRepresentationItem for SolidModel {}
impl ISolidModel for SolidModel {}
impl SolidModel {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = SolidModel::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait ISolidReplica: ISolidModel {
    fn parent_solid(&self) -> &EntityRef;
    fn transformation(&self) -> &EntityRef;
}
#[derive(Default, Debug)]
pub struct SolidReplica {
    name: Label,
    parent_solid: EntityRef,
    transformation: EntityRef,
}
impl IRepresentationItem for SolidReplica {
    fn name(&self) -> &Label {
        &self.name
    }
}
impl IGeometricRepresentationItem for SolidReplica {}
impl ISolidModel for SolidReplica {}
impl ISolidReplica for SolidReplica {
    fn parent_solid(&self) -> &EntityRef {
        &self.parent_solid
    }
    fn transformation(&self) -> &EntityRef {
        &self.transformation
    }
}
impl SolidReplica {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = SolidReplica::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => entity.parent_solid = parameter.into(),
                2usize => entity.transformation = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait ISolidWithAngleBasedChamfer: ISolidWithChamferedEdges {
    fn offset_distance(&self) -> &PositiveLengthMeasure;
    fn left_offset(&self) -> bool;
    fn offset_angle(&self) -> &PositivePlaneAngleMeasure;
}
#[derive(Default, Debug)]
pub struct SolidWithAngleBasedChamfer {
    name: Label,
    rationale: Text,
    base_solid: EntityRef,
    blended_edges: Vec<EntityRef>,
    offset_distance: PositiveLengthMeasure,
    left_offset: bool,
    offset_angle: PositivePlaneAngleMeasure,
}
impl IRepresentationItem for SolidWithAngleBasedChamfer {
    fn name(&self) -> &Label {
        &self.name
    }
}
impl IGeometricRepresentationItem for SolidWithAngleBasedChamfer {}
impl ISolidModel for SolidWithAngleBasedChamfer {}
impl IModifiedSolid for SolidWithAngleBasedChamfer {
    fn rationale(&self) -> &Text {
        &self.rationale
    }
    fn base_solid(&self) -> &EntityRef {
        &self.base_solid
    }
}
impl IEdgeBlendedSolid for SolidWithAngleBasedChamfer {
    fn blended_edges(&self) -> &Vec<EntityRef> {
        &self.blended_edges
    }
}
impl ISolidWithChamferedEdges for SolidWithAngleBasedChamfer {}
impl ISolidWithAngleBasedChamfer for SolidWithAngleBasedChamfer {
    fn offset_distance(&self) -> &PositiveLengthMeasure {
        &self.offset_distance
    }
    fn left_offset(&self) -> bool {
        self.left_offset
    }
    fn offset_angle(&self) -> &PositivePlaneAngleMeasure {
        &self.offset_angle
    }
}
impl SolidWithAngleBasedChamfer {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = SolidWithAngleBasedChamfer::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => entity.rationale = parameter.into(),
                2usize => entity.base_solid = parameter.into(),
                3usize => entity.blended_edges = parameter.into(),
                4usize => entity.offset_distance = parameter.into(),
                5usize => entity.left_offset = parameter.into(),
                6usize => entity.offset_angle = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait ISolidWithChamferedEdges: IEdgeBlendedSolid {}
pub trait ISolidWithCircularPattern: ISolidWithShapeElementPattern {
    fn replicate_count(&self) -> &PositiveInteger;
    fn angular_spacing(&self) -> &PlaneAngleMeasure;
    fn radial_alignment(&self) -> bool;
    fn reference_point(&self) -> &EntityRef;
}
#[derive(Default, Debug)]
pub struct SolidWithCircularPattern {
    name: Label,
    rationale: Text,
    base_solid: EntityRef,
    placing: EntityRef,
    replicated_element: EntityRef,
    replicate_count: PositiveInteger,
    angular_spacing: PlaneAngleMeasure,
    radial_alignment: bool,
    reference_point: EntityRef,
}
impl IRepresentationItem for SolidWithCircularPattern {
    fn name(&self) -> &Label {
        &self.name
    }
}
impl IGeometricRepresentationItem for SolidWithCircularPattern {}
impl ISolidModel for SolidWithCircularPattern {}
impl IModifiedSolid for SolidWithCircularPattern {
    fn rationale(&self) -> &Text {
        &self.rationale
    }
    fn base_solid(&self) -> &EntityRef {
        &self.base_solid
    }
}
impl IModifiedSolidWithPlacedConfiguration for SolidWithCircularPattern {
    fn placing(&self) -> &EntityRef {
        &self.placing
    }
}
impl ISolidWithShapeElementPattern for SolidWithCircularPattern {
    fn replicated_element(&self) -> &EntityRef {
        &self.replicated_element
    }
}
impl ISolidWithCircularPattern for SolidWithCircularPattern {
    fn replicate_count(&self) -> &PositiveInteger {
        &self.replicate_count
    }
    fn angular_spacing(&self) -> &PlaneAngleMeasure {
        &self.angular_spacing
    }
    fn radial_alignment(&self) -> bool {
        self.radial_alignment
    }
    fn reference_point(&self) -> &EntityRef {
        &self.reference_point
    }
}
impl SolidWithCircularPattern {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = SolidWithCircularPattern::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => entity.rationale = parameter.into(),
                2usize => entity.base_solid = parameter.into(),
                3usize => entity.placing = parameter.into(),
                4usize => entity.replicated_element = parameter.into(),
                5usize => entity.replicate_count = parameter.into(),
                6usize => entity.angular_spacing = parameter.into(),
                7usize => entity.radial_alignment = parameter.into(),
                8usize => entity.reference_point = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait ISolidWithCircularPocket: ISolidWithPocket {
    fn pocket_radius(&self) -> &PositiveLengthMeasure;
}
#[derive(Default, Debug)]
pub struct SolidWithCircularPocket {
    name: Label,
    rationale: Text,
    base_solid: EntityRef,
    placing: EntityRef,
    depth: PositiveLengthMeasure,
    floor_blend_radius: NonNegativeLengthMeasure,
    draft_angle: PlaneAngleMeasure,
    pocket_radius: PositiveLengthMeasure,
}
impl IRepresentationItem for SolidWithCircularPocket {
    fn name(&self) -> &Label {
        &self.name
    }
}
impl IGeometricRepresentationItem for SolidWithCircularPocket {}
impl ISolidModel for SolidWithCircularPocket {}
impl IModifiedSolid for SolidWithCircularPocket {
    fn rationale(&self) -> &Text {
        &self.rationale
    }
    fn base_solid(&self) -> &EntityRef {
        &self.base_solid
    }
}
impl IModifiedSolidWithPlacedConfiguration for SolidWithCircularPocket {
    fn placing(&self) -> &EntityRef {
        &self.placing
    }
}
impl ISolidWithDepression for SolidWithCircularPocket {
    fn depth(&self) -> &PositiveLengthMeasure {
        &self.depth
    }
}
impl ISolidWithPocket for SolidWithCircularPocket {
    fn floor_blend_radius(&self) -> &NonNegativeLengthMeasure {
        &self.floor_blend_radius
    }
    fn draft_angle(&self) -> &PlaneAngleMeasure {
        &self.draft_angle
    }
}
impl ISolidWithCircularPocket for SolidWithCircularPocket {
    fn pocket_radius(&self) -> &PositiveLengthMeasure {
        &self.pocket_radius
    }
}
impl SolidWithCircularPocket {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = SolidWithCircularPocket::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => entity.rationale = parameter.into(),
                2usize => entity.base_solid = parameter.into(),
                3usize => entity.placing = parameter.into(),
                4usize => entity.depth = parameter.into(),
                5usize => entity.floor_blend_radius = parameter.into(),
                6usize => entity.draft_angle = parameter.into(),
                7usize => entity.pocket_radius = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait ISolidWithCircularProtrusion: ISolidWithProtrusion {
    fn protrusion_radius(&self) -> &PositiveLengthMeasure;
}
#[derive(Default, Debug)]
pub struct SolidWithCircularProtrusion {
    name: Label,
    rationale: Text,
    base_solid: EntityRef,
    placing: EntityRef,
    protrusion_height: PositiveLengthMeasure,
    protrusion_draft_angle: PlaneAngleMeasure,
    protrusion_radius: PositiveLengthMeasure,
}
impl IRepresentationItem for SolidWithCircularProtrusion {
    fn name(&self) -> &Label {
        &self.name
    }
}
impl IGeometricRepresentationItem for SolidWithCircularProtrusion {}
impl ISolidModel for SolidWithCircularProtrusion {}
impl IModifiedSolid for SolidWithCircularProtrusion {
    fn rationale(&self) -> &Text {
        &self.rationale
    }
    fn base_solid(&self) -> &EntityRef {
        &self.base_solid
    }
}
impl IModifiedSolidWithPlacedConfiguration for SolidWithCircularProtrusion {
    fn placing(&self) -> &EntityRef {
        &self.placing
    }
}
impl ISolidWithProtrusion for SolidWithCircularProtrusion {
    fn protrusion_height(&self) -> &PositiveLengthMeasure {
        &self.protrusion_height
    }
    fn protrusion_draft_angle(&self) -> &PlaneAngleMeasure {
        &self.protrusion_draft_angle
    }
}
impl ISolidWithCircularProtrusion for SolidWithCircularProtrusion {
    fn protrusion_radius(&self) -> &PositiveLengthMeasure {
        &self.protrusion_radius
    }
}
impl SolidWithCircularProtrusion {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = SolidWithCircularProtrusion::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => entity.rationale = parameter.into(),
                2usize => entity.base_solid = parameter.into(),
                3usize => entity.placing = parameter.into(),
                4usize => entity.protrusion_height = parameter.into(),
                5usize => entity.protrusion_draft_angle = parameter.into(),
                6usize => entity.protrusion_radius = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait ISolidWithConicalBottomRoundHole: ISolidWithSteppedRoundHole {
    fn semi_apex_angle(&self) -> &PositivePlaneAngleMeasure;
    fn tip_radius(&self) -> &NonNegativeLengthMeasure;
}
#[derive(Default, Debug)]
pub struct SolidWithConicalBottomRoundHole {
    name: Label,
    rationale: Text,
    base_solid: EntityRef,
    placing: EntityRef,
    depth: PositiveLengthMeasure,
    segments: PositiveInteger,
    segment_radii: Vec<PositiveLengthMeasure>,
    segment_depths: Vec<PositiveLengthMeasure>,
    semi_apex_angle: PositivePlaneAngleMeasure,
    tip_radius: NonNegativeLengthMeasure,
}
impl IRepresentationItem for SolidWithConicalBottomRoundHole {
    fn name(&self) -> &Label {
        &self.name
    }
}
impl IGeometricRepresentationItem for SolidWithConicalBottomRoundHole {}
impl ISolidModel for SolidWithConicalBottomRoundHole {}
impl IModifiedSolid for SolidWithConicalBottomRoundHole {
    fn rationale(&self) -> &Text {
        &self.rationale
    }
    fn base_solid(&self) -> &EntityRef {
        &self.base_solid
    }
}
impl IModifiedSolidWithPlacedConfiguration for SolidWithConicalBottomRoundHole {
    fn placing(&self) -> &EntityRef {
        &self.placing
    }
}
impl ISolidWithDepression for SolidWithConicalBottomRoundHole {
    fn depth(&self) -> &PositiveLengthMeasure {
        &self.depth
    }
}
impl ISolidWithHole for SolidWithConicalBottomRoundHole {}
impl ISolidWithSteppedRoundHole for SolidWithConicalBottomRoundHole {
    fn segments(&self) -> &PositiveInteger {
        &self.segments
    }
    fn segment_radii(&self) -> &Vec<PositiveLengthMeasure> {
        &self.segment_radii
    }
    fn segment_depths(&self) -> &Vec<PositiveLengthMeasure> {
        &self.segment_depths
    }
}
impl ISolidWithConicalBottomRoundHole for SolidWithConicalBottomRoundHole {
    fn semi_apex_angle(&self) -> &PositivePlaneAngleMeasure {
        &self.semi_apex_angle
    }
    fn tip_radius(&self) -> &NonNegativeLengthMeasure {
        &self.tip_radius
    }
}
impl SolidWithConicalBottomRoundHole {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = SolidWithConicalBottomRoundHole::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => entity.rationale = parameter.into(),
                2usize => entity.base_solid = parameter.into(),
                3usize => entity.placing = parameter.into(),
                4usize => entity.depth = parameter.into(),
                5usize => entity.segments = parameter.into(),
                6usize => entity.segment_radii = parameter.into(),
                7usize => entity.segment_depths = parameter.into(),
                8usize => entity.semi_apex_angle = parameter.into(),
                9usize => entity.tip_radius = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait ISolidWithConstantRadiusEdgeBlend: IEdgeBlendedSolid {
    fn radius(&self) -> &PositiveLengthMeasure;
}
#[derive(Default, Debug)]
pub struct SolidWithConstantRadiusEdgeBlend {
    name: Label,
    rationale: Text,
    base_solid: EntityRef,
    blended_edges: Vec<EntityRef>,
    radius: PositiveLengthMeasure,
}
impl IRepresentationItem for SolidWithConstantRadiusEdgeBlend {
    fn name(&self) -> &Label {
        &self.name
    }
}
impl IGeometricRepresentationItem for SolidWithConstantRadiusEdgeBlend {}
impl ISolidModel for SolidWithConstantRadiusEdgeBlend {}
impl IModifiedSolid for SolidWithConstantRadiusEdgeBlend {
    fn rationale(&self) -> &Text {
        &self.rationale
    }
    fn base_solid(&self) -> &EntityRef {
        &self.base_solid
    }
}
impl IEdgeBlendedSolid for SolidWithConstantRadiusEdgeBlend {
    fn blended_edges(&self) -> &Vec<EntityRef> {
        &self.blended_edges
    }
}
impl ISolidWithConstantRadiusEdgeBlend for SolidWithConstantRadiusEdgeBlend {
    fn radius(&self) -> &PositiveLengthMeasure {
        &self.radius
    }
}
impl SolidWithConstantRadiusEdgeBlend {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = SolidWithConstantRadiusEdgeBlend::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => entity.rationale = parameter.into(),
                2usize => entity.base_solid = parameter.into(),
                3usize => entity.blended_edges = parameter.into(),
                4usize => entity.radius = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait ISolidWithCurvedSlot: ISolidWithSlot {
    fn slot_centreline(&self) -> &EntityRef;
}
#[derive(Default, Debug)]
pub struct SolidWithCurvedSlot {
    name: Label,
    rationale: Text,
    base_solid: EntityRef,
    placing: EntityRef,
    depth: PositiveLengthMeasure,
    slot_width: PositiveLengthMeasure,
    closed_ends: Vec<Option<bool>>,
    end_exit_faces: Vec<HashSet<EntityRef>>,
    slot_centreline: EntityRef,
}
impl IRepresentationItem for SolidWithCurvedSlot {
    fn name(&self) -> &Label {
        &self.name
    }
}
impl IGeometricRepresentationItem for SolidWithCurvedSlot {}
impl ISolidModel for SolidWithCurvedSlot {}
impl IModifiedSolid for SolidWithCurvedSlot {
    fn rationale(&self) -> &Text {
        &self.rationale
    }
    fn base_solid(&self) -> &EntityRef {
        &self.base_solid
    }
}
impl IModifiedSolidWithPlacedConfiguration for SolidWithCurvedSlot {
    fn placing(&self) -> &EntityRef {
        &self.placing
    }
}
impl ISolidWithDepression for SolidWithCurvedSlot {
    fn depth(&self) -> &PositiveLengthMeasure {
        &self.depth
    }
}
impl ISolidWithSlot for SolidWithCurvedSlot {
    fn slot_width(&self) -> &PositiveLengthMeasure {
        &self.slot_width
    }
    fn closed_ends(&self) -> &Vec<Option<bool>> {
        &self.closed_ends
    }
    fn end_exit_faces(&self) -> &Vec<HashSet<EntityRef>> {
        &self.end_exit_faces
    }
}
impl ISolidWithCurvedSlot for SolidWithCurvedSlot {
    fn slot_centreline(&self) -> &EntityRef {
        &self.slot_centreline
    }
}
impl SolidWithCurvedSlot {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = SolidWithCurvedSlot::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => entity.rationale = parameter.into(),
                2usize => entity.base_solid = parameter.into(),
                3usize => entity.placing = parameter.into(),
                4usize => entity.depth = parameter.into(),
                5usize => entity.slot_width = parameter.into(),
                6usize => entity.closed_ends = parameter.into(),
                7usize => entity.end_exit_faces = parameter.into(),
                8usize => entity.slot_centreline = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait ISolidWithDepression: IModifiedSolidWithPlacedConfiguration {
    fn depth(&self) -> &PositiveLengthMeasure;
}
pub trait ISolidWithDoubleOffsetChamfer: ISolidWithChamferedEdges {
    fn left_offset_distance(&self) -> &PositiveLengthMeasure;
    fn right_offset_distance(&self) -> &PositiveLengthMeasure;
}
#[derive(Default, Debug)]
pub struct SolidWithDoubleOffsetChamfer {
    name: Label,
    rationale: Text,
    base_solid: EntityRef,
    blended_edges: Vec<EntityRef>,
    left_offset_distance: PositiveLengthMeasure,
    right_offset_distance: PositiveLengthMeasure,
}
impl IRepresentationItem for SolidWithDoubleOffsetChamfer {
    fn name(&self) -> &Label {
        &self.name
    }
}
impl IGeometricRepresentationItem for SolidWithDoubleOffsetChamfer {}
impl ISolidModel for SolidWithDoubleOffsetChamfer {}
impl IModifiedSolid for SolidWithDoubleOffsetChamfer {
    fn rationale(&self) -> &Text {
        &self.rationale
    }
    fn base_solid(&self) -> &EntityRef {
        &self.base_solid
    }
}
impl IEdgeBlendedSolid for SolidWithDoubleOffsetChamfer {
    fn blended_edges(&self) -> &Vec<EntityRef> {
        &self.blended_edges
    }
}
impl ISolidWithChamferedEdges for SolidWithDoubleOffsetChamfer {}
impl ISolidWithDoubleOffsetChamfer for SolidWithDoubleOffsetChamfer {
    fn left_offset_distance(&self) -> &PositiveLengthMeasure {
        &self.left_offset_distance
    }
    fn right_offset_distance(&self) -> &PositiveLengthMeasure {
        &self.right_offset_distance
    }
}
impl SolidWithDoubleOffsetChamfer {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = SolidWithDoubleOffsetChamfer::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => entity.rationale = parameter.into(),
                2usize => entity.base_solid = parameter.into(),
                3usize => entity.blended_edges = parameter.into(),
                4usize => entity.left_offset_distance = parameter.into(),
                5usize => entity.right_offset_distance = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait ISolidWithFlatBottomRoundHole: ISolidWithSteppedRoundHole {
    fn fillet_radius(&self) -> &NonNegativeLengthMeasure;
}
#[derive(Default, Debug)]
pub struct SolidWithFlatBottomRoundHole {
    name: Label,
    rationale: Text,
    base_solid: EntityRef,
    placing: EntityRef,
    depth: PositiveLengthMeasure,
    segments: PositiveInteger,
    segment_radii: Vec<PositiveLengthMeasure>,
    segment_depths: Vec<PositiveLengthMeasure>,
    fillet_radius: NonNegativeLengthMeasure,
}
impl IRepresentationItem for SolidWithFlatBottomRoundHole {
    fn name(&self) -> &Label {
        &self.name
    }
}
impl IGeometricRepresentationItem for SolidWithFlatBottomRoundHole {}
impl ISolidModel for SolidWithFlatBottomRoundHole {}
impl IModifiedSolid for SolidWithFlatBottomRoundHole {
    fn rationale(&self) -> &Text {
        &self.rationale
    }
    fn base_solid(&self) -> &EntityRef {
        &self.base_solid
    }
}
impl IModifiedSolidWithPlacedConfiguration for SolidWithFlatBottomRoundHole {
    fn placing(&self) -> &EntityRef {
        &self.placing
    }
}
impl ISolidWithDepression for SolidWithFlatBottomRoundHole {
    fn depth(&self) -> &PositiveLengthMeasure {
        &self.depth
    }
}
impl ISolidWithHole for SolidWithFlatBottomRoundHole {}
impl ISolidWithSteppedRoundHole for SolidWithFlatBottomRoundHole {
    fn segments(&self) -> &PositiveInteger {
        &self.segments
    }
    fn segment_radii(&self) -> &Vec<PositiveLengthMeasure> {
        &self.segment_radii
    }
    fn segment_depths(&self) -> &Vec<PositiveLengthMeasure> {
        &self.segment_depths
    }
}
impl ISolidWithFlatBottomRoundHole for SolidWithFlatBottomRoundHole {
    fn fillet_radius(&self) -> &NonNegativeLengthMeasure {
        &self.fillet_radius
    }
}
impl SolidWithFlatBottomRoundHole {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = SolidWithFlatBottomRoundHole::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => entity.rationale = parameter.into(),
                2usize => entity.base_solid = parameter.into(),
                3usize => entity.placing = parameter.into(),
                4usize => entity.depth = parameter.into(),
                5usize => entity.segments = parameter.into(),
                6usize => entity.segment_radii = parameter.into(),
                7usize => entity.segment_depths = parameter.into(),
                8usize => entity.fillet_radius = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait ISolidWithGeneralPocket: ISolidWithPocket {
    fn profile(&self) -> &EntityRef;
    fn reference_point(&self) -> &EntityRef;
}
#[derive(Default, Debug)]
pub struct SolidWithGeneralPocket {
    name: Label,
    rationale: Text,
    base_solid: EntityRef,
    placing: EntityRef,
    depth: PositiveLengthMeasure,
    floor_blend_radius: NonNegativeLengthMeasure,
    draft_angle: PlaneAngleMeasure,
    profile: EntityRef,
    reference_point: EntityRef,
}
impl IRepresentationItem for SolidWithGeneralPocket {
    fn name(&self) -> &Label {
        &self.name
    }
}
impl IGeometricRepresentationItem for SolidWithGeneralPocket {}
impl ISolidModel for SolidWithGeneralPocket {}
impl IModifiedSolid for SolidWithGeneralPocket {
    fn rationale(&self) -> &Text {
        &self.rationale
    }
    fn base_solid(&self) -> &EntityRef {
        &self.base_solid
    }
}
impl IModifiedSolidWithPlacedConfiguration for SolidWithGeneralPocket {
    fn placing(&self) -> &EntityRef {
        &self.placing
    }
}
impl ISolidWithDepression for SolidWithGeneralPocket {
    fn depth(&self) -> &PositiveLengthMeasure {
        &self.depth
    }
}
impl ISolidWithPocket for SolidWithGeneralPocket {
    fn floor_blend_radius(&self) -> &NonNegativeLengthMeasure {
        &self.floor_blend_radius
    }
    fn draft_angle(&self) -> &PlaneAngleMeasure {
        &self.draft_angle
    }
}
impl ISolidWithGeneralPocket for SolidWithGeneralPocket {
    fn profile(&self) -> &EntityRef {
        &self.profile
    }
    fn reference_point(&self) -> &EntityRef {
        &self.reference_point
    }
}
impl SolidWithGeneralPocket {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = SolidWithGeneralPocket::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => entity.rationale = parameter.into(),
                2usize => entity.base_solid = parameter.into(),
                3usize => entity.placing = parameter.into(),
                4usize => entity.depth = parameter.into(),
                5usize => entity.floor_blend_radius = parameter.into(),
                6usize => entity.draft_angle = parameter.into(),
                7usize => entity.profile = parameter.into(),
                8usize => entity.reference_point = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait ISolidWithGeneralProtrusion: ISolidWithProtrusion {
    fn profile(&self) -> &EntityRef;
    fn reference_point(&self) -> &EntityRef;
}
#[derive(Default, Debug)]
pub struct SolidWithGeneralProtrusion {
    name: Label,
    rationale: Text,
    base_solid: EntityRef,
    placing: EntityRef,
    protrusion_height: PositiveLengthMeasure,
    protrusion_draft_angle: PlaneAngleMeasure,
    profile: EntityRef,
    reference_point: EntityRef,
}
impl IRepresentationItem for SolidWithGeneralProtrusion {
    fn name(&self) -> &Label {
        &self.name
    }
}
impl IGeometricRepresentationItem for SolidWithGeneralProtrusion {}
impl ISolidModel for SolidWithGeneralProtrusion {}
impl IModifiedSolid for SolidWithGeneralProtrusion {
    fn rationale(&self) -> &Text {
        &self.rationale
    }
    fn base_solid(&self) -> &EntityRef {
        &self.base_solid
    }
}
impl IModifiedSolidWithPlacedConfiguration for SolidWithGeneralProtrusion {
    fn placing(&self) -> &EntityRef {
        &self.placing
    }
}
impl ISolidWithProtrusion for SolidWithGeneralProtrusion {
    fn protrusion_height(&self) -> &PositiveLengthMeasure {
        &self.protrusion_height
    }
    fn protrusion_draft_angle(&self) -> &PlaneAngleMeasure {
        &self.protrusion_draft_angle
    }
}
impl ISolidWithGeneralProtrusion for SolidWithGeneralProtrusion {
    fn profile(&self) -> &EntityRef {
        &self.profile
    }
    fn reference_point(&self) -> &EntityRef {
        &self.reference_point
    }
}
impl SolidWithGeneralProtrusion {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = SolidWithGeneralProtrusion::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => entity.rationale = parameter.into(),
                2usize => entity.base_solid = parameter.into(),
                3usize => entity.placing = parameter.into(),
                4usize => entity.protrusion_height = parameter.into(),
                5usize => entity.protrusion_draft_angle = parameter.into(),
                6usize => entity.profile = parameter.into(),
                7usize => entity.reference_point = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait ISolidWithGroove: ISolidWithDepression {
    fn groove_radius(&self) -> &PositiveLengthMeasure;
    fn groove_width(&self) -> &PositiveLengthMeasure;
    fn draft_angle(&self) -> &PlaneAngleMeasure;
    fn floor_fillet_radius(&self) -> &NonNegativeLengthMeasure;
    fn external_groove(&self) -> bool;
}
#[derive(Default, Debug)]
pub struct SolidWithGroove {
    name: Label,
    rationale: Text,
    base_solid: EntityRef,
    placing: EntityRef,
    depth: PositiveLengthMeasure,
    groove_radius: PositiveLengthMeasure,
    groove_width: PositiveLengthMeasure,
    draft_angle: PlaneAngleMeasure,
    floor_fillet_radius: NonNegativeLengthMeasure,
    external_groove: bool,
}
impl IRepresentationItem for SolidWithGroove {
    fn name(&self) -> &Label {
        &self.name
    }
}
impl IGeometricRepresentationItem for SolidWithGroove {}
impl ISolidModel for SolidWithGroove {}
impl IModifiedSolid for SolidWithGroove {
    fn rationale(&self) -> &Text {
        &self.rationale
    }
    fn base_solid(&self) -> &EntityRef {
        &self.base_solid
    }
}
impl IModifiedSolidWithPlacedConfiguration for SolidWithGroove {
    fn placing(&self) -> &EntityRef {
        &self.placing
    }
}
impl ISolidWithDepression for SolidWithGroove {
    fn depth(&self) -> &PositiveLengthMeasure {
        &self.depth
    }
}
impl ISolidWithGroove for SolidWithGroove {
    fn groove_radius(&self) -> &PositiveLengthMeasure {
        &self.groove_radius
    }
    fn groove_width(&self) -> &PositiveLengthMeasure {
        &self.groove_width
    }
    fn draft_angle(&self) -> &PlaneAngleMeasure {
        &self.draft_angle
    }
    fn floor_fillet_radius(&self) -> &NonNegativeLengthMeasure {
        &self.floor_fillet_radius
    }
    fn external_groove(&self) -> bool {
        self.external_groove
    }
}
impl SolidWithGroove {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = SolidWithGroove::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => entity.rationale = parameter.into(),
                2usize => entity.base_solid = parameter.into(),
                3usize => entity.placing = parameter.into(),
                4usize => entity.depth = parameter.into(),
                5usize => entity.groove_radius = parameter.into(),
                6usize => entity.groove_width = parameter.into(),
                7usize => entity.draft_angle = parameter.into(),
                8usize => entity.floor_fillet_radius = parameter.into(),
                9usize => entity.external_groove = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait ISolidWithHole: ISolidWithDepression {}
pub trait ISolidWithIncompleteCircularPattern: ISolidWithCircularPattern {
    fn omitted_instances(&self) -> &HashSet<PositiveInteger>;
}
#[derive(Default, Debug)]
pub struct SolidWithIncompleteCircularPattern {
    name: Label,
    rationale: Text,
    base_solid: EntityRef,
    placing: EntityRef,
    replicated_element: EntityRef,
    replicate_count: PositiveInteger,
    angular_spacing: PlaneAngleMeasure,
    radial_alignment: bool,
    reference_point: EntityRef,
    omitted_instances: HashSet<PositiveInteger>,
}
impl IRepresentationItem for SolidWithIncompleteCircularPattern {
    fn name(&self) -> &Label {
        &self.name
    }
}
impl IGeometricRepresentationItem for SolidWithIncompleteCircularPattern {}
impl ISolidModel for SolidWithIncompleteCircularPattern {}
impl IModifiedSolid for SolidWithIncompleteCircularPattern {
    fn rationale(&self) -> &Text {
        &self.rationale
    }
    fn base_solid(&self) -> &EntityRef {
        &self.base_solid
    }
}
impl IModifiedSolidWithPlacedConfiguration for SolidWithIncompleteCircularPattern {
    fn placing(&self) -> &EntityRef {
        &self.placing
    }
}
impl ISolidWithShapeElementPattern for SolidWithIncompleteCircularPattern {
    fn replicated_element(&self) -> &EntityRef {
        &self.replicated_element
    }
}
impl ISolidWithCircularPattern for SolidWithIncompleteCircularPattern {
    fn replicate_count(&self) -> &PositiveInteger {
        &self.replicate_count
    }
    fn angular_spacing(&self) -> &PlaneAngleMeasure {
        &self.angular_spacing
    }
    fn radial_alignment(&self) -> bool {
        self.radial_alignment
    }
    fn reference_point(&self) -> &EntityRef {
        &self.reference_point
    }
}
impl ISolidWithIncompleteCircularPattern for SolidWithIncompleteCircularPattern {
    fn omitted_instances(&self) -> &HashSet<PositiveInteger> {
        &self.omitted_instances
    }
}
impl SolidWithIncompleteCircularPattern {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = SolidWithIncompleteCircularPattern::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => entity.rationale = parameter.into(),
                2usize => entity.base_solid = parameter.into(),
                3usize => entity.placing = parameter.into(),
                4usize => entity.replicated_element = parameter.into(),
                5usize => entity.replicate_count = parameter.into(),
                6usize => entity.angular_spacing = parameter.into(),
                7usize => entity.radial_alignment = parameter.into(),
                8usize => entity.reference_point = parameter.into(),
                9usize => entity.omitted_instances = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait ISolidWithIncompleteRectangularPattern: ISolidWithRectangularPattern {
    fn omitted_instances(&self) -> &HashSet<Vec<PositiveInteger>>;
}
#[derive(Default, Debug)]
pub struct SolidWithIncompleteRectangularPattern {
    name: Label,
    rationale: Text,
    base_solid: EntityRef,
    placing: EntityRef,
    replicated_element: EntityRef,
    row_count: PositiveInteger,
    column_count: PositiveInteger,
    row_spacing: LengthMeasure,
    column_spacing: LengthMeasure,
    omitted_instances: HashSet<Vec<PositiveInteger>>,
}
impl IRepresentationItem for SolidWithIncompleteRectangularPattern {
    fn name(&self) -> &Label {
        &self.name
    }
}
impl IGeometricRepresentationItem for SolidWithIncompleteRectangularPattern {}
impl ISolidModel for SolidWithIncompleteRectangularPattern {}
impl IModifiedSolid for SolidWithIncompleteRectangularPattern {
    fn rationale(&self) -> &Text {
        &self.rationale
    }
    fn base_solid(&self) -> &EntityRef {
        &self.base_solid
    }
}
impl IModifiedSolidWithPlacedConfiguration for SolidWithIncompleteRectangularPattern {
    fn placing(&self) -> &EntityRef {
        &self.placing
    }
}
impl ISolidWithShapeElementPattern for SolidWithIncompleteRectangularPattern {
    fn replicated_element(&self) -> &EntityRef {
        &self.replicated_element
    }
}
impl ISolidWithRectangularPattern for SolidWithIncompleteRectangularPattern {
    fn row_count(&self) -> &PositiveInteger {
        &self.row_count
    }
    fn column_count(&self) -> &PositiveInteger {
        &self.column_count
    }
    fn row_spacing(&self) -> &LengthMeasure {
        &self.row_spacing
    }
    fn column_spacing(&self) -> &LengthMeasure {
        &self.column_spacing
    }
}
impl ISolidWithIncompleteRectangularPattern for SolidWithIncompleteRectangularPattern {
    fn omitted_instances(&self) -> &HashSet<Vec<PositiveInteger>> {
        &self.omitted_instances
    }
}
impl SolidWithIncompleteRectangularPattern {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = SolidWithIncompleteRectangularPattern::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => entity.rationale = parameter.into(),
                2usize => entity.base_solid = parameter.into(),
                3usize => entity.placing = parameter.into(),
                4usize => entity.replicated_element = parameter.into(),
                5usize => entity.row_count = parameter.into(),
                6usize => entity.column_count = parameter.into(),
                7usize => entity.row_spacing = parameter.into(),
                8usize => entity.column_spacing = parameter.into(),
                9usize => entity.omitted_instances = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait ISolidWithPocket: ISolidWithDepression {
    fn floor_blend_radius(&self) -> &NonNegativeLengthMeasure;
    fn draft_angle(&self) -> &PlaneAngleMeasure;
}
pub trait ISolidWithProtrusion: IModifiedSolidWithPlacedConfiguration {
    fn protrusion_height(&self) -> &PositiveLengthMeasure;
    fn protrusion_draft_angle(&self) -> &PlaneAngleMeasure;
}
pub trait ISolidWithRectangularPattern: ISolidWithShapeElementPattern {
    fn row_count(&self) -> &PositiveInteger;
    fn column_count(&self) -> &PositiveInteger;
    fn row_spacing(&self) -> &LengthMeasure;
    fn column_spacing(&self) -> &LengthMeasure;
}
#[derive(Default, Debug)]
pub struct SolidWithRectangularPattern {
    name: Label,
    rationale: Text,
    base_solid: EntityRef,
    placing: EntityRef,
    replicated_element: EntityRef,
    row_count: PositiveInteger,
    column_count: PositiveInteger,
    row_spacing: LengthMeasure,
    column_spacing: LengthMeasure,
}
impl IRepresentationItem for SolidWithRectangularPattern {
    fn name(&self) -> &Label {
        &self.name
    }
}
impl IGeometricRepresentationItem for SolidWithRectangularPattern {}
impl ISolidModel for SolidWithRectangularPattern {}
impl IModifiedSolid for SolidWithRectangularPattern {
    fn rationale(&self) -> &Text {
        &self.rationale
    }
    fn base_solid(&self) -> &EntityRef {
        &self.base_solid
    }
}
impl IModifiedSolidWithPlacedConfiguration for SolidWithRectangularPattern {
    fn placing(&self) -> &EntityRef {
        &self.placing
    }
}
impl ISolidWithShapeElementPattern for SolidWithRectangularPattern {
    fn replicated_element(&self) -> &EntityRef {
        &self.replicated_element
    }
}
impl ISolidWithRectangularPattern for SolidWithRectangularPattern {
    fn row_count(&self) -> &PositiveInteger {
        &self.row_count
    }
    fn column_count(&self) -> &PositiveInteger {
        &self.column_count
    }
    fn row_spacing(&self) -> &LengthMeasure {
        &self.row_spacing
    }
    fn column_spacing(&self) -> &LengthMeasure {
        &self.column_spacing
    }
}
impl SolidWithRectangularPattern {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = SolidWithRectangularPattern::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => entity.rationale = parameter.into(),
                2usize => entity.base_solid = parameter.into(),
                3usize => entity.placing = parameter.into(),
                4usize => entity.replicated_element = parameter.into(),
                5usize => entity.row_count = parameter.into(),
                6usize => entity.column_count = parameter.into(),
                7usize => entity.row_spacing = parameter.into(),
                8usize => entity.column_spacing = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait ISolidWithRectangularPocket: ISolidWithPocket {
    fn pocket_length(&self) -> &PositiveLengthMeasure;
    fn pocket_width(&self) -> &PositiveLengthMeasure;
    fn corner_radius(&self) -> &NonNegativeLengthMeasure;
}
#[derive(Default, Debug)]
pub struct SolidWithRectangularPocket {
    name: Label,
    rationale: Text,
    base_solid: EntityRef,
    placing: EntityRef,
    depth: PositiveLengthMeasure,
    floor_blend_radius: NonNegativeLengthMeasure,
    draft_angle: PlaneAngleMeasure,
    pocket_length: PositiveLengthMeasure,
    pocket_width: PositiveLengthMeasure,
    corner_radius: NonNegativeLengthMeasure,
}
impl IRepresentationItem for SolidWithRectangularPocket {
    fn name(&self) -> &Label {
        &self.name
    }
}
impl IGeometricRepresentationItem for SolidWithRectangularPocket {}
impl ISolidModel for SolidWithRectangularPocket {}
impl IModifiedSolid for SolidWithRectangularPocket {
    fn rationale(&self) -> &Text {
        &self.rationale
    }
    fn base_solid(&self) -> &EntityRef {
        &self.base_solid
    }
}
impl IModifiedSolidWithPlacedConfiguration for SolidWithRectangularPocket {
    fn placing(&self) -> &EntityRef {
        &self.placing
    }
}
impl ISolidWithDepression for SolidWithRectangularPocket {
    fn depth(&self) -> &PositiveLengthMeasure {
        &self.depth
    }
}
impl ISolidWithPocket for SolidWithRectangularPocket {
    fn floor_blend_radius(&self) -> &NonNegativeLengthMeasure {
        &self.floor_blend_radius
    }
    fn draft_angle(&self) -> &PlaneAngleMeasure {
        &self.draft_angle
    }
}
impl ISolidWithRectangularPocket for SolidWithRectangularPocket {
    fn pocket_length(&self) -> &PositiveLengthMeasure {
        &self.pocket_length
    }
    fn pocket_width(&self) -> &PositiveLengthMeasure {
        &self.pocket_width
    }
    fn corner_radius(&self) -> &NonNegativeLengthMeasure {
        &self.corner_radius
    }
}
impl SolidWithRectangularPocket {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = SolidWithRectangularPocket::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => entity.rationale = parameter.into(),
                2usize => entity.base_solid = parameter.into(),
                3usize => entity.placing = parameter.into(),
                4usize => entity.depth = parameter.into(),
                5usize => entity.floor_blend_radius = parameter.into(),
                6usize => entity.draft_angle = parameter.into(),
                7usize => entity.pocket_length = parameter.into(),
                8usize => entity.pocket_width = parameter.into(),
                9usize => entity.corner_radius = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait ISolidWithRectangularProtrusion: ISolidWithProtrusion {
    fn protrusion_length(&self) -> &PositiveLengthMeasure;
    fn protrusion_width(&self) -> &PositiveLengthMeasure;
    fn protrusion_corner_radius(&self) -> &NonNegativeLengthMeasure;
}
#[derive(Default, Debug)]
pub struct SolidWithRectangularProtrusion {
    name: Label,
    rationale: Text,
    base_solid: EntityRef,
    placing: EntityRef,
    protrusion_height: PositiveLengthMeasure,
    protrusion_draft_angle: PlaneAngleMeasure,
    protrusion_length: PositiveLengthMeasure,
    protrusion_width: PositiveLengthMeasure,
    protrusion_corner_radius: NonNegativeLengthMeasure,
}
impl IRepresentationItem for SolidWithRectangularProtrusion {
    fn name(&self) -> &Label {
        &self.name
    }
}
impl IGeometricRepresentationItem for SolidWithRectangularProtrusion {}
impl ISolidModel for SolidWithRectangularProtrusion {}
impl IModifiedSolid for SolidWithRectangularProtrusion {
    fn rationale(&self) -> &Text {
        &self.rationale
    }
    fn base_solid(&self) -> &EntityRef {
        &self.base_solid
    }
}
impl IModifiedSolidWithPlacedConfiguration for SolidWithRectangularProtrusion {
    fn placing(&self) -> &EntityRef {
        &self.placing
    }
}
impl ISolidWithProtrusion for SolidWithRectangularProtrusion {
    fn protrusion_height(&self) -> &PositiveLengthMeasure {
        &self.protrusion_height
    }
    fn protrusion_draft_angle(&self) -> &PlaneAngleMeasure {
        &self.protrusion_draft_angle
    }
}
impl ISolidWithRectangularProtrusion for SolidWithRectangularProtrusion {
    fn protrusion_length(&self) -> &PositiveLengthMeasure {
        &self.protrusion_length
    }
    fn protrusion_width(&self) -> &PositiveLengthMeasure {
        &self.protrusion_width
    }
    fn protrusion_corner_radius(&self) -> &NonNegativeLengthMeasure {
        &self.protrusion_corner_radius
    }
}
impl SolidWithRectangularProtrusion {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = SolidWithRectangularProtrusion::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => entity.rationale = parameter.into(),
                2usize => entity.base_solid = parameter.into(),
                3usize => entity.placing = parameter.into(),
                4usize => entity.protrusion_height = parameter.into(),
                5usize => entity.protrusion_draft_angle = parameter.into(),
                6usize => entity.protrusion_length = parameter.into(),
                7usize => entity.protrusion_width = parameter.into(),
                8usize => entity.protrusion_corner_radius = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait ISolidWithShapeElementPattern: IModifiedSolidWithPlacedConfiguration {
    fn replicated_element(&self) -> &EntityRef;
}
pub trait ISolidWithSingleOffsetChamfer: ISolidWithChamferedEdges {
    fn offset_distance(&self) -> &PositiveLengthMeasure;
}
#[derive(Default, Debug)]
pub struct SolidWithSingleOffsetChamfer {
    name: Label,
    rationale: Text,
    base_solid: EntityRef,
    blended_edges: Vec<EntityRef>,
    offset_distance: PositiveLengthMeasure,
}
impl IRepresentationItem for SolidWithSingleOffsetChamfer {
    fn name(&self) -> &Label {
        &self.name
    }
}
impl IGeometricRepresentationItem for SolidWithSingleOffsetChamfer {}
impl ISolidModel for SolidWithSingleOffsetChamfer {}
impl IModifiedSolid for SolidWithSingleOffsetChamfer {
    fn rationale(&self) -> &Text {
        &self.rationale
    }
    fn base_solid(&self) -> &EntityRef {
        &self.base_solid
    }
}
impl IEdgeBlendedSolid for SolidWithSingleOffsetChamfer {
    fn blended_edges(&self) -> &Vec<EntityRef> {
        &self.blended_edges
    }
}
impl ISolidWithChamferedEdges for SolidWithSingleOffsetChamfer {}
impl ISolidWithSingleOffsetChamfer for SolidWithSingleOffsetChamfer {
    fn offset_distance(&self) -> &PositiveLengthMeasure {
        &self.offset_distance
    }
}
impl SolidWithSingleOffsetChamfer {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = SolidWithSingleOffsetChamfer::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => entity.rationale = parameter.into(),
                2usize => entity.base_solid = parameter.into(),
                3usize => entity.blended_edges = parameter.into(),
                4usize => entity.offset_distance = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait ISolidWithSlot: ISolidWithDepression {
    fn slot_width(&self) -> &PositiveLengthMeasure;
    fn closed_ends(&self) -> &Vec<Option<bool>>;
    fn end_exit_faces(&self) -> &Vec<HashSet<EntityRef>>;
}
pub trait ISolidWithSphericalBottomRoundHole: ISolidWithSteppedRoundHole {
    fn sphere_radius(&self) -> &PositiveLengthMeasure;
}
#[derive(Default, Debug)]
pub struct SolidWithSphericalBottomRoundHole {
    name: Label,
    rationale: Text,
    base_solid: EntityRef,
    placing: EntityRef,
    depth: PositiveLengthMeasure,
    segments: PositiveInteger,
    segment_radii: Vec<PositiveLengthMeasure>,
    segment_depths: Vec<PositiveLengthMeasure>,
    sphere_radius: PositiveLengthMeasure,
}
impl IRepresentationItem for SolidWithSphericalBottomRoundHole {
    fn name(&self) -> &Label {
        &self.name
    }
}
impl IGeometricRepresentationItem for SolidWithSphericalBottomRoundHole {}
impl ISolidModel for SolidWithSphericalBottomRoundHole {}
impl IModifiedSolid for SolidWithSphericalBottomRoundHole {
    fn rationale(&self) -> &Text {
        &self.rationale
    }
    fn base_solid(&self) -> &EntityRef {
        &self.base_solid
    }
}
impl IModifiedSolidWithPlacedConfiguration for SolidWithSphericalBottomRoundHole {
    fn placing(&self) -> &EntityRef {
        &self.placing
    }
}
impl ISolidWithDepression for SolidWithSphericalBottomRoundHole {
    fn depth(&self) -> &PositiveLengthMeasure {
        &self.depth
    }
}
impl ISolidWithHole for SolidWithSphericalBottomRoundHole {}
impl ISolidWithSteppedRoundHole for SolidWithSphericalBottomRoundHole {
    fn segments(&self) -> &PositiveInteger {
        &self.segments
    }
    fn segment_radii(&self) -> &Vec<PositiveLengthMeasure> {
        &self.segment_radii
    }
    fn segment_depths(&self) -> &Vec<PositiveLengthMeasure> {
        &self.segment_depths
    }
}
impl ISolidWithSphericalBottomRoundHole for SolidWithSphericalBottomRoundHole {
    fn sphere_radius(&self) -> &PositiveLengthMeasure {
        &self.sphere_radius
    }
}
impl SolidWithSphericalBottomRoundHole {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = SolidWithSphericalBottomRoundHole::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => entity.rationale = parameter.into(),
                2usize => entity.base_solid = parameter.into(),
                3usize => entity.placing = parameter.into(),
                4usize => entity.depth = parameter.into(),
                5usize => entity.segments = parameter.into(),
                6usize => entity.segment_radii = parameter.into(),
                7usize => entity.segment_depths = parameter.into(),
                8usize => entity.sphere_radius = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait ISolidWithSteppedRoundHole: ISolidWithHole {
    fn segments(&self) -> &PositiveInteger;
    fn segment_radii(&self) -> &Vec<PositiveLengthMeasure>;
    fn segment_depths(&self) -> &Vec<PositiveLengthMeasure>;
}
#[derive(Default, Debug)]
pub struct SolidWithSteppedRoundHole {
    name: Label,
    rationale: Text,
    base_solid: EntityRef,
    placing: EntityRef,
    depth: PositiveLengthMeasure,
    segments: PositiveInteger,
    segment_radii: Vec<PositiveLengthMeasure>,
    segment_depths: Vec<PositiveLengthMeasure>,
}
impl IRepresentationItem for SolidWithSteppedRoundHole {
    fn name(&self) -> &Label {
        &self.name
    }
}
impl IGeometricRepresentationItem for SolidWithSteppedRoundHole {}
impl ISolidModel for SolidWithSteppedRoundHole {}
impl IModifiedSolid for SolidWithSteppedRoundHole {
    fn rationale(&self) -> &Text {
        &self.rationale
    }
    fn base_solid(&self) -> &EntityRef {
        &self.base_solid
    }
}
impl IModifiedSolidWithPlacedConfiguration for SolidWithSteppedRoundHole {
    fn placing(&self) -> &EntityRef {
        &self.placing
    }
}
impl ISolidWithDepression for SolidWithSteppedRoundHole {
    fn depth(&self) -> &PositiveLengthMeasure {
        &self.depth
    }
}
impl ISolidWithHole for SolidWithSteppedRoundHole {}
impl ISolidWithSteppedRoundHole for SolidWithSteppedRoundHole {
    fn segments(&self) -> &PositiveInteger {
        &self.segments
    }
    fn segment_radii(&self) -> &Vec<PositiveLengthMeasure> {
        &self.segment_radii
    }
    fn segment_depths(&self) -> &Vec<PositiveLengthMeasure> {
        &self.segment_depths
    }
}
impl SolidWithSteppedRoundHole {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = SolidWithSteppedRoundHole::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => entity.rationale = parameter.into(),
                2usize => entity.base_solid = parameter.into(),
                3usize => entity.placing = parameter.into(),
                4usize => entity.depth = parameter.into(),
                5usize => entity.segments = parameter.into(),
                6usize => entity.segment_radii = parameter.into(),
                7usize => entity.segment_depths = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait ISolidWithSteppedRoundHoleAndConicalTransitions: ISolidWithSteppedRoundHole {
    fn conical_transitions(&self) -> &HashSet<EntityRef>;
}
#[derive(Default, Debug)]
pub struct SolidWithSteppedRoundHoleAndConicalTransitions {
    name: Label,
    rationale: Text,
    base_solid: EntityRef,
    placing: EntityRef,
    depth: PositiveLengthMeasure,
    segments: PositiveInteger,
    segment_radii: Vec<PositiveLengthMeasure>,
    segment_depths: Vec<PositiveLengthMeasure>,
    conical_transitions: HashSet<EntityRef>,
}
impl IRepresentationItem for SolidWithSteppedRoundHoleAndConicalTransitions {
    fn name(&self) -> &Label {
        &self.name
    }
}
impl IGeometricRepresentationItem for SolidWithSteppedRoundHoleAndConicalTransitions {}
impl ISolidModel for SolidWithSteppedRoundHoleAndConicalTransitions {}
impl IModifiedSolid for SolidWithSteppedRoundHoleAndConicalTransitions {
    fn rationale(&self) -> &Text {
        &self.rationale
    }
    fn base_solid(&self) -> &EntityRef {
        &self.base_solid
    }
}
impl IModifiedSolidWithPlacedConfiguration for SolidWithSteppedRoundHoleAndConicalTransitions {
    fn placing(&self) -> &EntityRef {
        &self.placing
    }
}
impl ISolidWithDepression for SolidWithSteppedRoundHoleAndConicalTransitions {
    fn depth(&self) -> &PositiveLengthMeasure {
        &self.depth
    }
}
impl ISolidWithHole for SolidWithSteppedRoundHoleAndConicalTransitions {}
impl ISolidWithSteppedRoundHole for SolidWithSteppedRoundHoleAndConicalTransitions {
    fn segments(&self) -> &PositiveInteger {
        &self.segments
    }
    fn segment_radii(&self) -> &Vec<PositiveLengthMeasure> {
        &self.segment_radii
    }
    fn segment_depths(&self) -> &Vec<PositiveLengthMeasure> {
        &self.segment_depths
    }
}
impl ISolidWithSteppedRoundHoleAndConicalTransitions for SolidWithSteppedRoundHoleAndConicalTransitions {
    fn conical_transitions(&self) -> &HashSet<EntityRef> {
        &self.conical_transitions
    }
}
impl SolidWithSteppedRoundHoleAndConicalTransitions {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = SolidWithSteppedRoundHoleAndConicalTransitions::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => entity.rationale = parameter.into(),
                2usize => entity.base_solid = parameter.into(),
                3usize => entity.placing = parameter.into(),
                4usize => entity.depth = parameter.into(),
                5usize => entity.segments = parameter.into(),
                6usize => entity.segment_radii = parameter.into(),
                7usize => entity.segment_depths = parameter.into(),
                8usize => entity.conical_transitions = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait ISolidWithStraightSlot: ISolidWithSlot {
    fn slot_length(&self) -> &PositiveLengthMeasure;
}
#[derive(Default, Debug)]
pub struct SolidWithStraightSlot {
    name: Label,
    rationale: Text,
    base_solid: EntityRef,
    placing: EntityRef,
    depth: PositiveLengthMeasure,
    slot_width: PositiveLengthMeasure,
    closed_ends: Vec<Option<bool>>,
    end_exit_faces: Vec<HashSet<EntityRef>>,
    slot_length: PositiveLengthMeasure,
}
impl IRepresentationItem for SolidWithStraightSlot {
    fn name(&self) -> &Label {
        &self.name
    }
}
impl IGeometricRepresentationItem for SolidWithStraightSlot {}
impl ISolidModel for SolidWithStraightSlot {}
impl IModifiedSolid for SolidWithStraightSlot {
    fn rationale(&self) -> &Text {
        &self.rationale
    }
    fn base_solid(&self) -> &EntityRef {
        &self.base_solid
    }
}
impl IModifiedSolidWithPlacedConfiguration for SolidWithStraightSlot {
    fn placing(&self) -> &EntityRef {
        &self.placing
    }
}
impl ISolidWithDepression for SolidWithStraightSlot {
    fn depth(&self) -> &PositiveLengthMeasure {
        &self.depth
    }
}
impl ISolidWithSlot for SolidWithStraightSlot {
    fn slot_width(&self) -> &PositiveLengthMeasure {
        &self.slot_width
    }
    fn closed_ends(&self) -> &Vec<Option<bool>> {
        &self.closed_ends
    }
    fn end_exit_faces(&self) -> &Vec<HashSet<EntityRef>> {
        &self.end_exit_faces
    }
}
impl ISolidWithStraightSlot for SolidWithStraightSlot {
    fn slot_length(&self) -> &PositiveLengthMeasure {
        &self.slot_length
    }
}
impl SolidWithStraightSlot {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = SolidWithStraightSlot::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => entity.rationale = parameter.into(),
                2usize => entity.base_solid = parameter.into(),
                3usize => entity.placing = parameter.into(),
                4usize => entity.depth = parameter.into(),
                5usize => entity.slot_width = parameter.into(),
                6usize => entity.closed_ends = parameter.into(),
                7usize => entity.end_exit_faces = parameter.into(),
                8usize => entity.slot_length = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait ISolidWithTeeSectionSlot: ISolidWithSlot {
    fn tee_section_width(&self) -> &PositiveLengthMeasure;
    fn collar_depth(&self) -> &PositiveLengthMeasure;
}
#[derive(Default, Debug)]
pub struct SolidWithTeeSectionSlot {
    name: Label,
    rationale: Text,
    base_solid: EntityRef,
    placing: EntityRef,
    depth: PositiveLengthMeasure,
    slot_width: PositiveLengthMeasure,
    closed_ends: Vec<Option<bool>>,
    end_exit_faces: Vec<HashSet<EntityRef>>,
    tee_section_width: PositiveLengthMeasure,
    collar_depth: PositiveLengthMeasure,
}
impl IRepresentationItem for SolidWithTeeSectionSlot {
    fn name(&self) -> &Label {
        &self.name
    }
}
impl IGeometricRepresentationItem for SolidWithTeeSectionSlot {}
impl ISolidModel for SolidWithTeeSectionSlot {}
impl IModifiedSolid for SolidWithTeeSectionSlot {
    fn rationale(&self) -> &Text {
        &self.rationale
    }
    fn base_solid(&self) -> &EntityRef {
        &self.base_solid
    }
}
impl IModifiedSolidWithPlacedConfiguration for SolidWithTeeSectionSlot {
    fn placing(&self) -> &EntityRef {
        &self.placing
    }
}
impl ISolidWithDepression for SolidWithTeeSectionSlot {
    fn depth(&self) -> &PositiveLengthMeasure {
        &self.depth
    }
}
impl ISolidWithSlot for SolidWithTeeSectionSlot {
    fn slot_width(&self) -> &PositiveLengthMeasure {
        &self.slot_width
    }
    fn closed_ends(&self) -> &Vec<Option<bool>> {
        &self.closed_ends
    }
    fn end_exit_faces(&self) -> &Vec<HashSet<EntityRef>> {
        &self.end_exit_faces
    }
}
impl ISolidWithTeeSectionSlot for SolidWithTeeSectionSlot {
    fn tee_section_width(&self) -> &PositiveLengthMeasure {
        &self.tee_section_width
    }
    fn collar_depth(&self) -> &PositiveLengthMeasure {
        &self.collar_depth
    }
}
impl SolidWithTeeSectionSlot {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = SolidWithTeeSectionSlot::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => entity.rationale = parameter.into(),
                2usize => entity.base_solid = parameter.into(),
                3usize => entity.placing = parameter.into(),
                4usize => entity.depth = parameter.into(),
                5usize => entity.slot_width = parameter.into(),
                6usize => entity.closed_ends = parameter.into(),
                7usize => entity.end_exit_faces = parameter.into(),
                8usize => entity.tee_section_width = parameter.into(),
                9usize => entity.collar_depth = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait ISolidWithThroughDepression: ISolidWithDepression {
    fn exit_faces(&self) -> &HashSet<EntityRef>;
}
#[derive(Default, Debug)]
pub struct SolidWithThroughDepression {
    name: Label,
    rationale: Text,
    base_solid: EntityRef,
    placing: EntityRef,
    depth: PositiveLengthMeasure,
    exit_faces: HashSet<EntityRef>,
}
impl IRepresentationItem for SolidWithThroughDepression {
    fn name(&self) -> &Label {
        &self.name
    }
}
impl IGeometricRepresentationItem for SolidWithThroughDepression {}
impl ISolidModel for SolidWithThroughDepression {}
impl IModifiedSolid for SolidWithThroughDepression {
    fn rationale(&self) -> &Text {
        &self.rationale
    }
    fn base_solid(&self) -> &EntityRef {
        &self.base_solid
    }
}
impl IModifiedSolidWithPlacedConfiguration for SolidWithThroughDepression {
    fn placing(&self) -> &EntityRef {
        &self.placing
    }
}
impl ISolidWithDepression for SolidWithThroughDepression {
    fn depth(&self) -> &PositiveLengthMeasure {
        &self.depth
    }
}
impl ISolidWithThroughDepression for SolidWithThroughDepression {
    fn exit_faces(&self) -> &HashSet<EntityRef> {
        &self.exit_faces
    }
}
impl SolidWithThroughDepression {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = SolidWithThroughDepression::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => entity.rationale = parameter.into(),
                2usize => entity.base_solid = parameter.into(),
                3usize => entity.placing = parameter.into(),
                4usize => entity.depth = parameter.into(),
                5usize => entity.exit_faces = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait ISolidWithTrapezoidalSectionSlot: ISolidWithSlot {
    fn draft_angle(&self) -> &PlaneAngleMeasure;
    fn floor_fillet_radius(&self) -> &NonNegativeLengthMeasure;
}
#[derive(Default, Debug)]
pub struct SolidWithTrapezoidalSectionSlot {
    name: Label,
    rationale: Text,
    base_solid: EntityRef,
    placing: EntityRef,
    depth: PositiveLengthMeasure,
    slot_width: PositiveLengthMeasure,
    closed_ends: Vec<Option<bool>>,
    end_exit_faces: Vec<HashSet<EntityRef>>,
    draft_angle: PlaneAngleMeasure,
    floor_fillet_radius: NonNegativeLengthMeasure,
}
impl IRepresentationItem for SolidWithTrapezoidalSectionSlot {
    fn name(&self) -> &Label {
        &self.name
    }
}
impl IGeometricRepresentationItem for SolidWithTrapezoidalSectionSlot {}
impl ISolidModel for SolidWithTrapezoidalSectionSlot {}
impl IModifiedSolid for SolidWithTrapezoidalSectionSlot {
    fn rationale(&self) -> &Text {
        &self.rationale
    }
    fn base_solid(&self) -> &EntityRef {
        &self.base_solid
    }
}
impl IModifiedSolidWithPlacedConfiguration for SolidWithTrapezoidalSectionSlot {
    fn placing(&self) -> &EntityRef {
        &self.placing
    }
}
impl ISolidWithDepression for SolidWithTrapezoidalSectionSlot {
    fn depth(&self) -> &PositiveLengthMeasure {
        &self.depth
    }
}
impl ISolidWithSlot for SolidWithTrapezoidalSectionSlot {
    fn slot_width(&self) -> &PositiveLengthMeasure {
        &self.slot_width
    }
    fn closed_ends(&self) -> &Vec<Option<bool>> {
        &self.closed_ends
    }
    fn end_exit_faces(&self) -> &Vec<HashSet<EntityRef>> {
        &self.end_exit_faces
    }
}
impl ISolidWithTrapezoidalSectionSlot for SolidWithTrapezoidalSectionSlot {
    fn draft_angle(&self) -> &PlaneAngleMeasure {
        &self.draft_angle
    }
    fn floor_fillet_radius(&self) -> &NonNegativeLengthMeasure {
        &self.floor_fillet_radius
    }
}
impl SolidWithTrapezoidalSectionSlot {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = SolidWithTrapezoidalSectionSlot::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => entity.rationale = parameter.into(),
                2usize => entity.base_solid = parameter.into(),
                3usize => entity.placing = parameter.into(),
                4usize => entity.depth = parameter.into(),
                5usize => entity.slot_width = parameter.into(),
                6usize => entity.closed_ends = parameter.into(),
                7usize => entity.end_exit_faces = parameter.into(),
                8usize => entity.draft_angle = parameter.into(),
                9usize => entity.floor_fillet_radius = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait ISolidWithVariableRadiusEdgeBlend: IEdgeBlendedSolid + ITrackBlendedSolid {
    fn point_list(&self) -> &Vec<EntityRef>;
    fn radius_list(&self) -> &Vec<PositiveLengthMeasure>;
    fn edge_function_list(&self) -> &Vec<BlendRadiusVariationType>;
}
#[derive(Default, Debug)]
pub struct SolidWithVariableRadiusEdgeBlend {
    name: Label,
    rationale: Text,
    base_solid: EntityRef,
    blended_edges: Vec<EntityRef>,
    point_list: Vec<EntityRef>,
    radius_list: Vec<PositiveLengthMeasure>,
    edge_function_list: Vec<BlendRadiusVariationType>,
}
impl IRepresentationItem for SolidWithVariableRadiusEdgeBlend {
    fn name(&self) -> &Label {
        &self.name
    }
}
impl IGeometricRepresentationItem for SolidWithVariableRadiusEdgeBlend {}
impl ISolidModel for SolidWithVariableRadiusEdgeBlend {}
impl IModifiedSolid for SolidWithVariableRadiusEdgeBlend {
    fn rationale(&self) -> &Text {
        &self.rationale
    }
    fn base_solid(&self) -> &EntityRef {
        &self.base_solid
    }
}
impl IEdgeBlendedSolid for SolidWithVariableRadiusEdgeBlend {
    fn blended_edges(&self) -> &Vec<EntityRef> {
        &self.blended_edges
    }
}
impl ISolidWithVariableRadiusEdgeBlend for SolidWithVariableRadiusEdgeBlend {
    fn point_list(&self) -> &Vec<EntityRef> {
        &self.point_list
    }
    fn radius_list(&self) -> &Vec<PositiveLengthMeasure> {
        &self.radius_list
    }
    fn edge_function_list(&self) -> &Vec<BlendRadiusVariationType> {
        &self.edge_function_list
    }
}
impl ITrackBlendedSolid for SolidWithVariableRadiusEdgeBlend {}
impl SolidWithVariableRadiusEdgeBlend {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = SolidWithVariableRadiusEdgeBlend::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => entity.rationale = parameter.into(),
                2usize => entity.base_solid = parameter.into(),
                3usize => entity.blended_edges = parameter.into(),
                4usize => entity.point_list = parameter.into(),
                5usize => entity.radius_list = parameter.into(),
                6usize => entity.edge_function_list = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait ISourceForRequirement: IGroupAssignment {
    fn items(&self) -> &HashSet<EntityRef>;
    fn assigned_group(&self) -> &EntityRef;
}
#[derive(Default, Debug)]
pub struct SourceForRequirement {
    items: HashSet<EntityRef>,
    assigned_group: EntityRef,
}
impl IGroupAssignment for SourceForRequirement {
    fn assigned_group(&self) -> &EntityRef {
        &self.assigned_group
    }
}
impl ISourceForRequirement for SourceForRequirement {
    fn items(&self) -> &HashSet<EntityRef> {
        &self.items
    }
    fn assigned_group(&self) -> &EntityRef {
        &self.assigned_group
    }
}
impl SourceForRequirement {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = SourceForRequirement::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.items = parameter.into(),
                1usize => entity.assigned_group = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait ISourcedRequirement: IGroupAssignment {
    fn items(&self) -> &HashSet<EntityRef>;
    fn assigned_group(&self) -> &EntityRef;
}
#[derive(Default, Debug)]
pub struct SourcedRequirement {
    items: HashSet<EntityRef>,
    assigned_group: EntityRef,
}
impl IGroupAssignment for SourcedRequirement {
    fn assigned_group(&self) -> &EntityRef {
        &self.assigned_group
    }
}
impl ISourcedRequirement for SourcedRequirement {
    fn items(&self) -> &HashSet<EntityRef> {
        &self.items
    }
    fn assigned_group(&self) -> &EntityRef {
        &self.assigned_group
    }
}
impl SourcedRequirement {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = SourcedRequirement::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.items = parameter.into(),
                1usize => entity.assigned_group = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait ISpecificationDefinition: IProductDefinition {}
#[derive(Default, Debug)]
pub struct SpecificationDefinition {
    id: Identifier,
    description: Option<Text>,
    formation: EntityRef,
    frame_of_reference: EntityRef,
}
impl IProductDefinition for SpecificationDefinition {
    fn id(&self) -> &Identifier {
        &self.id
    }
    fn description(&self) -> &Option<Text> {
        &self.description
    }
    fn formation(&self) -> &EntityRef {
        &self.formation
    }
    fn frame_of_reference(&self) -> &EntityRef {
        &self.frame_of_reference
    }
}
impl ISpecificationDefinition for SpecificationDefinition {}
impl SpecificationDefinition {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = SpecificationDefinition::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.id = parameter.into(),
                1usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => entity.formation = parameter.into(),
                3usize => entity.frame_of_reference = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait ISpecifiedHigherUsageOccurrence: IAssemblyComponentUsage {
    fn upper_usage(&self) -> &EntityRef;
    fn next_usage(&self) -> &EntityRef;
}
#[derive(Default, Debug)]
pub struct SpecifiedHigherUsageOccurrence {
    id: Identifier,
    name: Label,
    description: Option<Text>,
    relating_product_definition: EntityRef,
    related_product_definition: EntityRef,
    reference_designator: Option<Identifier>,
    upper_usage: EntityRef,
    next_usage: EntityRef,
}
impl IProductDefinitionRelationship for SpecifiedHigherUsageOccurrence {
    fn id(&self) -> &Identifier {
        &self.id
    }
    fn name(&self) -> &Label {
        &self.name
    }
    fn description(&self) -> &Option<Text> {
        &self.description
    }
    fn relating_product_definition(&self) -> &EntityRef {
        &self.relating_product_definition
    }
    fn related_product_definition(&self) -> &EntityRef {
        &self.related_product_definition
    }
}
impl IProductDefinitionUsage for SpecifiedHigherUsageOccurrence {}
impl IAssemblyComponentUsage for SpecifiedHigherUsageOccurrence {
    fn reference_designator(&self) -> &Option<Identifier> {
        &self.reference_designator
    }
}
impl ISpecifiedHigherUsageOccurrence for SpecifiedHigherUsageOccurrence {
    fn upper_usage(&self) -> &EntityRef {
        &self.upper_usage
    }
    fn next_usage(&self) -> &EntityRef {
        &self.next_usage
    }
}
impl SpecifiedHigherUsageOccurrence {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = SpecifiedHigherUsageOccurrence::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.id = parameter.into(),
                1usize => entity.name = parameter.into(),
                2usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => entity.relating_product_definition = parameter.into(),
                4usize => entity.related_product_definition = parameter.into(),
                5usize => {
                    entity.reference_designator = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                6usize => entity.upper_usage = parameter.into(),
                7usize => entity.next_usage = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait ISphere: IGeometricRepresentationItem {
    fn radius(&self) -> &PositiveLengthMeasure;
    fn centre(&self) -> &EntityRef;
}
#[derive(Default, Debug)]
pub struct Sphere {
    name: Label,
    radius: PositiveLengthMeasure,
    centre: EntityRef,
}
impl IRepresentationItem for Sphere {
    fn name(&self) -> &Label {
        &self.name
    }
}
impl IGeometricRepresentationItem for Sphere {}
impl ISphere for Sphere {
    fn radius(&self) -> &PositiveLengthMeasure {
        &self.radius
    }
    fn centre(&self) -> &EntityRef {
        &self.centre
    }
}
impl Sphere {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = Sphere::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => entity.radius = parameter.into(),
                2usize => entity.centre = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait ISphericalSurface: IElementarySurface {
    fn radius(&self) -> &PositiveLengthMeasure;
}
#[derive(Default, Debug)]
pub struct SphericalSurface {
    name: Label,
    position: EntityRef,
    radius: PositiveLengthMeasure,
}
impl IRepresentationItem for SphericalSurface {
    fn name(&self) -> &Label {
        &self.name
    }
}
impl IGeometricRepresentationItem for SphericalSurface {}
impl ISurface for SphericalSurface {}
impl IElementarySurface for SphericalSurface {
    fn position(&self) -> &EntityRef {
        &self.position
    }
}
impl ISphericalSurface for SphericalSurface {
    fn radius(&self) -> &PositiveLengthMeasure {
        &self.radius
    }
}
impl SphericalSurface {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = SphericalSurface::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => entity.position = parameter.into(),
                2usize => entity.radius = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IStandardUncertainty: IUncertaintyQualifier {
    fn uncertainty_value(&self) -> Real;
}
#[derive(Default, Debug)]
pub struct StandardUncertainty {
    measure_name: Label,
    description: Text,
    uncertainty_value: Real,
}
impl IUncertaintyQualifier for StandardUncertainty {
    fn measure_name(&self) -> &Label {
        &self.measure_name
    }
    fn description(&self) -> &Text {
        &self.description
    }
}
impl IStandardUncertainty for StandardUncertainty {
    fn uncertainty_value(&self) -> Real {
        self.uncertainty_value
    }
}
impl StandardUncertainty {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = StandardUncertainty::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.measure_name = parameter.into(),
                1usize => entity.description = parameter.into(),
                2usize => entity.uncertainty_value = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IStartRequest: IActionRequestAssignment {
    fn items(&self) -> &HashSet<EntityRef>;
}
#[derive(Default, Debug)]
pub struct StartRequest {
    assigned_action_request: EntityRef,
    items: HashSet<EntityRef>,
}
impl IActionRequestAssignment for StartRequest {
    fn assigned_action_request(&self) -> &EntityRef {
        &self.assigned_action_request
    }
}
impl IStartRequest for StartRequest {
    fn items(&self) -> &HashSet<EntityRef> {
        &self.items
    }
}
impl StartRequest {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = StartRequest::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.assigned_action_request = parameter.into(),
                1usize => entity.items = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IStartWork: IActionAssignment {
    fn items(&self) -> &HashSet<EntityRef>;
}
#[derive(Default, Debug)]
pub struct StartWork {
    assigned_action: EntityRef,
    items: HashSet<EntityRef>,
}
impl IActionAssignment for StartWork {
    fn assigned_action(&self) -> &EntityRef {
        &self.assigned_action
    }
}
impl IStartWork for StartWork {
    fn items(&self) -> &HashSet<EntityRef> {
        &self.items
    }
}
impl StartWork {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = StartWork::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.assigned_action = parameter.into(),
                1usize => entity.items = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IStraightnessTolerance: IGeometricTolerance {}
#[derive(Default, Debug)]
pub struct StraightnessTolerance {
    name: Label,
    description: Text,
    magnitude: EntityRef,
    toleranced_shape_aspect: EntityRef,
}
impl IGeometricTolerance for StraightnessTolerance {
    fn name(&self) -> &Label {
        &self.name
    }
    fn description(&self) -> &Text {
        &self.description
    }
    fn magnitude(&self) -> &EntityRef {
        &self.magnitude
    }
    fn toleranced_shape_aspect(&self) -> &EntityRef {
        &self.toleranced_shape_aspect
    }
}
impl IStraightnessTolerance for StraightnessTolerance {}
impl StraightnessTolerance {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = StraightnessTolerance::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => entity.description = parameter.into(),
                2usize => entity.magnitude = parameter.into(),
                3usize => entity.toleranced_shape_aspect = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IStructuredDimensionCallout: IDraughtingCallout {}
#[derive(Default, Debug)]
pub struct StructuredDimensionCallout {
    name: Label,
    contents: HashSet<EntityRef>,
}
impl IRepresentationItem for StructuredDimensionCallout {
    fn name(&self) -> &Label {
        &self.name
    }
}
impl IGeometricRepresentationItem for StructuredDimensionCallout {}
impl IDraughtingCallout for StructuredDimensionCallout {
    fn contents(&self) -> &HashSet<EntityRef> {
        &self.contents
    }
}
impl IStructuredDimensionCallout for StructuredDimensionCallout {}
impl StructuredDimensionCallout {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = StructuredDimensionCallout::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => entity.contents = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IStructuredTextComposition: ICompoundRepresentationItem {}
#[derive(Default, Debug)]
pub struct StructuredTextComposition {
    name: Label,
    item_element: CompoundItemDefinition,
}
impl IRepresentationItem for StructuredTextComposition {
    fn name(&self) -> &Label {
        &self.name
    }
}
impl ICompoundRepresentationItem for StructuredTextComposition {
    fn item_element(&self) -> &CompoundItemDefinition {
        &self.item_element
    }
}
impl IStructuredTextComposition for StructuredTextComposition {}
impl StructuredTextComposition {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = StructuredTextComposition::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => entity.item_element = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IStructuredTextRepresentation: IRepresentation {
    fn items(&self) -> &HashSet<EntityRef>;
}
#[derive(Default, Debug)]
pub struct StructuredTextRepresentation {
    name: Label,
    context_of_items: EntityRef,
    items: HashSet<EntityRef>,
}
impl IRepresentation for StructuredTextRepresentation {
    fn name(&self) -> &Label {
        &self.name
    }
    fn items(&self) -> &HashSet<EntityRef> {
        &self.items
    }
    fn context_of_items(&self) -> &EntityRef {
        &self.context_of_items
    }
}
impl IStructuredTextRepresentation for StructuredTextRepresentation {
    fn items(&self) -> &HashSet<EntityRef> {
        &self.items
    }
}
impl StructuredTextRepresentation {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = StructuredTextRepresentation::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => entity.context_of_items = parameter.into(),
                2usize => entity.items = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IStyledItem: IRepresentationItem {
    fn styles(&self) -> &HashSet<EntityRef>;
    fn item(&self) -> &EntityRef;
}
#[derive(Default, Debug)]
pub struct StyledItem {
    name: Label,
    styles: HashSet<EntityRef>,
    item: EntityRef,
}
impl IRepresentationItem for StyledItem {
    fn name(&self) -> &Label {
        &self.name
    }
}
impl IStyledItem for StyledItem {
    fn styles(&self) -> &HashSet<EntityRef> {
        &self.styles
    }
    fn item(&self) -> &EntityRef {
        &self.item
    }
}
impl StyledItem {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = StyledItem::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => entity.styles = parameter.into(),
                2usize => entity.item = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait ISubedge: IEdge {
    fn parent_edge(&self) -> &EntityRef;
}
#[derive(Default, Debug)]
pub struct Subedge {
    name: Label,
    edge_start: EntityRef,
    edge_end: EntityRef,
    parent_edge: EntityRef,
}
impl IRepresentationItem for Subedge {
    fn name(&self) -> &Label {
        &self.name
    }
}
impl ITopologicalRepresentationItem for Subedge {}
impl IEdge for Subedge {
    fn edge_start(&self) -> &EntityRef {
        &self.edge_start
    }
    fn edge_end(&self) -> &EntityRef {
        &self.edge_end
    }
}
impl ISubedge for Subedge {
    fn parent_edge(&self) -> &EntityRef {
        &self.parent_edge
    }
}
impl Subedge {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = Subedge::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => entity.edge_start = parameter.into(),
                2usize => entity.edge_end = parameter.into(),
                3usize => entity.parent_edge = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait ISubface: IFace {
    fn parent_face(&self) -> &EntityRef;
}
#[derive(Default, Debug)]
pub struct Subface {
    name: Label,
    bounds: HashSet<EntityRef>,
    parent_face: EntityRef,
}
impl IRepresentationItem for Subface {
    fn name(&self) -> &Label {
        &self.name
    }
}
impl ITopologicalRepresentationItem for Subface {}
impl IFace for Subface {
    fn bounds(&self) -> &HashSet<EntityRef> {
        &self.bounds
    }
}
impl ISubface for Subface {
    fn parent_face(&self) -> &EntityRef {
        &self.parent_face
    }
}
impl Subface {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = Subface::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => entity.bounds = parameter.into(),
                2usize => entity.parent_face = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait ISuppliedPartRelationship: IProductDefinitionRelationship {}
#[derive(Default, Debug)]
pub struct SuppliedPartRelationship {
    id: Identifier,
    name: Label,
    description: Option<Text>,
    relating_product_definition: EntityRef,
    related_product_definition: EntityRef,
}
impl IProductDefinitionRelationship for SuppliedPartRelationship {
    fn id(&self) -> &Identifier {
        &self.id
    }
    fn name(&self) -> &Label {
        &self.name
    }
    fn description(&self) -> &Option<Text> {
        &self.description
    }
    fn relating_product_definition(&self) -> &EntityRef {
        &self.relating_product_definition
    }
    fn related_product_definition(&self) -> &EntityRef {
        &self.related_product_definition
    }
}
impl ISuppliedPartRelationship for SuppliedPartRelationship {}
impl SuppliedPartRelationship {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = SuppliedPartRelationship::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.id = parameter.into(),
                1usize => entity.name = parameter.into(),
                2usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => entity.relating_product_definition = parameter.into(),
                4usize => entity.related_product_definition = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait ISurface: IGeometricRepresentationItem {}
#[derive(Default, Debug)]
pub struct Surface {
    name: Label,
}
impl IRepresentationItem for Surface {
    fn name(&self) -> &Label {
        &self.name
    }
}
impl IGeometricRepresentationItem for Surface {}
impl ISurface for Surface {}
impl Surface {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = Surface::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait ISurfaceConditionCallout: IDraughtingCallout {}
#[derive(Default, Debug)]
pub struct SurfaceConditionCallout {
    name: Label,
    contents: HashSet<EntityRef>,
}
impl IRepresentationItem for SurfaceConditionCallout {
    fn name(&self) -> &Label {
        &self.name
    }
}
impl IGeometricRepresentationItem for SurfaceConditionCallout {}
impl IDraughtingCallout for SurfaceConditionCallout {
    fn contents(&self) -> &HashSet<EntityRef> {
        &self.contents
    }
}
impl ISurfaceConditionCallout for SurfaceConditionCallout {}
impl SurfaceConditionCallout {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = SurfaceConditionCallout::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => entity.contents = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait ISurfaceCurve: ICurve {
    fn curve_3d(&self) -> &EntityRef;
    fn associated_geometry(&self) -> &Vec<EntityRef>;
    fn master_representation(&self) -> &PreferredSurfaceCurveRepresentation;
}
#[derive(Default, Debug)]
pub struct SurfaceCurve {
    name: Label,
    curve_3d: EntityRef,
    associated_geometry: Vec<EntityRef>,
    master_representation: PreferredSurfaceCurveRepresentation,
}
impl IRepresentationItem for SurfaceCurve {
    fn name(&self) -> &Label {
        &self.name
    }
}
impl IGeometricRepresentationItem for SurfaceCurve {}
impl ICurve for SurfaceCurve {}
impl ISurfaceCurve for SurfaceCurve {
    fn curve_3d(&self) -> &EntityRef {
        &self.curve_3d
    }
    fn associated_geometry(&self) -> &Vec<EntityRef> {
        &self.associated_geometry
    }
    fn master_representation(&self) -> &PreferredSurfaceCurveRepresentation {
        &self.master_representation
    }
}
impl SurfaceCurve {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = SurfaceCurve::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => entity.curve_3d = parameter.into(),
                2usize => entity.associated_geometry = parameter.into(),
                3usize => entity.master_representation = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait ISurfaceCurveSweptAreaSolid: ISweptAreaSolid {
    fn directrix(&self) -> &EntityRef;
    fn start_param(&self) -> Real;
    fn end_param(&self) -> Real;
    fn reference_surface(&self) -> &EntityRef;
}
#[derive(Default, Debug)]
pub struct SurfaceCurveSweptAreaSolid {
    name: Label,
    swept_area: EntityRef,
    directrix: EntityRef,
    start_param: Real,
    end_param: Real,
    reference_surface: EntityRef,
}
impl IRepresentationItem for SurfaceCurveSweptAreaSolid {
    fn name(&self) -> &Label {
        &self.name
    }
}
impl IGeometricRepresentationItem for SurfaceCurveSweptAreaSolid {}
impl ISolidModel for SurfaceCurveSweptAreaSolid {}
impl ISweptAreaSolid for SurfaceCurveSweptAreaSolid {
    fn swept_area(&self) -> &EntityRef {
        &self.swept_area
    }
}
impl ISurfaceCurveSweptAreaSolid for SurfaceCurveSweptAreaSolid {
    fn directrix(&self) -> &EntityRef {
        &self.directrix
    }
    fn start_param(&self) -> Real {
        self.start_param
    }
    fn end_param(&self) -> Real {
        self.end_param
    }
    fn reference_surface(&self) -> &EntityRef {
        &self.reference_surface
    }
}
impl SurfaceCurveSweptAreaSolid {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = SurfaceCurveSweptAreaSolid::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => entity.swept_area = parameter.into(),
                2usize => entity.directrix = parameter.into(),
                3usize => entity.start_param = parameter.into(),
                4usize => entity.end_param = parameter.into(),
                5usize => entity.reference_surface = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait ISurfaceOfLinearExtrusion: ISweptSurface {
    fn extrusion_axis(&self) -> &EntityRef;
}
#[derive(Default, Debug)]
pub struct SurfaceOfLinearExtrusion {
    name: Label,
    swept_curve: EntityRef,
    extrusion_axis: EntityRef,
}
impl IRepresentationItem for SurfaceOfLinearExtrusion {
    fn name(&self) -> &Label {
        &self.name
    }
}
impl IGeometricRepresentationItem for SurfaceOfLinearExtrusion {}
impl ISurface for SurfaceOfLinearExtrusion {}
impl ISweptSurface for SurfaceOfLinearExtrusion {
    fn swept_curve(&self) -> &EntityRef {
        &self.swept_curve
    }
}
impl ISurfaceOfLinearExtrusion for SurfaceOfLinearExtrusion {
    fn extrusion_axis(&self) -> &EntityRef {
        &self.extrusion_axis
    }
}
impl SurfaceOfLinearExtrusion {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = SurfaceOfLinearExtrusion::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => entity.swept_curve = parameter.into(),
                2usize => entity.extrusion_axis = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait ISurfaceOfRevolution: ISweptSurface {
    fn axis_position(&self) -> &EntityRef;
}
#[derive(Default, Debug)]
pub struct SurfaceOfRevolution {
    name: Label,
    swept_curve: EntityRef,
    axis_position: EntityRef,
}
impl IRepresentationItem for SurfaceOfRevolution {
    fn name(&self) -> &Label {
        &self.name
    }
}
impl IGeometricRepresentationItem for SurfaceOfRevolution {}
impl ISurface for SurfaceOfRevolution {}
impl ISweptSurface for SurfaceOfRevolution {
    fn swept_curve(&self) -> &EntityRef {
        &self.swept_curve
    }
}
impl ISurfaceOfRevolution for SurfaceOfRevolution {
    fn axis_position(&self) -> &EntityRef {
        &self.axis_position
    }
}
impl SurfaceOfRevolution {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = SurfaceOfRevolution::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => entity.swept_curve = parameter.into(),
                2usize => entity.axis_position = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait ISurfacePatch: IFoundedItem {
    fn parent_surface(&self) -> &EntityRef;
    fn u_transition(&self) -> &TransitionCode;
    fn v_transition(&self) -> &TransitionCode;
    fn u_sense(&self) -> bool;
    fn v_sense(&self) -> bool;
}
#[derive(Default, Debug)]
pub struct SurfacePatch {
    parent_surface: EntityRef,
    u_transition: TransitionCode,
    v_transition: TransitionCode,
    u_sense: bool,
    v_sense: bool,
}
impl IFoundedItem for SurfacePatch {}
impl ISurfacePatch for SurfacePatch {
    fn parent_surface(&self) -> &EntityRef {
        &self.parent_surface
    }
    fn u_transition(&self) -> &TransitionCode {
        &self.u_transition
    }
    fn v_transition(&self) -> &TransitionCode {
        &self.v_transition
    }
    fn u_sense(&self) -> bool {
        self.u_sense
    }
    fn v_sense(&self) -> bool {
        self.v_sense
    }
}
impl SurfacePatch {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = SurfacePatch::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.parent_surface = parameter.into(),
                1usize => entity.u_transition = parameter.into(),
                2usize => entity.v_transition = parameter.into(),
                3usize => entity.u_sense = parameter.into(),
                4usize => entity.v_sense = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait ISurfaceProfileTolerance: IGeometricTolerance {}
#[derive(Default, Debug)]
pub struct SurfaceProfileTolerance {
    name: Label,
    description: Text,
    magnitude: EntityRef,
    toleranced_shape_aspect: EntityRef,
}
impl IGeometricTolerance for SurfaceProfileTolerance {
    fn name(&self) -> &Label {
        &self.name
    }
    fn description(&self) -> &Text {
        &self.description
    }
    fn magnitude(&self) -> &EntityRef {
        &self.magnitude
    }
    fn toleranced_shape_aspect(&self) -> &EntityRef {
        &self.toleranced_shape_aspect
    }
}
impl ISurfaceProfileTolerance for SurfaceProfileTolerance {}
impl SurfaceProfileTolerance {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = SurfaceProfileTolerance::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => entity.description = parameter.into(),
                2usize => entity.magnitude = parameter.into(),
                3usize => entity.toleranced_shape_aspect = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait ISurfaceRenderingProperties {
    fn rendered_colour(&self) -> &EntityRef;
}
#[derive(Default, Debug)]
pub struct SurfaceRenderingProperties {
    rendered_colour: EntityRef,
}
impl ISurfaceRenderingProperties for SurfaceRenderingProperties {
    fn rendered_colour(&self) -> &EntityRef {
        &self.rendered_colour
    }
}
impl SurfaceRenderingProperties {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = SurfaceRenderingProperties::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.rendered_colour = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait ISurfaceReplica: ISurface {
    fn parent_surface(&self) -> &EntityRef;
    fn transformation(&self) -> &EntityRef;
}
#[derive(Default, Debug)]
pub struct SurfaceReplica {
    name: Label,
    parent_surface: EntityRef,
    transformation: EntityRef,
}
impl IRepresentationItem for SurfaceReplica {
    fn name(&self) -> &Label {
        &self.name
    }
}
impl IGeometricRepresentationItem for SurfaceReplica {}
impl ISurface for SurfaceReplica {}
impl ISurfaceReplica for SurfaceReplica {
    fn parent_surface(&self) -> &EntityRef {
        &self.parent_surface
    }
    fn transformation(&self) -> &EntityRef {
        &self.transformation
    }
}
impl SurfaceReplica {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = SurfaceReplica::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => entity.parent_surface = parameter.into(),
                2usize => entity.transformation = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait ISurfaceSideStyle: IFoundedItem {
    fn name(&self) -> &Label;
    fn styles(&self) -> &HashSet<EntityRef>;
}
#[derive(Default, Debug)]
pub struct SurfaceSideStyle {
    name: Label,
    styles: HashSet<EntityRef>,
}
impl IFoundedItem for SurfaceSideStyle {}
impl ISurfaceSideStyle for SurfaceSideStyle {
    fn name(&self) -> &Label {
        &self.name
    }
    fn styles(&self) -> &HashSet<EntityRef> {
        &self.styles
    }
}
impl SurfaceSideStyle {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = SurfaceSideStyle::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => entity.styles = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait ISurfaceStyleBoundary: IFoundedItem {
    fn style_of_boundary(&self) -> &EntityRef;
}
#[derive(Default, Debug)]
pub struct SurfaceStyleBoundary {
    style_of_boundary: EntityRef,
}
impl IFoundedItem for SurfaceStyleBoundary {}
impl ISurfaceStyleBoundary for SurfaceStyleBoundary {
    fn style_of_boundary(&self) -> &EntityRef {
        &self.style_of_boundary
    }
}
impl SurfaceStyleBoundary {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = SurfaceStyleBoundary::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.style_of_boundary = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait ISurfaceStyleControlGrid: IFoundedItem {
    fn style_of_control_grid(&self) -> &EntityRef;
}
#[derive(Default, Debug)]
pub struct SurfaceStyleControlGrid {
    style_of_control_grid: EntityRef,
}
impl IFoundedItem for SurfaceStyleControlGrid {}
impl ISurfaceStyleControlGrid for SurfaceStyleControlGrid {
    fn style_of_control_grid(&self) -> &EntityRef {
        &self.style_of_control_grid
    }
}
impl SurfaceStyleControlGrid {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = SurfaceStyleControlGrid::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.style_of_control_grid = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait ISurfaceStyleFillArea: IFoundedItem {
    fn fill_area(&self) -> &EntityRef;
}
#[derive(Default, Debug)]
pub struct SurfaceStyleFillArea {
    fill_area: EntityRef,
}
impl IFoundedItem for SurfaceStyleFillArea {}
impl ISurfaceStyleFillArea for SurfaceStyleFillArea {
    fn fill_area(&self) -> &EntityRef {
        &self.fill_area
    }
}
impl SurfaceStyleFillArea {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = SurfaceStyleFillArea::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.fill_area = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait ISurfaceStyleParameterLine: IFoundedItem {
    fn style_of_parameter_lines(&self) -> &EntityRef;
    fn direction_counts(&self) -> &HashSet<DirectionCountSelect>;
}
#[derive(Default, Debug)]
pub struct SurfaceStyleParameterLine {
    style_of_parameter_lines: EntityRef,
    direction_counts: HashSet<DirectionCountSelect>,
}
impl IFoundedItem for SurfaceStyleParameterLine {}
impl ISurfaceStyleParameterLine for SurfaceStyleParameterLine {
    fn style_of_parameter_lines(&self) -> &EntityRef {
        &self.style_of_parameter_lines
    }
    fn direction_counts(&self) -> &HashSet<DirectionCountSelect> {
        &self.direction_counts
    }
}
impl SurfaceStyleParameterLine {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = SurfaceStyleParameterLine::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.style_of_parameter_lines = parameter.into(),
                1usize => entity.direction_counts = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait ISurfaceStyleReflectanceAmbient {
    fn ambient_reflectance(&self) -> Real;
}
#[derive(Default, Debug)]
pub struct SurfaceStyleReflectanceAmbient {
    ambient_reflectance: Real,
}
impl ISurfaceStyleReflectanceAmbient for SurfaceStyleReflectanceAmbient {
    fn ambient_reflectance(&self) -> Real {
        self.ambient_reflectance
    }
}
impl SurfaceStyleReflectanceAmbient {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = SurfaceStyleReflectanceAmbient::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.ambient_reflectance = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait ISurfaceStyleReflectanceAmbientDiffuse: ISurfaceStyleReflectanceAmbient {
    fn diffuse_reflectance(&self) -> Real;
}
#[derive(Default, Debug)]
pub struct SurfaceStyleReflectanceAmbientDiffuse {
    ambient_reflectance: Real,
    diffuse_reflectance: Real,
}
impl ISurfaceStyleReflectanceAmbient for SurfaceStyleReflectanceAmbientDiffuse {
    fn ambient_reflectance(&self) -> Real {
        self.ambient_reflectance
    }
}
impl ISurfaceStyleReflectanceAmbientDiffuse for SurfaceStyleReflectanceAmbientDiffuse {
    fn diffuse_reflectance(&self) -> Real {
        self.diffuse_reflectance
    }
}
impl SurfaceStyleReflectanceAmbientDiffuse {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = SurfaceStyleReflectanceAmbientDiffuse::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.ambient_reflectance = parameter.into(),
                1usize => entity.diffuse_reflectance = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait ISurfaceStyleReflectanceAmbientDiffuseSpecular: ISurfaceStyleReflectanceAmbientDiffuse {
    fn specular_reflectance(&self) -> Real;
    fn specular_exponent(&self) -> Real;
    fn specular_colour(&self) -> &EntityRef;
}
#[derive(Default, Debug)]
pub struct SurfaceStyleReflectanceAmbientDiffuseSpecular {
    ambient_reflectance: Real,
    diffuse_reflectance: Real,
    specular_reflectance: Real,
    specular_exponent: Real,
    specular_colour: EntityRef,
}
impl ISurfaceStyleReflectanceAmbient for SurfaceStyleReflectanceAmbientDiffuseSpecular {
    fn ambient_reflectance(&self) -> Real {
        self.ambient_reflectance
    }
}
impl ISurfaceStyleReflectanceAmbientDiffuse for SurfaceStyleReflectanceAmbientDiffuseSpecular {
    fn diffuse_reflectance(&self) -> Real {
        self.diffuse_reflectance
    }
}
impl ISurfaceStyleReflectanceAmbientDiffuseSpecular for SurfaceStyleReflectanceAmbientDiffuseSpecular {
    fn specular_reflectance(&self) -> Real {
        self.specular_reflectance
    }
    fn specular_exponent(&self) -> Real {
        self.specular_exponent
    }
    fn specular_colour(&self) -> &EntityRef {
        &self.specular_colour
    }
}
impl SurfaceStyleReflectanceAmbientDiffuseSpecular {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = SurfaceStyleReflectanceAmbientDiffuseSpecular::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.ambient_reflectance = parameter.into(),
                1usize => entity.diffuse_reflectance = parameter.into(),
                2usize => entity.specular_reflectance = parameter.into(),
                3usize => entity.specular_exponent = parameter.into(),
                4usize => entity.specular_colour = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait ISurfaceStyleRendering {
    fn rendering_method(&self) -> &ShadingSurfaceMethod;
    fn surface_colour(&self) -> &EntityRef;
}
#[derive(Default, Debug)]
pub struct SurfaceStyleRendering {
    rendering_method: ShadingSurfaceMethod,
    surface_colour: EntityRef,
}
impl ISurfaceStyleRendering for SurfaceStyleRendering {
    fn rendering_method(&self) -> &ShadingSurfaceMethod {
        &self.rendering_method
    }
    fn surface_colour(&self) -> &EntityRef {
        &self.surface_colour
    }
}
impl SurfaceStyleRendering {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = SurfaceStyleRendering::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.rendering_method = parameter.into(),
                1usize => entity.surface_colour = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait ISurfaceStyleRenderingWithProperties: ISurfaceStyleRendering {
    fn properties(&self) -> &HashSet<EntityRef>;
}
#[derive(Default, Debug)]
pub struct SurfaceStyleRenderingWithProperties {
    rendering_method: ShadingSurfaceMethod,
    surface_colour: EntityRef,
    properties: HashSet<EntityRef>,
}
impl ISurfaceStyleRendering for SurfaceStyleRenderingWithProperties {
    fn rendering_method(&self) -> &ShadingSurfaceMethod {
        &self.rendering_method
    }
    fn surface_colour(&self) -> &EntityRef {
        &self.surface_colour
    }
}
impl ISurfaceStyleRenderingWithProperties for SurfaceStyleRenderingWithProperties {
    fn properties(&self) -> &HashSet<EntityRef> {
        &self.properties
    }
}
impl SurfaceStyleRenderingWithProperties {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = SurfaceStyleRenderingWithProperties::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.rendering_method = parameter.into(),
                1usize => entity.surface_colour = parameter.into(),
                2usize => entity.properties = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait ISurfaceStyleSegmentationCurve: IFoundedItem {
    fn style_of_segmentation_curve(&self) -> &EntityRef;
}
#[derive(Default, Debug)]
pub struct SurfaceStyleSegmentationCurve {
    style_of_segmentation_curve: EntityRef,
}
impl IFoundedItem for SurfaceStyleSegmentationCurve {}
impl ISurfaceStyleSegmentationCurve for SurfaceStyleSegmentationCurve {
    fn style_of_segmentation_curve(&self) -> &EntityRef {
        &self.style_of_segmentation_curve
    }
}
impl SurfaceStyleSegmentationCurve {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = SurfaceStyleSegmentationCurve::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.style_of_segmentation_curve = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait ISurfaceStyleSilhouette: IFoundedItem {
    fn style_of_silhouette(&self) -> &EntityRef;
}
#[derive(Default, Debug)]
pub struct SurfaceStyleSilhouette {
    style_of_silhouette: EntityRef,
}
impl IFoundedItem for SurfaceStyleSilhouette {}
impl ISurfaceStyleSilhouette for SurfaceStyleSilhouette {
    fn style_of_silhouette(&self) -> &EntityRef {
        &self.style_of_silhouette
    }
}
impl SurfaceStyleSilhouette {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = SurfaceStyleSilhouette::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.style_of_silhouette = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait ISurfaceStyleTransparent {
    fn transparency(&self) -> Real;
}
#[derive(Default, Debug)]
pub struct SurfaceStyleTransparent {
    transparency: Real,
}
impl ISurfaceStyleTransparent for SurfaceStyleTransparent {
    fn transparency(&self) -> Real {
        self.transparency
    }
}
impl SurfaceStyleTransparent {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = SurfaceStyleTransparent::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.transparency = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait ISurfaceStyleUsage: IFoundedItem {
    fn side(&self) -> &SurfaceSide;
    fn style(&self) -> &EntityRef;
}
#[derive(Default, Debug)]
pub struct SurfaceStyleUsage {
    side: SurfaceSide,
    style: EntityRef,
}
impl IFoundedItem for SurfaceStyleUsage {}
impl ISurfaceStyleUsage for SurfaceStyleUsage {
    fn side(&self) -> &SurfaceSide {
        &self.side
    }
    fn style(&self) -> &EntityRef {
        &self.style
    }
}
impl SurfaceStyleUsage {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = SurfaceStyleUsage::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.side = parameter.into(),
                1usize => entity.style = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait ISurfaceTextureRepresentation: IRepresentation {}
#[derive(Default, Debug)]
pub struct SurfaceTextureRepresentation {
    name: Label,
    items: HashSet<EntityRef>,
    context_of_items: EntityRef,
}
impl IRepresentation for SurfaceTextureRepresentation {
    fn name(&self) -> &Label {
        &self.name
    }
    fn items(&self) -> &HashSet<EntityRef> {
        &self.items
    }
    fn context_of_items(&self) -> &EntityRef {
        &self.context_of_items
    }
}
impl ISurfaceTextureRepresentation for SurfaceTextureRepresentation {}
impl SurfaceTextureRepresentation {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = SurfaceTextureRepresentation::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => entity.items = parameter.into(),
                2usize => entity.context_of_items = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait ISurfacedOpenShell: IOpenShell {}
#[derive(Default, Debug)]
pub struct SurfacedOpenShell {
    name: Label,
    cfs_faces: HashSet<EntityRef>,
}
impl IRepresentationItem for SurfacedOpenShell {
    fn name(&self) -> &Label {
        &self.name
    }
}
impl ITopologicalRepresentationItem for SurfacedOpenShell {}
impl IConnectedFaceSet for SurfacedOpenShell {
    fn cfs_faces(&self) -> &HashSet<EntityRef> {
        &self.cfs_faces
    }
}
impl IOpenShell for SurfacedOpenShell {}
impl ISurfacedOpenShell for SurfacedOpenShell {}
impl SurfacedOpenShell {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = SurfacedOpenShell::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => entity.cfs_faces = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait ISweptAreaSolid: ISolidModel {
    fn swept_area(&self) -> &EntityRef;
}
#[derive(Default, Debug)]
pub struct SweptAreaSolid {
    name: Label,
    swept_area: EntityRef,
}
impl IRepresentationItem for SweptAreaSolid {
    fn name(&self) -> &Label {
        &self.name
    }
}
impl IGeometricRepresentationItem for SweptAreaSolid {}
impl ISolidModel for SweptAreaSolid {}
impl ISweptAreaSolid for SweptAreaSolid {
    fn swept_area(&self) -> &EntityRef {
        &self.swept_area
    }
}
impl SweptAreaSolid {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = SweptAreaSolid::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => entity.swept_area = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait ISweptDiskSolid: ISolidModel {
    fn directrix(&self) -> &EntityRef;
    fn radius(&self) -> &PositiveLengthMeasure;
    fn inner_radius(&self) -> &Option<PositiveLengthMeasure>;
    fn start_param(&self) -> Real;
    fn end_param(&self) -> Real;
}
#[derive(Default, Debug)]
pub struct SweptDiskSolid {
    name: Label,
    directrix: EntityRef,
    radius: PositiveLengthMeasure,
    inner_radius: Option<PositiveLengthMeasure>,
    start_param: Real,
    end_param: Real,
}
impl IRepresentationItem for SweptDiskSolid {
    fn name(&self) -> &Label {
        &self.name
    }
}
impl IGeometricRepresentationItem for SweptDiskSolid {}
impl ISolidModel for SweptDiskSolid {}
impl ISweptDiskSolid for SweptDiskSolid {
    fn directrix(&self) -> &EntityRef {
        &self.directrix
    }
    fn radius(&self) -> &PositiveLengthMeasure {
        &self.radius
    }
    fn inner_radius(&self) -> &Option<PositiveLengthMeasure> {
        &self.inner_radius
    }
    fn start_param(&self) -> Real {
        self.start_param
    }
    fn end_param(&self) -> Real {
        self.end_param
    }
}
impl SweptDiskSolid {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = SweptDiskSolid::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => entity.directrix = parameter.into(),
                2usize => entity.radius = parameter.into(),
                3usize => {
                    entity.inner_radius = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => entity.start_param = parameter.into(),
                5usize => entity.end_param = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait ISweptFaceSolid: ISolidModel {
    fn swept_face(&self) -> &EntityRef;
}
#[derive(Default, Debug)]
pub struct SweptFaceSolid {
    name: Label,
    swept_face: EntityRef,
}
impl IRepresentationItem for SweptFaceSolid {
    fn name(&self) -> &Label {
        &self.name
    }
}
impl IGeometricRepresentationItem for SweptFaceSolid {}
impl ISolidModel for SweptFaceSolid {}
impl ISweptFaceSolid for SweptFaceSolid {
    fn swept_face(&self) -> &EntityRef {
        &self.swept_face
    }
}
impl SweptFaceSolid {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = SweptFaceSolid::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => entity.swept_face = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait ISweptSurface: ISurface {
    fn swept_curve(&self) -> &EntityRef;
}
#[derive(Default, Debug)]
pub struct SweptSurface {
    name: Label,
    swept_curve: EntityRef,
}
impl IRepresentationItem for SweptSurface {
    fn name(&self) -> &Label {
        &self.name
    }
}
impl IGeometricRepresentationItem for SweptSurface {}
impl ISurface for SweptSurface {}
impl ISweptSurface for SweptSurface {
    fn swept_curve(&self) -> &EntityRef {
        &self.swept_curve
    }
}
impl SweptSurface {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = SweptSurface::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => entity.swept_curve = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait ISymbol: IRepresentationItem {}
#[derive(Default, Debug)]
pub struct Symbol {
    name: Label,
}
impl IRepresentationItem for Symbol {
    fn name(&self) -> &Label {
        &self.name
    }
}
impl ISymbol for Symbol {}
impl Symbol {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = Symbol::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait ISymbolColour {
    fn colour_of_symbol(&self) -> &EntityRef;
}
#[derive(Default, Debug)]
pub struct SymbolColour {
    colour_of_symbol: EntityRef,
}
impl ISymbolColour for SymbolColour {
    fn colour_of_symbol(&self) -> &EntityRef {
        &self.colour_of_symbol
    }
}
impl SymbolColour {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = SymbolColour::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.colour_of_symbol = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait ISymbolRepresentation: IRepresentation {}
#[derive(Default, Debug)]
pub struct SymbolRepresentation {
    name: Label,
    items: HashSet<EntityRef>,
    context_of_items: EntityRef,
}
impl IRepresentation for SymbolRepresentation {
    fn name(&self) -> &Label {
        &self.name
    }
    fn items(&self) -> &HashSet<EntityRef> {
        &self.items
    }
    fn context_of_items(&self) -> &EntityRef {
        &self.context_of_items
    }
}
impl ISymbolRepresentation for SymbolRepresentation {}
impl SymbolRepresentation {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = SymbolRepresentation::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => entity.items = parameter.into(),
                2usize => entity.context_of_items = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait ISymbolRepresentationMap: IRepresentationMap {
    fn mapped_representation(&self) -> &EntityRef;
    fn mapping_origin(&self) -> &EntityRef;
}
#[derive(Default, Debug)]
pub struct SymbolRepresentationMap {
    mapped_representation: EntityRef,
    mapping_origin: EntityRef,
}
impl IRepresentationMap for SymbolRepresentationMap {
    fn mapping_origin(&self) -> &EntityRef {
        &self.mapping_origin
    }
    fn mapped_representation(&self) -> &EntityRef {
        &self.mapped_representation
    }
}
impl ISymbolRepresentationMap for SymbolRepresentationMap {
    fn mapped_representation(&self) -> &EntityRef {
        &self.mapped_representation
    }
    fn mapping_origin(&self) -> &EntityRef {
        &self.mapping_origin
    }
}
impl SymbolRepresentationMap {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = SymbolRepresentationMap::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.mapped_representation = parameter.into(),
                1usize => entity.mapping_origin = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait ISymbolStyle: IFoundedItem {
    fn name(&self) -> &Label;
    fn style_of_symbol(&self) -> &EntityRef;
}
#[derive(Default, Debug)]
pub struct SymbolStyle {
    name: Label,
    style_of_symbol: EntityRef,
}
impl IFoundedItem for SymbolStyle {}
impl ISymbolStyle for SymbolStyle {
    fn name(&self) -> &Label {
        &self.name
    }
    fn style_of_symbol(&self) -> &EntityRef {
        &self.style_of_symbol
    }
}
impl SymbolStyle {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = SymbolStyle::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => entity.style_of_symbol = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait ISymbolTarget: IGeometricRepresentationItem {
    fn placement(&self) -> &EntityRef;
    fn x_scale(&self) -> &PositiveRatioMeasure;
    fn y_scale(&self) -> &PositiveRatioMeasure;
}
#[derive(Default, Debug)]
pub struct SymbolTarget {
    name: Label,
    placement: EntityRef,
    x_scale: PositiveRatioMeasure,
    y_scale: PositiveRatioMeasure,
}
impl IRepresentationItem for SymbolTarget {
    fn name(&self) -> &Label {
        &self.name
    }
}
impl IGeometricRepresentationItem for SymbolTarget {}
impl ISymbolTarget for SymbolTarget {
    fn placement(&self) -> &EntityRef {
        &self.placement
    }
    fn x_scale(&self) -> &PositiveRatioMeasure {
        &self.x_scale
    }
    fn y_scale(&self) -> &PositiveRatioMeasure {
        &self.y_scale
    }
}
impl SymbolTarget {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = SymbolTarget::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => entity.placement = parameter.into(),
                2usize => entity.x_scale = parameter.into(),
                3usize => entity.y_scale = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait ISymmetricShapeAspect: IShapeAspect {}
#[derive(Default, Debug)]
pub struct SymmetricShapeAspect {
    name: Label,
    description: Option<Text>,
    of_shape: EntityRef,
    product_definitional: Option<bool>,
}
impl IShapeAspect for SymmetricShapeAspect {
    fn name(&self) -> &Label {
        &self.name
    }
    fn description(&self) -> &Option<Text> {
        &self.description
    }
    fn of_shape(&self) -> &EntityRef {
        &self.of_shape
    }
    fn product_definitional(&self) -> Option<bool> {
        self.product_definitional
    }
}
impl ISymmetricShapeAspect for SymmetricShapeAspect {}
impl SymmetricShapeAspect {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = SymmetricShapeAspect::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => entity.of_shape = parameter.into(),
                3usize => entity.product_definitional = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait ISymmetryTolerance: IGeometricToleranceWithDatumReference {}
#[derive(Default, Debug)]
pub struct SymmetryTolerance {
    name: Label,
    description: Text,
    magnitude: EntityRef,
    toleranced_shape_aspect: EntityRef,
    datum_system: HashSet<EntityRef>,
}
impl IGeometricTolerance for SymmetryTolerance {
    fn name(&self) -> &Label {
        &self.name
    }
    fn description(&self) -> &Text {
        &self.description
    }
    fn magnitude(&self) -> &EntityRef {
        &self.magnitude
    }
    fn toleranced_shape_aspect(&self) -> &EntityRef {
        &self.toleranced_shape_aspect
    }
}
impl IGeometricToleranceWithDatumReference for SymmetryTolerance {
    fn datum_system(&self) -> &HashSet<EntityRef> {
        &self.datum_system
    }
}
impl ISymmetryTolerance for SymmetryTolerance {}
impl SymmetryTolerance {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = SymmetryTolerance::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => entity.description = parameter.into(),
                2usize => entity.magnitude = parameter.into(),
                3usize => entity.toleranced_shape_aspect = parameter.into(),
                4usize => entity.datum_system = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait ITableRepresentationItem: ICompoundRepresentationItem {}
#[derive(Default, Debug)]
pub struct TableRepresentationItem {
    name: Label,
    item_element: CompoundItemDefinition,
}
impl IRepresentationItem for TableRepresentationItem {
    fn name(&self) -> &Label {
        &self.name
    }
}
impl ICompoundRepresentationItem for TableRepresentationItem {
    fn item_element(&self) -> &CompoundItemDefinition {
        &self.item_element
    }
}
impl ITableRepresentationItem for TableRepresentationItem {}
impl TableRepresentationItem {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = TableRepresentationItem::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => entity.item_element = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait ITactileAppearanceRepresentation: IRepresentation {}
#[derive(Default, Debug)]
pub struct TactileAppearanceRepresentation {
    name: Label,
    items: HashSet<EntityRef>,
    context_of_items: EntityRef,
}
impl IRepresentation for TactileAppearanceRepresentation {
    fn name(&self) -> &Label {
        &self.name
    }
    fn items(&self) -> &HashSet<EntityRef> {
        &self.items
    }
    fn context_of_items(&self) -> &EntityRef {
        &self.context_of_items
    }
}
impl ITactileAppearanceRepresentation for TactileAppearanceRepresentation {}
impl TactileAppearanceRepresentation {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = TactileAppearanceRepresentation::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => entity.items = parameter.into(),
                2usize => entity.context_of_items = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait ITaggedTextFormat: IRepresentationContext {}
#[derive(Default, Debug)]
pub struct TaggedTextFormat {
    context_identifier: Identifier,
    context_type: Text,
}
impl IRepresentationContext for TaggedTextFormat {
    fn context_identifier(&self) -> &Identifier {
        &self.context_identifier
    }
    fn context_type(&self) -> &Text {
        &self.context_type
    }
}
impl ITaggedTextFormat for TaggedTextFormat {}
impl TaggedTextFormat {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = TaggedTextFormat::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.context_identifier = parameter.into(),
                1usize => entity.context_type = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait ITaggedTextItem: IDescriptiveRepresentationItem {}
#[derive(Default, Debug)]
pub struct TaggedTextItem {
    name: Label,
    description: Text,
}
impl IRepresentationItem for TaggedTextItem {
    fn name(&self) -> &Label {
        &self.name
    }
}
impl IDescriptiveRepresentationItem for TaggedTextItem {
    fn description(&self) -> &Text {
        &self.description
    }
}
impl ITaggedTextItem for TaggedTextItem {}
impl TaggedTextItem {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = TaggedTextItem::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => entity.description = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait ITangent: IDerivedShapeAspect {}
#[derive(Default, Debug)]
pub struct Tangent {
    name: Label,
    description: Option<Text>,
    of_shape: EntityRef,
    product_definitional: Option<bool>,
}
impl IShapeAspect for Tangent {
    fn name(&self) -> &Label {
        &self.name
    }
    fn description(&self) -> &Option<Text> {
        &self.description
    }
    fn of_shape(&self) -> &EntityRef {
        &self.of_shape
    }
    fn product_definitional(&self) -> Option<bool> {
        self.product_definitional
    }
}
impl IDerivedShapeAspect for Tangent {}
impl ITangent for Tangent {}
impl Tangent {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = Tangent::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => entity.of_shape = parameter.into(),
                3usize => entity.product_definitional = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait ITerminatorSymbol: IAnnotationSymbolOccurrence {
    fn annotated_curve(&self) -> &EntityRef;
}
#[derive(Default, Debug)]
pub struct TerminatorSymbol {
    name: Label,
    styles: HashSet<EntityRef>,
    item: EntityRef,
    annotated_curve: EntityRef,
}
impl IRepresentationItem for TerminatorSymbol {
    fn name(&self) -> &Label {
        &self.name
    }
}
impl IStyledItem for TerminatorSymbol {
    fn styles(&self) -> &HashSet<EntityRef> {
        &self.styles
    }
    fn item(&self) -> &EntityRef {
        &self.item
    }
}
impl IAnnotationOccurrence for TerminatorSymbol {}
impl IAnnotationSymbolOccurrence for TerminatorSymbol {
    fn item(&self) -> &EntityRef {
        &self.item
    }
}
impl ITerminatorSymbol for TerminatorSymbol {
    fn annotated_curve(&self) -> &EntityRef {
        &self.annotated_curve
    }
}
impl TerminatorSymbol {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = TerminatorSymbol::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => entity.styles = parameter.into(),
                2usize => entity.item = parameter.into(),
                3usize => entity.annotated_curve = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait ITextFont {
    fn id(&self) -> &Identifier;
    fn name(&self) -> &Label;
    fn description(&self) -> &Text;
}
#[derive(Default, Debug)]
pub struct TextFont {
    id: Identifier,
    name: Label,
    description: Text,
}
impl ITextFont for TextFont {
    fn id(&self) -> &Identifier {
        &self.id
    }
    fn name(&self) -> &Label {
        &self.name
    }
    fn description(&self) -> &Text {
        &self.description
    }
}
impl TextFont {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = TextFont::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.id = parameter.into(),
                1usize => entity.name = parameter.into(),
                2usize => entity.description = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait ITextFontFamily {
    fn id(&self) -> &Identifier;
    fn name(&self) -> &Label;
    fn description(&self) -> &Text;
}
#[derive(Default, Debug)]
pub struct TextFontFamily {
    id: Identifier,
    name: Label,
    description: Text,
}
impl ITextFontFamily for TextFontFamily {
    fn id(&self) -> &Identifier {
        &self.id
    }
    fn name(&self) -> &Label {
        &self.name
    }
    fn description(&self) -> &Text {
        &self.description
    }
}
impl TextFontFamily {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = TextFontFamily::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.id = parameter.into(),
                1usize => entity.name = parameter.into(),
                2usize => entity.description = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait ITextFontInFamily {
    fn font(&self) -> &EntityRef;
    fn family(&self) -> &EntityRef;
}
#[derive(Default, Debug)]
pub struct TextFontInFamily {
    font: EntityRef,
    family: EntityRef,
}
impl ITextFontInFamily for TextFontInFamily {
    fn font(&self) -> &EntityRef {
        &self.font
    }
    fn family(&self) -> &EntityRef {
        &self.family
    }
}
impl TextFontInFamily {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = TextFontInFamily::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.font = parameter.into(),
                1usize => entity.family = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait ITextLiteral: IGeometricRepresentationItem {
    fn literal(&self) -> &PresentableText;
    fn placement(&self) -> &EntityRef;
    fn alignment(&self) -> &TextAlignment;
    fn path(&self) -> &TextPath;
    fn font(&self) -> &EntityRef;
}
#[derive(Default, Debug)]
pub struct TextLiteral {
    name: Label,
    literal: PresentableText,
    placement: EntityRef,
    alignment: TextAlignment,
    path: TextPath,
    font: EntityRef,
}
impl IRepresentationItem for TextLiteral {
    fn name(&self) -> &Label {
        &self.name
    }
}
impl IGeometricRepresentationItem for TextLiteral {}
impl ITextLiteral for TextLiteral {
    fn literal(&self) -> &PresentableText {
        &self.literal
    }
    fn placement(&self) -> &EntityRef {
        &self.placement
    }
    fn alignment(&self) -> &TextAlignment {
        &self.alignment
    }
    fn path(&self) -> &TextPath {
        &self.path
    }
    fn font(&self) -> &EntityRef {
        &self.font
    }
}
impl TextLiteral {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = TextLiteral::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => entity.literal = parameter.into(),
                2usize => entity.placement = parameter.into(),
                3usize => entity.alignment = parameter.into(),
                4usize => entity.path = parameter.into(),
                5usize => entity.font = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait ITextLiteralWithAssociatedCurves: ITextLiteral {
    fn associated_curves(&self) -> &HashSet<EntityRef>;
}
#[derive(Default, Debug)]
pub struct TextLiteralWithAssociatedCurves {
    name: Label,
    literal: PresentableText,
    placement: EntityRef,
    alignment: TextAlignment,
    path: TextPath,
    font: EntityRef,
    associated_curves: HashSet<EntityRef>,
}
impl IRepresentationItem for TextLiteralWithAssociatedCurves {
    fn name(&self) -> &Label {
        &self.name
    }
}
impl IGeometricRepresentationItem for TextLiteralWithAssociatedCurves {}
impl ITextLiteral for TextLiteralWithAssociatedCurves {
    fn literal(&self) -> &PresentableText {
        &self.literal
    }
    fn placement(&self) -> &EntityRef {
        &self.placement
    }
    fn alignment(&self) -> &TextAlignment {
        &self.alignment
    }
    fn path(&self) -> &TextPath {
        &self.path
    }
    fn font(&self) -> &EntityRef {
        &self.font
    }
}
impl ITextLiteralWithAssociatedCurves for TextLiteralWithAssociatedCurves {
    fn associated_curves(&self) -> &HashSet<EntityRef> {
        &self.associated_curves
    }
}
impl TextLiteralWithAssociatedCurves {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = TextLiteralWithAssociatedCurves::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => entity.literal = parameter.into(),
                2usize => entity.placement = parameter.into(),
                3usize => entity.alignment = parameter.into(),
                4usize => entity.path = parameter.into(),
                5usize => entity.font = parameter.into(),
                6usize => entity.associated_curves = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait ITextLiteralWithBlankingBox: ITextLiteral {
    fn blanking(&self) -> &EntityRef;
}
#[derive(Default, Debug)]
pub struct TextLiteralWithBlankingBox {
    name: Label,
    literal: PresentableText,
    placement: EntityRef,
    alignment: TextAlignment,
    path: TextPath,
    font: EntityRef,
    blanking: EntityRef,
}
impl IRepresentationItem for TextLiteralWithBlankingBox {
    fn name(&self) -> &Label {
        &self.name
    }
}
impl IGeometricRepresentationItem for TextLiteralWithBlankingBox {}
impl ITextLiteral for TextLiteralWithBlankingBox {
    fn literal(&self) -> &PresentableText {
        &self.literal
    }
    fn placement(&self) -> &EntityRef {
        &self.placement
    }
    fn alignment(&self) -> &TextAlignment {
        &self.alignment
    }
    fn path(&self) -> &TextPath {
        &self.path
    }
    fn font(&self) -> &EntityRef {
        &self.font
    }
}
impl ITextLiteralWithBlankingBox for TextLiteralWithBlankingBox {
    fn blanking(&self) -> &EntityRef {
        &self.blanking
    }
}
impl TextLiteralWithBlankingBox {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = TextLiteralWithBlankingBox::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => entity.literal = parameter.into(),
                2usize => entity.placement = parameter.into(),
                3usize => entity.alignment = parameter.into(),
                4usize => entity.path = parameter.into(),
                5usize => entity.font = parameter.into(),
                6usize => entity.blanking = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait ITextLiteralWithDelineation: ITextLiteral {
    fn delineation(&self) -> &TextDelineation;
}
#[derive(Default, Debug)]
pub struct TextLiteralWithDelineation {
    name: Label,
    literal: PresentableText,
    placement: EntityRef,
    alignment: TextAlignment,
    path: TextPath,
    font: EntityRef,
    delineation: TextDelineation,
}
impl IRepresentationItem for TextLiteralWithDelineation {
    fn name(&self) -> &Label {
        &self.name
    }
}
impl IGeometricRepresentationItem for TextLiteralWithDelineation {}
impl ITextLiteral for TextLiteralWithDelineation {
    fn literal(&self) -> &PresentableText {
        &self.literal
    }
    fn placement(&self) -> &EntityRef {
        &self.placement
    }
    fn alignment(&self) -> &TextAlignment {
        &self.alignment
    }
    fn path(&self) -> &TextPath {
        &self.path
    }
    fn font(&self) -> &EntityRef {
        &self.font
    }
}
impl ITextLiteralWithDelineation for TextLiteralWithDelineation {
    fn delineation(&self) -> &TextDelineation {
        &self.delineation
    }
}
impl TextLiteralWithDelineation {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = TextLiteralWithDelineation::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => entity.literal = parameter.into(),
                2usize => entity.placement = parameter.into(),
                3usize => entity.alignment = parameter.into(),
                4usize => entity.path = parameter.into(),
                5usize => entity.font = parameter.into(),
                6usize => entity.delineation = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait ITextLiteralWithExtent: ITextLiteral {
    fn extent(&self) -> &EntityRef;
}
#[derive(Default, Debug)]
pub struct TextLiteralWithExtent {
    name: Label,
    literal: PresentableText,
    placement: EntityRef,
    alignment: TextAlignment,
    path: TextPath,
    font: EntityRef,
    extent: EntityRef,
}
impl IRepresentationItem for TextLiteralWithExtent {
    fn name(&self) -> &Label {
        &self.name
    }
}
impl IGeometricRepresentationItem for TextLiteralWithExtent {}
impl ITextLiteral for TextLiteralWithExtent {
    fn literal(&self) -> &PresentableText {
        &self.literal
    }
    fn placement(&self) -> &EntityRef {
        &self.placement
    }
    fn alignment(&self) -> &TextAlignment {
        &self.alignment
    }
    fn path(&self) -> &TextPath {
        &self.path
    }
    fn font(&self) -> &EntityRef {
        &self.font
    }
}
impl ITextLiteralWithExtent for TextLiteralWithExtent {
    fn extent(&self) -> &EntityRef {
        &self.extent
    }
}
impl TextLiteralWithExtent {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = TextLiteralWithExtent::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => entity.literal = parameter.into(),
                2usize => entity.placement = parameter.into(),
                3usize => entity.alignment = parameter.into(),
                4usize => entity.path = parameter.into(),
                5usize => entity.font = parameter.into(),
                6usize => entity.extent = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait ITextStringRepresentation: IRepresentation {
    fn items(&self) -> &HashSet<EntityRef>;
}
#[derive(Default, Debug)]
pub struct TextStringRepresentation {
    name: Label,
    context_of_items: EntityRef,
    items: HashSet<EntityRef>,
}
impl IRepresentation for TextStringRepresentation {
    fn name(&self) -> &Label {
        &self.name
    }
    fn items(&self) -> &HashSet<EntityRef> {
        &self.items
    }
    fn context_of_items(&self) -> &EntityRef {
        &self.context_of_items
    }
}
impl ITextStringRepresentation for TextStringRepresentation {
    fn items(&self) -> &HashSet<EntityRef> {
        &self.items
    }
}
impl TextStringRepresentation {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = TextStringRepresentation::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => entity.context_of_items = parameter.into(),
                2usize => entity.items = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait ITextStyle: IFoundedItem {
    fn name(&self) -> &Label;
    fn character_appearance(&self) -> &EntityRef;
}
#[derive(Default, Debug)]
pub struct TextStyle {
    name: Label,
    character_appearance: EntityRef,
}
impl IFoundedItem for TextStyle {}
impl ITextStyle for TextStyle {
    fn name(&self) -> &Label {
        &self.name
    }
    fn character_appearance(&self) -> &EntityRef {
        &self.character_appearance
    }
}
impl TextStyle {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = TextStyle::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => entity.character_appearance = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait ITextStyleForDefinedFont {
    fn text_colour(&self) -> &EntityRef;
}
#[derive(Default, Debug)]
pub struct TextStyleForDefinedFont {
    text_colour: EntityRef,
}
impl ITextStyleForDefinedFont for TextStyleForDefinedFont {
    fn text_colour(&self) -> &EntityRef {
        &self.text_colour
    }
}
impl TextStyleForDefinedFont {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = TextStyleForDefinedFont::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.text_colour = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait ITextStyleWithBoxCharacteristics: ITextStyle {
    fn characteristics(&self) -> &HashSet<BoxCharacteristicSelect>;
}
#[derive(Default, Debug)]
pub struct TextStyleWithBoxCharacteristics {
    name: Label,
    character_appearance: EntityRef,
    characteristics: HashSet<BoxCharacteristicSelect>,
}
impl IFoundedItem for TextStyleWithBoxCharacteristics {}
impl ITextStyle for TextStyleWithBoxCharacteristics {
    fn name(&self) -> &Label {
        &self.name
    }
    fn character_appearance(&self) -> &EntityRef {
        &self.character_appearance
    }
}
impl ITextStyleWithBoxCharacteristics for TextStyleWithBoxCharacteristics {
    fn characteristics(&self) -> &HashSet<BoxCharacteristicSelect> {
        &self.characteristics
    }
}
impl TextStyleWithBoxCharacteristics {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = TextStyleWithBoxCharacteristics::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => entity.character_appearance = parameter.into(),
                2usize => entity.characteristics = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait ITextStyleWithMirror: ITextStyle {
    fn mirror_placement(&self) -> &EntityRef;
}
#[derive(Default, Debug)]
pub struct TextStyleWithMirror {
    name: Label,
    character_appearance: EntityRef,
    mirror_placement: EntityRef,
}
impl IFoundedItem for TextStyleWithMirror {}
impl ITextStyle for TextStyleWithMirror {
    fn name(&self) -> &Label {
        &self.name
    }
    fn character_appearance(&self) -> &EntityRef {
        &self.character_appearance
    }
}
impl ITextStyleWithMirror for TextStyleWithMirror {
    fn mirror_placement(&self) -> &EntityRef {
        &self.mirror_placement
    }
}
impl TextStyleWithMirror {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = TextStyleWithMirror::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => entity.character_appearance = parameter.into(),
                2usize => entity.mirror_placement = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait ITextStyleWithSpacing: ITextStyle {
    fn character_spacing(&self) -> &CharacterSpacingSelect;
}
#[derive(Default, Debug)]
pub struct TextStyleWithSpacing {
    name: Label,
    character_appearance: EntityRef,
    character_spacing: CharacterSpacingSelect,
}
impl IFoundedItem for TextStyleWithSpacing {}
impl ITextStyle for TextStyleWithSpacing {
    fn name(&self) -> &Label {
        &self.name
    }
    fn character_appearance(&self) -> &EntityRef {
        &self.character_appearance
    }
}
impl ITextStyleWithSpacing for TextStyleWithSpacing {
    fn character_spacing(&self) -> &CharacterSpacingSelect {
        &self.character_spacing
    }
}
impl TextStyleWithSpacing {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = TextStyleWithSpacing::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => entity.character_appearance = parameter.into(),
                2usize => entity.character_spacing = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IThermalResistanceMeasureWithUnit: IMeasureWithUnit {}
#[derive(Default, Debug)]
pub struct ThermalResistanceMeasureWithUnit {
    value_component: MeasureValue,
    unit_component: EntityRef,
}
impl IMeasureWithUnit for ThermalResistanceMeasureWithUnit {
    fn value_component(&self) -> &MeasureValue {
        &self.value_component
    }
    fn unit_component(&self) -> &EntityRef {
        &self.unit_component
    }
}
impl IThermalResistanceMeasureWithUnit for ThermalResistanceMeasureWithUnit {}
impl ThermalResistanceMeasureWithUnit {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = ThermalResistanceMeasureWithUnit::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.value_component = parameter.into(),
                1usize => entity.unit_component = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IThermalResistanceUnit: IDerivedUnit {}
#[derive(Default, Debug)]
pub struct ThermalResistanceUnit {
    elements: HashSet<EntityRef>,
}
impl IDerivedUnit for ThermalResistanceUnit {
    fn elements(&self) -> &HashSet<EntityRef> {
        &self.elements
    }
}
impl IThermalResistanceUnit for ThermalResistanceUnit {}
impl ThermalResistanceUnit {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = ThermalResistanceUnit::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.elements = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IThermodynamicTemperatureMeasureWithUnit: IMeasureWithUnit {}
#[derive(Default, Debug)]
pub struct ThermodynamicTemperatureMeasureWithUnit {
    value_component: MeasureValue,
    unit_component: EntityRef,
}
impl IMeasureWithUnit for ThermodynamicTemperatureMeasureWithUnit {
    fn value_component(&self) -> &MeasureValue {
        &self.value_component
    }
    fn unit_component(&self) -> &EntityRef {
        &self.unit_component
    }
}
impl IThermodynamicTemperatureMeasureWithUnit for ThermodynamicTemperatureMeasureWithUnit {}
impl ThermodynamicTemperatureMeasureWithUnit {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = ThermodynamicTemperatureMeasureWithUnit::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.value_component = parameter.into(),
                1usize => entity.unit_component = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IThermodynamicTemperatureUnit: INamedUnit {}
#[derive(Default, Debug)]
pub struct ThermodynamicTemperatureUnit {
    dimensions: EntityRef,
}
impl INamedUnit for ThermodynamicTemperatureUnit {
    fn dimensions(&self) -> &EntityRef {
        &self.dimensions
    }
}
impl IThermodynamicTemperatureUnit for ThermodynamicTemperatureUnit {}
impl ThermodynamicTemperatureUnit {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = ThermodynamicTemperatureUnit::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.dimensions = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IThickenedFaceSolid: ISolidModel {
    fn base_element(&self) -> &EntityRef;
    fn offset1(&self) -> &LengthMeasure;
    fn offset2(&self) -> &LengthMeasure;
}
#[derive(Default, Debug)]
pub struct ThickenedFaceSolid {
    name: Label,
    base_element: EntityRef,
    offset1: LengthMeasure,
    offset2: LengthMeasure,
}
impl IRepresentationItem for ThickenedFaceSolid {
    fn name(&self) -> &Label {
        &self.name
    }
}
impl IGeometricRepresentationItem for ThickenedFaceSolid {}
impl ISolidModel for ThickenedFaceSolid {}
impl IThickenedFaceSolid for ThickenedFaceSolid {
    fn base_element(&self) -> &EntityRef {
        &self.base_element
    }
    fn offset1(&self) -> &LengthMeasure {
        &self.offset1
    }
    fn offset2(&self) -> &LengthMeasure {
        &self.offset2
    }
}
impl ThickenedFaceSolid {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = ThickenedFaceSolid::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => entity.base_element = parameter.into(),
                2usize => entity.offset1 = parameter.into(),
                3usize => entity.offset2 = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IThicknessLaminateDefinition: IProductDefinition {}
#[derive(Default, Debug)]
pub struct ThicknessLaminateDefinition {
    id: Identifier,
    description: Option<Text>,
    formation: EntityRef,
    frame_of_reference: EntityRef,
}
impl IProductDefinition for ThicknessLaminateDefinition {
    fn id(&self) -> &Identifier {
        &self.id
    }
    fn description(&self) -> &Option<Text> {
        &self.description
    }
    fn formation(&self) -> &EntityRef {
        &self.formation
    }
    fn frame_of_reference(&self) -> &EntityRef {
        &self.frame_of_reference
    }
}
impl IThicknessLaminateDefinition for ThicknessLaminateDefinition {}
impl ThicknessLaminateDefinition {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = ThicknessLaminateDefinition::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.id = parameter.into(),
                1usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => entity.formation = parameter.into(),
                3usize => entity.frame_of_reference = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IThicknessLaminateTable: IZoneStructuralMakeup {}
#[derive(Default, Debug)]
pub struct ThicknessLaminateTable {
    id: Identifier,
    description: Option<Text>,
    formation: EntityRef,
    frame_of_reference: EntityRef,
}
impl IProductDefinition for ThicknessLaminateTable {
    fn id(&self) -> &Identifier {
        &self.id
    }
    fn description(&self) -> &Option<Text> {
        &self.description
    }
    fn formation(&self) -> &EntityRef {
        &self.formation
    }
    fn frame_of_reference(&self) -> &EntityRef {
        &self.frame_of_reference
    }
}
impl ILaminateTable for ThicknessLaminateTable {}
impl IZoneStructuralMakeup for ThicknessLaminateTable {}
impl IThicknessLaminateTable for ThicknessLaminateTable {}
impl ThicknessLaminateTable {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = ThicknessLaminateTable::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.id = parameter.into(),
                1usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => entity.formation = parameter.into(),
                3usize => entity.frame_of_reference = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait ITimeInterval {
    fn id(&self) -> &Identifier;
    fn name(&self) -> &Label;
    fn description(&self) -> &Option<Text>;
}
#[derive(Default, Debug)]
pub struct TimeInterval {
    id: Identifier,
    name: Label,
    description: Option<Text>,
}
impl ITimeInterval for TimeInterval {
    fn id(&self) -> &Identifier {
        &self.id
    }
    fn name(&self) -> &Label {
        &self.name
    }
    fn description(&self) -> &Option<Text> {
        &self.description
    }
}
impl TimeInterval {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = TimeInterval::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.id = parameter.into(),
                1usize => entity.name = parameter.into(),
                2usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
}
pub trait ITimeIntervalAssignment {
    fn assigned_time_interval(&self) -> &EntityRef;
    fn role(&self) -> &EntityRef;
}
pub trait ITimeIntervalBasedEffectivity: IEffectivity {
    fn effectivity_period(&self) -> &EntityRef;
}
#[derive(Default, Debug)]
pub struct TimeIntervalBasedEffectivity {
    id: Identifier,
    effectivity_period: EntityRef,
}
impl IEffectivity for TimeIntervalBasedEffectivity {
    fn id(&self) -> &Identifier {
        &self.id
    }
}
impl ITimeIntervalBasedEffectivity for TimeIntervalBasedEffectivity {
    fn effectivity_period(&self) -> &EntityRef {
        &self.effectivity_period
    }
}
impl TimeIntervalBasedEffectivity {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = TimeIntervalBasedEffectivity::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.id = parameter.into(),
                1usize => entity.effectivity_period = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait ITimeIntervalRelationship {
    fn name(&self) -> &Label;
    fn description(&self) -> &Option<Text>;
    fn relating_time_interval(&self) -> &EntityRef;
    fn related_time_interval(&self) -> &EntityRef;
}
#[derive(Default, Debug)]
pub struct TimeIntervalRelationship {
    name: Label,
    description: Option<Text>,
    relating_time_interval: EntityRef,
    related_time_interval: EntityRef,
}
impl ITimeIntervalRelationship for TimeIntervalRelationship {
    fn name(&self) -> &Label {
        &self.name
    }
    fn description(&self) -> &Option<Text> {
        &self.description
    }
    fn relating_time_interval(&self) -> &EntityRef {
        &self.relating_time_interval
    }
    fn related_time_interval(&self) -> &EntityRef {
        &self.related_time_interval
    }
}
impl TimeIntervalRelationship {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = TimeIntervalRelationship::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => entity.relating_time_interval = parameter.into(),
                3usize => entity.related_time_interval = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait ITimeIntervalRole {
    fn name(&self) -> &Label;
    fn description(&self) -> &Option<Text>;
}
#[derive(Default, Debug)]
pub struct TimeIntervalRole {
    name: Label,
    description: Option<Text>,
}
impl ITimeIntervalRole for TimeIntervalRole {
    fn name(&self) -> &Label {
        &self.name
    }
    fn description(&self) -> &Option<Text> {
        &self.description
    }
}
impl TimeIntervalRole {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = TimeIntervalRole::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
}
pub trait ITimeIntervalWithBounds: ITimeInterval {
    fn primary_bound(&self) -> &Option<EntityRef>;
    fn secondary_bound(&self) -> &Option<EntityRef>;
    fn duration(&self) -> &Option<EntityRef>;
}
#[derive(Default, Debug)]
pub struct TimeIntervalWithBounds {
    id: Identifier,
    name: Label,
    description: Option<Text>,
    primary_bound: Option<EntityRef>,
    secondary_bound: Option<EntityRef>,
    duration: Option<EntityRef>,
}
impl ITimeInterval for TimeIntervalWithBounds {
    fn id(&self) -> &Identifier {
        &self.id
    }
    fn name(&self) -> &Label {
        &self.name
    }
    fn description(&self) -> &Option<Text> {
        &self.description
    }
}
impl ITimeIntervalWithBounds for TimeIntervalWithBounds {
    fn primary_bound(&self) -> &Option<EntityRef> {
        &self.primary_bound
    }
    fn secondary_bound(&self) -> &Option<EntityRef> {
        &self.secondary_bound
    }
    fn duration(&self) -> &Option<EntityRef> {
        &self.duration
    }
}
impl TimeIntervalWithBounds {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = TimeIntervalWithBounds::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.id = parameter.into(),
                1usize => entity.name = parameter.into(),
                2usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.primary_bound = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => {
                    entity.secondary_bound = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                5usize => {
                    entity.duration = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
}
pub trait ITimeMeasureWithUnit: IMeasureWithUnit {}
#[derive(Default, Debug)]
pub struct TimeMeasureWithUnit {
    value_component: MeasureValue,
    unit_component: EntityRef,
}
impl IMeasureWithUnit for TimeMeasureWithUnit {
    fn value_component(&self) -> &MeasureValue {
        &self.value_component
    }
    fn unit_component(&self) -> &EntityRef {
        &self.unit_component
    }
}
impl ITimeMeasureWithUnit for TimeMeasureWithUnit {}
impl TimeMeasureWithUnit {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = TimeMeasureWithUnit::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.value_component = parameter.into(),
                1usize => entity.unit_component = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait ITimeUnit: INamedUnit {}
#[derive(Default, Debug)]
pub struct TimeUnit {
    dimensions: EntityRef,
}
impl INamedUnit for TimeUnit {
    fn dimensions(&self) -> &EntityRef {
        &self.dimensions
    }
}
impl ITimeUnit for TimeUnit {}
impl TimeUnit {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = TimeUnit::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.dimensions = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IToleranceValue {
    fn lower_bound(&self) -> &EntityRef;
    fn upper_bound(&self) -> &EntityRef;
}
#[derive(Default, Debug)]
pub struct ToleranceValue {
    lower_bound: EntityRef,
    upper_bound: EntityRef,
}
impl IToleranceValue for ToleranceValue {
    fn lower_bound(&self) -> &EntityRef {
        &self.lower_bound
    }
    fn upper_bound(&self) -> &EntityRef {
        &self.upper_bound
    }
}
impl ToleranceValue {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = ToleranceValue::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.lower_bound = parameter.into(),
                1usize => entity.upper_bound = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IToleranceZone: IShapeAspect {
    fn defining_tolerance(&self) -> &HashSet<EntityRef>;
    fn form(&self) -> &EntityRef;
}
#[derive(Default, Debug)]
pub struct ToleranceZone {
    name: Label,
    description: Option<Text>,
    of_shape: EntityRef,
    product_definitional: Option<bool>,
    defining_tolerance: HashSet<EntityRef>,
    form: EntityRef,
}
impl IShapeAspect for ToleranceZone {
    fn name(&self) -> &Label {
        &self.name
    }
    fn description(&self) -> &Option<Text> {
        &self.description
    }
    fn of_shape(&self) -> &EntityRef {
        &self.of_shape
    }
    fn product_definitional(&self) -> Option<bool> {
        self.product_definitional
    }
}
impl IToleranceZone for ToleranceZone {
    fn defining_tolerance(&self) -> &HashSet<EntityRef> {
        &self.defining_tolerance
    }
    fn form(&self) -> &EntityRef {
        &self.form
    }
}
impl ToleranceZone {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = ToleranceZone::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => entity.of_shape = parameter.into(),
                3usize => entity.product_definitional = parameter.into(),
                4usize => entity.defining_tolerance = parameter.into(),
                5usize => entity.form = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IToleranceZoneDefinition {
    fn zone(&self) -> &EntityRef;
    fn boundaries(&self) -> &HashSet<EntityRef>;
}
#[derive(Default, Debug)]
pub struct ToleranceZoneDefinition {
    zone: EntityRef,
    boundaries: HashSet<EntityRef>,
}
impl IToleranceZoneDefinition for ToleranceZoneDefinition {
    fn zone(&self) -> &EntityRef {
        &self.zone
    }
    fn boundaries(&self) -> &HashSet<EntityRef> {
        &self.boundaries
    }
}
impl ToleranceZoneDefinition {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = ToleranceZoneDefinition::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.zone = parameter.into(),
                1usize => entity.boundaries = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IToleranceZoneForm {
    fn name(&self) -> &Label;
}
#[derive(Default, Debug)]
pub struct ToleranceZoneForm {
    name: Label,
}
impl IToleranceZoneForm for ToleranceZoneForm {
    fn name(&self) -> &Label {
        &self.name
    }
}
impl ToleranceZoneForm {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = ToleranceZoneForm::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait ITopologicalRepresentationItem: IRepresentationItem {}
#[derive(Default, Debug)]
pub struct TopologicalRepresentationItem {
    name: Label,
}
impl IRepresentationItem for TopologicalRepresentationItem {
    fn name(&self) -> &Label {
        &self.name
    }
}
impl ITopologicalRepresentationItem for TopologicalRepresentationItem {}
impl TopologicalRepresentationItem {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = TopologicalRepresentationItem::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IToroidalSurface: IElementarySurface {
    fn major_radius(&self) -> &PositiveLengthMeasure;
    fn minor_radius(&self) -> &PositiveLengthMeasure;
}
#[derive(Default, Debug)]
pub struct ToroidalSurface {
    name: Label,
    position: EntityRef,
    major_radius: PositiveLengthMeasure,
    minor_radius: PositiveLengthMeasure,
}
impl IRepresentationItem for ToroidalSurface {
    fn name(&self) -> &Label {
        &self.name
    }
}
impl IGeometricRepresentationItem for ToroidalSurface {}
impl ISurface for ToroidalSurface {}
impl IElementarySurface for ToroidalSurface {
    fn position(&self) -> &EntityRef {
        &self.position
    }
}
impl IToroidalSurface for ToroidalSurface {
    fn major_radius(&self) -> &PositiveLengthMeasure {
        &self.major_radius
    }
    fn minor_radius(&self) -> &PositiveLengthMeasure {
        &self.minor_radius
    }
}
impl ToroidalSurface {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = ToroidalSurface::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => entity.position = parameter.into(),
                2usize => entity.major_radius = parameter.into(),
                3usize => entity.minor_radius = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait ITorus: IGeometricRepresentationItem {
    fn position(&self) -> &EntityRef;
    fn major_radius(&self) -> &PositiveLengthMeasure;
    fn minor_radius(&self) -> &PositiveLengthMeasure;
}
#[derive(Default, Debug)]
pub struct Torus {
    name: Label,
    position: EntityRef,
    major_radius: PositiveLengthMeasure,
    minor_radius: PositiveLengthMeasure,
}
impl IRepresentationItem for Torus {
    fn name(&self) -> &Label {
        &self.name
    }
}
impl IGeometricRepresentationItem for Torus {}
impl ITorus for Torus {
    fn position(&self) -> &EntityRef {
        &self.position
    }
    fn major_radius(&self) -> &PositiveLengthMeasure {
        &self.major_radius
    }
    fn minor_radius(&self) -> &PositiveLengthMeasure {
        &self.minor_radius
    }
}
impl Torus {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = Torus::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => entity.position = parameter.into(),
                2usize => entity.major_radius = parameter.into(),
                3usize => entity.minor_radius = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait ITotalRunoutTolerance: IGeometricToleranceWithDatumReference {}
#[derive(Default, Debug)]
pub struct TotalRunoutTolerance {
    name: Label,
    description: Text,
    magnitude: EntityRef,
    toleranced_shape_aspect: EntityRef,
    datum_system: HashSet<EntityRef>,
}
impl IGeometricTolerance for TotalRunoutTolerance {
    fn name(&self) -> &Label {
        &self.name
    }
    fn description(&self) -> &Text {
        &self.description
    }
    fn magnitude(&self) -> &EntityRef {
        &self.magnitude
    }
    fn toleranced_shape_aspect(&self) -> &EntityRef {
        &self.toleranced_shape_aspect
    }
}
impl IGeometricToleranceWithDatumReference for TotalRunoutTolerance {
    fn datum_system(&self) -> &HashSet<EntityRef> {
        &self.datum_system
    }
}
impl ITotalRunoutTolerance for TotalRunoutTolerance {}
impl TotalRunoutTolerance {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = TotalRunoutTolerance::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => entity.description = parameter.into(),
                2usize => entity.magnitude = parameter.into(),
                3usize => entity.toleranced_shape_aspect = parameter.into(),
                4usize => entity.datum_system = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait ITrackBlendedSolid: IEdgeBlendedSolid {}
pub trait ITrackBlendedSolidWithEndConditions: ITrackBlendedSolid {
    fn end_conditions(&self) -> &Vec<EntityRef>;
}
#[derive(Default, Debug)]
pub struct TrackBlendedSolidWithEndConditions {
    name: Label,
    rationale: Text,
    base_solid: EntityRef,
    blended_edges: Vec<EntityRef>,
    end_conditions: Vec<EntityRef>,
}
impl IRepresentationItem for TrackBlendedSolidWithEndConditions {
    fn name(&self) -> &Label {
        &self.name
    }
}
impl IGeometricRepresentationItem for TrackBlendedSolidWithEndConditions {}
impl ISolidModel for TrackBlendedSolidWithEndConditions {}
impl IModifiedSolid for TrackBlendedSolidWithEndConditions {
    fn rationale(&self) -> &Text {
        &self.rationale
    }
    fn base_solid(&self) -> &EntityRef {
        &self.base_solid
    }
}
impl IEdgeBlendedSolid for TrackBlendedSolidWithEndConditions {
    fn blended_edges(&self) -> &Vec<EntityRef> {
        &self.blended_edges
    }
}
impl ITrackBlendedSolid for TrackBlendedSolidWithEndConditions {}
impl ITrackBlendedSolidWithEndConditions for TrackBlendedSolidWithEndConditions {
    fn end_conditions(&self) -> &Vec<EntityRef> {
        &self.end_conditions
    }
}
impl TrackBlendedSolidWithEndConditions {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = TrackBlendedSolidWithEndConditions::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => entity.rationale = parameter.into(),
                2usize => entity.base_solid = parameter.into(),
                3usize => entity.blended_edges = parameter.into(),
                4usize => entity.end_conditions = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait ITransformationWithDerivedAngle: IItemDefinedTransformation {
    fn transform_item_1(&self) -> &EntityRef;
    fn transform_item_2(&self) -> &EntityRef;
}
#[derive(Default, Debug)]
pub struct TransformationWithDerivedAngle {
    name: Label,
    description: Option<Text>,
    transform_item_1: EntityRef,
    transform_item_2: EntityRef,
}
impl IItemDefinedTransformation for TransformationWithDerivedAngle {
    fn name(&self) -> &Label {
        &self.name
    }
    fn description(&self) -> &Option<Text> {
        &self.description
    }
    fn transform_item_1(&self) -> &EntityRef {
        &self.transform_item_1
    }
    fn transform_item_2(&self) -> &EntityRef {
        &self.transform_item_2
    }
}
impl ITransformationWithDerivedAngle for TransformationWithDerivedAngle {
    fn transform_item_1(&self) -> &EntityRef {
        &self.transform_item_1
    }
    fn transform_item_2(&self) -> &EntityRef {
        &self.transform_item_2
    }
}
impl TransformationWithDerivedAngle {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = TransformationWithDerivedAngle::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => entity.transform_item_1 = parameter.into(),
                3usize => entity.transform_item_2 = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait ITrimmedCurve: IBoundedCurve {
    fn basis_curve(&self) -> &EntityRef;
    fn trim_1(&self) -> &HashSet<TrimmingSelect>;
    fn trim_2(&self) -> &HashSet<TrimmingSelect>;
    fn sense_agreement(&self) -> bool;
    fn master_representation(&self) -> &TrimmingPreference;
}
#[derive(Default, Debug)]
pub struct TrimmedCurve {
    name: Label,
    basis_curve: EntityRef,
    trim_1: HashSet<TrimmingSelect>,
    trim_2: HashSet<TrimmingSelect>,
    sense_agreement: bool,
    master_representation: TrimmingPreference,
}
impl IRepresentationItem for TrimmedCurve {
    fn name(&self) -> &Label {
        &self.name
    }
}
impl IGeometricRepresentationItem for TrimmedCurve {}
impl ICurve for TrimmedCurve {}
impl IBoundedCurve for TrimmedCurve {}
impl ITrimmedCurve for TrimmedCurve {
    fn basis_curve(&self) -> &EntityRef {
        &self.basis_curve
    }
    fn trim_1(&self) -> &HashSet<TrimmingSelect> {
        &self.trim_1
    }
    fn trim_2(&self) -> &HashSet<TrimmingSelect> {
        &self.trim_2
    }
    fn sense_agreement(&self) -> bool {
        self.sense_agreement
    }
    fn master_representation(&self) -> &TrimmingPreference {
        &self.master_representation
    }
}
impl TrimmedCurve {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = TrimmedCurve::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => entity.basis_curve = parameter.into(),
                2usize => entity.trim_1 = parameter.into(),
                3usize => entity.trim_2 = parameter.into(),
                4usize => entity.sense_agreement = parameter.into(),
                5usize => entity.master_representation = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait ITwoDirectionRepeatFactor: IOneDirectionRepeatFactor {
    fn second_repeat_factor(&self) -> &EntityRef;
}
#[derive(Default, Debug)]
pub struct TwoDirectionRepeatFactor {
    name: Label,
    repeat_factor: EntityRef,
    second_repeat_factor: EntityRef,
}
impl IRepresentationItem for TwoDirectionRepeatFactor {
    fn name(&self) -> &Label {
        &self.name
    }
}
impl IGeometricRepresentationItem for TwoDirectionRepeatFactor {}
impl IOneDirectionRepeatFactor for TwoDirectionRepeatFactor {
    fn repeat_factor(&self) -> &EntityRef {
        &self.repeat_factor
    }
}
impl ITwoDirectionRepeatFactor for TwoDirectionRepeatFactor {
    fn second_repeat_factor(&self) -> &EntityRef {
        &self.second_repeat_factor
    }
}
impl TwoDirectionRepeatFactor {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = TwoDirectionRepeatFactor::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => entity.repeat_factor = parameter.into(),
                2usize => entity.second_repeat_factor = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait ITypeQualifier {
    fn name(&self) -> &Label;
}
#[derive(Default, Debug)]
pub struct TypeQualifier {
    name: Label,
}
impl ITypeQualifier for TypeQualifier {
    fn name(&self) -> &Label {
        &self.name
    }
}
impl TypeQualifier {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = TypeQualifier::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IUnaryGenericExpression: IGenericExpression {
    fn operand(&self) -> &EntityRef;
}
pub trait IUnaryNumericExpression: INumericExpression + IUnaryGenericExpression {
    fn operand(&self) -> &EntityRef;
}
pub trait IUncertaintyAssignedRepresentation: IRepresentation {
    fn uncertainty(&self) -> &HashSet<EntityRef>;
}
#[derive(Default, Debug)]
pub struct UncertaintyAssignedRepresentation {
    name: Label,
    items: HashSet<EntityRef>,
    context_of_items: EntityRef,
    uncertainty: HashSet<EntityRef>,
}
impl IRepresentation for UncertaintyAssignedRepresentation {
    fn name(&self) -> &Label {
        &self.name
    }
    fn items(&self) -> &HashSet<EntityRef> {
        &self.items
    }
    fn context_of_items(&self) -> &EntityRef {
        &self.context_of_items
    }
}
impl IUncertaintyAssignedRepresentation for UncertaintyAssignedRepresentation {
    fn uncertainty(&self) -> &HashSet<EntityRef> {
        &self.uncertainty
    }
}
impl UncertaintyAssignedRepresentation {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = UncertaintyAssignedRepresentation::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => entity.items = parameter.into(),
                2usize => entity.context_of_items = parameter.into(),
                3usize => entity.uncertainty = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IUncertaintyMeasureWithUnit: IMeasureWithUnit {
    fn name(&self) -> &Label;
    fn description(&self) -> &Option<Text>;
}
#[derive(Default, Debug)]
pub struct UncertaintyMeasureWithUnit {
    value_component: MeasureValue,
    unit_component: EntityRef,
    name: Label,
    description: Option<Text>,
}
impl IMeasureWithUnit for UncertaintyMeasureWithUnit {
    fn value_component(&self) -> &MeasureValue {
        &self.value_component
    }
    fn unit_component(&self) -> &EntityRef {
        &self.unit_component
    }
}
impl IUncertaintyMeasureWithUnit for UncertaintyMeasureWithUnit {
    fn name(&self) -> &Label {
        &self.name
    }
    fn description(&self) -> &Option<Text> {
        &self.description
    }
}
impl UncertaintyMeasureWithUnit {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = UncertaintyMeasureWithUnit::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.value_component = parameter.into(),
                1usize => entity.unit_component = parameter.into(),
                2usize => entity.name = parameter.into(),
                3usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
}
pub trait IUncertaintyQualifier {
    fn measure_name(&self) -> &Label;
    fn description(&self) -> &Text;
}
#[derive(Default, Debug)]
pub struct UncertaintyQualifier {
    measure_name: Label,
    description: Text,
}
impl IUncertaintyQualifier for UncertaintyQualifier {
    fn measure_name(&self) -> &Label {
        &self.measure_name
    }
    fn description(&self) -> &Text {
        &self.description
    }
}
impl UncertaintyQualifier {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = UncertaintyQualifier::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.measure_name = parameter.into(),
                1usize => entity.description = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IUniformCurve: IBSplineCurve {}
#[derive(Default, Debug)]
pub struct UniformCurve {
    name: Label,
    degree: i64,
    control_points_list: Vec<EntityRef>,
    curve_form: BSplineCurveForm,
    closed_curve: Option<bool>,
    self_intersect: Option<bool>,
}
impl IRepresentationItem for UniformCurve {
    fn name(&self) -> &Label {
        &self.name
    }
}
impl IGeometricRepresentationItem for UniformCurve {}
impl ICurve for UniformCurve {}
impl IBoundedCurve for UniformCurve {}
impl IBSplineCurve for UniformCurve {
    fn degree(&self) -> i64 {
        self.degree
    }
    fn control_points_list(&self) -> &Vec<EntityRef> {
        &self.control_points_list
    }
    fn curve_form(&self) -> &BSplineCurveForm {
        &self.curve_form
    }
    fn closed_curve(&self) -> Option<bool> {
        self.closed_curve
    }
    fn self_intersect(&self) -> Option<bool> {
        self.self_intersect
    }
}
impl IUniformCurve for UniformCurve {}
impl UniformCurve {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = UniformCurve::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => entity.degree = parameter.into(),
                2usize => entity.control_points_list = parameter.into(),
                3usize => entity.curve_form = parameter.into(),
                4usize => entity.closed_curve = parameter.into(),
                5usize => entity.self_intersect = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IUniformResourceIdentifier: IDescriptiveRepresentationItem {}
#[derive(Default, Debug)]
pub struct UniformResourceIdentifier {
    name: Label,
    description: Text,
}
impl IRepresentationItem for UniformResourceIdentifier {
    fn name(&self) -> &Label {
        &self.name
    }
}
impl IDescriptiveRepresentationItem for UniformResourceIdentifier {
    fn description(&self) -> &Text {
        &self.description
    }
}
impl IUniformResourceIdentifier for UniformResourceIdentifier {}
impl UniformResourceIdentifier {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = UniformResourceIdentifier::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => entity.description = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IUniformSurface: IBSplineSurface {}
#[derive(Default, Debug)]
pub struct UniformSurface {
    name: Label,
    u_degree: i64,
    v_degree: i64,
    control_points_list: Vec<Vec<EntityRef>>,
    surface_form: BSplineSurfaceForm,
    u_closed: Option<bool>,
    v_closed: Option<bool>,
    self_intersect: Option<bool>,
}
impl IRepresentationItem for UniformSurface {
    fn name(&self) -> &Label {
        &self.name
    }
}
impl IGeometricRepresentationItem for UniformSurface {}
impl ISurface for UniformSurface {}
impl IBoundedSurface for UniformSurface {}
impl IBSplineSurface for UniformSurface {
    fn u_degree(&self) -> i64 {
        self.u_degree
    }
    fn v_degree(&self) -> i64 {
        self.v_degree
    }
    fn control_points_list(&self) -> &Vec<Vec<EntityRef>> {
        &self.control_points_list
    }
    fn surface_form(&self) -> &BSplineSurfaceForm {
        &self.surface_form
    }
    fn u_closed(&self) -> Option<bool> {
        self.u_closed
    }
    fn v_closed(&self) -> Option<bool> {
        self.v_closed
    }
    fn self_intersect(&self) -> Option<bool> {
        self.self_intersect
    }
}
impl IUniformSurface for UniformSurface {}
impl UniformSurface {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = UniformSurface::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => entity.u_degree = parameter.into(),
                2usize => entity.v_degree = parameter.into(),
                3usize => entity.control_points_list = parameter.into(),
                4usize => entity.surface_form = parameter.into(),
                5usize => entity.u_closed = parameter.into(),
                6usize => entity.v_closed = parameter.into(),
                7usize => entity.self_intersect = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IUsageAssociation: IActionMethodRelationship {
    fn related_method(&self) -> &EntityRef;
    fn relating_method(&self) -> &EntityRef;
}
#[derive(Default, Debug)]
pub struct UsageAssociation {
    name: Label,
    description: Option<Text>,
    related_method: EntityRef,
    relating_method: EntityRef,
}
impl IActionMethodRelationship for UsageAssociation {
    fn name(&self) -> &Label {
        &self.name
    }
    fn description(&self) -> &Option<Text> {
        &self.description
    }
    fn relating_method(&self) -> &EntityRef {
        &self.relating_method
    }
    fn related_method(&self) -> &EntityRef {
        &self.related_method
    }
}
impl IUsageAssociation for UsageAssociation {
    fn related_method(&self) -> &EntityRef {
        &self.related_method
    }
    fn relating_method(&self) -> &EntityRef {
        &self.relating_method
    }
}
impl UsageAssociation {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = UsageAssociation::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => entity.related_method = parameter.into(),
                3usize => entity.relating_method = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IUserDefinedCurveFont: ICurveStyleFont + IMappedItem {}
#[derive(Default, Debug)]
pub struct UserDefinedCurveFont {
    name: Label,
    pattern_list: Vec<EntityRef>,
    mapping_source: EntityRef,
    mapping_target: EntityRef,
}
impl IFoundedItem for UserDefinedCurveFont {}
impl ICurveStyleFont for UserDefinedCurveFont {
    fn name(&self) -> &Label {
        &self.name
    }
    fn pattern_list(&self) -> &Vec<EntityRef> {
        &self.pattern_list
    }
}
impl IRepresentationItem for UserDefinedCurveFont {
    fn name(&self) -> &Label {
        &self.name
    }
}
impl IMappedItem for UserDefinedCurveFont {
    fn mapping_source(&self) -> &EntityRef {
        &self.mapping_source
    }
    fn mapping_target(&self) -> &EntityRef {
        &self.mapping_target
    }
}
impl IUserDefinedCurveFont for UserDefinedCurveFont {}
impl UserDefinedCurveFont {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = UserDefinedCurveFont::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => entity.pattern_list = parameter.into(),
                2usize => entity.mapping_source = parameter.into(),
                3usize => entity.mapping_target = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IUserDefinedMarker: IMappedItem + IPreDefinedMarker {}
#[derive(Default, Debug)]
pub struct UserDefinedMarker {
    name: Label,
    mapping_source: EntityRef,
    mapping_target: EntityRef,
}
impl IRepresentationItem for UserDefinedMarker {
    fn name(&self) -> &Label {
        &self.name
    }
}
impl IMappedItem for UserDefinedMarker {
    fn mapping_source(&self) -> &EntityRef {
        &self.mapping_source
    }
    fn mapping_target(&self) -> &EntityRef {
        &self.mapping_target
    }
}
impl IPreDefinedItem for UserDefinedMarker {
    fn name(&self) -> &Label {
        &self.name
    }
}
impl IPreDefinedMarker for UserDefinedMarker {}
impl IUserDefinedMarker for UserDefinedMarker {}
impl UserDefinedMarker {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = UserDefinedMarker::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => entity.mapping_source = parameter.into(),
                2usize => entity.mapping_target = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IUserDefinedTerminatorSymbol: IMappedItem + IPreDefinedSymbol {}
#[derive(Default, Debug)]
pub struct UserDefinedTerminatorSymbol {
    name: Label,
    mapping_source: EntityRef,
    mapping_target: EntityRef,
}
impl IRepresentationItem for UserDefinedTerminatorSymbol {
    fn name(&self) -> &Label {
        &self.name
    }
}
impl IMappedItem for UserDefinedTerminatorSymbol {
    fn mapping_source(&self) -> &EntityRef {
        &self.mapping_source
    }
    fn mapping_target(&self) -> &EntityRef {
        &self.mapping_target
    }
}
impl IPreDefinedItem for UserDefinedTerminatorSymbol {
    fn name(&self) -> &Label {
        &self.name
    }
}
impl IPreDefinedSymbol for UserDefinedTerminatorSymbol {}
impl IUserDefinedTerminatorSymbol for UserDefinedTerminatorSymbol {}
impl UserDefinedTerminatorSymbol {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = UserDefinedTerminatorSymbol::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => entity.mapping_source = parameter.into(),
                2usize => entity.mapping_target = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IUserSelectedElements: IRepresentationItem {
    fn picked_items(&self) -> &HashSet<EntityRef>;
}
#[derive(Default, Debug)]
pub struct UserSelectedElements {
    name: Label,
    picked_items: HashSet<EntityRef>,
}
impl IRepresentationItem for UserSelectedElements {
    fn name(&self) -> &Label {
        &self.name
    }
}
impl IUserSelectedElements for UserSelectedElements {
    fn picked_items(&self) -> &HashSet<EntityRef> {
        &self.picked_items
    }
}
impl UserSelectedElements {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = UserSelectedElements::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => entity.picked_items = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IUserSelectedShapeElements: IUserSelectedElements {}
#[derive(Default, Debug)]
pub struct UserSelectedShapeElements {
    name: Label,
    picked_items: HashSet<EntityRef>,
}
impl IRepresentationItem for UserSelectedShapeElements {
    fn name(&self) -> &Label {
        &self.name
    }
}
impl IUserSelectedElements for UserSelectedShapeElements {
    fn picked_items(&self) -> &HashSet<EntityRef> {
        &self.picked_items
    }
}
impl IUserSelectedShapeElements for UserSelectedShapeElements {}
impl UserSelectedShapeElements {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = UserSelectedShapeElements::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => entity.picked_items = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IValueRange: ICompoundRepresentationItem {}
#[derive(Default, Debug)]
pub struct ValueRange {
    name: Label,
    item_element: CompoundItemDefinition,
}
impl IRepresentationItem for ValueRange {
    fn name(&self) -> &Label {
        &self.name
    }
}
impl ICompoundRepresentationItem for ValueRange {
    fn item_element(&self) -> &CompoundItemDefinition {
        &self.item_element
    }
}
impl IValueRange for ValueRange {}
impl ValueRange {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = ValueRange::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => entity.item_element = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IValueRepresentationItem: IRepresentationItem {
    fn value_component(&self) -> &MeasureValue;
}
#[derive(Default, Debug)]
pub struct ValueRepresentationItem {
    name: Label,
    value_component: MeasureValue,
}
impl IRepresentationItem for ValueRepresentationItem {
    fn name(&self) -> &Label {
        &self.name
    }
}
impl IValueRepresentationItem for ValueRepresentationItem {
    fn value_component(&self) -> &MeasureValue {
        &self.value_component
    }
}
impl ValueRepresentationItem {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = ValueRepresentationItem::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => entity.value_component = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IVariableSemantics {}
pub trait IVariationalRepresentationItem: IRepresentationItem {}
pub trait IVector: IGeometricRepresentationItem {
    fn orientation(&self) -> &EntityRef;
    fn magnitude(&self) -> &LengthMeasure;
}
#[derive(Default, Debug)]
pub struct Vector {
    name: Label,
    orientation: EntityRef,
    magnitude: LengthMeasure,
}
impl IRepresentationItem for Vector {
    fn name(&self) -> &Label {
        &self.name
    }
}
impl IGeometricRepresentationItem for Vector {}
impl IVector for Vector {
    fn orientation(&self) -> &EntityRef {
        &self.orientation
    }
    fn magnitude(&self) -> &LengthMeasure {
        &self.magnitude
    }
}
impl Vector {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = Vector::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => entity.orientation = parameter.into(),
                2usize => entity.magnitude = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IVectorStyle: ICurveStyle + IPreDefinedTerminatorSymbol {}
#[derive(Default, Debug)]
pub struct VectorStyle {
    name: Label,
    curve_font: EntityRef,
    curve_width: SizeSelect,
    curve_colour: EntityRef,
}
impl IFoundedItem for VectorStyle {}
impl ICurveStyle for VectorStyle {
    fn name(&self) -> &Label {
        &self.name
    }
    fn curve_font(&self) -> &EntityRef {
        &self.curve_font
    }
    fn curve_width(&self) -> &SizeSelect {
        &self.curve_width
    }
    fn curve_colour(&self) -> &EntityRef {
        &self.curve_colour
    }
}
impl IPreDefinedItem for VectorStyle {
    fn name(&self) -> &Label {
        &self.name
    }
}
impl IPreDefinedSymbol for VectorStyle {}
impl IPreDefinedTerminatorSymbol for VectorStyle {}
impl IVectorStyle for VectorStyle {}
impl VectorStyle {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = VectorStyle::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => entity.curve_font = parameter.into(),
                2usize => entity.curve_width = parameter.into(),
                3usize => entity.curve_colour = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IVelocityMeasureWithUnit: IMeasureWithUnit {}
#[derive(Default, Debug)]
pub struct VelocityMeasureWithUnit {
    value_component: MeasureValue,
    unit_component: EntityRef,
}
impl IMeasureWithUnit for VelocityMeasureWithUnit {
    fn value_component(&self) -> &MeasureValue {
        &self.value_component
    }
    fn unit_component(&self) -> &EntityRef {
        &self.unit_component
    }
}
impl IVelocityMeasureWithUnit for VelocityMeasureWithUnit {}
impl VelocityMeasureWithUnit {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = VelocityMeasureWithUnit::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.value_component = parameter.into(),
                1usize => entity.unit_component = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IVelocityUnit: IDerivedUnit {}
#[derive(Default, Debug)]
pub struct VelocityUnit {
    elements: HashSet<EntityRef>,
}
impl IDerivedUnit for VelocityUnit {
    fn elements(&self) -> &HashSet<EntityRef> {
        &self.elements
    }
}
impl IVelocityUnit for VelocityUnit {}
impl VelocityUnit {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = VelocityUnit::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.elements = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IVersionedActionRequest {
    fn id(&self) -> &Identifier;
    fn version(&self) -> &Label;
    fn purpose(&self) -> &Text;
    fn description(&self) -> &Option<Text>;
}
#[derive(Default, Debug)]
pub struct VersionedActionRequest {
    id: Identifier,
    version: Label,
    purpose: Text,
    description: Option<Text>,
}
impl IVersionedActionRequest for VersionedActionRequest {
    fn id(&self) -> &Identifier {
        &self.id
    }
    fn version(&self) -> &Label {
        &self.version
    }
    fn purpose(&self) -> &Text {
        &self.purpose
    }
    fn description(&self) -> &Option<Text> {
        &self.description
    }
}
impl VersionedActionRequest {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = VersionedActionRequest::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.id = parameter.into(),
                1usize => entity.version = parameter.into(),
                2usize => entity.purpose = parameter.into(),
                3usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
}
pub trait IVertex: ITopologicalRepresentationItem {}
#[derive(Default, Debug)]
pub struct Vertex {
    name: Label,
}
impl IRepresentationItem for Vertex {
    fn name(&self) -> &Label {
        &self.name
    }
}
impl ITopologicalRepresentationItem for Vertex {}
impl IVertex for Vertex {}
impl Vertex {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = Vertex::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IVertexLoop: ILoop {
    fn loop_vertex(&self) -> &EntityRef;
}
#[derive(Default, Debug)]
pub struct VertexLoop {
    name: Label,
    loop_vertex: EntityRef,
}
impl IRepresentationItem for VertexLoop {
    fn name(&self) -> &Label {
        &self.name
    }
}
impl ITopologicalRepresentationItem for VertexLoop {}
impl ILoop for VertexLoop {}
impl IVertexLoop for VertexLoop {
    fn loop_vertex(&self) -> &EntityRef {
        &self.loop_vertex
    }
}
impl VertexLoop {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = VertexLoop::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => entity.loop_vertex = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IVertexPoint: IVertex + IGeometricRepresentationItem {
    fn vertex_geometry(&self) -> &EntityRef;
}
#[derive(Default, Debug)]
pub struct VertexPoint {
    name: Label,
    vertex_geometry: EntityRef,
}
impl IRepresentationItem for VertexPoint {
    fn name(&self) -> &Label {
        &self.name
    }
}
impl ITopologicalRepresentationItem for VertexPoint {}
impl IVertex for VertexPoint {}
impl IVertexPoint for VertexPoint {
    fn vertex_geometry(&self) -> &EntityRef {
        &self.vertex_geometry
    }
}
impl IGeometricRepresentationItem for VertexPoint {}
impl VertexPoint {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = VertexPoint::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => entity.vertex_geometry = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IVertexShell: ITopologicalRepresentationItem {
    fn vertex_shell_extent(&self) -> &EntityRef;
}
#[derive(Default, Debug)]
pub struct VertexShell {
    name: Label,
    vertex_shell_extent: EntityRef,
}
impl IRepresentationItem for VertexShell {
    fn name(&self) -> &Label {
        &self.name
    }
}
impl ITopologicalRepresentationItem for VertexShell {}
impl IVertexShell for VertexShell {
    fn vertex_shell_extent(&self) -> &EntityRef {
        &self.vertex_shell_extent
    }
}
impl VertexShell {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = VertexShell::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => entity.vertex_shell_extent = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IViewDependentAnnotationRepresentation: IPresentationRepresentation {
    fn items(&self) -> &HashSet<EntityRef>;
}
#[derive(Default, Debug)]
pub struct ViewDependentAnnotationRepresentation {
    name: Label,
    context_of_items: EntityRef,
    items: HashSet<EntityRef>,
}
impl IRepresentation for ViewDependentAnnotationRepresentation {
    fn name(&self) -> &Label {
        &self.name
    }
    fn items(&self) -> &HashSet<EntityRef> {
        &self.items
    }
    fn context_of_items(&self) -> &EntityRef {
        &self.context_of_items
    }
}
impl IPresentationRepresentation for ViewDependentAnnotationRepresentation {
    fn context_of_items(&self) -> &EntityRef {
        &self.context_of_items
    }
}
impl IViewDependentAnnotationRepresentation for ViewDependentAnnotationRepresentation {
    fn items(&self) -> &HashSet<EntityRef> {
        &self.items
    }
}
impl ViewDependentAnnotationRepresentation {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = ViewDependentAnnotationRepresentation::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => entity.context_of_items = parameter.into(),
                2usize => entity.items = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IViewVolume: IFoundedItem {
    fn projection_type(&self) -> &CentralOrParallel;
    fn projection_point(&self) -> &EntityRef;
    fn view_plane_distance(&self) -> &LengthMeasure;
    fn front_plane_distance(&self) -> &LengthMeasure;
    fn front_plane_clipping(&self) -> bool;
    fn back_plane_distance(&self) -> &LengthMeasure;
    fn back_plane_clipping(&self) -> bool;
    fn view_volume_sides_clipping(&self) -> bool;
    fn view_window(&self) -> &EntityRef;
}
#[derive(Default, Debug)]
pub struct ViewVolume {
    projection_type: CentralOrParallel,
    projection_point: EntityRef,
    view_plane_distance: LengthMeasure,
    front_plane_distance: LengthMeasure,
    front_plane_clipping: bool,
    back_plane_distance: LengthMeasure,
    back_plane_clipping: bool,
    view_volume_sides_clipping: bool,
    view_window: EntityRef,
}
impl IFoundedItem for ViewVolume {}
impl IViewVolume for ViewVolume {
    fn projection_type(&self) -> &CentralOrParallel {
        &self.projection_type
    }
    fn projection_point(&self) -> &EntityRef {
        &self.projection_point
    }
    fn view_plane_distance(&self) -> &LengthMeasure {
        &self.view_plane_distance
    }
    fn front_plane_distance(&self) -> &LengthMeasure {
        &self.front_plane_distance
    }
    fn front_plane_clipping(&self) -> bool {
        self.front_plane_clipping
    }
    fn back_plane_distance(&self) -> &LengthMeasure {
        &self.back_plane_distance
    }
    fn back_plane_clipping(&self) -> bool {
        self.back_plane_clipping
    }
    fn view_volume_sides_clipping(&self) -> bool {
        self.view_volume_sides_clipping
    }
    fn view_window(&self) -> &EntityRef {
        &self.view_window
    }
}
impl ViewVolume {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = ViewVolume::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.projection_type = parameter.into(),
                1usize => entity.projection_point = parameter.into(),
                2usize => entity.view_plane_distance = parameter.into(),
                3usize => entity.front_plane_distance = parameter.into(),
                4usize => entity.front_plane_clipping = parameter.into(),
                5usize => entity.back_plane_distance = parameter.into(),
                6usize => entity.back_plane_clipping = parameter.into(),
                7usize => entity.view_volume_sides_clipping = parameter.into(),
                8usize => entity.view_window = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IVisualAppearanceRepresentation: IRepresentation {}
#[derive(Default, Debug)]
pub struct VisualAppearanceRepresentation {
    name: Label,
    items: HashSet<EntityRef>,
    context_of_items: EntityRef,
}
impl IRepresentation for VisualAppearanceRepresentation {
    fn name(&self) -> &Label {
        &self.name
    }
    fn items(&self) -> &HashSet<EntityRef> {
        &self.items
    }
    fn context_of_items(&self) -> &EntityRef {
        &self.context_of_items
    }
}
impl IVisualAppearanceRepresentation for VisualAppearanceRepresentation {}
impl VisualAppearanceRepresentation {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = VisualAppearanceRepresentation::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => entity.items = parameter.into(),
                2usize => entity.context_of_items = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IVolumeMeasureWithUnit: IMeasureWithUnit {}
#[derive(Default, Debug)]
pub struct VolumeMeasureWithUnit {
    value_component: MeasureValue,
    unit_component: EntityRef,
}
impl IMeasureWithUnit for VolumeMeasureWithUnit {
    fn value_component(&self) -> &MeasureValue {
        &self.value_component
    }
    fn unit_component(&self) -> &EntityRef {
        &self.unit_component
    }
}
impl IVolumeMeasureWithUnit for VolumeMeasureWithUnit {}
impl VolumeMeasureWithUnit {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = VolumeMeasureWithUnit::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.value_component = parameter.into(),
                1usize => entity.unit_component = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IVolumeUnit: IDerivedUnit {}
#[derive(Default, Debug)]
pub struct VolumeUnit {
    elements: HashSet<EntityRef>,
}
impl IDerivedUnit for VolumeUnit {
    fn elements(&self) -> &HashSet<EntityRef> {
        &self.elements
    }
}
impl IVolumeUnit for VolumeUnit {}
impl VolumeUnit {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = VolumeUnit::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.elements = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IWeekOfYearAndDayDate: IDate {
    fn week_component(&self) -> &WeekInYearNumber;
    fn day_component(&self) -> &Option<DayInWeekNumber>;
}
#[derive(Default, Debug)]
pub struct WeekOfYearAndDayDate {
    year_component: YearNumber,
    week_component: WeekInYearNumber,
    day_component: Option<DayInWeekNumber>,
}
impl IDate for WeekOfYearAndDayDate {
    fn year_component(&self) -> &YearNumber {
        &self.year_component
    }
}
impl IWeekOfYearAndDayDate for WeekOfYearAndDayDate {
    fn week_component(&self) -> &WeekInYearNumber {
        &self.week_component
    }
    fn day_component(&self) -> &Option<DayInWeekNumber> {
        &self.day_component
    }
}
impl WeekOfYearAndDayDate {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = WeekOfYearAndDayDate::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.year_component = parameter.into(),
                1usize => entity.week_component = parameter.into(),
                2usize => {
                    entity.day_component = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
}
pub trait IWireShell: ITopologicalRepresentationItem {
    fn wire_shell_extent(&self) -> &HashSet<EntityRef>;
}
#[derive(Default, Debug)]
pub struct WireShell {
    name: Label,
    wire_shell_extent: HashSet<EntityRef>,
}
impl IRepresentationItem for WireShell {
    fn name(&self) -> &Label {
        &self.name
    }
}
impl ITopologicalRepresentationItem for WireShell {}
impl IWireShell for WireShell {
    fn wire_shell_extent(&self) -> &HashSet<EntityRef> {
        &self.wire_shell_extent
    }
}
impl WireShell {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = WireShell::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => entity.wire_shell_extent = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IYearMonth: IDate {
    fn month_component(&self) -> &MonthInYearNumber;
}
#[derive(Default, Debug)]
pub struct YearMonth {
    year_component: YearNumber,
    month_component: MonthInYearNumber,
}
impl IDate for YearMonth {
    fn year_component(&self) -> &YearNumber {
        &self.year_component
    }
}
impl IYearMonth for YearMonth {
    fn month_component(&self) -> &MonthInYearNumber {
        &self.month_component
    }
}
impl YearMonth {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = YearMonth::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.year_component = parameter.into(),
                1usize => entity.month_component = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IZoneStructuralMakeup: ILaminateTable {}
#[derive(Default, Debug)]
pub struct ZoneStructuralMakeup {
    id: Identifier,
    description: Option<Text>,
    formation: EntityRef,
    frame_of_reference: EntityRef,
}
impl IProductDefinition for ZoneStructuralMakeup {
    fn id(&self) -> &Identifier {
        &self.id
    }
    fn description(&self) -> &Option<Text> {
        &self.description
    }
    fn formation(&self) -> &EntityRef {
        &self.formation
    }
    fn frame_of_reference(&self) -> &EntityRef {
        &self.frame_of_reference
    }
}
impl ILaminateTable for ZoneStructuralMakeup {}
impl IZoneStructuralMakeup for ZoneStructuralMakeup {}
impl ZoneStructuralMakeup {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = ZoneStructuralMakeup::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.id = parameter.into(),
                1usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => entity.formation = parameter.into(),
                3usize => entity.frame_of_reference = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
use std::any::{Any, TypeId};
use std::collections::{BTreeMap, HashMap};
pub struct Ap203Reader {
    pub entities: BTreeMap<i64, Box<dyn Any>>,
    pub type_ids: HashMap<TypeId, Vec<i64>>,
    pub type_names: HashMap<TypeId, &'static str>,
    empty: Vec<i64>,
}
impl Ap203Reader {
    pub fn new() -> Self {
        Ap203Reader {
            entities: BTreeMap::new(),
            type_ids: HashMap::new(),
            type_names: HashMap::new(),
            empty: Vec::new(),
        }
    }
    pub fn add_entity<T: Any>(&mut self, id: i64, entity: T) {
        let type_id = entity.type_id();
        self.entities.insert(id, Box::new(entity));
        self.type_ids.entry(type_id).or_insert(vec![]).push(id);
        self.type_names.entry(type_id).or_insert(std::any::type_name::<T>());
    }
    pub fn get_entity<T: Any>(&self, entity_ref: &EntityRef) -> Option<&T> {
        self.entities
            .get(&entity_ref.0)
            .map(|entity| entity.downcast_ref::<T>())
            .flatten()
    }
    pub fn get_entities<T: Any>(&self) -> impl Iterator<Item = &T> {
        let type_id = TypeId::of::<T>();
        self.type_ids
            .get(&type_id)
            .unwrap_or(&self.empty)
            .iter()
            .map(move |id| self.entities[id].downcast_ref::<T>().unwrap())
    }
    pub fn get_type_name(&self, id: i64) -> &'static str {
        let type_id = (*self.entities[&id]).type_id();
        self.type_names[&type_id]
    }
}
impl StepReader for Ap203Reader {
    fn insert_entity(&mut self, id: i64, type_id: TypeId, type_name: &'static str, entity: Box<dyn Any>) {
        self.entities.insert(id, entity);
        self.type_ids.entry(type_id).or_insert(vec![]).push(id);
        self.type_names.entry(type_id).or_insert(type_name);
    }
    fn create_entity(&self, typed_parameter: TypedParameter) -> Option<(TypeId, &'static str, Box<dyn Any>)> {
        match typed_parameter.type_name.as_str() {
            "ABSORBED_DOSE_MEASURE_WITH_UNIT" => {
                let entity = AbsorbedDoseMeasureWithUnit::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<AbsorbedDoseMeasureWithUnit>(),
                    Box::new(entity),
                ))
            }
            "ABSORBED_DOSE_UNIT" => {
                let entity = AbsorbedDoseUnit::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<AbsorbedDoseUnit>(),
                    Box::new(entity),
                ))
            }
            "ABSTRACT_VARIABLE" => {
                let entity = AbstractVariable::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<AbstractVariable>(),
                    Box::new(entity),
                ))
            }
            "ACCELERATION_MEASURE_WITH_UNIT" => {
                let entity = AccelerationMeasureWithUnit::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<AccelerationMeasureWithUnit>(),
                    Box::new(entity),
                ))
            }
            "ACCELERATION_UNIT" => {
                let entity = AccelerationUnit::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<AccelerationUnit>(),
                    Box::new(entity),
                ))
            }
            "ACTION" => {
                let entity = Action::form_parameters(typed_parameter.parameters);
                Some((entity.type_id(), std::any::type_name::<Action>(), Box::new(entity)))
            }
            "ACTION_DIRECTIVE" => {
                let entity = ActionDirective::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<ActionDirective>(),
                    Box::new(entity),
                ))
            }
            "ACTION_METHOD" => {
                let entity = ActionMethod::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<ActionMethod>(),
                    Box::new(entity),
                ))
            }
            "ACTION_METHOD_RELATIONSHIP" => {
                let entity = ActionMethodRelationship::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<ActionMethodRelationship>(),
                    Box::new(entity),
                ))
            }
            "ACTION_METHOD_ROLE" => {
                let entity = ActionMethodRole::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<ActionMethodRole>(),
                    Box::new(entity),
                ))
            }
            "ACTION_PROPERTY" => {
                let entity = ActionProperty::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<ActionProperty>(),
                    Box::new(entity),
                ))
            }
            "ACTION_PROPERTY_REPRESENTATION" => {
                let entity = ActionPropertyRepresentation::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<ActionPropertyRepresentation>(),
                    Box::new(entity),
                ))
            }
            "ACTION_RELATIONSHIP" => {
                let entity = ActionRelationship::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<ActionRelationship>(),
                    Box::new(entity),
                ))
            }
            "ACTION_REQUEST_SOLUTION" => {
                let entity = ActionRequestSolution::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<ActionRequestSolution>(),
                    Box::new(entity),
                ))
            }
            "ACTION_REQUEST_STATUS" => {
                let entity = ActionRequestStatus::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<ActionRequestStatus>(),
                    Box::new(entity),
                ))
            }
            "ACTION_STATUS" => {
                let entity = ActionStatus::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<ActionStatus>(),
                    Box::new(entity),
                ))
            }
            "ADDRESS" => {
                let entity = Address::form_parameters(typed_parameter.parameters);
                Some((entity.type_id(), std::any::type_name::<Address>(), Box::new(entity)))
            }
            "ADVANCED_BREP_SHAPE_REPRESENTATION" => {
                let entity = AdvancedBrepShapeRepresentation::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<AdvancedBrepShapeRepresentation>(),
                    Box::new(entity),
                ))
            }
            "ADVANCED_FACE" => {
                let entity = AdvancedFace::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<AdvancedFace>(),
                    Box::new(entity),
                ))
            }
            "ALTERNATE_PRODUCT_RELATIONSHIP" => {
                let entity = AlternateProductRelationship::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<AlternateProductRelationship>(),
                    Box::new(entity),
                ))
            }
            "AMOUNT_OF_SUBSTANCE_MEASURE_WITH_UNIT" => {
                let entity = AmountOfSubstanceMeasureWithUnit::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<AmountOfSubstanceMeasureWithUnit>(),
                    Box::new(entity),
                ))
            }
            "AMOUNT_OF_SUBSTANCE_UNIT" => {
                let entity = AmountOfSubstanceUnit::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<AmountOfSubstanceUnit>(),
                    Box::new(entity),
                ))
            }
            "ANGLE_DIRECTION_REFERENCE" => {
                let entity = AngleDirectionReference::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<AngleDirectionReference>(),
                    Box::new(entity),
                ))
            }
            "ANGULAR_DIMENSION" => {
                let entity = AngularDimension::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<AngularDimension>(),
                    Box::new(entity),
                ))
            }
            "ANGULAR_LOCATION" => {
                let entity = AngularLocation::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<AngularLocation>(),
                    Box::new(entity),
                ))
            }
            "ANGULAR_SIZE" => {
                let entity = AngularSize::form_parameters(typed_parameter.parameters);
                Some((entity.type_id(), std::any::type_name::<AngularSize>(), Box::new(entity)))
            }
            "ANGULARITY_TOLERANCE" => {
                let entity = AngularityTolerance::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<AngularityTolerance>(),
                    Box::new(entity),
                ))
            }
            "ANNOTATION_CURVE_OCCURRENCE" => {
                let entity = AnnotationCurveOccurrence::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<AnnotationCurveOccurrence>(),
                    Box::new(entity),
                ))
            }
            "ANNOTATION_FILL_AREA" => {
                let entity = AnnotationFillArea::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<AnnotationFillArea>(),
                    Box::new(entity),
                ))
            }
            "ANNOTATION_FILL_AREA_OCCURRENCE" => {
                let entity = AnnotationFillAreaOccurrence::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<AnnotationFillAreaOccurrence>(),
                    Box::new(entity),
                ))
            }
            "ANNOTATION_OCCURRENCE" => {
                let entity = AnnotationOccurrence::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<AnnotationOccurrence>(),
                    Box::new(entity),
                ))
            }
            "ANNOTATION_OCCURRENCE_ASSOCIATIVITY" => {
                let entity = AnnotationOccurrenceAssociativity::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<AnnotationOccurrenceAssociativity>(),
                    Box::new(entity),
                ))
            }
            "ANNOTATION_OCCURRENCE_RELATIONSHIP" => {
                let entity = AnnotationOccurrenceRelationship::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<AnnotationOccurrenceRelationship>(),
                    Box::new(entity),
                ))
            }
            "ANNOTATION_PLANE" => {
                let entity = AnnotationPlane::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<AnnotationPlane>(),
                    Box::new(entity),
                ))
            }
            "ANNOTATION_SUBFIGURE_OCCURRENCE" => {
                let entity = AnnotationSubfigureOccurrence::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<AnnotationSubfigureOccurrence>(),
                    Box::new(entity),
                ))
            }
            "ANNOTATION_SYMBOL" => {
                let entity = AnnotationSymbol::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<AnnotationSymbol>(),
                    Box::new(entity),
                ))
            }
            "ANNOTATION_SYMBOL_OCCURRENCE" => {
                let entity = AnnotationSymbolOccurrence::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<AnnotationSymbolOccurrence>(),
                    Box::new(entity),
                ))
            }
            "ANNOTATION_TEXT" => {
                let entity = AnnotationText::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<AnnotationText>(),
                    Box::new(entity),
                ))
            }
            "ANNOTATION_TEXT_CHARACTER" => {
                let entity = AnnotationTextCharacter::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<AnnotationTextCharacter>(),
                    Box::new(entity),
                ))
            }
            "ANNOTATION_TEXT_OCCURRENCE" => {
                let entity = AnnotationTextOccurrence::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<AnnotationTextOccurrence>(),
                    Box::new(entity),
                ))
            }
            "APEX" => {
                let entity = Apex::form_parameters(typed_parameter.parameters);
                Some((entity.type_id(), std::any::type_name::<Apex>(), Box::new(entity)))
            }
            "APPLICATION_CONTEXT" => {
                let entity = ApplicationContext::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<ApplicationContext>(),
                    Box::new(entity),
                ))
            }
            "APPLICATION_CONTEXT_ELEMENT" => {
                let entity = ApplicationContextElement::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<ApplicationContextElement>(),
                    Box::new(entity),
                ))
            }
            "APPLICATION_PROTOCOL_DEFINITION" => {
                let entity = ApplicationProtocolDefinition::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<ApplicationProtocolDefinition>(),
                    Box::new(entity),
                ))
            }
            "APPLIED_ACTION_ASSIGNMENT" => {
                let entity = AppliedActionAssignment::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<AppliedActionAssignment>(),
                    Box::new(entity),
                ))
            }
            "APPLIED_ACTION_METHOD_ASSIGNMENT" => {
                let entity = AppliedActionMethodAssignment::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<AppliedActionMethodAssignment>(),
                    Box::new(entity),
                ))
            }
            "APPLIED_ACTION_REQUEST_ASSIGNMENT" => {
                let entity = AppliedActionRequestAssignment::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<AppliedActionRequestAssignment>(),
                    Box::new(entity),
                ))
            }
            "APPLIED_APPROVAL_ASSIGNMENT" => {
                let entity = AppliedApprovalAssignment::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<AppliedApprovalAssignment>(),
                    Box::new(entity),
                ))
            }
            "APPLIED_ATTRIBUTE_CLASSIFICATION_ASSIGNMENT" => {
                let entity = AppliedAttributeClassificationAssignment::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<AppliedAttributeClassificationAssignment>(),
                    Box::new(entity),
                ))
            }
            "APPLIED_CERTIFICATION_ASSIGNMENT" => {
                let entity = AppliedCertificationAssignment::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<AppliedCertificationAssignment>(),
                    Box::new(entity),
                ))
            }
            "APPLIED_CLASSIFICATION_ASSIGNMENT" => {
                let entity = AppliedClassificationAssignment::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<AppliedClassificationAssignment>(),
                    Box::new(entity),
                ))
            }
            "APPLIED_CONTRACT_ASSIGNMENT" => {
                let entity = AppliedContractAssignment::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<AppliedContractAssignment>(),
                    Box::new(entity),
                ))
            }
            "APPLIED_DATE_AND_TIME_ASSIGNMENT" => {
                let entity = AppliedDateAndTimeAssignment::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<AppliedDateAndTimeAssignment>(),
                    Box::new(entity),
                ))
            }
            "APPLIED_DATE_ASSIGNMENT" => {
                let entity = AppliedDateAssignment::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<AppliedDateAssignment>(),
                    Box::new(entity),
                ))
            }
            "APPLIED_DOCUMENT_REFERENCE" => {
                let entity = AppliedDocumentReference::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<AppliedDocumentReference>(),
                    Box::new(entity),
                ))
            }
            "APPLIED_DOCUMENT_USAGE_CONSTRAINT_ASSIGNMENT" => {
                let entity = AppliedDocumentUsageConstraintAssignment::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<AppliedDocumentUsageConstraintAssignment>(),
                    Box::new(entity),
                ))
            }
            "APPLIED_EFFECTIVITY_ASSIGNMENT" => {
                let entity = AppliedEffectivityAssignment::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<AppliedEffectivityAssignment>(),
                    Box::new(entity),
                ))
            }
            "APPLIED_EVENT_OCCURRENCE_ASSIGNMENT" => {
                let entity = AppliedEventOccurrenceAssignment::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<AppliedEventOccurrenceAssignment>(),
                    Box::new(entity),
                ))
            }
            "APPLIED_EXTERNAL_IDENTIFICATION_ASSIGNMENT" => {
                let entity = AppliedExternalIdentificationAssignment::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<AppliedExternalIdentificationAssignment>(),
                    Box::new(entity),
                ))
            }
            "APPLIED_GROUP_ASSIGNMENT" => {
                let entity = AppliedGroupAssignment::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<AppliedGroupAssignment>(),
                    Box::new(entity),
                ))
            }
            "APPLIED_IDENTIFICATION_ASSIGNMENT" => {
                let entity = AppliedIdentificationAssignment::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<AppliedIdentificationAssignment>(),
                    Box::new(entity),
                ))
            }
            "APPLIED_NAME_ASSIGNMENT" => {
                let entity = AppliedNameAssignment::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<AppliedNameAssignment>(),
                    Box::new(entity),
                ))
            }
            "APPLIED_ORGANIZATION_ASSIGNMENT" => {
                let entity = AppliedOrganizationAssignment::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<AppliedOrganizationAssignment>(),
                    Box::new(entity),
                ))
            }
            "APPLIED_ORGANIZATIONAL_PROJECT_ASSIGNMENT" => {
                let entity = AppliedOrganizationalProjectAssignment::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<AppliedOrganizationalProjectAssignment>(),
                    Box::new(entity),
                ))
            }
            "APPLIED_PERSON_AND_ORGANIZATION_ASSIGNMENT" => {
                let entity = AppliedPersonAndOrganizationAssignment::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<AppliedPersonAndOrganizationAssignment>(),
                    Box::new(entity),
                ))
            }
            "APPLIED_PRESENTED_ITEM" => {
                let entity = AppliedPresentedItem::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<AppliedPresentedItem>(),
                    Box::new(entity),
                ))
            }
            "APPLIED_SECURITY_CLASSIFICATION_ASSIGNMENT" => {
                let entity = AppliedSecurityClassificationAssignment::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<AppliedSecurityClassificationAssignment>(),
                    Box::new(entity),
                ))
            }
            "APPLIED_TIME_INTERVAL_ASSIGNMENT" => {
                let entity = AppliedTimeIntervalAssignment::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<AppliedTimeIntervalAssignment>(),
                    Box::new(entity),
                ))
            }
            "APPLIED_USAGE_RIGHT" => {
                let entity = AppliedUsageRight::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<AppliedUsageRight>(),
                    Box::new(entity),
                ))
            }
            "APPROVAL" => {
                let entity = Approval::form_parameters(typed_parameter.parameters);
                Some((entity.type_id(), std::any::type_name::<Approval>(), Box::new(entity)))
            }
            "APPROVAL_DATE_TIME" => {
                let entity = ApprovalDateTime::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<ApprovalDateTime>(),
                    Box::new(entity),
                ))
            }
            "APPROVAL_PERSON_ORGANIZATION" => {
                let entity = ApprovalPersonOrganization::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<ApprovalPersonOrganization>(),
                    Box::new(entity),
                ))
            }
            "APPROVAL_RELATIONSHIP" => {
                let entity = ApprovalRelationship::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<ApprovalRelationship>(),
                    Box::new(entity),
                ))
            }
            "APPROVAL_ROLE" => {
                let entity = ApprovalRole::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<ApprovalRole>(),
                    Box::new(entity),
                ))
            }
            "APPROVAL_STATUS" => {
                let entity = ApprovalStatus::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<ApprovalStatus>(),
                    Box::new(entity),
                ))
            }
            "AREA_DEPENDENT_ANNOTATION_REPRESENTATION" => {
                let entity = AreaDependentAnnotationRepresentation::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<AreaDependentAnnotationRepresentation>(),
                    Box::new(entity),
                ))
            }
            "AREA_IN_SET" => {
                let entity = AreaInSet::form_parameters(typed_parameter.parameters);
                Some((entity.type_id(), std::any::type_name::<AreaInSet>(), Box::new(entity)))
            }
            "AREA_MEASURE_WITH_UNIT" => {
                let entity = AreaMeasureWithUnit::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<AreaMeasureWithUnit>(),
                    Box::new(entity),
                ))
            }
            "AREA_UNIT" => {
                let entity = AreaUnit::form_parameters(typed_parameter.parameters);
                Some((entity.type_id(), std::any::type_name::<AreaUnit>(), Box::new(entity)))
            }
            "ASSEMBLY_COMPONENT_USAGE" => {
                let entity = AssemblyComponentUsage::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<AssemblyComponentUsage>(),
                    Box::new(entity),
                ))
            }
            "ASSEMBLY_COMPONENT_USAGE_SUBSTITUTE" => {
                let entity = AssemblyComponentUsageSubstitute::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<AssemblyComponentUsageSubstitute>(),
                    Box::new(entity),
                ))
            }
            "ASSIGNED_REQUIREMENT" => {
                let entity = AssignedRequirement::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<AssignedRequirement>(),
                    Box::new(entity),
                ))
            }
            "ATOMIC_FORMULA" => {
                let entity = AtomicFormula::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<AtomicFormula>(),
                    Box::new(entity),
                ))
            }
            "ATTRIBUTE_ASSERTION" => {
                let entity = AttributeAssertion::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<AttributeAssertion>(),
                    Box::new(entity),
                ))
            }
            "ATTRIBUTE_LANGUAGE_ASSIGNMENT" => {
                let entity = AttributeLanguageAssignment::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<AttributeLanguageAssignment>(),
                    Box::new(entity),
                ))
            }
            "ATTRIBUTE_VALUE_ROLE" => {
                let entity = AttributeValueRole::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<AttributeValueRole>(),
                    Box::new(entity),
                ))
            }
            "AUXILIARY_GEOMETRIC_REPRESENTATION_ITEM" => {
                let entity = AuxiliaryGeometricRepresentationItem::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<AuxiliaryGeometricRepresentationItem>(),
                    Box::new(entity),
                ))
            }
            "AXIS1_PLACEMENT" => {
                let entity = Axis1Placement::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<Axis1Placement>(),
                    Box::new(entity),
                ))
            }
            "AXIS2_PLACEMENT_2D" => {
                let entity = Axis2Placement2d::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<Axis2Placement2d>(),
                    Box::new(entity),
                ))
            }
            "AXIS2_PLACEMENT_3D" => {
                let entity = Axis2Placement3d::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<Axis2Placement3d>(),
                    Box::new(entity),
                ))
            }
            "B_SPLINE_CURVE" => {
                let entity = BSplineCurve::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<BSplineCurve>(),
                    Box::new(entity),
                ))
            }
            "B_SPLINE_CURVE_WITH_KNOTS" => {
                let entity = BSplineCurveWithKnots::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<BSplineCurveWithKnots>(),
                    Box::new(entity),
                ))
            }
            "B_SPLINE_SURFACE" => {
                let entity = BSplineSurface::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<BSplineSurface>(),
                    Box::new(entity),
                ))
            }
            "B_SPLINE_SURFACE_WITH_KNOTS" => {
                let entity = BSplineSurfaceWithKnots::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<BSplineSurfaceWithKnots>(),
                    Box::new(entity),
                ))
            }
            "BACK_CHAINING_RULE" => {
                let entity = BackChainingRule::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<BackChainingRule>(),
                    Box::new(entity),
                ))
            }
            "BACK_CHAINING_RULE_BODY" => {
                let entity = BackChainingRuleBody::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<BackChainingRuleBody>(),
                    Box::new(entity),
                ))
            }
            "BACKGROUND_COLOUR" => {
                let entity = BackgroundColour::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<BackgroundColour>(),
                    Box::new(entity),
                ))
            }
            "BEVELED_SHEET_REPRESENTATION" => {
                let entity = BeveledSheetRepresentation::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<BeveledSheetRepresentation>(),
                    Box::new(entity),
                ))
            }
            "BEZIER_CURVE" => {
                let entity = BezierCurve::form_parameters(typed_parameter.parameters);
                Some((entity.type_id(), std::any::type_name::<BezierCurve>(), Box::new(entity)))
            }
            "BEZIER_SURFACE" => {
                let entity = BezierSurface::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<BezierSurface>(),
                    Box::new(entity),
                ))
            }
            "BINARY_REPRESENTATION_ITEM" => {
                let entity = BinaryRepresentationItem::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<BinaryRepresentationItem>(),
                    Box::new(entity),
                ))
            }
            "BLOCK" => {
                let entity = Block::form_parameters(typed_parameter.parameters);
                Some((entity.type_id(), std::any::type_name::<Block>(), Box::new(entity)))
            }
            "BOOLEAN_LITERAL" => {
                let entity = BooleanLiteral::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<BooleanLiteral>(),
                    Box::new(entity),
                ))
            }
            "BOOLEAN_REPRESENTATION_ITEM" => {
                let entity = BooleanRepresentationItem::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<BooleanRepresentationItem>(),
                    Box::new(entity),
                ))
            }
            "BOOLEAN_RESULT" => {
                let entity = BooleanResult::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<BooleanResult>(),
                    Box::new(entity),
                ))
            }
            "BOUNDARY_CURVE" => {
                let entity = BoundaryCurve::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<BoundaryCurve>(),
                    Box::new(entity),
                ))
            }
            "BOUNDED_CURVE" => {
                let entity = BoundedCurve::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<BoundedCurve>(),
                    Box::new(entity),
                ))
            }
            "BOUNDED_PCURVE" => {
                let entity = BoundedPcurve::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<BoundedPcurve>(),
                    Box::new(entity),
                ))
            }
            "BOUNDED_SURFACE" => {
                let entity = BoundedSurface::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<BoundedSurface>(),
                    Box::new(entity),
                ))
            }
            "BOUNDED_SURFACE_CURVE" => {
                let entity = BoundedSurfaceCurve::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<BoundedSurfaceCurve>(),
                    Box::new(entity),
                ))
            }
            "BOX_DOMAIN" => {
                let entity = BoxDomain::form_parameters(typed_parameter.parameters);
                Some((entity.type_id(), std::any::type_name::<BoxDomain>(), Box::new(entity)))
            }
            "BOXED_HALF_SPACE" => {
                let entity = BoxedHalfSpace::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<BoxedHalfSpace>(),
                    Box::new(entity),
                ))
            }
            "BREAKDOWN_CONTEXT" => {
                let entity = BreakdownContext::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<BreakdownContext>(),
                    Box::new(entity),
                ))
            }
            "BREAKDOWN_ELEMENT_GROUP_ASSIGNMENT" => {
                let entity = BreakdownElementGroupAssignment::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<BreakdownElementGroupAssignment>(),
                    Box::new(entity),
                ))
            }
            "BREAKDOWN_ELEMENT_REALIZATION" => {
                let entity = BreakdownElementRealization::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<BreakdownElementRealization>(),
                    Box::new(entity),
                ))
            }
            "BREAKDOWN_ELEMENT_USAGE" => {
                let entity = BreakdownElementUsage::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<BreakdownElementUsage>(),
                    Box::new(entity),
                ))
            }
            "BREAKDOWN_OF" => {
                let entity = BreakdownOf::form_parameters(typed_parameter.parameters);
                Some((entity.type_id(), std::any::type_name::<BreakdownOf>(), Box::new(entity)))
            }
            "BREP_WITH_VOIDS" => {
                let entity = BrepWithVoids::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<BrepWithVoids>(),
                    Box::new(entity),
                ))
            }
            "BYTES_REPRESENTATION_ITEM" => {
                let entity = BytesRepresentationItem::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<BytesRepresentationItem>(),
                    Box::new(entity),
                ))
            }
            "CALENDAR_DATE" => {
                let entity = CalendarDate::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<CalendarDate>(),
                    Box::new(entity),
                ))
            }
            "CAMERA_IMAGE" => {
                let entity = CameraImage::form_parameters(typed_parameter.parameters);
                Some((entity.type_id(), std::any::type_name::<CameraImage>(), Box::new(entity)))
            }
            "CAMERA_IMAGE_3D_WITH_SCALE" => {
                let entity = CameraImage3dWithScale::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<CameraImage3dWithScale>(),
                    Box::new(entity),
                ))
            }
            "CAMERA_MODEL_D3" => {
                let entity = CameraModelD3::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<CameraModelD3>(),
                    Box::new(entity),
                ))
            }
            "CAMERA_MODEL_D3_MULTI_CLIPPING" => {
                let entity = CameraModelD3MultiClipping::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<CameraModelD3MultiClipping>(),
                    Box::new(entity),
                ))
            }
            "CAMERA_MODEL_D3_MULTI_CLIPPING_INTERSECTION" => {
                let entity = CameraModelD3MultiClippingIntersection::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<CameraModelD3MultiClippingIntersection>(),
                    Box::new(entity),
                ))
            }
            "CAMERA_MODEL_D3_MULTI_CLIPPING_UNION" => {
                let entity = CameraModelD3MultiClippingUnion::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<CameraModelD3MultiClippingUnion>(),
                    Box::new(entity),
                ))
            }
            "CAMERA_MODEL_D3_WITH_HLHSR" => {
                let entity = CameraModelD3WithHlhsr::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<CameraModelD3WithHlhsr>(),
                    Box::new(entity),
                ))
            }
            "CAMERA_MODEL_WITH_LIGHT_SOURCES" => {
                let entity = CameraModelWithLightSources::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<CameraModelWithLightSources>(),
                    Box::new(entity),
                ))
            }
            "CAMERA_USAGE" => {
                let entity = CameraUsage::form_parameters(typed_parameter.parameters);
                Some((entity.type_id(), std::any::type_name::<CameraUsage>(), Box::new(entity)))
            }
            "CAPACITANCE_MEASURE_WITH_UNIT" => {
                let entity = CapacitanceMeasureWithUnit::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<CapacitanceMeasureWithUnit>(),
                    Box::new(entity),
                ))
            }
            "CAPACITANCE_UNIT" => {
                let entity = CapacitanceUnit::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<CapacitanceUnit>(),
                    Box::new(entity),
                ))
            }
            "CARTESIAN_POINT" => {
                let entity = CartesianPoint::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<CartesianPoint>(),
                    Box::new(entity),
                ))
            }
            "CARTESIAN_TRANSFORMATION_OPERATOR" => {
                let entity = CartesianTransformationOperator::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<CartesianTransformationOperator>(),
                    Box::new(entity),
                ))
            }
            "CARTESIAN_TRANSFORMATION_OPERATOR_2D" => {
                let entity = CartesianTransformationOperator2d::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<CartesianTransformationOperator2d>(),
                    Box::new(entity),
                ))
            }
            "CARTESIAN_TRANSFORMATION_OPERATOR_3D" => {
                let entity = CartesianTransformationOperator3d::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<CartesianTransformationOperator3d>(),
                    Box::new(entity),
                ))
            }
            "CC_DESIGN_APPROVAL" => {
                let entity = CcDesignApproval::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<CcDesignApproval>(),
                    Box::new(entity),
                ))
            }
            "CC_DESIGN_CERTIFICATION" => {
                let entity = CcDesignCertification::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<CcDesignCertification>(),
                    Box::new(entity),
                ))
            }
            "CC_DESIGN_CONTRACT" => {
                let entity = CcDesignContract::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<CcDesignContract>(),
                    Box::new(entity),
                ))
            }
            "CC_DESIGN_DATE_AND_TIME_ASSIGNMENT" => {
                let entity = CcDesignDateAndTimeAssignment::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<CcDesignDateAndTimeAssignment>(),
                    Box::new(entity),
                ))
            }
            "CC_DESIGN_PERSON_AND_ORGANIZATION_ASSIGNMENT" => {
                let entity = CcDesignPersonAndOrganizationAssignment::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<CcDesignPersonAndOrganizationAssignment>(),
                    Box::new(entity),
                ))
            }
            "CC_DESIGN_SECURITY_CLASSIFICATION" => {
                let entity = CcDesignSecurityClassification::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<CcDesignSecurityClassification>(),
                    Box::new(entity),
                ))
            }
            "CC_DESIGN_SPECIFICATION_REFERENCE" => {
                let entity = CcDesignSpecificationReference::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<CcDesignSpecificationReference>(),
                    Box::new(entity),
                ))
            }
            "CELSIUS_TEMPERATURE_MEASURE_WITH_UNIT" => {
                let entity = CelsiusTemperatureMeasureWithUnit::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<CelsiusTemperatureMeasureWithUnit>(),
                    Box::new(entity),
                ))
            }
            "CENTRE_OF_SYMMETRY" => {
                let entity = CentreOfSymmetry::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<CentreOfSymmetry>(),
                    Box::new(entity),
                ))
            }
            "CERTIFICATION" => {
                let entity = Certification::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<Certification>(),
                    Box::new(entity),
                ))
            }
            "CERTIFICATION_TYPE" => {
                let entity = CertificationType::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<CertificationType>(),
                    Box::new(entity),
                ))
            }
            "CHANGE" => {
                let entity = Change::form_parameters(typed_parameter.parameters);
                Some((entity.type_id(), std::any::type_name::<Change>(), Box::new(entity)))
            }
            "CHANGE_REQUEST" => {
                let entity = ChangeRequest::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<ChangeRequest>(),
                    Box::new(entity),
                ))
            }
            "CHARACTER_GLYPH_FONT_USAGE" => {
                let entity = CharacterGlyphFontUsage::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<CharacterGlyphFontUsage>(),
                    Box::new(entity),
                ))
            }
            "CHARACTER_GLYPH_STYLE_OUTLINE" => {
                let entity = CharacterGlyphStyleOutline::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<CharacterGlyphStyleOutline>(),
                    Box::new(entity),
                ))
            }
            "CHARACTER_GLYPH_STYLE_STROKE" => {
                let entity = CharacterGlyphStyleStroke::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<CharacterGlyphStyleStroke>(),
                    Box::new(entity),
                ))
            }
            "CHARACTER_GLYPH_SYMBOL" => {
                let entity = CharacterGlyphSymbol::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<CharacterGlyphSymbol>(),
                    Box::new(entity),
                ))
            }
            "CHARACTER_GLYPH_SYMBOL_OUTLINE" => {
                let entity = CharacterGlyphSymbolOutline::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<CharacterGlyphSymbolOutline>(),
                    Box::new(entity),
                ))
            }
            "CHARACTER_GLYPH_SYMBOL_STROKE" => {
                let entity = CharacterGlyphSymbolStroke::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<CharacterGlyphSymbolStroke>(),
                    Box::new(entity),
                ))
            }
            "CHARACTERISTIC_DATA_COLUMN_HEADER" => {
                let entity = CharacteristicDataColumnHeader::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<CharacteristicDataColumnHeader>(),
                    Box::new(entity),
                ))
            }
            "CHARACTERISTIC_DATA_COLUMN_HEADER_LINK" => {
                let entity = CharacteristicDataColumnHeaderLink::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<CharacteristicDataColumnHeaderLink>(),
                    Box::new(entity),
                ))
            }
            "CHARACTERISTIC_DATA_TABLE_HEADER" => {
                let entity = CharacteristicDataTableHeader::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<CharacteristicDataTableHeader>(),
                    Box::new(entity),
                ))
            }
            "CHARACTERISTIC_DATA_TABLE_HEADER_DECOMPOSITION" => {
                let entity = CharacteristicDataTableHeaderDecomposition::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<CharacteristicDataTableHeaderDecomposition>(),
                    Box::new(entity),
                ))
            }
            "CHARACTERISTIC_TYPE" => {
                let entity = CharacteristicType::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<CharacteristicType>(),
                    Box::new(entity),
                ))
            }
            "CHARACTERIZED_CLASS" => {
                let entity = CharacterizedClass::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<CharacterizedClass>(),
                    Box::new(entity),
                ))
            }
            "CHARACTERIZED_OBJECT" => {
                let entity = CharacterizedObject::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<CharacterizedObject>(),
                    Box::new(entity),
                ))
            }
            "CIRCLE" => {
                let entity = Circle::form_parameters(typed_parameter.parameters);
                Some((entity.type_id(), std::any::type_name::<Circle>(), Box::new(entity)))
            }
            "CIRCULAR_RUNOUT_TOLERANCE" => {
                let entity = CircularRunoutTolerance::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<CircularRunoutTolerance>(),
                    Box::new(entity),
                ))
            }
            "CLASS" => {
                let entity = Class::form_parameters(typed_parameter.parameters);
                Some((entity.type_id(), std::any::type_name::<Class>(), Box::new(entity)))
            }
            "CLASS_BY_EXTENSION" => {
                let entity = ClassByExtension::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<ClassByExtension>(),
                    Box::new(entity),
                ))
            }
            "CLASS_BY_INTENSION" => {
                let entity = ClassByIntension::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<ClassByIntension>(),
                    Box::new(entity),
                ))
            }
            "CLASS_SYSTEM" => {
                let entity = ClassSystem::form_parameters(typed_parameter.parameters);
                Some((entity.type_id(), std::any::type_name::<ClassSystem>(), Box::new(entity)))
            }
            "CLASS_USAGE_EFFECTIVITY_CONTEXT_ASSIGNMENT" => {
                let entity = ClassUsageEffectivityContextAssignment::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<ClassUsageEffectivityContextAssignment>(),
                    Box::new(entity),
                ))
            }
            "CLASSIFICATION_ROLE" => {
                let entity = ClassificationRole::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<ClassificationRole>(),
                    Box::new(entity),
                ))
            }
            "CLOSED_SHELL" => {
                let entity = ClosedShell::form_parameters(typed_parameter.parameters);
                Some((entity.type_id(), std::any::type_name::<ClosedShell>(), Box::new(entity)))
            }
            "COAXIALITY_TOLERANCE" => {
                let entity = CoaxialityTolerance::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<CoaxialityTolerance>(),
                    Box::new(entity),
                ))
            }
            "COLOUR" => {
                let entity = Colour::form_parameters(typed_parameter.parameters);
                Some((entity.type_id(), std::any::type_name::<Colour>(), Box::new(entity)))
            }
            "COLOUR_RGB" => {
                let entity = ColourRgb::form_parameters(typed_parameter.parameters);
                Some((entity.type_id(), std::any::type_name::<ColourRgb>(), Box::new(entity)))
            }
            "COLOUR_SPECIFICATION" => {
                let entity = ColourSpecification::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<ColourSpecification>(),
                    Box::new(entity),
                ))
            }
            "COMMON_DATUM" => {
                let entity = CommonDatum::form_parameters(typed_parameter.parameters);
                Some((entity.type_id(), std::any::type_name::<CommonDatum>(), Box::new(entity)))
            }
            "COMPLEX_CLAUSE" => {
                let entity = ComplexClause::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<ComplexClause>(),
                    Box::new(entity),
                ))
            }
            "COMPLEX_CONJUNCTIVE_CLAUSE" => {
                let entity = ComplexConjunctiveClause::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<ComplexConjunctiveClause>(),
                    Box::new(entity),
                ))
            }
            "COMPLEX_DISJUNCTIVE_CLAUSE" => {
                let entity = ComplexDisjunctiveClause::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<ComplexDisjunctiveClause>(),
                    Box::new(entity),
                ))
            }
            "COMPLEX_SHELLED_SOLID" => {
                let entity = ComplexShelledSolid::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<ComplexShelledSolid>(),
                    Box::new(entity),
                ))
            }
            "COMPOSITE_ASSEMBLY_DEFINITION" => {
                let entity = CompositeAssemblyDefinition::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<CompositeAssemblyDefinition>(),
                    Box::new(entity),
                ))
            }
            "COMPOSITE_ASSEMBLY_SEQUENCE_DEFINITION" => {
                let entity = CompositeAssemblySequenceDefinition::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<CompositeAssemblySequenceDefinition>(),
                    Box::new(entity),
                ))
            }
            "COMPOSITE_ASSEMBLY_TABLE" => {
                let entity = CompositeAssemblyTable::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<CompositeAssemblyTable>(),
                    Box::new(entity),
                ))
            }
            "COMPOSITE_CURVE" => {
                let entity = CompositeCurve::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<CompositeCurve>(),
                    Box::new(entity),
                ))
            }
            "COMPOSITE_CURVE_ON_SURFACE" => {
                let entity = CompositeCurveOnSurface::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<CompositeCurveOnSurface>(),
                    Box::new(entity),
                ))
            }
            "COMPOSITE_CURVE_SEGMENT" => {
                let entity = CompositeCurveSegment::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<CompositeCurveSegment>(),
                    Box::new(entity),
                ))
            }
            "COMPOSITE_MATERIAL_DESIGNATION" => {
                let entity = CompositeMaterialDesignation::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<CompositeMaterialDesignation>(),
                    Box::new(entity),
                ))
            }
            "COMPOSITE_SHAPE_ASPECT" => {
                let entity = CompositeShapeAspect::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<CompositeShapeAspect>(),
                    Box::new(entity),
                ))
            }
            "COMPOSITE_SHEET_REPRESENTATION" => {
                let entity = CompositeSheetRepresentation::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<CompositeSheetRepresentation>(),
                    Box::new(entity),
                ))
            }
            "COMPOSITE_TEXT" => {
                let entity = CompositeText::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<CompositeText>(),
                    Box::new(entity),
                ))
            }
            "COMPOSITE_TEXT_WITH_ASSOCIATED_CURVES" => {
                let entity = CompositeTextWithAssociatedCurves::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<CompositeTextWithAssociatedCurves>(),
                    Box::new(entity),
                ))
            }
            "COMPOSITE_TEXT_WITH_BLANKING_BOX" => {
                let entity = CompositeTextWithBlankingBox::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<CompositeTextWithBlankingBox>(),
                    Box::new(entity),
                ))
            }
            "COMPOSITE_TEXT_WITH_DELINEATION" => {
                let entity = CompositeTextWithDelineation::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<CompositeTextWithDelineation>(),
                    Box::new(entity),
                ))
            }
            "COMPOSITE_TEXT_WITH_EXTENT" => {
                let entity = CompositeTextWithExtent::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<CompositeTextWithExtent>(),
                    Box::new(entity),
                ))
            }
            "COMPOUND_REPRESENTATION_ITEM" => {
                let entity = CompoundRepresentationItem::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<CompoundRepresentationItem>(),
                    Box::new(entity),
                ))
            }
            "COMPOUND_SHAPE_REPRESENTATION" => {
                let entity = CompoundShapeRepresentation::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<CompoundShapeRepresentation>(),
                    Box::new(entity),
                ))
            }
            "CONCENTRICITY_TOLERANCE" => {
                let entity = ConcentricityTolerance::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<ConcentricityTolerance>(),
                    Box::new(entity),
                ))
            }
            "CONCEPT_FEATURE_OPERATOR" => {
                let entity = ConceptFeatureOperator::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<ConceptFeatureOperator>(),
                    Box::new(entity),
                ))
            }
            "CONCEPT_FEATURE_RELATIONSHIP" => {
                let entity = ConceptFeatureRelationship::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<ConceptFeatureRelationship>(),
                    Box::new(entity),
                ))
            }
            "CONCEPT_FEATURE_RELATIONSHIP_WITH_CONDITION" => {
                let entity = ConceptFeatureRelationshipWithCondition::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<ConceptFeatureRelationshipWithCondition>(),
                    Box::new(entity),
                ))
            }
            "CONDITIONAL_CONCEPT_FEATURE" => {
                let entity = ConditionalConceptFeature::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<ConditionalConceptFeature>(),
                    Box::new(entity),
                ))
            }
            "CONDUCTANCE_MEASURE_WITH_UNIT" => {
                let entity = ConductanceMeasureWithUnit::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<ConductanceMeasureWithUnit>(),
                    Box::new(entity),
                ))
            }
            "CONDUCTANCE_UNIT" => {
                let entity = ConductanceUnit::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<ConductanceUnit>(),
                    Box::new(entity),
                ))
            }
            "CONFIGURABLE_ITEM" => {
                let entity = ConfigurableItem::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<ConfigurableItem>(),
                    Box::new(entity),
                ))
            }
            "CONFIGURATION_DESIGN" => {
                let entity = ConfigurationDesign::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<ConfigurationDesign>(),
                    Box::new(entity),
                ))
            }
            "CONFIGURATION_EFFECTIVITY" => {
                let entity = ConfigurationEffectivity::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<ConfigurationEffectivity>(),
                    Box::new(entity),
                ))
            }
            "CONFIGURATION_ITEM" => {
                let entity = ConfigurationItem::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<ConfigurationItem>(),
                    Box::new(entity),
                ))
            }
            "CONFIGURED_EFFECTIVITY_ASSIGNMENT" => {
                let entity = ConfiguredEffectivityAssignment::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<ConfiguredEffectivityAssignment>(),
                    Box::new(entity),
                ))
            }
            "CONFIGURED_EFFECTIVITY_CONTEXT_ASSIGNMENT" => {
                let entity = ConfiguredEffectivityContextAssignment::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<ConfiguredEffectivityContextAssignment>(),
                    Box::new(entity),
                ))
            }
            "CONIC" => {
                let entity = Conic::form_parameters(typed_parameter.parameters);
                Some((entity.type_id(), std::any::type_name::<Conic>(), Box::new(entity)))
            }
            "CONICAL_STEPPED_HOLE_TRANSITION" => {
                let entity = ConicalSteppedHoleTransition::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<ConicalSteppedHoleTransition>(),
                    Box::new(entity),
                ))
            }
            "CONICAL_SURFACE" => {
                let entity = ConicalSurface::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<ConicalSurface>(),
                    Box::new(entity),
                ))
            }
            "CONNECTED_EDGE_SET" => {
                let entity = ConnectedEdgeSet::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<ConnectedEdgeSet>(),
                    Box::new(entity),
                ))
            }
            "CONNECTED_FACE_SET" => {
                let entity = ConnectedFaceSet::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<ConnectedFaceSet>(),
                    Box::new(entity),
                ))
            }
            "CONNECTED_FACE_SUB_SET" => {
                let entity = ConnectedFaceSubSet::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<ConnectedFaceSubSet>(),
                    Box::new(entity),
                ))
            }
            "CONSTRUCTIVE_GEOMETRY_REPRESENTATION" => {
                let entity = ConstructiveGeometryRepresentation::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<ConstructiveGeometryRepresentation>(),
                    Box::new(entity),
                ))
            }
            "CONSTRUCTIVE_GEOMETRY_REPRESENTATION_RELATIONSHIP" => {
                let entity =
                    ConstructiveGeometryRepresentationRelationship::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<ConstructiveGeometryRepresentationRelationship>(),
                    Box::new(entity),
                ))
            }
            "CONTACT_RATIO_REPRESENTATION" => {
                let entity = ContactRatioRepresentation::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<ContactRatioRepresentation>(),
                    Box::new(entity),
                ))
            }
            "CONTEXT_DEPENDENT_INVISIBILITY" => {
                let entity = ContextDependentInvisibility::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<ContextDependentInvisibility>(),
                    Box::new(entity),
                ))
            }
            "CONTEXT_DEPENDENT_OVER_RIDING_STYLED_ITEM" => {
                let entity = ContextDependentOverRidingStyledItem::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<ContextDependentOverRidingStyledItem>(),
                    Box::new(entity),
                ))
            }
            "CONTEXT_DEPENDENT_SHAPE_REPRESENTATION" => {
                let entity = ContextDependentShapeRepresentation::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<ContextDependentShapeRepresentation>(),
                    Box::new(entity),
                ))
            }
            "CONTEXT_DEPENDENT_UNIT" => {
                let entity = ContextDependentUnit::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<ContextDependentUnit>(),
                    Box::new(entity),
                ))
            }
            "CONTRACT" => {
                let entity = Contract::form_parameters(typed_parameter.parameters);
                Some((entity.type_id(), std::any::type_name::<Contract>(), Box::new(entity)))
            }
            "CONTRACT_TYPE" => {
                let entity = ContractType::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<ContractType>(),
                    Box::new(entity),
                ))
            }
            "CONVERSION_BASED_UNIT" => {
                let entity = ConversionBasedUnit::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<ConversionBasedUnit>(),
                    Box::new(entity),
                ))
            }
            "COORDINATED_UNIVERSAL_TIME_OFFSET" => {
                let entity = CoordinatedUniversalTimeOffset::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<CoordinatedUniversalTimeOffset>(),
                    Box::new(entity),
                ))
            }
            "CSG_SHAPE_REPRESENTATION" => {
                let entity = CsgShapeRepresentation::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<CsgShapeRepresentation>(),
                    Box::new(entity),
                ))
            }
            "CSG_SOLID" => {
                let entity = CsgSolid::form_parameters(typed_parameter.parameters);
                Some((entity.type_id(), std::any::type_name::<CsgSolid>(), Box::new(entity)))
            }
            "CURRENCY_MEASURE_WITH_UNIT" => {
                let entity = CurrencyMeasureWithUnit::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<CurrencyMeasureWithUnit>(),
                    Box::new(entity),
                ))
            }
            "CURVE" => {
                let entity = Curve::form_parameters(typed_parameter.parameters);
                Some((entity.type_id(), std::any::type_name::<Curve>(), Box::new(entity)))
            }
            "CURVE_BOUNDED_SURFACE" => {
                let entity = CurveBoundedSurface::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<CurveBoundedSurface>(),
                    Box::new(entity),
                ))
            }
            "CURVE_DIMENSION" => {
                let entity = CurveDimension::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<CurveDimension>(),
                    Box::new(entity),
                ))
            }
            "CURVE_REPLICA" => {
                let entity = CurveReplica::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<CurveReplica>(),
                    Box::new(entity),
                ))
            }
            "CURVE_STYLE" => {
                let entity = CurveStyle::form_parameters(typed_parameter.parameters);
                Some((entity.type_id(), std::any::type_name::<CurveStyle>(), Box::new(entity)))
            }
            "CURVE_STYLE_FONT" => {
                let entity = CurveStyleFont::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<CurveStyleFont>(),
                    Box::new(entity),
                ))
            }
            "CURVE_STYLE_FONT_AND_SCALING" => {
                let entity = CurveStyleFontAndScaling::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<CurveStyleFontAndScaling>(),
                    Box::new(entity),
                ))
            }
            "CURVE_STYLE_FONT_PATTERN" => {
                let entity = CurveStyleFontPattern::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<CurveStyleFontPattern>(),
                    Box::new(entity),
                ))
            }
            "CURVE_STYLE_RENDERING" => {
                let entity = CurveStyleRendering::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<CurveStyleRendering>(),
                    Box::new(entity),
                ))
            }
            "CURVE_SWEPT_SOLID_SHAPE_REPRESENTATION" => {
                let entity = CurveSweptSolidShapeRepresentation::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<CurveSweptSolidShapeRepresentation>(),
                    Box::new(entity),
                ))
            }
            "CYLINDRICAL_SURFACE" => {
                let entity = CylindricalSurface::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<CylindricalSurface>(),
                    Box::new(entity),
                ))
            }
            "CYLINDRICITY_TOLERANCE" => {
                let entity = CylindricityTolerance::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<CylindricityTolerance>(),
                    Box::new(entity),
                ))
            }
            "DATA_ENVIRONMENT" => {
                let entity = DataEnvironment::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<DataEnvironment>(),
                    Box::new(entity),
                ))
            }
            "DATE" => {
                let entity = Date::form_parameters(typed_parameter.parameters);
                Some((entity.type_id(), std::any::type_name::<Date>(), Box::new(entity)))
            }
            "DATE_AND_TIME" => {
                let entity = DateAndTime::form_parameters(typed_parameter.parameters);
                Some((entity.type_id(), std::any::type_name::<DateAndTime>(), Box::new(entity)))
            }
            "DATE_REPRESENTATION_ITEM" => {
                let entity = DateRepresentationItem::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<DateRepresentationItem>(),
                    Box::new(entity),
                ))
            }
            "DATE_ROLE" => {
                let entity = DateRole::form_parameters(typed_parameter.parameters);
                Some((entity.type_id(), std::any::type_name::<DateRole>(), Box::new(entity)))
            }
            "DATE_TIME_REPRESENTATION_ITEM" => {
                let entity = DateTimeRepresentationItem::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<DateTimeRepresentationItem>(),
                    Box::new(entity),
                ))
            }
            "DATE_TIME_ROLE" => {
                let entity = DateTimeRole::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<DateTimeRole>(),
                    Box::new(entity),
                ))
            }
            "DATED_EFFECTIVITY" => {
                let entity = DatedEffectivity::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<DatedEffectivity>(),
                    Box::new(entity),
                ))
            }
            "DATUM" => {
                let entity = Datum::form_parameters(typed_parameter.parameters);
                Some((entity.type_id(), std::any::type_name::<Datum>(), Box::new(entity)))
            }
            "DATUM_FEATURE" => {
                let entity = DatumFeature::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<DatumFeature>(),
                    Box::new(entity),
                ))
            }
            "DATUM_FEATURE_CALLOUT" => {
                let entity = DatumFeatureCallout::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<DatumFeatureCallout>(),
                    Box::new(entity),
                ))
            }
            "DATUM_REFERENCE" => {
                let entity = DatumReference::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<DatumReference>(),
                    Box::new(entity),
                ))
            }
            "DATUM_TARGET" => {
                let entity = DatumTarget::form_parameters(typed_parameter.parameters);
                Some((entity.type_id(), std::any::type_name::<DatumTarget>(), Box::new(entity)))
            }
            "DATUM_TARGET_CALLOUT" => {
                let entity = DatumTargetCallout::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<DatumTargetCallout>(),
                    Box::new(entity),
                ))
            }
            "DEFAULT_TOLERANCE_TABLE" => {
                let entity = DefaultToleranceTable::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<DefaultToleranceTable>(),
                    Box::new(entity),
                ))
            }
            "DEFAULT_TOLERANCE_TABLE_CELL" => {
                let entity = DefaultToleranceTableCell::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<DefaultToleranceTableCell>(),
                    Box::new(entity),
                ))
            }
            "DEFINED_SYMBOL" => {
                let entity = DefinedSymbol::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<DefinedSymbol>(),
                    Box::new(entity),
                ))
            }
            "DEFINITIONAL_REPRESENTATION" => {
                let entity = DefinitionalRepresentation::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<DefinitionalRepresentation>(),
                    Box::new(entity),
                ))
            }
            "DEFINITIONAL_REPRESENTATION_RELATIONSHIP" => {
                let entity = DefinitionalRepresentationRelationship::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<DefinitionalRepresentationRelationship>(),
                    Box::new(entity),
                ))
            }
            "DEFINITIONAL_REPRESENTATION_RELATIONSHIP_WITH_SAME_CONTEXT" => {
                let entity =
                    DefinitionalRepresentationRelationshipWithSameContext::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<DefinitionalRepresentationRelationshipWithSameContext>(),
                    Box::new(entity),
                ))
            }
            "DEGENERATE_PCURVE" => {
                let entity = DegeneratePcurve::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<DegeneratePcurve>(),
                    Box::new(entity),
                ))
            }
            "DEGENERATE_TOROIDAL_SURFACE" => {
                let entity = DegenerateToroidalSurface::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<DegenerateToroidalSurface>(),
                    Box::new(entity),
                ))
            }
            "DERIVED_SHAPE_ASPECT" => {
                let entity = DerivedShapeAspect::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<DerivedShapeAspect>(),
                    Box::new(entity),
                ))
            }
            "DERIVED_UNIT" => {
                let entity = DerivedUnit::form_parameters(typed_parameter.parameters);
                Some((entity.type_id(), std::any::type_name::<DerivedUnit>(), Box::new(entity)))
            }
            "DERIVED_UNIT_ELEMENT" => {
                let entity = DerivedUnitElement::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<DerivedUnitElement>(),
                    Box::new(entity),
                ))
            }
            "DESCRIPTION_ATTRIBUTE" => {
                let entity = DescriptionAttribute::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<DescriptionAttribute>(),
                    Box::new(entity),
                ))
            }
            "DESCRIPTIVE_REPRESENTATION_ITEM" => {
                let entity = DescriptiveRepresentationItem::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<DescriptiveRepresentationItem>(),
                    Box::new(entity),
                ))
            }
            "DESIGN_CONTEXT" => {
                let entity = DesignContext::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<DesignContext>(),
                    Box::new(entity),
                ))
            }
            "DESIGN_MAKE_FROM_RELATIONSHIP" => {
                let entity = DesignMakeFromRelationship::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<DesignMakeFromRelationship>(),
                    Box::new(entity),
                ))
            }
            "DIAMETER_DIMENSION" => {
                let entity = DiameterDimension::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<DiameterDimension>(),
                    Box::new(entity),
                ))
            }
            "DIELECTRIC_CONSTANT_MEASURE_WITH_UNIT" => {
                let entity = DielectricConstantMeasureWithUnit::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<DielectricConstantMeasureWithUnit>(),
                    Box::new(entity),
                ))
            }
            "DIMENSION_CALLOUT" => {
                let entity = DimensionCallout::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<DimensionCallout>(),
                    Box::new(entity),
                ))
            }
            "DIMENSION_CALLOUT_COMPONENT_RELATIONSHIP" => {
                let entity = DimensionCalloutComponentRelationship::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<DimensionCalloutComponentRelationship>(),
                    Box::new(entity),
                ))
            }
            "DIMENSION_CALLOUT_RELATIONSHIP" => {
                let entity = DimensionCalloutRelationship::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<DimensionCalloutRelationship>(),
                    Box::new(entity),
                ))
            }
            "DIMENSION_CURVE" => {
                let entity = DimensionCurve::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<DimensionCurve>(),
                    Box::new(entity),
                ))
            }
            "DIMENSION_CURVE_DIRECTED_CALLOUT" => {
                let entity = DimensionCurveDirectedCallout::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<DimensionCurveDirectedCallout>(),
                    Box::new(entity),
                ))
            }
            "DIMENSION_CURVE_TERMINATOR" => {
                let entity = DimensionCurveTerminator::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<DimensionCurveTerminator>(),
                    Box::new(entity),
                ))
            }
            "DIMENSION_CURVE_TERMINATOR_TO_PROJECTION_CURVE_ASSOCIATIVITY" => {
                let entity =
                    DimensionCurveTerminatorToProjectionCurveAssociativity::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<DimensionCurveTerminatorToProjectionCurveAssociativity>(),
                    Box::new(entity),
                ))
            }
            "DIMENSION_PAIR" => {
                let entity = DimensionPair::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<DimensionPair>(),
                    Box::new(entity),
                ))
            }
            "DIMENSION_RELATED_TOLERANCE_ZONE_ELEMENT" => {
                let entity = DimensionRelatedToleranceZoneElement::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<DimensionRelatedToleranceZoneElement>(),
                    Box::new(entity),
                ))
            }
            "DIMENSION_TEXT_ASSOCIATIVITY" => {
                let entity = DimensionTextAssociativity::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<DimensionTextAssociativity>(),
                    Box::new(entity),
                ))
            }
            "DIMENSIONAL_CHARACTERISTIC_REPRESENTATION" => {
                let entity = DimensionalCharacteristicRepresentation::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<DimensionalCharacteristicRepresentation>(),
                    Box::new(entity),
                ))
            }
            "DIMENSIONAL_EXPONENTS" => {
                let entity = DimensionalExponents::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<DimensionalExponents>(),
                    Box::new(entity),
                ))
            }
            "DIMENSIONAL_LOCATION" => {
                let entity = DimensionalLocation::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<DimensionalLocation>(),
                    Box::new(entity),
                ))
            }
            "DIMENSIONAL_LOCATION_WITH_PATH" => {
                let entity = DimensionalLocationWithPath::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<DimensionalLocationWithPath>(),
                    Box::new(entity),
                ))
            }
            "DIMENSIONAL_SIZE" => {
                let entity = DimensionalSize::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<DimensionalSize>(),
                    Box::new(entity),
                ))
            }
            "DIMENSIONAL_SIZE_WITH_PATH" => {
                let entity = DimensionalSizeWithPath::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<DimensionalSizeWithPath>(),
                    Box::new(entity),
                ))
            }
            "DIRECTED_ACTION" => {
                let entity = DirectedAction::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<DirectedAction>(),
                    Box::new(entity),
                ))
            }
            "DIRECTED_DIMENSIONAL_LOCATION" => {
                let entity = DirectedDimensionalLocation::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<DirectedDimensionalLocation>(),
                    Box::new(entity),
                ))
            }
            "DIRECTION" => {
                let entity = Direction::form_parameters(typed_parameter.parameters);
                Some((entity.type_id(), std::any::type_name::<Direction>(), Box::new(entity)))
            }
            "DOCUMENT" => {
                let entity = Document::form_parameters(typed_parameter.parameters);
                Some((entity.type_id(), std::any::type_name::<Document>(), Box::new(entity)))
            }
            "DOCUMENT_FILE" => {
                let entity = DocumentFile::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<DocumentFile>(),
                    Box::new(entity),
                ))
            }
            "DOCUMENT_IDENTIFIER" => {
                let entity = DocumentIdentifier::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<DocumentIdentifier>(),
                    Box::new(entity),
                ))
            }
            "DOCUMENT_IDENTIFIER_ASSIGNMENT" => {
                let entity = DocumentIdentifierAssignment::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<DocumentIdentifierAssignment>(),
                    Box::new(entity),
                ))
            }
            "DOCUMENT_PRODUCT_ASSOCIATION" => {
                let entity = DocumentProductAssociation::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<DocumentProductAssociation>(),
                    Box::new(entity),
                ))
            }
            "DOCUMENT_PRODUCT_EQUIVALENCE" => {
                let entity = DocumentProductEquivalence::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<DocumentProductEquivalence>(),
                    Box::new(entity),
                ))
            }
            "DOCUMENT_RELATIONSHIP" => {
                let entity = DocumentRelationship::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<DocumentRelationship>(),
                    Box::new(entity),
                ))
            }
            "DOCUMENT_REPRESENTATION_TYPE" => {
                let entity = DocumentRepresentationType::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<DocumentRepresentationType>(),
                    Box::new(entity),
                ))
            }
            "DOCUMENT_TYPE" => {
                let entity = DocumentType::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<DocumentType>(),
                    Box::new(entity),
                ))
            }
            "DOCUMENT_USAGE_CONSTRAINT" => {
                let entity = DocumentUsageConstraint::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<DocumentUsageConstraint>(),
                    Box::new(entity),
                ))
            }
            "DOCUMENT_USAGE_ROLE" => {
                let entity = DocumentUsageRole::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<DocumentUsageRole>(),
                    Box::new(entity),
                ))
            }
            "DOSE_EQUIVALENT_MEASURE_WITH_UNIT" => {
                let entity = DoseEquivalentMeasureWithUnit::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<DoseEquivalentMeasureWithUnit>(),
                    Box::new(entity),
                ))
            }
            "DOSE_EQUIVALENT_UNIT" => {
                let entity = DoseEquivalentUnit::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<DoseEquivalentUnit>(),
                    Box::new(entity),
                ))
            }
            "DOUBLE_OFFSET_SHELLED_SOLID" => {
                let entity = DoubleOffsetShelledSolid::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<DoubleOffsetShelledSolid>(),
                    Box::new(entity),
                ))
            }
            "DRAPED_DEFINED_TRANSFORMATION" => {
                let entity = DrapedDefinedTransformation::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<DrapedDefinedTransformation>(),
                    Box::new(entity),
                ))
            }
            "DRAUGHTING_ANNOTATION_OCCURRENCE" => {
                let entity = DraughtingAnnotationOccurrence::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<DraughtingAnnotationOccurrence>(),
                    Box::new(entity),
                ))
            }
            "DRAUGHTING_CALLOUT" => {
                let entity = DraughtingCallout::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<DraughtingCallout>(),
                    Box::new(entity),
                ))
            }
            "DRAUGHTING_CALLOUT_RELATIONSHIP" => {
                let entity = DraughtingCalloutRelationship::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<DraughtingCalloutRelationship>(),
                    Box::new(entity),
                ))
            }
            "DRAUGHTING_ELEMENTS" => {
                let entity = DraughtingElements::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<DraughtingElements>(),
                    Box::new(entity),
                ))
            }
            "DRAUGHTING_MODEL" => {
                let entity = DraughtingModel::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<DraughtingModel>(),
                    Box::new(entity),
                ))
            }
            "DRAUGHTING_MODEL_ITEM_ASSOCIATION" => {
                let entity = DraughtingModelItemAssociation::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<DraughtingModelItemAssociation>(),
                    Box::new(entity),
                ))
            }
            "DRAUGHTING_PRE_DEFINED_COLOUR" => {
                let entity = DraughtingPreDefinedColour::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<DraughtingPreDefinedColour>(),
                    Box::new(entity),
                ))
            }
            "DRAUGHTING_PRE_DEFINED_CURVE_FONT" => {
                let entity = DraughtingPreDefinedCurveFont::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<DraughtingPreDefinedCurveFont>(),
                    Box::new(entity),
                ))
            }
            "DRAUGHTING_PRE_DEFINED_TEXT_FONT" => {
                let entity = DraughtingPreDefinedTextFont::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<DraughtingPreDefinedTextFont>(),
                    Box::new(entity),
                ))
            }
            "DRAUGHTING_SUBFIGURE_REPRESENTATION" => {
                let entity = DraughtingSubfigureRepresentation::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<DraughtingSubfigureRepresentation>(),
                    Box::new(entity),
                ))
            }
            "DRAUGHTING_SYMBOL_REPRESENTATION" => {
                let entity = DraughtingSymbolRepresentation::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<DraughtingSymbolRepresentation>(),
                    Box::new(entity),
                ))
            }
            "DRAUGHTING_TEXT_LITERAL_WITH_DELINEATION" => {
                let entity = DraughtingTextLiteralWithDelineation::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<DraughtingTextLiteralWithDelineation>(),
                    Box::new(entity),
                ))
            }
            "DRAUGHTING_TITLE" => {
                let entity = DraughtingTitle::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<DraughtingTitle>(),
                    Box::new(entity),
                ))
            }
            "DRAWING_DEFINITION" => {
                let entity = DrawingDefinition::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<DrawingDefinition>(),
                    Box::new(entity),
                ))
            }
            "DRAWING_REVISION" => {
                let entity = DrawingRevision::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<DrawingRevision>(),
                    Box::new(entity),
                ))
            }
            "DRAWING_REVISION_SEQUENCE" => {
                let entity = DrawingRevisionSequence::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<DrawingRevisionSequence>(),
                    Box::new(entity),
                ))
            }
            "DRAWING_SHEET_REVISION" => {
                let entity = DrawingSheetRevision::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<DrawingSheetRevision>(),
                    Box::new(entity),
                ))
            }
            "DRAWING_SHEET_REVISION_SEQUENCE" => {
                let entity = DrawingSheetRevisionSequence::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<DrawingSheetRevisionSequence>(),
                    Box::new(entity),
                ))
            }
            "DRAWING_SHEET_REVISION_USAGE" => {
                let entity = DrawingSheetRevisionUsage::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<DrawingSheetRevisionUsage>(),
                    Box::new(entity),
                ))
            }
            "EDGE" => {
                let entity = Edge::form_parameters(typed_parameter.parameters);
                Some((entity.type_id(), std::any::type_name::<Edge>(), Box::new(entity)))
            }
            "EDGE_BASED_WIREFRAME_MODEL" => {
                let entity = EdgeBasedWireframeModel::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<EdgeBasedWireframeModel>(),
                    Box::new(entity),
                ))
            }
            "EDGE_BASED_WIREFRAME_SHAPE_REPRESENTATION" => {
                let entity = EdgeBasedWireframeShapeRepresentation::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<EdgeBasedWireframeShapeRepresentation>(),
                    Box::new(entity),
                ))
            }
            "EDGE_CURVE" => {
                let entity = EdgeCurve::form_parameters(typed_parameter.parameters);
                Some((entity.type_id(), std::any::type_name::<EdgeCurve>(), Box::new(entity)))
            }
            "EDGE_LOOP" => {
                let entity = EdgeLoop::form_parameters(typed_parameter.parameters);
                Some((entity.type_id(), std::any::type_name::<EdgeLoop>(), Box::new(entity)))
            }
            "EFFECTIVITY" => {
                let entity = Effectivity::form_parameters(typed_parameter.parameters);
                Some((entity.type_id(), std::any::type_name::<Effectivity>(), Box::new(entity)))
            }
            "EFFECTIVITY_CONTEXT_ROLE" => {
                let entity = EffectivityContextRole::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<EffectivityContextRole>(),
                    Box::new(entity),
                ))
            }
            "EFFECTIVITY_RELATIONSHIP" => {
                let entity = EffectivityRelationship::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<EffectivityRelationship>(),
                    Box::new(entity),
                ))
            }
            "ELECTRIC_CHARGE_MEASURE_WITH_UNIT" => {
                let entity = ElectricChargeMeasureWithUnit::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<ElectricChargeMeasureWithUnit>(),
                    Box::new(entity),
                ))
            }
            "ELECTRIC_CHARGE_UNIT" => {
                let entity = ElectricChargeUnit::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<ElectricChargeUnit>(),
                    Box::new(entity),
                ))
            }
            "ELECTRIC_CURRENT_MEASURE_WITH_UNIT" => {
                let entity = ElectricCurrentMeasureWithUnit::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<ElectricCurrentMeasureWithUnit>(),
                    Box::new(entity),
                ))
            }
            "ELECTRIC_CURRENT_UNIT" => {
                let entity = ElectricCurrentUnit::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<ElectricCurrentUnit>(),
                    Box::new(entity),
                ))
            }
            "ELECTRIC_POTENTIAL_MEASURE_WITH_UNIT" => {
                let entity = ElectricPotentialMeasureWithUnit::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<ElectricPotentialMeasureWithUnit>(),
                    Box::new(entity),
                ))
            }
            "ELECTRIC_POTENTIAL_UNIT" => {
                let entity = ElectricPotentialUnit::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<ElectricPotentialUnit>(),
                    Box::new(entity),
                ))
            }
            "ELEMENTARY_BREP_SHAPE_REPRESENTATION" => {
                let entity = ElementaryBrepShapeRepresentation::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<ElementaryBrepShapeRepresentation>(),
                    Box::new(entity),
                ))
            }
            "ELEMENTARY_SURFACE" => {
                let entity = ElementarySurface::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<ElementarySurface>(),
                    Box::new(entity),
                ))
            }
            "ELLIPSE" => {
                let entity = Ellipse::form_parameters(typed_parameter.parameters);
                Some((entity.type_id(), std::any::type_name::<Ellipse>(), Box::new(entity)))
            }
            "ENERGY_MEASURE_WITH_UNIT" => {
                let entity = EnergyMeasureWithUnit::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<EnergyMeasureWithUnit>(),
                    Box::new(entity),
                ))
            }
            "ENERGY_UNIT" => {
                let entity = EnergyUnit::form_parameters(typed_parameter.parameters);
                Some((entity.type_id(), std::any::type_name::<EnergyUnit>(), Box::new(entity)))
            }
            "ENTITY_ASSERTION" => {
                let entity = EntityAssertion::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<EntityAssertion>(),
                    Box::new(entity),
                ))
            }
            "ENUM_REFERENCE_PREFIX" => {
                let entity = EnumReferencePrefix::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<EnumReferencePrefix>(),
                    Box::new(entity),
                ))
            }
            "ENVIRONMENT" => {
                let entity = Environment::form_parameters(typed_parameter.parameters);
                Some((entity.type_id(), std::any::type_name::<Environment>(), Box::new(entity)))
            }
            "EVALUATED_CHARACTERISTIC" => {
                let entity = EvaluatedCharacteristic::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<EvaluatedCharacteristic>(),
                    Box::new(entity),
                ))
            }
            "EVALUATED_DEGENERATE_PCURVE" => {
                let entity = EvaluatedDegeneratePcurve::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<EvaluatedDegeneratePcurve>(),
                    Box::new(entity),
                ))
            }
            "EVALUATION_PRODUCT_DEFINITION" => {
                let entity = EvaluationProductDefinition::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<EvaluationProductDefinition>(),
                    Box::new(entity),
                ))
            }
            "EVENT_OCCURRENCE" => {
                let entity = EventOccurrence::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<EventOccurrence>(),
                    Box::new(entity),
                ))
            }
            "EVENT_OCCURRENCE_RELATIONSHIP" => {
                let entity = EventOccurrenceRelationship::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<EventOccurrenceRelationship>(),
                    Box::new(entity),
                ))
            }
            "EVENT_OCCURRENCE_ROLE" => {
                let entity = EventOccurrenceRole::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<EventOccurrenceRole>(),
                    Box::new(entity),
                ))
            }
            "EXCLUSIVE_PRODUCT_CONCEPT_FEATURE_CATEGORY" => {
                let entity = ExclusiveProductConceptFeatureCategory::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<ExclusiveProductConceptFeatureCategory>(),
                    Box::new(entity),
                ))
            }
            "EXECUTED_ACTION" => {
                let entity = ExecutedAction::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<ExecutedAction>(),
                    Box::new(entity),
                ))
            }
            "EXPANDED_UNCERTAINTY" => {
                let entity = ExpandedUncertainty::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<ExpandedUncertainty>(),
                    Box::new(entity),
                ))
            }
            "EXPLICIT_PROCEDURAL_GEOMETRIC_REPRESENTATION_ITEM_RELATIONSHIP" => {
                let entity = ExplicitProceduralGeometricRepresentationItemRelationship::form_parameters(
                    typed_parameter.parameters,
                );
                Some((
                    entity.type_id(),
                    std::any::type_name::<ExplicitProceduralGeometricRepresentationItemRelationship>(),
                    Box::new(entity),
                ))
            }
            "EXPLICIT_PROCEDURAL_REPRESENTATION_ITEM_RELATIONSHIP" => {
                let entity =
                    ExplicitProceduralRepresentationItemRelationship::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<ExplicitProceduralRepresentationItemRelationship>(),
                    Box::new(entity),
                ))
            }
            "EXPLICIT_PROCEDURAL_REPRESENTATION_RELATIONSHIP" => {
                let entity = ExplicitProceduralRepresentationRelationship::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<ExplicitProceduralRepresentationRelationship>(),
                    Box::new(entity),
                ))
            }
            "EXPLICIT_PROCEDURAL_SHAPE_REPRESENTATION_RELATIONSHIP" => {
                let entity =
                    ExplicitProceduralShapeRepresentationRelationship::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<ExplicitProceduralShapeRepresentationRelationship>(),
                    Box::new(entity),
                ))
            }
            "EXPRESSION_CONVERSION_BASED_UNIT" => {
                let entity = ExpressionConversionBasedUnit::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<ExpressionConversionBasedUnit>(),
                    Box::new(entity),
                ))
            }
            "EXTENSION" => {
                let entity = Extension::form_parameters(typed_parameter.parameters);
                Some((entity.type_id(), std::any::type_name::<Extension>(), Box::new(entity)))
            }
            "EXTENT" => {
                let entity = Extent::form_parameters(typed_parameter.parameters);
                Some((entity.type_id(), std::any::type_name::<Extent>(), Box::new(entity)))
            }
            "EXTERNAL_CLASS_LIBRARY" => {
                let entity = ExternalClassLibrary::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<ExternalClassLibrary>(),
                    Box::new(entity),
                ))
            }
            "EXTERNAL_SOURCE" => {
                let entity = ExternalSource::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<ExternalSource>(),
                    Box::new(entity),
                ))
            }
            "EXTERNAL_SOURCE_RELATIONSHIP" => {
                let entity = ExternalSourceRelationship::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<ExternalSourceRelationship>(),
                    Box::new(entity),
                ))
            }
            "EXTERNALLY_DEFINED_CLASS" => {
                let entity = ExternallyDefinedClass::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<ExternallyDefinedClass>(),
                    Box::new(entity),
                ))
            }
            "EXTERNALLY_DEFINED_COLOUR" => {
                let entity = ExternallyDefinedColour::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<ExternallyDefinedColour>(),
                    Box::new(entity),
                ))
            }
            "EXTERNALLY_DEFINED_CONTEXT_DEPENDENT_UNIT" => {
                let entity = ExternallyDefinedContextDependentUnit::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<ExternallyDefinedContextDependentUnit>(),
                    Box::new(entity),
                ))
            }
            "EXTERNALLY_DEFINED_CONVERSION_BASED_UNIT" => {
                let entity = ExternallyDefinedConversionBasedUnit::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<ExternallyDefinedConversionBasedUnit>(),
                    Box::new(entity),
                ))
            }
            "EXTERNALLY_DEFINED_CURRENCY" => {
                let entity = ExternallyDefinedCurrency::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<ExternallyDefinedCurrency>(),
                    Box::new(entity),
                ))
            }
            "EXTERNALLY_DEFINED_CURVE_FONT" => {
                let entity = ExternallyDefinedCurveFont::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<ExternallyDefinedCurveFont>(),
                    Box::new(entity),
                ))
            }
            "EXTERNALLY_DEFINED_DIMENSION_DEFINITION" => {
                let entity = ExternallyDefinedDimensionDefinition::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<ExternallyDefinedDimensionDefinition>(),
                    Box::new(entity),
                ))
            }
            "EXTERNALLY_DEFINED_GENERAL_PROPERTY" => {
                let entity = ExternallyDefinedGeneralProperty::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<ExternallyDefinedGeneralProperty>(),
                    Box::new(entity),
                ))
            }
            "EXTERNALLY_DEFINED_HATCH_STYLE" => {
                let entity = ExternallyDefinedHatchStyle::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<ExternallyDefinedHatchStyle>(),
                    Box::new(entity),
                ))
            }
            "EXTERNALLY_DEFINED_ITEM" => {
                let entity = ExternallyDefinedItem::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<ExternallyDefinedItem>(),
                    Box::new(entity),
                ))
            }
            "EXTERNALLY_DEFINED_ITEM_RELATIONSHIP" => {
                let entity = ExternallyDefinedItemRelationship::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<ExternallyDefinedItemRelationship>(),
                    Box::new(entity),
                ))
            }
            "EXTERNALLY_DEFINED_MARKER" => {
                let entity = ExternallyDefinedMarker::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<ExternallyDefinedMarker>(),
                    Box::new(entity),
                ))
            }
            "EXTERNALLY_DEFINED_PICTURE_REPRESENTATION_ITEM" => {
                let entity = ExternallyDefinedPictureRepresentationItem::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<ExternallyDefinedPictureRepresentationItem>(),
                    Box::new(entity),
                ))
            }
            "EXTERNALLY_DEFINED_REPRESENTATION_ITEM" => {
                let entity = ExternallyDefinedRepresentationItem::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<ExternallyDefinedRepresentationItem>(),
                    Box::new(entity),
                ))
            }
            "EXTERNALLY_DEFINED_STRING" => {
                let entity = ExternallyDefinedString::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<ExternallyDefinedString>(),
                    Box::new(entity),
                ))
            }
            "EXTERNALLY_DEFINED_SYMBOL" => {
                let entity = ExternallyDefinedSymbol::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<ExternallyDefinedSymbol>(),
                    Box::new(entity),
                ))
            }
            "EXTERNALLY_DEFINED_TERMINATOR_SYMBOL" => {
                let entity = ExternallyDefinedTerminatorSymbol::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<ExternallyDefinedTerminatorSymbol>(),
                    Box::new(entity),
                ))
            }
            "EXTERNALLY_DEFINED_TEXT_FONT" => {
                let entity = ExternallyDefinedTextFont::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<ExternallyDefinedTextFont>(),
                    Box::new(entity),
                ))
            }
            "EXTERNALLY_DEFINED_TILE" => {
                let entity = ExternallyDefinedTile::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<ExternallyDefinedTile>(),
                    Box::new(entity),
                ))
            }
            "EXTERNALLY_DEFINED_TILE_STYLE" => {
                let entity = ExternallyDefinedTileStyle::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<ExternallyDefinedTileStyle>(),
                    Box::new(entity),
                ))
            }
            "EXTRUDED_AREA_SOLID" => {
                let entity = ExtrudedAreaSolid::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<ExtrudedAreaSolid>(),
                    Box::new(entity),
                ))
            }
            "EXTRUDED_FACE_SOLID" => {
                let entity = ExtrudedFaceSolid::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<ExtrudedFaceSolid>(),
                    Box::new(entity),
                ))
            }
            "EXTRUDED_FACE_SOLID_WITH_DRAFT_ANGLE" => {
                let entity = ExtrudedFaceSolidWithDraftAngle::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<ExtrudedFaceSolidWithDraftAngle>(),
                    Box::new(entity),
                ))
            }
            "EXTRUDED_FACE_SOLID_WITH_MULTIPLE_DRAFT_ANGLES" => {
                let entity = ExtrudedFaceSolidWithMultipleDraftAngles::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<ExtrudedFaceSolidWithMultipleDraftAngles>(),
                    Box::new(entity),
                ))
            }
            "EXTRUDED_FACE_SOLID_WITH_TRIM_CONDITIONS" => {
                let entity = ExtrudedFaceSolidWithTrimConditions::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<ExtrudedFaceSolidWithTrimConditions>(),
                    Box::new(entity),
                ))
            }
            "FACE" => {
                let entity = Face::form_parameters(typed_parameter.parameters);
                Some((entity.type_id(), std::any::type_name::<Face>(), Box::new(entity)))
            }
            "FACE_BASED_SURFACE_MODEL" => {
                let entity = FaceBasedSurfaceModel::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<FaceBasedSurfaceModel>(),
                    Box::new(entity),
                ))
            }
            "FACE_BOUND" => {
                let entity = FaceBound::form_parameters(typed_parameter.parameters);
                Some((entity.type_id(), std::any::type_name::<FaceBound>(), Box::new(entity)))
            }
            "FACE_OUTER_BOUND" => {
                let entity = FaceOuterBound::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<FaceOuterBound>(),
                    Box::new(entity),
                ))
            }
            "FACE_SURFACE" => {
                let entity = FaceSurface::form_parameters(typed_parameter.parameters);
                Some((entity.type_id(), std::any::type_name::<FaceSurface>(), Box::new(entity)))
            }
            "FACETED_BREP" => {
                let entity = FacetedBrep::form_parameters(typed_parameter.parameters);
                Some((entity.type_id(), std::any::type_name::<FacetedBrep>(), Box::new(entity)))
            }
            "FACETED_BREP_SHAPE_REPRESENTATION" => {
                let entity = FacetedBrepShapeRepresentation::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<FacetedBrepShapeRepresentation>(),
                    Box::new(entity),
                ))
            }
            "FACT_TYPE" => {
                let entity = FactType::form_parameters(typed_parameter.parameters);
                Some((entity.type_id(), std::any::type_name::<FactType>(), Box::new(entity)))
            }
            "FILL_AREA_STYLE" => {
                let entity = FillAreaStyle::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<FillAreaStyle>(),
                    Box::new(entity),
                ))
            }
            "FILL_AREA_STYLE_COLOUR" => {
                let entity = FillAreaStyleColour::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<FillAreaStyleColour>(),
                    Box::new(entity),
                ))
            }
            "FILL_AREA_STYLE_HATCHING" => {
                let entity = FillAreaStyleHatching::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<FillAreaStyleHatching>(),
                    Box::new(entity),
                ))
            }
            "FILL_AREA_STYLE_TILE_COLOURED_REGION" => {
                let entity = FillAreaStyleTileColouredRegion::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<FillAreaStyleTileColouredRegion>(),
                    Box::new(entity),
                ))
            }
            "FILL_AREA_STYLE_TILE_CURVE_WITH_STYLE" => {
                let entity = FillAreaStyleTileCurveWithStyle::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<FillAreaStyleTileCurveWithStyle>(),
                    Box::new(entity),
                ))
            }
            "FILL_AREA_STYLE_TILE_SYMBOL_WITH_STYLE" => {
                let entity = FillAreaStyleTileSymbolWithStyle::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<FillAreaStyleTileSymbolWithStyle>(),
                    Box::new(entity),
                ))
            }
            "FILL_AREA_STYLE_TILES" => {
                let entity = FillAreaStyleTiles::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<FillAreaStyleTiles>(),
                    Box::new(entity),
                ))
            }
            "FLAT_PATTERN_PLY_REPRESENTATION_RELATIONSHIP" => {
                let entity = FlatPatternPlyRepresentationRelationship::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<FlatPatternPlyRepresentationRelationship>(),
                    Box::new(entity),
                ))
            }
            "FLATNESS_TOLERANCE" => {
                let entity = FlatnessTolerance::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<FlatnessTolerance>(),
                    Box::new(entity),
                ))
            }
            "FORCE_MEASURE_WITH_UNIT" => {
                let entity = ForceMeasureWithUnit::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<ForceMeasureWithUnit>(),
                    Box::new(entity),
                ))
            }
            "FORCE_UNIT" => {
                let entity = ForceUnit::form_parameters(typed_parameter.parameters);
                Some((entity.type_id(), std::any::type_name::<ForceUnit>(), Box::new(entity)))
            }
            "FORWARD_CHAINING_RULE" => {
                let entity = ForwardChainingRule::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<ForwardChainingRule>(),
                    Box::new(entity),
                ))
            }
            "FORWARD_CHAINING_RULE_PREMISE" => {
                let entity = ForwardChainingRulePremise::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<ForwardChainingRulePremise>(),
                    Box::new(entity),
                ))
            }
            "FOUNDED_ITEM" => {
                let entity = FoundedItem::form_parameters(typed_parameter.parameters);
                Some((entity.type_id(), std::any::type_name::<FoundedItem>(), Box::new(entity)))
            }
            "FREQUENCY_MEASURE_WITH_UNIT" => {
                let entity = FrequencyMeasureWithUnit::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<FrequencyMeasureWithUnit>(),
                    Box::new(entity),
                ))
            }
            "FREQUENCY_UNIT" => {
                let entity = FrequencyUnit::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<FrequencyUnit>(),
                    Box::new(entity),
                ))
            }
            "FUNC" => {
                let entity = Func::form_parameters(typed_parameter.parameters);
                Some((entity.type_id(), std::any::type_name::<Func>(), Box::new(entity)))
            }
            "FUNCTIONAL_BREAKDOWN_CONTEXT" => {
                let entity = FunctionalBreakdownContext::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<FunctionalBreakdownContext>(),
                    Box::new(entity),
                ))
            }
            "FUNCTIONAL_ELEMENT_USAGE" => {
                let entity = FunctionalElementUsage::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<FunctionalElementUsage>(),
                    Box::new(entity),
                ))
            }
            "FUNCTIONALLY_DEFINED_TRANSFORMATION" => {
                let entity = FunctionallyDefinedTransformation::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<FunctionallyDefinedTransformation>(),
                    Box::new(entity),
                ))
            }
            "GENERAL_MATERIAL_PROPERTY" => {
                let entity = GeneralMaterialProperty::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<GeneralMaterialProperty>(),
                    Box::new(entity),
                ))
            }
            "GENERAL_PROPERTY" => {
                let entity = GeneralProperty::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<GeneralProperty>(),
                    Box::new(entity),
                ))
            }
            "GENERAL_PROPERTY_ASSOCIATION" => {
                let entity = GeneralPropertyAssociation::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<GeneralPropertyAssociation>(),
                    Box::new(entity),
                ))
            }
            "GENERAL_PROPERTY_RELATIONSHIP" => {
                let entity = GeneralPropertyRelationship::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<GeneralPropertyRelationship>(),
                    Box::new(entity),
                ))
            }
            "GEOMETRIC_ALIGNMENT" => {
                let entity = GeometricAlignment::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<GeometricAlignment>(),
                    Box::new(entity),
                ))
            }
            "GEOMETRIC_CURVE_SET" => {
                let entity = GeometricCurveSet::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<GeometricCurveSet>(),
                    Box::new(entity),
                ))
            }
            "GEOMETRIC_INTERSECTION" => {
                let entity = GeometricIntersection::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<GeometricIntersection>(),
                    Box::new(entity),
                ))
            }
            "GEOMETRIC_ITEM_SPECIFIC_USAGE" => {
                let entity = GeometricItemSpecificUsage::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<GeometricItemSpecificUsage>(),
                    Box::new(entity),
                ))
            }
            "GEOMETRIC_MODEL_ELEMENT_RELATIONSHIP" => {
                let entity = GeometricModelElementRelationship::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<GeometricModelElementRelationship>(),
                    Box::new(entity),
                ))
            }
            "GEOMETRIC_REPRESENTATION_CONTEXT" => {
                let entity = GeometricRepresentationContext::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<GeometricRepresentationContext>(),
                    Box::new(entity),
                ))
            }
            "GEOMETRIC_REPRESENTATION_ITEM" => {
                let entity = GeometricRepresentationItem::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<GeometricRepresentationItem>(),
                    Box::new(entity),
                ))
            }
            "GEOMETRIC_SET" => {
                let entity = GeometricSet::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<GeometricSet>(),
                    Box::new(entity),
                ))
            }
            "GEOMETRIC_TOLERANCE" => {
                let entity = GeometricTolerance::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<GeometricTolerance>(),
                    Box::new(entity),
                ))
            }
            "GEOMETRIC_TOLERANCE_RELATIONSHIP" => {
                let entity = GeometricToleranceRelationship::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<GeometricToleranceRelationship>(),
                    Box::new(entity),
                ))
            }
            "GEOMETRIC_TOLERANCE_WITH_DATUM_REFERENCE" => {
                let entity = GeometricToleranceWithDatumReference::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<GeometricToleranceWithDatumReference>(),
                    Box::new(entity),
                ))
            }
            "GEOMETRIC_TOLERANCE_WITH_DEFINED_UNIT" => {
                let entity = GeometricToleranceWithDefinedUnit::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<GeometricToleranceWithDefinedUnit>(),
                    Box::new(entity),
                ))
            }
            "GEOMETRICAL_TOLERANCE_CALLOUT" => {
                let entity = GeometricalToleranceCallout::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<GeometricalToleranceCallout>(),
                    Box::new(entity),
                ))
            }
            "GEOMETRICALLY_BOUNDED_2D_WIREFRAME_REPRESENTATION" => {
                let entity = GeometricallyBounded2dWireframeRepresentation::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<GeometricallyBounded2dWireframeRepresentation>(),
                    Box::new(entity),
                ))
            }
            "GEOMETRICALLY_BOUNDED_SURFACE_SHAPE_REPRESENTATION" => {
                let entity =
                    GeometricallyBoundedSurfaceShapeRepresentation::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<GeometricallyBoundedSurfaceShapeRepresentation>(),
                    Box::new(entity),
                ))
            }
            "GEOMETRICALLY_BOUNDED_WIREFRAME_SHAPE_REPRESENTATION" => {
                let entity =
                    GeometricallyBoundedWireframeShapeRepresentation::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<GeometricallyBoundedWireframeShapeRepresentation>(),
                    Box::new(entity),
                ))
            }
            "GLOBAL_ASSIGNMENT" => {
                let entity = GlobalAssignment::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<GlobalAssignment>(),
                    Box::new(entity),
                ))
            }
            "GLOBAL_UNCERTAINTY_ASSIGNED_CONTEXT" => {
                let entity = GlobalUncertaintyAssignedContext::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<GlobalUncertaintyAssignedContext>(),
                    Box::new(entity),
                ))
            }
            "GLOBAL_UNIT_ASSIGNED_CONTEXT" => {
                let entity = GlobalUnitAssignedContext::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<GlobalUnitAssignedContext>(),
                    Box::new(entity),
                ))
            }
            "GROUND_FACT" => {
                let entity = GroundFact::form_parameters(typed_parameter.parameters);
                Some((entity.type_id(), std::any::type_name::<GroundFact>(), Box::new(entity)))
            }
            "GROUP" => {
                let entity = Group::form_parameters(typed_parameter.parameters);
                Some((entity.type_id(), std::any::type_name::<Group>(), Box::new(entity)))
            }
            "GROUP_RELATIONSHIP" => {
                let entity = GroupRelationship::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<GroupRelationship>(),
                    Box::new(entity),
                ))
            }
            "HALF_SPACE_SOLID" => {
                let entity = HalfSpaceSolid::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<HalfSpaceSolid>(),
                    Box::new(entity),
                ))
            }
            "HARDNESS_REPRESENTATION" => {
                let entity = HardnessRepresentation::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<HardnessRepresentation>(),
                    Box::new(entity),
                ))
            }
            "HIDDEN_ELEMENT_OVER_RIDING_STYLED_ITEM" => {
                let entity = HiddenElementOverRidingStyledItem::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<HiddenElementOverRidingStyledItem>(),
                    Box::new(entity),
                ))
            }
            "HYPERBOLA" => {
                let entity = Hyperbola::form_parameters(typed_parameter.parameters);
                Some((entity.type_id(), std::any::type_name::<Hyperbola>(), Box::new(entity)))
            }
            "ID_ATTRIBUTE" => {
                let entity = IdAttribute::form_parameters(typed_parameter.parameters);
                Some((entity.type_id(), std::any::type_name::<IdAttribute>(), Box::new(entity)))
            }
            "IDENTIFICATION_ROLE" => {
                let entity = IdentificationRole::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<IdentificationRole>(),
                    Box::new(entity),
                ))
            }
            "ILLUMINANCE_MEASURE_WITH_UNIT" => {
                let entity = IlluminanceMeasureWithUnit::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<IlluminanceMeasureWithUnit>(),
                    Box::new(entity),
                ))
            }
            "ILLUMINANCE_UNIT" => {
                let entity = IlluminanceUnit::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<IlluminanceUnit>(),
                    Box::new(entity),
                ))
            }
            "INCLUDED_TEXT_BLOCK" => {
                let entity = IncludedTextBlock::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<IncludedTextBlock>(),
                    Box::new(entity),
                ))
            }
            "INCLUSION_PRODUCT_CONCEPT_FEATURE" => {
                let entity = InclusionProductConceptFeature::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<InclusionProductConceptFeature>(),
                    Box::new(entity),
                ))
            }
            "INDIRECTLY_SELECTED_ELEMENTS" => {
                let entity = IndirectlySelectedElements::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<IndirectlySelectedElements>(),
                    Box::new(entity),
                ))
            }
            "INDIRECTLY_SELECTED_SHAPE_ELEMENTS" => {
                let entity = IndirectlySelectedShapeElements::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<IndirectlySelectedShapeElements>(),
                    Box::new(entity),
                ))
            }
            "INDUCTANCE_MEASURE_WITH_UNIT" => {
                let entity = InductanceMeasureWithUnit::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<InductanceMeasureWithUnit>(),
                    Box::new(entity),
                ))
            }
            "INDUCTANCE_UNIT" => {
                let entity = InductanceUnit::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<InductanceUnit>(),
                    Box::new(entity),
                ))
            }
            "INFORMATION_RIGHT" => {
                let entity = InformationRight::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<InformationRight>(),
                    Box::new(entity),
                ))
            }
            "INFORMATION_USAGE_RIGHT" => {
                let entity = InformationUsageRight::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<InformationUsageRight>(),
                    Box::new(entity),
                ))
            }
            "INSTANCE_USAGE_CONTEXT_ASSIGNMENT" => {
                let entity = InstanceUsageContextAssignment::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<InstanceUsageContextAssignment>(),
                    Box::new(entity),
                ))
            }
            "INSTANCED_FEATURE" => {
                let entity = InstancedFeature::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<InstancedFeature>(),
                    Box::new(entity),
                ))
            }
            "INT_LITERAL" => {
                let entity = IntLiteral::form_parameters(typed_parameter.parameters);
                Some((entity.type_id(), std::any::type_name::<IntLiteral>(), Box::new(entity)))
            }
            "INTEGER_REPRESENTATION_ITEM" => {
                let entity = IntegerRepresentationItem::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<IntegerRepresentationItem>(),
                    Box::new(entity),
                ))
            }
            "INTERSECTION_CURVE" => {
                let entity = IntersectionCurve::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<IntersectionCurve>(),
                    Box::new(entity),
                ))
            }
            "INTERVAL_EXPRESSION" => {
                let entity = IntervalExpression::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<IntervalExpression>(),
                    Box::new(entity),
                ))
            }
            "INVISIBILITY" => {
                let entity = Invisibility::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<Invisibility>(),
                    Box::new(entity),
                ))
            }
            "ISO4217_CURRENCY" => {
                let entity = Iso4217Currency::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<Iso4217Currency>(),
                    Box::new(entity),
                ))
            }
            "ITEM_DEFINED_TRANSFORMATION" => {
                let entity = ItemDefinedTransformation::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<ItemDefinedTransformation>(),
                    Box::new(entity),
                ))
            }
            "ITEM_IDENTIFIED_REPRESENTATION_USAGE" => {
                let entity = ItemIdentifiedRepresentationUsage::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<ItemIdentifiedRepresentationUsage>(),
                    Box::new(entity),
                ))
            }
            "KNOWN_SOURCE" => {
                let entity = KnownSource::form_parameters(typed_parameter.parameters);
                Some((entity.type_id(), std::any::type_name::<KnownSource>(), Box::new(entity)))
            }
            "LAID_DEFINED_TRANSFORMATION" => {
                let entity = LaidDefinedTransformation::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<LaidDefinedTransformation>(),
                    Box::new(entity),
                ))
            }
            "LAMINATE_TABLE" => {
                let entity = LaminateTable::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<LaminateTable>(),
                    Box::new(entity),
                ))
            }
            "LANGUAGE" => {
                let entity = Language::form_parameters(typed_parameter.parameters);
                Some((entity.type_id(), std::any::type_name::<Language>(), Box::new(entity)))
            }
            "LEADER_CURVE" => {
                let entity = LeaderCurve::form_parameters(typed_parameter.parameters);
                Some((entity.type_id(), std::any::type_name::<LeaderCurve>(), Box::new(entity)))
            }
            "LEADER_DIRECTED_CALLOUT" => {
                let entity = LeaderDirectedCallout::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<LeaderDirectedCallout>(),
                    Box::new(entity),
                ))
            }
            "LEADER_DIRECTED_DIMENSION" => {
                let entity = LeaderDirectedDimension::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<LeaderDirectedDimension>(),
                    Box::new(entity),
                ))
            }
            "LEADER_TERMINATOR" => {
                let entity = LeaderTerminator::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<LeaderTerminator>(),
                    Box::new(entity),
                ))
            }
            "LENGTH_MEASURE_WITH_UNIT" => {
                let entity = LengthMeasureWithUnit::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<LengthMeasureWithUnit>(),
                    Box::new(entity),
                ))
            }
            "LENGTH_UNIT" => {
                let entity = LengthUnit::form_parameters(typed_parameter.parameters);
                Some((entity.type_id(), std::any::type_name::<LengthUnit>(), Box::new(entity)))
            }
            "LIGHT_SOURCE" => {
                let entity = LightSource::form_parameters(typed_parameter.parameters);
                Some((entity.type_id(), std::any::type_name::<LightSource>(), Box::new(entity)))
            }
            "LIGHT_SOURCE_AMBIENT" => {
                let entity = LightSourceAmbient::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<LightSourceAmbient>(),
                    Box::new(entity),
                ))
            }
            "LIGHT_SOURCE_DIRECTIONAL" => {
                let entity = LightSourceDirectional::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<LightSourceDirectional>(),
                    Box::new(entity),
                ))
            }
            "LIGHT_SOURCE_POSITIONAL" => {
                let entity = LightSourcePositional::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<LightSourcePositional>(),
                    Box::new(entity),
                ))
            }
            "LIGHT_SOURCE_SPOT" => {
                let entity = LightSourceSpot::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<LightSourceSpot>(),
                    Box::new(entity),
                ))
            }
            "LIMITS_AND_FITS" => {
                let entity = LimitsAndFits::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<LimitsAndFits>(),
                    Box::new(entity),
                ))
            }
            "LINE" => {
                let entity = Line::form_parameters(typed_parameter.parameters);
                Some((entity.type_id(), std::any::type_name::<Line>(), Box::new(entity)))
            }
            "LINE_PROFILE_TOLERANCE" => {
                let entity = LineProfileTolerance::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<LineProfileTolerance>(),
                    Box::new(entity),
                ))
            }
            "LINEAR_DIMENSION" => {
                let entity = LinearDimension::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<LinearDimension>(),
                    Box::new(entity),
                ))
            }
            "LITERAL_CONJUNCTION" => {
                let entity = LiteralConjunction::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<LiteralConjunction>(),
                    Box::new(entity),
                ))
            }
            "LITERAL_DISJUNCTION" => {
                let entity = LiteralDisjunction::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<LiteralDisjunction>(),
                    Box::new(entity),
                ))
            }
            "LOCAL_TIME" => {
                let entity = LocalTime::form_parameters(typed_parameter.parameters);
                Some((entity.type_id(), std::any::type_name::<LocalTime>(), Box::new(entity)))
            }
            "LOGICAL_LITERAL" => {
                let entity = LogicalLiteral::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<LogicalLiteral>(),
                    Box::new(entity),
                ))
            }
            "LOGICAL_REPRESENTATION_ITEM" => {
                let entity = LogicalRepresentationItem::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<LogicalRepresentationItem>(),
                    Box::new(entity),
                ))
            }
            "LOOP" => {
                let entity = Loop::form_parameters(typed_parameter.parameters);
                Some((entity.type_id(), std::any::type_name::<Loop>(), Box::new(entity)))
            }
            "LOSS_TANGENT_MEASURE_WITH_UNIT" => {
                let entity = LossTangentMeasureWithUnit::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<LossTangentMeasureWithUnit>(),
                    Box::new(entity),
                ))
            }
            "LOT_EFFECTIVITY" => {
                let entity = LotEffectivity::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<LotEffectivity>(),
                    Box::new(entity),
                ))
            }
            "LUMINOUS_FLUX_MEASURE_WITH_UNIT" => {
                let entity = LuminousFluxMeasureWithUnit::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<LuminousFluxMeasureWithUnit>(),
                    Box::new(entity),
                ))
            }
            "LUMINOUS_FLUX_UNIT" => {
                let entity = LuminousFluxUnit::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<LuminousFluxUnit>(),
                    Box::new(entity),
                ))
            }
            "LUMINOUS_INTENSITY_MEASURE_WITH_UNIT" => {
                let entity = LuminousIntensityMeasureWithUnit::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<LuminousIntensityMeasureWithUnit>(),
                    Box::new(entity),
                ))
            }
            "LUMINOUS_INTENSITY_UNIT" => {
                let entity = LuminousIntensityUnit::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<LuminousIntensityUnit>(),
                    Box::new(entity),
                ))
            }
            "MAGNETIC_FLUX_DENSITY_MEASURE_WITH_UNIT" => {
                let entity = MagneticFluxDensityMeasureWithUnit::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<MagneticFluxDensityMeasureWithUnit>(),
                    Box::new(entity),
                ))
            }
            "MAGNETIC_FLUX_DENSITY_UNIT" => {
                let entity = MagneticFluxDensityUnit::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<MagneticFluxDensityUnit>(),
                    Box::new(entity),
                ))
            }
            "MAGNETIC_FLUX_MEASURE_WITH_UNIT" => {
                let entity = MagneticFluxMeasureWithUnit::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<MagneticFluxMeasureWithUnit>(),
                    Box::new(entity),
                ))
            }
            "MAGNETIC_FLUX_UNIT" => {
                let entity = MagneticFluxUnit::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<MagneticFluxUnit>(),
                    Box::new(entity),
                ))
            }
            "MAKE_FROM_USAGE_OPTION" => {
                let entity = MakeFromUsageOption::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<MakeFromUsageOption>(),
                    Box::new(entity),
                ))
            }
            "MANIFOLD_SOLID_BREP" => {
                let entity = ManifoldSolidBrep::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<ManifoldSolidBrep>(),
                    Box::new(entity),
                ))
            }
            "MANIFOLD_SUBSURFACE_SHAPE_REPRESENTATION" => {
                let entity = ManifoldSubsurfaceShapeRepresentation::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<ManifoldSubsurfaceShapeRepresentation>(),
                    Box::new(entity),
                ))
            }
            "MANIFOLD_SURFACE_SHAPE_REPRESENTATION" => {
                let entity = ManifoldSurfaceShapeRepresentation::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<ManifoldSurfaceShapeRepresentation>(),
                    Box::new(entity),
                ))
            }
            "MAPPED_ITEM" => {
                let entity = MappedItem::form_parameters(typed_parameter.parameters);
                Some((entity.type_id(), std::any::type_name::<MappedItem>(), Box::new(entity)))
            }
            "MASS_MEASURE_WITH_UNIT" => {
                let entity = MassMeasureWithUnit::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<MassMeasureWithUnit>(),
                    Box::new(entity),
                ))
            }
            "MASS_UNIT" => {
                let entity = MassUnit::form_parameters(typed_parameter.parameters);
                Some((entity.type_id(), std::any::type_name::<MassUnit>(), Box::new(entity)))
            }
            "MATERIAL_DESIGNATION" => {
                let entity = MaterialDesignation::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<MaterialDesignation>(),
                    Box::new(entity),
                ))
            }
            "MATERIAL_DESIGNATION_CHARACTERIZATION" => {
                let entity = MaterialDesignationCharacterization::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<MaterialDesignationCharacterization>(),
                    Box::new(entity),
                ))
            }
            "MATERIAL_PROPERTY" => {
                let entity = MaterialProperty::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<MaterialProperty>(),
                    Box::new(entity),
                ))
            }
            "MATERIAL_PROPERTY_REPRESENTATION" => {
                let entity = MaterialPropertyRepresentation::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<MaterialPropertyRepresentation>(),
                    Box::new(entity),
                ))
            }
            "MEASURE_QUALIFICATION" => {
                let entity = MeasureQualification::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<MeasureQualification>(),
                    Box::new(entity),
                ))
            }
            "MEASURE_REPRESENTATION_ITEM" => {
                let entity = MeasureRepresentationItem::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<MeasureRepresentationItem>(),
                    Box::new(entity),
                ))
            }
            "MEASURE_WITH_UNIT" => {
                let entity = MeasureWithUnit::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<MeasureWithUnit>(),
                    Box::new(entity),
                ))
            }
            "MECHANICAL_CONTEXT" => {
                let entity = MechanicalContext::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<MechanicalContext>(),
                    Box::new(entity),
                ))
            }
            "MECHANICAL_DESIGN_AND_DRAUGHTING_RELATIONSHIP" => {
                let entity = MechanicalDesignAndDraughtingRelationship::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<MechanicalDesignAndDraughtingRelationship>(),
                    Box::new(entity),
                ))
            }
            "MECHANICAL_DESIGN_GEOMETRIC_PRESENTATION_AREA" => {
                let entity = MechanicalDesignGeometricPresentationArea::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<MechanicalDesignGeometricPresentationArea>(),
                    Box::new(entity),
                ))
            }
            "MECHANICAL_DESIGN_GEOMETRIC_PRESENTATION_REPRESENTATION" => {
                let entity =
                    MechanicalDesignGeometricPresentationRepresentation::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<MechanicalDesignGeometricPresentationRepresentation>(),
                    Box::new(entity),
                ))
            }
            "MECHANICAL_DESIGN_PRESENTATION_REPRESENTATION_WITH_DRAUGHTING" => {
                let entity = MechanicalDesignPresentationRepresentationWithDraughting::form_parameters(
                    typed_parameter.parameters,
                );
                Some((
                    entity.type_id(),
                    std::any::type_name::<MechanicalDesignPresentationRepresentationWithDraughting>(),
                    Box::new(entity),
                ))
            }
            "MECHANICAL_DESIGN_SHADED_PRESENTATION_AREA" => {
                let entity = MechanicalDesignShadedPresentationArea::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<MechanicalDesignShadedPresentationArea>(),
                    Box::new(entity),
                ))
            }
            "MECHANICAL_DESIGN_SHADED_PRESENTATION_REPRESENTATION" => {
                let entity =
                    MechanicalDesignShadedPresentationRepresentation::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<MechanicalDesignShadedPresentationRepresentation>(),
                    Box::new(entity),
                ))
            }
            "MIN_AND_MAJOR_PLY_ORIENTATION_BASIS" => {
                let entity = MinAndMajorPlyOrientationBasis::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<MinAndMajorPlyOrientationBasis>(),
                    Box::new(entity),
                ))
            }
            "MODIFIED_GEOMETRIC_TOLERANCE" => {
                let entity = ModifiedGeometricTolerance::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<ModifiedGeometricTolerance>(),
                    Box::new(entity),
                ))
            }
            "MOMENTS_OF_INERTIA_REPRESENTATION" => {
                let entity = MomentsOfInertiaRepresentation::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<MomentsOfInertiaRepresentation>(),
                    Box::new(entity),
                ))
            }
            "MULTI_LANGUAGE_ATTRIBUTE_ASSIGNMENT" => {
                let entity = MultiLanguageAttributeAssignment::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<MultiLanguageAttributeAssignment>(),
                    Box::new(entity),
                ))
            }
            "NAME_ATTRIBUTE" => {
                let entity = NameAttribute::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<NameAttribute>(),
                    Box::new(entity),
                ))
            }
            "NAMED_UNIT" => {
                let entity = NamedUnit::form_parameters(typed_parameter.parameters);
                Some((entity.type_id(), std::any::type_name::<NamedUnit>(), Box::new(entity)))
            }
            "NEXT_ASSEMBLY_USAGE_OCCURRENCE" => {
                let entity = NextAssemblyUsageOccurrence::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<NextAssemblyUsageOccurrence>(),
                    Box::new(entity),
                ))
            }
            "NON_MANIFOLD_SURFACE_SHAPE_REPRESENTATION" => {
                let entity = NonManifoldSurfaceShapeRepresentation::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<NonManifoldSurfaceShapeRepresentation>(),
                    Box::new(entity),
                ))
            }
            "NULL_REPRESENTATION_ITEM" => {
                let entity = NullRepresentationItem::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<NullRepresentationItem>(),
                    Box::new(entity),
                ))
            }
            "OBJECT_ROLE" => {
                let entity = ObjectRole::form_parameters(typed_parameter.parameters);
                Some((entity.type_id(), std::any::type_name::<ObjectRole>(), Box::new(entity)))
            }
            "OFFSET_CURVE_2D" => {
                let entity = OffsetCurve2d::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<OffsetCurve2d>(),
                    Box::new(entity),
                ))
            }
            "OFFSET_CURVE_3D" => {
                let entity = OffsetCurve3d::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<OffsetCurve3d>(),
                    Box::new(entity),
                ))
            }
            "OFFSET_SURFACE" => {
                let entity = OffsetSurface::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<OffsetSurface>(),
                    Box::new(entity),
                ))
            }
            "ONE_DIRECTION_REPEAT_FACTOR" => {
                let entity = OneDirectionRepeatFactor::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<OneDirectionRepeatFactor>(),
                    Box::new(entity),
                ))
            }
            "OPEN_SHELL" => {
                let entity = OpenShell::form_parameters(typed_parameter.parameters);
                Some((entity.type_id(), std::any::type_name::<OpenShell>(), Box::new(entity)))
            }
            "ORDINAL_DATE" => {
                let entity = OrdinalDate::form_parameters(typed_parameter.parameters);
                Some((entity.type_id(), std::any::type_name::<OrdinalDate>(), Box::new(entity)))
            }
            "ORDINATE_DIMENSION" => {
                let entity = OrdinateDimension::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<OrdinateDimension>(),
                    Box::new(entity),
                ))
            }
            "ORGANIZATION" => {
                let entity = Organization::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<Organization>(),
                    Box::new(entity),
                ))
            }
            "ORGANIZATION_RELATIONSHIP" => {
                let entity = OrganizationRelationship::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<OrganizationRelationship>(),
                    Box::new(entity),
                ))
            }
            "ORGANIZATION_ROLE" => {
                let entity = OrganizationRole::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<OrganizationRole>(),
                    Box::new(entity),
                ))
            }
            "ORGANIZATIONAL_ADDRESS" => {
                let entity = OrganizationalAddress::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<OrganizationalAddress>(),
                    Box::new(entity),
                ))
            }
            "ORGANIZATIONAL_PROJECT" => {
                let entity = OrganizationalProject::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<OrganizationalProject>(),
                    Box::new(entity),
                ))
            }
            "ORGANIZATIONAL_PROJECT_RELATIONSHIP" => {
                let entity = OrganizationalProjectRelationship::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<OrganizationalProjectRelationship>(),
                    Box::new(entity),
                ))
            }
            "ORGANIZATIONAL_PROJECT_ROLE" => {
                let entity = OrganizationalProjectRole::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<OrganizationalProjectRole>(),
                    Box::new(entity),
                ))
            }
            "ORIENTED_CLOSED_SHELL" => {
                let entity = OrientedClosedShell::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<OrientedClosedShell>(),
                    Box::new(entity),
                ))
            }
            "ORIENTED_EDGE" => {
                let entity = OrientedEdge::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<OrientedEdge>(),
                    Box::new(entity),
                ))
            }
            "ORIENTED_FACE" => {
                let entity = OrientedFace::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<OrientedFace>(),
                    Box::new(entity),
                ))
            }
            "ORIENTED_OPEN_SHELL" => {
                let entity = OrientedOpenShell::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<OrientedOpenShell>(),
                    Box::new(entity),
                ))
            }
            "ORIENTED_PATH" => {
                let entity = OrientedPath::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<OrientedPath>(),
                    Box::new(entity),
                ))
            }
            "ORIENTED_SURFACE" => {
                let entity = OrientedSurface::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<OrientedSurface>(),
                    Box::new(entity),
                ))
            }
            "OUTER_BOUNDARY_CURVE" => {
                let entity = OuterBoundaryCurve::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<OuterBoundaryCurve>(),
                    Box::new(entity),
                ))
            }
            "OVER_RIDING_STYLED_ITEM" => {
                let entity = OverRidingStyledItem::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<OverRidingStyledItem>(),
                    Box::new(entity),
                ))
            }
            "PACKAGE_PRODUCT_CONCEPT_FEATURE" => {
                let entity = PackageProductConceptFeature::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<PackageProductConceptFeature>(),
                    Box::new(entity),
                ))
            }
            "PARABOLA" => {
                let entity = Parabola::form_parameters(typed_parameter.parameters);
                Some((entity.type_id(), std::any::type_name::<Parabola>(), Box::new(entity)))
            }
            "PARALLEL_OFFSET" => {
                let entity = ParallelOffset::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<ParallelOffset>(),
                    Box::new(entity),
                ))
            }
            "PARALLELISM_TOLERANCE" => {
                let entity = ParallelismTolerance::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<ParallelismTolerance>(),
                    Box::new(entity),
                ))
            }
            "PARAMETRIC_REPRESENTATION_CONTEXT" => {
                let entity = ParametricRepresentationContext::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<ParametricRepresentationContext>(),
                    Box::new(entity),
                ))
            }
            "PART_LAMINATE_TABLE" => {
                let entity = PartLaminateTable::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<PartLaminateTable>(),
                    Box::new(entity),
                ))
            }
            "PARTIAL_DOCUMENT_WITH_STRUCTURED_TEXT_REPRESENTATION_ASSIGNMENT" => {
                let entity = PartialDocumentWithStructuredTextRepresentationAssignment::form_parameters(
                    typed_parameter.parameters,
                );
                Some((
                    entity.type_id(),
                    std::any::type_name::<PartialDocumentWithStructuredTextRepresentationAssignment>(),
                    Box::new(entity),
                ))
            }
            "PATH" => {
                let entity = Path::form_parameters(typed_parameter.parameters);
                Some((entity.type_id(), std::any::type_name::<Path>(), Box::new(entity)))
            }
            "PCURVE" => {
                let entity = Pcurve::form_parameters(typed_parameter.parameters);
                Some((entity.type_id(), std::any::type_name::<Pcurve>(), Box::new(entity)))
            }
            "PERCENTAGE_LAMINATE_DEFINITION" => {
                let entity = PercentageLaminateDefinition::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<PercentageLaminateDefinition>(),
                    Box::new(entity),
                ))
            }
            "PERCENTAGE_LAMINATE_TABLE" => {
                let entity = PercentageLaminateTable::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<PercentageLaminateTable>(),
                    Box::new(entity),
                ))
            }
            "PERCENTAGE_PLY_DEFINITION" => {
                let entity = PercentagePlyDefinition::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<PercentagePlyDefinition>(),
                    Box::new(entity),
                ))
            }
            "PERPENDICULAR_TO" => {
                let entity = PerpendicularTo::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<PerpendicularTo>(),
                    Box::new(entity),
                ))
            }
            "PERPENDICULARITY_TOLERANCE" => {
                let entity = PerpendicularityTolerance::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<PerpendicularityTolerance>(),
                    Box::new(entity),
                ))
            }
            "PERSON" => {
                let entity = Person::form_parameters(typed_parameter.parameters);
                Some((entity.type_id(), std::any::type_name::<Person>(), Box::new(entity)))
            }
            "PERSON_AND_ORGANIZATION" => {
                let entity = PersonAndOrganization::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<PersonAndOrganization>(),
                    Box::new(entity),
                ))
            }
            "PERSON_AND_ORGANIZATION_ADDRESS" => {
                let entity = PersonAndOrganizationAddress::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<PersonAndOrganizationAddress>(),
                    Box::new(entity),
                ))
            }
            "PERSON_AND_ORGANIZATION_ROLE" => {
                let entity = PersonAndOrganizationRole::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<PersonAndOrganizationRole>(),
                    Box::new(entity),
                ))
            }
            "PERSONAL_ADDRESS" => {
                let entity = PersonalAddress::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<PersonalAddress>(),
                    Box::new(entity),
                ))
            }
            "PHYSICAL_BREAKDOWN_CONTEXT" => {
                let entity = PhysicalBreakdownContext::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<PhysicalBreakdownContext>(),
                    Box::new(entity),
                ))
            }
            "PHYSICAL_ELEMENT_USAGE" => {
                let entity = PhysicalElementUsage::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<PhysicalElementUsage>(),
                    Box::new(entity),
                ))
            }
            "PICTURE_REPRESENTATION" => {
                let entity = PictureRepresentation::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<PictureRepresentation>(),
                    Box::new(entity),
                ))
            }
            "PLACED_DATUM_TARGET_FEATURE" => {
                let entity = PlacedDatumTargetFeature::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<PlacedDatumTargetFeature>(),
                    Box::new(entity),
                ))
            }
            "PLACED_FEATURE" => {
                let entity = PlacedFeature::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<PlacedFeature>(),
                    Box::new(entity),
                ))
            }
            "PLACEMENT" => {
                let entity = Placement::form_parameters(typed_parameter.parameters);
                Some((entity.type_id(), std::any::type_name::<Placement>(), Box::new(entity)))
            }
            "PLANAR_BOX" => {
                let entity = PlanarBox::form_parameters(typed_parameter.parameters);
                Some((entity.type_id(), std::any::type_name::<PlanarBox>(), Box::new(entity)))
            }
            "PLANAR_EXTENT" => {
                let entity = PlanarExtent::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<PlanarExtent>(),
                    Box::new(entity),
                ))
            }
            "PLANE" => {
                let entity = Plane::form_parameters(typed_parameter.parameters);
                Some((entity.type_id(), std::any::type_name::<Plane>(), Box::new(entity)))
            }
            "PLANE_ANGLE_MEASURE_WITH_UNIT" => {
                let entity = PlaneAngleMeasureWithUnit::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<PlaneAngleMeasureWithUnit>(),
                    Box::new(entity),
                ))
            }
            "PLANE_ANGLE_UNIT" => {
                let entity = PlaneAngleUnit::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<PlaneAngleUnit>(),
                    Box::new(entity),
                ))
            }
            "PLUS_MINUS_TOLERANCE" => {
                let entity = PlusMinusTolerance::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<PlusMinusTolerance>(),
                    Box::new(entity),
                ))
            }
            "PLY_LAMINATE_DEFINITION" => {
                let entity = PlyLaminateDefinition::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<PlyLaminateDefinition>(),
                    Box::new(entity),
                ))
            }
            "PLY_LAMINATE_SEQUENCE_DEFINITION" => {
                let entity = PlyLaminateSequenceDefinition::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<PlyLaminateSequenceDefinition>(),
                    Box::new(entity),
                ))
            }
            "PLY_LAMINATE_TABLE" => {
                let entity = PlyLaminateTable::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<PlyLaminateTable>(),
                    Box::new(entity),
                ))
            }
            "POINT" => {
                let entity = Point::form_parameters(typed_parameter.parameters);
                Some((entity.type_id(), std::any::type_name::<Point>(), Box::new(entity)))
            }
            "POINT_AND_VECTOR" => {
                let entity = PointAndVector::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<PointAndVector>(),
                    Box::new(entity),
                ))
            }
            "POINT_ON_CURVE" => {
                let entity = PointOnCurve::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<PointOnCurve>(),
                    Box::new(entity),
                ))
            }
            "POINT_ON_SURFACE" => {
                let entity = PointOnSurface::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<PointOnSurface>(),
                    Box::new(entity),
                ))
            }
            "POINT_PATH" => {
                let entity = PointPath::form_parameters(typed_parameter.parameters);
                Some((entity.type_id(), std::any::type_name::<PointPath>(), Box::new(entity)))
            }
            "POINT_REPLICA" => {
                let entity = PointReplica::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<PointReplica>(),
                    Box::new(entity),
                ))
            }
            "POINT_STYLE" => {
                let entity = PointStyle::form_parameters(typed_parameter.parameters);
                Some((entity.type_id(), std::any::type_name::<PointStyle>(), Box::new(entity)))
            }
            "POLAR_COMPLEX_NUMBER_LITERAL" => {
                let entity = PolarComplexNumberLiteral::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<PolarComplexNumberLiteral>(),
                    Box::new(entity),
                ))
            }
            "POLY_LOOP" => {
                let entity = PolyLoop::form_parameters(typed_parameter.parameters);
                Some((entity.type_id(), std::any::type_name::<PolyLoop>(), Box::new(entity)))
            }
            "POLYLINE" => {
                let entity = Polyline::form_parameters(typed_parameter.parameters);
                Some((entity.type_id(), std::any::type_name::<Polyline>(), Box::new(entity)))
            }
            "POSITION_TOLERANCE" => {
                let entity = PositionTolerance::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<PositionTolerance>(),
                    Box::new(entity),
                ))
            }
            "POSITIONED_SKETCH" => {
                let entity = PositionedSketch::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<PositionedSketch>(),
                    Box::new(entity),
                ))
            }
            "POWER_MEASURE_WITH_UNIT" => {
                let entity = PowerMeasureWithUnit::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<PowerMeasureWithUnit>(),
                    Box::new(entity),
                ))
            }
            "POWER_UNIT" => {
                let entity = PowerUnit::form_parameters(typed_parameter.parameters);
                Some((entity.type_id(), std::any::type_name::<PowerUnit>(), Box::new(entity)))
            }
            "PRE_DEFINED_COLOUR" => {
                let entity = PreDefinedColour::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<PreDefinedColour>(),
                    Box::new(entity),
                ))
            }
            "PRE_DEFINED_CURVE_FONT" => {
                let entity = PreDefinedCurveFont::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<PreDefinedCurveFont>(),
                    Box::new(entity),
                ))
            }
            "PRE_DEFINED_DIMENSION_SYMBOL" => {
                let entity = PreDefinedDimensionSymbol::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<PreDefinedDimensionSymbol>(),
                    Box::new(entity),
                ))
            }
            "PRE_DEFINED_GEOMETRICAL_TOLERANCE_SYMBOL" => {
                let entity = PreDefinedGeometricalToleranceSymbol::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<PreDefinedGeometricalToleranceSymbol>(),
                    Box::new(entity),
                ))
            }
            "PRE_DEFINED_ITEM" => {
                let entity = PreDefinedItem::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<PreDefinedItem>(),
                    Box::new(entity),
                ))
            }
            "PRE_DEFINED_MARKER" => {
                let entity = PreDefinedMarker::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<PreDefinedMarker>(),
                    Box::new(entity),
                ))
            }
            "PRE_DEFINED_POINT_MARKER_SYMBOL" => {
                let entity = PreDefinedPointMarkerSymbol::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<PreDefinedPointMarkerSymbol>(),
                    Box::new(entity),
                ))
            }
            "PRE_DEFINED_SURFACE_CONDITION_SYMBOL" => {
                let entity = PreDefinedSurfaceConditionSymbol::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<PreDefinedSurfaceConditionSymbol>(),
                    Box::new(entity),
                ))
            }
            "PRE_DEFINED_SURFACE_SIDE_STYLE" => {
                let entity = PreDefinedSurfaceSideStyle::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<PreDefinedSurfaceSideStyle>(),
                    Box::new(entity),
                ))
            }
            "PRE_DEFINED_SYMBOL" => {
                let entity = PreDefinedSymbol::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<PreDefinedSymbol>(),
                    Box::new(entity),
                ))
            }
            "PRE_DEFINED_TERMINATOR_SYMBOL" => {
                let entity = PreDefinedTerminatorSymbol::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<PreDefinedTerminatorSymbol>(),
                    Box::new(entity),
                ))
            }
            "PRE_DEFINED_TEXT_FONT" => {
                let entity = PreDefinedTextFont::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<PreDefinedTextFont>(),
                    Box::new(entity),
                ))
            }
            "PRE_DEFINED_TILE" => {
                let entity = PreDefinedTile::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<PreDefinedTile>(),
                    Box::new(entity),
                ))
            }
            "PRECISION_QUALIFIER" => {
                let entity = PrecisionQualifier::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<PrecisionQualifier>(),
                    Box::new(entity),
                ))
            }
            "PREDEFINED_PICTURE_REPRESENTATION_ITEM" => {
                let entity = PredefinedPictureRepresentationItem::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<PredefinedPictureRepresentationItem>(),
                    Box::new(entity),
                ))
            }
            "PRESENTATION_AREA" => {
                let entity = PresentationArea::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<PresentationArea>(),
                    Box::new(entity),
                ))
            }
            "PRESENTATION_LAYER_ASSIGNMENT" => {
                let entity = PresentationLayerAssignment::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<PresentationLayerAssignment>(),
                    Box::new(entity),
                ))
            }
            "PRESENTATION_REPRESENTATION" => {
                let entity = PresentationRepresentation::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<PresentationRepresentation>(),
                    Box::new(entity),
                ))
            }
            "PRESENTATION_SET" => {
                let entity = PresentationSet::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<PresentationSet>(),
                    Box::new(entity),
                ))
            }
            "PRESENTATION_SIZE" => {
                let entity = PresentationSize::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<PresentationSize>(),
                    Box::new(entity),
                ))
            }
            "PRESENTATION_STYLE_ASSIGNMENT" => {
                let entity = PresentationStyleAssignment::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<PresentationStyleAssignment>(),
                    Box::new(entity),
                ))
            }
            "PRESENTATION_STYLE_BY_CONTEXT" => {
                let entity = PresentationStyleByContext::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<PresentationStyleByContext>(),
                    Box::new(entity),
                ))
            }
            "PRESENTATION_VIEW" => {
                let entity = PresentationView::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<PresentationView>(),
                    Box::new(entity),
                ))
            }
            "PRESENTED_ITEM_REPRESENTATION" => {
                let entity = PresentedItemRepresentation::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<PresentedItemRepresentation>(),
                    Box::new(entity),
                ))
            }
            "PRESSURE_MEASURE_WITH_UNIT" => {
                let entity = PressureMeasureWithUnit::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<PressureMeasureWithUnit>(),
                    Box::new(entity),
                ))
            }
            "PRESSURE_UNIT" => {
                let entity = PressureUnit::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<PressureUnit>(),
                    Box::new(entity),
                ))
            }
            "PROCEDURAL_REPRESENTATION" => {
                let entity = ProceduralRepresentation::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<ProceduralRepresentation>(),
                    Box::new(entity),
                ))
            }
            "PROCEDURAL_REPRESENTATION_SEQUENCE" => {
                let entity = ProceduralRepresentationSequence::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<ProceduralRepresentationSequence>(),
                    Box::new(entity),
                ))
            }
            "PROCEDURAL_SHAPE_REPRESENTATION" => {
                let entity = ProceduralShapeRepresentation::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<ProceduralShapeRepresentation>(),
                    Box::new(entity),
                ))
            }
            "PROCEDURAL_SHAPE_REPRESENTATION_SEQUENCE" => {
                let entity = ProceduralShapeRepresentationSequence::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<ProceduralShapeRepresentationSequence>(),
                    Box::new(entity),
                ))
            }
            "PRODUCT" => {
                let entity = Product::form_parameters(typed_parameter.parameters);
                Some((entity.type_id(), std::any::type_name::<Product>(), Box::new(entity)))
            }
            "PRODUCT_CATEGORY" => {
                let entity = ProductCategory::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<ProductCategory>(),
                    Box::new(entity),
                ))
            }
            "PRODUCT_CATEGORY_RELATIONSHIP" => {
                let entity = ProductCategoryRelationship::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<ProductCategoryRelationship>(),
                    Box::new(entity),
                ))
            }
            "PRODUCT_CLASS" => {
                let entity = ProductClass::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<ProductClass>(),
                    Box::new(entity),
                ))
            }
            "PRODUCT_CONCEPT" => {
                let entity = ProductConcept::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<ProductConcept>(),
                    Box::new(entity),
                ))
            }
            "PRODUCT_CONCEPT_CONTEXT" => {
                let entity = ProductConceptContext::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<ProductConceptContext>(),
                    Box::new(entity),
                ))
            }
            "PRODUCT_CONCEPT_FEATURE" => {
                let entity = ProductConceptFeature::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<ProductConceptFeature>(),
                    Box::new(entity),
                ))
            }
            "PRODUCT_CONCEPT_FEATURE_ASSOCIATION" => {
                let entity = ProductConceptFeatureAssociation::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<ProductConceptFeatureAssociation>(),
                    Box::new(entity),
                ))
            }
            "PRODUCT_CONCEPT_FEATURE_CATEGORY" => {
                let entity = ProductConceptFeatureCategory::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<ProductConceptFeatureCategory>(),
                    Box::new(entity),
                ))
            }
            "PRODUCT_CONCEPT_FEATURE_CATEGORY_USAGE" => {
                let entity = ProductConceptFeatureCategoryUsage::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<ProductConceptFeatureCategoryUsage>(),
                    Box::new(entity),
                ))
            }
            "PRODUCT_CONCEPT_RELATIONSHIP" => {
                let entity = ProductConceptRelationship::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<ProductConceptRelationship>(),
                    Box::new(entity),
                ))
            }
            "PRODUCT_CONTEXT" => {
                let entity = ProductContext::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<ProductContext>(),
                    Box::new(entity),
                ))
            }
            "PRODUCT_DEFINITION" => {
                let entity = ProductDefinition::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<ProductDefinition>(),
                    Box::new(entity),
                ))
            }
            "PRODUCT_DEFINITION_CONTEXT" => {
                let entity = ProductDefinitionContext::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<ProductDefinitionContext>(),
                    Box::new(entity),
                ))
            }
            "PRODUCT_DEFINITION_CONTEXT_ASSOCIATION" => {
                let entity = ProductDefinitionContextAssociation::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<ProductDefinitionContextAssociation>(),
                    Box::new(entity),
                ))
            }
            "PRODUCT_DEFINITION_CONTEXT_ROLE" => {
                let entity = ProductDefinitionContextRole::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<ProductDefinitionContextRole>(),
                    Box::new(entity),
                ))
            }
            "PRODUCT_DEFINITION_EFFECTIVITY" => {
                let entity = ProductDefinitionEffectivity::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<ProductDefinitionEffectivity>(),
                    Box::new(entity),
                ))
            }
            "PRODUCT_DEFINITION_ELEMENT_RELATIONSHIP" => {
                let entity = ProductDefinitionElementRelationship::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<ProductDefinitionElementRelationship>(),
                    Box::new(entity),
                ))
            }
            "PRODUCT_DEFINITION_FORMATION" => {
                let entity = ProductDefinitionFormation::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<ProductDefinitionFormation>(),
                    Box::new(entity),
                ))
            }
            "PRODUCT_DEFINITION_FORMATION_RELATIONSHIP" => {
                let entity = ProductDefinitionFormationRelationship::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<ProductDefinitionFormationRelationship>(),
                    Box::new(entity),
                ))
            }
            "PRODUCT_DEFINITION_FORMATION_WITH_SPECIFIED_SOURCE" => {
                let entity = ProductDefinitionFormationWithSpecifiedSource::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<ProductDefinitionFormationWithSpecifiedSource>(),
                    Box::new(entity),
                ))
            }
            "PRODUCT_DEFINITION_GROUP_ASSIGNMENT" => {
                let entity = ProductDefinitionGroupAssignment::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<ProductDefinitionGroupAssignment>(),
                    Box::new(entity),
                ))
            }
            "PRODUCT_DEFINITION_OCCURRENCE_RELATIONSHIP" => {
                let entity = ProductDefinitionOccurrenceRelationship::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<ProductDefinitionOccurrenceRelationship>(),
                    Box::new(entity),
                ))
            }
            "PRODUCT_DEFINITION_RELATIONSHIP" => {
                let entity = ProductDefinitionRelationship::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<ProductDefinitionRelationship>(),
                    Box::new(entity),
                ))
            }
            "PRODUCT_DEFINITION_SHAPE" => {
                let entity = ProductDefinitionShape::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<ProductDefinitionShape>(),
                    Box::new(entity),
                ))
            }
            "PRODUCT_DEFINITION_SUBSTITUTE" => {
                let entity = ProductDefinitionSubstitute::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<ProductDefinitionSubstitute>(),
                    Box::new(entity),
                ))
            }
            "PRODUCT_DEFINITION_USAGE" => {
                let entity = ProductDefinitionUsage::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<ProductDefinitionUsage>(),
                    Box::new(entity),
                ))
            }
            "PRODUCT_DEFINITION_WITH_ASSOCIATED_DOCUMENTS" => {
                let entity = ProductDefinitionWithAssociatedDocuments::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<ProductDefinitionWithAssociatedDocuments>(),
                    Box::new(entity),
                ))
            }
            "PRODUCT_IDENTIFICATION" => {
                let entity = ProductIdentification::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<ProductIdentification>(),
                    Box::new(entity),
                ))
            }
            "PRODUCT_MATERIAL_COMPOSITION_RELATIONSHIP" => {
                let entity = ProductMaterialCompositionRelationship::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<ProductMaterialCompositionRelationship>(),
                    Box::new(entity),
                ))
            }
            "PRODUCT_RELATED_PRODUCT_CATEGORY" => {
                let entity = ProductRelatedProductCategory::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<ProductRelatedProductCategory>(),
                    Box::new(entity),
                ))
            }
            "PRODUCT_SPECIFICATION" => {
                let entity = ProductSpecification::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<ProductSpecification>(),
                    Box::new(entity),
                ))
            }
            "PROJECTED_ZONE_DEFINITION" => {
                let entity = ProjectedZoneDefinition::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<ProjectedZoneDefinition>(),
                    Box::new(entity),
                ))
            }
            "PROJECTION_CURVE" => {
                let entity = ProjectionCurve::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<ProjectionCurve>(),
                    Box::new(entity),
                ))
            }
            "PROJECTION_DIRECTED_CALLOUT" => {
                let entity = ProjectionDirectedCallout::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<ProjectionDirectedCallout>(),
                    Box::new(entity),
                ))
            }
            "PROMISSORY_USAGE_OCCURRENCE" => {
                let entity = PromissoryUsageOccurrence::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<PromissoryUsageOccurrence>(),
                    Box::new(entity),
                ))
            }
            "PROPERTY_DEFINITION" => {
                let entity = PropertyDefinition::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<PropertyDefinition>(),
                    Box::new(entity),
                ))
            }
            "PROPERTY_DEFINITION_RELATIONSHIP" => {
                let entity = PropertyDefinitionRelationship::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<PropertyDefinitionRelationship>(),
                    Box::new(entity),
                ))
            }
            "PROPERTY_DEFINITION_REPRESENTATION" => {
                let entity = PropertyDefinitionRepresentation::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<PropertyDefinitionRepresentation>(),
                    Box::new(entity),
                ))
            }
            "QUALIFIED_REPRESENTATION_ITEM" => {
                let entity = QualifiedRepresentationItem::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<QualifiedRepresentationItem>(),
                    Box::new(entity),
                ))
            }
            "QUALITATIVE_UNCERTAINTY" => {
                let entity = QualitativeUncertainty::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<QualitativeUncertainty>(),
                    Box::new(entity),
                ))
            }
            "QUANTIFIED_ASSEMBLY_COMPONENT_USAGE" => {
                let entity = QuantifiedAssemblyComponentUsage::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<QuantifiedAssemblyComponentUsage>(),
                    Box::new(entity),
                ))
            }
            "QUASI_UNIFORM_CURVE" => {
                let entity = QuasiUniformCurve::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<QuasiUniformCurve>(),
                    Box::new(entity),
                ))
            }
            "QUASI_UNIFORM_SURFACE" => {
                let entity = QuasiUniformSurface::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<QuasiUniformSurface>(),
                    Box::new(entity),
                ))
            }
            "RADIOACTIVITY_MEASURE_WITH_UNIT" => {
                let entity = RadioactivityMeasureWithUnit::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<RadioactivityMeasureWithUnit>(),
                    Box::new(entity),
                ))
            }
            "RADIOACTIVITY_UNIT" => {
                let entity = RadioactivityUnit::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<RadioactivityUnit>(),
                    Box::new(entity),
                ))
            }
            "RADIUS_DIMENSION" => {
                let entity = RadiusDimension::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<RadiusDimension>(),
                    Box::new(entity),
                ))
            }
            "RANGE_CHARACTERISTIC" => {
                let entity = RangeCharacteristic::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<RangeCharacteristic>(),
                    Box::new(entity),
                ))
            }
            "RATIO_MEASURE_WITH_UNIT" => {
                let entity = RatioMeasureWithUnit::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<RatioMeasureWithUnit>(),
                    Box::new(entity),
                ))
            }
            "RATIO_UNIT" => {
                let entity = RatioUnit::form_parameters(typed_parameter.parameters);
                Some((entity.type_id(), std::any::type_name::<RatioUnit>(), Box::new(entity)))
            }
            "RATIONAL_B_SPLINE_CURVE" => {
                let entity = RationalBSplineCurve::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<RationalBSplineCurve>(),
                    Box::new(entity),
                ))
            }
            "RATIONAL_B_SPLINE_SURFACE" => {
                let entity = RationalBSplineSurface::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<RationalBSplineSurface>(),
                    Box::new(entity),
                ))
            }
            "RATIONAL_REPRESENTATION_ITEM" => {
                let entity = RationalRepresentationItem::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<RationalRepresentationItem>(),
                    Box::new(entity),
                ))
            }
            "REAL_LITERAL" => {
                let entity = RealLiteral::form_parameters(typed_parameter.parameters);
                Some((entity.type_id(), std::any::type_name::<RealLiteral>(), Box::new(entity)))
            }
            "REAL_REPRESENTATION_ITEM" => {
                let entity = RealRepresentationItem::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<RealRepresentationItem>(),
                    Box::new(entity),
                ))
            }
            "RECTANGULAR_COMPOSITE_SURFACE" => {
                let entity = RectangularCompositeSurface::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<RectangularCompositeSurface>(),
                    Box::new(entity),
                ))
            }
            "RECTANGULAR_TRIMMED_SURFACE" => {
                let entity = RectangularTrimmedSurface::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<RectangularTrimmedSurface>(),
                    Box::new(entity),
                ))
            }
            "REFERENCED_MODIFIED_DATUM" => {
                let entity = ReferencedModifiedDatum::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<ReferencedModifiedDatum>(),
                    Box::new(entity),
                ))
            }
            "RELATIVE_EVENT_OCCURRENCE" => {
                let entity = RelativeEventOccurrence::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<RelativeEventOccurrence>(),
                    Box::new(entity),
                ))
            }
            "REP_ITEM_GROUP" => {
                let entity = RepItemGroup::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<RepItemGroup>(),
                    Box::new(entity),
                ))
            }
            "REPARAMETRISED_COMPOSITE_CURVE_SEGMENT" => {
                let entity = ReparametrisedCompositeCurveSegment::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<ReparametrisedCompositeCurveSegment>(),
                    Box::new(entity),
                ))
            }
            "REPRESENTATION" => {
                let entity = Representation::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<Representation>(),
                    Box::new(entity),
                ))
            }
            "REPRESENTATION_CONTEXT" => {
                let entity = RepresentationContext::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<RepresentationContext>(),
                    Box::new(entity),
                ))
            }
            "REPRESENTATION_ITEM" => {
                let entity = RepresentationItem::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<RepresentationItem>(),
                    Box::new(entity),
                ))
            }
            "REPRESENTATION_ITEM_RELATIONSHIP" => {
                let entity = RepresentationItemRelationship::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<RepresentationItemRelationship>(),
                    Box::new(entity),
                ))
            }
            "REPRESENTATION_MAP" => {
                let entity = RepresentationMap::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<RepresentationMap>(),
                    Box::new(entity),
                ))
            }
            "REPRESENTATION_RELATIONSHIP" => {
                let entity = RepresentationRelationship::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<RepresentationRelationship>(),
                    Box::new(entity),
                ))
            }
            "REPRESENTATION_RELATIONSHIP_WITH_TRANSFORMATION" => {
                let entity = RepresentationRelationshipWithTransformation::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<RepresentationRelationshipWithTransformation>(),
                    Box::new(entity),
                ))
            }
            "REQUIREMENT_ASSIGNED_OBJECT" => {
                let entity = RequirementAssignedObject::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<RequirementAssignedObject>(),
                    Box::new(entity),
                ))
            }
            "REQUIREMENT_ASSIGNMENT" => {
                let entity = RequirementAssignment::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<RequirementAssignment>(),
                    Box::new(entity),
                ))
            }
            "REQUIREMENT_SOURCE" => {
                let entity = RequirementSource::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<RequirementSource>(),
                    Box::new(entity),
                ))
            }
            "RESISTANCE_MEASURE_WITH_UNIT" => {
                let entity = ResistanceMeasureWithUnit::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<ResistanceMeasureWithUnit>(),
                    Box::new(entity),
                ))
            }
            "RESISTANCE_UNIT" => {
                let entity = ResistanceUnit::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<ResistanceUnit>(),
                    Box::new(entity),
                ))
            }
            "REVOLVED_AREA_SOLID" => {
                let entity = RevolvedAreaSolid::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<RevolvedAreaSolid>(),
                    Box::new(entity),
                ))
            }
            "REVOLVED_FACE_SOLID" => {
                let entity = RevolvedFaceSolid::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<RevolvedFaceSolid>(),
                    Box::new(entity),
                ))
            }
            "REVOLVED_FACE_SOLID_WITH_TRIM_CONDITIONS" => {
                let entity = RevolvedFaceSolidWithTrimConditions::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<RevolvedFaceSolidWithTrimConditions>(),
                    Box::new(entity),
                ))
            }
            "RIGHT_ANGULAR_WEDGE" => {
                let entity = RightAngularWedge::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<RightAngularWedge>(),
                    Box::new(entity),
                ))
            }
            "RIGHT_CIRCULAR_CONE" => {
                let entity = RightCircularCone::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<RightCircularCone>(),
                    Box::new(entity),
                ))
            }
            "RIGHT_CIRCULAR_CYLINDER" => {
                let entity = RightCircularCylinder::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<RightCircularCylinder>(),
                    Box::new(entity),
                ))
            }
            "RIGHT_TO_USAGE_ASSOCIATION" => {
                let entity = RightToUsageAssociation::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<RightToUsageAssociation>(),
                    Box::new(entity),
                ))
            }
            "ROLE_ASSOCIATION" => {
                let entity = RoleAssociation::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<RoleAssociation>(),
                    Box::new(entity),
                ))
            }
            "ROUNDNESS_TOLERANCE" => {
                let entity = RoundnessTolerance::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<RoundnessTolerance>(),
                    Box::new(entity),
                ))
            }
            "ROW_REPRESENTATION_ITEM" => {
                let entity = RowRepresentationItem::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<RowRepresentationItem>(),
                    Box::new(entity),
                ))
            }
            "ROW_VALUE" => {
                let entity = RowValue::form_parameters(typed_parameter.parameters);
                Some((entity.type_id(), std::any::type_name::<RowValue>(), Box::new(entity)))
            }
            "ROW_VARIABLE" => {
                let entity = RowVariable::form_parameters(typed_parameter.parameters);
                Some((entity.type_id(), std::any::type_name::<RowVariable>(), Box::new(entity)))
            }
            "RULE_ACTION" => {
                let entity = RuleAction::form_parameters(typed_parameter.parameters);
                Some((entity.type_id(), std::any::type_name::<RuleAction>(), Box::new(entity)))
            }
            "RULE_CONDITION" => {
                let entity = RuleCondition::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<RuleCondition>(),
                    Box::new(entity),
                ))
            }
            "RULE_DEFINITION" => {
                let entity = RuleDefinition::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<RuleDefinition>(),
                    Box::new(entity),
                ))
            }
            "RULE_SET" => {
                let entity = RuleSet::form_parameters(typed_parameter.parameters);
                Some((entity.type_id(), std::any::type_name::<RuleSet>(), Box::new(entity)))
            }
            "RULE_SET_GROUP" => {
                let entity = RuleSetGroup::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<RuleSetGroup>(),
                    Box::new(entity),
                ))
            }
            "RULE_SOFTWARE_DEFINITION" => {
                let entity = RuleSoftwareDefinition::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<RuleSoftwareDefinition>(),
                    Box::new(entity),
                ))
            }
            "RULE_SUPERSEDED_ASSIGNMENT" => {
                let entity = RuleSupersededAssignment::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<RuleSupersededAssignment>(),
                    Box::new(entity),
                ))
            }
            "RULE_SUPERSEDENCE" => {
                let entity = RuleSupersedence::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<RuleSupersedence>(),
                    Box::new(entity),
                ))
            }
            "RULED_SURFACE_SWEPT_AREA_SOLID" => {
                let entity = RuledSurfaceSweptAreaSolid::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<RuledSurfaceSweptAreaSolid>(),
                    Box::new(entity),
                ))
            }
            "RUNOUT_ZONE_DEFINITION" => {
                let entity = RunoutZoneDefinition::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<RunoutZoneDefinition>(),
                    Box::new(entity),
                ))
            }
            "RUNOUT_ZONE_ORIENTATION" => {
                let entity = RunoutZoneOrientation::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<RunoutZoneOrientation>(),
                    Box::new(entity),
                ))
            }
            "RUNOUT_ZONE_ORIENTATION_REFERENCE_DIRECTION" => {
                let entity = RunoutZoneOrientationReferenceDirection::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<RunoutZoneOrientationReferenceDirection>(),
                    Box::new(entity),
                ))
            }
            "SCALAR_VARIABLE" => {
                let entity = ScalarVariable::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<ScalarVariable>(),
                    Box::new(entity),
                ))
            }
            "SCATTERING_PARAMETER" => {
                let entity = ScatteringParameter::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<ScatteringParameter>(),
                    Box::new(entity),
                ))
            }
            "SCULPTURED_SOLID" => {
                let entity = SculpturedSolid::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<SculpturedSolid>(),
                    Box::new(entity),
                ))
            }
            "SEAM_CURVE" => {
                let entity = SeamCurve::form_parameters(typed_parameter.parameters);
                Some((entity.type_id(), std::any::type_name::<SeamCurve>(), Box::new(entity)))
            }
            "SECURITY_CLASSIFICATION" => {
                let entity = SecurityClassification::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<SecurityClassification>(),
                    Box::new(entity),
                ))
            }
            "SECURITY_CLASSIFICATION_LEVEL" => {
                let entity = SecurityClassificationLevel::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<SecurityClassificationLevel>(),
                    Box::new(entity),
                ))
            }
            "SERIAL_NUMBERED_EFFECTIVITY" => {
                let entity = SerialNumberedEffectivity::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<SerialNumberedEffectivity>(),
                    Box::new(entity),
                ))
            }
            "SHAPE_ASPECT" => {
                let entity = ShapeAspect::form_parameters(typed_parameter.parameters);
                Some((entity.type_id(), std::any::type_name::<ShapeAspect>(), Box::new(entity)))
            }
            "SHAPE_ASPECT_ASSOCIATIVITY" => {
                let entity = ShapeAspectAssociativity::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<ShapeAspectAssociativity>(),
                    Box::new(entity),
                ))
            }
            "SHAPE_ASPECT_DERIVING_RELATIONSHIP" => {
                let entity = ShapeAspectDerivingRelationship::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<ShapeAspectDerivingRelationship>(),
                    Box::new(entity),
                ))
            }
            "SHAPE_ASPECT_RELATIONSHIP" => {
                let entity = ShapeAspectRelationship::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<ShapeAspectRelationship>(),
                    Box::new(entity),
                ))
            }
            "SHAPE_DEFINITION_REPRESENTATION" => {
                let entity = ShapeDefinitionRepresentation::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<ShapeDefinitionRepresentation>(),
                    Box::new(entity),
                ))
            }
            "SHAPE_DIMENSION_REPRESENTATION" => {
                let entity = ShapeDimensionRepresentation::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<ShapeDimensionRepresentation>(),
                    Box::new(entity),
                ))
            }
            "SHAPE_FEATURE_DEFINITION" => {
                let entity = ShapeFeatureDefinition::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<ShapeFeatureDefinition>(),
                    Box::new(entity),
                ))
            }
            "SHAPE_REPRESENTATION" => {
                let entity = ShapeRepresentation::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<ShapeRepresentation>(),
                    Box::new(entity),
                ))
            }
            "SHAPE_REPRESENTATION_RELATIONSHIP" => {
                let entity = ShapeRepresentationRelationship::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<ShapeRepresentationRelationship>(),
                    Box::new(entity),
                ))
            }
            "SHAPE_REPRESENTATION_WITH_PARAMETERS" => {
                let entity = ShapeRepresentationWithParameters::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<ShapeRepresentationWithParameters>(),
                    Box::new(entity),
                ))
            }
            "SHELL_BASED_SURFACE_MODEL" => {
                let entity = ShellBasedSurfaceModel::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<ShellBasedSurfaceModel>(),
                    Box::new(entity),
                ))
            }
            "SHELL_BASED_WIREFRAME_MODEL" => {
                let entity = ShellBasedWireframeModel::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<ShellBasedWireframeModel>(),
                    Box::new(entity),
                ))
            }
            "SHELL_BASED_WIREFRAME_SHAPE_REPRESENTATION" => {
                let entity = ShellBasedWireframeShapeRepresentation::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<ShellBasedWireframeShapeRepresentation>(),
                    Box::new(entity),
                ))
            }
            "SHELLED_SOLID" => {
                let entity = ShelledSolid::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<ShelledSolid>(),
                    Box::new(entity),
                ))
            }
            "SI_ABSORBED_DOSE_UNIT" => {
                let entity = SiAbsorbedDoseUnit::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<SiAbsorbedDoseUnit>(),
                    Box::new(entity),
                ))
            }
            "SI_CAPACITANCE_UNIT" => {
                let entity = SiCapacitanceUnit::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<SiCapacitanceUnit>(),
                    Box::new(entity),
                ))
            }
            "SI_CONDUCTANCE_UNIT" => {
                let entity = SiConductanceUnit::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<SiConductanceUnit>(),
                    Box::new(entity),
                ))
            }
            "SI_DOSE_EQUIVALENT_UNIT" => {
                let entity = SiDoseEquivalentUnit::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<SiDoseEquivalentUnit>(),
                    Box::new(entity),
                ))
            }
            "SI_ELECTRIC_CHARGE_UNIT" => {
                let entity = SiElectricChargeUnit::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<SiElectricChargeUnit>(),
                    Box::new(entity),
                ))
            }
            "SI_ELECTRIC_POTENTIAL_UNIT" => {
                let entity = SiElectricPotentialUnit::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<SiElectricPotentialUnit>(),
                    Box::new(entity),
                ))
            }
            "SI_ENERGY_UNIT" => {
                let entity = SiEnergyUnit::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<SiEnergyUnit>(),
                    Box::new(entity),
                ))
            }
            "SI_FORCE_UNIT" => {
                let entity = SiForceUnit::form_parameters(typed_parameter.parameters);
                Some((entity.type_id(), std::any::type_name::<SiForceUnit>(), Box::new(entity)))
            }
            "SI_FREQUENCY_UNIT" => {
                let entity = SiFrequencyUnit::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<SiFrequencyUnit>(),
                    Box::new(entity),
                ))
            }
            "SI_ILLUMINANCE_UNIT" => {
                let entity = SiIlluminanceUnit::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<SiIlluminanceUnit>(),
                    Box::new(entity),
                ))
            }
            "SI_INDUCTANCE_UNIT" => {
                let entity = SiInductanceUnit::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<SiInductanceUnit>(),
                    Box::new(entity),
                ))
            }
            "SI_MAGNETIC_FLUX_DENSITY_UNIT" => {
                let entity = SiMagneticFluxDensityUnit::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<SiMagneticFluxDensityUnit>(),
                    Box::new(entity),
                ))
            }
            "SI_MAGNETIC_FLUX_UNIT" => {
                let entity = SiMagneticFluxUnit::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<SiMagneticFluxUnit>(),
                    Box::new(entity),
                ))
            }
            "SI_POWER_UNIT" => {
                let entity = SiPowerUnit::form_parameters(typed_parameter.parameters);
                Some((entity.type_id(), std::any::type_name::<SiPowerUnit>(), Box::new(entity)))
            }
            "SI_PRESSURE_UNIT" => {
                let entity = SiPressureUnit::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<SiPressureUnit>(),
                    Box::new(entity),
                ))
            }
            "SI_RADIOACTIVITY_UNIT" => {
                let entity = SiRadioactivityUnit::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<SiRadioactivityUnit>(),
                    Box::new(entity),
                ))
            }
            "SI_RESISTANCE_UNIT" => {
                let entity = SiResistanceUnit::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<SiResistanceUnit>(),
                    Box::new(entity),
                ))
            }
            "SI_UNIT" => {
                let entity = SiUnit::form_parameters(typed_parameter.parameters);
                Some((entity.type_id(), std::any::type_name::<SiUnit>(), Box::new(entity)))
            }
            "SIMPLE_CLAUSE" => {
                let entity = SimpleClause::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<SimpleClause>(),
                    Box::new(entity),
                ))
            }
            "SLASH_EXPRESSION" => {
                let entity = SlashExpression::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<SlashExpression>(),
                    Box::new(entity),
                ))
            }
            "SMEARED_MATERIAL_DEFINITION" => {
                let entity = SmearedMaterialDefinition::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<SmearedMaterialDefinition>(),
                    Box::new(entity),
                ))
            }
            "SOLID_ANGLE_MEASURE_WITH_UNIT" => {
                let entity = SolidAngleMeasureWithUnit::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<SolidAngleMeasureWithUnit>(),
                    Box::new(entity),
                ))
            }
            "SOLID_ANGLE_UNIT" => {
                let entity = SolidAngleUnit::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<SolidAngleUnit>(),
                    Box::new(entity),
                ))
            }
            "SOLID_CURVE_FONT" => {
                let entity = SolidCurveFont::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<SolidCurveFont>(),
                    Box::new(entity),
                ))
            }
            "SOLID_MODEL" => {
                let entity = SolidModel::form_parameters(typed_parameter.parameters);
                Some((entity.type_id(), std::any::type_name::<SolidModel>(), Box::new(entity)))
            }
            "SOLID_REPLICA" => {
                let entity = SolidReplica::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<SolidReplica>(),
                    Box::new(entity),
                ))
            }
            "SOLID_WITH_ANGLE_BASED_CHAMFER" => {
                let entity = SolidWithAngleBasedChamfer::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<SolidWithAngleBasedChamfer>(),
                    Box::new(entity),
                ))
            }
            "SOLID_WITH_CIRCULAR_PATTERN" => {
                let entity = SolidWithCircularPattern::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<SolidWithCircularPattern>(),
                    Box::new(entity),
                ))
            }
            "SOLID_WITH_CIRCULAR_POCKET" => {
                let entity = SolidWithCircularPocket::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<SolidWithCircularPocket>(),
                    Box::new(entity),
                ))
            }
            "SOLID_WITH_CIRCULAR_PROTRUSION" => {
                let entity = SolidWithCircularProtrusion::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<SolidWithCircularProtrusion>(),
                    Box::new(entity),
                ))
            }
            "SOLID_WITH_CONICAL_BOTTOM_ROUND_HOLE" => {
                let entity = SolidWithConicalBottomRoundHole::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<SolidWithConicalBottomRoundHole>(),
                    Box::new(entity),
                ))
            }
            "SOLID_WITH_CONSTANT_RADIUS_EDGE_BLEND" => {
                let entity = SolidWithConstantRadiusEdgeBlend::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<SolidWithConstantRadiusEdgeBlend>(),
                    Box::new(entity),
                ))
            }
            "SOLID_WITH_CURVED_SLOT" => {
                let entity = SolidWithCurvedSlot::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<SolidWithCurvedSlot>(),
                    Box::new(entity),
                ))
            }
            "SOLID_WITH_DOUBLE_OFFSET_CHAMFER" => {
                let entity = SolidWithDoubleOffsetChamfer::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<SolidWithDoubleOffsetChamfer>(),
                    Box::new(entity),
                ))
            }
            "SOLID_WITH_FLAT_BOTTOM_ROUND_HOLE" => {
                let entity = SolidWithFlatBottomRoundHole::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<SolidWithFlatBottomRoundHole>(),
                    Box::new(entity),
                ))
            }
            "SOLID_WITH_GENERAL_POCKET" => {
                let entity = SolidWithGeneralPocket::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<SolidWithGeneralPocket>(),
                    Box::new(entity),
                ))
            }
            "SOLID_WITH_GENERAL_PROTRUSION" => {
                let entity = SolidWithGeneralProtrusion::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<SolidWithGeneralProtrusion>(),
                    Box::new(entity),
                ))
            }
            "SOLID_WITH_GROOVE" => {
                let entity = SolidWithGroove::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<SolidWithGroove>(),
                    Box::new(entity),
                ))
            }
            "SOLID_WITH_INCOMPLETE_CIRCULAR_PATTERN" => {
                let entity = SolidWithIncompleteCircularPattern::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<SolidWithIncompleteCircularPattern>(),
                    Box::new(entity),
                ))
            }
            "SOLID_WITH_INCOMPLETE_RECTANGULAR_PATTERN" => {
                let entity = SolidWithIncompleteRectangularPattern::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<SolidWithIncompleteRectangularPattern>(),
                    Box::new(entity),
                ))
            }
            "SOLID_WITH_RECTANGULAR_PATTERN" => {
                let entity = SolidWithRectangularPattern::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<SolidWithRectangularPattern>(),
                    Box::new(entity),
                ))
            }
            "SOLID_WITH_RECTANGULAR_POCKET" => {
                let entity = SolidWithRectangularPocket::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<SolidWithRectangularPocket>(),
                    Box::new(entity),
                ))
            }
            "SOLID_WITH_RECTANGULAR_PROTRUSION" => {
                let entity = SolidWithRectangularProtrusion::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<SolidWithRectangularProtrusion>(),
                    Box::new(entity),
                ))
            }
            "SOLID_WITH_SINGLE_OFFSET_CHAMFER" => {
                let entity = SolidWithSingleOffsetChamfer::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<SolidWithSingleOffsetChamfer>(),
                    Box::new(entity),
                ))
            }
            "SOLID_WITH_SPHERICAL_BOTTOM_ROUND_HOLE" => {
                let entity = SolidWithSphericalBottomRoundHole::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<SolidWithSphericalBottomRoundHole>(),
                    Box::new(entity),
                ))
            }
            "SOLID_WITH_STEPPED_ROUND_HOLE" => {
                let entity = SolidWithSteppedRoundHole::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<SolidWithSteppedRoundHole>(),
                    Box::new(entity),
                ))
            }
            "SOLID_WITH_STEPPED_ROUND_HOLE_AND_CONICAL_TRANSITIONS" => {
                let entity =
                    SolidWithSteppedRoundHoleAndConicalTransitions::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<SolidWithSteppedRoundHoleAndConicalTransitions>(),
                    Box::new(entity),
                ))
            }
            "SOLID_WITH_STRAIGHT_SLOT" => {
                let entity = SolidWithStraightSlot::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<SolidWithStraightSlot>(),
                    Box::new(entity),
                ))
            }
            "SOLID_WITH_TEE_SECTION_SLOT" => {
                let entity = SolidWithTeeSectionSlot::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<SolidWithTeeSectionSlot>(),
                    Box::new(entity),
                ))
            }
            "SOLID_WITH_THROUGH_DEPRESSION" => {
                let entity = SolidWithThroughDepression::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<SolidWithThroughDepression>(),
                    Box::new(entity),
                ))
            }
            "SOLID_WITH_TRAPEZOIDAL_SECTION_SLOT" => {
                let entity = SolidWithTrapezoidalSectionSlot::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<SolidWithTrapezoidalSectionSlot>(),
                    Box::new(entity),
                ))
            }
            "SOLID_WITH_VARIABLE_RADIUS_EDGE_BLEND" => {
                let entity = SolidWithVariableRadiusEdgeBlend::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<SolidWithVariableRadiusEdgeBlend>(),
                    Box::new(entity),
                ))
            }
            "SOURCE_FOR_REQUIREMENT" => {
                let entity = SourceForRequirement::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<SourceForRequirement>(),
                    Box::new(entity),
                ))
            }
            "SOURCED_REQUIREMENT" => {
                let entity = SourcedRequirement::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<SourcedRequirement>(),
                    Box::new(entity),
                ))
            }
            "SPECIFICATION_DEFINITION" => {
                let entity = SpecificationDefinition::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<SpecificationDefinition>(),
                    Box::new(entity),
                ))
            }
            "SPECIFIED_HIGHER_USAGE_OCCURRENCE" => {
                let entity = SpecifiedHigherUsageOccurrence::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<SpecifiedHigherUsageOccurrence>(),
                    Box::new(entity),
                ))
            }
            "SPHERE" => {
                let entity = Sphere::form_parameters(typed_parameter.parameters);
                Some((entity.type_id(), std::any::type_name::<Sphere>(), Box::new(entity)))
            }
            "SPHERICAL_SURFACE" => {
                let entity = SphericalSurface::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<SphericalSurface>(),
                    Box::new(entity),
                ))
            }
            "STANDARD_UNCERTAINTY" => {
                let entity = StandardUncertainty::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<StandardUncertainty>(),
                    Box::new(entity),
                ))
            }
            "START_REQUEST" => {
                let entity = StartRequest::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<StartRequest>(),
                    Box::new(entity),
                ))
            }
            "START_WORK" => {
                let entity = StartWork::form_parameters(typed_parameter.parameters);
                Some((entity.type_id(), std::any::type_name::<StartWork>(), Box::new(entity)))
            }
            "STRAIGHTNESS_TOLERANCE" => {
                let entity = StraightnessTolerance::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<StraightnessTolerance>(),
                    Box::new(entity),
                ))
            }
            "STRUCTURED_DIMENSION_CALLOUT" => {
                let entity = StructuredDimensionCallout::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<StructuredDimensionCallout>(),
                    Box::new(entity),
                ))
            }
            "STRUCTURED_TEXT_COMPOSITION" => {
                let entity = StructuredTextComposition::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<StructuredTextComposition>(),
                    Box::new(entity),
                ))
            }
            "STRUCTURED_TEXT_REPRESENTATION" => {
                let entity = StructuredTextRepresentation::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<StructuredTextRepresentation>(),
                    Box::new(entity),
                ))
            }
            "STYLED_ITEM" => {
                let entity = StyledItem::form_parameters(typed_parameter.parameters);
                Some((entity.type_id(), std::any::type_name::<StyledItem>(), Box::new(entity)))
            }
            "SUBEDGE" => {
                let entity = Subedge::form_parameters(typed_parameter.parameters);
                Some((entity.type_id(), std::any::type_name::<Subedge>(), Box::new(entity)))
            }
            "SUBFACE" => {
                let entity = Subface::form_parameters(typed_parameter.parameters);
                Some((entity.type_id(), std::any::type_name::<Subface>(), Box::new(entity)))
            }
            "SUPPLIED_PART_RELATIONSHIP" => {
                let entity = SuppliedPartRelationship::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<SuppliedPartRelationship>(),
                    Box::new(entity),
                ))
            }
            "SURFACE" => {
                let entity = Surface::form_parameters(typed_parameter.parameters);
                Some((entity.type_id(), std::any::type_name::<Surface>(), Box::new(entity)))
            }
            "SURFACE_CONDITION_CALLOUT" => {
                let entity = SurfaceConditionCallout::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<SurfaceConditionCallout>(),
                    Box::new(entity),
                ))
            }
            "SURFACE_CURVE" => {
                let entity = SurfaceCurve::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<SurfaceCurve>(),
                    Box::new(entity),
                ))
            }
            "SURFACE_CURVE_SWEPT_AREA_SOLID" => {
                let entity = SurfaceCurveSweptAreaSolid::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<SurfaceCurveSweptAreaSolid>(),
                    Box::new(entity),
                ))
            }
            "SURFACE_OF_LINEAR_EXTRUSION" => {
                let entity = SurfaceOfLinearExtrusion::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<SurfaceOfLinearExtrusion>(),
                    Box::new(entity),
                ))
            }
            "SURFACE_OF_REVOLUTION" => {
                let entity = SurfaceOfRevolution::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<SurfaceOfRevolution>(),
                    Box::new(entity),
                ))
            }
            "SURFACE_PATCH" => {
                let entity = SurfacePatch::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<SurfacePatch>(),
                    Box::new(entity),
                ))
            }
            "SURFACE_PROFILE_TOLERANCE" => {
                let entity = SurfaceProfileTolerance::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<SurfaceProfileTolerance>(),
                    Box::new(entity),
                ))
            }
            "SURFACE_RENDERING_PROPERTIES" => {
                let entity = SurfaceRenderingProperties::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<SurfaceRenderingProperties>(),
                    Box::new(entity),
                ))
            }
            "SURFACE_REPLICA" => {
                let entity = SurfaceReplica::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<SurfaceReplica>(),
                    Box::new(entity),
                ))
            }
            "SURFACE_SIDE_STYLE" => {
                let entity = SurfaceSideStyle::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<SurfaceSideStyle>(),
                    Box::new(entity),
                ))
            }
            "SURFACE_STYLE_BOUNDARY" => {
                let entity = SurfaceStyleBoundary::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<SurfaceStyleBoundary>(),
                    Box::new(entity),
                ))
            }
            "SURFACE_STYLE_CONTROL_GRID" => {
                let entity = SurfaceStyleControlGrid::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<SurfaceStyleControlGrid>(),
                    Box::new(entity),
                ))
            }
            "SURFACE_STYLE_FILL_AREA" => {
                let entity = SurfaceStyleFillArea::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<SurfaceStyleFillArea>(),
                    Box::new(entity),
                ))
            }
            "SURFACE_STYLE_PARAMETER_LINE" => {
                let entity = SurfaceStyleParameterLine::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<SurfaceStyleParameterLine>(),
                    Box::new(entity),
                ))
            }
            "SURFACE_STYLE_REFLECTANCE_AMBIENT" => {
                let entity = SurfaceStyleReflectanceAmbient::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<SurfaceStyleReflectanceAmbient>(),
                    Box::new(entity),
                ))
            }
            "SURFACE_STYLE_REFLECTANCE_AMBIENT_DIFFUSE" => {
                let entity = SurfaceStyleReflectanceAmbientDiffuse::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<SurfaceStyleReflectanceAmbientDiffuse>(),
                    Box::new(entity),
                ))
            }
            "SURFACE_STYLE_REFLECTANCE_AMBIENT_DIFFUSE_SPECULAR" => {
                let entity = SurfaceStyleReflectanceAmbientDiffuseSpecular::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<SurfaceStyleReflectanceAmbientDiffuseSpecular>(),
                    Box::new(entity),
                ))
            }
            "SURFACE_STYLE_RENDERING" => {
                let entity = SurfaceStyleRendering::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<SurfaceStyleRendering>(),
                    Box::new(entity),
                ))
            }
            "SURFACE_STYLE_RENDERING_WITH_PROPERTIES" => {
                let entity = SurfaceStyleRenderingWithProperties::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<SurfaceStyleRenderingWithProperties>(),
                    Box::new(entity),
                ))
            }
            "SURFACE_STYLE_SEGMENTATION_CURVE" => {
                let entity = SurfaceStyleSegmentationCurve::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<SurfaceStyleSegmentationCurve>(),
                    Box::new(entity),
                ))
            }
            "SURFACE_STYLE_SILHOUETTE" => {
                let entity = SurfaceStyleSilhouette::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<SurfaceStyleSilhouette>(),
                    Box::new(entity),
                ))
            }
            "SURFACE_STYLE_TRANSPARENT" => {
                let entity = SurfaceStyleTransparent::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<SurfaceStyleTransparent>(),
                    Box::new(entity),
                ))
            }
            "SURFACE_STYLE_USAGE" => {
                let entity = SurfaceStyleUsage::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<SurfaceStyleUsage>(),
                    Box::new(entity),
                ))
            }
            "SURFACE_TEXTURE_REPRESENTATION" => {
                let entity = SurfaceTextureRepresentation::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<SurfaceTextureRepresentation>(),
                    Box::new(entity),
                ))
            }
            "SURFACED_OPEN_SHELL" => {
                let entity = SurfacedOpenShell::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<SurfacedOpenShell>(),
                    Box::new(entity),
                ))
            }
            "SWEPT_AREA_SOLID" => {
                let entity = SweptAreaSolid::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<SweptAreaSolid>(),
                    Box::new(entity),
                ))
            }
            "SWEPT_DISK_SOLID" => {
                let entity = SweptDiskSolid::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<SweptDiskSolid>(),
                    Box::new(entity),
                ))
            }
            "SWEPT_FACE_SOLID" => {
                let entity = SweptFaceSolid::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<SweptFaceSolid>(),
                    Box::new(entity),
                ))
            }
            "SWEPT_SURFACE" => {
                let entity = SweptSurface::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<SweptSurface>(),
                    Box::new(entity),
                ))
            }
            "SYMBOL" => {
                let entity = Symbol::form_parameters(typed_parameter.parameters);
                Some((entity.type_id(), std::any::type_name::<Symbol>(), Box::new(entity)))
            }
            "SYMBOL_COLOUR" => {
                let entity = SymbolColour::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<SymbolColour>(),
                    Box::new(entity),
                ))
            }
            "SYMBOL_REPRESENTATION" => {
                let entity = SymbolRepresentation::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<SymbolRepresentation>(),
                    Box::new(entity),
                ))
            }
            "SYMBOL_REPRESENTATION_MAP" => {
                let entity = SymbolRepresentationMap::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<SymbolRepresentationMap>(),
                    Box::new(entity),
                ))
            }
            "SYMBOL_STYLE" => {
                let entity = SymbolStyle::form_parameters(typed_parameter.parameters);
                Some((entity.type_id(), std::any::type_name::<SymbolStyle>(), Box::new(entity)))
            }
            "SYMBOL_TARGET" => {
                let entity = SymbolTarget::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<SymbolTarget>(),
                    Box::new(entity),
                ))
            }
            "SYMMETRIC_SHAPE_ASPECT" => {
                let entity = SymmetricShapeAspect::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<SymmetricShapeAspect>(),
                    Box::new(entity),
                ))
            }
            "SYMMETRY_TOLERANCE" => {
                let entity = SymmetryTolerance::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<SymmetryTolerance>(),
                    Box::new(entity),
                ))
            }
            "TABLE_REPRESENTATION_ITEM" => {
                let entity = TableRepresentationItem::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<TableRepresentationItem>(),
                    Box::new(entity),
                ))
            }
            "TACTILE_APPEARANCE_REPRESENTATION" => {
                let entity = TactileAppearanceRepresentation::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<TactileAppearanceRepresentation>(),
                    Box::new(entity),
                ))
            }
            "TAGGED_TEXT_FORMAT" => {
                let entity = TaggedTextFormat::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<TaggedTextFormat>(),
                    Box::new(entity),
                ))
            }
            "TAGGED_TEXT_ITEM" => {
                let entity = TaggedTextItem::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<TaggedTextItem>(),
                    Box::new(entity),
                ))
            }
            "TANGENT" => {
                let entity = Tangent::form_parameters(typed_parameter.parameters);
                Some((entity.type_id(), std::any::type_name::<Tangent>(), Box::new(entity)))
            }
            "TERMINATOR_SYMBOL" => {
                let entity = TerminatorSymbol::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<TerminatorSymbol>(),
                    Box::new(entity),
                ))
            }
            "TEXT_FONT" => {
                let entity = TextFont::form_parameters(typed_parameter.parameters);
                Some((entity.type_id(), std::any::type_name::<TextFont>(), Box::new(entity)))
            }
            "TEXT_FONT_FAMILY" => {
                let entity = TextFontFamily::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<TextFontFamily>(),
                    Box::new(entity),
                ))
            }
            "TEXT_FONT_IN_FAMILY" => {
                let entity = TextFontInFamily::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<TextFontInFamily>(),
                    Box::new(entity),
                ))
            }
            "TEXT_LITERAL" => {
                let entity = TextLiteral::form_parameters(typed_parameter.parameters);
                Some((entity.type_id(), std::any::type_name::<TextLiteral>(), Box::new(entity)))
            }
            "TEXT_LITERAL_WITH_ASSOCIATED_CURVES" => {
                let entity = TextLiteralWithAssociatedCurves::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<TextLiteralWithAssociatedCurves>(),
                    Box::new(entity),
                ))
            }
            "TEXT_LITERAL_WITH_BLANKING_BOX" => {
                let entity = TextLiteralWithBlankingBox::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<TextLiteralWithBlankingBox>(),
                    Box::new(entity),
                ))
            }
            "TEXT_LITERAL_WITH_DELINEATION" => {
                let entity = TextLiteralWithDelineation::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<TextLiteralWithDelineation>(),
                    Box::new(entity),
                ))
            }
            "TEXT_LITERAL_WITH_EXTENT" => {
                let entity = TextLiteralWithExtent::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<TextLiteralWithExtent>(),
                    Box::new(entity),
                ))
            }
            "TEXT_STRING_REPRESENTATION" => {
                let entity = TextStringRepresentation::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<TextStringRepresentation>(),
                    Box::new(entity),
                ))
            }
            "TEXT_STYLE" => {
                let entity = TextStyle::form_parameters(typed_parameter.parameters);
                Some((entity.type_id(), std::any::type_name::<TextStyle>(), Box::new(entity)))
            }
            "TEXT_STYLE_FOR_DEFINED_FONT" => {
                let entity = TextStyleForDefinedFont::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<TextStyleForDefinedFont>(),
                    Box::new(entity),
                ))
            }
            "TEXT_STYLE_WITH_BOX_CHARACTERISTICS" => {
                let entity = TextStyleWithBoxCharacteristics::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<TextStyleWithBoxCharacteristics>(),
                    Box::new(entity),
                ))
            }
            "TEXT_STYLE_WITH_MIRROR" => {
                let entity = TextStyleWithMirror::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<TextStyleWithMirror>(),
                    Box::new(entity),
                ))
            }
            "TEXT_STYLE_WITH_SPACING" => {
                let entity = TextStyleWithSpacing::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<TextStyleWithSpacing>(),
                    Box::new(entity),
                ))
            }
            "THERMAL_RESISTANCE_MEASURE_WITH_UNIT" => {
                let entity = ThermalResistanceMeasureWithUnit::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<ThermalResistanceMeasureWithUnit>(),
                    Box::new(entity),
                ))
            }
            "THERMAL_RESISTANCE_UNIT" => {
                let entity = ThermalResistanceUnit::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<ThermalResistanceUnit>(),
                    Box::new(entity),
                ))
            }
            "THERMODYNAMIC_TEMPERATURE_MEASURE_WITH_UNIT" => {
                let entity = ThermodynamicTemperatureMeasureWithUnit::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<ThermodynamicTemperatureMeasureWithUnit>(),
                    Box::new(entity),
                ))
            }
            "THERMODYNAMIC_TEMPERATURE_UNIT" => {
                let entity = ThermodynamicTemperatureUnit::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<ThermodynamicTemperatureUnit>(),
                    Box::new(entity),
                ))
            }
            "THICKENED_FACE_SOLID" => {
                let entity = ThickenedFaceSolid::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<ThickenedFaceSolid>(),
                    Box::new(entity),
                ))
            }
            "THICKNESS_LAMINATE_DEFINITION" => {
                let entity = ThicknessLaminateDefinition::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<ThicknessLaminateDefinition>(),
                    Box::new(entity),
                ))
            }
            "THICKNESS_LAMINATE_TABLE" => {
                let entity = ThicknessLaminateTable::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<ThicknessLaminateTable>(),
                    Box::new(entity),
                ))
            }
            "TIME_INTERVAL" => {
                let entity = TimeInterval::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<TimeInterval>(),
                    Box::new(entity),
                ))
            }
            "TIME_INTERVAL_BASED_EFFECTIVITY" => {
                let entity = TimeIntervalBasedEffectivity::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<TimeIntervalBasedEffectivity>(),
                    Box::new(entity),
                ))
            }
            "TIME_INTERVAL_RELATIONSHIP" => {
                let entity = TimeIntervalRelationship::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<TimeIntervalRelationship>(),
                    Box::new(entity),
                ))
            }
            "TIME_INTERVAL_ROLE" => {
                let entity = TimeIntervalRole::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<TimeIntervalRole>(),
                    Box::new(entity),
                ))
            }
            "TIME_INTERVAL_WITH_BOUNDS" => {
                let entity = TimeIntervalWithBounds::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<TimeIntervalWithBounds>(),
                    Box::new(entity),
                ))
            }
            "TIME_MEASURE_WITH_UNIT" => {
                let entity = TimeMeasureWithUnit::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<TimeMeasureWithUnit>(),
                    Box::new(entity),
                ))
            }
            "TIME_UNIT" => {
                let entity = TimeUnit::form_parameters(typed_parameter.parameters);
                Some((entity.type_id(), std::any::type_name::<TimeUnit>(), Box::new(entity)))
            }
            "TOLERANCE_VALUE" => {
                let entity = ToleranceValue::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<ToleranceValue>(),
                    Box::new(entity),
                ))
            }
            "TOLERANCE_ZONE" => {
                let entity = ToleranceZone::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<ToleranceZone>(),
                    Box::new(entity),
                ))
            }
            "TOLERANCE_ZONE_DEFINITION" => {
                let entity = ToleranceZoneDefinition::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<ToleranceZoneDefinition>(),
                    Box::new(entity),
                ))
            }
            "TOLERANCE_ZONE_FORM" => {
                let entity = ToleranceZoneForm::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<ToleranceZoneForm>(),
                    Box::new(entity),
                ))
            }
            "TOPOLOGICAL_REPRESENTATION_ITEM" => {
                let entity = TopologicalRepresentationItem::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<TopologicalRepresentationItem>(),
                    Box::new(entity),
                ))
            }
            "TOROIDAL_SURFACE" => {
                let entity = ToroidalSurface::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<ToroidalSurface>(),
                    Box::new(entity),
                ))
            }
            "TORUS" => {
                let entity = Torus::form_parameters(typed_parameter.parameters);
                Some((entity.type_id(), std::any::type_name::<Torus>(), Box::new(entity)))
            }
            "TOTAL_RUNOUT_TOLERANCE" => {
                let entity = TotalRunoutTolerance::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<TotalRunoutTolerance>(),
                    Box::new(entity),
                ))
            }
            "TRACK_BLENDED_SOLID_WITH_END_CONDITIONS" => {
                let entity = TrackBlendedSolidWithEndConditions::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<TrackBlendedSolidWithEndConditions>(),
                    Box::new(entity),
                ))
            }
            "TRANSFORMATION_WITH_DERIVED_ANGLE" => {
                let entity = TransformationWithDerivedAngle::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<TransformationWithDerivedAngle>(),
                    Box::new(entity),
                ))
            }
            "TRIMMED_CURVE" => {
                let entity = TrimmedCurve::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<TrimmedCurve>(),
                    Box::new(entity),
                ))
            }
            "TWO_DIRECTION_REPEAT_FACTOR" => {
                let entity = TwoDirectionRepeatFactor::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<TwoDirectionRepeatFactor>(),
                    Box::new(entity),
                ))
            }
            "TYPE_QUALIFIER" => {
                let entity = TypeQualifier::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<TypeQualifier>(),
                    Box::new(entity),
                ))
            }
            "UNCERTAINTY_ASSIGNED_REPRESENTATION" => {
                let entity = UncertaintyAssignedRepresentation::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<UncertaintyAssignedRepresentation>(),
                    Box::new(entity),
                ))
            }
            "UNCERTAINTY_MEASURE_WITH_UNIT" => {
                let entity = UncertaintyMeasureWithUnit::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<UncertaintyMeasureWithUnit>(),
                    Box::new(entity),
                ))
            }
            "UNCERTAINTY_QUALIFIER" => {
                let entity = UncertaintyQualifier::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<UncertaintyQualifier>(),
                    Box::new(entity),
                ))
            }
            "UNIFORM_CURVE" => {
                let entity = UniformCurve::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<UniformCurve>(),
                    Box::new(entity),
                ))
            }
            "UNIFORM_RESOURCE_IDENTIFIER" => {
                let entity = UniformResourceIdentifier::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<UniformResourceIdentifier>(),
                    Box::new(entity),
                ))
            }
            "UNIFORM_SURFACE" => {
                let entity = UniformSurface::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<UniformSurface>(),
                    Box::new(entity),
                ))
            }
            "USAGE_ASSOCIATION" => {
                let entity = UsageAssociation::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<UsageAssociation>(),
                    Box::new(entity),
                ))
            }
            "USER_DEFINED_CURVE_FONT" => {
                let entity = UserDefinedCurveFont::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<UserDefinedCurveFont>(),
                    Box::new(entity),
                ))
            }
            "USER_DEFINED_MARKER" => {
                let entity = UserDefinedMarker::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<UserDefinedMarker>(),
                    Box::new(entity),
                ))
            }
            "USER_DEFINED_TERMINATOR_SYMBOL" => {
                let entity = UserDefinedTerminatorSymbol::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<UserDefinedTerminatorSymbol>(),
                    Box::new(entity),
                ))
            }
            "USER_SELECTED_ELEMENTS" => {
                let entity = UserSelectedElements::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<UserSelectedElements>(),
                    Box::new(entity),
                ))
            }
            "USER_SELECTED_SHAPE_ELEMENTS" => {
                let entity = UserSelectedShapeElements::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<UserSelectedShapeElements>(),
                    Box::new(entity),
                ))
            }
            "VALUE_RANGE" => {
                let entity = ValueRange::form_parameters(typed_parameter.parameters);
                Some((entity.type_id(), std::any::type_name::<ValueRange>(), Box::new(entity)))
            }
            "VALUE_REPRESENTATION_ITEM" => {
                let entity = ValueRepresentationItem::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<ValueRepresentationItem>(),
                    Box::new(entity),
                ))
            }
            "VECTOR" => {
                let entity = Vector::form_parameters(typed_parameter.parameters);
                Some((entity.type_id(), std::any::type_name::<Vector>(), Box::new(entity)))
            }
            "VECTOR_STYLE" => {
                let entity = VectorStyle::form_parameters(typed_parameter.parameters);
                Some((entity.type_id(), std::any::type_name::<VectorStyle>(), Box::new(entity)))
            }
            "VELOCITY_MEASURE_WITH_UNIT" => {
                let entity = VelocityMeasureWithUnit::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<VelocityMeasureWithUnit>(),
                    Box::new(entity),
                ))
            }
            "VELOCITY_UNIT" => {
                let entity = VelocityUnit::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<VelocityUnit>(),
                    Box::new(entity),
                ))
            }
            "VERSIONED_ACTION_REQUEST" => {
                let entity = VersionedActionRequest::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<VersionedActionRequest>(),
                    Box::new(entity),
                ))
            }
            "VERTEX" => {
                let entity = Vertex::form_parameters(typed_parameter.parameters);
                Some((entity.type_id(), std::any::type_name::<Vertex>(), Box::new(entity)))
            }
            "VERTEX_LOOP" => {
                let entity = VertexLoop::form_parameters(typed_parameter.parameters);
                Some((entity.type_id(), std::any::type_name::<VertexLoop>(), Box::new(entity)))
            }
            "VERTEX_POINT" => {
                let entity = VertexPoint::form_parameters(typed_parameter.parameters);
                Some((entity.type_id(), std::any::type_name::<VertexPoint>(), Box::new(entity)))
            }
            "VERTEX_SHELL" => {
                let entity = VertexShell::form_parameters(typed_parameter.parameters);
                Some((entity.type_id(), std::any::type_name::<VertexShell>(), Box::new(entity)))
            }
            "VIEW_DEPENDENT_ANNOTATION_REPRESENTATION" => {
                let entity = ViewDependentAnnotationRepresentation::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<ViewDependentAnnotationRepresentation>(),
                    Box::new(entity),
                ))
            }
            "VIEW_VOLUME" => {
                let entity = ViewVolume::form_parameters(typed_parameter.parameters);
                Some((entity.type_id(), std::any::type_name::<ViewVolume>(), Box::new(entity)))
            }
            "VISUAL_APPEARANCE_REPRESENTATION" => {
                let entity = VisualAppearanceRepresentation::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<VisualAppearanceRepresentation>(),
                    Box::new(entity),
                ))
            }
            "VOLUME_MEASURE_WITH_UNIT" => {
                let entity = VolumeMeasureWithUnit::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<VolumeMeasureWithUnit>(),
                    Box::new(entity),
                ))
            }
            "VOLUME_UNIT" => {
                let entity = VolumeUnit::form_parameters(typed_parameter.parameters);
                Some((entity.type_id(), std::any::type_name::<VolumeUnit>(), Box::new(entity)))
            }
            "WEEK_OF_YEAR_AND_DAY_DATE" => {
                let entity = WeekOfYearAndDayDate::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<WeekOfYearAndDayDate>(),
                    Box::new(entity),
                ))
            }
            "WIRE_SHELL" => {
                let entity = WireShell::form_parameters(typed_parameter.parameters);
                Some((entity.type_id(), std::any::type_name::<WireShell>(), Box::new(entity)))
            }
            "YEAR_MONTH" => {
                let entity = YearMonth::form_parameters(typed_parameter.parameters);
                Some((entity.type_id(), std::any::type_name::<YearMonth>(), Box::new(entity)))
            }
            "ZONE_STRUCTURAL_MAKEUP" => {
                let entity = ZoneStructuralMakeup::form_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<ZoneStructuralMakeup>(),
                    Box::new(entity),
                ))
            }
            _ => {
                println!("{} is not implemented", typed_parameter.type_name);
                None
            }
        }
    }
}
