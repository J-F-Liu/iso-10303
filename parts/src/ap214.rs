#![doc = r" This file is generated. Do not edit."]
#![allow(dead_code)]
use iso_10303::step::*;
use std::collections::HashSet;
#[derive(Default, Debug)]
pub struct Unimplemented {}
impl From<Parameter> for Unimplemented {
    fn from(_parameter: Parameter) -> Self {
        Unimplemented {}
    }
}
#[derive(Eq, PartialEq, Hash, Debug)]
pub enum ActionItem {
    EntityRef(EntityRef),
    Action(EntityRef),
    ActionDirective(EntityRef),
    ActionMethod(EntityRef),
    ActionProperty(EntityRef),
    ActionRelationship(EntityRef),
    ActionRequestSolution(EntityRef),
    AlternateProductRelationship(EntityRef),
    AppliedActionAssignment(EntityRef),
    AppliedClassificationAssignment(EntityRef),
    AppliedPersonAndOrganizationAssignment(EntityRef),
    ApprovalStatus(EntityRef),
    AssemblyComponentUsageSubstitute(EntityRef),
    Certification(EntityRef),
    Class(EntityRef),
    ClassSystem(EntityRef),
    ConfigurationDesign(EntityRef),
    ConfigurationEffectivity(EntityRef),
    ConfigurationItem(EntityRef),
    ConfiguredEffectivityAssignment(EntityRef),
    Contract(EntityRef),
    DocumentFile(EntityRef),
    DraughtingModel(EntityRef),
    DrawingRevision(EntityRef),
    ExecutedAction(EntityRef),
    GeneralProperty(EntityRef),
    MaterialDesignation(EntityRef),
    MechanicalDesignGeometricPresentationRepresentation(EntityRef),
    OrganizationRelationship(EntityRef),
    OrganizationalProject(EntityRef),
    PersonAndOrganization(EntityRef),
    PresentationArea(EntityRef),
    Product(EntityRef),
    ProductConcept(EntityRef),
    ProductConceptFeature(EntityRef),
    ProductConceptFeatureAssociation(EntityRef),
    ProductConceptFeatureCategory(EntityRef),
    ProductConceptFeatureCategoryUsage(EntityRef),
    ProductDefinition(EntityRef),
    ProductDefinitionFormation(EntityRef),
    ProductDefinitionFormationRelationship(EntityRef),
    ProductDefinitionRelationship(EntityRef),
    ProductDefinitionSubstitute(EntityRef),
    PropertyDefinition(EntityRef),
    RequirementForActionResource(EntityRef),
    ResourceProperty(EntityRef),
    SecurityClassification(EntityRef),
    SecurityClassificationLevel(EntityRef),
    ShapeAspect(EntityRef),
    ShapeRepresentation(EntityRef),
    VersionedActionRequest(EntityRef),
}
impl Default for ActionItem {
    fn default() -> Self {
        ActionItem::Action(EntityRef::default())
    }
}
impl From<Parameter> for ActionItem {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EntityRef(id) => ActionItem::EntityRef(EntityRef(id)),
                _ => panic!("parameter is not an instance"),
            },
            _ => panic!("parameter is not recognized"),
        }
    }
}
#[derive(Eq, PartialEq, Hash, Debug)]
pub enum ActionRequestItem {
    EntityRef(EntityRef),
    Action(EntityRef),
    ActionMethod(EntityRef),
    ActionProperty(EntityRef),
    ActionRelationship(EntityRef),
    AlternateProductRelationship(EntityRef),
    AssemblyComponentUsageSubstitute(EntityRef),
    ConfigurationDesign(EntityRef),
    ConfigurationEffectivity(EntityRef),
    ConfigurationItem(EntityRef),
    ConfiguredEffectivityAssignment(EntityRef),
    DocumentFile(EntityRef),
    DraughtingModel(EntityRef),
    DrawingRevision(EntityRef),
    GeneralProperty(EntityRef),
    MaterialDesignation(EntityRef),
    MechanicalDesignGeometricPresentationRepresentation(EntityRef),
    OrganizationalProject(EntityRef),
    PresentationArea(EntityRef),
    Product(EntityRef),
    ProductConcept(EntityRef),
    ProductConceptFeature(EntityRef),
    ProductConceptFeatureAssociation(EntityRef),
    ProductConceptFeatureCategory(EntityRef),
    ProductConceptFeatureCategoryUsage(EntityRef),
    ProductDefinition(EntityRef),
    ProductDefinitionFormation(EntityRef),
    ProductDefinitionRelationship(EntityRef),
    ProductDefinitionSubstitute(EntityRef),
    PropertyDefinition(EntityRef),
    ResourceProperty(EntityRef),
    ShapeAspect(EntityRef),
    ShapeRepresentation(EntityRef),
}
impl Default for ActionRequestItem {
    fn default() -> Self {
        ActionRequestItem::Action(EntityRef::default())
    }
}
impl From<Parameter> for ActionRequestItem {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EntityRef(id) => ActionRequestItem::EntityRef(EntityRef(id)),
                _ => panic!("parameter is not an instance"),
            },
            _ => panic!("parameter is not recognized"),
        }
    }
}
#[derive(Eq, PartialEq, Hash, Debug)]
pub enum AheadOrBehind {
    Ahead,
    Exact,
    Behind,
}
impl Default for AheadOrBehind {
    fn default() -> Self {
        AheadOrBehind::Ahead
    }
}
impl From<String> for AheadOrBehind {
    fn from(value: String) -> Self {
        match value.as_str() {
            "AHEAD" => AheadOrBehind::Ahead,
            "EXACT" => AheadOrBehind::Exact,
            "BEHIND" => AheadOrBehind::Behind,
            _ => panic!("{} is not a valid value", value),
        }
    }
}
impl From<Parameter> for AheadOrBehind {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EnumValue(value) => value.into(),
                _ => panic!("parameter is not an enum value"),
            },
            Parameter::OmittedParameter => AheadOrBehind::default(),
            _ => panic!("parameter is not an enum value"),
        }
    }
}
type AmountOfSubstanceMeasure = Real;
#[derive(Eq, PartialEq, Hash, Debug)]
pub enum AngleRelator {
    Equal,
    Large,
    Small,
}
impl Default for AngleRelator {
    fn default() -> Self {
        AngleRelator::Equal
    }
}
impl From<String> for AngleRelator {
    fn from(value: String) -> Self {
        match value.as_str() {
            "EQUAL" => AngleRelator::Equal,
            "LARGE" => AngleRelator::Large,
            "SMALL" => AngleRelator::Small,
            _ => panic!("{} is not a valid value", value),
        }
    }
}
impl From<Parameter> for AngleRelator {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EnumValue(value) => value.into(),
                _ => panic!("parameter is not an enum value"),
            },
            Parameter::OmittedParameter => AngleRelator::default(),
            _ => panic!("parameter is not an enum value"),
        }
    }
}
#[derive(Eq, PartialEq, Hash, Debug)]
pub enum AnnotationPlaneElement {
    EntityRef(EntityRef),
    DraughtingCallout(EntityRef),
    StyledItem(EntityRef),
}
impl Default for AnnotationPlaneElement {
    fn default() -> Self {
        AnnotationPlaneElement::DraughtingCallout(EntityRef::default())
    }
}
impl From<Parameter> for AnnotationPlaneElement {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EntityRef(id) => AnnotationPlaneElement::EntityRef(EntityRef(id)),
                _ => panic!("parameter is not an instance"),
            },
            _ => panic!("parameter is not recognized"),
        }
    }
}
#[derive(Debug)]
pub enum AnnotationSymbolOccurrenceItem {
    EntityRef(EntityRef),
    AnnotationSymbol(EntityRef),
    DefinedSymbol(EntityRef),
}
impl Default for AnnotationSymbolOccurrenceItem {
    fn default() -> Self {
        AnnotationSymbolOccurrenceItem::AnnotationSymbol(EntityRef::default())
    }
}
impl From<Parameter> for AnnotationSymbolOccurrenceItem {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EntityRef(id) => AnnotationSymbolOccurrenceItem::EntityRef(EntityRef(id)),
                _ => panic!("parameter is not an instance"),
            },
            _ => panic!("parameter is not recognized"),
        }
    }
}
#[derive(Debug)]
pub enum AnnotationTextOccurrenceItem {
    EntityRef(EntityRef),
    TextLiteral(EntityRef),
    AnnotationText(EntityRef),
    AnnotationTextCharacter(EntityRef),
    DefinedCharacterGlyph(EntityRef),
    CompositeText(EntityRef),
}
impl Default for AnnotationTextOccurrenceItem {
    fn default() -> Self {
        AnnotationTextOccurrenceItem::TextLiteral(EntityRef::default())
    }
}
impl From<Parameter> for AnnotationTextOccurrenceItem {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EntityRef(id) => AnnotationTextOccurrenceItem::EntityRef(EntityRef(id)),
                _ => panic!("parameter is not an instance"),
            },
            _ => panic!("parameter is not recognized"),
        }
    }
}
#[derive(Eq, PartialEq, Hash, Debug)]
pub enum ApprovalItem {
    EntityRef(EntityRef),
    Action(EntityRef),
    ActionDirective(EntityRef),
    ActionProperty(EntityRef),
    ActionRequestSolution(EntityRef),
    AlternateProductRelationship(EntityRef),
    AppliedActionAssignment(EntityRef),
    AppliedClassificationAssignment(EntityRef),
    AssemblyComponentUsageSubstitute(EntityRef),
    Certification(EntityRef),
    Class(EntityRef),
    ClassSystem(EntityRef),
    ConfigurationDesign(EntityRef),
    ConfigurationEffectivity(EntityRef),
    ConfiguredEffectivityAssignment(EntityRef),
    Contract(EntityRef),
    DocumentFile(EntityRef),
    DraughtingModel(EntityRef),
    DrawingRevision(EntityRef),
    ExecutedAction(EntityRef),
    GeneralProperty(EntityRef),
    MaterialDesignation(EntityRef),
    MechanicalDesignGeometricPresentationRepresentation(EntityRef),
    OrganizationalProject(EntityRef),
    PresentationArea(EntityRef),
    Product(EntityRef),
    ProductConcept(EntityRef),
    ProductConceptFeature(EntityRef),
    ProductConceptFeatureAssociation(EntityRef),
    ProductConceptFeatureCategory(EntityRef),
    ProductConceptFeatureCategoryUsage(EntityRef),
    ProductDefinition(EntityRef),
    ProductDefinitionFormation(EntityRef),
    ProductDefinitionRelationship(EntityRef),
    ProductDefinitionSubstitute(EntityRef),
    PropertyDefinition(EntityRef),
    ResourceProperty(EntityRef),
    ShapeRepresentation(EntityRef),
    VersionedActionRequest(EntityRef),
}
impl Default for ApprovalItem {
    fn default() -> Self {
        ApprovalItem::Action(EntityRef::default())
    }
}
impl From<Parameter> for ApprovalItem {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EntityRef(id) => ApprovalItem::EntityRef(EntityRef(id)),
                _ => panic!("parameter is not an instance"),
            },
            _ => panic!("parameter is not recognized"),
        }
    }
}
#[derive(Eq, PartialEq, Hash, Debug)]
pub enum ApproximationMethod {
    ChordalDeviation,
    ChordalLength,
}
impl Default for ApproximationMethod {
    fn default() -> Self {
        ApproximationMethod::ChordalDeviation
    }
}
impl From<String> for ApproximationMethod {
    fn from(value: String) -> Self {
        match value.as_str() {
            "CHORDAL_DEVIATION" => ApproximationMethod::ChordalDeviation,
            "CHORDAL_LENGTH" => ApproximationMethod::ChordalLength,
            _ => panic!("{} is not a valid value", value),
        }
    }
}
impl From<Parameter> for ApproximationMethod {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EnumValue(value) => value.into(),
                _ => panic!("parameter is not an enum value"),
            },
            Parameter::OmittedParameter => ApproximationMethod::default(),
            _ => panic!("parameter is not an enum value"),
        }
    }
}
type AreaMeasure = Real;
#[derive(Debug)]
pub enum AreaOrView {
    EntityRef(EntityRef),
    PresentationArea(EntityRef),
    PresentationView(EntityRef),
}
impl Default for AreaOrView {
    fn default() -> Self {
        AreaOrView::PresentationArea(EntityRef::default())
    }
}
impl From<Parameter> for AreaOrView {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EntityRef(id) => AreaOrView::EntityRef(EntityRef(id)),
                _ => panic!("parameter is not an instance"),
            },
            _ => panic!("parameter is not recognized"),
        }
    }
}
#[derive(Eq, PartialEq, Hash, Debug)]
pub enum AttributeLanguageItem {
    EntityRef(EntityRef),
    Action(EntityRef),
    ActionDirective(EntityRef),
    ActionMethod(EntityRef),
    ActionProperty(EntityRef),
    ActionRelationship(EntityRef),
    AlternateProductRelationship(EntityRef),
    ApplicationContext(EntityRef),
    ApprovalRelationship(EntityRef),
    AssemblyComponentUsageSubstitute(EntityRef),
    AttributeValueAssignment(EntityRef),
    Certification(EntityRef),
    ConfigurationDesign(EntityRef),
    ConfigurationItem(EntityRef),
    Contract(EntityRef),
    DataEnvironment(EntityRef),
    DateRole(EntityRef),
    DateTimeRole(EntityRef),
    DescriptiveRepresentationItem(EntityRef),
    DocumentRelationship(EntityRef),
    DraughtingTitle(EntityRef),
    Effectivity(EntityRef),
    EffectivityRelationship(EntityRef),
    EventOccurrence(EntityRef),
    ExternalSource(EntityRef),
    GeneralProperty(EntityRef),
    GeneralPropertyRelationship(EntityRef),
    GeometricRepresentationItem(EntityRef),
    GeometricTolerance(EntityRef),
    Group(EntityRef),
    GroupRelationship(EntityRef),
    IdentificationRole(EntityRef),
    KinematicPair(EntityRef),
    MappedItem(EntityRef),
    NameAssignment(EntityRef),
    OrganizationRelationship(EntityRef),
    OrganizationRole(EntityRef),
    OrganizationalProject(EntityRef),
    OrganizationalProjectRelationship(EntityRef),
    PairActuator(EntityRef),
    PersonAndOrganizationRole(EntityRef),
    PresentationLayerAssignment(EntityRef),
    ProcessProductAssociation(EntityRef),
    Product(EntityRef),
    ProductConcept(EntityRef),
    ProductConceptFeature(EntityRef),
    ProductConceptFeatureAssociation(EntityRef),
    ProductConceptRelationship(EntityRef),
    ProductDefinition(EntityRef),
    ProductDefinitionFormation(EntityRef),
    ProductDefinitionFormationRelationship(EntityRef),
    ProductDefinitionRelationship(EntityRef),
    ProductDefinitionSubstitute(EntityRef),
    ProductRelatedProductCategory(EntityRef),
    PropertyDefinition(EntityRef),
    PropertyDefinitionRelationship(EntityRef),
    Representation(EntityRef),
    RepresentationRelationship(EntityRef),
    RequirementForActionResource(EntityRef),
    ResourceProperty(EntityRef),
    ResourceRequirementType(EntityRef),
    SecurityClassification(EntityRef),
    ShapeAspect(EntityRef),
    ShapeAspectRelationship(EntityRef),
    StyledItem(EntityRef),
    TimeIntervalRole(EntityRef),
    TopologicalRepresentationItem(EntityRef),
    UncertaintyMeasureWithUnit(EntityRef),
    UncertaintyQualifier(EntityRef),
    VersionedActionRequest(EntityRef),
    VersionedActionRequestRelationship(EntityRef),
}
impl Default for AttributeLanguageItem {
    fn default() -> Self {
        AttributeLanguageItem::Action(EntityRef::default())
    }
}
impl From<Parameter> for AttributeLanguageItem {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EntityRef(id) => AttributeLanguageItem::EntityRef(EntityRef(id)),
                _ => panic!("parameter is not an instance"),
            },
            _ => panic!("parameter is not recognized"),
        }
    }
}
#[derive(Debug)]
pub enum AttributeType {
    Label(Label),
    Text(Text),
}
impl Default for AttributeType {
    fn default() -> Self {
        AttributeType::Label(Label::default())
    }
}
impl From<Parameter> for AttributeType {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::TypedParameter(typed_parameter) => match typed_parameter.type_name.as_str() {
                "LABEL" => AttributeType::Label(typed_parameter.parameters.into_iter().next().unwrap().into()),
                "TEXT" => AttributeType::Text(typed_parameter.parameters.into_iter().next().unwrap().into()),
                _ => panic!("parameter type is not recognized: {}", typed_parameter.type_name),
            },
            _ => panic!("parameter is not recognized"),
        }
    }
}
#[derive(Eq, PartialEq, Hash, Debug)]
pub enum Axis2Placement {
    EntityRef(EntityRef),
    Axis2Placement2d(EntityRef),
    Axis2Placement3d(EntityRef),
}
impl Default for Axis2Placement {
    fn default() -> Self {
        Axis2Placement::Axis2Placement2d(EntityRef::default())
    }
}
impl From<Parameter> for Axis2Placement {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EntityRef(id) => Axis2Placement::EntityRef(EntityRef(id)),
                _ => panic!("parameter is not an instance"),
            },
            _ => panic!("parameter is not recognized"),
        }
    }
}
#[derive(Eq, PartialEq, Hash, Debug)]
pub enum BSplineCurveForm {
    PolylineForm,
    CircularArc,
    EllipticArc,
    ParabolicArc,
    HyperbolicArc,
    Unspecified,
}
impl Default for BSplineCurveForm {
    fn default() -> Self {
        BSplineCurveForm::PolylineForm
    }
}
impl From<String> for BSplineCurveForm {
    fn from(value: String) -> Self {
        match value.as_str() {
            "POLYLINE_FORM" => BSplineCurveForm::PolylineForm,
            "CIRCULAR_ARC" => BSplineCurveForm::CircularArc,
            "ELLIPTIC_ARC" => BSplineCurveForm::EllipticArc,
            "PARABOLIC_ARC" => BSplineCurveForm::ParabolicArc,
            "HYPERBOLIC_ARC" => BSplineCurveForm::HyperbolicArc,
            "UNSPECIFIED" => BSplineCurveForm::Unspecified,
            _ => panic!("{} is not a valid value", value),
        }
    }
}
impl From<Parameter> for BSplineCurveForm {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EnumValue(value) => value.into(),
                _ => panic!("parameter is not an enum value"),
            },
            Parameter::OmittedParameter => BSplineCurveForm::default(),
            _ => panic!("parameter is not an enum value"),
        }
    }
}
#[derive(Eq, PartialEq, Hash, Debug)]
pub enum BSplineSurfaceForm {
    PlaneSurf,
    CylindricalSurf,
    ConicalSurf,
    SphericalSurf,
    ToroidalSurf,
    SurfOfRevolution,
    RuledSurf,
    GeneralisedCone,
    QuadricSurf,
    SurfOfLinearExtrusion,
    Unspecified,
}
impl Default for BSplineSurfaceForm {
    fn default() -> Self {
        BSplineSurfaceForm::PlaneSurf
    }
}
impl From<String> for BSplineSurfaceForm {
    fn from(value: String) -> Self {
        match value.as_str() {
            "PLANE_SURF" => BSplineSurfaceForm::PlaneSurf,
            "CYLINDRICAL_SURF" => BSplineSurfaceForm::CylindricalSurf,
            "CONICAL_SURF" => BSplineSurfaceForm::ConicalSurf,
            "SPHERICAL_SURF" => BSplineSurfaceForm::SphericalSurf,
            "TOROIDAL_SURF" => BSplineSurfaceForm::ToroidalSurf,
            "SURF_OF_REVOLUTION" => BSplineSurfaceForm::SurfOfRevolution,
            "RULED_SURF" => BSplineSurfaceForm::RuledSurf,
            "GENERALISED_CONE" => BSplineSurfaceForm::GeneralisedCone,
            "QUADRIC_SURF" => BSplineSurfaceForm::QuadricSurf,
            "SURF_OF_LINEAR_EXTRUSION" => BSplineSurfaceForm::SurfOfLinearExtrusion,
            "UNSPECIFIED" => BSplineSurfaceForm::Unspecified,
            _ => panic!("{} is not a valid value", value),
        }
    }
}
impl From<Parameter> for BSplineSurfaceForm {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EnumValue(value) => value.into(),
                _ => panic!("parameter is not an enum value"),
            },
            Parameter::OmittedParameter => BSplineSurfaceForm::default(),
            _ => panic!("parameter is not an enum value"),
        }
    }
}
#[derive(Debug)]
pub enum BooleanOperand {
    EntityRef(EntityRef),
    SolidModel(EntityRef),
    HalfSpaceSolid(EntityRef),
    CsgPrimitive(CsgPrimitive),
    BooleanResult(EntityRef),
}
impl Default for BooleanOperand {
    fn default() -> Self {
        BooleanOperand::SolidModel(EntityRef::default())
    }
}
impl From<Parameter> for BooleanOperand {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::TypedParameter(typed_parameter) => match typed_parameter.type_name.as_str() {
                "CSG_PRIMITIVE" => {
                    BooleanOperand::CsgPrimitive(typed_parameter.parameters.into_iter().next().unwrap().into())
                }
                _ => panic!("parameter type is not recognized: {}", typed_parameter.type_name),
            },
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EntityRef(id) => BooleanOperand::EntityRef(EntityRef(id)),
                _ => panic!("parameter is not an instance"),
            },
            _ => panic!("parameter is not recognized"),
        }
    }
}
#[derive(Eq, PartialEq, Hash, Debug)]
pub enum BooleanOperator {
    Union,
    Intersection,
    Difference,
}
impl Default for BooleanOperator {
    fn default() -> Self {
        BooleanOperator::Union
    }
}
impl From<String> for BooleanOperator {
    fn from(value: String) -> Self {
        match value.as_str() {
            "UNION" => BooleanOperator::Union,
            "INTERSECTION" => BooleanOperator::Intersection,
            "DIFFERENCE" => BooleanOperator::Difference,
            _ => panic!("{} is not a valid value", value),
        }
    }
}
impl From<Parameter> for BooleanOperator {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EnumValue(value) => value.into(),
                _ => panic!("parameter is not an enum value"),
            },
            Parameter::OmittedParameter => BooleanOperator::default(),
            _ => panic!("parameter is not an enum value"),
        }
    }
}
#[derive(Eq, PartialEq, Hash, Debug)]
pub enum BoxCharacteristicSelect {
    BoxHeight(BoxHeight),
    BoxWidth(BoxWidth),
    BoxSlantAngle(BoxSlantAngle),
    BoxRotateAngle(BoxRotateAngle),
}
impl Default for BoxCharacteristicSelect {
    fn default() -> Self {
        BoxCharacteristicSelect::BoxHeight(BoxHeight::default())
    }
}
impl From<Parameter> for BoxCharacteristicSelect {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::TypedParameter(typed_parameter) => match typed_parameter.type_name.as_str() {
                "BOX_HEIGHT" => {
                    BoxCharacteristicSelect::BoxHeight(typed_parameter.parameters.into_iter().next().unwrap().into())
                }
                "BOX_WIDTH" => {
                    BoxCharacteristicSelect::BoxWidth(typed_parameter.parameters.into_iter().next().unwrap().into())
                }
                "BOX_SLANT_ANGLE" => BoxCharacteristicSelect::BoxSlantAngle(
                    typed_parameter.parameters.into_iter().next().unwrap().into(),
                ),
                "BOX_ROTATE_ANGLE" => BoxCharacteristicSelect::BoxRotateAngle(
                    typed_parameter.parameters.into_iter().next().unwrap().into(),
                ),
                _ => panic!("parameter type is not recognized: {}", typed_parameter.type_name),
            },
            _ => panic!("parameter is not recognized"),
        }
    }
}
type BoxHeight = PositiveRatioMeasure;
type BoxRotateAngle = PlaneAngleMeasure;
type BoxSlantAngle = PlaneAngleMeasure;
type BoxWidth = PositiveRatioMeasure;
#[derive(Eq, PartialEq, Hash, Debug)]
pub enum CategoryUsageItem {
    ProductClass(EntityRef),
}
impl Default for CategoryUsageItem {
    fn default() -> Self {
        CategoryUsageItem::ProductClass(EntityRef::default())
    }
}
impl From<Parameter> for CategoryUsageItem {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EntityRef(id) => CategoryUsageItem::ProductClass(EntityRef(id)),
                _ => panic!("parameter is not an instance"),
            },
            _ => panic!("parameter is not recognized"),
        }
    }
}
type CelsiusTemperatureMeasure = Real;
#[derive(Eq, PartialEq, Hash, Debug)]
pub enum CentralOrParallel {
    Central,
    Parallel,
}
impl Default for CentralOrParallel {
    fn default() -> Self {
        CentralOrParallel::Central
    }
}
impl From<String> for CentralOrParallel {
    fn from(value: String) -> Self {
        match value.as_str() {
            "CENTRAL" => CentralOrParallel::Central,
            "PARALLEL" => CentralOrParallel::Parallel,
            _ => panic!("{} is not a valid value", value),
        }
    }
}
impl From<Parameter> for CentralOrParallel {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EnumValue(value) => value.into(),
                _ => panic!("parameter is not an enum value"),
            },
            Parameter::OmittedParameter => CentralOrParallel::default(),
            _ => panic!("parameter is not an enum value"),
        }
    }
}
#[derive(Eq, PartialEq, Hash, Debug)]
pub enum CertificationItem {
    EntityRef(EntityRef),
    ProductDefinition(EntityRef),
    ProductDefinitionFormation(EntityRef),
    ProductDefinitionFormationRelationship(EntityRef),
    ProductDefinitionRelationship(EntityRef),
}
impl Default for CertificationItem {
    fn default() -> Self {
        CertificationItem::ProductDefinition(EntityRef::default())
    }
}
impl From<Parameter> for CertificationItem {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EntityRef(id) => CertificationItem::EntityRef(EntityRef(id)),
                _ => panic!("parameter is not an instance"),
            },
            _ => panic!("parameter is not recognized"),
        }
    }
}
#[derive(Debug)]
pub enum CharacterSpacingSelect {
    LengthMeasure(LengthMeasure),
    RatioMeasure(RatioMeasure),
    MeasureWithUnit(EntityRef),
    DescriptiveMeasure(DescriptiveMeasure),
}
impl Default for CharacterSpacingSelect {
    fn default() -> Self {
        CharacterSpacingSelect::LengthMeasure(LengthMeasure::default())
    }
}
impl From<Parameter> for CharacterSpacingSelect {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::TypedParameter(typed_parameter) => match typed_parameter.type_name.as_str() {
                "LENGTH_MEASURE" => {
                    CharacterSpacingSelect::LengthMeasure(typed_parameter.parameters.into_iter().next().unwrap().into())
                }
                "RATIO_MEASURE" => {
                    CharacterSpacingSelect::RatioMeasure(typed_parameter.parameters.into_iter().next().unwrap().into())
                }
                "DESCRIPTIVE_MEASURE" => CharacterSpacingSelect::DescriptiveMeasure(
                    typed_parameter.parameters.into_iter().next().unwrap().into(),
                ),
                _ => panic!("parameter type is not recognized: {}", typed_parameter.type_name),
            },
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EntityRef(id) => CharacterSpacingSelect::MeasureWithUnit(EntityRef(id)),
                _ => panic!("parameter is not an instance"),
            },
            _ => panic!("parameter is not recognized"),
        }
    }
}
#[derive(Debug)]
pub enum CharacterStyleSelect {
    TextStyleForDefinedFont(EntityRef),
}
impl Default for CharacterStyleSelect {
    fn default() -> Self {
        CharacterStyleSelect::TextStyleForDefinedFont(EntityRef::default())
    }
}
impl From<Parameter> for CharacterStyleSelect {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EntityRef(id) => CharacterStyleSelect::TextStyleForDefinedFont(EntityRef(id)),
                _ => panic!("parameter is not an instance"),
            },
            _ => panic!("parameter is not recognized"),
        }
    }
}
#[derive(Eq, PartialEq, Hash, Debug)]
pub enum CharacterizedActionDefinition {
    EntityRef(EntityRef),
    Action(EntityRef),
    ActionMethod(EntityRef),
    ActionMethodRelationship(EntityRef),
    ActionRelationship(EntityRef),
}
impl Default for CharacterizedActionDefinition {
    fn default() -> Self {
        CharacterizedActionDefinition::Action(EntityRef::default())
    }
}
impl From<Parameter> for CharacterizedActionDefinition {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EntityRef(id) => CharacterizedActionDefinition::EntityRef(EntityRef(id)),
                _ => panic!("parameter is not an instance"),
            },
            _ => panic!("parameter is not recognized"),
        }
    }
}
#[derive(Eq, PartialEq, Hash, Debug)]
pub enum CharacterizedDefinition {
    CharacterizedObject(EntityRef),
    CharacterizedProductDefinition(CharacterizedProductDefinition),
    ShapeDefinition(ShapeDefinition),
}
impl Default for CharacterizedDefinition {
    fn default() -> Self {
        CharacterizedDefinition::CharacterizedObject(EntityRef::default())
    }
}
impl From<Parameter> for CharacterizedDefinition {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::TypedParameter(typed_parameter) => match typed_parameter.type_name.as_str() {
                "CHARACTERIZED_PRODUCT_DEFINITION" => CharacterizedDefinition::CharacterizedProductDefinition(
                    typed_parameter.parameters.into_iter().next().unwrap().into(),
                ),
                "SHAPE_DEFINITION" => CharacterizedDefinition::ShapeDefinition(
                    typed_parameter.parameters.into_iter().next().unwrap().into(),
                ),
                _ => panic!("parameter type is not recognized: {}", typed_parameter.type_name),
            },
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EntityRef(id) => CharacterizedDefinition::CharacterizedObject(EntityRef(id)),
                _ => panic!("parameter is not an instance"),
            },
            _ => panic!("parameter is not recognized"),
        }
    }
}
#[derive(Debug)]
pub enum CharacterizedMaterialProperty {
    MaterialPropertyRepresentation(EntityRef),
}
impl Default for CharacterizedMaterialProperty {
    fn default() -> Self {
        CharacterizedMaterialProperty::MaterialPropertyRepresentation(EntityRef::default())
    }
}
impl From<Parameter> for CharacterizedMaterialProperty {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EntityRef(id) => {
                    CharacterizedMaterialProperty::MaterialPropertyRepresentation(EntityRef(id))
                }
                _ => panic!("parameter is not an instance"),
            },
            _ => panic!("parameter is not recognized"),
        }
    }
}
#[derive(Eq, PartialEq, Hash, Debug)]
pub enum CharacterizedProductDefinition {
    EntityRef(EntityRef),
    ProductDefinition(EntityRef),
    ProductDefinitionRelationship(EntityRef),
}
impl Default for CharacterizedProductDefinition {
    fn default() -> Self {
        CharacterizedProductDefinition::ProductDefinition(EntityRef::default())
    }
}
impl From<Parameter> for CharacterizedProductDefinition {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EntityRef(id) => CharacterizedProductDefinition::EntityRef(EntityRef(id)),
                _ => panic!("parameter is not an instance"),
            },
            _ => panic!("parameter is not recognized"),
        }
    }
}
#[derive(Debug)]
pub enum CharacterizedResourceDefinition {
    EntityRef(EntityRef),
    ActionResource(EntityRef),
    ActionResourceRequirement(EntityRef),
}
impl Default for CharacterizedResourceDefinition {
    fn default() -> Self {
        CharacterizedResourceDefinition::ActionResource(EntityRef::default())
    }
}
impl From<Parameter> for CharacterizedResourceDefinition {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EntityRef(id) => CharacterizedResourceDefinition::EntityRef(EntityRef(id)),
                _ => panic!("parameter is not an instance"),
            },
            _ => panic!("parameter is not recognized"),
        }
    }
}
#[derive(Eq, PartialEq, Hash, Debug)]
pub enum ClassUsageEffectivityContextItem {
    ProductDefinition(EntityRef),
}
impl Default for ClassUsageEffectivityContextItem {
    fn default() -> Self {
        ClassUsageEffectivityContextItem::ProductDefinition(EntityRef::default())
    }
}
impl From<Parameter> for ClassUsageEffectivityContextItem {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EntityRef(id) => ClassUsageEffectivityContextItem::ProductDefinition(EntityRef(id)),
                _ => panic!("parameter is not an instance"),
            },
            _ => panic!("parameter is not recognized"),
        }
    }
}
#[derive(Eq, PartialEq, Hash, Debug)]
pub enum ClassificationItem {
    EntityRef(EntityRef),
    Action(EntityRef),
    ActionDirective(EntityRef),
    ActionMethod(EntityRef),
    ActionProperty(EntityRef),
    ActionRelationship(EntityRef),
    ApprovalStatus(EntityRef),
    Class(EntityRef),
    ConfigurationItem(EntityRef),
    Contract(EntityRef),
    DescriptiveRepresentationItem(EntityRef),
    DocumentFile(EntityRef),
    DocumentType(EntityRef),
    Effectivity(EntityRef),
    ExecutedAction(EntityRef),
    FeatureDefinition(EntityRef),
    GeneralFeature(EntityRef),
    GeneralProperty(EntityRef),
    MaterialDesignation(EntityRef),
    OrganizationalProject(EntityRef),
    PlusMinusTolerance(EntityRef),
    ProcessOperation(EntityRef),
    Product(EntityRef),
    ProductConcept(EntityRef),
    ProductConceptFeature(EntityRef),
    ProductConceptFeatureCategory(EntityRef),
    ProductDefinition(EntityRef),
    ProductDefinitionFormation(EntityRef),
    ProductDefinitionRelationship(EntityRef),
    PropertyDefinition(EntityRef),
    ResourceProperty(EntityRef),
    SecurityClassificationLevel(EntityRef),
    ShapeAspect(EntityRef),
    VersionedActionRequest(EntityRef),
}
impl Default for ClassificationItem {
    fn default() -> Self {
        ClassificationItem::Action(EntityRef::default())
    }
}
impl From<Parameter> for ClassificationItem {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EntityRef(id) => ClassificationItem::EntityRef(EntityRef(id)),
                _ => panic!("parameter is not an instance"),
            },
            _ => panic!("parameter is not recognized"),
        }
    }
}
#[derive(Debug)]
pub enum CompoundItemDefinition {
    ListRepresentationItem(ListRepresentationItem),
    SetRepresentationItem(SetRepresentationItem),
}
impl Default for CompoundItemDefinition {
    fn default() -> Self {
        CompoundItemDefinition::ListRepresentationItem(ListRepresentationItem::default())
    }
}
impl From<Parameter> for CompoundItemDefinition {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::TypedParameter(typed_parameter) => match typed_parameter.type_name.as_str() {
                "LIST_REPRESENTATION_ITEM" => CompoundItemDefinition::ListRepresentationItem(
                    typed_parameter.parameters.into_iter().next().unwrap().into(),
                ),
                "SET_REPRESENTATION_ITEM" => CompoundItemDefinition::SetRepresentationItem(
                    typed_parameter.parameters.into_iter().next().unwrap().into(),
                ),
                _ => panic!("parameter type is not recognized: {}", typed_parameter.type_name),
            },
            _ => panic!("parameter is not recognized"),
        }
    }
}
#[derive(Debug)]
pub enum ConfigurationDesignItem {
    EntityRef(EntityRef),
    ProductDefinition(EntityRef),
    ProductDefinitionFormation(EntityRef),
}
impl Default for ConfigurationDesignItem {
    fn default() -> Self {
        ConfigurationDesignItem::ProductDefinition(EntityRef::default())
    }
}
impl From<Parameter> for ConfigurationDesignItem {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EntityRef(id) => ConfigurationDesignItem::EntityRef(EntityRef(id)),
                _ => panic!("parameter is not an instance"),
            },
            _ => panic!("parameter is not recognized"),
        }
    }
}
#[derive(Eq, PartialEq, Hash, Debug)]
pub enum ConfiguredEffectivityContextItem {
    ProductConceptFeatureAssociation(EntityRef),
}
impl Default for ConfiguredEffectivityContextItem {
    fn default() -> Self {
        ConfiguredEffectivityContextItem::ProductConceptFeatureAssociation(EntityRef::default())
    }
}
impl From<Parameter> for ConfiguredEffectivityContextItem {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EntityRef(id) => {
                    ConfiguredEffectivityContextItem::ProductConceptFeatureAssociation(EntityRef(id))
                }
                _ => panic!("parameter is not an instance"),
            },
            _ => panic!("parameter is not recognized"),
        }
    }
}
#[derive(Eq, PartialEq, Hash, Debug)]
pub enum ConfiguredEffectivityItem {
    EntityRef(EntityRef),
    ActionRelationship(EntityRef),
    ProcessPlan(EntityRef),
    ProductDefinition(EntityRef),
    ProductProcessPlan(EntityRef),
}
impl Default for ConfiguredEffectivityItem {
    fn default() -> Self {
        ConfiguredEffectivityItem::ActionRelationship(EntityRef::default())
    }
}
impl From<Parameter> for ConfiguredEffectivityItem {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EntityRef(id) => ConfiguredEffectivityItem::EntityRef(EntityRef(id)),
                _ => panic!("parameter is not an instance"),
            },
            _ => panic!("parameter is not recognized"),
        }
    }
}
type ContextDependentMeasure = Real;
#[derive(Eq, PartialEq, Hash, Debug)]
pub enum ContractItem {
    EntityRef(EntityRef),
    DrawingRevision(EntityRef),
    ExecutedAction(EntityRef),
    ProductDefinitionFormation(EntityRef),
}
impl Default for ContractItem {
    fn default() -> Self {
        ContractItem::DrawingRevision(EntityRef::default())
    }
}
impl From<Parameter> for ContractItem {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EntityRef(id) => ContractItem::EntityRef(EntityRef(id)),
                _ => panic!("parameter is not an instance"),
            },
            _ => panic!("parameter is not recognized"),
        }
    }
}
type CountMeasure = Real;
#[derive(Debug)]
pub enum CsgPrimitive {
    EntityRef(EntityRef),
    Sphere(EntityRef),
    Block(EntityRef),
    RightAngularWedge(EntityRef),
    Torus(EntityRef),
    RightCircularCone(EntityRef),
    RightCircularCylinder(EntityRef),
}
impl Default for CsgPrimitive {
    fn default() -> Self {
        CsgPrimitive::Sphere(EntityRef::default())
    }
}
impl From<Parameter> for CsgPrimitive {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EntityRef(id) => CsgPrimitive::EntityRef(EntityRef(id)),
                _ => panic!("parameter is not an instance"),
            },
            _ => panic!("parameter is not recognized"),
        }
    }
}
#[derive(Debug)]
pub enum CsgSelect {
    BooleanResult(EntityRef),
    CsgPrimitive(CsgPrimitive),
}
impl Default for CsgSelect {
    fn default() -> Self {
        CsgSelect::BooleanResult(EntityRef::default())
    }
}
impl From<Parameter> for CsgSelect {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::TypedParameter(typed_parameter) => match typed_parameter.type_name.as_str() {
                "CSG_PRIMITIVE" => {
                    CsgSelect::CsgPrimitive(typed_parameter.parameters.into_iter().next().unwrap().into())
                }
                _ => panic!("parameter type is not recognized: {}", typed_parameter.type_name),
            },
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EntityRef(id) => CsgSelect::BooleanResult(EntityRef(id)),
                _ => panic!("parameter is not an instance"),
            },
            _ => panic!("parameter is not recognized"),
        }
    }
}
#[derive(Debug)]
pub enum CurveFontOrScaledCurveFontSelect {
    CurveStyleFontSelect(CurveStyleFontSelect),
}
impl Default for CurveFontOrScaledCurveFontSelect {
    fn default() -> Self {
        CurveFontOrScaledCurveFontSelect::CurveStyleFontSelect(CurveStyleFontSelect::default())
    }
}
impl From<Parameter> for CurveFontOrScaledCurveFontSelect {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::TypedParameter(typed_parameter) => match typed_parameter.type_name.as_str() {
                "CURVE_STYLE_FONT_SELECT" => CurveFontOrScaledCurveFontSelect::CurveStyleFontSelect(
                    typed_parameter.parameters.into_iter().next().unwrap().into(),
                ),
                _ => panic!("parameter type is not recognized: {}", typed_parameter.type_name),
            },
            _ => panic!("parameter is not recognized"),
        }
    }
}
#[derive(Debug)]
pub enum CurveOnSurface {
    EntityRef(EntityRef),
    Pcurve(EntityRef),
    SurfaceCurve(EntityRef),
    CompositeCurveOnSurface(EntityRef),
}
impl Default for CurveOnSurface {
    fn default() -> Self {
        CurveOnSurface::Pcurve(EntityRef::default())
    }
}
impl From<Parameter> for CurveOnSurface {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EntityRef(id) => CurveOnSurface::EntityRef(EntityRef(id)),
                _ => panic!("parameter is not an instance"),
            },
            _ => panic!("parameter is not recognized"),
        }
    }
}
#[derive(Debug)]
pub enum CurveOrRender {
    EntityRef(EntityRef),
    CurveStyle(EntityRef),
    CurveStyleRendering(EntityRef),
}
impl Default for CurveOrRender {
    fn default() -> Self {
        CurveOrRender::CurveStyle(EntityRef::default())
    }
}
impl From<Parameter> for CurveOrRender {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EntityRef(id) => CurveOrRender::EntityRef(EntityRef(id)),
                _ => panic!("parameter is not an instance"),
            },
            _ => panic!("parameter is not recognized"),
        }
    }
}
#[derive(Debug)]
pub enum CurveStyleFontSelect {
    EntityRef(EntityRef),
    CurveStyleFont(EntityRef),
    PreDefinedCurveFont(EntityRef),
    ExternallyDefinedCurveFont(EntityRef),
}
impl Default for CurveStyleFontSelect {
    fn default() -> Self {
        CurveStyleFontSelect::CurveStyleFont(EntityRef::default())
    }
}
impl From<Parameter> for CurveStyleFontSelect {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EntityRef(id) => CurveStyleFontSelect::EntityRef(EntityRef(id)),
                _ => panic!("parameter is not an instance"),
            },
            _ => panic!("parameter is not recognized"),
        }
    }
}
type CurveToleranceDeviation = PositiveLengthMeasure;
type CurveToleranceParameter = Real;
#[derive(Eq, PartialEq, Hash, Debug)]
pub enum DateAndTimeItem {
    EntityRef(EntityRef),
    Action(EntityRef),
    ActionDirective(EntityRef),
    ActionMethod(EntityRef),
    ActionProperty(EntityRef),
    ActionRelationship(EntityRef),
    ActionRequestSolution(EntityRef),
    AlternateProductRelationship(EntityRef),
    AppliedActionAssignment(EntityRef),
    AppliedClassificationAssignment(EntityRef),
    AppliedOrganizationAssignment(EntityRef),
    AppliedPersonAndOrganizationAssignment(EntityRef),
    ApprovalPersonOrganization(EntityRef),
    ApprovalStatus(EntityRef),
    AssemblyComponentUsageSubstitute(EntityRef),
    Certification(EntityRef),
    Class(EntityRef),
    ClassSystem(EntityRef),
    ConfigurationDesign(EntityRef),
    ConfigurationItem(EntityRef),
    ConfiguredEffectivityAssignment(EntityRef),
    Contract(EntityRef),
    DocumentFile(EntityRef),
    DraughtingModel(EntityRef),
    DrawingRevision(EntityRef),
    Effectivity(EntityRef),
    EventOccurrence(EntityRef),
    ExecutedAction(EntityRef),
    GeneralProperty(EntityRef),
    MaterialDesignation(EntityRef),
    MechanicalDesignGeometricPresentationRepresentation(EntityRef),
    OrganizationRelationship(EntityRef),
    OrganizationalProject(EntityRef),
    PersonAndOrganization(EntityRef),
    PresentationArea(EntityRef),
    Product(EntityRef),
    ProductConcept(EntityRef),
    ProductConceptFeature(EntityRef),
    ProductConceptFeatureAssociation(EntityRef),
    ProductConceptFeatureCategory(EntityRef),
    ProductConceptFeatureCategoryUsage(EntityRef),
    ProductDefinition(EntityRef),
    ProductDefinitionFormation(EntityRef),
    ProductDefinitionFormationRelationship(EntityRef),
    ProductDefinitionRelationship(EntityRef),
    ProductDefinitionSubstitute(EntityRef),
    PropertyDefinition(EntityRef),
    RequirementForActionResource(EntityRef),
    ResourceProperty(EntityRef),
    SecurityClassification(EntityRef),
    SecurityClassificationLevel(EntityRef),
    ShapeRepresentation(EntityRef),
    VersionedActionRequest(EntityRef),
}
impl Default for DateAndTimeItem {
    fn default() -> Self {
        DateAndTimeItem::Action(EntityRef::default())
    }
}
impl From<Parameter> for DateAndTimeItem {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EntityRef(id) => DateAndTimeItem::EntityRef(EntityRef(id)),
                _ => panic!("parameter is not an instance"),
            },
            _ => panic!("parameter is not recognized"),
        }
    }
}
#[derive(Eq, PartialEq, Hash, Debug)]
pub enum DateItem {
    EntityRef(EntityRef),
    Action(EntityRef),
    ActionDirective(EntityRef),
    ActionMethod(EntityRef),
    ActionProperty(EntityRef),
    ActionRelationship(EntityRef),
    ActionRequestSolution(EntityRef),
    AlternateProductRelationship(EntityRef),
    AppliedActionAssignment(EntityRef),
    AppliedClassificationAssignment(EntityRef),
    AppliedOrganizationAssignment(EntityRef),
    AppliedPersonAndOrganizationAssignment(EntityRef),
    ApprovalPersonOrganization(EntityRef),
    ApprovalStatus(EntityRef),
    AssemblyComponentUsageSubstitute(EntityRef),
    Certification(EntityRef),
    Class(EntityRef),
    ClassSystem(EntityRef),
    ConfigurationDesign(EntityRef),
    ConfigurationItem(EntityRef),
    ConfiguredEffectivityAssignment(EntityRef),
    Contract(EntityRef),
    DocumentFile(EntityRef),
    DraughtingModel(EntityRef),
    DrawingRevision(EntityRef),
    Effectivity(EntityRef),
    EventOccurrence(EntityRef),
    ExecutedAction(EntityRef),
    GeneralProperty(EntityRef),
    MaterialDesignation(EntityRef),
    MechanicalDesignGeometricPresentationRepresentation(EntityRef),
    OrganizationRelationship(EntityRef),
    OrganizationalProject(EntityRef),
    PersonAndOrganization(EntityRef),
    PresentationArea(EntityRef),
    Product(EntityRef),
    ProductConcept(EntityRef),
    ProductConceptFeature(EntityRef),
    ProductConceptFeatureAssociation(EntityRef),
    ProductConceptFeatureCategory(EntityRef),
    ProductConceptFeatureCategoryUsage(EntityRef),
    ProductDefinition(EntityRef),
    ProductDefinitionFormation(EntityRef),
    ProductDefinitionFormationRelationship(EntityRef),
    ProductDefinitionRelationship(EntityRef),
    ProductDefinitionSubstitute(EntityRef),
    PropertyDefinition(EntityRef),
    RequirementForActionResource(EntityRef),
    ResourceProperty(EntityRef),
    SecurityClassification(EntityRef),
    SecurityClassificationLevel(EntityRef),
    ShapeRepresentation(EntityRef),
    VersionedActionRequest(EntityRef),
}
impl Default for DateItem {
    fn default() -> Self {
        DateItem::Action(EntityRef::default())
    }
}
impl From<Parameter> for DateItem {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EntityRef(id) => DateItem::EntityRef(EntityRef(id)),
                _ => panic!("parameter is not an instance"),
            },
            _ => panic!("parameter is not recognized"),
        }
    }
}
#[derive(Debug)]
pub enum DateTimeOrEventOccurrence {
    DateTimeSelect(DateTimeSelect),
    EventOccurrence(EntityRef),
}
impl Default for DateTimeOrEventOccurrence {
    fn default() -> Self {
        DateTimeOrEventOccurrence::DateTimeSelect(DateTimeSelect::default())
    }
}
impl From<Parameter> for DateTimeOrEventOccurrence {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::TypedParameter(typed_parameter) => match typed_parameter.type_name.as_str() {
                "DATE_TIME_SELECT" => DateTimeOrEventOccurrence::DateTimeSelect(
                    typed_parameter.parameters.into_iter().next().unwrap().into(),
                ),
                _ => panic!("parameter type is not recognized: {}", typed_parameter.type_name),
            },
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EntityRef(id) => DateTimeOrEventOccurrence::EventOccurrence(EntityRef(id)),
                _ => panic!("parameter is not an instance"),
            },
            _ => panic!("parameter is not recognized"),
        }
    }
}
#[derive(Debug)]
pub enum DateTimeSelect {
    EntityRef(EntityRef),
    Date(EntityRef),
    DateAndTime(EntityRef),
    LocalTime(EntityRef),
}
impl Default for DateTimeSelect {
    fn default() -> Self {
        DateTimeSelect::Date(EntityRef::default())
    }
}
impl From<Parameter> for DateTimeSelect {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EntityRef(id) => DateTimeSelect::EntityRef(EntityRef(id)),
                _ => panic!("parameter is not an instance"),
            },
            _ => panic!("parameter is not recognized"),
        }
    }
}
type DayInMonthNumber = i64;
#[derive(Debug)]
pub enum DefinedGlyphSelect {
    ExternallyDefinedCharacterGlyph(EntityRef),
}
impl Default for DefinedGlyphSelect {
    fn default() -> Self {
        DefinedGlyphSelect::ExternallyDefinedCharacterGlyph(EntityRef::default())
    }
}
impl From<Parameter> for DefinedGlyphSelect {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EntityRef(id) => DefinedGlyphSelect::ExternallyDefinedCharacterGlyph(EntityRef(id)),
                _ => panic!("parameter is not an instance"),
            },
            _ => panic!("parameter is not recognized"),
        }
    }
}
#[derive(Debug)]
pub enum DefinedSymbolSelect {
    EntityRef(EntityRef),
    PreDefinedSymbol(EntityRef),
    ExternallyDefinedSymbol(EntityRef),
}
impl Default for DefinedSymbolSelect {
    fn default() -> Self {
        DefinedSymbolSelect::PreDefinedSymbol(EntityRef::default())
    }
}
impl From<Parameter> for DefinedSymbolSelect {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EntityRef(id) => DefinedSymbolSelect::EntityRef(EntityRef(id)),
                _ => panic!("parameter is not an instance"),
            },
            _ => panic!("parameter is not recognized"),
        }
    }
}
#[derive(Debug)]
pub enum DerivedPropertySelect {
    EntityRef(EntityRef),
    PropertyDefinition(EntityRef),
    ActionProperty(EntityRef),
    ResourceProperty(EntityRef),
}
impl Default for DerivedPropertySelect {
    fn default() -> Self {
        DerivedPropertySelect::PropertyDefinition(EntityRef::default())
    }
}
impl From<Parameter> for DerivedPropertySelect {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EntityRef(id) => DerivedPropertySelect::EntityRef(EntityRef(id)),
                _ => panic!("parameter is not an instance"),
            },
            _ => panic!("parameter is not recognized"),
        }
    }
}
#[derive(Debug)]
pub enum DescriptionAttributeSelect {
    EntityRef(EntityRef),
    ActionRequestSolution(EntityRef),
    ApplicationContext(EntityRef),
    ApprovalRole(EntityRef),
    ConfigurationDesign(EntityRef),
    DateRole(EntityRef),
    DateTimeRole(EntityRef),
    ContextDependentShapeRepresentation(EntityRef),
    Effectivity(EntityRef),
    ExternalSource(EntityRef),
    OrganizationRole(EntityRef),
    PersonAndOrganizationRole(EntityRef),
    PersonAndOrganization(EntityRef),
    PropertyDefinitionRepresentation(EntityRef),
    Representation(EntityRef),
}
impl Default for DescriptionAttributeSelect {
    fn default() -> Self {
        DescriptionAttributeSelect::ActionRequestSolution(EntityRef::default())
    }
}
impl From<Parameter> for DescriptionAttributeSelect {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EntityRef(id) => DescriptionAttributeSelect::EntityRef(EntityRef(id)),
                _ => panic!("parameter is not an instance"),
            },
            _ => panic!("parameter is not recognized"),
        }
    }
}
type DescriptiveMeasure = String;
type DimensionCount = i64;
#[derive(Eq, PartialEq, Hash, Debug)]
pub enum DimensionExtentUsage {
    Origin,
    Target,
}
impl Default for DimensionExtentUsage {
    fn default() -> Self {
        DimensionExtentUsage::Origin
    }
}
impl From<String> for DimensionExtentUsage {
    fn from(value: String) -> Self {
        match value.as_str() {
            "ORIGIN" => DimensionExtentUsage::Origin,
            "TARGET" => DimensionExtentUsage::Target,
            _ => panic!("{} is not a valid value", value),
        }
    }
}
impl From<Parameter> for DimensionExtentUsage {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EnumValue(value) => value.into(),
                _ => panic!("parameter is not an enum value"),
            },
            Parameter::OmittedParameter => DimensionExtentUsage::default(),
            _ => panic!("parameter is not an enum value"),
        }
    }
}
#[derive(Debug)]
pub enum DimensionalCharacteristic {
    EntityRef(EntityRef),
    DimensionalLocation(EntityRef),
    DimensionalSize(EntityRef),
}
impl Default for DimensionalCharacteristic {
    fn default() -> Self {
        DimensionalCharacteristic::DimensionalLocation(EntityRef::default())
    }
}
impl From<Parameter> for DimensionalCharacteristic {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EntityRef(id) => DimensionalCharacteristic::EntityRef(EntityRef(id)),
                _ => panic!("parameter is not an instance"),
            },
            _ => panic!("parameter is not recognized"),
        }
    }
}
#[derive(Eq, PartialEq, Hash, Debug)]
pub enum DirectionCountSelect {
    UDirectionCount(UDirectionCount),
    VDirectionCount(VDirectionCount),
}
impl Default for DirectionCountSelect {
    fn default() -> Self {
        DirectionCountSelect::UDirectionCount(UDirectionCount::default())
    }
}
impl From<Parameter> for DirectionCountSelect {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::TypedParameter(typed_parameter) => match typed_parameter.type_name.as_str() {
                "U_DIRECTION_COUNT" => {
                    DirectionCountSelect::UDirectionCount(typed_parameter.parameters.into_iter().next().unwrap().into())
                }
                "V_DIRECTION_COUNT" => {
                    DirectionCountSelect::VDirectionCount(typed_parameter.parameters.into_iter().next().unwrap().into())
                }
                _ => panic!("parameter type is not recognized: {}", typed_parameter.type_name),
            },
            _ => panic!("parameter is not recognized"),
        }
    }
}
#[derive(Eq, PartialEq, Hash, Debug)]
pub enum DocumentReferenceItem {
    EntityRef(EntityRef),
    ActionDirective(EntityRef),
    ActionMethod(EntityRef),
    ActionRelationship(EntityRef),
    AppliedActionAssignment(EntityRef),
    Approval(EntityRef),
    Certification(EntityRef),
    Class(EntityRef),
    ClassSystem(EntityRef),
    ConfigurationDesign(EntityRef),
    ConfigurationItem(EntityRef),
    Contract(EntityRef),
    DescriptiveRepresentationItem(EntityRef),
    ExecutedAction(EntityRef),
    ExternallyDefinedDimensionDefinition(EntityRef),
    FeatureDefinition(EntityRef),
    GeneralProperty(EntityRef),
    MaterialDesignation(EntityRef),
    Organization(EntityRef),
    OrganizationalProject(EntityRef),
    Person(EntityRef),
    PresentationArea(EntityRef),
    ProcessPlan(EntityRef),
    Product(EntityRef),
    ProductConcept(EntityRef),
    ProductConceptFeature(EntityRef),
    ProductConceptFeatureCategory(EntityRef),
    ProductDefinition(EntityRef),
    ProductDefinitionFormation(EntityRef),
    ProductDefinitionFormationRelationship(EntityRef),
    ProductDefinitionProcess(EntityRef),
    ProductDefinitionRelationship(EntityRef),
    ProductDefinitionSubstitute(EntityRef),
    ProductRelatedProductCategory(EntityRef),
    PropertyDefinition(EntityRef),
    Representation(EntityRef),
    ResourceRequirementType(EntityRef),
    Retention(EntityRef),
    SecurityClassification(EntityRef),
    ShapeAspect(EntityRef),
    ShapeAspectRelationship(EntityRef),
    VersionedActionRequest(EntityRef),
}
impl Default for DocumentReferenceItem {
    fn default() -> Self {
        DocumentReferenceItem::ActionDirective(EntityRef::default())
    }
}
impl From<Parameter> for DocumentReferenceItem {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EntityRef(id) => DocumentReferenceItem::EntityRef(EntityRef(id)),
                _ => panic!("parameter is not an instance"),
            },
            _ => panic!("parameter is not recognized"),
        }
    }
}
#[derive(Eq, PartialEq, Hash, Debug)]
pub enum DraughtingCalloutElement {
    EntityRef(EntityRef),
    AnnotationTextOccurrence(EntityRef),
    AnnotationSymbolOccurrence(EntityRef),
    AnnotationCurveOccurrence(EntityRef),
}
impl Default for DraughtingCalloutElement {
    fn default() -> Self {
        DraughtingCalloutElement::AnnotationTextOccurrence(EntityRef::default())
    }
}
impl From<Parameter> for DraughtingCalloutElement {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EntityRef(id) => DraughtingCalloutElement::EntityRef(EntityRef(id)),
                _ => panic!("parameter is not an instance"),
            },
            _ => panic!("parameter is not recognized"),
        }
    }
}
#[derive(Debug)]
pub enum DraughtingModelItemAssociationSelect {
    EntityRef(EntityRef),
    AnnotationOccurrence(EntityRef),
    DraughtingCallout(EntityRef),
}
impl Default for DraughtingModelItemAssociationSelect {
    fn default() -> Self {
        DraughtingModelItemAssociationSelect::AnnotationOccurrence(EntityRef::default())
    }
}
impl From<Parameter> for DraughtingModelItemAssociationSelect {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EntityRef(id) => DraughtingModelItemAssociationSelect::EntityRef(EntityRef(id)),
                _ => panic!("parameter is not an instance"),
            },
            _ => panic!("parameter is not recognized"),
        }
    }
}
#[derive(Eq, PartialEq, Hash, Debug)]
pub enum DraughtingTitledItem {
    EntityRef(EntityRef),
    DrawingRevision(EntityRef),
    DrawingSheetRevision(EntityRef),
}
impl Default for DraughtingTitledItem {
    fn default() -> Self {
        DraughtingTitledItem::DrawingRevision(EntityRef::default())
    }
}
impl From<Parameter> for DraughtingTitledItem {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EntityRef(id) => DraughtingTitledItem::EntityRef(EntityRef(id)),
                _ => panic!("parameter is not an instance"),
            },
            _ => panic!("parameter is not recognized"),
        }
    }
}
#[derive(Eq, PartialEq, Hash, Debug)]
pub enum EffectivityItem {
    EntityRef(EntityRef),
    Action(EntityRef),
    ActionMethod(EntityRef),
    ActionMethodRelationship(EntityRef),
    ActionProperty(EntityRef),
    ActionRelationship(EntityRef),
    AssemblyComponentUsageSubstitute(EntityRef),
    Class(EntityRef),
    ClassSystem(EntityRef),
    ConfigurationDesign(EntityRef),
    ConfigurationItem(EntityRef),
    ConfiguredEffectivityAssignment(EntityRef),
    DocumentFile(EntityRef),
    DraughtingModel(EntityRef),
    DrawingRevision(EntityRef),
    GeneralProperty(EntityRef),
    MaterialDesignation(EntityRef),
    MechanicalDesignGeometricPresentationRepresentation(EntityRef),
    PresentationArea(EntityRef),
    Product(EntityRef),
    ProductConcept(EntityRef),
    ProductConceptFeature(EntityRef),
    ProductConceptFeatureAssociation(EntityRef),
    ProductConceptFeatureCategory(EntityRef),
    ProductConceptFeatureCategoryUsage(EntityRef),
    ProductDefinition(EntityRef),
    ProductDefinitionFormation(EntityRef),
    ProductDefinitionFormationRelationship(EntityRef),
    ProductDefinitionRelationship(EntityRef),
    ProductDefinitionSubstitute(EntityRef),
    PropertyDefinition(EntityRef),
    RequirementForActionResource(EntityRef),
    ResourceProperty(EntityRef),
    SecurityClassification(EntityRef),
    ShapeAspect(EntityRef),
    ShapeRepresentation(EntityRef),
}
impl Default for EffectivityItem {
    fn default() -> Self {
        EffectivityItem::Action(EntityRef::default())
    }
}
impl From<Parameter> for EffectivityItem {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EntityRef(id) => EffectivityItem::EntityRef(EntityRef(id)),
                _ => panic!("parameter is not an instance"),
            },
            _ => panic!("parameter is not recognized"),
        }
    }
}
type ElectricCurrentMeasure = Real;
#[derive(Eq, PartialEq, Hash, Debug)]
pub enum EventOccurrenceItem {
    EntityRef(EntityRef),
    Action(EntityRef),
    ActionDirective(EntityRef),
    ActionMethod(EntityRef),
    ActionProperty(EntityRef),
    ActionRelationship(EntityRef),
    ActionRequestSolution(EntityRef),
    AlternateProductRelationship(EntityRef),
    AppliedActionAssignment(EntityRef),
    AppliedClassificationAssignment(EntityRef),
    AppliedPersonAndOrganizationAssignment(EntityRef),
    ApprovalStatus(EntityRef),
    AssemblyComponentUsageSubstitute(EntityRef),
    Certification(EntityRef),
    Class(EntityRef),
    ClassSystem(EntityRef),
    ConfigurationDesign(EntityRef),
    ConfigurationEffectivity(EntityRef),
    ConfigurationItem(EntityRef),
    ConfiguredEffectivityAssignment(EntityRef),
    Contract(EntityRef),
    DocumentFile(EntityRef),
    DraughtingModel(EntityRef),
    DrawingRevision(EntityRef),
    ExecutedAction(EntityRef),
    GeneralProperty(EntityRef),
    MaterialDesignation(EntityRef),
    MechanicalDesignGeometricPresentationRepresentation(EntityRef),
    OrganizationRelationship(EntityRef),
    OrganizationalProject(EntityRef),
    PersonAndOrganization(EntityRef),
    PresentationArea(EntityRef),
    Product(EntityRef),
    ProductConcept(EntityRef),
    ProductConceptFeature(EntityRef),
    ProductConceptFeatureAssociation(EntityRef),
    ProductConceptFeatureCategory(EntityRef),
    ProductConceptFeatureCategoryUsage(EntityRef),
    ProductDefinition(EntityRef),
    ProductDefinitionFormation(EntityRef),
    ProductDefinitionFormationRelationship(EntityRef),
    ProductDefinitionRelationship(EntityRef),
    ProductDefinitionSubstitute(EntityRef),
    PropertyDefinition(EntityRef),
    RequirementForActionResource(EntityRef),
    ResourceProperty(EntityRef),
    SecurityClassification(EntityRef),
    SecurityClassificationLevel(EntityRef),
    ShapeRepresentation(EntityRef),
    VersionedActionRequest(EntityRef),
}
impl Default for EventOccurrenceItem {
    fn default() -> Self {
        EventOccurrenceItem::Action(EntityRef::default())
    }
}
impl From<Parameter> for EventOccurrenceItem {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EntityRef(id) => EventOccurrenceItem::EntityRef(EntityRef(id)),
                _ => panic!("parameter is not an instance"),
            },
            _ => panic!("parameter is not recognized"),
        }
    }
}
#[derive(Eq, PartialEq, Hash, Debug)]
pub enum ExternalIdentificationItem {
    EntityRef(EntityRef),
    DocumentFile(EntityRef),
    ExternallyDefinedClass(EntityRef),
    ExternallyDefinedGeneralProperty(EntityRef),
    ProductDefinition(EntityRef),
}
impl Default for ExternalIdentificationItem {
    fn default() -> Self {
        ExternalIdentificationItem::DocumentFile(EntityRef::default())
    }
}
impl From<Parameter> for ExternalIdentificationItem {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EntityRef(id) => ExternalIdentificationItem::EntityRef(EntityRef(id)),
                _ => panic!("parameter is not an instance"),
            },
            _ => panic!("parameter is not recognized"),
        }
    }
}
#[derive(Eq, PartialEq, Hash, Debug)]
pub enum FillAreaStyleTileShapeSelect {
    FillAreaStyleTileSymbolWithStyle(EntityRef),
}
impl Default for FillAreaStyleTileShapeSelect {
    fn default() -> Self {
        FillAreaStyleTileShapeSelect::FillAreaStyleTileSymbolWithStyle(EntityRef::default())
    }
}
impl From<Parameter> for FillAreaStyleTileShapeSelect {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EntityRef(id) => {
                    FillAreaStyleTileShapeSelect::FillAreaStyleTileSymbolWithStyle(EntityRef(id))
                }
                _ => panic!("parameter is not an instance"),
            },
            _ => panic!("parameter is not recognized"),
        }
    }
}
#[derive(Eq, PartialEq, Hash, Debug)]
pub enum FillStyleSelect {
    EntityRef(EntityRef),
    FillAreaStyleColour(EntityRef),
    ExternallyDefinedTileStyle(EntityRef),
    FillAreaStyleTiles(EntityRef),
    ExternallyDefinedHatchStyle(EntityRef),
    FillAreaStyleHatching(EntityRef),
}
impl Default for FillStyleSelect {
    fn default() -> Self {
        FillStyleSelect::FillAreaStyleColour(EntityRef::default())
    }
}
impl From<Parameter> for FillStyleSelect {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EntityRef(id) => FillStyleSelect::EntityRef(EntityRef(id)),
                _ => panic!("parameter is not an instance"),
            },
            _ => panic!("parameter is not recognized"),
        }
    }
}
#[derive(Debug)]
pub enum FontSelect {
    EntityRef(EntityRef),
    PreDefinedTextFont(EntityRef),
    ExternallyDefinedTextFont(EntityRef),
}
impl Default for FontSelect {
    fn default() -> Self {
        FontSelect::PreDefinedTextFont(EntityRef::default())
    }
}
impl From<Parameter> for FontSelect {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EntityRef(id) => FontSelect::EntityRef(EntityRef(id)),
                _ => panic!("parameter is not an instance"),
            },
            _ => panic!("parameter is not recognized"),
        }
    }
}
#[derive(Debug)]
pub enum FoundedItemSelect {
    EntityRef(EntityRef),
    FoundedItem(EntityRef),
    RepresentationItem(EntityRef),
}
impl Default for FoundedItemSelect {
    fn default() -> Self {
        FoundedItemSelect::FoundedItem(EntityRef::default())
    }
}
impl From<Parameter> for FoundedItemSelect {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EntityRef(id) => FoundedItemSelect::EntityRef(EntityRef(id)),
                _ => panic!("parameter is not an instance"),
            },
            _ => panic!("parameter is not recognized"),
        }
    }
}
#[derive(Eq, PartialEq, Hash, Debug)]
pub enum GeometricSetSelect {
    EntityRef(EntityRef),
    Point(EntityRef),
    Curve(EntityRef),
    Surface(EntityRef),
}
impl Default for GeometricSetSelect {
    fn default() -> Self {
        GeometricSetSelect::Point(EntityRef::default())
    }
}
impl From<Parameter> for GeometricSetSelect {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EntityRef(id) => GeometricSetSelect::EntityRef(EntityRef(id)),
                _ => panic!("parameter is not an instance"),
            },
            _ => panic!("parameter is not recognized"),
        }
    }
}
#[derive(Eq, PartialEq, Hash, Debug)]
pub enum GroupItem {
    EntityRef(EntityRef),
    GeometricRepresentationItem(EntityRef),
    MappedItem(EntityRef),
    ProductConceptFeature(EntityRef),
    ShapeAspect(EntityRef),
    StyledItem(EntityRef),
    TopologicalRepresentationItem(EntityRef),
}
impl Default for GroupItem {
    fn default() -> Self {
        GroupItem::GeometricRepresentationItem(EntityRef::default())
    }
}
impl From<Parameter> for GroupItem {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EntityRef(id) => GroupItem::EntityRef(EntityRef(id)),
                _ => panic!("parameter is not an instance"),
            },
            _ => panic!("parameter is not recognized"),
        }
    }
}
type HourInDay = i64;
#[derive(Debug)]
pub enum IdAttributeSelect {
    EntityRef(EntityRef),
    Action(EntityRef),
    Address(EntityRef),
    ProductCategory(EntityRef),
    PropertyDefinition(EntityRef),
    ShapeAspect(EntityRef),
    ShapeAspectRelationship(EntityRef),
    ApplicationContext(EntityRef),
    Group(EntityRef),
    OrganizationalProject(EntityRef),
    Representation(EntityRef),
}
impl Default for IdAttributeSelect {
    fn default() -> Self {
        IdAttributeSelect::Action(EntityRef::default())
    }
}
impl From<Parameter> for IdAttributeSelect {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EntityRef(id) => IdAttributeSelect::EntityRef(EntityRef(id)),
                _ => panic!("parameter is not an instance"),
            },
            _ => panic!("parameter is not recognized"),
        }
    }
}
#[derive(Eq, PartialEq, Hash, Debug)]
pub enum IdentificationItem {
    EntityRef(EntityRef),
    Action(EntityRef),
    ActionDirective(EntityRef),
    ActionMethod(EntityRef),
    ActionProperty(EntityRef),
    AppliedIdentificationAssignment(EntityRef),
    ApprovalStatus(EntityRef),
    Class(EntityRef),
    ClassSystem(EntityRef),
    ConfigurationItem(EntityRef),
    DimensionalSize(EntityRef),
    DocumentFile(EntityRef),
    DocumentType(EntityRef),
    DraughtingModel(EntityRef),
    Effectivity(EntityRef),
    GeneralProperty(EntityRef),
    MeasureRepresentationItem(EntityRef),
    MechanicalDesignGeometricPresentationRepresentation(EntityRef),
    Organization(EntityRef),
    OrganizationalProject(EntityRef),
    PersonAndOrganization(EntityRef),
    PresentationArea(EntityRef),
    Product(EntityRef),
    ProductConcept(EntityRef),
    ProductConceptFeature(EntityRef),
    ProductConceptFeatureCategory(EntityRef),
    ProductDefinition(EntityRef),
    ProductDefinitionFormation(EntityRef),
    ProductDefinitionRelationship(EntityRef),
    PropertyDefinition(EntityRef),
    PropertyDefinitionRelationship(EntityRef),
    SecurityClassificationLevel(EntityRef),
    ShapeAspectRelationship(EntityRef),
    ShapeRepresentation(EntityRef),
    VersionedActionRequest(EntityRef),
}
impl Default for IdentificationItem {
    fn default() -> Self {
        IdentificationItem::Action(EntityRef::default())
    }
}
impl From<Parameter> for IdentificationItem {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EntityRef(id) => IdentificationItem::EntityRef(EntityRef(id)),
                _ => panic!("parameter is not an instance"),
            },
            _ => panic!("parameter is not recognized"),
        }
    }
}
type Identifier = String;
#[derive(Eq, PartialEq, Hash, Debug)]
pub enum InterpolationType {
    Undefined,
    Synchronous,
    Linear,
}
impl Default for InterpolationType {
    fn default() -> Self {
        InterpolationType::Undefined
    }
}
impl From<String> for InterpolationType {
    fn from(value: String) -> Self {
        match value.as_str() {
            "UNDEFINED" => InterpolationType::Undefined,
            "SYNCHRONOUS" => InterpolationType::Synchronous,
            "LINEAR" => InterpolationType::Linear,
            _ => panic!("{} is not a valid value", value),
        }
    }
}
impl From<Parameter> for InterpolationType {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EnumValue(value) => value.into(),
                _ => panic!("parameter is not an enum value"),
            },
            Parameter::OmittedParameter => InterpolationType::default(),
            _ => panic!("parameter is not an enum value"),
        }
    }
}
#[derive(Debug)]
pub enum InvisibilityContext {
    EntityRef(EntityRef),
    PresentationRepresentation(EntityRef),
    PresentationSet(EntityRef),
}
impl Default for InvisibilityContext {
    fn default() -> Self {
        InvisibilityContext::PresentationRepresentation(EntityRef::default())
    }
}
impl From<Parameter> for InvisibilityContext {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EntityRef(id) => InvisibilityContext::EntityRef(EntityRef(id)),
                _ => panic!("parameter is not an instance"),
            },
            _ => panic!("parameter is not recognized"),
        }
    }
}
#[derive(Eq, PartialEq, Hash, Debug)]
pub enum InvisibleItem {
    EntityRef(EntityRef),
    DraughtingCallout(EntityRef),
    PresentationLayerAssignment(EntityRef),
    Representation(EntityRef),
    StyledItem(EntityRef),
}
impl Default for InvisibleItem {
    fn default() -> Self {
        InvisibleItem::DraughtingCallout(EntityRef::default())
    }
}
impl From<Parameter> for InvisibleItem {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EntityRef(id) => InvisibleItem::EntityRef(EntityRef(id)),
                _ => panic!("parameter is not an instance"),
            },
            _ => panic!("parameter is not recognized"),
        }
    }
}
#[derive(Eq, PartialEq, Hash, Debug)]
pub enum KinematicAnalysisDefinition {
    InterpolatedConfigurationSequence(EntityRef),
}
impl Default for KinematicAnalysisDefinition {
    fn default() -> Self {
        KinematicAnalysisDefinition::InterpolatedConfigurationSequence(EntityRef::default())
    }
}
impl From<Parameter> for KinematicAnalysisDefinition {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EntityRef(id) => {
                    KinematicAnalysisDefinition::InterpolatedConfigurationSequence(EntityRef(id))
                }
                _ => panic!("parameter is not an instance"),
            },
            _ => panic!("parameter is not recognized"),
        }
    }
}
#[derive(Eq, PartialEq, Hash, Debug)]
pub enum KinematicFrameBackground {
    EntityRef(EntityRef),
    Point(EntityRef),
    Curve(EntityRef),
    Surface(EntityRef),
}
impl Default for KinematicFrameBackground {
    fn default() -> Self {
        KinematicFrameBackground::Point(EntityRef::default())
    }
}
impl From<Parameter> for KinematicFrameBackground {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EntityRef(id) => KinematicFrameBackground::EntityRef(EntityRef(id)),
                _ => panic!("parameter is not an instance"),
            },
            _ => panic!("parameter is not recognized"),
        }
    }
}
#[derive(Eq, PartialEq, Hash, Debug)]
pub enum KinematicResult {
    EntityRef(EntityRef),
    InterpolatedConfigurationSequence(EntityRef),
    ResultingPath(EntityRef),
}
impl Default for KinematicResult {
    fn default() -> Self {
        KinematicResult::InterpolatedConfigurationSequence(EntityRef::default())
    }
}
impl From<Parameter> for KinematicResult {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EntityRef(id) => KinematicResult::EntityRef(EntityRef(id)),
                _ => panic!("parameter is not an instance"),
            },
            _ => panic!("parameter is not recognized"),
        }
    }
}
#[derive(Eq, PartialEq, Hash, Debug)]
pub enum KnotType {
    UniformKnots,
    QuasiUniformKnots,
    PiecewiseBezierKnots,
    Unspecified,
}
impl Default for KnotType {
    fn default() -> Self {
        KnotType::UniformKnots
    }
}
impl From<String> for KnotType {
    fn from(value: String) -> Self {
        match value.as_str() {
            "UNIFORM_KNOTS" => KnotType::UniformKnots,
            "QUASI_UNIFORM_KNOTS" => KnotType::QuasiUniformKnots,
            "PIECEWISE_BEZIER_KNOTS" => KnotType::PiecewiseBezierKnots,
            "UNSPECIFIED" => KnotType::Unspecified,
            _ => panic!("{} is not a valid value", value),
        }
    }
}
impl From<Parameter> for KnotType {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EnumValue(value) => value.into(),
                _ => panic!("parameter is not an enum value"),
            },
            Parameter::OmittedParameter => KnotType::default(),
            _ => panic!("parameter is not an enum value"),
        }
    }
}
type Label = String;
#[derive(Eq, PartialEq, Hash, Debug)]
pub enum LanguageItem {
    Representation(EntityRef),
}
impl Default for LanguageItem {
    fn default() -> Self {
        LanguageItem::Representation(EntityRef::default())
    }
}
impl From<Parameter> for LanguageItem {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EntityRef(id) => LanguageItem::Representation(EntityRef(id)),
                _ => panic!("parameter is not an instance"),
            },
            _ => panic!("parameter is not recognized"),
        }
    }
}
#[derive(Eq, PartialEq, Hash, Debug)]
pub enum LayeredItem {
    EntityRef(EntityRef),
    PresentationRepresentation(EntityRef),
    RepresentationItem(EntityRef),
}
impl Default for LayeredItem {
    fn default() -> Self {
        LayeredItem::PresentationRepresentation(EntityRef::default())
    }
}
impl From<Parameter> for LayeredItem {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EntityRef(id) => LayeredItem::EntityRef(EntityRef(id)),
                _ => panic!("parameter is not an instance"),
            },
            _ => panic!("parameter is not recognized"),
        }
    }
}
type LengthMeasure = Real;
#[derive(Eq, PartialEq, Hash, Debug)]
pub enum LimitCondition {
    MaximumMaterialCondition,
    LeastMaterialCondition,
    RegardlessOfFeatureSize,
}
impl Default for LimitCondition {
    fn default() -> Self {
        LimitCondition::MaximumMaterialCondition
    }
}
impl From<String> for LimitCondition {
    fn from(value: String) -> Self {
        match value.as_str() {
            "MAXIMUM_MATERIAL_CONDITION" => LimitCondition::MaximumMaterialCondition,
            "LEAST_MATERIAL_CONDITION" => LimitCondition::LeastMaterialCondition,
            "REGARDLESS_OF_FEATURE_SIZE" => LimitCondition::RegardlessOfFeatureSize,
            _ => panic!("{} is not a valid value", value),
        }
    }
}
impl From<Parameter> for LimitCondition {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EnumValue(value) => value.into(),
                _ => panic!("parameter is not an enum value"),
            },
            Parameter::OmittedParameter => LimitCondition::default(),
            _ => panic!("parameter is not an enum value"),
        }
    }
}
type ListOfReversibleTopologyItem = Vec<EntityRef>;
type ListRepresentationItem = Vec<EntityRef>;
type LuminousIntensityMeasure = Real;
#[derive(Debug)]
pub enum MarkerSelect {
    MarkerType(MarkerType),
    PreDefinedMarker(EntityRef),
}
impl Default for MarkerSelect {
    fn default() -> Self {
        MarkerSelect::MarkerType(MarkerType::default())
    }
}
impl From<Parameter> for MarkerSelect {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::TypedParameter(typed_parameter) => match typed_parameter.type_name.as_str() {
                "MARKER_TYPE" => {
                    MarkerSelect::MarkerType(typed_parameter.parameters.into_iter().next().unwrap().into())
                }
                _ => panic!("parameter type is not recognized: {}", typed_parameter.type_name),
            },
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EntityRef(id) => MarkerSelect::PreDefinedMarker(EntityRef(id)),
                _ => panic!("parameter is not an instance"),
            },
            _ => panic!("parameter is not recognized"),
        }
    }
}
#[derive(Eq, PartialEq, Hash, Debug)]
pub enum MarkerType {
    Dot,
    X,
    Plus,
    Asterisk,
    Ring,
    Square,
    Triangle,
}
impl Default for MarkerType {
    fn default() -> Self {
        MarkerType::Dot
    }
}
impl From<String> for MarkerType {
    fn from(value: String) -> Self {
        match value.as_str() {
            "DOT" => MarkerType::Dot,
            "X" => MarkerType::X,
            "PLUS" => MarkerType::Plus,
            "ASTERISK" => MarkerType::Asterisk,
            "RING" => MarkerType::Ring,
            "SQUARE" => MarkerType::Square,
            "TRIANGLE" => MarkerType::Triangle,
            _ => panic!("{} is not a valid value", value),
        }
    }
}
impl From<Parameter> for MarkerType {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EnumValue(value) => value.into(),
                _ => panic!("parameter is not an enum value"),
            },
            Parameter::OmittedParameter => MarkerType::default(),
            _ => panic!("parameter is not an enum value"),
        }
    }
}
type MassMeasure = Real;
#[derive(Debug)]
pub enum MeasureValue {
    AmountOfSubstanceMeasure(AmountOfSubstanceMeasure),
    AreaMeasure(AreaMeasure),
    CelsiusTemperatureMeasure(CelsiusTemperatureMeasure),
    ContextDependentMeasure(ContextDependentMeasure),
    CountMeasure(CountMeasure),
    DescriptiveMeasure(DescriptiveMeasure),
    ElectricCurrentMeasure(ElectricCurrentMeasure),
    LengthMeasure(LengthMeasure),
    LuminousIntensityMeasure(LuminousIntensityMeasure),
    MassMeasure(MassMeasure),
    NumericMeasure(NumericMeasure),
    NonNegativeLengthMeasure(NonNegativeLengthMeasure),
    ParameterValue(ParameterValue),
    PlaneAngleMeasure(PlaneAngleMeasure),
    PositiveLengthMeasure(PositiveLengthMeasure),
    PositivePlaneAngleMeasure(PositivePlaneAngleMeasure),
    PositiveRatioMeasure(PositiveRatioMeasure),
    RatioMeasure(RatioMeasure),
    SolidAngleMeasure(SolidAngleMeasure),
    ThermodynamicTemperatureMeasure(ThermodynamicTemperatureMeasure),
    TimeMeasure(TimeMeasure),
    VolumeMeasure(VolumeMeasure),
}
impl Default for MeasureValue {
    fn default() -> Self {
        MeasureValue::AmountOfSubstanceMeasure(AmountOfSubstanceMeasure::default())
    }
}
impl From<Parameter> for MeasureValue {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::TypedParameter(typed_parameter) => match typed_parameter.type_name.as_str() {
                "AMOUNT_OF_SUBSTANCE_MEASURE" => MeasureValue::AmountOfSubstanceMeasure(
                    typed_parameter.parameters.into_iter().next().unwrap().into(),
                ),
                "AREA_MEASURE" => {
                    MeasureValue::AreaMeasure(typed_parameter.parameters.into_iter().next().unwrap().into())
                }
                "CELSIUS_TEMPERATURE_MEASURE" => MeasureValue::CelsiusTemperatureMeasure(
                    typed_parameter.parameters.into_iter().next().unwrap().into(),
                ),
                "CONTEXT_DEPENDENT_MEASURE" => {
                    MeasureValue::ContextDependentMeasure(typed_parameter.parameters.into_iter().next().unwrap().into())
                }
                "COUNT_MEASURE" => {
                    MeasureValue::CountMeasure(typed_parameter.parameters.into_iter().next().unwrap().into())
                }
                "DESCRIPTIVE_MEASURE" => {
                    MeasureValue::DescriptiveMeasure(typed_parameter.parameters.into_iter().next().unwrap().into())
                }
                "ELECTRIC_CURRENT_MEASURE" => {
                    MeasureValue::ElectricCurrentMeasure(typed_parameter.parameters.into_iter().next().unwrap().into())
                }
                "LENGTH_MEASURE" => {
                    MeasureValue::LengthMeasure(typed_parameter.parameters.into_iter().next().unwrap().into())
                }
                "LUMINOUS_INTENSITY_MEASURE" => MeasureValue::LuminousIntensityMeasure(
                    typed_parameter.parameters.into_iter().next().unwrap().into(),
                ),
                "MASS_MEASURE" => {
                    MeasureValue::MassMeasure(typed_parameter.parameters.into_iter().next().unwrap().into())
                }
                "NUMERIC_MEASURE" => {
                    MeasureValue::NumericMeasure(typed_parameter.parameters.into_iter().next().unwrap().into())
                }
                "NON_NEGATIVE_LENGTH_MEASURE" => MeasureValue::NonNegativeLengthMeasure(
                    typed_parameter.parameters.into_iter().next().unwrap().into(),
                ),
                "PARAMETER_VALUE" => {
                    MeasureValue::ParameterValue(typed_parameter.parameters.into_iter().next().unwrap().into())
                }
                "PLANE_ANGLE_MEASURE" => {
                    MeasureValue::PlaneAngleMeasure(typed_parameter.parameters.into_iter().next().unwrap().into())
                }
                "POSITIVE_LENGTH_MEASURE" => {
                    MeasureValue::PositiveLengthMeasure(typed_parameter.parameters.into_iter().next().unwrap().into())
                }
                "POSITIVE_PLANE_ANGLE_MEASURE" => MeasureValue::PositivePlaneAngleMeasure(
                    typed_parameter.parameters.into_iter().next().unwrap().into(),
                ),
                "POSITIVE_RATIO_MEASURE" => {
                    MeasureValue::PositiveRatioMeasure(typed_parameter.parameters.into_iter().next().unwrap().into())
                }
                "RATIO_MEASURE" => {
                    MeasureValue::RatioMeasure(typed_parameter.parameters.into_iter().next().unwrap().into())
                }
                "SOLID_ANGLE_MEASURE" => {
                    MeasureValue::SolidAngleMeasure(typed_parameter.parameters.into_iter().next().unwrap().into())
                }
                "THERMODYNAMIC_TEMPERATURE_MEASURE" => MeasureValue::ThermodynamicTemperatureMeasure(
                    typed_parameter.parameters.into_iter().next().unwrap().into(),
                ),
                "TIME_MEASURE" => {
                    MeasureValue::TimeMeasure(typed_parameter.parameters.into_iter().next().unwrap().into())
                }
                "VOLUME_MEASURE" => {
                    MeasureValue::VolumeMeasure(typed_parameter.parameters.into_iter().next().unwrap().into())
                }
                _ => panic!("parameter type is not recognized: {}", typed_parameter.type_name),
            },
            _ => panic!("parameter is not recognized"),
        }
    }
}
type MinuteInHour = i64;
type MonthInYearNumber = i64;
#[derive(Debug)]
pub enum MotionParameterMeasure {
    ParameterValue(ParameterValue),
    MeasureWithUnit(EntityRef),
}
impl Default for MotionParameterMeasure {
    fn default() -> Self {
        MotionParameterMeasure::ParameterValue(ParameterValue::default())
    }
}
impl From<Parameter> for MotionParameterMeasure {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::TypedParameter(typed_parameter) => match typed_parameter.type_name.as_str() {
                "PARAMETER_VALUE" => MotionParameterMeasure::ParameterValue(
                    typed_parameter.parameters.into_iter().next().unwrap().into(),
                ),
                _ => panic!("parameter type is not recognized: {}", typed_parameter.type_name),
            },
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EntityRef(id) => MotionParameterMeasure::MeasureWithUnit(EntityRef(id)),
                _ => panic!("parameter is not an instance"),
            },
            _ => panic!("parameter is not recognized"),
        }
    }
}
#[derive(Eq, PartialEq, Hash, Debug)]
pub enum MultiLanguageAttributeItem {
    EntityRef(EntityRef),
    Action(EntityRef),
    ActionDirective(EntityRef),
    ActionMethod(EntityRef),
    ActionProperty(EntityRef),
    ActionRelationship(EntityRef),
    AlternateProductRelationship(EntityRef),
    ApplicationContext(EntityRef),
    ApprovalRelationship(EntityRef),
    AssemblyComponentUsageSubstitute(EntityRef),
    Certification(EntityRef),
    ConfigurationDesign(EntityRef),
    ConfigurationItem(EntityRef),
    Contract(EntityRef),
    DataEnvironment(EntityRef),
    DateRole(EntityRef),
    DateTimeRole(EntityRef),
    DescriptiveRepresentationItem(EntityRef),
    DocumentRelationship(EntityRef),
    DraughtingTitle(EntityRef),
    Effectivity(EntityRef),
    EffectivityRelationship(EntityRef),
    EventOccurrence(EntityRef),
    ExternalSource(EntityRef),
    GeneralProperty(EntityRef),
    GeneralPropertyRelationship(EntityRef),
    GeometricRepresentationItem(EntityRef),
    GeometricTolerance(EntityRef),
    Group(EntityRef),
    GroupRelationship(EntityRef),
    IdentificationRole(EntityRef),
    KinematicPair(EntityRef),
    MappedItem(EntityRef),
    NameAssignment(EntityRef),
    OrganizationRelationship(EntityRef),
    OrganizationRole(EntityRef),
    OrganizationalProject(EntityRef),
    OrganizationalProjectRelationship(EntityRef),
    PairActuator(EntityRef),
    PersonAndOrganizationRole(EntityRef),
    PresentationLayerAssignment(EntityRef),
    ProcessProductAssociation(EntityRef),
    Product(EntityRef),
    ProductConcept(EntityRef),
    ProductConceptFeature(EntityRef),
    ProductConceptFeatureAssociation(EntityRef),
    ProductConceptRelationship(EntityRef),
    ProductDefinition(EntityRef),
    ProductDefinitionFormation(EntityRef),
    ProductDefinitionFormationRelationship(EntityRef),
    ProductDefinitionRelationship(EntityRef),
    ProductDefinitionSubstitute(EntityRef),
    ProductRelatedProductCategory(EntityRef),
    PropertyDefinition(EntityRef),
    PropertyDefinitionRelationship(EntityRef),
    Representation(EntityRef),
    RepresentationRelationship(EntityRef),
    RequirementForActionResource(EntityRef),
    ResourceProperty(EntityRef),
    ResourceRequirementType(EntityRef),
    SecurityClassification(EntityRef),
    ShapeAspect(EntityRef),
    ShapeAspectRelationship(EntityRef),
    StyledItem(EntityRef),
    TimeIntervalRole(EntityRef),
    TopologicalRepresentationItem(EntityRef),
    UncertaintyMeasureWithUnit(EntityRef),
    UncertaintyQualifier(EntityRef),
    VersionedActionRequest(EntityRef),
    VersionedActionRequestRelationship(EntityRef),
}
impl Default for MultiLanguageAttributeItem {
    fn default() -> Self {
        MultiLanguageAttributeItem::Action(EntityRef::default())
    }
}
impl From<Parameter> for MultiLanguageAttributeItem {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EntityRef(id) => MultiLanguageAttributeItem::EntityRef(EntityRef(id)),
                _ => panic!("parameter is not an instance"),
            },
            _ => panic!("parameter is not recognized"),
        }
    }
}
#[derive(Debug)]
pub enum NameAttributeSelect {
    EntityRef(EntityRef),
    ActionRequestSolution(EntityRef),
    Address(EntityRef),
    ConfigurationDesign(EntityRef),
    ContextDependentShapeRepresentation(EntityRef),
    DerivedUnit(EntityRef),
    Effectivity(EntityRef),
    PersonAndOrganization(EntityRef),
    ProductDefinition(EntityRef),
    ProductDefinitionSubstitute(EntityRef),
    PropertyDefinitionRepresentation(EntityRef),
}
impl Default for NameAttributeSelect {
    fn default() -> Self {
        NameAttributeSelect::ActionRequestSolution(EntityRef::default())
    }
}
impl From<Parameter> for NameAttributeSelect {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EntityRef(id) => NameAttributeSelect::EntityRef(EntityRef(id)),
                _ => panic!("parameter is not an instance"),
            },
            _ => panic!("parameter is not recognized"),
        }
    }
}
#[derive(Eq, PartialEq, Hash, Debug)]
pub enum NameItem {
    EntityRef(EntityRef),
    KinematicJoint(EntityRef),
    KinematicLink(EntityRef),
    KinematicStructure(EntityRef),
}
impl Default for NameItem {
    fn default() -> Self {
        NameItem::KinematicJoint(EntityRef::default())
    }
}
impl From<Parameter> for NameItem {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EntityRef(id) => NameItem::EntityRef(EntityRef(id)),
                _ => panic!("parameter is not an instance"),
            },
            _ => panic!("parameter is not recognized"),
        }
    }
}
type NonNegativeLengthMeasure = LengthMeasure;
#[derive(Eq, PartialEq, Hash, Debug)]
pub enum NullStyle {
    Null,
}
impl Default for NullStyle {
    fn default() -> Self {
        NullStyle::Null
    }
}
impl From<String> for NullStyle {
    fn from(value: String) -> Self {
        match value.as_str() {
            "NULL" => NullStyle::Null,
            _ => panic!("{} is not a valid value", value),
        }
    }
}
impl From<Parameter> for NullStyle {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EnumValue(value) => value.into(),
                _ => panic!("parameter is not an enum value"),
            },
            Parameter::OmittedParameter => NullStyle::default(),
            _ => panic!("parameter is not an enum value"),
        }
    }
}
type NumericMeasure = Real;
#[derive(Eq, PartialEq, Hash, Debug)]
pub enum OrganizationItem {
    EntityRef(EntityRef),
    Action(EntityRef),
    ActionDirective(EntityRef),
    ActionMethod(EntityRef),
    ActionProperty(EntityRef),
    ActionRelationship(EntityRef),
    ActionRequestSolution(EntityRef),
    AlternateProductRelationship(EntityRef),
    AppliedActionAssignment(EntityRef),
    AppliedClassificationAssignment(EntityRef),
    AppliedIdentificationAssignment(EntityRef),
    AppliedOrganizationAssignment(EntityRef),
    AppliedPersonAndOrganizationAssignment(EntityRef),
    Approval(EntityRef),
    ApprovalStatus(EntityRef),
    AssemblyComponentUsageSubstitute(EntityRef),
    Certification(EntityRef),
    Class(EntityRef),
    ClassSystem(EntityRef),
    ConfigurationDesign(EntityRef),
    ConfigurationEffectivity(EntityRef),
    ConfigurationItem(EntityRef),
    ConfiguredEffectivityAssignment(EntityRef),
    Contract(EntityRef),
    DocumentFile(EntityRef),
    DocumentType(EntityRef),
    DraughtingModel(EntityRef),
    DrawingRevision(EntityRef),
    Effectivity(EntityRef),
    EventOccurrence(EntityRef),
    ExecutedAction(EntityRef),
    GeneralProperty(EntityRef),
    MaterialDesignation(EntityRef),
    MechanicalDesignGeometricPresentationRepresentation(EntityRef),
    Organization(EntityRef),
    OrganizationRelationship(EntityRef),
    OrganizationalProject(EntityRef),
    PersonAndOrganization(EntityRef),
    PresentationArea(EntityRef),
    Product(EntityRef),
    ProductConcept(EntityRef),
    ProductConceptFeature(EntityRef),
    ProductConceptFeatureAssociation(EntityRef),
    ProductConceptFeatureCategory(EntityRef),
    ProductConceptFeatureCategoryUsage(EntityRef),
    ProductDefinition(EntityRef),
    ProductDefinitionFormation(EntityRef),
    ProductDefinitionFormationRelationship(EntityRef),
    ProductDefinitionRelationship(EntityRef),
    ProductDefinitionSubstitute(EntityRef),
    PropertyDefinition(EntityRef),
    RequirementForActionResource(EntityRef),
    ResourceProperty(EntityRef),
    SecurityClassification(EntityRef),
    SecurityClassificationLevel(EntityRef),
    ShapeRepresentation(EntityRef),
    VersionedActionRequest(EntityRef),
}
impl Default for OrganizationItem {
    fn default() -> Self {
        OrganizationItem::Action(EntityRef::default())
    }
}
impl From<Parameter> for OrganizationItem {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EntityRef(id) => OrganizationItem::EntityRef(EntityRef(id)),
                _ => panic!("parameter is not an instance"),
            },
            _ => panic!("parameter is not recognized"),
        }
    }
}
#[derive(Eq, PartialEq, Hash, Debug)]
pub enum OrganizationalProjectItem {
    EntityRef(EntityRef),
    AssemblyComponentUsage(EntityRef),
    ConfigurationItem(EntityRef),
    ExecutedAction(EntityRef),
    Product(EntityRef),
    ProductConcept(EntityRef),
    ProductDefinition(EntityRef),
    ProductDefinitionFormation(EntityRef),
}
impl Default for OrganizationalProjectItem {
    fn default() -> Self {
        OrganizationalProjectItem::AssemblyComponentUsage(EntityRef::default())
    }
}
impl From<Parameter> for OrganizationalProjectItem {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EntityRef(id) => OrganizationalProjectItem::EntityRef(EntityRef(id)),
                _ => panic!("parameter is not an instance"),
            },
            _ => panic!("parameter is not recognized"),
        }
    }
}
type ParameterValue = Real;
#[derive(Debug)]
pub enum PcurveOrSurface {
    EntityRef(EntityRef),
    Pcurve(EntityRef),
    Surface(EntityRef),
}
impl Default for PcurveOrSurface {
    fn default() -> Self {
        PcurveOrSurface::Pcurve(EntityRef::default())
    }
}
impl From<Parameter> for PcurveOrSurface {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EntityRef(id) => PcurveOrSurface::EntityRef(EntityRef(id)),
                _ => panic!("parameter is not an instance"),
            },
            _ => panic!("parameter is not recognized"),
        }
    }
}
#[derive(Eq, PartialEq, Hash, Debug)]
pub enum PersonAndOrganizationItem {
    EntityRef(EntityRef),
    Action(EntityRef),
    ActionDirective(EntityRef),
    ActionMethod(EntityRef),
    ActionProperty(EntityRef),
    ActionRelationship(EntityRef),
    ActionRequestSolution(EntityRef),
    AlternateProductRelationship(EntityRef),
    AppliedActionAssignment(EntityRef),
    AppliedClassificationAssignment(EntityRef),
    AppliedOrganizationAssignment(EntityRef),
    AppliedPersonAndOrganizationAssignment(EntityRef),
    ApprovalStatus(EntityRef),
    AssemblyComponentUsageSubstitute(EntityRef),
    Certification(EntityRef),
    Class(EntityRef),
    ClassSystem(EntityRef),
    ConfigurationDesign(EntityRef),
    ConfigurationEffectivity(EntityRef),
    ConfigurationItem(EntityRef),
    ConfiguredEffectivityAssignment(EntityRef),
    Contract(EntityRef),
    DocumentFile(EntityRef),
    DocumentType(EntityRef),
    DraughtingModel(EntityRef),
    DrawingRevision(EntityRef),
    EventOccurrence(EntityRef),
    ExecutedAction(EntityRef),
    GeneralProperty(EntityRef),
    MaterialDesignation(EntityRef),
    MechanicalDesignGeometricPresentationRepresentation(EntityRef),
    Organization(EntityRef),
    OrganizationRelationship(EntityRef),
    OrganizationalProject(EntityRef),
    PersonAndOrganization(EntityRef),
    PresentationArea(EntityRef),
    Product(EntityRef),
    ProductConcept(EntityRef),
    ProductConceptFeature(EntityRef),
    ProductConceptFeatureAssociation(EntityRef),
    ProductConceptFeatureCategory(EntityRef),
    ProductConceptFeatureCategoryUsage(EntityRef),
    ProductDefinition(EntityRef),
    ProductDefinitionFormation(EntityRef),
    ProductDefinitionFormationRelationship(EntityRef),
    ProductDefinitionRelationship(EntityRef),
    ProductDefinitionSubstitute(EntityRef),
    PropertyDefinition(EntityRef),
    RequirementForActionResource(EntityRef),
    ResourceProperty(EntityRef),
    SecurityClassification(EntityRef),
    SecurityClassificationLevel(EntityRef),
    ShapeRepresentation(EntityRef),
    VersionedActionRequest(EntityRef),
}
impl Default for PersonAndOrganizationItem {
    fn default() -> Self {
        PersonAndOrganizationItem::Action(EntityRef::default())
    }
}
impl From<Parameter> for PersonAndOrganizationItem {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EntityRef(id) => PersonAndOrganizationItem::EntityRef(EntityRef(id)),
                _ => panic!("parameter is not an instance"),
            },
            _ => panic!("parameter is not recognized"),
        }
    }
}
#[derive(Debug)]
pub enum PersonOrganizationSelect {
    EntityRef(EntityRef),
    Person(EntityRef),
    Organization(EntityRef),
    PersonAndOrganization(EntityRef),
}
impl Default for PersonOrganizationSelect {
    fn default() -> Self {
        PersonOrganizationSelect::Person(EntityRef::default())
    }
}
impl From<Parameter> for PersonOrganizationSelect {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EntityRef(id) => PersonOrganizationSelect::EntityRef(EntityRef(id)),
                _ => panic!("parameter is not an instance"),
            },
            _ => panic!("parameter is not recognized"),
        }
    }
}
type PlaneAngleMeasure = Real;
#[derive(Debug)]
pub enum PlaneOrPlanarBox {
    EntityRef(EntityRef),
    Plane(EntityRef),
    PlanarBox(EntityRef),
}
impl Default for PlaneOrPlanarBox {
    fn default() -> Self {
        PlaneOrPlanarBox::Plane(EntityRef::default())
    }
}
impl From<Parameter> for PlaneOrPlanarBox {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EntityRef(id) => PlaneOrPlanarBox::EntityRef(EntityRef(id)),
                _ => panic!("parameter is not an instance"),
            },
            _ => panic!("parameter is not recognized"),
        }
    }
}
type PositiveLengthMeasure = NonNegativeLengthMeasure;
type PositivePlaneAngleMeasure = PlaneAngleMeasure;
type PositiveRatioMeasure = RatioMeasure;
#[derive(Eq, PartialEq, Hash, Debug)]
pub enum PreferredSurfaceCurveRepresentation {
    Curve3d,
    PcurveS1,
    PcurveS2,
}
impl Default for PreferredSurfaceCurveRepresentation {
    fn default() -> Self {
        PreferredSurfaceCurveRepresentation::Curve3d
    }
}
impl From<String> for PreferredSurfaceCurveRepresentation {
    fn from(value: String) -> Self {
        match value.as_str() {
            "CURVE_3D" => PreferredSurfaceCurveRepresentation::Curve3d,
            "PCURVE_S1" => PreferredSurfaceCurveRepresentation::PcurveS1,
            "PCURVE_S2" => PreferredSurfaceCurveRepresentation::PcurveS2,
            _ => panic!("{} is not a valid value", value),
        }
    }
}
impl From<Parameter> for PreferredSurfaceCurveRepresentation {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EnumValue(value) => value.into(),
                _ => panic!("parameter is not an enum value"),
            },
            Parameter::OmittedParameter => PreferredSurfaceCurveRepresentation::default(),
            _ => panic!("parameter is not an enum value"),
        }
    }
}
type PresentableText = String;
#[derive(Debug)]
pub enum PresentationRepresentationSelect {
    EntityRef(EntityRef),
    PresentationRepresentation(EntityRef),
    PresentationSet(EntityRef),
}
impl Default for PresentationRepresentationSelect {
    fn default() -> Self {
        PresentationRepresentationSelect::PresentationRepresentation(EntityRef::default())
    }
}
impl From<Parameter> for PresentationRepresentationSelect {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EntityRef(id) => PresentationRepresentationSelect::EntityRef(EntityRef(id)),
                _ => panic!("parameter is not an instance"),
            },
            _ => panic!("parameter is not recognized"),
        }
    }
}
#[derive(Debug)]
pub enum PresentationSizeAssignmentSelect {
    EntityRef(EntityRef),
    PresentationView(EntityRef),
    PresentationArea(EntityRef),
    AreaInSet(EntityRef),
}
impl Default for PresentationSizeAssignmentSelect {
    fn default() -> Self {
        PresentationSizeAssignmentSelect::PresentationView(EntityRef::default())
    }
}
impl From<Parameter> for PresentationSizeAssignmentSelect {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EntityRef(id) => PresentationSizeAssignmentSelect::EntityRef(EntityRef(id)),
                _ => panic!("parameter is not an instance"),
            },
            _ => panic!("parameter is not recognized"),
        }
    }
}
#[derive(Eq, PartialEq, Hash, Debug)]
pub enum PresentationStyleSelect {
    EntityRef(EntityRef),
    PreDefinedPresentationStyle(EntityRef),
    PointStyle(EntityRef),
    CurveStyle(EntityRef),
    SurfaceStyleUsage(EntityRef),
    SymbolStyle(EntityRef),
    FillAreaStyle(EntityRef),
    TextStyle(EntityRef),
    ApproximationTolerance(EntityRef),
    ExternallyDefinedStyle(EntityRef),
    NullStyle(NullStyle),
}
impl Default for PresentationStyleSelect {
    fn default() -> Self {
        PresentationStyleSelect::PreDefinedPresentationStyle(EntityRef::default())
    }
}
impl From<Parameter> for PresentationStyleSelect {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::TypedParameter(typed_parameter) => match typed_parameter.type_name.as_str() {
                "NULL_STYLE" => {
                    PresentationStyleSelect::NullStyle(typed_parameter.parameters.into_iter().next().unwrap().into())
                }
                _ => panic!("parameter type is not recognized: {}", typed_parameter.type_name),
            },
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EntityRef(id) => PresentationStyleSelect::EntityRef(EntityRef(id)),
                _ => panic!("parameter is not an instance"),
            },
            _ => panic!("parameter is not recognized"),
        }
    }
}
#[derive(Eq, PartialEq, Hash, Debug)]
pub enum PresentedItemSelect {
    EntityRef(EntityRef),
    Action(EntityRef),
    ActionMethod(EntityRef),
    ActionRelationship(EntityRef),
    ProductConcept(EntityRef),
    ProductConceptFeature(EntityRef),
    ProductConceptFeatureCategory(EntityRef),
    ProductDefinition(EntityRef),
    ProductDefinitionFormation(EntityRef),
    ProductDefinitionRelationship(EntityRef),
}
impl Default for PresentedItemSelect {
    fn default() -> Self {
        PresentedItemSelect::Action(EntityRef::default())
    }
}
impl From<Parameter> for PresentedItemSelect {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EntityRef(id) => PresentedItemSelect::EntityRef(EntityRef(id)),
                _ => panic!("parameter is not an instance"),
            },
            _ => panic!("parameter is not recognized"),
        }
    }
}
#[derive(Debug)]
pub enum ProductOrFormationOrDefinition {
    EntityRef(EntityRef),
    Product(EntityRef),
    ProductDefinitionFormation(EntityRef),
    ProductDefinition(EntityRef),
}
impl Default for ProductOrFormationOrDefinition {
    fn default() -> Self {
        ProductOrFormationOrDefinition::Product(EntityRef::default())
    }
}
impl From<Parameter> for ProductOrFormationOrDefinition {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EntityRef(id) => ProductOrFormationOrDefinition::EntityRef(EntityRef(id)),
                _ => panic!("parameter is not an instance"),
            },
            _ => panic!("parameter is not recognized"),
        }
    }
}
#[derive(Eq, PartialEq, Hash, Debug)]
pub enum ProductOrPresentationSpace {
    ProductShapeSpace,
    PresentationAreaSpace,
}
impl Default for ProductOrPresentationSpace {
    fn default() -> Self {
        ProductOrPresentationSpace::ProductShapeSpace
    }
}
impl From<String> for ProductOrPresentationSpace {
    fn from(value: String) -> Self {
        match value.as_str() {
            "PRODUCT_SHAPE_SPACE" => ProductOrPresentationSpace::ProductShapeSpace,
            "PRESENTATION_AREA_SPACE" => ProductOrPresentationSpace::PresentationAreaSpace,
            _ => panic!("{} is not a valid value", value),
        }
    }
}
impl From<Parameter> for ProductOrPresentationSpace {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EnumValue(value) => value.into(),
                _ => panic!("parameter is not an enum value"),
            },
            Parameter::OmittedParameter => ProductOrPresentationSpace::default(),
            _ => panic!("parameter is not an enum value"),
        }
    }
}
#[derive(Debug)]
pub enum PropertyOrShapeSelect {
    PropertyDefinition(EntityRef),
    ShapeDefinition(ShapeDefinition),
}
impl Default for PropertyOrShapeSelect {
    fn default() -> Self {
        PropertyOrShapeSelect::PropertyDefinition(EntityRef::default())
    }
}
impl From<Parameter> for PropertyOrShapeSelect {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::TypedParameter(typed_parameter) => match typed_parameter.type_name.as_str() {
                "SHAPE_DEFINITION" => PropertyOrShapeSelect::ShapeDefinition(
                    typed_parameter.parameters.into_iter().next().unwrap().into(),
                ),
                _ => panic!("parameter type is not recognized: {}", typed_parameter.type_name),
            },
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EntityRef(id) => PropertyOrShapeSelect::PropertyDefinition(EntityRef(id)),
                _ => panic!("parameter is not an instance"),
            },
            _ => panic!("parameter is not recognized"),
        }
    }
}
type RatioMeasure = Real;
#[derive(Eq, PartialEq, Hash, Debug)]
pub enum RenderingPropertiesSelect {
    EntityRef(EntityRef),
    SurfaceStyleReflectanceAmbient(EntityRef),
    SurfaceStyleTransparent(EntityRef),
}
impl Default for RenderingPropertiesSelect {
    fn default() -> Self {
        RenderingPropertiesSelect::SurfaceStyleReflectanceAmbient(EntityRef::default())
    }
}
impl From<Parameter> for RenderingPropertiesSelect {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EntityRef(id) => RenderingPropertiesSelect::EntityRef(EntityRef(id)),
                _ => panic!("parameter is not an instance"),
            },
            _ => panic!("parameter is not recognized"),
        }
    }
}
#[derive(Debug)]
pub enum RepresentedDefinition {
    EntityRef(EntityRef),
    GeneralProperty(EntityRef),
    PropertyDefinition(EntityRef),
    PropertyDefinitionRelationship(EntityRef),
    ShapeAspect(EntityRef),
    ShapeAspectRelationship(EntityRef),
}
impl Default for RepresentedDefinition {
    fn default() -> Self {
        RepresentedDefinition::GeneralProperty(EntityRef::default())
    }
}
impl From<Parameter> for RepresentedDefinition {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EntityRef(id) => RepresentedDefinition::EntityRef(EntityRef(id)),
                _ => panic!("parameter is not an instance"),
            },
            _ => panic!("parameter is not recognized"),
        }
    }
}
#[derive(Debug)]
pub enum ReversibleTopology {
    ReversibleTopologyItem(ReversibleTopologyItem),
    ListOfReversibleTopologyItem(ListOfReversibleTopologyItem),
    SetOfReversibleTopologyItem(SetOfReversibleTopologyItem),
}
impl Default for ReversibleTopology {
    fn default() -> Self {
        ReversibleTopology::ReversibleTopologyItem(ReversibleTopologyItem::default())
    }
}
impl From<Parameter> for ReversibleTopology {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::TypedParameter(typed_parameter) => match typed_parameter.type_name.as_str() {
                "REVERSIBLE_TOPOLOGY_ITEM" => ReversibleTopology::ReversibleTopologyItem(
                    typed_parameter.parameters.into_iter().next().unwrap().into(),
                ),
                "LIST_OF_REVERSIBLE_TOPOLOGY_ITEM" => ReversibleTopology::ListOfReversibleTopologyItem(
                    typed_parameter.parameters.into_iter().next().unwrap().into(),
                ),
                "SET_OF_REVERSIBLE_TOPOLOGY_ITEM" => ReversibleTopology::SetOfReversibleTopologyItem(
                    typed_parameter.parameters.into_iter().next().unwrap().into(),
                ),
                _ => panic!("parameter type is not recognized: {}", typed_parameter.type_name),
            },
            _ => panic!("parameter is not recognized"),
        }
    }
}
#[derive(Debug)]
pub enum ReversibleTopologyItem {
    EntityRef(EntityRef),
    Edge(EntityRef),
    Path(EntityRef),
    Face(EntityRef),
    FaceBound(EntityRef),
    ClosedShell(EntityRef),
    OpenShell(EntityRef),
}
impl Default for ReversibleTopologyItem {
    fn default() -> Self {
        ReversibleTopologyItem::Edge(EntityRef::default())
    }
}
impl From<Parameter> for ReversibleTopologyItem {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EntityRef(id) => ReversibleTopologyItem::EntityRef(EntityRef(id)),
                _ => panic!("parameter is not an instance"),
            },
            _ => panic!("parameter is not recognized"),
        }
    }
}
#[derive(Debug)]
pub enum RigidPlacement {
    Axis2Placement3d(EntityRef),
}
impl Default for RigidPlacement {
    fn default() -> Self {
        RigidPlacement::Axis2Placement3d(EntityRef::default())
    }
}
impl From<Parameter> for RigidPlacement {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EntityRef(id) => RigidPlacement::Axis2Placement3d(EntityRef(id)),
                _ => panic!("parameter is not an instance"),
            },
            _ => panic!("parameter is not recognized"),
        }
    }
}
#[derive(Debug)]
pub enum RoleSelect {
    EntityRef(EntityRef),
    ActionAssignment(EntityRef),
    ActionRequestAssignment(EntityRef),
    ApprovalAssignment(EntityRef),
    ApprovalDateTime(EntityRef),
    CertificationAssignment(EntityRef),
    ContractAssignment(EntityRef),
    DocumentReference(EntityRef),
    EffectivityAssignment(EntityRef),
    GroupAssignment(EntityRef),
    NameAssignment(EntityRef),
    SecurityClassificationAssignment(EntityRef),
}
impl Default for RoleSelect {
    fn default() -> Self {
        RoleSelect::ActionAssignment(EntityRef::default())
    }
}
impl From<Parameter> for RoleSelect {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EntityRef(id) => RoleSelect::EntityRef(EntityRef(id)),
                _ => panic!("parameter is not an instance"),
            },
            _ => panic!("parameter is not recognized"),
        }
    }
}
#[derive(Debug)]
pub enum RotationalRangeMeasure {
    PlaneAngleMeasure(PlaneAngleMeasure),
    UnlimitedRange(UnlimitedRange),
}
impl Default for RotationalRangeMeasure {
    fn default() -> Self {
        RotationalRangeMeasure::PlaneAngleMeasure(PlaneAngleMeasure::default())
    }
}
impl From<Parameter> for RotationalRangeMeasure {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::TypedParameter(typed_parameter) => match typed_parameter.type_name.as_str() {
                "PLANE_ANGLE_MEASURE" => RotationalRangeMeasure::PlaneAngleMeasure(
                    typed_parameter.parameters.into_iter().next().unwrap().into(),
                ),
                "UNLIMITED_RANGE" => RotationalRangeMeasure::UnlimitedRange(
                    typed_parameter.parameters.into_iter().next().unwrap().into(),
                ),
                _ => panic!("parameter type is not recognized: {}", typed_parameter.type_name),
            },
            _ => panic!("parameter is not recognized"),
        }
    }
}
type SecondInMinute = Real;
#[derive(Eq, PartialEq, Hash, Debug)]
pub enum SecurityClassificationItem {
    EntityRef(EntityRef),
    Action(EntityRef),
    ActionDirective(EntityRef),
    ActionProperty(EntityRef),
    AppliedActionAssignment(EntityRef),
    AssemblyComponentUsageSubstitute(EntityRef),
    ClassSystem(EntityRef),
    ConfigurationDesign(EntityRef),
    ConfigurationEffectivity(EntityRef),
    ConfiguredEffectivityAssignment(EntityRef),
    DocumentFile(EntityRef),
    DraughtingModel(EntityRef),
    DrawingRevision(EntityRef),
    ExecutedAction(EntityRef),
    GeneralProperty(EntityRef),
    MaterialDesignation(EntityRef),
    MechanicalDesignGeometricPresentationRepresentation(EntityRef),
    OrganizationalProject(EntityRef),
    PresentationArea(EntityRef),
    Product(EntityRef),
    ProductConcept(EntityRef),
    ProductConceptFeature(EntityRef),
    ProductConceptFeatureCategory(EntityRef),
    ProductDefinition(EntityRef),
    ProductDefinitionFormation(EntityRef),
    ProductDefinitionRelationship(EntityRef),
    PropertyDefinition(EntityRef),
    ResourceProperty(EntityRef),
    ShapeRepresentation(EntityRef),
    VersionedActionRequest(EntityRef),
}
impl Default for SecurityClassificationItem {
    fn default() -> Self {
        SecurityClassificationItem::Action(EntityRef::default())
    }
}
impl From<Parameter> for SecurityClassificationItem {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EntityRef(id) => SecurityClassificationItem::EntityRef(EntityRef(id)),
                _ => panic!("parameter is not an instance"),
            },
            _ => panic!("parameter is not recognized"),
        }
    }
}
type SetOfReversibleTopologyItem = HashSet<EntityRef>;
type SetRepresentationItem = HashSet<EntityRef>;
#[derive(Eq, PartialEq, Hash, Debug)]
pub enum ShadingCurveMethod {
    ConstantColour,
    LinearColour,
}
impl Default for ShadingCurveMethod {
    fn default() -> Self {
        ShadingCurveMethod::ConstantColour
    }
}
impl From<String> for ShadingCurveMethod {
    fn from(value: String) -> Self {
        match value.as_str() {
            "CONSTANT_COLOUR" => ShadingCurveMethod::ConstantColour,
            "LINEAR_COLOUR" => ShadingCurveMethod::LinearColour,
            _ => panic!("{} is not a valid value", value),
        }
    }
}
impl From<Parameter> for ShadingCurveMethod {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EnumValue(value) => value.into(),
                _ => panic!("parameter is not an enum value"),
            },
            Parameter::OmittedParameter => ShadingCurveMethod::default(),
            _ => panic!("parameter is not an enum value"),
        }
    }
}
#[derive(Eq, PartialEq, Hash, Debug)]
pub enum ShadingSurfaceMethod {
    ConstantShading,
    ColourShading,
    DotShading,
    NormalShading,
}
impl Default for ShadingSurfaceMethod {
    fn default() -> Self {
        ShadingSurfaceMethod::ConstantShading
    }
}
impl From<String> for ShadingSurfaceMethod {
    fn from(value: String) -> Self {
        match value.as_str() {
            "CONSTANT_SHADING" => ShadingSurfaceMethod::ConstantShading,
            "COLOUR_SHADING" => ShadingSurfaceMethod::ColourShading,
            "DOT_SHADING" => ShadingSurfaceMethod::DotShading,
            "NORMAL_SHADING" => ShadingSurfaceMethod::NormalShading,
            _ => panic!("{} is not a valid value", value),
        }
    }
}
impl From<Parameter> for ShadingSurfaceMethod {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EnumValue(value) => value.into(),
                _ => panic!("parameter is not an enum value"),
            },
            Parameter::OmittedParameter => ShadingSurfaceMethod::default(),
            _ => panic!("parameter is not an enum value"),
        }
    }
}
#[derive(Eq, PartialEq, Hash, Debug)]
pub enum ShapeDefinition {
    EntityRef(EntityRef),
    ProductDefinitionShape(EntityRef),
    ShapeAspect(EntityRef),
    ShapeAspectRelationship(EntityRef),
}
impl Default for ShapeDefinition {
    fn default() -> Self {
        ShapeDefinition::ProductDefinitionShape(EntityRef::default())
    }
}
impl From<Parameter> for ShapeDefinition {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EntityRef(id) => ShapeDefinition::EntityRef(EntityRef(id)),
                _ => panic!("parameter is not an instance"),
            },
            _ => panic!("parameter is not recognized"),
        }
    }
}
#[derive(Eq, PartialEq, Hash, Debug)]
pub enum Shell {
    EntityRef(EntityRef),
    OpenShell(EntityRef),
    ClosedShell(EntityRef),
}
impl Default for Shell {
    fn default() -> Self {
        Shell::OpenShell(EntityRef::default())
    }
}
impl From<Parameter> for Shell {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EntityRef(id) => Shell::EntityRef(EntityRef(id)),
                _ => panic!("parameter is not an instance"),
            },
            _ => panic!("parameter is not recognized"),
        }
    }
}
#[derive(Eq, PartialEq, Hash, Debug)]
pub enum SiPrefix {
    Exa,
    Peta,
    Tera,
    Giga,
    Mega,
    Kilo,
    Hecto,
    Deca,
    Deci,
    Centi,
    Milli,
    Micro,
    Nano,
    Pico,
    Femto,
    Atto,
}
impl Default for SiPrefix {
    fn default() -> Self {
        SiPrefix::Exa
    }
}
impl From<String> for SiPrefix {
    fn from(value: String) -> Self {
        match value.as_str() {
            "EXA" => SiPrefix::Exa,
            "PETA" => SiPrefix::Peta,
            "TERA" => SiPrefix::Tera,
            "GIGA" => SiPrefix::Giga,
            "MEGA" => SiPrefix::Mega,
            "KILO" => SiPrefix::Kilo,
            "HECTO" => SiPrefix::Hecto,
            "DECA" => SiPrefix::Deca,
            "DECI" => SiPrefix::Deci,
            "CENTI" => SiPrefix::Centi,
            "MILLI" => SiPrefix::Milli,
            "MICRO" => SiPrefix::Micro,
            "NANO" => SiPrefix::Nano,
            "PICO" => SiPrefix::Pico,
            "FEMTO" => SiPrefix::Femto,
            "ATTO" => SiPrefix::Atto,
            _ => panic!("{} is not a valid value", value),
        }
    }
}
impl From<Parameter> for SiPrefix {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EnumValue(value) => value.into(),
                _ => panic!("parameter is not an enum value"),
            },
            Parameter::OmittedParameter => SiPrefix::default(),
            _ => panic!("parameter is not an enum value"),
        }
    }
}
#[derive(Eq, PartialEq, Hash, Debug)]
pub enum SiUnitName {
    Metre,
    Gram,
    Second,
    Ampere,
    Kelvin,
    Mole,
    Candela,
    Radian,
    Steradian,
    Hertz,
    Newton,
    Pascal,
    Joule,
    Watt,
    Coulomb,
    Volt,
    Farad,
    Ohm,
    Siemens,
    Weber,
    Tesla,
    Henry,
    DegreeCelsius,
    Lumen,
    Lux,
    Becquerel,
    Gray,
    Sievert,
}
impl Default for SiUnitName {
    fn default() -> Self {
        SiUnitName::Metre
    }
}
impl From<String> for SiUnitName {
    fn from(value: String) -> Self {
        match value.as_str() {
            "METRE" => SiUnitName::Metre,
            "GRAM" => SiUnitName::Gram,
            "SECOND" => SiUnitName::Second,
            "AMPERE" => SiUnitName::Ampere,
            "KELVIN" => SiUnitName::Kelvin,
            "MOLE" => SiUnitName::Mole,
            "CANDELA" => SiUnitName::Candela,
            "RADIAN" => SiUnitName::Radian,
            "STERADIAN" => SiUnitName::Steradian,
            "HERTZ" => SiUnitName::Hertz,
            "NEWTON" => SiUnitName::Newton,
            "PASCAL" => SiUnitName::Pascal,
            "JOULE" => SiUnitName::Joule,
            "WATT" => SiUnitName::Watt,
            "COULOMB" => SiUnitName::Coulomb,
            "VOLT" => SiUnitName::Volt,
            "FARAD" => SiUnitName::Farad,
            "OHM" => SiUnitName::Ohm,
            "SIEMENS" => SiUnitName::Siemens,
            "WEBER" => SiUnitName::Weber,
            "TESLA" => SiUnitName::Tesla,
            "HENRY" => SiUnitName::Henry,
            "DEGREE_CELSIUS" => SiUnitName::DegreeCelsius,
            "LUMEN" => SiUnitName::Lumen,
            "LUX" => SiUnitName::Lux,
            "BECQUEREL" => SiUnitName::Becquerel,
            "GRAY" => SiUnitName::Gray,
            "SIEVERT" => SiUnitName::Sievert,
            _ => panic!("{} is not a valid value", value),
        }
    }
}
impl From<Parameter> for SiUnitName {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EnumValue(value) => value.into(),
                _ => panic!("parameter is not an enum value"),
            },
            Parameter::OmittedParameter => SiUnitName::default(),
            _ => panic!("parameter is not an enum value"),
        }
    }
}
#[derive(Debug)]
pub enum SizeSelect {
    PositiveLengthMeasure(PositiveLengthMeasure),
    MeasureWithUnit(EntityRef),
    DescriptiveMeasure(DescriptiveMeasure),
}
impl Default for SizeSelect {
    fn default() -> Self {
        SizeSelect::PositiveLengthMeasure(PositiveLengthMeasure::default())
    }
}
impl From<Parameter> for SizeSelect {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::TypedParameter(typed_parameter) => match typed_parameter.type_name.as_str() {
                "POSITIVE_LENGTH_MEASURE" => {
                    SizeSelect::PositiveLengthMeasure(typed_parameter.parameters.into_iter().next().unwrap().into())
                }
                "DESCRIPTIVE_MEASURE" => {
                    SizeSelect::DescriptiveMeasure(typed_parameter.parameters.into_iter().next().unwrap().into())
                }
                _ => panic!("parameter type is not recognized: {}", typed_parameter.type_name),
            },
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EntityRef(id) => SizeSelect::MeasureWithUnit(EntityRef(id)),
                _ => panic!("parameter is not an instance"),
            },
            _ => panic!("parameter is not recognized"),
        }
    }
}
type SolidAngleMeasure = Real;
#[derive(Eq, PartialEq, Hash, Debug)]
pub enum Source {
    Made,
    Bought,
    NotKnown,
}
impl Default for Source {
    fn default() -> Self {
        Source::Made
    }
}
impl From<String> for Source {
    fn from(value: String) -> Self {
        match value.as_str() {
            "MADE" => Source::Made,
            "BOUGHT" => Source::Bought,
            "NOT_KNOWN" => Source::NotKnown,
            _ => panic!("{} is not a valid value", value),
        }
    }
}
impl From<Parameter> for Source {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EnumValue(value) => value.into(),
                _ => panic!("parameter is not an enum value"),
            },
            Parameter::OmittedParameter => Source::default(),
            _ => panic!("parameter is not an enum value"),
        }
    }
}
#[derive(Debug)]
pub enum SourceItem {
    Identifier(Identifier),
}
impl Default for SourceItem {
    fn default() -> Self {
        SourceItem::Identifier(Identifier::default())
    }
}
impl From<Parameter> for SourceItem {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::TypedParameter(typed_parameter) => match typed_parameter.type_name.as_str() {
                "IDENTIFIER" => SourceItem::Identifier(typed_parameter.parameters.into_iter().next().unwrap().into()),
                _ => panic!("parameter type is not recognized: {}", typed_parameter.type_name),
            },
            _ => panic!("parameter is not recognized"),
        }
    }
}
#[derive(Debug)]
pub enum SpatialRotation {
    YprRotation(YprRotation),
    RotationAboutDirection(EntityRef),
}
impl Default for SpatialRotation {
    fn default() -> Self {
        SpatialRotation::YprRotation(YprRotation::default())
    }
}
impl From<Parameter> for SpatialRotation {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::TypedParameter(typed_parameter) => match typed_parameter.type_name.as_str() {
                "YPR_ROTATION" => {
                    SpatialRotation::YprRotation(typed_parameter.parameters.into_iter().next().unwrap().into())
                }
                _ => panic!("parameter type is not recognized: {}", typed_parameter.type_name),
            },
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EntityRef(id) => SpatialRotation::RotationAboutDirection(EntityRef(id)),
                _ => panic!("parameter is not an instance"),
            },
            _ => panic!("parameter is not recognized"),
        }
    }
}
#[derive(Eq, PartialEq, Hash, Debug)]
pub enum SpecifiedItem {
    DrawingRevision(EntityRef),
}
impl Default for SpecifiedItem {
    fn default() -> Self {
        SpecifiedItem::DrawingRevision(EntityRef::default())
    }
}
impl From<Parameter> for SpecifiedItem {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EntityRef(id) => SpecifiedItem::DrawingRevision(EntityRef(id)),
                _ => panic!("parameter is not an instance"),
            },
            _ => panic!("parameter is not recognized"),
        }
    }
}
#[derive(Debug)]
pub enum StyleContextSelect {
    EntityRef(EntityRef),
    Group(EntityRef),
    PresentationLayerAssignment(EntityRef),
    PresentationSet(EntityRef),
    Representation(EntityRef),
    RepresentationItem(EntityRef),
    ShapeRepresentationRelationship(EntityRef),
}
impl Default for StyleContextSelect {
    fn default() -> Self {
        StyleContextSelect::Group(EntityRef::default())
    }
}
impl From<Parameter> for StyleContextSelect {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EntityRef(id) => StyleContextSelect::EntityRef(EntityRef(id)),
                _ => panic!("parameter is not an instance"),
            },
            _ => panic!("parameter is not recognized"),
        }
    }
}
#[derive(Eq, PartialEq, Hash, Debug)]
pub enum SupportedItem {
    EntityRef(EntityRef),
    ActionDirective(EntityRef),
    Action(EntityRef),
    ActionMethod(EntityRef),
}
impl Default for SupportedItem {
    fn default() -> Self {
        SupportedItem::ActionDirective(EntityRef::default())
    }
}
impl From<Parameter> for SupportedItem {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EntityRef(id) => SupportedItem::EntityRef(EntityRef(id)),
                _ => panic!("parameter is not an instance"),
            },
            _ => panic!("parameter is not recognized"),
        }
    }
}
#[derive(Eq, PartialEq, Hash, Debug)]
pub enum SurfaceSide {
    Positive,
    Negative,
    Both,
}
impl Default for SurfaceSide {
    fn default() -> Self {
        SurfaceSide::Positive
    }
}
impl From<String> for SurfaceSide {
    fn from(value: String) -> Self {
        match value.as_str() {
            "POSITIVE" => SurfaceSide::Positive,
            "NEGATIVE" => SurfaceSide::Negative,
            "BOTH" => SurfaceSide::Both,
            _ => panic!("{} is not a valid value", value),
        }
    }
}
impl From<Parameter> for SurfaceSide {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EnumValue(value) => value.into(),
                _ => panic!("parameter is not an enum value"),
            },
            Parameter::OmittedParameter => SurfaceSide::default(),
            _ => panic!("parameter is not an enum value"),
        }
    }
}
#[derive(Debug)]
pub enum SurfaceSideStyleSelect {
    SurfaceSideStyle(EntityRef),
}
impl Default for SurfaceSideStyleSelect {
    fn default() -> Self {
        SurfaceSideStyleSelect::SurfaceSideStyle(EntityRef::default())
    }
}
impl From<Parameter> for SurfaceSideStyleSelect {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EntityRef(id) => SurfaceSideStyleSelect::SurfaceSideStyle(EntityRef(id)),
                _ => panic!("parameter is not an instance"),
            },
            _ => panic!("parameter is not recognized"),
        }
    }
}
#[derive(Eq, PartialEq, Hash, Debug)]
pub enum SurfaceStyleElementSelect {
    EntityRef(EntityRef),
    SurfaceStyleFillArea(EntityRef),
    SurfaceStyleBoundary(EntityRef),
    SurfaceStyleSilhouette(EntityRef),
    SurfaceStyleSegmentationCurve(EntityRef),
    SurfaceStyleControlGrid(EntityRef),
    SurfaceStyleParameterLine(EntityRef),
    SurfaceStyleRendering(EntityRef),
}
impl Default for SurfaceStyleElementSelect {
    fn default() -> Self {
        SurfaceStyleElementSelect::SurfaceStyleFillArea(EntityRef::default())
    }
}
impl From<Parameter> for SurfaceStyleElementSelect {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EntityRef(id) => SurfaceStyleElementSelect::EntityRef(EntityRef(id)),
                _ => panic!("parameter is not an instance"),
            },
            _ => panic!("parameter is not recognized"),
        }
    }
}
type SurfaceToleranceDeviation = PositiveLengthMeasure;
type SurfaceToleranceParameter = Real;
#[derive(Debug)]
pub enum SymbolStyleSelect {
    SymbolColour(EntityRef),
}
impl Default for SymbolStyleSelect {
    fn default() -> Self {
        SymbolStyleSelect::SymbolColour(EntityRef::default())
    }
}
impl From<Parameter> for SymbolStyleSelect {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EntityRef(id) => SymbolStyleSelect::SymbolColour(EntityRef(id)),
                _ => panic!("parameter is not an instance"),
            },
            _ => panic!("parameter is not recognized"),
        }
    }
}
type Text = String;
type TextAlignment = Label;
type TextDelineation = Label;
#[derive(Eq, PartialEq, Hash, Debug)]
pub enum TextOrCharacter {
    EntityRef(EntityRef),
    AnnotationText(EntityRef),
    AnnotationTextCharacter(EntityRef),
    DefinedCharacterGlyph(EntityRef),
    CompositeText(EntityRef),
    TextLiteral(EntityRef),
}
impl Default for TextOrCharacter {
    fn default() -> Self {
        TextOrCharacter::AnnotationText(EntityRef::default())
    }
}
impl From<Parameter> for TextOrCharacter {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EntityRef(id) => TextOrCharacter::EntityRef(EntityRef(id)),
                _ => panic!("parameter is not an instance"),
            },
            _ => panic!("parameter is not recognized"),
        }
    }
}
#[derive(Eq, PartialEq, Hash, Debug)]
pub enum TextPath {
    Left,
    Right,
    Up,
    Down,
}
impl Default for TextPath {
    fn default() -> Self {
        TextPath::Left
    }
}
impl From<String> for TextPath {
    fn from(value: String) -> Self {
        match value.as_str() {
            "LEFT" => TextPath::Left,
            "RIGHT" => TextPath::Right,
            "UP" => TextPath::Up,
            "DOWN" => TextPath::Down,
            _ => panic!("{} is not a valid value", value),
        }
    }
}
impl From<Parameter> for TextPath {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EnumValue(value) => value.into(),
                _ => panic!("parameter is not an enum value"),
            },
            Parameter::OmittedParameter => TextPath::default(),
            _ => panic!("parameter is not an enum value"),
        }
    }
}
#[derive(Eq, PartialEq, Hash, Debug)]
pub enum TextStringRepresentationItem {
    EntityRef(EntityRef),
    TextLiteral(EntityRef),
    AnnotationText(EntityRef),
    AnnotationTextCharacter(EntityRef),
    DefinedCharacterGlyph(EntityRef),
    CompositeText(EntityRef),
    Axis2Placement(Axis2Placement),
}
impl Default for TextStringRepresentationItem {
    fn default() -> Self {
        TextStringRepresentationItem::TextLiteral(EntityRef::default())
    }
}
impl From<Parameter> for TextStringRepresentationItem {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::TypedParameter(typed_parameter) => match typed_parameter.type_name.as_str() {
                "AXIS2_PLACEMENT" => TextStringRepresentationItem::Axis2Placement(
                    typed_parameter.parameters.into_iter().next().unwrap().into(),
                ),
                _ => panic!("parameter type is not recognized: {}", typed_parameter.type_name),
            },
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EntityRef(id) => TextStringRepresentationItem::EntityRef(EntityRef(id)),
                _ => panic!("parameter is not an instance"),
            },
            _ => panic!("parameter is not recognized"),
        }
    }
}
type ThermodynamicTemperatureMeasure = Real;
#[derive(Eq, PartialEq, Hash, Debug)]
pub enum TimeIntervalItem {
    EntityRef(EntityRef),
    Action(EntityRef),
    ActionDirective(EntityRef),
    ActionMethod(EntityRef),
    ActionProperty(EntityRef),
    ActionRelationship(EntityRef),
    ActionRequestSolution(EntityRef),
    AlternateProductRelationship(EntityRef),
    AppliedActionAssignment(EntityRef),
    AppliedClassificationAssignment(EntityRef),
    AppliedPersonAndOrganizationAssignment(EntityRef),
    ApprovalStatus(EntityRef),
    AssemblyComponentUsageSubstitute(EntityRef),
    Certification(EntityRef),
    Class(EntityRef),
    ClassSystem(EntityRef),
    ConfigurationDesign(EntityRef),
    ConfigurationEffectivity(EntityRef),
    ConfigurationItem(EntityRef),
    ConfiguredEffectivityAssignment(EntityRef),
    Contract(EntityRef),
    DocumentFile(EntityRef),
    DraughtingModel(EntityRef),
    DrawingRevision(EntityRef),
    ExecutedAction(EntityRef),
    GeneralProperty(EntityRef),
    MaterialDesignation(EntityRef),
    MechanicalDesignGeometricPresentationRepresentation(EntityRef),
    OrganizationRelationship(EntityRef),
    OrganizationalProject(EntityRef),
    PersonAndOrganization(EntityRef),
    PresentationArea(EntityRef),
    Product(EntityRef),
    ProductConcept(EntityRef),
    ProductConceptFeature(EntityRef),
    ProductConceptFeatureAssociation(EntityRef),
    ProductConceptFeatureCategory(EntityRef),
    ProductConceptFeatureCategoryUsage(EntityRef),
    ProductDefinition(EntityRef),
    ProductDefinitionFormation(EntityRef),
    ProductDefinitionFormationRelationship(EntityRef),
    ProductDefinitionRelationship(EntityRef),
    ProductDefinitionSubstitute(EntityRef),
    PropertyDefinition(EntityRef),
    RequirementForActionResource(EntityRef),
    ResourceProperty(EntityRef),
    SecurityClassification(EntityRef),
    SecurityClassificationLevel(EntityRef),
    ShapeRepresentation(EntityRef),
    VersionedActionRequest(EntityRef),
}
impl Default for TimeIntervalItem {
    fn default() -> Self {
        TimeIntervalItem::Action(EntityRef::default())
    }
}
impl From<Parameter> for TimeIntervalItem {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EntityRef(id) => TimeIntervalItem::EntityRef(EntityRef(id)),
                _ => panic!("parameter is not an instance"),
            },
            _ => panic!("parameter is not recognized"),
        }
    }
}
type TimeMeasure = Real;
#[derive(Eq, PartialEq, Hash, Debug)]
pub enum ToleranceDeviationSelect {
    CurveToleranceDeviation(CurveToleranceDeviation),
    SurfaceToleranceDeviation(SurfaceToleranceDeviation),
}
impl Default for ToleranceDeviationSelect {
    fn default() -> Self {
        ToleranceDeviationSelect::CurveToleranceDeviation(CurveToleranceDeviation::default())
    }
}
impl From<Parameter> for ToleranceDeviationSelect {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::TypedParameter(typed_parameter) => match typed_parameter.type_name.as_str() {
                "CURVE_TOLERANCE_DEVIATION" => ToleranceDeviationSelect::CurveToleranceDeviation(
                    typed_parameter.parameters.into_iter().next().unwrap().into(),
                ),
                "SURFACE_TOLERANCE_DEVIATION" => ToleranceDeviationSelect::SurfaceToleranceDeviation(
                    typed_parameter.parameters.into_iter().next().unwrap().into(),
                ),
                _ => panic!("parameter type is not recognized: {}", typed_parameter.type_name),
            },
            _ => panic!("parameter is not recognized"),
        }
    }
}
#[derive(Debug)]
pub enum ToleranceMethodDefinition {
    EntityRef(EntityRef),
    ToleranceValue(EntityRef),
    LimitsAndFits(EntityRef),
}
impl Default for ToleranceMethodDefinition {
    fn default() -> Self {
        ToleranceMethodDefinition::ToleranceValue(EntityRef::default())
    }
}
impl From<Parameter> for ToleranceMethodDefinition {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EntityRef(id) => ToleranceMethodDefinition::EntityRef(EntityRef(id)),
                _ => panic!("parameter is not an instance"),
            },
            _ => panic!("parameter is not recognized"),
        }
    }
}
#[derive(Eq, PartialEq, Hash, Debug)]
pub enum ToleranceParameterSelect {
    CurveToleranceParameter(CurveToleranceParameter),
    SurfaceToleranceParameter(SurfaceToleranceParameter),
}
impl Default for ToleranceParameterSelect {
    fn default() -> Self {
        ToleranceParameterSelect::CurveToleranceParameter(CurveToleranceParameter::default())
    }
}
impl From<Parameter> for ToleranceParameterSelect {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::TypedParameter(typed_parameter) => match typed_parameter.type_name.as_str() {
                "CURVE_TOLERANCE_PARAMETER" => ToleranceParameterSelect::CurveToleranceParameter(
                    typed_parameter.parameters.into_iter().next().unwrap().into(),
                ),
                "SURFACE_TOLERANCE_PARAMETER" => ToleranceParameterSelect::SurfaceToleranceParameter(
                    typed_parameter.parameters.into_iter().next().unwrap().into(),
                ),
                _ => panic!("parameter type is not recognized: {}", typed_parameter.type_name),
            },
            _ => panic!("parameter is not recognized"),
        }
    }
}
#[derive(Debug)]
pub enum ToleranceSelect {
    EntityRef(EntityRef),
    ApproximationToleranceDeviation(EntityRef),
    ApproximationToleranceParameter(EntityRef),
}
impl Default for ToleranceSelect {
    fn default() -> Self {
        ToleranceSelect::ApproximationToleranceDeviation(EntityRef::default())
    }
}
impl From<Parameter> for ToleranceSelect {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EntityRef(id) => ToleranceSelect::EntityRef(EntityRef(id)),
                _ => panic!("parameter is not an instance"),
            },
            _ => panic!("parameter is not recognized"),
        }
    }
}
#[derive(Debug)]
pub enum Transformation {
    EntityRef(EntityRef),
    ItemDefinedTransformation(EntityRef),
    FunctionallyDefinedTransformation(EntityRef),
}
impl Default for Transformation {
    fn default() -> Self {
        Transformation::ItemDefinedTransformation(EntityRef::default())
    }
}
impl From<Parameter> for Transformation {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EntityRef(id) => Transformation::EntityRef(EntityRef(id)),
                _ => panic!("parameter is not an instance"),
            },
            _ => panic!("parameter is not recognized"),
        }
    }
}
#[derive(Eq, PartialEq, Hash, Debug)]
pub enum TransitionCode {
    Discontinuous,
    Continuous,
    ContSameGradient,
    ContSameGradientSameCurvature,
}
impl Default for TransitionCode {
    fn default() -> Self {
        TransitionCode::Discontinuous
    }
}
impl From<String> for TransitionCode {
    fn from(value: String) -> Self {
        match value.as_str() {
            "DISCONTINUOUS" => TransitionCode::Discontinuous,
            "CONTINUOUS" => TransitionCode::Continuous,
            "CONT_SAME_GRADIENT" => TransitionCode::ContSameGradient,
            "CONT_SAME_GRADIENT_SAME_CURVATURE" => TransitionCode::ContSameGradientSameCurvature,
            _ => panic!("{} is not a valid value", value),
        }
    }
}
impl From<Parameter> for TransitionCode {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EnumValue(value) => value.into(),
                _ => panic!("parameter is not an enum value"),
            },
            Parameter::OmittedParameter => TransitionCode::default(),
            _ => panic!("parameter is not an enum value"),
        }
    }
}
#[derive(Debug)]
pub enum TranslationalRangeMeasure {
    LengthMeasure(LengthMeasure),
    UnlimitedRange(UnlimitedRange),
}
impl Default for TranslationalRangeMeasure {
    fn default() -> Self {
        TranslationalRangeMeasure::LengthMeasure(LengthMeasure::default())
    }
}
impl From<Parameter> for TranslationalRangeMeasure {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::TypedParameter(typed_parameter) => match typed_parameter.type_name.as_str() {
                "LENGTH_MEASURE" => TranslationalRangeMeasure::LengthMeasure(
                    typed_parameter.parameters.into_iter().next().unwrap().into(),
                ),
                "UNLIMITED_RANGE" => TranslationalRangeMeasure::UnlimitedRange(
                    typed_parameter.parameters.into_iter().next().unwrap().into(),
                ),
                _ => panic!("parameter type is not recognized: {}", typed_parameter.type_name),
            },
            _ => panic!("parameter is not recognized"),
        }
    }
}
#[derive(Eq, PartialEq, Hash, Debug)]
pub enum TrimmingPreference {
    Cartesian,
    Parameter,
    Unspecified,
}
impl Default for TrimmingPreference {
    fn default() -> Self {
        TrimmingPreference::Cartesian
    }
}
impl From<String> for TrimmingPreference {
    fn from(value: String) -> Self {
        match value.as_str() {
            "CARTESIAN" => TrimmingPreference::Cartesian,
            "PARAMETER" => TrimmingPreference::Parameter,
            "UNSPECIFIED" => TrimmingPreference::Unspecified,
            _ => panic!("{} is not a valid value", value),
        }
    }
}
impl From<Parameter> for TrimmingPreference {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EnumValue(value) => value.into(),
                _ => panic!("parameter is not an enum value"),
            },
            Parameter::OmittedParameter => TrimmingPreference::default(),
            _ => panic!("parameter is not an enum value"),
        }
    }
}
#[derive(Eq, PartialEq, Hash, Debug)]
pub enum TrimmingSelect {
    CartesianPoint(EntityRef),
    ParameterValue(ParameterValue),
}
impl Default for TrimmingSelect {
    fn default() -> Self {
        TrimmingSelect::CartesianPoint(EntityRef::default())
    }
}
impl From<Parameter> for TrimmingSelect {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::TypedParameter(typed_parameter) => match typed_parameter.type_name.as_str() {
                "PARAMETER_VALUE" => {
                    TrimmingSelect::ParameterValue(typed_parameter.parameters.into_iter().next().unwrap().into())
                }
                _ => panic!("parameter type is not recognized: {}", typed_parameter.type_name),
            },
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EntityRef(id) => TrimmingSelect::CartesianPoint(EntityRef(id)),
                _ => panic!("parameter is not an instance"),
            },
            _ => panic!("parameter is not recognized"),
        }
    }
}
type UDirectionCount = i64;
#[derive(Eq, PartialEq, Hash, Debug)]
pub enum Unit {
    EntityRef(EntityRef),
    DerivedUnit(EntityRef),
    NamedUnit(EntityRef),
}
impl Default for Unit {
    fn default() -> Self {
        Unit::DerivedUnit(EntityRef::default())
    }
}
impl From<Parameter> for Unit {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EntityRef(id) => Unit::EntityRef(EntityRef(id)),
                _ => panic!("parameter is not an instance"),
            },
            _ => panic!("parameter is not recognized"),
        }
    }
}
#[derive(Eq, PartialEq, Hash, Debug)]
pub enum UnlimitedRange {
    Unlimited,
}
impl Default for UnlimitedRange {
    fn default() -> Self {
        UnlimitedRange::Unlimited
    }
}
impl From<String> for UnlimitedRange {
    fn from(value: String) -> Self {
        match value.as_str() {
            "UNLIMITED" => UnlimitedRange::Unlimited,
            _ => panic!("{} is not a valid value", value),
        }
    }
}
impl From<Parameter> for UnlimitedRange {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EnumValue(value) => value.into(),
                _ => panic!("parameter is not an enum value"),
            },
            Parameter::OmittedParameter => UnlimitedRange::default(),
            _ => panic!("parameter is not an enum value"),
        }
    }
}
type VDirectionCount = i64;
#[derive(Eq, PartialEq, Hash, Debug)]
pub enum ValueQualifier {
    EntityRef(EntityRef),
    PrecisionQualifier(EntityRef),
    TypeQualifier(EntityRef),
    UncertaintyQualifier(EntityRef),
}
impl Default for ValueQualifier {
    fn default() -> Self {
        ValueQualifier::PrecisionQualifier(EntityRef::default())
    }
}
impl From<Parameter> for ValueQualifier {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EntityRef(id) => ValueQualifier::EntityRef(EntityRef(id)),
                _ => panic!("parameter is not an instance"),
            },
            _ => panic!("parameter is not recognized"),
        }
    }
}
#[derive(Debug)]
pub enum VectorOrDirection {
    EntityRef(EntityRef),
    Vector(EntityRef),
    Direction(EntityRef),
}
impl Default for VectorOrDirection {
    fn default() -> Self {
        VectorOrDirection::Vector(EntityRef::default())
    }
}
impl From<Parameter> for VectorOrDirection {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EntityRef(id) => VectorOrDirection::EntityRef(EntityRef(id)),
                _ => panic!("parameter is not an instance"),
            },
            _ => panic!("parameter is not recognized"),
        }
    }
}
type VolumeMeasure = Real;
type YearNumber = i64;
#[derive(Eq, PartialEq, Hash, Debug)]
pub enum YprEnumeration {
    Yaw,
    Pitch,
    Roll,
}
impl Default for YprEnumeration {
    fn default() -> Self {
        YprEnumeration::Yaw
    }
}
impl From<String> for YprEnumeration {
    fn from(value: String) -> Self {
        match value.as_str() {
            "YAW" => YprEnumeration::Yaw,
            "PITCH" => YprEnumeration::Pitch,
            "ROLL" => YprEnumeration::Roll,
            _ => panic!("{} is not a valid value", value),
        }
    }
}
impl From<Parameter> for YprEnumeration {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EnumValue(value) => value.into(),
                _ => panic!("parameter is not an enum value"),
            },
            Parameter::OmittedParameter => YprEnumeration::default(),
            _ => panic!("parameter is not an enum value"),
        }
    }
}
type YprRotation = Vec<PlaneAngleMeasure>;
pub trait IAbsFunction: IUnaryFunctionCall {}
#[derive(Default, Debug)]
pub struct AbsFunction {
    operand: EntityRef,
}
impl IGenericExpression for AbsFunction {}
impl IExpression for AbsFunction {}
impl INumericExpression for AbsFunction {}
impl IUnaryNumericExpression for AbsFunction {
    fn operand(&self) -> &EntityRef {
        &self.operand
    }
}
impl IUnaryGenericExpression for AbsFunction {
    fn operand(&self) -> &EntityRef {
        &self.operand
    }
}
impl IUnaryFunctionCall for AbsFunction {}
impl IAbsFunction for AbsFunction {}
impl AbsFunction {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = AbsFunction::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.operand = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IAcosFunction: IUnaryFunctionCall {}
#[derive(Default, Debug)]
pub struct AcosFunction {
    operand: EntityRef,
}
impl IGenericExpression for AcosFunction {}
impl IExpression for AcosFunction {}
impl INumericExpression for AcosFunction {}
impl IUnaryNumericExpression for AcosFunction {
    fn operand(&self) -> &EntityRef {
        &self.operand
    }
}
impl IUnaryGenericExpression for AcosFunction {
    fn operand(&self) -> &EntityRef {
        &self.operand
    }
}
impl IUnaryFunctionCall for AcosFunction {}
impl IAcosFunction for AcosFunction {}
impl AcosFunction {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = AcosFunction::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.operand = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IAction {
    fn name(&self) -> &Label;
    fn description(&self) -> &Option<Text>;
    fn chosen_method(&self) -> &EntityRef;
}
#[derive(Default, Debug)]
pub struct Action {
    name: Label,
    description: Option<Text>,
    chosen_method: EntityRef,
}
impl IAction for Action {
    fn name(&self) -> &Label {
        &self.name
    }
    fn description(&self) -> &Option<Text> {
        &self.description
    }
    fn chosen_method(&self) -> &EntityRef {
        &self.chosen_method
    }
}
impl Action {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = Action::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => entity.chosen_method = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IActionAssignment {
    fn assigned_action(&self) -> &EntityRef;
}
pub trait IActionDirective {
    fn name(&self) -> &Label;
    fn description(&self) -> &Option<Text>;
    fn analysis(&self) -> &Text;
    fn comment(&self) -> &Text;
    fn requests(&self) -> &HashSet<EntityRef>;
}
#[derive(Default, Debug)]
pub struct ActionDirective {
    name: Label,
    description: Option<Text>,
    analysis: Text,
    comment: Text,
    requests: HashSet<EntityRef>,
}
impl IActionDirective for ActionDirective {
    fn name(&self) -> &Label {
        &self.name
    }
    fn description(&self) -> &Option<Text> {
        &self.description
    }
    fn analysis(&self) -> &Text {
        &self.analysis
    }
    fn comment(&self) -> &Text {
        &self.comment
    }
    fn requests(&self) -> &HashSet<EntityRef> {
        &self.requests
    }
}
impl ActionDirective {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = ActionDirective::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => entity.analysis = parameter.into(),
                3usize => entity.comment = parameter.into(),
                4usize => entity.requests = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IActionMethod {
    fn name(&self) -> &Label;
    fn description(&self) -> &Option<Text>;
    fn consequence(&self) -> &Text;
    fn purpose(&self) -> &Text;
}
#[derive(Default, Debug)]
pub struct ActionMethod {
    name: Label,
    description: Option<Text>,
    consequence: Text,
    purpose: Text,
}
impl IActionMethod for ActionMethod {
    fn name(&self) -> &Label {
        &self.name
    }
    fn description(&self) -> &Option<Text> {
        &self.description
    }
    fn consequence(&self) -> &Text {
        &self.consequence
    }
    fn purpose(&self) -> &Text {
        &self.purpose
    }
}
impl ActionMethod {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = ActionMethod::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => entity.consequence = parameter.into(),
                3usize => entity.purpose = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IActionMethodRelationship {
    fn name(&self) -> &Label;
    fn description(&self) -> &Option<Text>;
    fn relating_method(&self) -> &EntityRef;
    fn related_method(&self) -> &EntityRef;
}
#[derive(Default, Debug)]
pub struct ActionMethodRelationship {
    name: Label,
    description: Option<Text>,
    relating_method: EntityRef,
    related_method: EntityRef,
}
impl IActionMethodRelationship for ActionMethodRelationship {
    fn name(&self) -> &Label {
        &self.name
    }
    fn description(&self) -> &Option<Text> {
        &self.description
    }
    fn relating_method(&self) -> &EntityRef {
        &self.relating_method
    }
    fn related_method(&self) -> &EntityRef {
        &self.related_method
    }
}
impl ActionMethodRelationship {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = ActionMethodRelationship::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => entity.relating_method = parameter.into(),
                3usize => entity.related_method = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IActionProperty {
    fn name(&self) -> &Label;
    fn description(&self) -> &Text;
    fn definition(&self) -> &EntityRef;
}
#[derive(Default, Debug)]
pub struct ActionProperty {
    name: Label,
    description: Text,
    definition: EntityRef,
}
impl IActionProperty for ActionProperty {
    fn name(&self) -> &Label {
        &self.name
    }
    fn description(&self) -> &Text {
        &self.description
    }
    fn definition(&self) -> &EntityRef {
        &self.definition
    }
}
impl ActionProperty {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = ActionProperty::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => entity.description = parameter.into(),
                2usize => entity.definition = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IActionPropertyRepresentation {
    fn name(&self) -> &Label;
    fn description(&self) -> &Text;
    fn property(&self) -> &EntityRef;
    fn representation(&self) -> &EntityRef;
}
#[derive(Default, Debug)]
pub struct ActionPropertyRepresentation {
    name: Label,
    description: Text,
    property: EntityRef,
    representation: EntityRef,
}
impl IActionPropertyRepresentation for ActionPropertyRepresentation {
    fn name(&self) -> &Label {
        &self.name
    }
    fn description(&self) -> &Text {
        &self.description
    }
    fn property(&self) -> &EntityRef {
        &self.property
    }
    fn representation(&self) -> &EntityRef {
        &self.representation
    }
}
impl ActionPropertyRepresentation {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = ActionPropertyRepresentation::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => entity.description = parameter.into(),
                2usize => entity.property = parameter.into(),
                3usize => entity.representation = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IActionRelationship {
    fn name(&self) -> &Label;
    fn description(&self) -> &Option<Text>;
    fn relating_action(&self) -> &EntityRef;
    fn related_action(&self) -> &EntityRef;
}
#[derive(Default, Debug)]
pub struct ActionRelationship {
    name: Label,
    description: Option<Text>,
    relating_action: EntityRef,
    related_action: EntityRef,
}
impl IActionRelationship for ActionRelationship {
    fn name(&self) -> &Label {
        &self.name
    }
    fn description(&self) -> &Option<Text> {
        &self.description
    }
    fn relating_action(&self) -> &EntityRef {
        &self.relating_action
    }
    fn related_action(&self) -> &EntityRef {
        &self.related_action
    }
}
impl ActionRelationship {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = ActionRelationship::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => entity.relating_action = parameter.into(),
                3usize => entity.related_action = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IActionRequestAssignment {
    fn assigned_action_request(&self) -> &EntityRef;
}
pub trait IActionRequestSolution {
    fn method(&self) -> &EntityRef;
    fn request(&self) -> &EntityRef;
}
#[derive(Default, Debug)]
pub struct ActionRequestSolution {
    method: EntityRef,
    request: EntityRef,
}
impl IActionRequestSolution for ActionRequestSolution {
    fn method(&self) -> &EntityRef {
        &self.method
    }
    fn request(&self) -> &EntityRef {
        &self.request
    }
}
impl ActionRequestSolution {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = ActionRequestSolution::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.method = parameter.into(),
                1usize => entity.request = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IActionRequestStatus {
    fn status(&self) -> &Label;
    fn assigned_request(&self) -> &EntityRef;
}
#[derive(Default, Debug)]
pub struct ActionRequestStatus {
    status: Label,
    assigned_request: EntityRef,
}
impl IActionRequestStatus for ActionRequestStatus {
    fn status(&self) -> &Label {
        &self.status
    }
    fn assigned_request(&self) -> &EntityRef {
        &self.assigned_request
    }
}
impl ActionRequestStatus {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = ActionRequestStatus::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.status = parameter.into(),
                1usize => entity.assigned_request = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IActionResource {
    fn name(&self) -> &Label;
    fn description(&self) -> &Option<Text>;
    fn usage(&self) -> &HashSet<EntityRef>;
    fn kind(&self) -> &EntityRef;
}
#[derive(Default, Debug)]
pub struct ActionResource {
    name: Label,
    description: Option<Text>,
    usage: HashSet<EntityRef>,
    kind: EntityRef,
}
impl IActionResource for ActionResource {
    fn name(&self) -> &Label {
        &self.name
    }
    fn description(&self) -> &Option<Text> {
        &self.description
    }
    fn usage(&self) -> &HashSet<EntityRef> {
        &self.usage
    }
    fn kind(&self) -> &EntityRef {
        &self.kind
    }
}
impl ActionResource {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = ActionResource::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => entity.usage = parameter.into(),
                3usize => entity.kind = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IActionResourceRequirement {
    fn name(&self) -> &Label;
    fn description(&self) -> &Text;
    fn kind(&self) -> &EntityRef;
    fn operations(&self) -> &HashSet<EntityRef>;
}
#[derive(Default, Debug)]
pub struct ActionResourceRequirement {
    name: Label,
    description: Text,
    kind: EntityRef,
    operations: HashSet<EntityRef>,
}
impl IActionResourceRequirement for ActionResourceRequirement {
    fn name(&self) -> &Label {
        &self.name
    }
    fn description(&self) -> &Text {
        &self.description
    }
    fn kind(&self) -> &EntityRef {
        &self.kind
    }
    fn operations(&self) -> &HashSet<EntityRef> {
        &self.operations
    }
}
impl ActionResourceRequirement {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = ActionResourceRequirement::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => entity.description = parameter.into(),
                2usize => entity.kind = parameter.into(),
                3usize => entity.operations = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IActionResourceType {
    fn name(&self) -> &Label;
}
#[derive(Default, Debug)]
pub struct ActionResourceType {
    name: Label,
}
impl IActionResourceType for ActionResourceType {
    fn name(&self) -> &Label {
        &self.name
    }
}
impl ActionResourceType {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = ActionResourceType::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IActionStatus {
    fn status(&self) -> &Label;
    fn assigned_action(&self) -> &EntityRef;
}
#[derive(Default, Debug)]
pub struct ActionStatus {
    status: Label,
    assigned_action: EntityRef,
}
impl IActionStatus for ActionStatus {
    fn status(&self) -> &Label {
        &self.status
    }
    fn assigned_action(&self) -> &EntityRef {
        &self.assigned_action
    }
}
impl ActionStatus {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = ActionStatus::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.status = parameter.into(),
                1usize => entity.assigned_action = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IAddress {
    fn internal_location(&self) -> &Option<Label>;
    fn street_number(&self) -> &Option<Label>;
    fn street(&self) -> &Option<Label>;
    fn postal_box(&self) -> &Option<Label>;
    fn town(&self) -> &Option<Label>;
    fn region(&self) -> &Option<Label>;
    fn postal_code(&self) -> &Option<Label>;
    fn country(&self) -> &Option<Label>;
    fn facsimile_number(&self) -> &Option<Label>;
    fn telephone_number(&self) -> &Option<Label>;
    fn electronic_mail_address(&self) -> &Option<Label>;
    fn telex_number(&self) -> &Option<Label>;
}
#[derive(Default, Debug)]
pub struct Address {
    internal_location: Option<Label>,
    street_number: Option<Label>,
    street: Option<Label>,
    postal_box: Option<Label>,
    town: Option<Label>,
    region: Option<Label>,
    postal_code: Option<Label>,
    country: Option<Label>,
    facsimile_number: Option<Label>,
    telephone_number: Option<Label>,
    electronic_mail_address: Option<Label>,
    telex_number: Option<Label>,
}
impl IAddress for Address {
    fn internal_location(&self) -> &Option<Label> {
        &self.internal_location
    }
    fn street_number(&self) -> &Option<Label> {
        &self.street_number
    }
    fn street(&self) -> &Option<Label> {
        &self.street
    }
    fn postal_box(&self) -> &Option<Label> {
        &self.postal_box
    }
    fn town(&self) -> &Option<Label> {
        &self.town
    }
    fn region(&self) -> &Option<Label> {
        &self.region
    }
    fn postal_code(&self) -> &Option<Label> {
        &self.postal_code
    }
    fn country(&self) -> &Option<Label> {
        &self.country
    }
    fn facsimile_number(&self) -> &Option<Label> {
        &self.facsimile_number
    }
    fn telephone_number(&self) -> &Option<Label> {
        &self.telephone_number
    }
    fn electronic_mail_address(&self) -> &Option<Label> {
        &self.electronic_mail_address
    }
    fn telex_number(&self) -> &Option<Label> {
        &self.telex_number
    }
}
impl Address {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = Address::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => {
                    entity.internal_location = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                1usize => {
                    entity.street_number = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => {
                    entity.street = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.postal_box = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => {
                    entity.town = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                5usize => {
                    entity.region = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                6usize => {
                    entity.postal_code = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                7usize => {
                    entity.country = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                8usize => {
                    entity.facsimile_number = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                9usize => {
                    entity.telephone_number = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                10usize => {
                    entity.electronic_mail_address = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                11usize => {
                    entity.telex_number = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
}
pub trait IAdvancedBrepShapeRepresentation: IShapeRepresentation {}
#[derive(Default, Debug)]
pub struct AdvancedBrepShapeRepresentation {
    name: Label,
    items: HashSet<EntityRef>,
    context_of_items: EntityRef,
}
impl IRepresentation for AdvancedBrepShapeRepresentation {
    fn name(&self) -> &Label {
        &self.name
    }
    fn items(&self) -> &HashSet<EntityRef> {
        &self.items
    }
    fn context_of_items(&self) -> &EntityRef {
        &self.context_of_items
    }
}
impl IShapeRepresentation for AdvancedBrepShapeRepresentation {}
impl IAdvancedBrepShapeRepresentation for AdvancedBrepShapeRepresentation {}
impl AdvancedBrepShapeRepresentation {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = AdvancedBrepShapeRepresentation::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => entity.items = parameter.into(),
                2usize => entity.context_of_items = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IAdvancedFace: IFaceSurface {}
#[derive(Default, Debug)]
pub struct AdvancedFace {
    name: Label,
    bounds: HashSet<EntityRef>,
    face_geometry: EntityRef,
    same_sense: bool,
}
impl IRepresentationItem for AdvancedFace {
    fn name(&self) -> &Label {
        &self.name
    }
}
impl ITopologicalRepresentationItem for AdvancedFace {}
impl IFace for AdvancedFace {
    fn bounds(&self) -> &HashSet<EntityRef> {
        &self.bounds
    }
}
impl IFaceSurface for AdvancedFace {
    fn face_geometry(&self) -> &EntityRef {
        &self.face_geometry
    }
    fn same_sense(&self) -> bool {
        self.same_sense
    }
}
impl IGeometricRepresentationItem for AdvancedFace {}
impl IAdvancedFace for AdvancedFace {}
impl AdvancedFace {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = AdvancedFace::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => entity.bounds = parameter.into(),
                2usize => entity.face_geometry = parameter.into(),
                3usize => entity.same_sense = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IAlternateProductRelationship {
    fn name(&self) -> &Label;
    fn definition(&self) -> &Option<Text>;
    fn alternate(&self) -> &EntityRef;
    fn base(&self) -> &EntityRef;
    fn basis(&self) -> &Text;
}
#[derive(Default, Debug)]
pub struct AlternateProductRelationship {
    name: Label,
    definition: Option<Text>,
    alternate: EntityRef,
    base: EntityRef,
    basis: Text,
}
impl IAlternateProductRelationship for AlternateProductRelationship {
    fn name(&self) -> &Label {
        &self.name
    }
    fn definition(&self) -> &Option<Text> {
        &self.definition
    }
    fn alternate(&self) -> &EntityRef {
        &self.alternate
    }
    fn base(&self) -> &EntityRef {
        &self.base
    }
    fn basis(&self) -> &Text {
        &self.basis
    }
}
impl AlternateProductRelationship {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = AlternateProductRelationship::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => {
                    entity.definition = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => entity.alternate = parameter.into(),
                3usize => entity.base = parameter.into(),
                4usize => entity.basis = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IAmountOfSubstanceMeasureWithUnit: IMeasureWithUnit {}
#[derive(Default, Debug)]
pub struct AmountOfSubstanceMeasureWithUnit {
    value_component: MeasureValue,
    unit_component: EntityRef,
}
impl IMeasureWithUnit for AmountOfSubstanceMeasureWithUnit {
    fn value_component(&self) -> &MeasureValue {
        &self.value_component
    }
    fn unit_component(&self) -> &EntityRef {
        &self.unit_component
    }
}
impl IAmountOfSubstanceMeasureWithUnit for AmountOfSubstanceMeasureWithUnit {}
impl AmountOfSubstanceMeasureWithUnit {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = AmountOfSubstanceMeasureWithUnit::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.value_component = parameter.into(),
                1usize => entity.unit_component = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IAmountOfSubstanceUnit: INamedUnit {}
#[derive(Default, Debug)]
pub struct AmountOfSubstanceUnit {
    dimensions: EntityRef,
}
impl INamedUnit for AmountOfSubstanceUnit {
    fn dimensions(&self) -> &EntityRef {
        &self.dimensions
    }
}
impl IAmountOfSubstanceUnit for AmountOfSubstanceUnit {}
impl AmountOfSubstanceUnit {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = AmountOfSubstanceUnit::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.dimensions = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IAndExpression: IMultipleArityBooleanExpression {}
#[derive(Default, Debug)]
pub struct AndExpression {
    operands: Vec<EntityRef>,
}
impl IGenericExpression for AndExpression {}
impl IExpression for AndExpression {}
impl IBooleanExpression for AndExpression {}
impl IMultipleArityBooleanExpression for AndExpression {
    fn operands(&self) -> &Vec<EntityRef> {
        &self.operands
    }
}
impl IMultipleArityGenericExpression for AndExpression {
    fn operands(&self) -> &Vec<EntityRef> {
        &self.operands
    }
}
impl IAndExpression for AndExpression {}
impl AndExpression {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = AndExpression::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.operands = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IAngularDimension: IDimensionCurveDirectedCallout {}
#[derive(Default, Debug)]
pub struct AngularDimension {
    name: Label,
    contents: HashSet<EntityRef>,
}
impl IRepresentationItem for AngularDimension {
    fn name(&self) -> &Label {
        &self.name
    }
}
impl IGeometricRepresentationItem for AngularDimension {}
impl IDraughtingCallout for AngularDimension {
    fn contents(&self) -> &HashSet<EntityRef> {
        &self.contents
    }
}
impl IDimensionCurveDirectedCallout for AngularDimension {}
impl IAngularDimension for AngularDimension {}
impl AngularDimension {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = AngularDimension::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => entity.contents = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IAngularLocation: IDimensionalLocation {
    fn angle_selection(&self) -> &AngleRelator;
}
#[derive(Default, Debug)]
pub struct AngularLocation {
    name: Label,
    description: Option<Text>,
    relating_shape_aspect: EntityRef,
    related_shape_aspect: EntityRef,
    angle_selection: AngleRelator,
}
impl IShapeAspectRelationship for AngularLocation {
    fn name(&self) -> &Label {
        &self.name
    }
    fn description(&self) -> &Option<Text> {
        &self.description
    }
    fn relating_shape_aspect(&self) -> &EntityRef {
        &self.relating_shape_aspect
    }
    fn related_shape_aspect(&self) -> &EntityRef {
        &self.related_shape_aspect
    }
}
impl IDimensionalLocation for AngularLocation {}
impl IAngularLocation for AngularLocation {
    fn angle_selection(&self) -> &AngleRelator {
        &self.angle_selection
    }
}
impl AngularLocation {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = AngularLocation::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => entity.relating_shape_aspect = parameter.into(),
                3usize => entity.related_shape_aspect = parameter.into(),
                4usize => entity.angle_selection = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IAngularSize: IDimensionalSize {
    fn angle_selection(&self) -> &AngleRelator;
}
#[derive(Default, Debug)]
pub struct AngularSize {
    applies_to: EntityRef,
    name: Label,
    angle_selection: AngleRelator,
}
impl IDimensionalSize for AngularSize {
    fn applies_to(&self) -> &EntityRef {
        &self.applies_to
    }
    fn name(&self) -> &Label {
        &self.name
    }
}
impl IAngularSize for AngularSize {
    fn angle_selection(&self) -> &AngleRelator {
        &self.angle_selection
    }
}
impl AngularSize {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = AngularSize::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.applies_to = parameter.into(),
                1usize => entity.name = parameter.into(),
                2usize => entity.angle_selection = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IAngularityTolerance: IGeometricToleranceWithDatumReference {}
#[derive(Default, Debug)]
pub struct AngularityTolerance {
    name: Label,
    description: Text,
    magnitude: EntityRef,
    toleranced_shape_aspect: EntityRef,
    datum_system: HashSet<EntityRef>,
}
impl IGeometricTolerance for AngularityTolerance {
    fn name(&self) -> &Label {
        &self.name
    }
    fn description(&self) -> &Text {
        &self.description
    }
    fn magnitude(&self) -> &EntityRef {
        &self.magnitude
    }
    fn toleranced_shape_aspect(&self) -> &EntityRef {
        &self.toleranced_shape_aspect
    }
}
impl IGeometricToleranceWithDatumReference for AngularityTolerance {
    fn datum_system(&self) -> &HashSet<EntityRef> {
        &self.datum_system
    }
}
impl IAngularityTolerance for AngularityTolerance {}
impl AngularityTolerance {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = AngularityTolerance::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => entity.description = parameter.into(),
                2usize => entity.magnitude = parameter.into(),
                3usize => entity.toleranced_shape_aspect = parameter.into(),
                4usize => entity.datum_system = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IAnnotationCurveOccurrence: IAnnotationOccurrence {
    fn item(&self) -> &EntityRef;
}
#[derive(Default, Debug)]
pub struct AnnotationCurveOccurrence {
    name: Label,
    styles: HashSet<EntityRef>,
    item: EntityRef,
}
impl IRepresentationItem for AnnotationCurveOccurrence {
    fn name(&self) -> &Label {
        &self.name
    }
}
impl IStyledItem for AnnotationCurveOccurrence {
    fn styles(&self) -> &HashSet<EntityRef> {
        &self.styles
    }
    fn item(&self) -> &EntityRef {
        &self.item
    }
}
impl IAnnotationOccurrence for AnnotationCurveOccurrence {}
impl IAnnotationCurveOccurrence for AnnotationCurveOccurrence {
    fn item(&self) -> &EntityRef {
        &self.item
    }
}
impl AnnotationCurveOccurrence {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = AnnotationCurveOccurrence::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => entity.styles = parameter.into(),
                2usize => entity.item = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IAnnotationFillArea: IGeometricRepresentationItem {
    fn boundaries(&self) -> &HashSet<EntityRef>;
}
#[derive(Default, Debug)]
pub struct AnnotationFillArea {
    name: Label,
    boundaries: HashSet<EntityRef>,
}
impl IRepresentationItem for AnnotationFillArea {
    fn name(&self) -> &Label {
        &self.name
    }
}
impl IGeometricRepresentationItem for AnnotationFillArea {}
impl IAnnotationFillArea for AnnotationFillArea {
    fn boundaries(&self) -> &HashSet<EntityRef> {
        &self.boundaries
    }
}
impl AnnotationFillArea {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = AnnotationFillArea::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => entity.boundaries = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IAnnotationFillAreaOccurrence: IAnnotationOccurrence {
    fn fill_style_target(&self) -> &EntityRef;
    fn item(&self) -> &EntityRef;
}
#[derive(Default, Debug)]
pub struct AnnotationFillAreaOccurrence {
    name: Label,
    styles: HashSet<EntityRef>,
    fill_style_target: EntityRef,
    item: EntityRef,
}
impl IRepresentationItem for AnnotationFillAreaOccurrence {
    fn name(&self) -> &Label {
        &self.name
    }
}
impl IStyledItem for AnnotationFillAreaOccurrence {
    fn styles(&self) -> &HashSet<EntityRef> {
        &self.styles
    }
    fn item(&self) -> &EntityRef {
        &self.item
    }
}
impl IAnnotationOccurrence for AnnotationFillAreaOccurrence {}
impl IAnnotationFillAreaOccurrence for AnnotationFillAreaOccurrence {
    fn fill_style_target(&self) -> &EntityRef {
        &self.fill_style_target
    }
    fn item(&self) -> &EntityRef {
        &self.item
    }
}
impl AnnotationFillAreaOccurrence {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = AnnotationFillAreaOccurrence::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => entity.styles = parameter.into(),
                2usize => entity.fill_style_target = parameter.into(),
                3usize => entity.item = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IAnnotationOccurrence: IStyledItem {}
#[derive(Default, Debug)]
pub struct AnnotationOccurrence {
    name: Label,
    styles: HashSet<EntityRef>,
    item: EntityRef,
}
impl IRepresentationItem for AnnotationOccurrence {
    fn name(&self) -> &Label {
        &self.name
    }
}
impl IStyledItem for AnnotationOccurrence {
    fn styles(&self) -> &HashSet<EntityRef> {
        &self.styles
    }
    fn item(&self) -> &EntityRef {
        &self.item
    }
}
impl IAnnotationOccurrence for AnnotationOccurrence {}
impl AnnotationOccurrence {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = AnnotationOccurrence::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => entity.styles = parameter.into(),
                2usize => entity.item = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IAnnotationOccurrenceAssociativity: IAnnotationOccurrenceRelationship {}
#[derive(Default, Debug)]
pub struct AnnotationOccurrenceAssociativity {
    name: Label,
    description: Text,
    relating_annotation_occurrence: EntityRef,
    related_annotation_occurrence: EntityRef,
}
impl IAnnotationOccurrenceRelationship for AnnotationOccurrenceAssociativity {
    fn name(&self) -> &Label {
        &self.name
    }
    fn description(&self) -> &Text {
        &self.description
    }
    fn relating_annotation_occurrence(&self) -> &EntityRef {
        &self.relating_annotation_occurrence
    }
    fn related_annotation_occurrence(&self) -> &EntityRef {
        &self.related_annotation_occurrence
    }
}
impl IAnnotationOccurrenceAssociativity for AnnotationOccurrenceAssociativity {}
impl AnnotationOccurrenceAssociativity {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = AnnotationOccurrenceAssociativity::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => entity.description = parameter.into(),
                2usize => entity.relating_annotation_occurrence = parameter.into(),
                3usize => entity.related_annotation_occurrence = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IAnnotationOccurrenceRelationship {
    fn name(&self) -> &Label;
    fn description(&self) -> &Text;
    fn relating_annotation_occurrence(&self) -> &EntityRef;
    fn related_annotation_occurrence(&self) -> &EntityRef;
}
#[derive(Default, Debug)]
pub struct AnnotationOccurrenceRelationship {
    name: Label,
    description: Text,
    relating_annotation_occurrence: EntityRef,
    related_annotation_occurrence: EntityRef,
}
impl IAnnotationOccurrenceRelationship for AnnotationOccurrenceRelationship {
    fn name(&self) -> &Label {
        &self.name
    }
    fn description(&self) -> &Text {
        &self.description
    }
    fn relating_annotation_occurrence(&self) -> &EntityRef {
        &self.relating_annotation_occurrence
    }
    fn related_annotation_occurrence(&self) -> &EntityRef {
        &self.related_annotation_occurrence
    }
}
impl AnnotationOccurrenceRelationship {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = AnnotationOccurrenceRelationship::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => entity.description = parameter.into(),
                2usize => entity.relating_annotation_occurrence = parameter.into(),
                3usize => entity.related_annotation_occurrence = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IAnnotationPlane: IAnnotationOccurrence + IGeometricRepresentationItem {
    fn elements(&self) -> &Option<HashSet<EntityRef>>;
    fn item(&self) -> &EntityRef;
}
#[derive(Default, Debug)]
pub struct AnnotationPlane {
    name: Label,
    styles: HashSet<EntityRef>,
    elements: Option<HashSet<EntityRef>>,
    item: EntityRef,
}
impl IRepresentationItem for AnnotationPlane {
    fn name(&self) -> &Label {
        &self.name
    }
}
impl IStyledItem for AnnotationPlane {
    fn styles(&self) -> &HashSet<EntityRef> {
        &self.styles
    }
    fn item(&self) -> &EntityRef {
        &self.item
    }
}
impl IAnnotationOccurrence for AnnotationPlane {}
impl IAnnotationPlane for AnnotationPlane {
    fn elements(&self) -> &Option<HashSet<EntityRef>> {
        &self.elements
    }
    fn item(&self) -> &EntityRef {
        &self.item
    }
}
impl IGeometricRepresentationItem for AnnotationPlane {}
impl AnnotationPlane {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = AnnotationPlane::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => entity.styles = parameter.into(),
                2usize => {
                    entity.elements = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => entity.item = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IAnnotationSubfigureOccurrence: IAnnotationSymbolOccurrence {}
#[derive(Default, Debug)]
pub struct AnnotationSubfigureOccurrence {
    name: Label,
    styles: HashSet<EntityRef>,
    item: EntityRef,
}
impl IRepresentationItem for AnnotationSubfigureOccurrence {
    fn name(&self) -> &Label {
        &self.name
    }
}
impl IStyledItem for AnnotationSubfigureOccurrence {
    fn styles(&self) -> &HashSet<EntityRef> {
        &self.styles
    }
    fn item(&self) -> &EntityRef {
        &self.item
    }
}
impl IAnnotationOccurrence for AnnotationSubfigureOccurrence {}
impl IAnnotationSymbolOccurrence for AnnotationSubfigureOccurrence {
    fn item(&self) -> &EntityRef {
        &self.item
    }
}
impl IAnnotationSubfigureOccurrence for AnnotationSubfigureOccurrence {}
impl AnnotationSubfigureOccurrence {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = AnnotationSubfigureOccurrence::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => entity.styles = parameter.into(),
                2usize => entity.item = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IAnnotationSymbol: IMappedItem {
    fn mapping_source(&self) -> &EntityRef;
    fn mapping_target(&self) -> &EntityRef;
}
#[derive(Default, Debug)]
pub struct AnnotationSymbol {
    name: Label,
    mapping_source: EntityRef,
    mapping_target: EntityRef,
}
impl IRepresentationItem for AnnotationSymbol {
    fn name(&self) -> &Label {
        &self.name
    }
}
impl IMappedItem for AnnotationSymbol {
    fn mapping_source(&self) -> &EntityRef {
        &self.mapping_source
    }
    fn mapping_target(&self) -> &EntityRef {
        &self.mapping_target
    }
}
impl IAnnotationSymbol for AnnotationSymbol {
    fn mapping_source(&self) -> &EntityRef {
        &self.mapping_source
    }
    fn mapping_target(&self) -> &EntityRef {
        &self.mapping_target
    }
}
impl AnnotationSymbol {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = AnnotationSymbol::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => entity.mapping_source = parameter.into(),
                2usize => entity.mapping_target = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IAnnotationSymbolOccurrence: IAnnotationOccurrence {
    fn item(&self) -> &EntityRef;
}
#[derive(Default, Debug)]
pub struct AnnotationSymbolOccurrence {
    name: Label,
    styles: HashSet<EntityRef>,
    item: EntityRef,
}
impl IRepresentationItem for AnnotationSymbolOccurrence {
    fn name(&self) -> &Label {
        &self.name
    }
}
impl IStyledItem for AnnotationSymbolOccurrence {
    fn styles(&self) -> &HashSet<EntityRef> {
        &self.styles
    }
    fn item(&self) -> &EntityRef {
        &self.item
    }
}
impl IAnnotationOccurrence for AnnotationSymbolOccurrence {}
impl IAnnotationSymbolOccurrence for AnnotationSymbolOccurrence {
    fn item(&self) -> &EntityRef {
        &self.item
    }
}
impl AnnotationSymbolOccurrence {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = AnnotationSymbolOccurrence::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => entity.styles = parameter.into(),
                2usize => entity.item = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IAnnotationText: IMappedItem {
    fn mapping_target(&self) -> &EntityRef;
}
#[derive(Default, Debug)]
pub struct AnnotationText {
    name: Label,
    mapping_source: EntityRef,
    mapping_target: EntityRef,
}
impl IRepresentationItem for AnnotationText {
    fn name(&self) -> &Label {
        &self.name
    }
}
impl IMappedItem for AnnotationText {
    fn mapping_source(&self) -> &EntityRef {
        &self.mapping_source
    }
    fn mapping_target(&self) -> &EntityRef {
        &self.mapping_target
    }
}
impl IAnnotationText for AnnotationText {
    fn mapping_target(&self) -> &EntityRef {
        &self.mapping_target
    }
}
impl AnnotationText {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = AnnotationText::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => entity.mapping_source = parameter.into(),
                2usize => entity.mapping_target = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IAnnotationTextCharacter: IMappedItem {
    fn alignment(&self) -> &TextAlignment;
    fn mapping_target(&self) -> &EntityRef;
}
#[derive(Default, Debug)]
pub struct AnnotationTextCharacter {
    name: Label,
    mapping_source: EntityRef,
    alignment: TextAlignment,
    mapping_target: EntityRef,
}
impl IRepresentationItem for AnnotationTextCharacter {
    fn name(&self) -> &Label {
        &self.name
    }
}
impl IMappedItem for AnnotationTextCharacter {
    fn mapping_source(&self) -> &EntityRef {
        &self.mapping_source
    }
    fn mapping_target(&self) -> &EntityRef {
        &self.mapping_target
    }
}
impl IAnnotationTextCharacter for AnnotationTextCharacter {
    fn alignment(&self) -> &TextAlignment {
        &self.alignment
    }
    fn mapping_target(&self) -> &EntityRef {
        &self.mapping_target
    }
}
impl AnnotationTextCharacter {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = AnnotationTextCharacter::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => entity.mapping_source = parameter.into(),
                2usize => entity.alignment = parameter.into(),
                3usize => entity.mapping_target = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IAnnotationTextOccurrence: IAnnotationOccurrence {
    fn item(&self) -> &EntityRef;
}
#[derive(Default, Debug)]
pub struct AnnotationTextOccurrence {
    name: Label,
    styles: HashSet<EntityRef>,
    item: EntityRef,
}
impl IRepresentationItem for AnnotationTextOccurrence {
    fn name(&self) -> &Label {
        &self.name
    }
}
impl IStyledItem for AnnotationTextOccurrence {
    fn styles(&self) -> &HashSet<EntityRef> {
        &self.styles
    }
    fn item(&self) -> &EntityRef {
        &self.item
    }
}
impl IAnnotationOccurrence for AnnotationTextOccurrence {}
impl IAnnotationTextOccurrence for AnnotationTextOccurrence {
    fn item(&self) -> &EntityRef {
        &self.item
    }
}
impl AnnotationTextOccurrence {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = AnnotationTextOccurrence::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => entity.styles = parameter.into(),
                2usize => entity.item = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IApex: IDerivedShapeAspect {}
#[derive(Default, Debug)]
pub struct Apex {
    name: Label,
    description: Option<Text>,
    of_shape: EntityRef,
    product_definitional: Option<bool>,
}
impl IShapeAspect for Apex {
    fn name(&self) -> &Label {
        &self.name
    }
    fn description(&self) -> &Option<Text> {
        &self.description
    }
    fn of_shape(&self) -> &EntityRef {
        &self.of_shape
    }
    fn product_definitional(&self) -> Option<bool> {
        self.product_definitional
    }
}
impl IDerivedShapeAspect for Apex {}
impl IApex for Apex {}
impl Apex {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = Apex::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => entity.of_shape = parameter.into(),
                3usize => entity.product_definitional = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IApplicationContext {
    fn application(&self) -> &Label;
}
#[derive(Default, Debug)]
pub struct ApplicationContext {
    application: Label,
}
impl IApplicationContext for ApplicationContext {
    fn application(&self) -> &Label {
        &self.application
    }
}
impl ApplicationContext {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = ApplicationContext::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.application = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IApplicationContextElement {
    fn name(&self) -> &Label;
    fn frame_of_reference(&self) -> &EntityRef;
}
#[derive(Default, Debug)]
pub struct ApplicationContextElement {
    name: Label,
    frame_of_reference: EntityRef,
}
impl IApplicationContextElement for ApplicationContextElement {
    fn name(&self) -> &Label {
        &self.name
    }
    fn frame_of_reference(&self) -> &EntityRef {
        &self.frame_of_reference
    }
}
impl ApplicationContextElement {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = ApplicationContextElement::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => entity.frame_of_reference = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IApplicationContextRelationship {
    fn name(&self) -> &Label;
    fn description(&self) -> &Option<Text>;
    fn relating_context(&self) -> &EntityRef;
    fn related_context(&self) -> &EntityRef;
}
#[derive(Default, Debug)]
pub struct ApplicationContextRelationship {
    name: Label,
    description: Option<Text>,
    relating_context: EntityRef,
    related_context: EntityRef,
}
impl IApplicationContextRelationship for ApplicationContextRelationship {
    fn name(&self) -> &Label {
        &self.name
    }
    fn description(&self) -> &Option<Text> {
        &self.description
    }
    fn relating_context(&self) -> &EntityRef {
        &self.relating_context
    }
    fn related_context(&self) -> &EntityRef {
        &self.related_context
    }
}
impl ApplicationContextRelationship {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = ApplicationContextRelationship::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => entity.relating_context = parameter.into(),
                3usize => entity.related_context = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IApplicationProtocolDefinition {
    fn status(&self) -> &Label;
    fn application_interpreted_model_schema_name(&self) -> &Label;
    fn application_protocol_year(&self) -> &YearNumber;
    fn application(&self) -> &EntityRef;
}
#[derive(Default, Debug)]
pub struct ApplicationProtocolDefinition {
    status: Label,
    application_interpreted_model_schema_name: Label,
    application_protocol_year: YearNumber,
    application: EntityRef,
}
impl IApplicationProtocolDefinition for ApplicationProtocolDefinition {
    fn status(&self) -> &Label {
        &self.status
    }
    fn application_interpreted_model_schema_name(&self) -> &Label {
        &self.application_interpreted_model_schema_name
    }
    fn application_protocol_year(&self) -> &YearNumber {
        &self.application_protocol_year
    }
    fn application(&self) -> &EntityRef {
        &self.application
    }
}
impl ApplicationProtocolDefinition {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = ApplicationProtocolDefinition::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.status = parameter.into(),
                1usize => entity.application_interpreted_model_schema_name = parameter.into(),
                2usize => entity.application_protocol_year = parameter.into(),
                3usize => entity.application = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IAppliedActionAssignment: IActionAssignment {
    fn items(&self) -> &HashSet<EntityRef>;
}
#[derive(Default, Debug)]
pub struct AppliedActionAssignment {
    assigned_action: EntityRef,
    items: HashSet<EntityRef>,
}
impl IActionAssignment for AppliedActionAssignment {
    fn assigned_action(&self) -> &EntityRef {
        &self.assigned_action
    }
}
impl IAppliedActionAssignment for AppliedActionAssignment {
    fn items(&self) -> &HashSet<EntityRef> {
        &self.items
    }
}
impl AppliedActionAssignment {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = AppliedActionAssignment::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.assigned_action = parameter.into(),
                1usize => entity.items = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IAppliedActionRequestAssignment: IActionRequestAssignment {
    fn items(&self) -> &HashSet<EntityRef>;
}
#[derive(Default, Debug)]
pub struct AppliedActionRequestAssignment {
    assigned_action_request: EntityRef,
    items: HashSet<EntityRef>,
}
impl IActionRequestAssignment for AppliedActionRequestAssignment {
    fn assigned_action_request(&self) -> &EntityRef {
        &self.assigned_action_request
    }
}
impl IAppliedActionRequestAssignment for AppliedActionRequestAssignment {
    fn items(&self) -> &HashSet<EntityRef> {
        &self.items
    }
}
impl AppliedActionRequestAssignment {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = AppliedActionRequestAssignment::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.assigned_action_request = parameter.into(),
                1usize => entity.items = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IAppliedApprovalAssignment: IApprovalAssignment {
    fn items(&self) -> &HashSet<EntityRef>;
}
#[derive(Default, Debug)]
pub struct AppliedApprovalAssignment {
    assigned_approval: EntityRef,
    items: HashSet<EntityRef>,
}
impl IApprovalAssignment for AppliedApprovalAssignment {
    fn assigned_approval(&self) -> &EntityRef {
        &self.assigned_approval
    }
}
impl IAppliedApprovalAssignment for AppliedApprovalAssignment {
    fn items(&self) -> &HashSet<EntityRef> {
        &self.items
    }
}
impl AppliedApprovalAssignment {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = AppliedApprovalAssignment::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.assigned_approval = parameter.into(),
                1usize => entity.items = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IAppliedArea: IShapeAspect {}
#[derive(Default, Debug)]
pub struct AppliedArea {
    name: Label,
    description: Option<Text>,
    of_shape: EntityRef,
    product_definitional: Option<bool>,
}
impl IShapeAspect for AppliedArea {
    fn name(&self) -> &Label {
        &self.name
    }
    fn description(&self) -> &Option<Text> {
        &self.description
    }
    fn of_shape(&self) -> &EntityRef {
        &self.of_shape
    }
    fn product_definitional(&self) -> Option<bool> {
        self.product_definitional
    }
}
impl IAppliedArea for AppliedArea {}
impl AppliedArea {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = AppliedArea::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => entity.of_shape = parameter.into(),
                3usize => entity.product_definitional = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IAppliedCertificationAssignment: ICertificationAssignment {
    fn items(&self) -> &HashSet<EntityRef>;
}
#[derive(Default, Debug)]
pub struct AppliedCertificationAssignment {
    assigned_certification: EntityRef,
    items: HashSet<EntityRef>,
}
impl ICertificationAssignment for AppliedCertificationAssignment {
    fn assigned_certification(&self) -> &EntityRef {
        &self.assigned_certification
    }
}
impl IAppliedCertificationAssignment for AppliedCertificationAssignment {
    fn items(&self) -> &HashSet<EntityRef> {
        &self.items
    }
}
impl AppliedCertificationAssignment {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = AppliedCertificationAssignment::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.assigned_certification = parameter.into(),
                1usize => entity.items = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IAppliedClassificationAssignment: IClassificationAssignment {
    fn items(&self) -> &HashSet<EntityRef>;
}
#[derive(Default, Debug)]
pub struct AppliedClassificationAssignment {
    assigned_class: EntityRef,
    role: EntityRef,
    items: HashSet<EntityRef>,
}
impl IClassificationAssignment for AppliedClassificationAssignment {
    fn assigned_class(&self) -> &EntityRef {
        &self.assigned_class
    }
    fn role(&self) -> &EntityRef {
        &self.role
    }
}
impl IAppliedClassificationAssignment for AppliedClassificationAssignment {
    fn items(&self) -> &HashSet<EntityRef> {
        &self.items
    }
}
impl AppliedClassificationAssignment {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = AppliedClassificationAssignment::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.assigned_class = parameter.into(),
                1usize => entity.role = parameter.into(),
                2usize => entity.items = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IAppliedContractAssignment: IContractAssignment {
    fn items(&self) -> &HashSet<EntityRef>;
}
#[derive(Default, Debug)]
pub struct AppliedContractAssignment {
    assigned_contract: EntityRef,
    items: HashSet<EntityRef>,
}
impl IContractAssignment for AppliedContractAssignment {
    fn assigned_contract(&self) -> &EntityRef {
        &self.assigned_contract
    }
}
impl IAppliedContractAssignment for AppliedContractAssignment {
    fn items(&self) -> &HashSet<EntityRef> {
        &self.items
    }
}
impl AppliedContractAssignment {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = AppliedContractAssignment::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.assigned_contract = parameter.into(),
                1usize => entity.items = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IAppliedDateAndTimeAssignment: IDateAndTimeAssignment {
    fn items(&self) -> &HashSet<EntityRef>;
}
#[derive(Default, Debug)]
pub struct AppliedDateAndTimeAssignment {
    assigned_date_and_time: EntityRef,
    role: EntityRef,
    items: HashSet<EntityRef>,
}
impl IDateAndTimeAssignment for AppliedDateAndTimeAssignment {
    fn assigned_date_and_time(&self) -> &EntityRef {
        &self.assigned_date_and_time
    }
    fn role(&self) -> &EntityRef {
        &self.role
    }
}
impl IAppliedDateAndTimeAssignment for AppliedDateAndTimeAssignment {
    fn items(&self) -> &HashSet<EntityRef> {
        &self.items
    }
}
impl AppliedDateAndTimeAssignment {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = AppliedDateAndTimeAssignment::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.assigned_date_and_time = parameter.into(),
                1usize => entity.role = parameter.into(),
                2usize => entity.items = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IAppliedDateAssignment: IDateAssignment {
    fn items(&self) -> &HashSet<EntityRef>;
}
#[derive(Default, Debug)]
pub struct AppliedDateAssignment {
    assigned_date: EntityRef,
    role: EntityRef,
    items: HashSet<EntityRef>,
}
impl IDateAssignment for AppliedDateAssignment {
    fn assigned_date(&self) -> &EntityRef {
        &self.assigned_date
    }
    fn role(&self) -> &EntityRef {
        &self.role
    }
}
impl IAppliedDateAssignment for AppliedDateAssignment {
    fn items(&self) -> &HashSet<EntityRef> {
        &self.items
    }
}
impl AppliedDateAssignment {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = AppliedDateAssignment::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.assigned_date = parameter.into(),
                1usize => entity.role = parameter.into(),
                2usize => entity.items = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IAppliedDocumentReference: IDocumentReference {
    fn items(&self) -> &HashSet<EntityRef>;
}
#[derive(Default, Debug)]
pub struct AppliedDocumentReference {
    assigned_document: EntityRef,
    source: Label,
    items: HashSet<EntityRef>,
}
impl IDocumentReference for AppliedDocumentReference {
    fn assigned_document(&self) -> &EntityRef {
        &self.assigned_document
    }
    fn source(&self) -> &Label {
        &self.source
    }
}
impl IAppliedDocumentReference for AppliedDocumentReference {
    fn items(&self) -> &HashSet<EntityRef> {
        &self.items
    }
}
impl AppliedDocumentReference {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = AppliedDocumentReference::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.assigned_document = parameter.into(),
                1usize => entity.source = parameter.into(),
                2usize => entity.items = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IAppliedDocumentUsageConstraintAssignment: IDocumentUsageConstraintAssignment {
    fn items(&self) -> &HashSet<EntityRef>;
}
#[derive(Default, Debug)]
pub struct AppliedDocumentUsageConstraintAssignment {
    assigned_document_usage: EntityRef,
    role: EntityRef,
    items: HashSet<EntityRef>,
}
impl IDocumentUsageConstraintAssignment for AppliedDocumentUsageConstraintAssignment {
    fn assigned_document_usage(&self) -> &EntityRef {
        &self.assigned_document_usage
    }
    fn role(&self) -> &EntityRef {
        &self.role
    }
}
impl IAppliedDocumentUsageConstraintAssignment for AppliedDocumentUsageConstraintAssignment {
    fn items(&self) -> &HashSet<EntityRef> {
        &self.items
    }
}
impl AppliedDocumentUsageConstraintAssignment {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = AppliedDocumentUsageConstraintAssignment::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.assigned_document_usage = parameter.into(),
                1usize => entity.role = parameter.into(),
                2usize => entity.items = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IAppliedEffectivityAssignment: IEffectivityAssignment {
    fn items(&self) -> &HashSet<EntityRef>;
}
#[derive(Default, Debug)]
pub struct AppliedEffectivityAssignment {
    assigned_effectivity: EntityRef,
    items: HashSet<EntityRef>,
}
impl IEffectivityAssignment for AppliedEffectivityAssignment {
    fn assigned_effectivity(&self) -> &EntityRef {
        &self.assigned_effectivity
    }
}
impl IAppliedEffectivityAssignment for AppliedEffectivityAssignment {
    fn items(&self) -> &HashSet<EntityRef> {
        &self.items
    }
}
impl AppliedEffectivityAssignment {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = AppliedEffectivityAssignment::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.assigned_effectivity = parameter.into(),
                1usize => entity.items = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IAppliedEventOccurrenceAssignment: IEventOccurrenceAssignment {
    fn items(&self) -> &HashSet<EntityRef>;
}
#[derive(Default, Debug)]
pub struct AppliedEventOccurrenceAssignment {
    assigned_event_occurrence: EntityRef,
    role: EntityRef,
    items: HashSet<EntityRef>,
}
impl IEventOccurrenceAssignment for AppliedEventOccurrenceAssignment {
    fn assigned_event_occurrence(&self) -> &EntityRef {
        &self.assigned_event_occurrence
    }
    fn role(&self) -> &EntityRef {
        &self.role
    }
}
impl IAppliedEventOccurrenceAssignment for AppliedEventOccurrenceAssignment {
    fn items(&self) -> &HashSet<EntityRef> {
        &self.items
    }
}
impl AppliedEventOccurrenceAssignment {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = AppliedEventOccurrenceAssignment::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.assigned_event_occurrence = parameter.into(),
                1usize => entity.role = parameter.into(),
                2usize => entity.items = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IAppliedExternalIdentificationAssignment: IExternalIdentificationAssignment {
    fn items(&self) -> &HashSet<EntityRef>;
}
#[derive(Default, Debug)]
pub struct AppliedExternalIdentificationAssignment {
    assigned_id: Identifier,
    role: EntityRef,
    source: EntityRef,
    items: HashSet<EntityRef>,
}
impl IIdentificationAssignment for AppliedExternalIdentificationAssignment {
    fn assigned_id(&self) -> &Identifier {
        &self.assigned_id
    }
    fn role(&self) -> &EntityRef {
        &self.role
    }
}
impl IExternalIdentificationAssignment for AppliedExternalIdentificationAssignment {
    fn source(&self) -> &EntityRef {
        &self.source
    }
}
impl IAppliedExternalIdentificationAssignment for AppliedExternalIdentificationAssignment {
    fn items(&self) -> &HashSet<EntityRef> {
        &self.items
    }
}
impl AppliedExternalIdentificationAssignment {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = AppliedExternalIdentificationAssignment::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.assigned_id = parameter.into(),
                1usize => entity.role = parameter.into(),
                2usize => entity.source = parameter.into(),
                3usize => entity.items = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IAppliedGroupAssignment: IGroupAssignment {
    fn items(&self) -> &HashSet<EntityRef>;
}
#[derive(Default, Debug)]
pub struct AppliedGroupAssignment {
    assigned_group: EntityRef,
    items: HashSet<EntityRef>,
}
impl IGroupAssignment for AppliedGroupAssignment {
    fn assigned_group(&self) -> &EntityRef {
        &self.assigned_group
    }
}
impl IAppliedGroupAssignment for AppliedGroupAssignment {
    fn items(&self) -> &HashSet<EntityRef> {
        &self.items
    }
}
impl AppliedGroupAssignment {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = AppliedGroupAssignment::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.assigned_group = parameter.into(),
                1usize => entity.items = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IAppliedIdentificationAssignment: IIdentificationAssignment {
    fn items(&self) -> &HashSet<EntityRef>;
}
#[derive(Default, Debug)]
pub struct AppliedIdentificationAssignment {
    assigned_id: Identifier,
    role: EntityRef,
    items: HashSet<EntityRef>,
}
impl IIdentificationAssignment for AppliedIdentificationAssignment {
    fn assigned_id(&self) -> &Identifier {
        &self.assigned_id
    }
    fn role(&self) -> &EntityRef {
        &self.role
    }
}
impl IAppliedIdentificationAssignment for AppliedIdentificationAssignment {
    fn items(&self) -> &HashSet<EntityRef> {
        &self.items
    }
}
impl AppliedIdentificationAssignment {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = AppliedIdentificationAssignment::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.assigned_id = parameter.into(),
                1usize => entity.role = parameter.into(),
                2usize => entity.items = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IAppliedIneffectivityAssignment: IEffectivityAssignment {
    fn items(&self) -> &HashSet<EntityRef>;
}
#[derive(Default, Debug)]
pub struct AppliedIneffectivityAssignment {
    assigned_effectivity: EntityRef,
    items: HashSet<EntityRef>,
}
impl IEffectivityAssignment for AppliedIneffectivityAssignment {
    fn assigned_effectivity(&self) -> &EntityRef {
        &self.assigned_effectivity
    }
}
impl IAppliedIneffectivityAssignment for AppliedIneffectivityAssignment {
    fn items(&self) -> &HashSet<EntityRef> {
        &self.items
    }
}
impl AppliedIneffectivityAssignment {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = AppliedIneffectivityAssignment::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.assigned_effectivity = parameter.into(),
                1usize => entity.items = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IAppliedNameAssignment: INameAssignment {
    fn items(&self) -> &HashSet<EntityRef>;
}
#[derive(Default, Debug)]
pub struct AppliedNameAssignment {
    assigned_name: Label,
    items: HashSet<EntityRef>,
}
impl INameAssignment for AppliedNameAssignment {
    fn assigned_name(&self) -> &Label {
        &self.assigned_name
    }
}
impl IAppliedNameAssignment for AppliedNameAssignment {
    fn items(&self) -> &HashSet<EntityRef> {
        &self.items
    }
}
impl AppliedNameAssignment {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = AppliedNameAssignment::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.assigned_name = parameter.into(),
                1usize => entity.items = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IAppliedOrganizationAssignment: IOrganizationAssignment {
    fn items(&self) -> &HashSet<EntityRef>;
}
#[derive(Default, Debug)]
pub struct AppliedOrganizationAssignment {
    assigned_organization: EntityRef,
    role: EntityRef,
    items: HashSet<EntityRef>,
}
impl IOrganizationAssignment for AppliedOrganizationAssignment {
    fn assigned_organization(&self) -> &EntityRef {
        &self.assigned_organization
    }
    fn role(&self) -> &EntityRef {
        &self.role
    }
}
impl IAppliedOrganizationAssignment for AppliedOrganizationAssignment {
    fn items(&self) -> &HashSet<EntityRef> {
        &self.items
    }
}
impl AppliedOrganizationAssignment {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = AppliedOrganizationAssignment::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.assigned_organization = parameter.into(),
                1usize => entity.role = parameter.into(),
                2usize => entity.items = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IAppliedOrganizationalProjectAssignment: IOrganizationalProjectAssignment {
    fn items(&self) -> &HashSet<EntityRef>;
}
#[derive(Default, Debug)]
pub struct AppliedOrganizationalProjectAssignment {
    assigned_organizational_project: EntityRef,
    role: EntityRef,
    items: HashSet<EntityRef>,
}
impl IOrganizationalProjectAssignment for AppliedOrganizationalProjectAssignment {
    fn assigned_organizational_project(&self) -> &EntityRef {
        &self.assigned_organizational_project
    }
    fn role(&self) -> &EntityRef {
        &self.role
    }
}
impl IAppliedOrganizationalProjectAssignment for AppliedOrganizationalProjectAssignment {
    fn items(&self) -> &HashSet<EntityRef> {
        &self.items
    }
}
impl AppliedOrganizationalProjectAssignment {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = AppliedOrganizationalProjectAssignment::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.assigned_organizational_project = parameter.into(),
                1usize => entity.role = parameter.into(),
                2usize => entity.items = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IAppliedPersonAndOrganizationAssignment: IPersonAndOrganizationAssignment {
    fn items(&self) -> &HashSet<EntityRef>;
}
#[derive(Default, Debug)]
pub struct AppliedPersonAndOrganizationAssignment {
    assigned_person_and_organization: EntityRef,
    role: EntityRef,
    items: HashSet<EntityRef>,
}
impl IPersonAndOrganizationAssignment for AppliedPersonAndOrganizationAssignment {
    fn assigned_person_and_organization(&self) -> &EntityRef {
        &self.assigned_person_and_organization
    }
    fn role(&self) -> &EntityRef {
        &self.role
    }
}
impl IAppliedPersonAndOrganizationAssignment for AppliedPersonAndOrganizationAssignment {
    fn items(&self) -> &HashSet<EntityRef> {
        &self.items
    }
}
impl AppliedPersonAndOrganizationAssignment {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = AppliedPersonAndOrganizationAssignment::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.assigned_person_and_organization = parameter.into(),
                1usize => entity.role = parameter.into(),
                2usize => entity.items = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IAppliedPresentedItem: IPresentedItem {
    fn items(&self) -> &HashSet<EntityRef>;
}
#[derive(Default, Debug)]
pub struct AppliedPresentedItem {
    items: HashSet<EntityRef>,
}
impl IPresentedItem for AppliedPresentedItem {}
impl IAppliedPresentedItem for AppliedPresentedItem {
    fn items(&self) -> &HashSet<EntityRef> {
        &self.items
    }
}
impl AppliedPresentedItem {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = AppliedPresentedItem::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.items = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IAppliedSecurityClassificationAssignment: ISecurityClassificationAssignment {
    fn items(&self) -> &HashSet<EntityRef>;
}
#[derive(Default, Debug)]
pub struct AppliedSecurityClassificationAssignment {
    assigned_security_classification: EntityRef,
    items: HashSet<EntityRef>,
}
impl ISecurityClassificationAssignment for AppliedSecurityClassificationAssignment {
    fn assigned_security_classification(&self) -> &EntityRef {
        &self.assigned_security_classification
    }
}
impl IAppliedSecurityClassificationAssignment for AppliedSecurityClassificationAssignment {
    fn items(&self) -> &HashSet<EntityRef> {
        &self.items
    }
}
impl AppliedSecurityClassificationAssignment {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = AppliedSecurityClassificationAssignment::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.assigned_security_classification = parameter.into(),
                1usize => entity.items = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IAppliedTimeIntervalAssignment: ITimeIntervalAssignment {
    fn items(&self) -> &HashSet<EntityRef>;
}
#[derive(Default, Debug)]
pub struct AppliedTimeIntervalAssignment {
    assigned_time_interval: EntityRef,
    role: EntityRef,
    items: HashSet<EntityRef>,
}
impl ITimeIntervalAssignment for AppliedTimeIntervalAssignment {
    fn assigned_time_interval(&self) -> &EntityRef {
        &self.assigned_time_interval
    }
    fn role(&self) -> &EntityRef {
        &self.role
    }
}
impl IAppliedTimeIntervalAssignment for AppliedTimeIntervalAssignment {
    fn items(&self) -> &HashSet<EntityRef> {
        &self.items
    }
}
impl AppliedTimeIntervalAssignment {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = AppliedTimeIntervalAssignment::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.assigned_time_interval = parameter.into(),
                1usize => entity.role = parameter.into(),
                2usize => entity.items = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IApproval {
    fn status(&self) -> &EntityRef;
    fn level(&self) -> &Label;
}
#[derive(Default, Debug)]
pub struct Approval {
    status: EntityRef,
    level: Label,
}
impl IApproval for Approval {
    fn status(&self) -> &EntityRef {
        &self.status
    }
    fn level(&self) -> &Label {
        &self.level
    }
}
impl Approval {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = Approval::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.status = parameter.into(),
                1usize => entity.level = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IApprovalAssignment {
    fn assigned_approval(&self) -> &EntityRef;
}
pub trait IApprovalDateTime {
    fn date_time(&self) -> &EntityRef;
    fn dated_approval(&self) -> &EntityRef;
}
#[derive(Default, Debug)]
pub struct ApprovalDateTime {
    date_time: EntityRef,
    dated_approval: EntityRef,
}
impl IApprovalDateTime for ApprovalDateTime {
    fn date_time(&self) -> &EntityRef {
        &self.date_time
    }
    fn dated_approval(&self) -> &EntityRef {
        &self.dated_approval
    }
}
impl ApprovalDateTime {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = ApprovalDateTime::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.date_time = parameter.into(),
                1usize => entity.dated_approval = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IApprovalPersonOrganization {
    fn person_organization(&self) -> &EntityRef;
    fn authorized_approval(&self) -> &EntityRef;
    fn role(&self) -> &EntityRef;
}
#[derive(Default, Debug)]
pub struct ApprovalPersonOrganization {
    person_organization: EntityRef,
    authorized_approval: EntityRef,
    role: EntityRef,
}
impl IApprovalPersonOrganization for ApprovalPersonOrganization {
    fn person_organization(&self) -> &EntityRef {
        &self.person_organization
    }
    fn authorized_approval(&self) -> &EntityRef {
        &self.authorized_approval
    }
    fn role(&self) -> &EntityRef {
        &self.role
    }
}
impl ApprovalPersonOrganization {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = ApprovalPersonOrganization::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.person_organization = parameter.into(),
                1usize => entity.authorized_approval = parameter.into(),
                2usize => entity.role = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IApprovalRelationship {
    fn name(&self) -> &Label;
    fn description(&self) -> &Option<Text>;
    fn relating_approval(&self) -> &EntityRef;
    fn related_approval(&self) -> &EntityRef;
}
#[derive(Default, Debug)]
pub struct ApprovalRelationship {
    name: Label,
    description: Option<Text>,
    relating_approval: EntityRef,
    related_approval: EntityRef,
}
impl IApprovalRelationship for ApprovalRelationship {
    fn name(&self) -> &Label {
        &self.name
    }
    fn description(&self) -> &Option<Text> {
        &self.description
    }
    fn relating_approval(&self) -> &EntityRef {
        &self.relating_approval
    }
    fn related_approval(&self) -> &EntityRef {
        &self.related_approval
    }
}
impl ApprovalRelationship {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = ApprovalRelationship::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => entity.relating_approval = parameter.into(),
                3usize => entity.related_approval = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IApprovalRole {
    fn role(&self) -> &Label;
}
#[derive(Default, Debug)]
pub struct ApprovalRole {
    role: Label,
}
impl IApprovalRole for ApprovalRole {
    fn role(&self) -> &Label {
        &self.role
    }
}
impl ApprovalRole {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = ApprovalRole::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.role = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IApprovalStatus {
    fn name(&self) -> &Label;
}
#[derive(Default, Debug)]
pub struct ApprovalStatus {
    name: Label,
}
impl IApprovalStatus for ApprovalStatus {
    fn name(&self) -> &Label {
        &self.name
    }
}
impl ApprovalStatus {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = ApprovalStatus::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IApproximationTolerance: IFoundedItem {
    fn tolerance(&self) -> &EntityRef;
}
#[derive(Default, Debug)]
pub struct ApproximationTolerance {
    tolerance: EntityRef,
}
impl IFoundedItem for ApproximationTolerance {}
impl IApproximationTolerance for ApproximationTolerance {
    fn tolerance(&self) -> &EntityRef {
        &self.tolerance
    }
}
impl ApproximationTolerance {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = ApproximationTolerance::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.tolerance = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IApproximationToleranceDeviation: IFoundedItem {
    fn tessellation_type(&self) -> &ApproximationMethod;
    fn tolerances(&self) -> &HashSet<ToleranceDeviationSelect>;
    fn definition_space(&self) -> &ProductOrPresentationSpace;
}
#[derive(Default, Debug)]
pub struct ApproximationToleranceDeviation {
    tessellation_type: ApproximationMethod,
    tolerances: HashSet<ToleranceDeviationSelect>,
    definition_space: ProductOrPresentationSpace,
}
impl IFoundedItem for ApproximationToleranceDeviation {}
impl IApproximationToleranceDeviation for ApproximationToleranceDeviation {
    fn tessellation_type(&self) -> &ApproximationMethod {
        &self.tessellation_type
    }
    fn tolerances(&self) -> &HashSet<ToleranceDeviationSelect> {
        &self.tolerances
    }
    fn definition_space(&self) -> &ProductOrPresentationSpace {
        &self.definition_space
    }
}
impl ApproximationToleranceDeviation {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = ApproximationToleranceDeviation::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.tessellation_type = parameter.into(),
                1usize => entity.tolerances = parameter.into(),
                2usize => entity.definition_space = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IApproximationToleranceParameter: IFoundedItem {
    fn tolerances(&self) -> &HashSet<ToleranceParameterSelect>;
}
#[derive(Default, Debug)]
pub struct ApproximationToleranceParameter {
    tolerances: HashSet<ToleranceParameterSelect>,
}
impl IFoundedItem for ApproximationToleranceParameter {}
impl IApproximationToleranceParameter for ApproximationToleranceParameter {
    fn tolerances(&self) -> &HashSet<ToleranceParameterSelect> {
        &self.tolerances
    }
}
impl ApproximationToleranceParameter {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = ApproximationToleranceParameter::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.tolerances = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IAreaInSet {
    fn area(&self) -> &EntityRef;
    fn in_set(&self) -> &EntityRef;
}
#[derive(Default, Debug)]
pub struct AreaInSet {
    area: EntityRef,
    in_set: EntityRef,
}
impl IAreaInSet for AreaInSet {
    fn area(&self) -> &EntityRef {
        &self.area
    }
    fn in_set(&self) -> &EntityRef {
        &self.in_set
    }
}
impl AreaInSet {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = AreaInSet::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.area = parameter.into(),
                1usize => entity.in_set = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IAreaMeasureWithUnit: IMeasureWithUnit {}
#[derive(Default, Debug)]
pub struct AreaMeasureWithUnit {
    value_component: MeasureValue,
    unit_component: EntityRef,
}
impl IMeasureWithUnit for AreaMeasureWithUnit {
    fn value_component(&self) -> &MeasureValue {
        &self.value_component
    }
    fn unit_component(&self) -> &EntityRef {
        &self.unit_component
    }
}
impl IAreaMeasureWithUnit for AreaMeasureWithUnit {}
impl AreaMeasureWithUnit {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = AreaMeasureWithUnit::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.value_component = parameter.into(),
                1usize => entity.unit_component = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IAreaUnit: IDerivedUnit {}
#[derive(Default, Debug)]
pub struct AreaUnit {
    elements: HashSet<EntityRef>,
}
impl IDerivedUnit for AreaUnit {
    fn elements(&self) -> &HashSet<EntityRef> {
        &self.elements
    }
}
impl IAreaUnit for AreaUnit {}
impl AreaUnit {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = AreaUnit::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.elements = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IAsinFunction: IUnaryFunctionCall {}
#[derive(Default, Debug)]
pub struct AsinFunction {
    operand: EntityRef,
}
impl IGenericExpression for AsinFunction {}
impl IExpression for AsinFunction {}
impl INumericExpression for AsinFunction {}
impl IUnaryNumericExpression for AsinFunction {
    fn operand(&self) -> &EntityRef {
        &self.operand
    }
}
impl IUnaryGenericExpression for AsinFunction {
    fn operand(&self) -> &EntityRef {
        &self.operand
    }
}
impl IUnaryFunctionCall for AsinFunction {}
impl IAsinFunction for AsinFunction {}
impl AsinFunction {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = AsinFunction::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.operand = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IAssemblyComponentUsage: IProductDefinitionUsage {
    fn reference_designator(&self) -> &Option<Identifier>;
}
#[derive(Default, Debug)]
pub struct AssemblyComponentUsage {
    id: Identifier,
    name: Label,
    description: Option<Text>,
    relating_product_definition: EntityRef,
    related_product_definition: EntityRef,
    reference_designator: Option<Identifier>,
}
impl IProductDefinitionRelationship for AssemblyComponentUsage {
    fn id(&self) -> &Identifier {
        &self.id
    }
    fn name(&self) -> &Label {
        &self.name
    }
    fn description(&self) -> &Option<Text> {
        &self.description
    }
    fn relating_product_definition(&self) -> &EntityRef {
        &self.relating_product_definition
    }
    fn related_product_definition(&self) -> &EntityRef {
        &self.related_product_definition
    }
}
impl IProductDefinitionUsage for AssemblyComponentUsage {}
impl IAssemblyComponentUsage for AssemblyComponentUsage {
    fn reference_designator(&self) -> &Option<Identifier> {
        &self.reference_designator
    }
}
impl AssemblyComponentUsage {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = AssemblyComponentUsage::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.id = parameter.into(),
                1usize => entity.name = parameter.into(),
                2usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => entity.relating_product_definition = parameter.into(),
                4usize => entity.related_product_definition = parameter.into(),
                5usize => {
                    entity.reference_designator = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
}
pub trait IAssemblyComponentUsageSubstitute {
    fn name(&self) -> &Label;
    fn definition(&self) -> &Option<Text>;
    fn base(&self) -> &EntityRef;
    fn substitute(&self) -> &EntityRef;
}
#[derive(Default, Debug)]
pub struct AssemblyComponentUsageSubstitute {
    name: Label,
    definition: Option<Text>,
    base: EntityRef,
    substitute: EntityRef,
}
impl IAssemblyComponentUsageSubstitute for AssemblyComponentUsageSubstitute {
    fn name(&self) -> &Label {
        &self.name
    }
    fn definition(&self) -> &Option<Text> {
        &self.definition
    }
    fn base(&self) -> &EntityRef {
        &self.base
    }
    fn substitute(&self) -> &EntityRef {
        &self.substitute
    }
}
impl AssemblyComponentUsageSubstitute {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = AssemblyComponentUsageSubstitute::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => {
                    entity.definition = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => entity.base = parameter.into(),
                3usize => entity.substitute = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IAtanFunction: IBinaryFunctionCall {}
#[derive(Default, Debug)]
pub struct AtanFunction {
    operands: Vec<EntityRef>,
}
impl IGenericExpression for AtanFunction {}
impl IExpression for AtanFunction {}
impl INumericExpression for AtanFunction {}
impl IBinaryNumericExpression for AtanFunction {
    fn operands(&self) -> &Vec<EntityRef> {
        &self.operands
    }
}
impl IBinaryGenericExpression for AtanFunction {
    fn operands(&self) -> &Vec<EntityRef> {
        &self.operands
    }
}
impl IBinaryFunctionCall for AtanFunction {}
impl IAtanFunction for AtanFunction {}
impl AtanFunction {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = AtanFunction::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.operands = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IAttributeClassificationAssignment {
    fn assigned_class(&self) -> &EntityRef;
    fn attribute_name(&self) -> &Label;
    fn role(&self) -> &EntityRef;
}
pub trait IAttributeLanguageAssignment: IAttributeClassificationAssignment {
    fn items(&self) -> &HashSet<EntityRef>;
}
#[derive(Default, Debug)]
pub struct AttributeLanguageAssignment {
    assigned_class: EntityRef,
    attribute_name: Label,
    role: EntityRef,
    items: HashSet<EntityRef>,
}
impl IAttributeClassificationAssignment for AttributeLanguageAssignment {
    fn assigned_class(&self) -> &EntityRef {
        &self.assigned_class
    }
    fn attribute_name(&self) -> &Label {
        &self.attribute_name
    }
    fn role(&self) -> &EntityRef {
        &self.role
    }
}
impl IAttributeLanguageAssignment for AttributeLanguageAssignment {
    fn items(&self) -> &HashSet<EntityRef> {
        &self.items
    }
}
impl AttributeLanguageAssignment {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = AttributeLanguageAssignment::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.assigned_class = parameter.into(),
                1usize => entity.attribute_name = parameter.into(),
                2usize => entity.role = parameter.into(),
                3usize => entity.items = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IAttributeValueAssignment {
    fn attribute_name(&self) -> &Label;
    fn attribute_value(&self) -> &AttributeType;
    fn role(&self) -> &EntityRef;
}
pub trait IAttributeValueRole {
    fn name(&self) -> &Label;
    fn description(&self) -> &Option<Text>;
}
#[derive(Default, Debug)]
pub struct AttributeValueRole {
    name: Label,
    description: Option<Text>,
}
impl IAttributeValueRole for AttributeValueRole {
    fn name(&self) -> &Label {
        &self.name
    }
    fn description(&self) -> &Option<Text> {
        &self.description
    }
}
impl AttributeValueRole {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = AttributeValueRole::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
}
pub trait IAxis1Placement: IPlacement {
    fn axis(&self) -> &Option<EntityRef>;
}
#[derive(Default, Debug)]
pub struct Axis1Placement {
    name: Label,
    location: EntityRef,
    axis: Option<EntityRef>,
}
impl IRepresentationItem for Axis1Placement {
    fn name(&self) -> &Label {
        &self.name
    }
}
impl IGeometricRepresentationItem for Axis1Placement {}
impl IPlacement for Axis1Placement {
    fn location(&self) -> &EntityRef {
        &self.location
    }
}
impl IAxis1Placement for Axis1Placement {
    fn axis(&self) -> &Option<EntityRef> {
        &self.axis
    }
}
impl Axis1Placement {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = Axis1Placement::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => entity.location = parameter.into(),
                2usize => {
                    entity.axis = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
}
pub trait IAxis2Placement2d: IPlacement {
    fn ref_direction(&self) -> &Option<EntityRef>;
}
#[derive(Default, Debug)]
pub struct Axis2Placement2d {
    name: Label,
    location: EntityRef,
    ref_direction: Option<EntityRef>,
}
impl IRepresentationItem for Axis2Placement2d {
    fn name(&self) -> &Label {
        &self.name
    }
}
impl IGeometricRepresentationItem for Axis2Placement2d {}
impl IPlacement for Axis2Placement2d {
    fn location(&self) -> &EntityRef {
        &self.location
    }
}
impl IAxis2Placement2d for Axis2Placement2d {
    fn ref_direction(&self) -> &Option<EntityRef> {
        &self.ref_direction
    }
}
impl Axis2Placement2d {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = Axis2Placement2d::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => entity.location = parameter.into(),
                2usize => {
                    entity.ref_direction = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
}
pub trait IAxis2Placement3d: IPlacement {
    fn axis(&self) -> &Option<EntityRef>;
    fn ref_direction(&self) -> &Option<EntityRef>;
}
#[derive(Default, Debug)]
pub struct Axis2Placement3d {
    name: Label,
    location: EntityRef,
    axis: Option<EntityRef>,
    ref_direction: Option<EntityRef>,
}
impl IRepresentationItem for Axis2Placement3d {
    fn name(&self) -> &Label {
        &self.name
    }
}
impl IGeometricRepresentationItem for Axis2Placement3d {}
impl IPlacement for Axis2Placement3d {
    fn location(&self) -> &EntityRef {
        &self.location
    }
}
impl IAxis2Placement3d for Axis2Placement3d {
    fn axis(&self) -> &Option<EntityRef> {
        &self.axis
    }
    fn ref_direction(&self) -> &Option<EntityRef> {
        &self.ref_direction
    }
}
impl Axis2Placement3d {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = Axis2Placement3d::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => entity.location = parameter.into(),
                2usize => {
                    entity.axis = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.ref_direction = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
}
pub trait IBSplineCurve: IBoundedCurve {
    fn degree(&self) -> i64;
    fn control_points_list(&self) -> &Vec<EntityRef>;
    fn curve_form(&self) -> &BSplineCurveForm;
    fn closed_curve(&self) -> Option<bool>;
    fn self_intersect(&self) -> Option<bool>;
}
#[derive(Default, Debug)]
pub struct BSplineCurve {
    name: Label,
    degree: i64,
    control_points_list: Vec<EntityRef>,
    curve_form: BSplineCurveForm,
    closed_curve: Option<bool>,
    self_intersect: Option<bool>,
}
impl IRepresentationItem for BSplineCurve {
    fn name(&self) -> &Label {
        &self.name
    }
}
impl IGeometricRepresentationItem for BSplineCurve {}
impl ICurve for BSplineCurve {}
impl IBoundedCurve for BSplineCurve {}
impl IBSplineCurve for BSplineCurve {
    fn degree(&self) -> i64 {
        self.degree
    }
    fn control_points_list(&self) -> &Vec<EntityRef> {
        &self.control_points_list
    }
    fn curve_form(&self) -> &BSplineCurveForm {
        &self.curve_form
    }
    fn closed_curve(&self) -> Option<bool> {
        self.closed_curve
    }
    fn self_intersect(&self) -> Option<bool> {
        self.self_intersect
    }
}
impl BSplineCurve {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = BSplineCurve::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => entity.degree = parameter.into(),
                2usize => entity.control_points_list = parameter.into(),
                3usize => entity.curve_form = parameter.into(),
                4usize => entity.closed_curve = parameter.into(),
                5usize => entity.self_intersect = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IBSplineCurveWithKnots: IBSplineCurve {
    fn knot_multiplicities(&self) -> &Vec<i64>;
    fn knots(&self) -> &Vec<ParameterValue>;
    fn knot_spec(&self) -> &KnotType;
}
#[derive(Default, Debug)]
pub struct BSplineCurveWithKnots {
    name: Label,
    degree: i64,
    control_points_list: Vec<EntityRef>,
    curve_form: BSplineCurveForm,
    closed_curve: Option<bool>,
    self_intersect: Option<bool>,
    knot_multiplicities: Vec<i64>,
    knots: Vec<ParameterValue>,
    knot_spec: KnotType,
}
impl IRepresentationItem for BSplineCurveWithKnots {
    fn name(&self) -> &Label {
        &self.name
    }
}
impl IGeometricRepresentationItem for BSplineCurveWithKnots {}
impl ICurve for BSplineCurveWithKnots {}
impl IBoundedCurve for BSplineCurveWithKnots {}
impl IBSplineCurve for BSplineCurveWithKnots {
    fn degree(&self) -> i64 {
        self.degree
    }
    fn control_points_list(&self) -> &Vec<EntityRef> {
        &self.control_points_list
    }
    fn curve_form(&self) -> &BSplineCurveForm {
        &self.curve_form
    }
    fn closed_curve(&self) -> Option<bool> {
        self.closed_curve
    }
    fn self_intersect(&self) -> Option<bool> {
        self.self_intersect
    }
}
impl IBSplineCurveWithKnots for BSplineCurveWithKnots {
    fn knot_multiplicities(&self) -> &Vec<i64> {
        &self.knot_multiplicities
    }
    fn knots(&self) -> &Vec<ParameterValue> {
        &self.knots
    }
    fn knot_spec(&self) -> &KnotType {
        &self.knot_spec
    }
}
impl BSplineCurveWithKnots {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = BSplineCurveWithKnots::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => entity.degree = parameter.into(),
                2usize => entity.control_points_list = parameter.into(),
                3usize => entity.curve_form = parameter.into(),
                4usize => entity.closed_curve = parameter.into(),
                5usize => entity.self_intersect = parameter.into(),
                6usize => entity.knot_multiplicities = parameter.into(),
                7usize => entity.knots = parameter.into(),
                8usize => entity.knot_spec = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IBSplineSurface: IBoundedSurface {
    fn u_degree(&self) -> i64;
    fn v_degree(&self) -> i64;
    fn control_points_list(&self) -> &Vec<Vec<EntityRef>>;
    fn surface_form(&self) -> &BSplineSurfaceForm;
    fn u_closed(&self) -> Option<bool>;
    fn v_closed(&self) -> Option<bool>;
    fn self_intersect(&self) -> Option<bool>;
}
#[derive(Default, Debug)]
pub struct BSplineSurface {
    name: Label,
    u_degree: i64,
    v_degree: i64,
    control_points_list: Vec<Vec<EntityRef>>,
    surface_form: BSplineSurfaceForm,
    u_closed: Option<bool>,
    v_closed: Option<bool>,
    self_intersect: Option<bool>,
}
impl IRepresentationItem for BSplineSurface {
    fn name(&self) -> &Label {
        &self.name
    }
}
impl IGeometricRepresentationItem for BSplineSurface {}
impl ISurface for BSplineSurface {}
impl IBoundedSurface for BSplineSurface {}
impl IBSplineSurface for BSplineSurface {
    fn u_degree(&self) -> i64 {
        self.u_degree
    }
    fn v_degree(&self) -> i64 {
        self.v_degree
    }
    fn control_points_list(&self) -> &Vec<Vec<EntityRef>> {
        &self.control_points_list
    }
    fn surface_form(&self) -> &BSplineSurfaceForm {
        &self.surface_form
    }
    fn u_closed(&self) -> Option<bool> {
        self.u_closed
    }
    fn v_closed(&self) -> Option<bool> {
        self.v_closed
    }
    fn self_intersect(&self) -> Option<bool> {
        self.self_intersect
    }
}
impl BSplineSurface {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = BSplineSurface::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => entity.u_degree = parameter.into(),
                2usize => entity.v_degree = parameter.into(),
                3usize => entity.control_points_list = parameter.into(),
                4usize => entity.surface_form = parameter.into(),
                5usize => entity.u_closed = parameter.into(),
                6usize => entity.v_closed = parameter.into(),
                7usize => entity.self_intersect = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IBSplineSurfaceWithKnots: IBSplineSurface {
    fn u_multiplicities(&self) -> &Vec<i64>;
    fn v_multiplicities(&self) -> &Vec<i64>;
    fn u_knots(&self) -> &Vec<ParameterValue>;
    fn v_knots(&self) -> &Vec<ParameterValue>;
    fn knot_spec(&self) -> &KnotType;
}
#[derive(Default, Debug)]
pub struct BSplineSurfaceWithKnots {
    name: Label,
    u_degree: i64,
    v_degree: i64,
    control_points_list: Vec<Vec<EntityRef>>,
    surface_form: BSplineSurfaceForm,
    u_closed: Option<bool>,
    v_closed: Option<bool>,
    self_intersect: Option<bool>,
    u_multiplicities: Vec<i64>,
    v_multiplicities: Vec<i64>,
    u_knots: Vec<ParameterValue>,
    v_knots: Vec<ParameterValue>,
    knot_spec: KnotType,
}
impl IRepresentationItem for BSplineSurfaceWithKnots {
    fn name(&self) -> &Label {
        &self.name
    }
}
impl IGeometricRepresentationItem for BSplineSurfaceWithKnots {}
impl ISurface for BSplineSurfaceWithKnots {}
impl IBoundedSurface for BSplineSurfaceWithKnots {}
impl IBSplineSurface for BSplineSurfaceWithKnots {
    fn u_degree(&self) -> i64 {
        self.u_degree
    }
    fn v_degree(&self) -> i64 {
        self.v_degree
    }
    fn control_points_list(&self) -> &Vec<Vec<EntityRef>> {
        &self.control_points_list
    }
    fn surface_form(&self) -> &BSplineSurfaceForm {
        &self.surface_form
    }
    fn u_closed(&self) -> Option<bool> {
        self.u_closed
    }
    fn v_closed(&self) -> Option<bool> {
        self.v_closed
    }
    fn self_intersect(&self) -> Option<bool> {
        self.self_intersect
    }
}
impl IBSplineSurfaceWithKnots for BSplineSurfaceWithKnots {
    fn u_multiplicities(&self) -> &Vec<i64> {
        &self.u_multiplicities
    }
    fn v_multiplicities(&self) -> &Vec<i64> {
        &self.v_multiplicities
    }
    fn u_knots(&self) -> &Vec<ParameterValue> {
        &self.u_knots
    }
    fn v_knots(&self) -> &Vec<ParameterValue> {
        &self.v_knots
    }
    fn knot_spec(&self) -> &KnotType {
        &self.knot_spec
    }
}
impl BSplineSurfaceWithKnots {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = BSplineSurfaceWithKnots::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => entity.u_degree = parameter.into(),
                2usize => entity.v_degree = parameter.into(),
                3usize => entity.control_points_list = parameter.into(),
                4usize => entity.surface_form = parameter.into(),
                5usize => entity.u_closed = parameter.into(),
                6usize => entity.v_closed = parameter.into(),
                7usize => entity.self_intersect = parameter.into(),
                8usize => entity.u_multiplicities = parameter.into(),
                9usize => entity.v_multiplicities = parameter.into(),
                10usize => entity.u_knots = parameter.into(),
                11usize => entity.v_knots = parameter.into(),
                12usize => entity.knot_spec = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IBackgroundColour: IColour {
    fn presentation(&self) -> &EntityRef;
}
#[derive(Default, Debug)]
pub struct BackgroundColour {
    presentation: EntityRef,
}
impl IColour for BackgroundColour {}
impl IBackgroundColour for BackgroundColour {
    fn presentation(&self) -> &EntityRef {
        &self.presentation
    }
}
impl BackgroundColour {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = BackgroundColour::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.presentation = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IBarringHole: IFeatureDefinition {}
#[derive(Default, Debug)]
pub struct BarringHole {
    name: Label,
    description: Option<Text>,
}
impl ICharacterizedObject for BarringHole {
    fn name(&self) -> &Label {
        &self.name
    }
    fn description(&self) -> &Option<Text> {
        &self.description
    }
}
impl IFeatureDefinition for BarringHole {}
impl IBarringHole for BarringHole {}
impl BarringHole {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = BarringHole::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
}
pub trait IBead: IFeatureDefinition {}
#[derive(Default, Debug)]
pub struct Bead {
    name: Label,
    description: Option<Text>,
}
impl ICharacterizedObject for Bead {
    fn name(&self) -> &Label {
        &self.name
    }
    fn description(&self) -> &Option<Text> {
        &self.description
    }
}
impl IFeatureDefinition for Bead {}
impl IBead for Bead {}
impl Bead {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = Bead::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
}
pub trait IBeadEnd: IShapeAspect {}
#[derive(Default, Debug)]
pub struct BeadEnd {
    name: Label,
    description: Option<Text>,
    of_shape: EntityRef,
    product_definitional: Option<bool>,
}
impl IShapeAspect for BeadEnd {
    fn name(&self) -> &Label {
        &self.name
    }
    fn description(&self) -> &Option<Text> {
        &self.description
    }
    fn of_shape(&self) -> &EntityRef {
        &self.of_shape
    }
    fn product_definitional(&self) -> Option<bool> {
        self.product_definitional
    }
}
impl IBeadEnd for BeadEnd {}
impl BeadEnd {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = BeadEnd::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => entity.of_shape = parameter.into(),
                3usize => entity.product_definitional = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IBezierCurve: IBSplineCurve {}
#[derive(Default, Debug)]
pub struct BezierCurve {
    name: Label,
    degree: i64,
    control_points_list: Vec<EntityRef>,
    curve_form: BSplineCurveForm,
    closed_curve: Option<bool>,
    self_intersect: Option<bool>,
}
impl IRepresentationItem for BezierCurve {
    fn name(&self) -> &Label {
        &self.name
    }
}
impl IGeometricRepresentationItem for BezierCurve {}
impl ICurve for BezierCurve {}
impl IBoundedCurve for BezierCurve {}
impl IBSplineCurve for BezierCurve {
    fn degree(&self) -> i64 {
        self.degree
    }
    fn control_points_list(&self) -> &Vec<EntityRef> {
        &self.control_points_list
    }
    fn curve_form(&self) -> &BSplineCurveForm {
        &self.curve_form
    }
    fn closed_curve(&self) -> Option<bool> {
        self.closed_curve
    }
    fn self_intersect(&self) -> Option<bool> {
        self.self_intersect
    }
}
impl IBezierCurve for BezierCurve {}
impl BezierCurve {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = BezierCurve::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => entity.degree = parameter.into(),
                2usize => entity.control_points_list = parameter.into(),
                3usize => entity.curve_form = parameter.into(),
                4usize => entity.closed_curve = parameter.into(),
                5usize => entity.self_intersect = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IBezierSurface: IBSplineSurface {}
#[derive(Default, Debug)]
pub struct BezierSurface {
    name: Label,
    u_degree: i64,
    v_degree: i64,
    control_points_list: Vec<Vec<EntityRef>>,
    surface_form: BSplineSurfaceForm,
    u_closed: Option<bool>,
    v_closed: Option<bool>,
    self_intersect: Option<bool>,
}
impl IRepresentationItem for BezierSurface {
    fn name(&self) -> &Label {
        &self.name
    }
}
impl IGeometricRepresentationItem for BezierSurface {}
impl ISurface for BezierSurface {}
impl IBoundedSurface for BezierSurface {}
impl IBSplineSurface for BezierSurface {
    fn u_degree(&self) -> i64 {
        self.u_degree
    }
    fn v_degree(&self) -> i64 {
        self.v_degree
    }
    fn control_points_list(&self) -> &Vec<Vec<EntityRef>> {
        &self.control_points_list
    }
    fn surface_form(&self) -> &BSplineSurfaceForm {
        &self.surface_form
    }
    fn u_closed(&self) -> Option<bool> {
        self.u_closed
    }
    fn v_closed(&self) -> Option<bool> {
        self.v_closed
    }
    fn self_intersect(&self) -> Option<bool> {
        self.self_intersect
    }
}
impl IBezierSurface for BezierSurface {}
impl BezierSurface {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = BezierSurface::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => entity.u_degree = parameter.into(),
                2usize => entity.v_degree = parameter.into(),
                3usize => entity.control_points_list = parameter.into(),
                4usize => entity.surface_form = parameter.into(),
                5usize => entity.u_closed = parameter.into(),
                6usize => entity.v_closed = parameter.into(),
                7usize => entity.self_intersect = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IBinaryBooleanExpression: IBooleanExpression + IBinaryGenericExpression {}
pub trait IBinaryFunctionCall: IBinaryNumericExpression {}
pub trait IBinaryGenericExpression: IGenericExpression {
    fn operands(&self) -> &Vec<EntityRef>;
}
pub trait IBinaryNumericExpression: INumericExpression + IBinaryGenericExpression {
    fn operands(&self) -> &Vec<EntityRef>;
}
pub trait IBlock: IGeometricRepresentationItem {
    fn position(&self) -> &EntityRef;
    fn x(&self) -> &PositiveLengthMeasure;
    fn y(&self) -> &PositiveLengthMeasure;
    fn z(&self) -> &PositiveLengthMeasure;
}
#[derive(Default, Debug)]
pub struct Block {
    name: Label,
    position: EntityRef,
    x: PositiveLengthMeasure,
    y: PositiveLengthMeasure,
    z: PositiveLengthMeasure,
}
impl IRepresentationItem for Block {
    fn name(&self) -> &Label {
        &self.name
    }
}
impl IGeometricRepresentationItem for Block {}
impl IBlock for Block {
    fn position(&self) -> &EntityRef {
        &self.position
    }
    fn x(&self) -> &PositiveLengthMeasure {
        &self.x
    }
    fn y(&self) -> &PositiveLengthMeasure {
        &self.y
    }
    fn z(&self) -> &PositiveLengthMeasure {
        &self.z
    }
}
impl Block {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = Block::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => entity.position = parameter.into(),
                2usize => entity.x = parameter.into(),
                3usize => entity.y = parameter.into(),
                4usize => entity.z = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IBooleanDefinedFunction: IDefinedFunction + IBooleanExpression {}
pub trait IBooleanExpression: IExpression {}
pub trait IBooleanLiteral: ISimpleBooleanExpression + IGenericLiteral {
    fn the_value(&self) -> bool;
}
#[derive(Default, Debug)]
pub struct BooleanLiteral {
    the_value: bool,
}
impl IGenericExpression for BooleanLiteral {}
impl IExpression for BooleanLiteral {}
impl IBooleanExpression for BooleanLiteral {}
impl ISimpleBooleanExpression for BooleanLiteral {}
impl ISimpleGenericExpression for BooleanLiteral {}
impl IBooleanLiteral for BooleanLiteral {
    fn the_value(&self) -> bool {
        self.the_value
    }
}
impl IGenericLiteral for BooleanLiteral {}
impl BooleanLiteral {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = BooleanLiteral::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.the_value = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IBooleanResult: IGeometricRepresentationItem {
    fn operator(&self) -> &BooleanOperator;
    fn first_operand(&self) -> &EntityRef;
    fn second_operand(&self) -> &EntityRef;
}
#[derive(Default, Debug)]
pub struct BooleanResult {
    name: Label,
    operator: BooleanOperator,
    first_operand: EntityRef,
    second_operand: EntityRef,
}
impl IRepresentationItem for BooleanResult {
    fn name(&self) -> &Label {
        &self.name
    }
}
impl IGeometricRepresentationItem for BooleanResult {}
impl IBooleanResult for BooleanResult {
    fn operator(&self) -> &BooleanOperator {
        &self.operator
    }
    fn first_operand(&self) -> &EntityRef {
        &self.first_operand
    }
    fn second_operand(&self) -> &EntityRef {
        &self.second_operand
    }
}
impl BooleanResult {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = BooleanResult::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => entity.operator = parameter.into(),
                2usize => entity.first_operand = parameter.into(),
                3usize => entity.second_operand = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IBooleanVariable: ISimpleBooleanExpression + IVariable {}
#[derive(Default, Debug)]
pub struct BooleanVariable {}
impl IGenericExpression for BooleanVariable {}
impl IExpression for BooleanVariable {}
impl IBooleanExpression for BooleanVariable {}
impl ISimpleBooleanExpression for BooleanVariable {}
impl ISimpleGenericExpression for BooleanVariable {}
impl IBooleanVariable for BooleanVariable {}
impl IVariable for BooleanVariable {}
impl IGenericVariable for BooleanVariable {}
impl BooleanVariable {
    pub fn form_parameters(_parameters: Vec<Parameter>) -> Self {
        BooleanVariable::default()
    }
}
pub trait IBoss: IFeatureDefinition {}
#[derive(Default, Debug)]
pub struct Boss {
    name: Label,
    description: Option<Text>,
}
impl ICharacterizedObject for Boss {
    fn name(&self) -> &Label {
        &self.name
    }
    fn description(&self) -> &Option<Text> {
        &self.description
    }
}
impl IFeatureDefinition for Boss {}
impl IBoss for Boss {}
impl Boss {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = Boss::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
}
pub trait IBossTop: IShapeAspect {}
#[derive(Default, Debug)]
pub struct BossTop {
    name: Label,
    description: Option<Text>,
    of_shape: EntityRef,
    product_definitional: Option<bool>,
}
impl IShapeAspect for BossTop {
    fn name(&self) -> &Label {
        &self.name
    }
    fn description(&self) -> &Option<Text> {
        &self.description
    }
    fn of_shape(&self) -> &EntityRef {
        &self.of_shape
    }
    fn product_definitional(&self) -> Option<bool> {
        self.product_definitional
    }
}
impl IBossTop for BossTop {}
impl BossTop {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = BossTop::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => entity.of_shape = parameter.into(),
                3usize => entity.product_definitional = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IBoundaryCurve: ICompositeCurveOnSurface {}
#[derive(Default, Debug)]
pub struct BoundaryCurve {
    name: Label,
    segments: Vec<EntityRef>,
    self_intersect: Option<bool>,
}
impl IRepresentationItem for BoundaryCurve {
    fn name(&self) -> &Label {
        &self.name
    }
}
impl IGeometricRepresentationItem for BoundaryCurve {}
impl ICurve for BoundaryCurve {}
impl IBoundedCurve for BoundaryCurve {}
impl ICompositeCurve for BoundaryCurve {
    fn segments(&self) -> &Vec<EntityRef> {
        &self.segments
    }
    fn self_intersect(&self) -> Option<bool> {
        self.self_intersect
    }
}
impl ICompositeCurveOnSurface for BoundaryCurve {}
impl IBoundaryCurve for BoundaryCurve {}
impl BoundaryCurve {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = BoundaryCurve::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => entity.segments = parameter.into(),
                2usize => entity.self_intersect = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IBoundedCurve: ICurve {}
#[derive(Default, Debug)]
pub struct BoundedCurve {
    name: Label,
}
impl IRepresentationItem for BoundedCurve {
    fn name(&self) -> &Label {
        &self.name
    }
}
impl IGeometricRepresentationItem for BoundedCurve {}
impl ICurve for BoundedCurve {}
impl IBoundedCurve for BoundedCurve {}
impl BoundedCurve {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = BoundedCurve::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IBoundedPcurve: IPcurve + IBoundedCurve {}
#[derive(Default, Debug)]
pub struct BoundedPcurve {
    name: Label,
    basis_surface: EntityRef,
    reference_to_curve: EntityRef,
}
impl IRepresentationItem for BoundedPcurve {
    fn name(&self) -> &Label {
        &self.name
    }
}
impl IGeometricRepresentationItem for BoundedPcurve {}
impl ICurve for BoundedPcurve {}
impl IPcurve for BoundedPcurve {
    fn basis_surface(&self) -> &EntityRef {
        &self.basis_surface
    }
    fn reference_to_curve(&self) -> &EntityRef {
        &self.reference_to_curve
    }
}
impl IBoundedPcurve for BoundedPcurve {}
impl IBoundedCurve for BoundedPcurve {}
impl BoundedPcurve {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = BoundedPcurve::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => entity.basis_surface = parameter.into(),
                2usize => entity.reference_to_curve = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IBoundedSurface: ISurface {}
#[derive(Default, Debug)]
pub struct BoundedSurface {
    name: Label,
}
impl IRepresentationItem for BoundedSurface {
    fn name(&self) -> &Label {
        &self.name
    }
}
impl IGeometricRepresentationItem for BoundedSurface {}
impl ISurface for BoundedSurface {}
impl IBoundedSurface for BoundedSurface {}
impl BoundedSurface {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = BoundedSurface::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IBoundedSurfaceCurve: ISurfaceCurve + IBoundedCurve {}
#[derive(Default, Debug)]
pub struct BoundedSurfaceCurve {
    name: Label,
    curve_3d: EntityRef,
    associated_geometry: Vec<EntityRef>,
    master_representation: PreferredSurfaceCurveRepresentation,
}
impl IRepresentationItem for BoundedSurfaceCurve {
    fn name(&self) -> &Label {
        &self.name
    }
}
impl IGeometricRepresentationItem for BoundedSurfaceCurve {}
impl ICurve for BoundedSurfaceCurve {}
impl ISurfaceCurve for BoundedSurfaceCurve {
    fn curve_3d(&self) -> &EntityRef {
        &self.curve_3d
    }
    fn associated_geometry(&self) -> &Vec<EntityRef> {
        &self.associated_geometry
    }
    fn master_representation(&self) -> &PreferredSurfaceCurveRepresentation {
        &self.master_representation
    }
}
impl IBoundedSurfaceCurve for BoundedSurfaceCurve {}
impl IBoundedCurve for BoundedSurfaceCurve {}
impl BoundedSurfaceCurve {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = BoundedSurfaceCurve::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => entity.curve_3d = parameter.into(),
                2usize => entity.associated_geometry = parameter.into(),
                3usize => entity.master_representation = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IBoxDomain: IFoundedItem {
    fn corner(&self) -> &EntityRef;
    fn xlength(&self) -> &PositiveLengthMeasure;
    fn ylength(&self) -> &PositiveLengthMeasure;
    fn zlength(&self) -> &PositiveLengthMeasure;
}
#[derive(Default, Debug)]
pub struct BoxDomain {
    corner: EntityRef,
    xlength: PositiveLengthMeasure,
    ylength: PositiveLengthMeasure,
    zlength: PositiveLengthMeasure,
}
impl IFoundedItem for BoxDomain {}
impl IBoxDomain for BoxDomain {
    fn corner(&self) -> &EntityRef {
        &self.corner
    }
    fn xlength(&self) -> &PositiveLengthMeasure {
        &self.xlength
    }
    fn ylength(&self) -> &PositiveLengthMeasure {
        &self.ylength
    }
    fn zlength(&self) -> &PositiveLengthMeasure {
        &self.zlength
    }
}
impl BoxDomain {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = BoxDomain::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.corner = parameter.into(),
                1usize => entity.xlength = parameter.into(),
                2usize => entity.ylength = parameter.into(),
                3usize => entity.zlength = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IBoxedHalfSpace: IHalfSpaceSolid {
    fn enclosure(&self) -> &EntityRef;
}
#[derive(Default, Debug)]
pub struct BoxedHalfSpace {
    name: Label,
    base_surface: EntityRef,
    agreement_flag: bool,
    enclosure: EntityRef,
}
impl IRepresentationItem for BoxedHalfSpace {
    fn name(&self) -> &Label {
        &self.name
    }
}
impl IGeometricRepresentationItem for BoxedHalfSpace {}
impl IHalfSpaceSolid for BoxedHalfSpace {
    fn base_surface(&self) -> &EntityRef {
        &self.base_surface
    }
    fn agreement_flag(&self) -> bool {
        self.agreement_flag
    }
}
impl IBoxedHalfSpace for BoxedHalfSpace {
    fn enclosure(&self) -> &EntityRef {
        &self.enclosure
    }
}
impl BoxedHalfSpace {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = BoxedHalfSpace::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => entity.base_surface = parameter.into(),
                2usize => entity.agreement_flag = parameter.into(),
                3usize => entity.enclosure = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IBrepWithVoids: IManifoldSolidBrep {
    fn voids(&self) -> &HashSet<EntityRef>;
}
#[derive(Default, Debug)]
pub struct BrepWithVoids {
    name: Label,
    outer: EntityRef,
    voids: HashSet<EntityRef>,
}
impl IRepresentationItem for BrepWithVoids {
    fn name(&self) -> &Label {
        &self.name
    }
}
impl IGeometricRepresentationItem for BrepWithVoids {}
impl ISolidModel for BrepWithVoids {}
impl IManifoldSolidBrep for BrepWithVoids {
    fn outer(&self) -> &EntityRef {
        &self.outer
    }
}
impl IBrepWithVoids for BrepWithVoids {
    fn voids(&self) -> &HashSet<EntityRef> {
        &self.voids
    }
}
impl BrepWithVoids {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = BrepWithVoids::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => entity.outer = parameter.into(),
                2usize => entity.voids = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait ICalendarDate: IDate {
    fn day_component(&self) -> &DayInMonthNumber;
    fn month_component(&self) -> &MonthInYearNumber;
}
#[derive(Default, Debug)]
pub struct CalendarDate {
    year_component: YearNumber,
    day_component: DayInMonthNumber,
    month_component: MonthInYearNumber,
}
impl IDate for CalendarDate {
    fn year_component(&self) -> &YearNumber {
        &self.year_component
    }
}
impl ICalendarDate for CalendarDate {
    fn day_component(&self) -> &DayInMonthNumber {
        &self.day_component
    }
    fn month_component(&self) -> &MonthInYearNumber {
        &self.month_component
    }
}
impl CalendarDate {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = CalendarDate::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.year_component = parameter.into(),
                1usize => entity.day_component = parameter.into(),
                2usize => entity.month_component = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait ICameraImage: IMappedItem {
    fn mapping_source(&self) -> &EntityRef;
    fn mapping_target(&self) -> &EntityRef;
}
#[derive(Default, Debug)]
pub struct CameraImage {
    name: Label,
    mapping_source: EntityRef,
    mapping_target: EntityRef,
}
impl IRepresentationItem for CameraImage {
    fn name(&self) -> &Label {
        &self.name
    }
}
impl IMappedItem for CameraImage {
    fn mapping_source(&self) -> &EntityRef {
        &self.mapping_source
    }
    fn mapping_target(&self) -> &EntityRef {
        &self.mapping_target
    }
}
impl ICameraImage for CameraImage {
    fn mapping_source(&self) -> &EntityRef {
        &self.mapping_source
    }
    fn mapping_target(&self) -> &EntityRef {
        &self.mapping_target
    }
}
impl CameraImage {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = CameraImage::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => entity.mapping_source = parameter.into(),
                2usize => entity.mapping_target = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait ICameraImage2dWithScale: ICameraImage {}
#[derive(Default, Debug)]
pub struct CameraImage2dWithScale {
    name: Label,
    mapping_source: EntityRef,
    mapping_target: EntityRef,
}
impl IRepresentationItem for CameraImage2dWithScale {
    fn name(&self) -> &Label {
        &self.name
    }
}
impl IMappedItem for CameraImage2dWithScale {
    fn mapping_source(&self) -> &EntityRef {
        &self.mapping_source
    }
    fn mapping_target(&self) -> &EntityRef {
        &self.mapping_target
    }
}
impl ICameraImage for CameraImage2dWithScale {
    fn mapping_source(&self) -> &EntityRef {
        &self.mapping_source
    }
    fn mapping_target(&self) -> &EntityRef {
        &self.mapping_target
    }
}
impl ICameraImage2dWithScale for CameraImage2dWithScale {}
impl CameraImage2dWithScale {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = CameraImage2dWithScale::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => entity.mapping_source = parameter.into(),
                2usize => entity.mapping_target = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait ICameraImage3dWithScale: ICameraImage {}
#[derive(Default, Debug)]
pub struct CameraImage3dWithScale {
    name: Label,
    mapping_source: EntityRef,
    mapping_target: EntityRef,
}
impl IRepresentationItem for CameraImage3dWithScale {
    fn name(&self) -> &Label {
        &self.name
    }
}
impl IMappedItem for CameraImage3dWithScale {
    fn mapping_source(&self) -> &EntityRef {
        &self.mapping_source
    }
    fn mapping_target(&self) -> &EntityRef {
        &self.mapping_target
    }
}
impl ICameraImage for CameraImage3dWithScale {
    fn mapping_source(&self) -> &EntityRef {
        &self.mapping_source
    }
    fn mapping_target(&self) -> &EntityRef {
        &self.mapping_target
    }
}
impl ICameraImage3dWithScale for CameraImage3dWithScale {}
impl CameraImage3dWithScale {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = CameraImage3dWithScale::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => entity.mapping_source = parameter.into(),
                2usize => entity.mapping_target = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait ICameraModel: IGeometricRepresentationItem {}
pub trait ICameraModelD2: ICameraModel {
    fn view_window(&self) -> &EntityRef;
    fn view_window_clipping(&self) -> bool;
}
#[derive(Default, Debug)]
pub struct CameraModelD2 {
    name: Label,
    view_window: EntityRef,
    view_window_clipping: bool,
}
impl IRepresentationItem for CameraModelD2 {
    fn name(&self) -> &Label {
        &self.name
    }
}
impl IGeometricRepresentationItem for CameraModelD2 {}
impl ICameraModel for CameraModelD2 {}
impl ICameraModelD2 for CameraModelD2 {
    fn view_window(&self) -> &EntityRef {
        &self.view_window
    }
    fn view_window_clipping(&self) -> bool {
        self.view_window_clipping
    }
}
impl CameraModelD2 {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = CameraModelD2::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => entity.view_window = parameter.into(),
                2usize => entity.view_window_clipping = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait ICameraModelD3: ICameraModel {
    fn view_reference_system(&self) -> &EntityRef;
    fn perspective_of_volume(&self) -> &EntityRef;
}
#[derive(Default, Debug)]
pub struct CameraModelD3 {
    name: Label,
    view_reference_system: EntityRef,
    perspective_of_volume: EntityRef,
}
impl IRepresentationItem for CameraModelD3 {
    fn name(&self) -> &Label {
        &self.name
    }
}
impl IGeometricRepresentationItem for CameraModelD3 {}
impl ICameraModel for CameraModelD3 {}
impl ICameraModelD3 for CameraModelD3 {
    fn view_reference_system(&self) -> &EntityRef {
        &self.view_reference_system
    }
    fn perspective_of_volume(&self) -> &EntityRef {
        &self.perspective_of_volume
    }
}
impl CameraModelD3 {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = CameraModelD3::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => entity.view_reference_system = parameter.into(),
                2usize => entity.perspective_of_volume = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait ICameraModelD3WithHlhsr: ICameraModelD3 {
    fn hidden_line_surface_removal(&self) -> bool;
}
#[derive(Default, Debug)]
pub struct CameraModelD3WithHlhsr {
    name: Label,
    view_reference_system: EntityRef,
    perspective_of_volume: EntityRef,
    hidden_line_surface_removal: bool,
}
impl IRepresentationItem for CameraModelD3WithHlhsr {
    fn name(&self) -> &Label {
        &self.name
    }
}
impl IGeometricRepresentationItem for CameraModelD3WithHlhsr {}
impl ICameraModel for CameraModelD3WithHlhsr {}
impl ICameraModelD3 for CameraModelD3WithHlhsr {
    fn view_reference_system(&self) -> &EntityRef {
        &self.view_reference_system
    }
    fn perspective_of_volume(&self) -> &EntityRef {
        &self.perspective_of_volume
    }
}
impl ICameraModelD3WithHlhsr for CameraModelD3WithHlhsr {
    fn hidden_line_surface_removal(&self) -> bool {
        self.hidden_line_surface_removal
    }
}
impl CameraModelD3WithHlhsr {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = CameraModelD3WithHlhsr::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => entity.view_reference_system = parameter.into(),
                2usize => entity.perspective_of_volume = parameter.into(),
                3usize => entity.hidden_line_surface_removal = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait ICameraUsage: IRepresentationMap {
    fn mapping_origin(&self) -> &EntityRef;
}
#[derive(Default, Debug)]
pub struct CameraUsage {
    mapped_representation: EntityRef,
    mapping_origin: EntityRef,
}
impl IRepresentationMap for CameraUsage {
    fn mapping_origin(&self) -> &EntityRef {
        &self.mapping_origin
    }
    fn mapped_representation(&self) -> &EntityRef {
        &self.mapped_representation
    }
}
impl ICameraUsage for CameraUsage {
    fn mapping_origin(&self) -> &EntityRef {
        &self.mapping_origin
    }
}
impl CameraUsage {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = CameraUsage::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.mapped_representation = parameter.into(),
                1usize => entity.mapping_origin = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait ICartesianPoint: IPoint {
    fn coordinates(&self) -> &Vec<LengthMeasure>;
}
#[derive(Default, Debug)]
pub struct CartesianPoint {
    name: Label,
    coordinates: Vec<LengthMeasure>,
}
impl IRepresentationItem for CartesianPoint {
    fn name(&self) -> &Label {
        &self.name
    }
}
impl IGeometricRepresentationItem for CartesianPoint {}
impl IPoint for CartesianPoint {}
impl ICartesianPoint for CartesianPoint {
    fn coordinates(&self) -> &Vec<LengthMeasure> {
        &self.coordinates
    }
}
impl CartesianPoint {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = CartesianPoint::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => entity.coordinates = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait ICartesianTransformationOperator: IGeometricRepresentationItem + IFunctionallyDefinedTransformation {
    fn axis1(&self) -> &Option<EntityRef>;
    fn axis2(&self) -> &Option<EntityRef>;
    fn local_origin(&self) -> &EntityRef;
    fn scale(&self) -> Option<Real>;
}
#[derive(Default, Debug)]
pub struct CartesianTransformationOperator {
    name: Label,
    description: Option<Text>,
    axis1: Option<EntityRef>,
    axis2: Option<EntityRef>,
    local_origin: EntityRef,
    scale: Option<Real>,
}
impl IRepresentationItem for CartesianTransformationOperator {
    fn name(&self) -> &Label {
        &self.name
    }
}
impl IGeometricRepresentationItem for CartesianTransformationOperator {}
impl IFunctionallyDefinedTransformation for CartesianTransformationOperator {
    fn name(&self) -> &Label {
        &self.name
    }
    fn description(&self) -> &Option<Text> {
        &self.description
    }
}
impl ICartesianTransformationOperator for CartesianTransformationOperator {
    fn axis1(&self) -> &Option<EntityRef> {
        &self.axis1
    }
    fn axis2(&self) -> &Option<EntityRef> {
        &self.axis2
    }
    fn local_origin(&self) -> &EntityRef {
        &self.local_origin
    }
    fn scale(&self) -> Option<Real> {
        self.scale
    }
}
impl CartesianTransformationOperator {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = CartesianTransformationOperator::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => {
                    entity.axis1 = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.axis2 = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => entity.local_origin = parameter.into(),
                5usize => {
                    entity.scale = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
}
pub trait ICartesianTransformationOperator2d: ICartesianTransformationOperator {}
#[derive(Default, Debug)]
pub struct CartesianTransformationOperator2d {
    name: Label,
    description: Option<Text>,
    axis1: Option<EntityRef>,
    axis2: Option<EntityRef>,
    local_origin: EntityRef,
    scale: Option<Real>,
}
impl IRepresentationItem for CartesianTransformationOperator2d {
    fn name(&self) -> &Label {
        &self.name
    }
}
impl IGeometricRepresentationItem for CartesianTransformationOperator2d {}
impl IFunctionallyDefinedTransformation for CartesianTransformationOperator2d {
    fn name(&self) -> &Label {
        &self.name
    }
    fn description(&self) -> &Option<Text> {
        &self.description
    }
}
impl ICartesianTransformationOperator for CartesianTransformationOperator2d {
    fn axis1(&self) -> &Option<EntityRef> {
        &self.axis1
    }
    fn axis2(&self) -> &Option<EntityRef> {
        &self.axis2
    }
    fn local_origin(&self) -> &EntityRef {
        &self.local_origin
    }
    fn scale(&self) -> Option<Real> {
        self.scale
    }
}
impl ICartesianTransformationOperator2d for CartesianTransformationOperator2d {}
impl CartesianTransformationOperator2d {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = CartesianTransformationOperator2d::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => {
                    entity.axis1 = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.axis2 = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => entity.local_origin = parameter.into(),
                5usize => {
                    entity.scale = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
}
pub trait ICartesianTransformationOperator3d: ICartesianTransformationOperator {
    fn axis3(&self) -> &Option<EntityRef>;
}
#[derive(Default, Debug)]
pub struct CartesianTransformationOperator3d {
    name: Label,
    description: Option<Text>,
    axis1: Option<EntityRef>,
    axis2: Option<EntityRef>,
    local_origin: EntityRef,
    scale: Option<Real>,
    axis3: Option<EntityRef>,
}
impl IRepresentationItem for CartesianTransformationOperator3d {
    fn name(&self) -> &Label {
        &self.name
    }
}
impl IGeometricRepresentationItem for CartesianTransformationOperator3d {}
impl IFunctionallyDefinedTransformation for CartesianTransformationOperator3d {
    fn name(&self) -> &Label {
        &self.name
    }
    fn description(&self) -> &Option<Text> {
        &self.description
    }
}
impl ICartesianTransformationOperator for CartesianTransformationOperator3d {
    fn axis1(&self) -> &Option<EntityRef> {
        &self.axis1
    }
    fn axis2(&self) -> &Option<EntityRef> {
        &self.axis2
    }
    fn local_origin(&self) -> &EntityRef {
        &self.local_origin
    }
    fn scale(&self) -> Option<Real> {
        self.scale
    }
}
impl ICartesianTransformationOperator3d for CartesianTransformationOperator3d {
    fn axis3(&self) -> &Option<EntityRef> {
        &self.axis3
    }
}
impl CartesianTransformationOperator3d {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = CartesianTransformationOperator3d::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => {
                    entity.axis1 = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.axis2 = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => entity.local_origin = parameter.into(),
                5usize => {
                    entity.scale = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                6usize => {
                    entity.axis3 = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
}
pub trait ICelsiusTemperatureMeasureWithUnit: IMeasureWithUnit {}
#[derive(Default, Debug)]
pub struct CelsiusTemperatureMeasureWithUnit {
    value_component: MeasureValue,
    unit_component: EntityRef,
}
impl IMeasureWithUnit for CelsiusTemperatureMeasureWithUnit {
    fn value_component(&self) -> &MeasureValue {
        &self.value_component
    }
    fn unit_component(&self) -> &EntityRef {
        &self.unit_component
    }
}
impl ICelsiusTemperatureMeasureWithUnit for CelsiusTemperatureMeasureWithUnit {}
impl CelsiusTemperatureMeasureWithUnit {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = CelsiusTemperatureMeasureWithUnit::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.value_component = parameter.into(),
                1usize => entity.unit_component = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait ICentreOfSymmetry: IDerivedShapeAspect {}
#[derive(Default, Debug)]
pub struct CentreOfSymmetry {
    name: Label,
    description: Option<Text>,
    of_shape: EntityRef,
    product_definitional: Option<bool>,
}
impl IShapeAspect for CentreOfSymmetry {
    fn name(&self) -> &Label {
        &self.name
    }
    fn description(&self) -> &Option<Text> {
        &self.description
    }
    fn of_shape(&self) -> &EntityRef {
        &self.of_shape
    }
    fn product_definitional(&self) -> Option<bool> {
        self.product_definitional
    }
}
impl IDerivedShapeAspect for CentreOfSymmetry {}
impl ICentreOfSymmetry for CentreOfSymmetry {}
impl CentreOfSymmetry {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = CentreOfSymmetry::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => entity.of_shape = parameter.into(),
                3usize => entity.product_definitional = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait ICertification {
    fn name(&self) -> &Label;
    fn purpose(&self) -> &Text;
    fn kind(&self) -> &EntityRef;
}
#[derive(Default, Debug)]
pub struct Certification {
    name: Label,
    purpose: Text,
    kind: EntityRef,
}
impl ICertification for Certification {
    fn name(&self) -> &Label {
        &self.name
    }
    fn purpose(&self) -> &Text {
        &self.purpose
    }
    fn kind(&self) -> &EntityRef {
        &self.kind
    }
}
impl Certification {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = Certification::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => entity.purpose = parameter.into(),
                2usize => entity.kind = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait ICertificationAssignment {
    fn assigned_certification(&self) -> &EntityRef;
}
pub trait ICertificationType {
    fn description(&self) -> &Label;
}
#[derive(Default, Debug)]
pub struct CertificationType {
    description: Label,
}
impl ICertificationType for CertificationType {
    fn description(&self) -> &Label {
        &self.description
    }
}
impl CertificationType {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = CertificationType::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.description = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IChamfer: ITransitionFeature {}
#[derive(Default, Debug)]
pub struct Chamfer {
    name: Label,
    description: Option<Text>,
    of_shape: EntityRef,
    product_definitional: Option<bool>,
}
impl IShapeAspect for Chamfer {
    fn name(&self) -> &Label {
        &self.name
    }
    fn description(&self) -> &Option<Text> {
        &self.description
    }
    fn of_shape(&self) -> &EntityRef {
        &self.of_shape
    }
    fn product_definitional(&self) -> Option<bool> {
        self.product_definitional
    }
}
impl ITransitionFeature for Chamfer {}
impl IChamfer for Chamfer {}
impl Chamfer {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = Chamfer::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => entity.of_shape = parameter.into(),
                3usize => entity.product_definitional = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IChamferOffset: IShapeAspect {}
#[derive(Default, Debug)]
pub struct ChamferOffset {
    name: Label,
    description: Option<Text>,
    of_shape: EntityRef,
    product_definitional: Option<bool>,
}
impl IShapeAspect for ChamferOffset {
    fn name(&self) -> &Label {
        &self.name
    }
    fn description(&self) -> &Option<Text> {
        &self.description
    }
    fn of_shape(&self) -> &EntityRef {
        &self.of_shape
    }
    fn product_definitional(&self) -> Option<bool> {
        self.product_definitional
    }
}
impl IChamferOffset for ChamferOffset {}
impl ChamferOffset {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = ChamferOffset::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => entity.of_shape = parameter.into(),
                3usize => entity.product_definitional = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait ICharacterGlyphSymbol: IGenericCharacterGlyphSymbol {
    fn character_box(&self) -> &EntityRef;
    fn baseline_ratio(&self) -> &RatioMeasure;
}
#[derive(Default, Debug)]
pub struct CharacterGlyphSymbol {
    name: Label,
    items: HashSet<EntityRef>,
    context_of_items: EntityRef,
    character_box: EntityRef,
    baseline_ratio: RatioMeasure,
}
impl IRepresentation for CharacterGlyphSymbol {
    fn name(&self) -> &Label {
        &self.name
    }
    fn items(&self) -> &HashSet<EntityRef> {
        &self.items
    }
    fn context_of_items(&self) -> &EntityRef {
        &self.context_of_items
    }
}
impl ISymbolRepresentation for CharacterGlyphSymbol {}
impl IGenericCharacterGlyphSymbol for CharacterGlyphSymbol {}
impl ICharacterGlyphSymbol for CharacterGlyphSymbol {
    fn character_box(&self) -> &EntityRef {
        &self.character_box
    }
    fn baseline_ratio(&self) -> &RatioMeasure {
        &self.baseline_ratio
    }
}
impl CharacterGlyphSymbol {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = CharacterGlyphSymbol::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => entity.items = parameter.into(),
                2usize => entity.context_of_items = parameter.into(),
                3usize => entity.character_box = parameter.into(),
                4usize => entity.baseline_ratio = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait ICharacterizedClass: ICharacterizedObject + IClass {}
#[derive(Default, Debug)]
pub struct CharacterizedClass {
    name: Label,
    description: Option<Text>,
}
impl ICharacterizedObject for CharacterizedClass {
    fn name(&self) -> &Label {
        &self.name
    }
    fn description(&self) -> &Option<Text> {
        &self.description
    }
}
impl IGroup for CharacterizedClass {
    fn name(&self) -> &Label {
        &self.name
    }
    fn description(&self) -> &Option<Text> {
        &self.description
    }
}
impl IClass for CharacterizedClass {}
impl ICharacterizedClass for CharacterizedClass {}
impl CharacterizedClass {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = CharacterizedClass::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
}
pub trait ICharacterizedObject {
    fn name(&self) -> &Label;
    fn description(&self) -> &Option<Text>;
}
#[derive(Default, Debug)]
pub struct CharacterizedObject {
    name: Label,
    description: Option<Text>,
}
impl ICharacterizedObject for CharacterizedObject {
    fn name(&self) -> &Label {
        &self.name
    }
    fn description(&self) -> &Option<Text> {
        &self.description
    }
}
impl CharacterizedObject {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = CharacterizedObject::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
}
pub trait ICircle: IConic {
    fn radius(&self) -> &PositiveLengthMeasure;
}
#[derive(Default, Debug)]
pub struct Circle {
    name: Label,
    position: EntityRef,
    radius: PositiveLengthMeasure,
}
impl IRepresentationItem for Circle {
    fn name(&self) -> &Label {
        &self.name
    }
}
impl IGeometricRepresentationItem for Circle {}
impl ICurve for Circle {}
impl IConic for Circle {
    fn position(&self) -> &EntityRef {
        &self.position
    }
}
impl ICircle for Circle {
    fn radius(&self) -> &PositiveLengthMeasure {
        &self.radius
    }
}
impl Circle {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = Circle::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => entity.position = parameter.into(),
                2usize => entity.radius = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait ICircularClosedProfile: IShapeAspect {}
#[derive(Default, Debug)]
pub struct CircularClosedProfile {
    name: Label,
    description: Option<Text>,
    of_shape: EntityRef,
    product_definitional: Option<bool>,
}
impl IShapeAspect for CircularClosedProfile {
    fn name(&self) -> &Label {
        &self.name
    }
    fn description(&self) -> &Option<Text> {
        &self.description
    }
    fn of_shape(&self) -> &EntityRef {
        &self.of_shape
    }
    fn product_definitional(&self) -> Option<bool> {
        self.product_definitional
    }
}
impl ICircularClosedProfile for CircularClosedProfile {}
impl CircularClosedProfile {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = CircularClosedProfile::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => entity.of_shape = parameter.into(),
                3usize => entity.product_definitional = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait ICircularPattern: IReplicateFeature {}
#[derive(Default, Debug)]
pub struct CircularPattern {
    name: Label,
    description: Option<Text>,
}
impl ICharacterizedObject for CircularPattern {
    fn name(&self) -> &Label {
        &self.name
    }
    fn description(&self) -> &Option<Text> {
        &self.description
    }
}
impl IFeatureDefinition for CircularPattern {}
impl IReplicateFeature for CircularPattern {}
impl ICircularPattern for CircularPattern {}
impl CircularPattern {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = CircularPattern::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
}
pub trait ICircularRunoutTolerance: IGeometricToleranceWithDatumReference {}
#[derive(Default, Debug)]
pub struct CircularRunoutTolerance {
    name: Label,
    description: Text,
    magnitude: EntityRef,
    toleranced_shape_aspect: EntityRef,
    datum_system: HashSet<EntityRef>,
}
impl IGeometricTolerance for CircularRunoutTolerance {
    fn name(&self) -> &Label {
        &self.name
    }
    fn description(&self) -> &Text {
        &self.description
    }
    fn magnitude(&self) -> &EntityRef {
        &self.magnitude
    }
    fn toleranced_shape_aspect(&self) -> &EntityRef {
        &self.toleranced_shape_aspect
    }
}
impl IGeometricToleranceWithDatumReference for CircularRunoutTolerance {
    fn datum_system(&self) -> &HashSet<EntityRef> {
        &self.datum_system
    }
}
impl ICircularRunoutTolerance for CircularRunoutTolerance {}
impl CircularRunoutTolerance {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = CircularRunoutTolerance::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => entity.description = parameter.into(),
                2usize => entity.magnitude = parameter.into(),
                3usize => entity.toleranced_shape_aspect = parameter.into(),
                4usize => entity.datum_system = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IClass: IGroup {}
#[derive(Default, Debug)]
pub struct Class {
    name: Label,
    description: Option<Text>,
}
impl IGroup for Class {
    fn name(&self) -> &Label {
        &self.name
    }
    fn description(&self) -> &Option<Text> {
        &self.description
    }
}
impl IClass for Class {}
impl Class {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = Class::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
}
pub trait IClassSystem: IGroup {}
#[derive(Default, Debug)]
pub struct ClassSystem {
    name: Label,
    description: Option<Text>,
}
impl IGroup for ClassSystem {
    fn name(&self) -> &Label {
        &self.name
    }
    fn description(&self) -> &Option<Text> {
        &self.description
    }
}
impl IClassSystem for ClassSystem {}
impl ClassSystem {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = ClassSystem::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
}
pub trait IClassUsageEffectivityContextAssignment: IEffectivityContextAssignment {
    fn items(&self) -> &HashSet<EntityRef>;
}
#[derive(Default, Debug)]
pub struct ClassUsageEffectivityContextAssignment {
    assigned_effectivity_assignment: EntityRef,
    role: EntityRef,
    items: HashSet<EntityRef>,
}
impl IEffectivityContextAssignment for ClassUsageEffectivityContextAssignment {
    fn assigned_effectivity_assignment(&self) -> &EntityRef {
        &self.assigned_effectivity_assignment
    }
    fn role(&self) -> &EntityRef {
        &self.role
    }
}
impl IClassUsageEffectivityContextAssignment for ClassUsageEffectivityContextAssignment {
    fn items(&self) -> &HashSet<EntityRef> {
        &self.items
    }
}
impl ClassUsageEffectivityContextAssignment {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = ClassUsageEffectivityContextAssignment::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.assigned_effectivity_assignment = parameter.into(),
                1usize => entity.role = parameter.into(),
                2usize => entity.items = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IClassificationAssignment {
    fn assigned_class(&self) -> &EntityRef;
    fn role(&self) -> &EntityRef;
}
pub trait IClassificationRole {
    fn name(&self) -> &Label;
    fn description(&self) -> &Option<Text>;
}
#[derive(Default, Debug)]
pub struct ClassificationRole {
    name: Label,
    description: Option<Text>,
}
impl IClassificationRole for ClassificationRole {
    fn name(&self) -> &Label {
        &self.name
    }
    fn description(&self) -> &Option<Text> {
        &self.description
    }
}
impl ClassificationRole {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = ClassificationRole::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
}
pub trait IClosedPathProfile: IShapeAspect {}
#[derive(Default, Debug)]
pub struct ClosedPathProfile {
    name: Label,
    description: Option<Text>,
    of_shape: EntityRef,
    product_definitional: Option<bool>,
}
impl IShapeAspect for ClosedPathProfile {
    fn name(&self) -> &Label {
        &self.name
    }
    fn description(&self) -> &Option<Text> {
        &self.description
    }
    fn of_shape(&self) -> &EntityRef {
        &self.of_shape
    }
    fn product_definitional(&self) -> Option<bool> {
        self.product_definitional
    }
}
impl IClosedPathProfile for ClosedPathProfile {}
impl ClosedPathProfile {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = ClosedPathProfile::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => entity.of_shape = parameter.into(),
                3usize => entity.product_definitional = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IClosedShell: IConnectedFaceSet {}
#[derive(Default, Debug)]
pub struct ClosedShell {
    name: Label,
    cfs_faces: HashSet<EntityRef>,
}
impl IRepresentationItem for ClosedShell {
    fn name(&self) -> &Label {
        &self.name
    }
}
impl ITopologicalRepresentationItem for ClosedShell {}
impl IConnectedFaceSet for ClosedShell {
    fn cfs_faces(&self) -> &HashSet<EntityRef> {
        &self.cfs_faces
    }
}
impl IClosedShell for ClosedShell {}
impl ClosedShell {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = ClosedShell::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => entity.cfs_faces = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait ICoaxialityTolerance: IGeometricToleranceWithDatumReference {}
#[derive(Default, Debug)]
pub struct CoaxialityTolerance {
    name: Label,
    description: Text,
    magnitude: EntityRef,
    toleranced_shape_aspect: EntityRef,
    datum_system: HashSet<EntityRef>,
}
impl IGeometricTolerance for CoaxialityTolerance {
    fn name(&self) -> &Label {
        &self.name
    }
    fn description(&self) -> &Text {
        &self.description
    }
    fn magnitude(&self) -> &EntityRef {
        &self.magnitude
    }
    fn toleranced_shape_aspect(&self) -> &EntityRef {
        &self.toleranced_shape_aspect
    }
}
impl IGeometricToleranceWithDatumReference for CoaxialityTolerance {
    fn datum_system(&self) -> &HashSet<EntityRef> {
        &self.datum_system
    }
}
impl ICoaxialityTolerance for CoaxialityTolerance {}
impl CoaxialityTolerance {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = CoaxialityTolerance::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => entity.description = parameter.into(),
                2usize => entity.magnitude = parameter.into(),
                3usize => entity.toleranced_shape_aspect = parameter.into(),
                4usize => entity.datum_system = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IColour {}
#[derive(Default, Debug)]
pub struct Colour {}
impl IColour for Colour {}
impl Colour {
    pub fn form_parameters(_parameters: Vec<Parameter>) -> Self {
        Colour::default()
    }
}
pub trait IColourRgb: IColourSpecification {
    fn red(&self) -> Real;
    fn green(&self) -> Real;
    fn blue(&self) -> Real;
}
#[derive(Default, Debug)]
pub struct ColourRgb {
    name: Label,
    red: Real,
    green: Real,
    blue: Real,
}
impl IColour for ColourRgb {}
impl IColourSpecification for ColourRgb {
    fn name(&self) -> &Label {
        &self.name
    }
}
impl IColourRgb for ColourRgb {
    fn red(&self) -> Real {
        self.red
    }
    fn green(&self) -> Real {
        self.green
    }
    fn blue(&self) -> Real {
        self.blue
    }
}
impl ColourRgb {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = ColourRgb::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => entity.red = parameter.into(),
                2usize => entity.green = parameter.into(),
                3usize => entity.blue = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IColourSpecification: IColour {
    fn name(&self) -> &Label;
}
#[derive(Default, Debug)]
pub struct ColourSpecification {
    name: Label,
}
impl IColour for ColourSpecification {}
impl IColourSpecification for ColourSpecification {
    fn name(&self) -> &Label {
        &self.name
    }
}
impl ColourSpecification {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = ColourSpecification::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait ICommonDatum: ICompositeShapeAspect + IDatum {}
#[derive(Default, Debug)]
pub struct CommonDatum {
    name: Label,
    description: Option<Text>,
    of_shape: EntityRef,
    product_definitional: Option<bool>,
    identification: Identifier,
}
impl IShapeAspect for CommonDatum {
    fn name(&self) -> &Label {
        &self.name
    }
    fn description(&self) -> &Option<Text> {
        &self.description
    }
    fn of_shape(&self) -> &EntityRef {
        &self.of_shape
    }
    fn product_definitional(&self) -> Option<bool> {
        self.product_definitional
    }
}
impl ICompositeShapeAspect for CommonDatum {}
impl ICommonDatum for CommonDatum {}
impl IDatum for CommonDatum {
    fn identification(&self) -> &Identifier {
        &self.identification
    }
}
impl CommonDatum {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = CommonDatum::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => entity.of_shape = parameter.into(),
                3usize => entity.product_definitional = parameter.into(),
                4usize => entity.identification = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IComparisonEqual: IComparisonExpression {}
#[derive(Default, Debug)]
pub struct ComparisonEqual {
    operands: Vec<EntityRef>,
}
impl IGenericExpression for ComparisonEqual {}
impl IExpression for ComparisonEqual {}
impl IBooleanExpression for ComparisonEqual {}
impl IComparisonExpression for ComparisonEqual {
    fn operands(&self) -> &Vec<EntityRef> {
        &self.operands
    }
}
impl IBinaryGenericExpression for ComparisonEqual {
    fn operands(&self) -> &Vec<EntityRef> {
        &self.operands
    }
}
impl IComparisonEqual for ComparisonEqual {}
impl ComparisonEqual {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = ComparisonEqual::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.operands = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IComparisonExpression: IBooleanExpression + IBinaryGenericExpression {
    fn operands(&self) -> &Vec<EntityRef>;
}
pub trait IComparisonGreater: IComparisonExpression {}
#[derive(Default, Debug)]
pub struct ComparisonGreater {
    operands: Vec<EntityRef>,
}
impl IGenericExpression for ComparisonGreater {}
impl IExpression for ComparisonGreater {}
impl IBooleanExpression for ComparisonGreater {}
impl IComparisonExpression for ComparisonGreater {
    fn operands(&self) -> &Vec<EntityRef> {
        &self.operands
    }
}
impl IBinaryGenericExpression for ComparisonGreater {
    fn operands(&self) -> &Vec<EntityRef> {
        &self.operands
    }
}
impl IComparisonGreater for ComparisonGreater {}
impl ComparisonGreater {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = ComparisonGreater::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.operands = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IComparisonGreaterEqual: IComparisonExpression {}
#[derive(Default, Debug)]
pub struct ComparisonGreaterEqual {
    operands: Vec<EntityRef>,
}
impl IGenericExpression for ComparisonGreaterEqual {}
impl IExpression for ComparisonGreaterEqual {}
impl IBooleanExpression for ComparisonGreaterEqual {}
impl IComparisonExpression for ComparisonGreaterEqual {
    fn operands(&self) -> &Vec<EntityRef> {
        &self.operands
    }
}
impl IBinaryGenericExpression for ComparisonGreaterEqual {
    fn operands(&self) -> &Vec<EntityRef> {
        &self.operands
    }
}
impl IComparisonGreaterEqual for ComparisonGreaterEqual {}
impl ComparisonGreaterEqual {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = ComparisonGreaterEqual::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.operands = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IComparisonLess: IComparisonExpression {}
#[derive(Default, Debug)]
pub struct ComparisonLess {
    operands: Vec<EntityRef>,
}
impl IGenericExpression for ComparisonLess {}
impl IExpression for ComparisonLess {}
impl IBooleanExpression for ComparisonLess {}
impl IComparisonExpression for ComparisonLess {
    fn operands(&self) -> &Vec<EntityRef> {
        &self.operands
    }
}
impl IBinaryGenericExpression for ComparisonLess {
    fn operands(&self) -> &Vec<EntityRef> {
        &self.operands
    }
}
impl IComparisonLess for ComparisonLess {}
impl ComparisonLess {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = ComparisonLess::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.operands = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IComparisonLessEqual: IComparisonExpression {}
#[derive(Default, Debug)]
pub struct ComparisonLessEqual {
    operands: Vec<EntityRef>,
}
impl IGenericExpression for ComparisonLessEqual {}
impl IExpression for ComparisonLessEqual {}
impl IBooleanExpression for ComparisonLessEqual {}
impl IComparisonExpression for ComparisonLessEqual {
    fn operands(&self) -> &Vec<EntityRef> {
        &self.operands
    }
}
impl IBinaryGenericExpression for ComparisonLessEqual {
    fn operands(&self) -> &Vec<EntityRef> {
        &self.operands
    }
}
impl IComparisonLessEqual for ComparisonLessEqual {}
impl ComparisonLessEqual {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = ComparisonLessEqual::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.operands = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IComparisonNotEqual: IComparisonExpression {}
#[derive(Default, Debug)]
pub struct ComparisonNotEqual {
    operands: Vec<EntityRef>,
}
impl IGenericExpression for ComparisonNotEqual {}
impl IExpression for ComparisonNotEqual {}
impl IBooleanExpression for ComparisonNotEqual {}
impl IComparisonExpression for ComparisonNotEqual {
    fn operands(&self) -> &Vec<EntityRef> {
        &self.operands
    }
}
impl IBinaryGenericExpression for ComparisonNotEqual {
    fn operands(&self) -> &Vec<EntityRef> {
        &self.operands
    }
}
impl IComparisonNotEqual for ComparisonNotEqual {}
impl ComparisonNotEqual {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = ComparisonNotEqual::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.operands = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait ICompositeCurve: IBoundedCurve {
    fn segments(&self) -> &Vec<EntityRef>;
    fn self_intersect(&self) -> Option<bool>;
}
#[derive(Default, Debug)]
pub struct CompositeCurve {
    name: Label,
    segments: Vec<EntityRef>,
    self_intersect: Option<bool>,
}
impl IRepresentationItem for CompositeCurve {
    fn name(&self) -> &Label {
        &self.name
    }
}
impl IGeometricRepresentationItem for CompositeCurve {}
impl ICurve for CompositeCurve {}
impl IBoundedCurve for CompositeCurve {}
impl ICompositeCurve for CompositeCurve {
    fn segments(&self) -> &Vec<EntityRef> {
        &self.segments
    }
    fn self_intersect(&self) -> Option<bool> {
        self.self_intersect
    }
}
impl CompositeCurve {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = CompositeCurve::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => entity.segments = parameter.into(),
                2usize => entity.self_intersect = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait ICompositeCurveOnSurface: ICompositeCurve {}
#[derive(Default, Debug)]
pub struct CompositeCurveOnSurface {
    name: Label,
    segments: Vec<EntityRef>,
    self_intersect: Option<bool>,
}
impl IRepresentationItem for CompositeCurveOnSurface {
    fn name(&self) -> &Label {
        &self.name
    }
}
impl IGeometricRepresentationItem for CompositeCurveOnSurface {}
impl ICurve for CompositeCurveOnSurface {}
impl IBoundedCurve for CompositeCurveOnSurface {}
impl ICompositeCurve for CompositeCurveOnSurface {
    fn segments(&self) -> &Vec<EntityRef> {
        &self.segments
    }
    fn self_intersect(&self) -> Option<bool> {
        self.self_intersect
    }
}
impl ICompositeCurveOnSurface for CompositeCurveOnSurface {}
impl CompositeCurveOnSurface {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = CompositeCurveOnSurface::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => entity.segments = parameter.into(),
                2usize => entity.self_intersect = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait ICompositeCurveSegment: IFoundedItem {
    fn transition(&self) -> &TransitionCode;
    fn same_sense(&self) -> bool;
    fn parent_curve(&self) -> &EntityRef;
}
#[derive(Default, Debug)]
pub struct CompositeCurveSegment {
    transition: TransitionCode,
    same_sense: bool,
    parent_curve: EntityRef,
}
impl IFoundedItem for CompositeCurveSegment {}
impl ICompositeCurveSegment for CompositeCurveSegment {
    fn transition(&self) -> &TransitionCode {
        &self.transition
    }
    fn same_sense(&self) -> bool {
        self.same_sense
    }
    fn parent_curve(&self) -> &EntityRef {
        &self.parent_curve
    }
}
impl CompositeCurveSegment {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = CompositeCurveSegment::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.transition = parameter.into(),
                1usize => entity.same_sense = parameter.into(),
                2usize => entity.parent_curve = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait ICompositeHole: ICompoundFeature {}
#[derive(Default, Debug)]
pub struct CompositeHole {
    name: Label,
    description: Option<Text>,
}
impl ICharacterizedObject for CompositeHole {
    fn name(&self) -> &Label {
        &self.name
    }
    fn description(&self) -> &Option<Text> {
        &self.description
    }
}
impl IFeatureDefinition for CompositeHole {}
impl ICompoundFeature for CompositeHole {}
impl ICompositeHole for CompositeHole {}
impl CompositeHole {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = CompositeHole::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
}
pub trait ICompositeShapeAspect: IShapeAspect {}
#[derive(Default, Debug)]
pub struct CompositeShapeAspect {
    name: Label,
    description: Option<Text>,
    of_shape: EntityRef,
    product_definitional: Option<bool>,
}
impl IShapeAspect for CompositeShapeAspect {
    fn name(&self) -> &Label {
        &self.name
    }
    fn description(&self) -> &Option<Text> {
        &self.description
    }
    fn of_shape(&self) -> &EntityRef {
        &self.of_shape
    }
    fn product_definitional(&self) -> Option<bool> {
        self.product_definitional
    }
}
impl ICompositeShapeAspect for CompositeShapeAspect {}
impl CompositeShapeAspect {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = CompositeShapeAspect::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => entity.of_shape = parameter.into(),
                3usize => entity.product_definitional = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait ICompositeText: IGeometricRepresentationItem {
    fn collected_text(&self) -> &HashSet<EntityRef>;
}
#[derive(Default, Debug)]
pub struct CompositeText {
    name: Label,
    collected_text: HashSet<EntityRef>,
}
impl IRepresentationItem for CompositeText {
    fn name(&self) -> &Label {
        &self.name
    }
}
impl IGeometricRepresentationItem for CompositeText {}
impl ICompositeText for CompositeText {
    fn collected_text(&self) -> &HashSet<EntityRef> {
        &self.collected_text
    }
}
impl CompositeText {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = CompositeText::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => entity.collected_text = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait ICompositeTextWithAssociatedCurves: ICompositeText {
    fn associated_curves(&self) -> &HashSet<EntityRef>;
}
#[derive(Default, Debug)]
pub struct CompositeTextWithAssociatedCurves {
    name: Label,
    collected_text: HashSet<EntityRef>,
    associated_curves: HashSet<EntityRef>,
}
impl IRepresentationItem for CompositeTextWithAssociatedCurves {
    fn name(&self) -> &Label {
        &self.name
    }
}
impl IGeometricRepresentationItem for CompositeTextWithAssociatedCurves {}
impl ICompositeText for CompositeTextWithAssociatedCurves {
    fn collected_text(&self) -> &HashSet<EntityRef> {
        &self.collected_text
    }
}
impl ICompositeTextWithAssociatedCurves for CompositeTextWithAssociatedCurves {
    fn associated_curves(&self) -> &HashSet<EntityRef> {
        &self.associated_curves
    }
}
impl CompositeTextWithAssociatedCurves {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = CompositeTextWithAssociatedCurves::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => entity.collected_text = parameter.into(),
                2usize => entity.associated_curves = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait ICompositeTextWithBlankingBox: ICompositeText {
    fn blanking(&self) -> &EntityRef;
}
#[derive(Default, Debug)]
pub struct CompositeTextWithBlankingBox {
    name: Label,
    collected_text: HashSet<EntityRef>,
    blanking: EntityRef,
}
impl IRepresentationItem for CompositeTextWithBlankingBox {
    fn name(&self) -> &Label {
        &self.name
    }
}
impl IGeometricRepresentationItem for CompositeTextWithBlankingBox {}
impl ICompositeText for CompositeTextWithBlankingBox {
    fn collected_text(&self) -> &HashSet<EntityRef> {
        &self.collected_text
    }
}
impl ICompositeTextWithBlankingBox for CompositeTextWithBlankingBox {
    fn blanking(&self) -> &EntityRef {
        &self.blanking
    }
}
impl CompositeTextWithBlankingBox {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = CompositeTextWithBlankingBox::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => entity.collected_text = parameter.into(),
                2usize => entity.blanking = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait ICompositeTextWithExtent: ICompositeText {
    fn extent(&self) -> &EntityRef;
}
#[derive(Default, Debug)]
pub struct CompositeTextWithExtent {
    name: Label,
    collected_text: HashSet<EntityRef>,
    extent: EntityRef,
}
impl IRepresentationItem for CompositeTextWithExtent {
    fn name(&self) -> &Label {
        &self.name
    }
}
impl IGeometricRepresentationItem for CompositeTextWithExtent {}
impl ICompositeText for CompositeTextWithExtent {
    fn collected_text(&self) -> &HashSet<EntityRef> {
        &self.collected_text
    }
}
impl ICompositeTextWithExtent for CompositeTextWithExtent {
    fn extent(&self) -> &EntityRef {
        &self.extent
    }
}
impl CompositeTextWithExtent {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = CompositeTextWithExtent::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => entity.collected_text = parameter.into(),
                2usize => entity.extent = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait ICompoundFeature: IFeatureDefinition {}
#[derive(Default, Debug)]
pub struct CompoundFeature {
    name: Label,
    description: Option<Text>,
}
impl ICharacterizedObject for CompoundFeature {
    fn name(&self) -> &Label {
        &self.name
    }
    fn description(&self) -> &Option<Text> {
        &self.description
    }
}
impl IFeatureDefinition for CompoundFeature {}
impl ICompoundFeature for CompoundFeature {}
impl CompoundFeature {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = CompoundFeature::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
}
pub trait ICompoundRepresentationItem: IRepresentationItem {
    fn item_element(&self) -> &CompoundItemDefinition;
}
#[derive(Default, Debug)]
pub struct CompoundRepresentationItem {
    name: Label,
    item_element: CompoundItemDefinition,
}
impl IRepresentationItem for CompoundRepresentationItem {
    fn name(&self) -> &Label {
        &self.name
    }
}
impl ICompoundRepresentationItem for CompoundRepresentationItem {
    fn item_element(&self) -> &CompoundItemDefinition {
        &self.item_element
    }
}
impl CompoundRepresentationItem {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = CompoundRepresentationItem::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => entity.item_element = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait ICompoundShapeRepresentation: IShapeRepresentation {}
#[derive(Default, Debug)]
pub struct CompoundShapeRepresentation {
    name: Label,
    items: HashSet<EntityRef>,
    context_of_items: EntityRef,
}
impl IRepresentation for CompoundShapeRepresentation {
    fn name(&self) -> &Label {
        &self.name
    }
    fn items(&self) -> &HashSet<EntityRef> {
        &self.items
    }
    fn context_of_items(&self) -> &EntityRef {
        &self.context_of_items
    }
}
impl IShapeRepresentation for CompoundShapeRepresentation {}
impl ICompoundShapeRepresentation for CompoundShapeRepresentation {}
impl CompoundShapeRepresentation {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = CompoundShapeRepresentation::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => entity.items = parameter.into(),
                2usize => entity.context_of_items = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IConcatExpression: IStringExpression + IMultipleArityGenericExpression {
    fn operands(&self) -> &Vec<EntityRef>;
}
#[derive(Default, Debug)]
pub struct ConcatExpression {
    operands: Vec<EntityRef>,
}
impl IGenericExpression for ConcatExpression {}
impl IExpression for ConcatExpression {}
impl IStringExpression for ConcatExpression {}
impl IConcatExpression for ConcatExpression {
    fn operands(&self) -> &Vec<EntityRef> {
        &self.operands
    }
}
impl IMultipleArityGenericExpression for ConcatExpression {
    fn operands(&self) -> &Vec<EntityRef> {
        &self.operands
    }
}
impl ConcatExpression {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = ConcatExpression::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.operands = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IConcentricityTolerance: IGeometricToleranceWithDatumReference {}
#[derive(Default, Debug)]
pub struct ConcentricityTolerance {
    name: Label,
    description: Text,
    magnitude: EntityRef,
    toleranced_shape_aspect: EntityRef,
    datum_system: HashSet<EntityRef>,
}
impl IGeometricTolerance for ConcentricityTolerance {
    fn name(&self) -> &Label {
        &self.name
    }
    fn description(&self) -> &Text {
        &self.description
    }
    fn magnitude(&self) -> &EntityRef {
        &self.magnitude
    }
    fn toleranced_shape_aspect(&self) -> &EntityRef {
        &self.toleranced_shape_aspect
    }
}
impl IGeometricToleranceWithDatumReference for ConcentricityTolerance {
    fn datum_system(&self) -> &HashSet<EntityRef> {
        &self.datum_system
    }
}
impl IConcentricityTolerance for ConcentricityTolerance {}
impl ConcentricityTolerance {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = ConcentricityTolerance::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => entity.description = parameter.into(),
                2usize => entity.magnitude = parameter.into(),
                3usize => entity.toleranced_shape_aspect = parameter.into(),
                4usize => entity.datum_system = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IConceptFeatureOperator {
    fn name(&self) -> &Label;
    fn description(&self) -> &Option<Text>;
}
#[derive(Default, Debug)]
pub struct ConceptFeatureOperator {
    name: Label,
    description: Option<Text>,
}
impl IConceptFeatureOperator for ConceptFeatureOperator {
    fn name(&self) -> &Label {
        &self.name
    }
    fn description(&self) -> &Option<Text> {
        &self.description
    }
}
impl ConceptFeatureOperator {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = ConceptFeatureOperator::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
}
pub trait IConceptFeatureRelationship {
    fn name(&self) -> &Label;
    fn description(&self) -> &Option<Text>;
    fn relating_product_concept_feature(&self) -> &EntityRef;
    fn related_product_concept_feature(&self) -> &EntityRef;
}
#[derive(Default, Debug)]
pub struct ConceptFeatureRelationship {
    name: Label,
    description: Option<Text>,
    relating_product_concept_feature: EntityRef,
    related_product_concept_feature: EntityRef,
}
impl IConceptFeatureRelationship for ConceptFeatureRelationship {
    fn name(&self) -> &Label {
        &self.name
    }
    fn description(&self) -> &Option<Text> {
        &self.description
    }
    fn relating_product_concept_feature(&self) -> &EntityRef {
        &self.relating_product_concept_feature
    }
    fn related_product_concept_feature(&self) -> &EntityRef {
        &self.related_product_concept_feature
    }
}
impl ConceptFeatureRelationship {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = ConceptFeatureRelationship::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => entity.relating_product_concept_feature = parameter.into(),
                3usize => entity.related_product_concept_feature = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IConceptFeatureRelationshipWithCondition: IConceptFeatureRelationship {
    fn conditional_operator(&self) -> &EntityRef;
}
#[derive(Default, Debug)]
pub struct ConceptFeatureRelationshipWithCondition {
    name: Label,
    description: Option<Text>,
    relating_product_concept_feature: EntityRef,
    related_product_concept_feature: EntityRef,
    conditional_operator: EntityRef,
}
impl IConceptFeatureRelationship for ConceptFeatureRelationshipWithCondition {
    fn name(&self) -> &Label {
        &self.name
    }
    fn description(&self) -> &Option<Text> {
        &self.description
    }
    fn relating_product_concept_feature(&self) -> &EntityRef {
        &self.relating_product_concept_feature
    }
    fn related_product_concept_feature(&self) -> &EntityRef {
        &self.related_product_concept_feature
    }
}
impl IConceptFeatureRelationshipWithCondition for ConceptFeatureRelationshipWithCondition {
    fn conditional_operator(&self) -> &EntityRef {
        &self.conditional_operator
    }
}
impl ConceptFeatureRelationshipWithCondition {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = ConceptFeatureRelationshipWithCondition::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => entity.relating_product_concept_feature = parameter.into(),
                3usize => entity.related_product_concept_feature = parameter.into(),
                4usize => entity.conditional_operator = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IConditionalConceptFeature: IProductConceptFeature {
    fn condition(&self) -> &EntityRef;
}
#[derive(Default, Debug)]
pub struct ConditionalConceptFeature {
    id: Identifier,
    name: Label,
    description: Option<Text>,
    condition: EntityRef,
}
impl IProductConceptFeature for ConditionalConceptFeature {
    fn id(&self) -> &Identifier {
        &self.id
    }
    fn name(&self) -> &Label {
        &self.name
    }
    fn description(&self) -> &Option<Text> {
        &self.description
    }
}
impl IConditionalConceptFeature for ConditionalConceptFeature {
    fn condition(&self) -> &EntityRef {
        &self.condition
    }
}
impl ConditionalConceptFeature {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = ConditionalConceptFeature::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.id = parameter.into(),
                1usize => entity.name = parameter.into(),
                2usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => entity.condition = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IConfigurableItem: IConfigurationItem {
    fn item_concept_feature(&self) -> &HashSet<EntityRef>;
}
#[derive(Default, Debug)]
pub struct ConfigurableItem {
    id: Identifier,
    name: Label,
    description: Option<Text>,
    item_concept: EntityRef,
    purpose: Option<Label>,
    item_concept_feature: HashSet<EntityRef>,
}
impl IConfigurationItem for ConfigurableItem {
    fn id(&self) -> &Identifier {
        &self.id
    }
    fn name(&self) -> &Label {
        &self.name
    }
    fn description(&self) -> &Option<Text> {
        &self.description
    }
    fn item_concept(&self) -> &EntityRef {
        &self.item_concept
    }
    fn purpose(&self) -> &Option<Label> {
        &self.purpose
    }
}
impl IConfigurableItem for ConfigurableItem {
    fn item_concept_feature(&self) -> &HashSet<EntityRef> {
        &self.item_concept_feature
    }
}
impl ConfigurableItem {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = ConfigurableItem::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.id = parameter.into(),
                1usize => entity.name = parameter.into(),
                2usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => entity.item_concept = parameter.into(),
                4usize => {
                    entity.purpose = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                5usize => entity.item_concept_feature = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IConfigurationDefinition {
    fn pair_values(&self) -> &HashSet<EntityRef>;
    fn t_parameter(&self) -> &MotionParameterMeasure;
}
#[derive(Default, Debug)]
pub struct ConfigurationDefinition {
    pair_values: HashSet<EntityRef>,
    t_parameter: MotionParameterMeasure,
}
impl IConfigurationDefinition for ConfigurationDefinition {
    fn pair_values(&self) -> &HashSet<EntityRef> {
        &self.pair_values
    }
    fn t_parameter(&self) -> &MotionParameterMeasure {
        &self.t_parameter
    }
}
impl ConfigurationDefinition {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = ConfigurationDefinition::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.pair_values = parameter.into(),
                1usize => entity.t_parameter = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IConfigurationDesign {
    fn configuration(&self) -> &EntityRef;
    fn design(&self) -> &EntityRef;
}
#[derive(Default, Debug)]
pub struct ConfigurationDesign {
    configuration: EntityRef,
    design: EntityRef,
}
impl IConfigurationDesign for ConfigurationDesign {
    fn configuration(&self) -> &EntityRef {
        &self.configuration
    }
    fn design(&self) -> &EntityRef {
        &self.design
    }
}
impl ConfigurationDesign {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = ConfigurationDesign::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.configuration = parameter.into(),
                1usize => entity.design = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IConfigurationEffectivity: IProductDefinitionEffectivity {
    fn configuration(&self) -> &EntityRef;
}
#[derive(Default, Debug)]
pub struct ConfigurationEffectivity {
    id: Identifier,
    usage: EntityRef,
    configuration: EntityRef,
}
impl IEffectivity for ConfigurationEffectivity {
    fn id(&self) -> &Identifier {
        &self.id
    }
}
impl IProductDefinitionEffectivity for ConfigurationEffectivity {
    fn usage(&self) -> &EntityRef {
        &self.usage
    }
}
impl IConfigurationEffectivity for ConfigurationEffectivity {
    fn configuration(&self) -> &EntityRef {
        &self.configuration
    }
}
impl ConfigurationEffectivity {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = ConfigurationEffectivity::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.id = parameter.into(),
                1usize => entity.usage = parameter.into(),
                2usize => entity.configuration = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IConfigurationInterpolation {
    fn previous_configuration_definition(&self) -> &EntityRef;
    fn next_configuration_definition(&self) -> &EntityRef;
    fn interpolation(&self) -> &InterpolationType;
}
#[derive(Default, Debug)]
pub struct ConfigurationInterpolation {
    previous_configuration_definition: EntityRef,
    next_configuration_definition: EntityRef,
    interpolation: InterpolationType,
}
impl IConfigurationInterpolation for ConfigurationInterpolation {
    fn previous_configuration_definition(&self) -> &EntityRef {
        &self.previous_configuration_definition
    }
    fn next_configuration_definition(&self) -> &EntityRef {
        &self.next_configuration_definition
    }
    fn interpolation(&self) -> &InterpolationType {
        &self.interpolation
    }
}
impl ConfigurationInterpolation {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = ConfigurationInterpolation::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.previous_configuration_definition = parameter.into(),
                1usize => entity.next_configuration_definition = parameter.into(),
                2usize => entity.interpolation = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IConfigurationItem {
    fn id(&self) -> &Identifier;
    fn name(&self) -> &Label;
    fn description(&self) -> &Option<Text>;
    fn item_concept(&self) -> &EntityRef;
    fn purpose(&self) -> &Option<Label>;
}
#[derive(Default, Debug)]
pub struct ConfigurationItem {
    id: Identifier,
    name: Label,
    description: Option<Text>,
    item_concept: EntityRef,
    purpose: Option<Label>,
}
impl IConfigurationItem for ConfigurationItem {
    fn id(&self) -> &Identifier {
        &self.id
    }
    fn name(&self) -> &Label {
        &self.name
    }
    fn description(&self) -> &Option<Text> {
        &self.description
    }
    fn item_concept(&self) -> &EntityRef {
        &self.item_concept
    }
    fn purpose(&self) -> &Option<Label> {
        &self.purpose
    }
}
impl ConfigurationItem {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = ConfigurationItem::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.id = parameter.into(),
                1usize => entity.name = parameter.into(),
                2usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => entity.item_concept = parameter.into(),
                4usize => {
                    entity.purpose = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
}
pub trait IConfiguredEffectivityAssignment: IEffectivityAssignment {
    fn items(&self) -> &HashSet<EntityRef>;
}
#[derive(Default, Debug)]
pub struct ConfiguredEffectivityAssignment {
    assigned_effectivity: EntityRef,
    items: HashSet<EntityRef>,
}
impl IEffectivityAssignment for ConfiguredEffectivityAssignment {
    fn assigned_effectivity(&self) -> &EntityRef {
        &self.assigned_effectivity
    }
}
impl IConfiguredEffectivityAssignment for ConfiguredEffectivityAssignment {
    fn items(&self) -> &HashSet<EntityRef> {
        &self.items
    }
}
impl ConfiguredEffectivityAssignment {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = ConfiguredEffectivityAssignment::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.assigned_effectivity = parameter.into(),
                1usize => entity.items = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IConfiguredEffectivityContextAssignment: IEffectivityContextAssignment {
    fn items(&self) -> &HashSet<EntityRef>;
}
#[derive(Default, Debug)]
pub struct ConfiguredEffectivityContextAssignment {
    assigned_effectivity_assignment: EntityRef,
    role: EntityRef,
    items: HashSet<EntityRef>,
}
impl IEffectivityContextAssignment for ConfiguredEffectivityContextAssignment {
    fn assigned_effectivity_assignment(&self) -> &EntityRef {
        &self.assigned_effectivity_assignment
    }
    fn role(&self) -> &EntityRef {
        &self.role
    }
}
impl IConfiguredEffectivityContextAssignment for ConfiguredEffectivityContextAssignment {
    fn items(&self) -> &HashSet<EntityRef> {
        &self.items
    }
}
impl ConfiguredEffectivityContextAssignment {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = ConfiguredEffectivityContextAssignment::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.assigned_effectivity_assignment = parameter.into(),
                1usize => entity.role = parameter.into(),
                2usize => entity.items = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IConic: ICurve {
    fn position(&self) -> &EntityRef;
}
#[derive(Default, Debug)]
pub struct Conic {
    name: Label,
    position: EntityRef,
}
impl IRepresentationItem for Conic {
    fn name(&self) -> &Label {
        &self.name
    }
}
impl IGeometricRepresentationItem for Conic {}
impl ICurve for Conic {}
impl IConic for Conic {
    fn position(&self) -> &EntityRef {
        &self.position
    }
}
impl Conic {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = Conic::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => entity.position = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IConicalSurface: IElementarySurface {
    fn radius(&self) -> &LengthMeasure;
    fn semi_angle(&self) -> &PlaneAngleMeasure;
}
#[derive(Default, Debug)]
pub struct ConicalSurface {
    name: Label,
    position: EntityRef,
    radius: LengthMeasure,
    semi_angle: PlaneAngleMeasure,
}
impl IRepresentationItem for ConicalSurface {
    fn name(&self) -> &Label {
        &self.name
    }
}
impl IGeometricRepresentationItem for ConicalSurface {}
impl ISurface for ConicalSurface {}
impl IElementarySurface for ConicalSurface {
    fn position(&self) -> &EntityRef {
        &self.position
    }
}
impl IConicalSurface for ConicalSurface {
    fn radius(&self) -> &LengthMeasure {
        &self.radius
    }
    fn semi_angle(&self) -> &PlaneAngleMeasure {
        &self.semi_angle
    }
}
impl ConicalSurface {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = ConicalSurface::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => entity.position = parameter.into(),
                2usize => entity.radius = parameter.into(),
                3usize => entity.semi_angle = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IConnectedEdgeSet: ITopologicalRepresentationItem {
    fn ces_edges(&self) -> &HashSet<EntityRef>;
}
#[derive(Default, Debug)]
pub struct ConnectedEdgeSet {
    name: Label,
    ces_edges: HashSet<EntityRef>,
}
impl IRepresentationItem for ConnectedEdgeSet {
    fn name(&self) -> &Label {
        &self.name
    }
}
impl ITopologicalRepresentationItem for ConnectedEdgeSet {}
impl IConnectedEdgeSet for ConnectedEdgeSet {
    fn ces_edges(&self) -> &HashSet<EntityRef> {
        &self.ces_edges
    }
}
impl ConnectedEdgeSet {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = ConnectedEdgeSet::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => entity.ces_edges = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IConnectedFaceSet: ITopologicalRepresentationItem {
    fn cfs_faces(&self) -> &HashSet<EntityRef>;
}
#[derive(Default, Debug)]
pub struct ConnectedFaceSet {
    name: Label,
    cfs_faces: HashSet<EntityRef>,
}
impl IRepresentationItem for ConnectedFaceSet {
    fn name(&self) -> &Label {
        &self.name
    }
}
impl ITopologicalRepresentationItem for ConnectedFaceSet {}
impl IConnectedFaceSet for ConnectedFaceSet {
    fn cfs_faces(&self) -> &HashSet<EntityRef> {
        &self.cfs_faces
    }
}
impl ConnectedFaceSet {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = ConnectedFaceSet::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => entity.cfs_faces = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IConnectedFaceSubSet: IConnectedFaceSet {
    fn parent_face_set(&self) -> &EntityRef;
}
#[derive(Default, Debug)]
pub struct ConnectedFaceSubSet {
    name: Label,
    cfs_faces: HashSet<EntityRef>,
    parent_face_set: EntityRef,
}
impl IRepresentationItem for ConnectedFaceSubSet {
    fn name(&self) -> &Label {
        &self.name
    }
}
impl ITopologicalRepresentationItem for ConnectedFaceSubSet {}
impl IConnectedFaceSet for ConnectedFaceSubSet {
    fn cfs_faces(&self) -> &HashSet<EntityRef> {
        &self.cfs_faces
    }
}
impl IConnectedFaceSubSet for ConnectedFaceSubSet {
    fn parent_face_set(&self) -> &EntityRef {
        &self.parent_face_set
    }
}
impl ConnectedFaceSubSet {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = ConnectedFaceSubSet::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => entity.cfs_faces = parameter.into(),
                2usize => entity.parent_face_set = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IConstructiveGeometryRepresentation: IRepresentation {}
#[derive(Default, Debug)]
pub struct ConstructiveGeometryRepresentation {
    name: Label,
    items: HashSet<EntityRef>,
    context_of_items: EntityRef,
}
impl IRepresentation for ConstructiveGeometryRepresentation {
    fn name(&self) -> &Label {
        &self.name
    }
    fn items(&self) -> &HashSet<EntityRef> {
        &self.items
    }
    fn context_of_items(&self) -> &EntityRef {
        &self.context_of_items
    }
}
impl IConstructiveGeometryRepresentation for ConstructiveGeometryRepresentation {}
impl ConstructiveGeometryRepresentation {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = ConstructiveGeometryRepresentation::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => entity.items = parameter.into(),
                2usize => entity.context_of_items = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IConstructiveGeometryRepresentationRelationship: IRepresentationRelationship {}
#[derive(Default, Debug)]
pub struct ConstructiveGeometryRepresentationRelationship {
    name: Label,
    description: Option<Text>,
    rep_1: EntityRef,
    rep_2: EntityRef,
}
impl IRepresentationRelationship for ConstructiveGeometryRepresentationRelationship {
    fn name(&self) -> &Label {
        &self.name
    }
    fn description(&self) -> &Option<Text> {
        &self.description
    }
    fn rep_1(&self) -> &EntityRef {
        &self.rep_1
    }
    fn rep_2(&self) -> &EntityRef {
        &self.rep_2
    }
}
impl IConstructiveGeometryRepresentationRelationship for ConstructiveGeometryRepresentationRelationship {}
impl ConstructiveGeometryRepresentationRelationship {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = ConstructiveGeometryRepresentationRelationship::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => entity.rep_1 = parameter.into(),
                3usize => entity.rep_2 = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IContactRatioRepresentation: IRepresentation {}
#[derive(Default, Debug)]
pub struct ContactRatioRepresentation {
    name: Label,
    items: HashSet<EntityRef>,
    context_of_items: EntityRef,
}
impl IRepresentation for ContactRatioRepresentation {
    fn name(&self) -> &Label {
        &self.name
    }
    fn items(&self) -> &HashSet<EntityRef> {
        &self.items
    }
    fn context_of_items(&self) -> &EntityRef {
        &self.context_of_items
    }
}
impl IContactRatioRepresentation for ContactRatioRepresentation {}
impl ContactRatioRepresentation {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = ContactRatioRepresentation::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => entity.items = parameter.into(),
                2usize => entity.context_of_items = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IContextDependentInvisibility: IInvisibility {
    fn presentation_context(&self) -> &EntityRef;
}
#[derive(Default, Debug)]
pub struct ContextDependentInvisibility {
    invisible_items: HashSet<EntityRef>,
    presentation_context: EntityRef,
}
impl IInvisibility for ContextDependentInvisibility {
    fn invisible_items(&self) -> &HashSet<EntityRef> {
        &self.invisible_items
    }
}
impl IContextDependentInvisibility for ContextDependentInvisibility {
    fn presentation_context(&self) -> &EntityRef {
        &self.presentation_context
    }
}
impl ContextDependentInvisibility {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = ContextDependentInvisibility::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.invisible_items = parameter.into(),
                1usize => entity.presentation_context = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IContextDependentOverRidingStyledItem: IOverRidingStyledItem {
    fn style_context(&self) -> &Vec<EntityRef>;
}
#[derive(Default, Debug)]
pub struct ContextDependentOverRidingStyledItem {
    name: Label,
    styles: HashSet<EntityRef>,
    item: EntityRef,
    over_ridden_style: EntityRef,
    style_context: Vec<EntityRef>,
}
impl IRepresentationItem for ContextDependentOverRidingStyledItem {
    fn name(&self) -> &Label {
        &self.name
    }
}
impl IStyledItem for ContextDependentOverRidingStyledItem {
    fn styles(&self) -> &HashSet<EntityRef> {
        &self.styles
    }
    fn item(&self) -> &EntityRef {
        &self.item
    }
}
impl IOverRidingStyledItem for ContextDependentOverRidingStyledItem {
    fn over_ridden_style(&self) -> &EntityRef {
        &self.over_ridden_style
    }
}
impl IContextDependentOverRidingStyledItem for ContextDependentOverRidingStyledItem {
    fn style_context(&self) -> &Vec<EntityRef> {
        &self.style_context
    }
}
impl ContextDependentOverRidingStyledItem {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = ContextDependentOverRidingStyledItem::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => entity.styles = parameter.into(),
                2usize => entity.item = parameter.into(),
                3usize => entity.over_ridden_style = parameter.into(),
                4usize => entity.style_context = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IContextDependentShapeRepresentation {
    fn representation_relation(&self) -> &EntityRef;
    fn represented_product_relation(&self) -> &EntityRef;
}
#[derive(Default, Debug)]
pub struct ContextDependentShapeRepresentation {
    representation_relation: EntityRef,
    represented_product_relation: EntityRef,
}
impl IContextDependentShapeRepresentation for ContextDependentShapeRepresentation {
    fn representation_relation(&self) -> &EntityRef {
        &self.representation_relation
    }
    fn represented_product_relation(&self) -> &EntityRef {
        &self.represented_product_relation
    }
}
impl ContextDependentShapeRepresentation {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = ContextDependentShapeRepresentation::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.representation_relation = parameter.into(),
                1usize => entity.represented_product_relation = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IContextDependentUnit: INamedUnit {
    fn name(&self) -> &Label;
}
#[derive(Default, Debug)]
pub struct ContextDependentUnit {
    dimensions: EntityRef,
    name: Label,
}
impl INamedUnit for ContextDependentUnit {
    fn dimensions(&self) -> &EntityRef {
        &self.dimensions
    }
}
impl IContextDependentUnit for ContextDependentUnit {
    fn name(&self) -> &Label {
        &self.name
    }
}
impl ContextDependentUnit {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = ContextDependentUnit::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.dimensions = parameter.into(),
                1usize => entity.name = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IContract {
    fn name(&self) -> &Label;
    fn purpose(&self) -> &Text;
    fn kind(&self) -> &EntityRef;
}
#[derive(Default, Debug)]
pub struct Contract {
    name: Label,
    purpose: Text,
    kind: EntityRef,
}
impl IContract for Contract {
    fn name(&self) -> &Label {
        &self.name
    }
    fn purpose(&self) -> &Text {
        &self.purpose
    }
    fn kind(&self) -> &EntityRef {
        &self.kind
    }
}
impl Contract {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = Contract::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => entity.purpose = parameter.into(),
                2usize => entity.kind = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IContractAssignment {
    fn assigned_contract(&self) -> &EntityRef;
}
pub trait IContractType {
    fn description(&self) -> &Label;
}
#[derive(Default, Debug)]
pub struct ContractType {
    description: Label,
}
impl IContractType for ContractType {
    fn description(&self) -> &Label {
        &self.description
    }
}
impl ContractType {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = ContractType::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.description = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IConversionBasedUnit: INamedUnit {
    fn name(&self) -> &Label;
    fn conversion_factor(&self) -> &EntityRef;
}
#[derive(Default, Debug)]
pub struct ConversionBasedUnit {
    dimensions: EntityRef,
    name: Label,
    conversion_factor: EntityRef,
}
impl INamedUnit for ConversionBasedUnit {
    fn dimensions(&self) -> &EntityRef {
        &self.dimensions
    }
}
impl IConversionBasedUnit for ConversionBasedUnit {
    fn name(&self) -> &Label {
        &self.name
    }
    fn conversion_factor(&self) -> &EntityRef {
        &self.conversion_factor
    }
}
impl ConversionBasedUnit {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = ConversionBasedUnit::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.dimensions = parameter.into(),
                1usize => entity.name = parameter.into(),
                2usize => entity.conversion_factor = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait ICoordinatedUniversalTimeOffset {
    fn hour_offset(&self) -> i64;
    fn minute_offset(&self) -> Option<i64>;
    fn sense(&self) -> &AheadOrBehind;
}
#[derive(Default, Debug)]
pub struct CoordinatedUniversalTimeOffset {
    hour_offset: i64,
    minute_offset: Option<i64>,
    sense: AheadOrBehind,
}
impl ICoordinatedUniversalTimeOffset for CoordinatedUniversalTimeOffset {
    fn hour_offset(&self) -> i64 {
        self.hour_offset
    }
    fn minute_offset(&self) -> Option<i64> {
        self.minute_offset
    }
    fn sense(&self) -> &AheadOrBehind {
        &self.sense
    }
}
impl CoordinatedUniversalTimeOffset {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = CoordinatedUniversalTimeOffset::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.hour_offset = parameter.into(),
                1usize => {
                    entity.minute_offset = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => entity.sense = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait ICosFunction: IUnaryFunctionCall {}
#[derive(Default, Debug)]
pub struct CosFunction {
    operand: EntityRef,
}
impl IGenericExpression for CosFunction {}
impl IExpression for CosFunction {}
impl INumericExpression for CosFunction {}
impl IUnaryNumericExpression for CosFunction {
    fn operand(&self) -> &EntityRef {
        &self.operand
    }
}
impl IUnaryGenericExpression for CosFunction {
    fn operand(&self) -> &EntityRef {
        &self.operand
    }
}
impl IUnaryFunctionCall for CosFunction {}
impl ICosFunction for CosFunction {}
impl CosFunction {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = CosFunction::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.operand = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait ICsgShapeRepresentation: IShapeRepresentation {}
#[derive(Default, Debug)]
pub struct CsgShapeRepresentation {
    name: Label,
    items: HashSet<EntityRef>,
    context_of_items: EntityRef,
}
impl IRepresentation for CsgShapeRepresentation {
    fn name(&self) -> &Label {
        &self.name
    }
    fn items(&self) -> &HashSet<EntityRef> {
        &self.items
    }
    fn context_of_items(&self) -> &EntityRef {
        &self.context_of_items
    }
}
impl IShapeRepresentation for CsgShapeRepresentation {}
impl ICsgShapeRepresentation for CsgShapeRepresentation {}
impl CsgShapeRepresentation {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = CsgShapeRepresentation::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => entity.items = parameter.into(),
                2usize => entity.context_of_items = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait ICsgSolid: ISolidModel {
    fn tree_root_expression(&self) -> &EntityRef;
}
#[derive(Default, Debug)]
pub struct CsgSolid {
    name: Label,
    tree_root_expression: EntityRef,
}
impl IRepresentationItem for CsgSolid {
    fn name(&self) -> &Label {
        &self.name
    }
}
impl IGeometricRepresentationItem for CsgSolid {}
impl ISolidModel for CsgSolid {}
impl ICsgSolid for CsgSolid {
    fn tree_root_expression(&self) -> &EntityRef {
        &self.tree_root_expression
    }
}
impl CsgSolid {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = CsgSolid::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => entity.tree_root_expression = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait ICurve: IGeometricRepresentationItem {}
#[derive(Default, Debug)]
pub struct Curve {
    name: Label,
}
impl IRepresentationItem for Curve {
    fn name(&self) -> &Label {
        &self.name
    }
}
impl IGeometricRepresentationItem for Curve {}
impl ICurve for Curve {}
impl Curve {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = Curve::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait ICurveBoundedSurface: IBoundedSurface {
    fn basis_surface(&self) -> &EntityRef;
    fn boundaries(&self) -> &HashSet<EntityRef>;
    fn implicit_outer(&self) -> bool;
}
#[derive(Default, Debug)]
pub struct CurveBoundedSurface {
    name: Label,
    basis_surface: EntityRef,
    boundaries: HashSet<EntityRef>,
    implicit_outer: bool,
}
impl IRepresentationItem for CurveBoundedSurface {
    fn name(&self) -> &Label {
        &self.name
    }
}
impl IGeometricRepresentationItem for CurveBoundedSurface {}
impl ISurface for CurveBoundedSurface {}
impl IBoundedSurface for CurveBoundedSurface {}
impl ICurveBoundedSurface for CurveBoundedSurface {
    fn basis_surface(&self) -> &EntityRef {
        &self.basis_surface
    }
    fn boundaries(&self) -> &HashSet<EntityRef> {
        &self.boundaries
    }
    fn implicit_outer(&self) -> bool {
        self.implicit_outer
    }
}
impl CurveBoundedSurface {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = CurveBoundedSurface::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => entity.basis_surface = parameter.into(),
                2usize => entity.boundaries = parameter.into(),
                3usize => entity.implicit_outer = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait ICurveDimension: IDimensionCurveDirectedCallout {}
#[derive(Default, Debug)]
pub struct CurveDimension {
    name: Label,
    contents: HashSet<EntityRef>,
}
impl IRepresentationItem for CurveDimension {
    fn name(&self) -> &Label {
        &self.name
    }
}
impl IGeometricRepresentationItem for CurveDimension {}
impl IDraughtingCallout for CurveDimension {
    fn contents(&self) -> &HashSet<EntityRef> {
        &self.contents
    }
}
impl IDimensionCurveDirectedCallout for CurveDimension {}
impl ICurveDimension for CurveDimension {}
impl CurveDimension {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = CurveDimension::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => entity.contents = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait ICurveReplica: ICurve {
    fn parent_curve(&self) -> &EntityRef;
    fn transformation(&self) -> &EntityRef;
}
#[derive(Default, Debug)]
pub struct CurveReplica {
    name: Label,
    parent_curve: EntityRef,
    transformation: EntityRef,
}
impl IRepresentationItem for CurveReplica {
    fn name(&self) -> &Label {
        &self.name
    }
}
impl IGeometricRepresentationItem for CurveReplica {}
impl ICurve for CurveReplica {}
impl ICurveReplica for CurveReplica {
    fn parent_curve(&self) -> &EntityRef {
        &self.parent_curve
    }
    fn transformation(&self) -> &EntityRef {
        &self.transformation
    }
}
impl CurveReplica {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = CurveReplica::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => entity.parent_curve = parameter.into(),
                2usize => entity.transformation = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait ICurveStyle: IFoundedItem {
    fn name(&self) -> &Label;
    fn curve_font(&self) -> &EntityRef;
    fn curve_width(&self) -> &SizeSelect;
    fn curve_colour(&self) -> &EntityRef;
}
#[derive(Default, Debug)]
pub struct CurveStyle {
    name: Label,
    curve_font: EntityRef,
    curve_width: SizeSelect,
    curve_colour: EntityRef,
}
impl IFoundedItem for CurveStyle {}
impl ICurveStyle for CurveStyle {
    fn name(&self) -> &Label {
        &self.name
    }
    fn curve_font(&self) -> &EntityRef {
        &self.curve_font
    }
    fn curve_width(&self) -> &SizeSelect {
        &self.curve_width
    }
    fn curve_colour(&self) -> &EntityRef {
        &self.curve_colour
    }
}
impl CurveStyle {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = CurveStyle::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => entity.curve_font = parameter.into(),
                2usize => entity.curve_width = parameter.into(),
                3usize => entity.curve_colour = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait ICurveStyleFont: IFoundedItem {
    fn name(&self) -> &Label;
    fn pattern_list(&self) -> &Vec<EntityRef>;
}
#[derive(Default, Debug)]
pub struct CurveStyleFont {
    name: Label,
    pattern_list: Vec<EntityRef>,
}
impl IFoundedItem for CurveStyleFont {}
impl ICurveStyleFont for CurveStyleFont {
    fn name(&self) -> &Label {
        &self.name
    }
    fn pattern_list(&self) -> &Vec<EntityRef> {
        &self.pattern_list
    }
}
impl CurveStyleFont {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = CurveStyleFont::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => entity.pattern_list = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait ICurveStyleFontPattern: IFoundedItem {
    fn visible_segment_length(&self) -> &PositiveLengthMeasure;
    fn invisible_segment_length(&self) -> &PositiveLengthMeasure;
}
#[derive(Default, Debug)]
pub struct CurveStyleFontPattern {
    visible_segment_length: PositiveLengthMeasure,
    invisible_segment_length: PositiveLengthMeasure,
}
impl IFoundedItem for CurveStyleFontPattern {}
impl ICurveStyleFontPattern for CurveStyleFontPattern {
    fn visible_segment_length(&self) -> &PositiveLengthMeasure {
        &self.visible_segment_length
    }
    fn invisible_segment_length(&self) -> &PositiveLengthMeasure {
        &self.invisible_segment_length
    }
}
impl CurveStyleFontPattern {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = CurveStyleFontPattern::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.visible_segment_length = parameter.into(),
                1usize => entity.invisible_segment_length = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait ICurveStyleRendering {
    fn rendering_method(&self) -> &ShadingCurveMethod;
    fn rendering_properties(&self) -> &EntityRef;
}
#[derive(Default, Debug)]
pub struct CurveStyleRendering {
    rendering_method: ShadingCurveMethod,
    rendering_properties: EntityRef,
}
impl ICurveStyleRendering for CurveStyleRendering {
    fn rendering_method(&self) -> &ShadingCurveMethod {
        &self.rendering_method
    }
    fn rendering_properties(&self) -> &EntityRef {
        &self.rendering_properties
    }
}
impl CurveStyleRendering {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = CurveStyleRendering::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.rendering_method = parameter.into(),
                1usize => entity.rendering_properties = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait ICurveSweptSolidShapeRepresentation: IShapeRepresentation {}
#[derive(Default, Debug)]
pub struct CurveSweptSolidShapeRepresentation {
    name: Label,
    items: HashSet<EntityRef>,
    context_of_items: EntityRef,
}
impl IRepresentation for CurveSweptSolidShapeRepresentation {
    fn name(&self) -> &Label {
        &self.name
    }
    fn items(&self) -> &HashSet<EntityRef> {
        &self.items
    }
    fn context_of_items(&self) -> &EntityRef {
        &self.context_of_items
    }
}
impl IShapeRepresentation for CurveSweptSolidShapeRepresentation {}
impl ICurveSweptSolidShapeRepresentation for CurveSweptSolidShapeRepresentation {}
impl CurveSweptSolidShapeRepresentation {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = CurveSweptSolidShapeRepresentation::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => entity.items = parameter.into(),
                2usize => entity.context_of_items = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait ICylindricalPair: IKinematicPair {}
#[derive(Default, Debug)]
pub struct CylindricalPair {
    name: Label,
    description: Option<Text>,
    transform_item_1: EntityRef,
    transform_item_2: EntityRef,
    joint: EntityRef,
}
impl IItemDefinedTransformation for CylindricalPair {
    fn name(&self) -> &Label {
        &self.name
    }
    fn description(&self) -> &Option<Text> {
        &self.description
    }
    fn transform_item_1(&self) -> &EntityRef {
        &self.transform_item_1
    }
    fn transform_item_2(&self) -> &EntityRef {
        &self.transform_item_2
    }
}
impl IKinematicPair for CylindricalPair {
    fn joint(&self) -> &EntityRef {
        &self.joint
    }
}
impl ICylindricalPair for CylindricalPair {}
impl CylindricalPair {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = CylindricalPair::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => entity.transform_item_1 = parameter.into(),
                3usize => entity.transform_item_2 = parameter.into(),
                4usize => entity.joint = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait ICylindricalPairRange: ISimplePairRange {
    fn applies_to_pair(&self) -> &EntityRef;
    fn lower_limit_actual_translation(&self) -> &TranslationalRangeMeasure;
    fn upper_limit_actual_translation(&self) -> &TranslationalRangeMeasure;
    fn lower_limit_actual_rotation(&self) -> &RotationalRangeMeasure;
    fn upper_limit_actual_rotation(&self) -> &RotationalRangeMeasure;
}
#[derive(Default, Debug)]
pub struct CylindricalPairRange {
    applies_to_pair: EntityRef,
    lower_limit_actual_translation: TranslationalRangeMeasure,
    upper_limit_actual_translation: TranslationalRangeMeasure,
    lower_limit_actual_rotation: RotationalRangeMeasure,
    upper_limit_actual_rotation: RotationalRangeMeasure,
}
impl ISimplePairRange for CylindricalPairRange {
    fn applies_to_pair(&self) -> &EntityRef {
        &self.applies_to_pair
    }
}
impl ICylindricalPairRange for CylindricalPairRange {
    fn applies_to_pair(&self) -> &EntityRef {
        &self.applies_to_pair
    }
    fn lower_limit_actual_translation(&self) -> &TranslationalRangeMeasure {
        &self.lower_limit_actual_translation
    }
    fn upper_limit_actual_translation(&self) -> &TranslationalRangeMeasure {
        &self.upper_limit_actual_translation
    }
    fn lower_limit_actual_rotation(&self) -> &RotationalRangeMeasure {
        &self.lower_limit_actual_rotation
    }
    fn upper_limit_actual_rotation(&self) -> &RotationalRangeMeasure {
        &self.upper_limit_actual_rotation
    }
}
impl CylindricalPairRange {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = CylindricalPairRange::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.applies_to_pair = parameter.into(),
                1usize => entity.lower_limit_actual_translation = parameter.into(),
                2usize => entity.upper_limit_actual_translation = parameter.into(),
                3usize => entity.lower_limit_actual_rotation = parameter.into(),
                4usize => entity.upper_limit_actual_rotation = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait ICylindricalPairValue: IPairValue {
    fn applies_to_pair(&self) -> &EntityRef;
    fn actual_translation(&self) -> &LengthMeasure;
    fn actual_rotation(&self) -> &PlaneAngleMeasure;
}
#[derive(Default, Debug)]
pub struct CylindricalPairValue {
    applies_to_pair: EntityRef,
    actual_translation: LengthMeasure,
    actual_rotation: PlaneAngleMeasure,
}
impl IPairValue for CylindricalPairValue {
    fn applies_to_pair(&self) -> &EntityRef {
        &self.applies_to_pair
    }
}
impl ICylindricalPairValue for CylindricalPairValue {
    fn applies_to_pair(&self) -> &EntityRef {
        &self.applies_to_pair
    }
    fn actual_translation(&self) -> &LengthMeasure {
        &self.actual_translation
    }
    fn actual_rotation(&self) -> &PlaneAngleMeasure {
        &self.actual_rotation
    }
}
impl CylindricalPairValue {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = CylindricalPairValue::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.applies_to_pair = parameter.into(),
                1usize => entity.actual_translation = parameter.into(),
                2usize => entity.actual_rotation = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait ICylindricalSurface: IElementarySurface {
    fn radius(&self) -> &PositiveLengthMeasure;
}
#[derive(Default, Debug)]
pub struct CylindricalSurface {
    name: Label,
    position: EntityRef,
    radius: PositiveLengthMeasure,
}
impl IRepresentationItem for CylindricalSurface {
    fn name(&self) -> &Label {
        &self.name
    }
}
impl IGeometricRepresentationItem for CylindricalSurface {}
impl ISurface for CylindricalSurface {}
impl IElementarySurface for CylindricalSurface {
    fn position(&self) -> &EntityRef {
        &self.position
    }
}
impl ICylindricalSurface for CylindricalSurface {
    fn radius(&self) -> &PositiveLengthMeasure {
        &self.radius
    }
}
impl CylindricalSurface {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = CylindricalSurface::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => entity.position = parameter.into(),
                2usize => entity.radius = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait ICylindricityTolerance: IGeometricTolerance {}
#[derive(Default, Debug)]
pub struct CylindricityTolerance {
    name: Label,
    description: Text,
    magnitude: EntityRef,
    toleranced_shape_aspect: EntityRef,
}
impl IGeometricTolerance for CylindricityTolerance {
    fn name(&self) -> &Label {
        &self.name
    }
    fn description(&self) -> &Text {
        &self.description
    }
    fn magnitude(&self) -> &EntityRef {
        &self.magnitude
    }
    fn toleranced_shape_aspect(&self) -> &EntityRef {
        &self.toleranced_shape_aspect
    }
}
impl ICylindricityTolerance for CylindricityTolerance {}
impl CylindricityTolerance {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = CylindricityTolerance::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => entity.description = parameter.into(),
                2usize => entity.magnitude = parameter.into(),
                3usize => entity.toleranced_shape_aspect = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IDataEnvironment {
    fn name(&self) -> &Label;
    fn description(&self) -> &Text;
    fn elements(&self) -> &HashSet<EntityRef>;
}
#[derive(Default, Debug)]
pub struct DataEnvironment {
    name: Label,
    description: Text,
    elements: HashSet<EntityRef>,
}
impl IDataEnvironment for DataEnvironment {
    fn name(&self) -> &Label {
        &self.name
    }
    fn description(&self) -> &Text {
        &self.description
    }
    fn elements(&self) -> &HashSet<EntityRef> {
        &self.elements
    }
}
impl DataEnvironment {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = DataEnvironment::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => entity.description = parameter.into(),
                2usize => entity.elements = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IDate {
    fn year_component(&self) -> &YearNumber;
}
#[derive(Default, Debug)]
pub struct Date {
    year_component: YearNumber,
}
impl IDate for Date {
    fn year_component(&self) -> &YearNumber {
        &self.year_component
    }
}
impl Date {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = Date::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.year_component = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IDateAndTime {
    fn date_component(&self) -> &EntityRef;
    fn time_component(&self) -> &EntityRef;
}
#[derive(Default, Debug)]
pub struct DateAndTime {
    date_component: EntityRef,
    time_component: EntityRef,
}
impl IDateAndTime for DateAndTime {
    fn date_component(&self) -> &EntityRef {
        &self.date_component
    }
    fn time_component(&self) -> &EntityRef {
        &self.time_component
    }
}
impl DateAndTime {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = DateAndTime::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.date_component = parameter.into(),
                1usize => entity.time_component = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IDateAndTimeAssignment {
    fn assigned_date_and_time(&self) -> &EntityRef;
    fn role(&self) -> &EntityRef;
}
pub trait IDateAssignment {
    fn assigned_date(&self) -> &EntityRef;
    fn role(&self) -> &EntityRef;
}
pub trait IDateRole {
    fn name(&self) -> &Label;
}
#[derive(Default, Debug)]
pub struct DateRole {
    name: Label,
}
impl IDateRole for DateRole {
    fn name(&self) -> &Label {
        &self.name
    }
}
impl DateRole {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = DateRole::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IDateTimeRole {
    fn name(&self) -> &Label;
}
#[derive(Default, Debug)]
pub struct DateTimeRole {
    name: Label,
}
impl IDateTimeRole for DateTimeRole {
    fn name(&self) -> &Label {
        &self.name
    }
}
impl DateTimeRole {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = DateTimeRole::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IDatedEffectivity: IEffectivity {
    fn effectivity_end_date(&self) -> &Option<EntityRef>;
    fn effectivity_start_date(&self) -> &EntityRef;
}
#[derive(Default, Debug)]
pub struct DatedEffectivity {
    id: Identifier,
    effectivity_end_date: Option<EntityRef>,
    effectivity_start_date: EntityRef,
}
impl IEffectivity for DatedEffectivity {
    fn id(&self) -> &Identifier {
        &self.id
    }
}
impl IDatedEffectivity for DatedEffectivity {
    fn effectivity_end_date(&self) -> &Option<EntityRef> {
        &self.effectivity_end_date
    }
    fn effectivity_start_date(&self) -> &EntityRef {
        &self.effectivity_start_date
    }
}
impl DatedEffectivity {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = DatedEffectivity::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.id = parameter.into(),
                1usize => {
                    entity.effectivity_end_date = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => entity.effectivity_start_date = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IDatum: IShapeAspect {
    fn identification(&self) -> &Identifier;
}
#[derive(Default, Debug)]
pub struct Datum {
    name: Label,
    description: Option<Text>,
    of_shape: EntityRef,
    product_definitional: Option<bool>,
    identification: Identifier,
}
impl IShapeAspect for Datum {
    fn name(&self) -> &Label {
        &self.name
    }
    fn description(&self) -> &Option<Text> {
        &self.description
    }
    fn of_shape(&self) -> &EntityRef {
        &self.of_shape
    }
    fn product_definitional(&self) -> Option<bool> {
        self.product_definitional
    }
}
impl IDatum for Datum {
    fn identification(&self) -> &Identifier {
        &self.identification
    }
}
impl Datum {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = Datum::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => entity.of_shape = parameter.into(),
                3usize => entity.product_definitional = parameter.into(),
                4usize => entity.identification = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IDatumFeature: IShapeAspect {}
#[derive(Default, Debug)]
pub struct DatumFeature {
    name: Label,
    description: Option<Text>,
    of_shape: EntityRef,
    product_definitional: Option<bool>,
}
impl IShapeAspect for DatumFeature {
    fn name(&self) -> &Label {
        &self.name
    }
    fn description(&self) -> &Option<Text> {
        &self.description
    }
    fn of_shape(&self) -> &EntityRef {
        &self.of_shape
    }
    fn product_definitional(&self) -> Option<bool> {
        self.product_definitional
    }
}
impl IDatumFeature for DatumFeature {}
impl DatumFeature {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = DatumFeature::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => entity.of_shape = parameter.into(),
                3usize => entity.product_definitional = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IDatumFeatureCallout: IDraughtingCallout {}
#[derive(Default, Debug)]
pub struct DatumFeatureCallout {
    name: Label,
    contents: HashSet<EntityRef>,
}
impl IRepresentationItem for DatumFeatureCallout {
    fn name(&self) -> &Label {
        &self.name
    }
}
impl IGeometricRepresentationItem for DatumFeatureCallout {}
impl IDraughtingCallout for DatumFeatureCallout {
    fn contents(&self) -> &HashSet<EntityRef> {
        &self.contents
    }
}
impl IDatumFeatureCallout for DatumFeatureCallout {}
impl DatumFeatureCallout {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = DatumFeatureCallout::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => entity.contents = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IDatumReference {
    fn precedence(&self) -> i64;
    fn referenced_datum(&self) -> &EntityRef;
}
#[derive(Default, Debug)]
pub struct DatumReference {
    precedence: i64,
    referenced_datum: EntityRef,
}
impl IDatumReference for DatumReference {
    fn precedence(&self) -> i64 {
        self.precedence
    }
    fn referenced_datum(&self) -> &EntityRef {
        &self.referenced_datum
    }
}
impl DatumReference {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = DatumReference::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.precedence = parameter.into(),
                1usize => entity.referenced_datum = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IDatumTarget: IShapeAspect {
    fn target_id(&self) -> &Identifier;
}
#[derive(Default, Debug)]
pub struct DatumTarget {
    name: Label,
    description: Option<Text>,
    of_shape: EntityRef,
    product_definitional: Option<bool>,
    target_id: Identifier,
}
impl IShapeAspect for DatumTarget {
    fn name(&self) -> &Label {
        &self.name
    }
    fn description(&self) -> &Option<Text> {
        &self.description
    }
    fn of_shape(&self) -> &EntityRef {
        &self.of_shape
    }
    fn product_definitional(&self) -> Option<bool> {
        self.product_definitional
    }
}
impl IDatumTarget for DatumTarget {
    fn target_id(&self) -> &Identifier {
        &self.target_id
    }
}
impl DatumTarget {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = DatumTarget::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => entity.of_shape = parameter.into(),
                3usize => entity.product_definitional = parameter.into(),
                4usize => entity.target_id = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IDatumTargetCallout: IDraughtingCallout {}
#[derive(Default, Debug)]
pub struct DatumTargetCallout {
    name: Label,
    contents: HashSet<EntityRef>,
}
impl IRepresentationItem for DatumTargetCallout {
    fn name(&self) -> &Label {
        &self.name
    }
}
impl IGeometricRepresentationItem for DatumTargetCallout {}
impl IDraughtingCallout for DatumTargetCallout {
    fn contents(&self) -> &HashSet<EntityRef> {
        &self.contents
    }
}
impl IDatumTargetCallout for DatumTargetCallout {}
impl DatumTargetCallout {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = DatumTargetCallout::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => entity.contents = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IDefaultToleranceTable: IRepresentation {}
#[derive(Default, Debug)]
pub struct DefaultToleranceTable {
    name: Label,
    items: HashSet<EntityRef>,
    context_of_items: EntityRef,
}
impl IRepresentation for DefaultToleranceTable {
    fn name(&self) -> &Label {
        &self.name
    }
    fn items(&self) -> &HashSet<EntityRef> {
        &self.items
    }
    fn context_of_items(&self) -> &EntityRef {
        &self.context_of_items
    }
}
impl IDefaultToleranceTable for DefaultToleranceTable {}
impl DefaultToleranceTable {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = DefaultToleranceTable::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => entity.items = parameter.into(),
                2usize => entity.context_of_items = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IDefaultToleranceTableCell: ICompoundRepresentationItem {}
#[derive(Default, Debug)]
pub struct DefaultToleranceTableCell {
    name: Label,
    item_element: CompoundItemDefinition,
}
impl IRepresentationItem for DefaultToleranceTableCell {
    fn name(&self) -> &Label {
        &self.name
    }
}
impl ICompoundRepresentationItem for DefaultToleranceTableCell {
    fn item_element(&self) -> &CompoundItemDefinition {
        &self.item_element
    }
}
impl IDefaultToleranceTableCell for DefaultToleranceTableCell {}
impl DefaultToleranceTableCell {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = DefaultToleranceTableCell::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => entity.item_element = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IDefinedCharacterGlyph: IGeometricRepresentationItem {
    fn definition(&self) -> &EntityRef;
    fn placement(&self) -> &EntityRef;
}
#[derive(Default, Debug)]
pub struct DefinedCharacterGlyph {
    name: Label,
    definition: EntityRef,
    placement: EntityRef,
}
impl IRepresentationItem for DefinedCharacterGlyph {
    fn name(&self) -> &Label {
        &self.name
    }
}
impl IGeometricRepresentationItem for DefinedCharacterGlyph {}
impl IDefinedCharacterGlyph for DefinedCharacterGlyph {
    fn definition(&self) -> &EntityRef {
        &self.definition
    }
    fn placement(&self) -> &EntityRef {
        &self.placement
    }
}
impl DefinedCharacterGlyph {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = DefinedCharacterGlyph::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => entity.definition = parameter.into(),
                2usize => entity.placement = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IDefinedFunction {}
pub trait IDefinedSymbol: IGeometricRepresentationItem {
    fn definition(&self) -> &EntityRef;
    fn target(&self) -> &EntityRef;
}
#[derive(Default, Debug)]
pub struct DefinedSymbol {
    name: Label,
    definition: EntityRef,
    target: EntityRef,
}
impl IRepresentationItem for DefinedSymbol {
    fn name(&self) -> &Label {
        &self.name
    }
}
impl IGeometricRepresentationItem for DefinedSymbol {}
impl IDefinedSymbol for DefinedSymbol {
    fn definition(&self) -> &EntityRef {
        &self.definition
    }
    fn target(&self) -> &EntityRef {
        &self.target
    }
}
impl DefinedSymbol {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = DefinedSymbol::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => entity.definition = parameter.into(),
                2usize => entity.target = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IDefinitionalRepresentation: IRepresentation {}
#[derive(Default, Debug)]
pub struct DefinitionalRepresentation {
    name: Label,
    items: HashSet<EntityRef>,
    context_of_items: EntityRef,
}
impl IRepresentation for DefinitionalRepresentation {
    fn name(&self) -> &Label {
        &self.name
    }
    fn items(&self) -> &HashSet<EntityRef> {
        &self.items
    }
    fn context_of_items(&self) -> &EntityRef {
        &self.context_of_items
    }
}
impl IDefinitionalRepresentation for DefinitionalRepresentation {}
impl DefinitionalRepresentation {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = DefinitionalRepresentation::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => entity.items = parameter.into(),
                2usize => entity.context_of_items = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IDegeneratePcurve: IPoint {
    fn basis_surface(&self) -> &EntityRef;
    fn reference_to_curve(&self) -> &EntityRef;
}
#[derive(Default, Debug)]
pub struct DegeneratePcurve {
    name: Label,
    basis_surface: EntityRef,
    reference_to_curve: EntityRef,
}
impl IRepresentationItem for DegeneratePcurve {
    fn name(&self) -> &Label {
        &self.name
    }
}
impl IGeometricRepresentationItem for DegeneratePcurve {}
impl IPoint for DegeneratePcurve {}
impl IDegeneratePcurve for DegeneratePcurve {
    fn basis_surface(&self) -> &EntityRef {
        &self.basis_surface
    }
    fn reference_to_curve(&self) -> &EntityRef {
        &self.reference_to_curve
    }
}
impl DegeneratePcurve {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = DegeneratePcurve::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => entity.basis_surface = parameter.into(),
                2usize => entity.reference_to_curve = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IDegenerateToroidalSurface: IToroidalSurface {
    fn select_outer(&self) -> bool;
}
#[derive(Default, Debug)]
pub struct DegenerateToroidalSurface {
    name: Label,
    position: EntityRef,
    major_radius: PositiveLengthMeasure,
    minor_radius: PositiveLengthMeasure,
    select_outer: bool,
}
impl IRepresentationItem for DegenerateToroidalSurface {
    fn name(&self) -> &Label {
        &self.name
    }
}
impl IGeometricRepresentationItem for DegenerateToroidalSurface {}
impl ISurface for DegenerateToroidalSurface {}
impl IElementarySurface for DegenerateToroidalSurface {
    fn position(&self) -> &EntityRef {
        &self.position
    }
}
impl IToroidalSurface for DegenerateToroidalSurface {
    fn major_radius(&self) -> &PositiveLengthMeasure {
        &self.major_radius
    }
    fn minor_radius(&self) -> &PositiveLengthMeasure {
        &self.minor_radius
    }
}
impl IDegenerateToroidalSurface for DegenerateToroidalSurface {
    fn select_outer(&self) -> bool {
        self.select_outer
    }
}
impl DegenerateToroidalSurface {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = DegenerateToroidalSurface::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => entity.position = parameter.into(),
                2usize => entity.major_radius = parameter.into(),
                3usize => entity.minor_radius = parameter.into(),
                4usize => entity.select_outer = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IDerivedShapeAspect: IShapeAspect {}
#[derive(Default, Debug)]
pub struct DerivedShapeAspect {
    name: Label,
    description: Option<Text>,
    of_shape: EntityRef,
    product_definitional: Option<bool>,
}
impl IShapeAspect for DerivedShapeAspect {
    fn name(&self) -> &Label {
        &self.name
    }
    fn description(&self) -> &Option<Text> {
        &self.description
    }
    fn of_shape(&self) -> &EntityRef {
        &self.of_shape
    }
    fn product_definitional(&self) -> Option<bool> {
        self.product_definitional
    }
}
impl IDerivedShapeAspect for DerivedShapeAspect {}
impl DerivedShapeAspect {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = DerivedShapeAspect::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => entity.of_shape = parameter.into(),
                3usize => entity.product_definitional = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IDerivedUnit {
    fn elements(&self) -> &HashSet<EntityRef>;
}
#[derive(Default, Debug)]
pub struct DerivedUnit {
    elements: HashSet<EntityRef>,
}
impl IDerivedUnit for DerivedUnit {
    fn elements(&self) -> &HashSet<EntityRef> {
        &self.elements
    }
}
impl DerivedUnit {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = DerivedUnit::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.elements = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IDerivedUnitElement {
    fn unit(&self) -> &EntityRef;
    fn exponent(&self) -> Real;
}
#[derive(Default, Debug)]
pub struct DerivedUnitElement {
    unit: EntityRef,
    exponent: Real,
}
impl IDerivedUnitElement for DerivedUnitElement {
    fn unit(&self) -> &EntityRef {
        &self.unit
    }
    fn exponent(&self) -> Real {
        self.exponent
    }
}
impl DerivedUnitElement {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = DerivedUnitElement::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.unit = parameter.into(),
                1usize => entity.exponent = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IDerivedUnitVariable: IDerivedUnit + IVariableSemantics {}
#[derive(Default, Debug)]
pub struct DerivedUnitVariable {
    elements: HashSet<EntityRef>,
}
impl IDerivedUnit for DerivedUnitVariable {
    fn elements(&self) -> &HashSet<EntityRef> {
        &self.elements
    }
}
impl IVariableSemantics for DerivedUnitVariable {}
impl IDerivedUnitVariable for DerivedUnitVariable {}
impl DerivedUnitVariable {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = DerivedUnitVariable::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.elements = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IDescriptionAttribute {
    fn attribute_value(&self) -> &Text;
    fn described_item(&self) -> &EntityRef;
}
#[derive(Default, Debug)]
pub struct DescriptionAttribute {
    attribute_value: Text,
    described_item: EntityRef,
}
impl IDescriptionAttribute for DescriptionAttribute {
    fn attribute_value(&self) -> &Text {
        &self.attribute_value
    }
    fn described_item(&self) -> &EntityRef {
        &self.described_item
    }
}
impl DescriptionAttribute {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = DescriptionAttribute::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.attribute_value = parameter.into(),
                1usize => entity.described_item = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IDescriptiveRepresentationItem: IRepresentationItem {
    fn description(&self) -> &Text;
}
#[derive(Default, Debug)]
pub struct DescriptiveRepresentationItem {
    name: Label,
    description: Text,
}
impl IRepresentationItem for DescriptiveRepresentationItem {
    fn name(&self) -> &Label {
        &self.name
    }
}
impl IDescriptiveRepresentationItem for DescriptiveRepresentationItem {
    fn description(&self) -> &Text {
        &self.description
    }
}
impl DescriptiveRepresentationItem {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = DescriptiveRepresentationItem::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => entity.description = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IDiameterDimension: IDimensionCurveDirectedCallout {}
#[derive(Default, Debug)]
pub struct DiameterDimension {
    name: Label,
    contents: HashSet<EntityRef>,
}
impl IRepresentationItem for DiameterDimension {
    fn name(&self) -> &Label {
        &self.name
    }
}
impl IGeometricRepresentationItem for DiameterDimension {}
impl IDraughtingCallout for DiameterDimension {
    fn contents(&self) -> &HashSet<EntityRef> {
        &self.contents
    }
}
impl IDimensionCurveDirectedCallout for DiameterDimension {}
impl IDiameterDimension for DiameterDimension {}
impl DiameterDimension {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = DiameterDimension::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => entity.contents = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IDimensionCallout: IDraughtingCallout {}
#[derive(Default, Debug)]
pub struct DimensionCallout {
    name: Label,
    contents: HashSet<EntityRef>,
}
impl IRepresentationItem for DimensionCallout {
    fn name(&self) -> &Label {
        &self.name
    }
}
impl IGeometricRepresentationItem for DimensionCallout {}
impl IDraughtingCallout for DimensionCallout {
    fn contents(&self) -> &HashSet<EntityRef> {
        &self.contents
    }
}
impl IDimensionCallout for DimensionCallout {}
impl DimensionCallout {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = DimensionCallout::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => entity.contents = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IDimensionCalloutComponentRelationship: IDraughtingCalloutRelationship {}
#[derive(Default, Debug)]
pub struct DimensionCalloutComponentRelationship {
    name: Label,
    description: Text,
    relating_draughting_callout: EntityRef,
    related_draughting_callout: EntityRef,
}
impl IDraughtingCalloutRelationship for DimensionCalloutComponentRelationship {
    fn name(&self) -> &Label {
        &self.name
    }
    fn description(&self) -> &Text {
        &self.description
    }
    fn relating_draughting_callout(&self) -> &EntityRef {
        &self.relating_draughting_callout
    }
    fn related_draughting_callout(&self) -> &EntityRef {
        &self.related_draughting_callout
    }
}
impl IDimensionCalloutComponentRelationship for DimensionCalloutComponentRelationship {}
impl DimensionCalloutComponentRelationship {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = DimensionCalloutComponentRelationship::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => entity.description = parameter.into(),
                2usize => entity.relating_draughting_callout = parameter.into(),
                3usize => entity.related_draughting_callout = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IDimensionCalloutRelationship: IDraughtingCalloutRelationship {}
#[derive(Default, Debug)]
pub struct DimensionCalloutRelationship {
    name: Label,
    description: Text,
    relating_draughting_callout: EntityRef,
    related_draughting_callout: EntityRef,
}
impl IDraughtingCalloutRelationship for DimensionCalloutRelationship {
    fn name(&self) -> &Label {
        &self.name
    }
    fn description(&self) -> &Text {
        &self.description
    }
    fn relating_draughting_callout(&self) -> &EntityRef {
        &self.relating_draughting_callout
    }
    fn related_draughting_callout(&self) -> &EntityRef {
        &self.related_draughting_callout
    }
}
impl IDimensionCalloutRelationship for DimensionCalloutRelationship {}
impl DimensionCalloutRelationship {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = DimensionCalloutRelationship::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => entity.description = parameter.into(),
                2usize => entity.relating_draughting_callout = parameter.into(),
                3usize => entity.related_draughting_callout = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IDimensionCurve: IAnnotationCurveOccurrence {}
#[derive(Default, Debug)]
pub struct DimensionCurve {
    name: Label,
    styles: HashSet<EntityRef>,
    item: EntityRef,
}
impl IRepresentationItem for DimensionCurve {
    fn name(&self) -> &Label {
        &self.name
    }
}
impl IStyledItem for DimensionCurve {
    fn styles(&self) -> &HashSet<EntityRef> {
        &self.styles
    }
    fn item(&self) -> &EntityRef {
        &self.item
    }
}
impl IAnnotationOccurrence for DimensionCurve {}
impl IAnnotationCurveOccurrence for DimensionCurve {
    fn item(&self) -> &EntityRef {
        &self.item
    }
}
impl IDimensionCurve for DimensionCurve {}
impl DimensionCurve {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = DimensionCurve::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => entity.styles = parameter.into(),
                2usize => entity.item = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IDimensionCurveDirectedCallout: IDraughtingCallout {}
#[derive(Default, Debug)]
pub struct DimensionCurveDirectedCallout {
    name: Label,
    contents: HashSet<EntityRef>,
}
impl IRepresentationItem for DimensionCurveDirectedCallout {
    fn name(&self) -> &Label {
        &self.name
    }
}
impl IGeometricRepresentationItem for DimensionCurveDirectedCallout {}
impl IDraughtingCallout for DimensionCurveDirectedCallout {
    fn contents(&self) -> &HashSet<EntityRef> {
        &self.contents
    }
}
impl IDimensionCurveDirectedCallout for DimensionCurveDirectedCallout {}
impl DimensionCurveDirectedCallout {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = DimensionCurveDirectedCallout::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => entity.contents = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IDimensionCurveTerminator: ITerminatorSymbol {
    fn role(&self) -> &DimensionExtentUsage;
}
#[derive(Default, Debug)]
pub struct DimensionCurveTerminator {
    name: Label,
    styles: HashSet<EntityRef>,
    item: EntityRef,
    annotated_curve: EntityRef,
    role: DimensionExtentUsage,
}
impl IRepresentationItem for DimensionCurveTerminator {
    fn name(&self) -> &Label {
        &self.name
    }
}
impl IStyledItem for DimensionCurveTerminator {
    fn styles(&self) -> &HashSet<EntityRef> {
        &self.styles
    }
    fn item(&self) -> &EntityRef {
        &self.item
    }
}
impl IAnnotationOccurrence for DimensionCurveTerminator {}
impl IAnnotationSymbolOccurrence for DimensionCurveTerminator {
    fn item(&self) -> &EntityRef {
        &self.item
    }
}
impl ITerminatorSymbol for DimensionCurveTerminator {
    fn annotated_curve(&self) -> &EntityRef {
        &self.annotated_curve
    }
}
impl IDimensionCurveTerminator for DimensionCurveTerminator {
    fn role(&self) -> &DimensionExtentUsage {
        &self.role
    }
}
impl DimensionCurveTerminator {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = DimensionCurveTerminator::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => entity.styles = parameter.into(),
                2usize => entity.item = parameter.into(),
                3usize => entity.annotated_curve = parameter.into(),
                4usize => entity.role = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IDimensionPair: IDraughtingCalloutRelationship {}
#[derive(Default, Debug)]
pub struct DimensionPair {
    name: Label,
    description: Text,
    relating_draughting_callout: EntityRef,
    related_draughting_callout: EntityRef,
}
impl IDraughtingCalloutRelationship for DimensionPair {
    fn name(&self) -> &Label {
        &self.name
    }
    fn description(&self) -> &Text {
        &self.description
    }
    fn relating_draughting_callout(&self) -> &EntityRef {
        &self.relating_draughting_callout
    }
    fn related_draughting_callout(&self) -> &EntityRef {
        &self.related_draughting_callout
    }
}
impl IDimensionPair for DimensionPair {}
impl DimensionPair {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = DimensionPair::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => entity.description = parameter.into(),
                2usize => entity.relating_draughting_callout = parameter.into(),
                3usize => entity.related_draughting_callout = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IDimensionRelatedToleranceZoneElement {
    fn related_dimension(&self) -> &EntityRef;
    fn related_element(&self) -> &EntityRef;
}
#[derive(Default, Debug)]
pub struct DimensionRelatedToleranceZoneElement {
    related_dimension: EntityRef,
    related_element: EntityRef,
}
impl IDimensionRelatedToleranceZoneElement for DimensionRelatedToleranceZoneElement {
    fn related_dimension(&self) -> &EntityRef {
        &self.related_dimension
    }
    fn related_element(&self) -> &EntityRef {
        &self.related_element
    }
}
impl DimensionRelatedToleranceZoneElement {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = DimensionRelatedToleranceZoneElement::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.related_dimension = parameter.into(),
                1usize => entity.related_element = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IDimensionTextAssociativity: ITextLiteral + IMappedItem {}
#[derive(Default, Debug)]
pub struct DimensionTextAssociativity {
    name: Label,
    literal: PresentableText,
    placement: EntityRef,
    alignment: TextAlignment,
    path: TextPath,
    font: EntityRef,
    mapping_source: EntityRef,
    mapping_target: EntityRef,
}
impl IRepresentationItem for DimensionTextAssociativity {
    fn name(&self) -> &Label {
        &self.name
    }
}
impl IGeometricRepresentationItem for DimensionTextAssociativity {}
impl ITextLiteral for DimensionTextAssociativity {
    fn literal(&self) -> &PresentableText {
        &self.literal
    }
    fn placement(&self) -> &EntityRef {
        &self.placement
    }
    fn alignment(&self) -> &TextAlignment {
        &self.alignment
    }
    fn path(&self) -> &TextPath {
        &self.path
    }
    fn font(&self) -> &EntityRef {
        &self.font
    }
}
impl IDimensionTextAssociativity for DimensionTextAssociativity {}
impl IMappedItem for DimensionTextAssociativity {
    fn mapping_source(&self) -> &EntityRef {
        &self.mapping_source
    }
    fn mapping_target(&self) -> &EntityRef {
        &self.mapping_target
    }
}
impl DimensionTextAssociativity {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = DimensionTextAssociativity::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => entity.literal = parameter.into(),
                2usize => entity.placement = parameter.into(),
                3usize => entity.alignment = parameter.into(),
                4usize => entity.path = parameter.into(),
                5usize => entity.font = parameter.into(),
                6usize => entity.mapping_source = parameter.into(),
                7usize => entity.mapping_target = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IDimensionalCharacteristicRepresentation {
    fn dimension(&self) -> &EntityRef;
    fn representation(&self) -> &EntityRef;
}
#[derive(Default, Debug)]
pub struct DimensionalCharacteristicRepresentation {
    dimension: EntityRef,
    representation: EntityRef,
}
impl IDimensionalCharacteristicRepresentation for DimensionalCharacteristicRepresentation {
    fn dimension(&self) -> &EntityRef {
        &self.dimension
    }
    fn representation(&self) -> &EntityRef {
        &self.representation
    }
}
impl DimensionalCharacteristicRepresentation {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = DimensionalCharacteristicRepresentation::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.dimension = parameter.into(),
                1usize => entity.representation = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IDimensionalExponents {
    fn length_exponent(&self) -> Real;
    fn mass_exponent(&self) -> Real;
    fn time_exponent(&self) -> Real;
    fn electric_current_exponent(&self) -> Real;
    fn thermodynamic_temperature_exponent(&self) -> Real;
    fn amount_of_substance_exponent(&self) -> Real;
    fn luminous_intensity_exponent(&self) -> Real;
}
#[derive(Default, Debug)]
pub struct DimensionalExponents {
    length_exponent: Real,
    mass_exponent: Real,
    time_exponent: Real,
    electric_current_exponent: Real,
    thermodynamic_temperature_exponent: Real,
    amount_of_substance_exponent: Real,
    luminous_intensity_exponent: Real,
}
impl IDimensionalExponents for DimensionalExponents {
    fn length_exponent(&self) -> Real {
        self.length_exponent
    }
    fn mass_exponent(&self) -> Real {
        self.mass_exponent
    }
    fn time_exponent(&self) -> Real {
        self.time_exponent
    }
    fn electric_current_exponent(&self) -> Real {
        self.electric_current_exponent
    }
    fn thermodynamic_temperature_exponent(&self) -> Real {
        self.thermodynamic_temperature_exponent
    }
    fn amount_of_substance_exponent(&self) -> Real {
        self.amount_of_substance_exponent
    }
    fn luminous_intensity_exponent(&self) -> Real {
        self.luminous_intensity_exponent
    }
}
impl DimensionalExponents {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = DimensionalExponents::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.length_exponent = parameter.into(),
                1usize => entity.mass_exponent = parameter.into(),
                2usize => entity.time_exponent = parameter.into(),
                3usize => entity.electric_current_exponent = parameter.into(),
                4usize => entity.thermodynamic_temperature_exponent = parameter.into(),
                5usize => entity.amount_of_substance_exponent = parameter.into(),
                6usize => entity.luminous_intensity_exponent = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IDimensionalLocation: IShapeAspectRelationship {}
#[derive(Default, Debug)]
pub struct DimensionalLocation {
    name: Label,
    description: Option<Text>,
    relating_shape_aspect: EntityRef,
    related_shape_aspect: EntityRef,
}
impl IShapeAspectRelationship for DimensionalLocation {
    fn name(&self) -> &Label {
        &self.name
    }
    fn description(&self) -> &Option<Text> {
        &self.description
    }
    fn relating_shape_aspect(&self) -> &EntityRef {
        &self.relating_shape_aspect
    }
    fn related_shape_aspect(&self) -> &EntityRef {
        &self.related_shape_aspect
    }
}
impl IDimensionalLocation for DimensionalLocation {}
impl DimensionalLocation {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = DimensionalLocation::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => entity.relating_shape_aspect = parameter.into(),
                3usize => entity.related_shape_aspect = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IDimensionalLocationWithPath: IDimensionalLocation {
    fn path(&self) -> &EntityRef;
}
#[derive(Default, Debug)]
pub struct DimensionalLocationWithPath {
    name: Label,
    description: Option<Text>,
    relating_shape_aspect: EntityRef,
    related_shape_aspect: EntityRef,
    path: EntityRef,
}
impl IShapeAspectRelationship for DimensionalLocationWithPath {
    fn name(&self) -> &Label {
        &self.name
    }
    fn description(&self) -> &Option<Text> {
        &self.description
    }
    fn relating_shape_aspect(&self) -> &EntityRef {
        &self.relating_shape_aspect
    }
    fn related_shape_aspect(&self) -> &EntityRef {
        &self.related_shape_aspect
    }
}
impl IDimensionalLocation for DimensionalLocationWithPath {}
impl IDimensionalLocationWithPath for DimensionalLocationWithPath {
    fn path(&self) -> &EntityRef {
        &self.path
    }
}
impl DimensionalLocationWithPath {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = DimensionalLocationWithPath::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => entity.relating_shape_aspect = parameter.into(),
                3usize => entity.related_shape_aspect = parameter.into(),
                4usize => entity.path = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IDimensionalSize {
    fn applies_to(&self) -> &EntityRef;
    fn name(&self) -> &Label;
}
#[derive(Default, Debug)]
pub struct DimensionalSize {
    applies_to: EntityRef,
    name: Label,
}
impl IDimensionalSize for DimensionalSize {
    fn applies_to(&self) -> &EntityRef {
        &self.applies_to
    }
    fn name(&self) -> &Label {
        &self.name
    }
}
impl DimensionalSize {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = DimensionalSize::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.applies_to = parameter.into(),
                1usize => entity.name = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IDimensionalSizeWithPath: IDimensionalSize {
    fn path(&self) -> &EntityRef;
}
#[derive(Default, Debug)]
pub struct DimensionalSizeWithPath {
    applies_to: EntityRef,
    name: Label,
    path: EntityRef,
}
impl IDimensionalSize for DimensionalSizeWithPath {
    fn applies_to(&self) -> &EntityRef {
        &self.applies_to
    }
    fn name(&self) -> &Label {
        &self.name
    }
}
impl IDimensionalSizeWithPath for DimensionalSizeWithPath {
    fn path(&self) -> &EntityRef {
        &self.path
    }
}
impl DimensionalSizeWithPath {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = DimensionalSizeWithPath::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.applies_to = parameter.into(),
                1usize => entity.name = parameter.into(),
                2usize => entity.path = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IDirectedAction: IExecutedAction {
    fn directive(&self) -> &EntityRef;
}
#[derive(Default, Debug)]
pub struct DirectedAction {
    name: Label,
    description: Option<Text>,
    chosen_method: EntityRef,
    directive: EntityRef,
}
impl IAction for DirectedAction {
    fn name(&self) -> &Label {
        &self.name
    }
    fn description(&self) -> &Option<Text> {
        &self.description
    }
    fn chosen_method(&self) -> &EntityRef {
        &self.chosen_method
    }
}
impl IExecutedAction for DirectedAction {}
impl IDirectedAction for DirectedAction {
    fn directive(&self) -> &EntityRef {
        &self.directive
    }
}
impl DirectedAction {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = DirectedAction::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => entity.chosen_method = parameter.into(),
                3usize => entity.directive = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IDirectedAngle: IShapeAspect {}
#[derive(Default, Debug)]
pub struct DirectedAngle {
    name: Label,
    description: Option<Text>,
    of_shape: EntityRef,
    product_definitional: Option<bool>,
}
impl IShapeAspect for DirectedAngle {
    fn name(&self) -> &Label {
        &self.name
    }
    fn description(&self) -> &Option<Text> {
        &self.description
    }
    fn of_shape(&self) -> &EntityRef {
        &self.of_shape
    }
    fn product_definitional(&self) -> Option<bool> {
        self.product_definitional
    }
}
impl IDirectedAngle for DirectedAngle {}
impl DirectedAngle {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = DirectedAngle::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => entity.of_shape = parameter.into(),
                3usize => entity.product_definitional = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IDirectedDimensionalLocation: IDimensionalLocation {}
#[derive(Default, Debug)]
pub struct DirectedDimensionalLocation {
    name: Label,
    description: Option<Text>,
    relating_shape_aspect: EntityRef,
    related_shape_aspect: EntityRef,
}
impl IShapeAspectRelationship for DirectedDimensionalLocation {
    fn name(&self) -> &Label {
        &self.name
    }
    fn description(&self) -> &Option<Text> {
        &self.description
    }
    fn relating_shape_aspect(&self) -> &EntityRef {
        &self.relating_shape_aspect
    }
    fn related_shape_aspect(&self) -> &EntityRef {
        &self.related_shape_aspect
    }
}
impl IDimensionalLocation for DirectedDimensionalLocation {}
impl IDirectedDimensionalLocation for DirectedDimensionalLocation {}
impl DirectedDimensionalLocation {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = DirectedDimensionalLocation::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => entity.relating_shape_aspect = parameter.into(),
                3usize => entity.related_shape_aspect = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IDirection: IGeometricRepresentationItem {
    fn direction_ratios(&self) -> &Vec<Real>;
}
#[derive(Default, Debug)]
pub struct Direction {
    name: Label,
    direction_ratios: Vec<Real>,
}
impl IRepresentationItem for Direction {
    fn name(&self) -> &Label {
        &self.name
    }
}
impl IGeometricRepresentationItem for Direction {}
impl IDirection for Direction {
    fn direction_ratios(&self) -> &Vec<Real> {
        &self.direction_ratios
    }
}
impl Direction {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = Direction::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => entity.direction_ratios = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IDirectionShapeRepresentation: IShapeRepresentation {}
#[derive(Default, Debug)]
pub struct DirectionShapeRepresentation {
    name: Label,
    items: HashSet<EntityRef>,
    context_of_items: EntityRef,
}
impl IRepresentation for DirectionShapeRepresentation {
    fn name(&self) -> &Label {
        &self.name
    }
    fn items(&self) -> &HashSet<EntityRef> {
        &self.items
    }
    fn context_of_items(&self) -> &EntityRef {
        &self.context_of_items
    }
}
impl IShapeRepresentation for DirectionShapeRepresentation {}
impl IDirectionShapeRepresentation for DirectionShapeRepresentation {}
impl DirectionShapeRepresentation {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = DirectionShapeRepresentation::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => entity.items = parameter.into(),
                2usize => entity.context_of_items = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IDivExpression: IBinaryNumericExpression {}
#[derive(Default, Debug)]
pub struct DivExpression {
    operands: Vec<EntityRef>,
}
impl IGenericExpression for DivExpression {}
impl IExpression for DivExpression {}
impl INumericExpression for DivExpression {}
impl IBinaryNumericExpression for DivExpression {
    fn operands(&self) -> &Vec<EntityRef> {
        &self.operands
    }
}
impl IBinaryGenericExpression for DivExpression {
    fn operands(&self) -> &Vec<EntityRef> {
        &self.operands
    }
}
impl IDivExpression for DivExpression {}
impl DivExpression {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = DivExpression::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.operands = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IDocument {
    fn id(&self) -> &Identifier;
    fn name(&self) -> &Label;
    fn description(&self) -> &Option<Text>;
    fn kind(&self) -> &EntityRef;
}
#[derive(Default, Debug)]
pub struct Document {
    id: Identifier,
    name: Label,
    description: Option<Text>,
    kind: EntityRef,
}
impl IDocument for Document {
    fn id(&self) -> &Identifier {
        &self.id
    }
    fn name(&self) -> &Label {
        &self.name
    }
    fn description(&self) -> &Option<Text> {
        &self.description
    }
    fn kind(&self) -> &EntityRef {
        &self.kind
    }
}
impl Document {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = Document::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.id = parameter.into(),
                1usize => entity.name = parameter.into(),
                2usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => entity.kind = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IDocumentFile: IDocument + ICharacterizedObject {}
#[derive(Default, Debug)]
pub struct DocumentFile {
    id: Identifier,
    name: Label,
    description: Option<Text>,
    kind: EntityRef,
}
impl IDocument for DocumentFile {
    fn id(&self) -> &Identifier {
        &self.id
    }
    fn name(&self) -> &Label {
        &self.name
    }
    fn description(&self) -> &Option<Text> {
        &self.description
    }
    fn kind(&self) -> &EntityRef {
        &self.kind
    }
}
impl ICharacterizedObject for DocumentFile {
    fn name(&self) -> &Label {
        &self.name
    }
    fn description(&self) -> &Option<Text> {
        &self.description
    }
}
impl IDocumentFile for DocumentFile {}
impl DocumentFile {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = DocumentFile::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.id = parameter.into(),
                1usize => entity.name = parameter.into(),
                2usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => entity.kind = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IDocumentProductAssociation {
    fn name(&self) -> &Label;
    fn description(&self) -> &Option<Text>;
    fn relating_document(&self) -> &EntityRef;
    fn related_product(&self) -> &EntityRef;
}
#[derive(Default, Debug)]
pub struct DocumentProductAssociation {
    name: Label,
    description: Option<Text>,
    relating_document: EntityRef,
    related_product: EntityRef,
}
impl IDocumentProductAssociation for DocumentProductAssociation {
    fn name(&self) -> &Label {
        &self.name
    }
    fn description(&self) -> &Option<Text> {
        &self.description
    }
    fn relating_document(&self) -> &EntityRef {
        &self.relating_document
    }
    fn related_product(&self) -> &EntityRef {
        &self.related_product
    }
}
impl DocumentProductAssociation {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = DocumentProductAssociation::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => entity.relating_document = parameter.into(),
                3usize => entity.related_product = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IDocumentProductEquivalence: IDocumentProductAssociation {}
#[derive(Default, Debug)]
pub struct DocumentProductEquivalence {
    name: Label,
    description: Option<Text>,
    relating_document: EntityRef,
    related_product: EntityRef,
}
impl IDocumentProductAssociation for DocumentProductEquivalence {
    fn name(&self) -> &Label {
        &self.name
    }
    fn description(&self) -> &Option<Text> {
        &self.description
    }
    fn relating_document(&self) -> &EntityRef {
        &self.relating_document
    }
    fn related_product(&self) -> &EntityRef {
        &self.related_product
    }
}
impl IDocumentProductEquivalence for DocumentProductEquivalence {}
impl DocumentProductEquivalence {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = DocumentProductEquivalence::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => entity.relating_document = parameter.into(),
                3usize => entity.related_product = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IDocumentReference {
    fn assigned_document(&self) -> &EntityRef;
    fn source(&self) -> &Label;
}
pub trait IDocumentRelationship {
    fn name(&self) -> &Label;
    fn description(&self) -> &Option<Text>;
    fn relating_document(&self) -> &EntityRef;
    fn related_document(&self) -> &EntityRef;
}
#[derive(Default, Debug)]
pub struct DocumentRelationship {
    name: Label,
    description: Option<Text>,
    relating_document: EntityRef,
    related_document: EntityRef,
}
impl IDocumentRelationship for DocumentRelationship {
    fn name(&self) -> &Label {
        &self.name
    }
    fn description(&self) -> &Option<Text> {
        &self.description
    }
    fn relating_document(&self) -> &EntityRef {
        &self.relating_document
    }
    fn related_document(&self) -> &EntityRef {
        &self.related_document
    }
}
impl DocumentRelationship {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = DocumentRelationship::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => entity.relating_document = parameter.into(),
                3usize => entity.related_document = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IDocumentRepresentationType {
    fn name(&self) -> &Label;
    fn represented_document(&self) -> &EntityRef;
}
#[derive(Default, Debug)]
pub struct DocumentRepresentationType {
    name: Label,
    represented_document: EntityRef,
}
impl IDocumentRepresentationType for DocumentRepresentationType {
    fn name(&self) -> &Label {
        &self.name
    }
    fn represented_document(&self) -> &EntityRef {
        &self.represented_document
    }
}
impl DocumentRepresentationType {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = DocumentRepresentationType::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => entity.represented_document = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IDocumentType {
    fn product_data_type(&self) -> &Label;
}
#[derive(Default, Debug)]
pub struct DocumentType {
    product_data_type: Label,
}
impl IDocumentType for DocumentType {
    fn product_data_type(&self) -> &Label {
        &self.product_data_type
    }
}
impl DocumentType {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = DocumentType::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.product_data_type = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IDocumentUsageConstraint {
    fn source(&self) -> &EntityRef;
    fn subject_element(&self) -> &Label;
    fn subject_element_value(&self) -> &Text;
}
#[derive(Default, Debug)]
pub struct DocumentUsageConstraint {
    source: EntityRef,
    subject_element: Label,
    subject_element_value: Text,
}
impl IDocumentUsageConstraint for DocumentUsageConstraint {
    fn source(&self) -> &EntityRef {
        &self.source
    }
    fn subject_element(&self) -> &Label {
        &self.subject_element
    }
    fn subject_element_value(&self) -> &Text {
        &self.subject_element_value
    }
}
impl DocumentUsageConstraint {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = DocumentUsageConstraint::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.source = parameter.into(),
                1usize => entity.subject_element = parameter.into(),
                2usize => entity.subject_element_value = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IDocumentUsageConstraintAssignment {
    fn assigned_document_usage(&self) -> &EntityRef;
    fn role(&self) -> &EntityRef;
}
pub trait IDocumentUsageRole {
    fn name(&self) -> &Label;
    fn description(&self) -> &Option<Text>;
}
#[derive(Default, Debug)]
pub struct DocumentUsageRole {
    name: Label,
    description: Option<Text>,
}
impl IDocumentUsageRole for DocumentUsageRole {
    fn name(&self) -> &Label {
        &self.name
    }
    fn description(&self) -> &Option<Text> {
        &self.description
    }
}
impl DocumentUsageRole {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = DocumentUsageRole::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
}
pub trait IDraughtingAnnotationOccurrence: IAnnotationOccurrence {}
#[derive(Default, Debug)]
pub struct DraughtingAnnotationOccurrence {
    name: Label,
    styles: HashSet<EntityRef>,
    item: EntityRef,
}
impl IRepresentationItem for DraughtingAnnotationOccurrence {
    fn name(&self) -> &Label {
        &self.name
    }
}
impl IStyledItem for DraughtingAnnotationOccurrence {
    fn styles(&self) -> &HashSet<EntityRef> {
        &self.styles
    }
    fn item(&self) -> &EntityRef {
        &self.item
    }
}
impl IAnnotationOccurrence for DraughtingAnnotationOccurrence {}
impl IDraughtingAnnotationOccurrence for DraughtingAnnotationOccurrence {}
impl DraughtingAnnotationOccurrence {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = DraughtingAnnotationOccurrence::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => entity.styles = parameter.into(),
                2usize => entity.item = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IDraughtingCallout: IGeometricRepresentationItem {
    fn contents(&self) -> &HashSet<EntityRef>;
}
#[derive(Default, Debug)]
pub struct DraughtingCallout {
    name: Label,
    contents: HashSet<EntityRef>,
}
impl IRepresentationItem for DraughtingCallout {
    fn name(&self) -> &Label {
        &self.name
    }
}
impl IGeometricRepresentationItem for DraughtingCallout {}
impl IDraughtingCallout for DraughtingCallout {
    fn contents(&self) -> &HashSet<EntityRef> {
        &self.contents
    }
}
impl DraughtingCallout {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = DraughtingCallout::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => entity.contents = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IDraughtingCalloutRelationship {
    fn name(&self) -> &Label;
    fn description(&self) -> &Text;
    fn relating_draughting_callout(&self) -> &EntityRef;
    fn related_draughting_callout(&self) -> &EntityRef;
}
#[derive(Default, Debug)]
pub struct DraughtingCalloutRelationship {
    name: Label,
    description: Text,
    relating_draughting_callout: EntityRef,
    related_draughting_callout: EntityRef,
}
impl IDraughtingCalloutRelationship for DraughtingCalloutRelationship {
    fn name(&self) -> &Label {
        &self.name
    }
    fn description(&self) -> &Text {
        &self.description
    }
    fn relating_draughting_callout(&self) -> &EntityRef {
        &self.relating_draughting_callout
    }
    fn related_draughting_callout(&self) -> &EntityRef {
        &self.related_draughting_callout
    }
}
impl DraughtingCalloutRelationship {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = DraughtingCalloutRelationship::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => entity.description = parameter.into(),
                2usize => entity.relating_draughting_callout = parameter.into(),
                3usize => entity.related_draughting_callout = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IDraughtingElements: IDraughtingCallout {}
#[derive(Default, Debug)]
pub struct DraughtingElements {
    name: Label,
    contents: HashSet<EntityRef>,
}
impl IRepresentationItem for DraughtingElements {
    fn name(&self) -> &Label {
        &self.name
    }
}
impl IGeometricRepresentationItem for DraughtingElements {}
impl IDraughtingCallout for DraughtingElements {
    fn contents(&self) -> &HashSet<EntityRef> {
        &self.contents
    }
}
impl IDraughtingElements for DraughtingElements {}
impl DraughtingElements {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = DraughtingElements::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => entity.contents = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IDraughtingModel: IRepresentation {}
#[derive(Default, Debug)]
pub struct DraughtingModel {
    name: Label,
    items: HashSet<EntityRef>,
    context_of_items: EntityRef,
}
impl IRepresentation for DraughtingModel {
    fn name(&self) -> &Label {
        &self.name
    }
    fn items(&self) -> &HashSet<EntityRef> {
        &self.items
    }
    fn context_of_items(&self) -> &EntityRef {
        &self.context_of_items
    }
}
impl IDraughtingModel for DraughtingModel {}
impl DraughtingModel {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = DraughtingModel::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => entity.items = parameter.into(),
                2usize => entity.context_of_items = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IDraughtingModelItemAssociation: IItemIdentifiedRepresentationUsage {
    fn definition(&self) -> &EntityRef;
    fn used_representation(&self) -> &EntityRef;
    fn identified_item(&self) -> &EntityRef;
}
#[derive(Default, Debug)]
pub struct DraughtingModelItemAssociation {
    name: Label,
    description: Option<Text>,
    definition: EntityRef,
    used_representation: EntityRef,
    identified_item: EntityRef,
}
impl IItemIdentifiedRepresentationUsage for DraughtingModelItemAssociation {
    fn name(&self) -> &Label {
        &self.name
    }
    fn description(&self) -> &Option<Text> {
        &self.description
    }
    fn definition(&self) -> &EntityRef {
        &self.definition
    }
    fn used_representation(&self) -> &EntityRef {
        &self.used_representation
    }
    fn identified_item(&self) -> &EntityRef {
        &self.identified_item
    }
}
impl IDraughtingModelItemAssociation for DraughtingModelItemAssociation {
    fn definition(&self) -> &EntityRef {
        &self.definition
    }
    fn used_representation(&self) -> &EntityRef {
        &self.used_representation
    }
    fn identified_item(&self) -> &EntityRef {
        &self.identified_item
    }
}
impl DraughtingModelItemAssociation {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = DraughtingModelItemAssociation::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => entity.definition = parameter.into(),
                3usize => entity.used_representation = parameter.into(),
                4usize => entity.identified_item = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IDraughtingPreDefinedColour: IPreDefinedColour {}
#[derive(Default, Debug)]
pub struct DraughtingPreDefinedColour {
    name: Label,
}
impl IPreDefinedItem for DraughtingPreDefinedColour {
    fn name(&self) -> &Label {
        &self.name
    }
}
impl IColour for DraughtingPreDefinedColour {}
impl IPreDefinedColour for DraughtingPreDefinedColour {}
impl IDraughtingPreDefinedColour for DraughtingPreDefinedColour {}
impl DraughtingPreDefinedColour {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = DraughtingPreDefinedColour::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IDraughtingPreDefinedCurveFont: IPreDefinedCurveFont {}
#[derive(Default, Debug)]
pub struct DraughtingPreDefinedCurveFont {
    name: Label,
}
impl IPreDefinedItem for DraughtingPreDefinedCurveFont {
    fn name(&self) -> &Label {
        &self.name
    }
}
impl IPreDefinedCurveFont for DraughtingPreDefinedCurveFont {}
impl IDraughtingPreDefinedCurveFont for DraughtingPreDefinedCurveFont {}
impl DraughtingPreDefinedCurveFont {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = DraughtingPreDefinedCurveFont::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IDraughtingPreDefinedTextFont: IPreDefinedTextFont {}
#[derive(Default, Debug)]
pub struct DraughtingPreDefinedTextFont {
    name: Label,
}
impl IPreDefinedItem for DraughtingPreDefinedTextFont {
    fn name(&self) -> &Label {
        &self.name
    }
}
impl IPreDefinedTextFont for DraughtingPreDefinedTextFont {}
impl IDraughtingPreDefinedTextFont for DraughtingPreDefinedTextFont {}
impl DraughtingPreDefinedTextFont {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = DraughtingPreDefinedTextFont::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IDraughtingSpecificationReference: IDocumentReference {
    fn specified_items(&self) -> &HashSet<EntityRef>;
}
#[derive(Default, Debug)]
pub struct DraughtingSpecificationReference {
    assigned_document: EntityRef,
    source: Label,
    specified_items: HashSet<EntityRef>,
}
impl IDocumentReference for DraughtingSpecificationReference {
    fn assigned_document(&self) -> &EntityRef {
        &self.assigned_document
    }
    fn source(&self) -> &Label {
        &self.source
    }
}
impl IDraughtingSpecificationReference for DraughtingSpecificationReference {
    fn specified_items(&self) -> &HashSet<EntityRef> {
        &self.specified_items
    }
}
impl DraughtingSpecificationReference {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = DraughtingSpecificationReference::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.assigned_document = parameter.into(),
                1usize => entity.source = parameter.into(),
                2usize => entity.specified_items = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IDraughtingSubfigureRepresentation: ISymbolRepresentation {}
#[derive(Default, Debug)]
pub struct DraughtingSubfigureRepresentation {
    name: Label,
    items: HashSet<EntityRef>,
    context_of_items: EntityRef,
}
impl IRepresentation for DraughtingSubfigureRepresentation {
    fn name(&self) -> &Label {
        &self.name
    }
    fn items(&self) -> &HashSet<EntityRef> {
        &self.items
    }
    fn context_of_items(&self) -> &EntityRef {
        &self.context_of_items
    }
}
impl ISymbolRepresentation for DraughtingSubfigureRepresentation {}
impl IDraughtingSubfigureRepresentation for DraughtingSubfigureRepresentation {}
impl DraughtingSubfigureRepresentation {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = DraughtingSubfigureRepresentation::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => entity.items = parameter.into(),
                2usize => entity.context_of_items = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IDraughtingSymbolRepresentation: ISymbolRepresentation {}
#[derive(Default, Debug)]
pub struct DraughtingSymbolRepresentation {
    name: Label,
    items: HashSet<EntityRef>,
    context_of_items: EntityRef,
}
impl IRepresentation for DraughtingSymbolRepresentation {
    fn name(&self) -> &Label {
        &self.name
    }
    fn items(&self) -> &HashSet<EntityRef> {
        &self.items
    }
    fn context_of_items(&self) -> &EntityRef {
        &self.context_of_items
    }
}
impl ISymbolRepresentation for DraughtingSymbolRepresentation {}
impl IDraughtingSymbolRepresentation for DraughtingSymbolRepresentation {}
impl DraughtingSymbolRepresentation {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = DraughtingSymbolRepresentation::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => entity.items = parameter.into(),
                2usize => entity.context_of_items = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IDraughtingTextLiteralWithDelineation: ITextLiteralWithDelineation {}
#[derive(Default, Debug)]
pub struct DraughtingTextLiteralWithDelineation {
    name: Label,
    literal: PresentableText,
    placement: EntityRef,
    alignment: TextAlignment,
    path: TextPath,
    font: EntityRef,
    delineation: TextDelineation,
}
impl IRepresentationItem for DraughtingTextLiteralWithDelineation {
    fn name(&self) -> &Label {
        &self.name
    }
}
impl IGeometricRepresentationItem for DraughtingTextLiteralWithDelineation {}
impl ITextLiteral for DraughtingTextLiteralWithDelineation {
    fn literal(&self) -> &PresentableText {
        &self.literal
    }
    fn placement(&self) -> &EntityRef {
        &self.placement
    }
    fn alignment(&self) -> &TextAlignment {
        &self.alignment
    }
    fn path(&self) -> &TextPath {
        &self.path
    }
    fn font(&self) -> &EntityRef {
        &self.font
    }
}
impl ITextLiteralWithDelineation for DraughtingTextLiteralWithDelineation {
    fn delineation(&self) -> &TextDelineation {
        &self.delineation
    }
}
impl IDraughtingTextLiteralWithDelineation for DraughtingTextLiteralWithDelineation {}
impl DraughtingTextLiteralWithDelineation {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = DraughtingTextLiteralWithDelineation::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => entity.literal = parameter.into(),
                2usize => entity.placement = parameter.into(),
                3usize => entity.alignment = parameter.into(),
                4usize => entity.path = parameter.into(),
                5usize => entity.font = parameter.into(),
                6usize => entity.delineation = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IDraughtingTitle {
    fn items(&self) -> &HashSet<EntityRef>;
    fn language(&self) -> &Label;
    fn contents(&self) -> &Text;
}
#[derive(Default, Debug)]
pub struct DraughtingTitle {
    items: HashSet<EntityRef>,
    language: Label,
    contents: Text,
}
impl IDraughtingTitle for DraughtingTitle {
    fn items(&self) -> &HashSet<EntityRef> {
        &self.items
    }
    fn language(&self) -> &Label {
        &self.language
    }
    fn contents(&self) -> &Text {
        &self.contents
    }
}
impl DraughtingTitle {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = DraughtingTitle::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.items = parameter.into(),
                1usize => entity.language = parameter.into(),
                2usize => entity.contents = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IDrawingDefinition {
    fn drawing_number(&self) -> &Identifier;
    fn drawing_type(&self) -> &Option<Label>;
}
#[derive(Default, Debug)]
pub struct DrawingDefinition {
    drawing_number: Identifier,
    drawing_type: Option<Label>,
}
impl IDrawingDefinition for DrawingDefinition {
    fn drawing_number(&self) -> &Identifier {
        &self.drawing_number
    }
    fn drawing_type(&self) -> &Option<Label> {
        &self.drawing_type
    }
}
impl DrawingDefinition {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = DrawingDefinition::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.drawing_number = parameter.into(),
                1usize => {
                    entity.drawing_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
}
pub trait IDrawingRevision: IPresentationSet {
    fn revision_identifier(&self) -> &Identifier;
    fn drawing_identifier(&self) -> &EntityRef;
    fn intended_scale(&self) -> &Option<Text>;
}
#[derive(Default, Debug)]
pub struct DrawingRevision {
    revision_identifier: Identifier,
    drawing_identifier: EntityRef,
    intended_scale: Option<Text>,
}
impl IPresentationSet for DrawingRevision {}
impl IDrawingRevision for DrawingRevision {
    fn revision_identifier(&self) -> &Identifier {
        &self.revision_identifier
    }
    fn drawing_identifier(&self) -> &EntityRef {
        &self.drawing_identifier
    }
    fn intended_scale(&self) -> &Option<Text> {
        &self.intended_scale
    }
}
impl DrawingRevision {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = DrawingRevision::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.revision_identifier = parameter.into(),
                1usize => entity.drawing_identifier = parameter.into(),
                2usize => {
                    entity.intended_scale = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
}
pub trait IDrawingRevisionSequence {
    fn predecessor(&self) -> &EntityRef;
    fn successor(&self) -> &EntityRef;
}
#[derive(Default, Debug)]
pub struct DrawingRevisionSequence {
    predecessor: EntityRef,
    successor: EntityRef,
}
impl IDrawingRevisionSequence for DrawingRevisionSequence {
    fn predecessor(&self) -> &EntityRef {
        &self.predecessor
    }
    fn successor(&self) -> &EntityRef {
        &self.successor
    }
}
impl DrawingRevisionSequence {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = DrawingRevisionSequence::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.predecessor = parameter.into(),
                1usize => entity.successor = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IDrawingSheetLayout: IDraughtingSymbolRepresentation {}
#[derive(Default, Debug)]
pub struct DrawingSheetLayout {
    name: Label,
    items: HashSet<EntityRef>,
    context_of_items: EntityRef,
}
impl IRepresentation for DrawingSheetLayout {
    fn name(&self) -> &Label {
        &self.name
    }
    fn items(&self) -> &HashSet<EntityRef> {
        &self.items
    }
    fn context_of_items(&self) -> &EntityRef {
        &self.context_of_items
    }
}
impl ISymbolRepresentation for DrawingSheetLayout {}
impl IDraughtingSymbolRepresentation for DrawingSheetLayout {}
impl IDrawingSheetLayout for DrawingSheetLayout {}
impl DrawingSheetLayout {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = DrawingSheetLayout::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => entity.items = parameter.into(),
                2usize => entity.context_of_items = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IDrawingSheetRevision: IPresentationArea {
    fn revision_identifier(&self) -> &Identifier;
}
#[derive(Default, Debug)]
pub struct DrawingSheetRevision {
    name: Label,
    items: HashSet<EntityRef>,
    context_of_items: EntityRef,
    revision_identifier: Identifier,
}
impl IRepresentation for DrawingSheetRevision {
    fn name(&self) -> &Label {
        &self.name
    }
    fn items(&self) -> &HashSet<EntityRef> {
        &self.items
    }
    fn context_of_items(&self) -> &EntityRef {
        &self.context_of_items
    }
}
impl IPresentationRepresentation for DrawingSheetRevision {
    fn context_of_items(&self) -> &EntityRef {
        &self.context_of_items
    }
}
impl IPresentationArea for DrawingSheetRevision {}
impl IDrawingSheetRevision for DrawingSheetRevision {
    fn revision_identifier(&self) -> &Identifier {
        &self.revision_identifier
    }
}
impl DrawingSheetRevision {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = DrawingSheetRevision::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => entity.items = parameter.into(),
                2usize => entity.context_of_items = parameter.into(),
                3usize => entity.revision_identifier = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IDrawingSheetRevisionUsage: IAreaInSet {
    fn sheet_number(&self) -> &Identifier;
}
#[derive(Default, Debug)]
pub struct DrawingSheetRevisionUsage {
    area: EntityRef,
    in_set: EntityRef,
    sheet_number: Identifier,
}
impl IAreaInSet for DrawingSheetRevisionUsage {
    fn area(&self) -> &EntityRef {
        &self.area
    }
    fn in_set(&self) -> &EntityRef {
        &self.in_set
    }
}
impl IDrawingSheetRevisionUsage for DrawingSheetRevisionUsage {
    fn sheet_number(&self) -> &Identifier {
        &self.sheet_number
    }
}
impl DrawingSheetRevisionUsage {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = DrawingSheetRevisionUsage::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.area = parameter.into(),
                1usize => entity.in_set = parameter.into(),
                2usize => entity.sheet_number = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IEdge: ITopologicalRepresentationItem {
    fn edge_start(&self) -> &EntityRef;
    fn edge_end(&self) -> &EntityRef;
}
#[derive(Default, Debug)]
pub struct Edge {
    name: Label,
    edge_start: EntityRef,
    edge_end: EntityRef,
}
impl IRepresentationItem for Edge {
    fn name(&self) -> &Label {
        &self.name
    }
}
impl ITopologicalRepresentationItem for Edge {}
impl IEdge for Edge {
    fn edge_start(&self) -> &EntityRef {
        &self.edge_start
    }
    fn edge_end(&self) -> &EntityRef {
        &self.edge_end
    }
}
impl Edge {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = Edge::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => entity.edge_start = parameter.into(),
                2usize => entity.edge_end = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IEdgeBasedWireframeModel: IGeometricRepresentationItem {
    fn ebwm_boundary(&self) -> &HashSet<EntityRef>;
}
#[derive(Default, Debug)]
pub struct EdgeBasedWireframeModel {
    name: Label,
    ebwm_boundary: HashSet<EntityRef>,
}
impl IRepresentationItem for EdgeBasedWireframeModel {
    fn name(&self) -> &Label {
        &self.name
    }
}
impl IGeometricRepresentationItem for EdgeBasedWireframeModel {}
impl IEdgeBasedWireframeModel for EdgeBasedWireframeModel {
    fn ebwm_boundary(&self) -> &HashSet<EntityRef> {
        &self.ebwm_boundary
    }
}
impl EdgeBasedWireframeModel {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = EdgeBasedWireframeModel::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => entity.ebwm_boundary = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IEdgeBasedWireframeShapeRepresentation: IShapeRepresentation {}
#[derive(Default, Debug)]
pub struct EdgeBasedWireframeShapeRepresentation {
    name: Label,
    items: HashSet<EntityRef>,
    context_of_items: EntityRef,
}
impl IRepresentation for EdgeBasedWireframeShapeRepresentation {
    fn name(&self) -> &Label {
        &self.name
    }
    fn items(&self) -> &HashSet<EntityRef> {
        &self.items
    }
    fn context_of_items(&self) -> &EntityRef {
        &self.context_of_items
    }
}
impl IShapeRepresentation for EdgeBasedWireframeShapeRepresentation {}
impl IEdgeBasedWireframeShapeRepresentation for EdgeBasedWireframeShapeRepresentation {}
impl EdgeBasedWireframeShapeRepresentation {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = EdgeBasedWireframeShapeRepresentation::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => entity.items = parameter.into(),
                2usize => entity.context_of_items = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IEdgeCurve: IEdge + IGeometricRepresentationItem {
    fn edge_geometry(&self) -> &EntityRef;
    fn same_sense(&self) -> bool;
}
#[derive(Default, Debug)]
pub struct EdgeCurve {
    name: Label,
    edge_start: EntityRef,
    edge_end: EntityRef,
    edge_geometry: EntityRef,
    same_sense: bool,
}
impl IRepresentationItem for EdgeCurve {
    fn name(&self) -> &Label {
        &self.name
    }
}
impl ITopologicalRepresentationItem for EdgeCurve {}
impl IEdge for EdgeCurve {
    fn edge_start(&self) -> &EntityRef {
        &self.edge_start
    }
    fn edge_end(&self) -> &EntityRef {
        &self.edge_end
    }
}
impl IEdgeCurve for EdgeCurve {
    fn edge_geometry(&self) -> &EntityRef {
        &self.edge_geometry
    }
    fn same_sense(&self) -> bool {
        self.same_sense
    }
}
impl IGeometricRepresentationItem for EdgeCurve {}
impl EdgeCurve {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = EdgeCurve::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => entity.edge_start = parameter.into(),
                2usize => entity.edge_end = parameter.into(),
                3usize => entity.edge_geometry = parameter.into(),
                4usize => entity.same_sense = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IEdgeLoop: ILoop + IPath {}
#[derive(Default, Debug)]
pub struct EdgeLoop {
    name: Label,
    edge_list: Vec<EntityRef>,
}
impl IRepresentationItem for EdgeLoop {
    fn name(&self) -> &Label {
        &self.name
    }
}
impl ITopologicalRepresentationItem for EdgeLoop {}
impl ILoop for EdgeLoop {}
impl IEdgeLoop for EdgeLoop {}
impl IPath for EdgeLoop {
    fn edge_list(&self) -> &Vec<EntityRef> {
        &self.edge_list
    }
}
impl EdgeLoop {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = EdgeLoop::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => entity.edge_list = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IEdgeRound: ITransitionFeature {}
#[derive(Default, Debug)]
pub struct EdgeRound {
    name: Label,
    description: Option<Text>,
    of_shape: EntityRef,
    product_definitional: Option<bool>,
}
impl IShapeAspect for EdgeRound {
    fn name(&self) -> &Label {
        &self.name
    }
    fn description(&self) -> &Option<Text> {
        &self.description
    }
    fn of_shape(&self) -> &EntityRef {
        &self.of_shape
    }
    fn product_definitional(&self) -> Option<bool> {
        self.product_definitional
    }
}
impl ITransitionFeature for EdgeRound {}
impl IEdgeRound for EdgeRound {}
impl EdgeRound {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = EdgeRound::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => entity.of_shape = parameter.into(),
                3usize => entity.product_definitional = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IEffectivity {
    fn id(&self) -> &Identifier;
}
#[derive(Default, Debug)]
pub struct Effectivity {
    id: Identifier,
}
impl IEffectivity for Effectivity {
    fn id(&self) -> &Identifier {
        &self.id
    }
}
impl Effectivity {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = Effectivity::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.id = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IEffectivityAssignment {
    fn assigned_effectivity(&self) -> &EntityRef;
}
pub trait IEffectivityContextAssignment {
    fn assigned_effectivity_assignment(&self) -> &EntityRef;
    fn role(&self) -> &EntityRef;
}
pub trait IEffectivityContextRole {
    fn name(&self) -> &Label;
    fn description(&self) -> &Option<Text>;
}
#[derive(Default, Debug)]
pub struct EffectivityContextRole {
    name: Label,
    description: Option<Text>,
}
impl IEffectivityContextRole for EffectivityContextRole {
    fn name(&self) -> &Label {
        &self.name
    }
    fn description(&self) -> &Option<Text> {
        &self.description
    }
}
impl EffectivityContextRole {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = EffectivityContextRole::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
}
pub trait IEffectivityRelationship {
    fn name(&self) -> &Label;
    fn description(&self) -> &Option<Text>;
    fn related_effectivity(&self) -> &EntityRef;
    fn relating_effectivity(&self) -> &EntityRef;
}
#[derive(Default, Debug)]
pub struct EffectivityRelationship {
    name: Label,
    description: Option<Text>,
    related_effectivity: EntityRef,
    relating_effectivity: EntityRef,
}
impl IEffectivityRelationship for EffectivityRelationship {
    fn name(&self) -> &Label {
        &self.name
    }
    fn description(&self) -> &Option<Text> {
        &self.description
    }
    fn related_effectivity(&self) -> &EntityRef {
        &self.related_effectivity
    }
    fn relating_effectivity(&self) -> &EntityRef {
        &self.relating_effectivity
    }
}
impl EffectivityRelationship {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = EffectivityRelationship::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => entity.related_effectivity = parameter.into(),
                3usize => entity.relating_effectivity = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IElectricCurrentMeasureWithUnit: IMeasureWithUnit {}
#[derive(Default, Debug)]
pub struct ElectricCurrentMeasureWithUnit {
    value_component: MeasureValue,
    unit_component: EntityRef,
}
impl IMeasureWithUnit for ElectricCurrentMeasureWithUnit {
    fn value_component(&self) -> &MeasureValue {
        &self.value_component
    }
    fn unit_component(&self) -> &EntityRef {
        &self.unit_component
    }
}
impl IElectricCurrentMeasureWithUnit for ElectricCurrentMeasureWithUnit {}
impl ElectricCurrentMeasureWithUnit {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = ElectricCurrentMeasureWithUnit::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.value_component = parameter.into(),
                1usize => entity.unit_component = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IElectricCurrentUnit: INamedUnit {}
#[derive(Default, Debug)]
pub struct ElectricCurrentUnit {
    dimensions: EntityRef,
}
impl INamedUnit for ElectricCurrentUnit {
    fn dimensions(&self) -> &EntityRef {
        &self.dimensions
    }
}
impl IElectricCurrentUnit for ElectricCurrentUnit {}
impl ElectricCurrentUnit {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = ElectricCurrentUnit::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.dimensions = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IElementDelivery: IAction {}
#[derive(Default, Debug)]
pub struct ElementDelivery {
    name: Label,
    description: Option<Text>,
    chosen_method: EntityRef,
}
impl IAction for ElementDelivery {
    fn name(&self) -> &Label {
        &self.name
    }
    fn description(&self) -> &Option<Text> {
        &self.description
    }
    fn chosen_method(&self) -> &EntityRef {
        &self.chosen_method
    }
}
impl IElementDelivery for ElementDelivery {}
impl ElementDelivery {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = ElementDelivery::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => entity.chosen_method = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IElementarySurface: ISurface {
    fn position(&self) -> &EntityRef;
}
#[derive(Default, Debug)]
pub struct ElementarySurface {
    name: Label,
    position: EntityRef,
}
impl IRepresentationItem for ElementarySurface {
    fn name(&self) -> &Label {
        &self.name
    }
}
impl IGeometricRepresentationItem for ElementarySurface {}
impl ISurface for ElementarySurface {}
impl IElementarySurface for ElementarySurface {
    fn position(&self) -> &EntityRef {
        &self.position
    }
}
impl ElementarySurface {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = ElementarySurface::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => entity.position = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IEllipse: IConic {
    fn semi_axis_1(&self) -> &PositiveLengthMeasure;
    fn semi_axis_2(&self) -> &PositiveLengthMeasure;
}
#[derive(Default, Debug)]
pub struct Ellipse {
    name: Label,
    position: EntityRef,
    semi_axis_1: PositiveLengthMeasure,
    semi_axis_2: PositiveLengthMeasure,
}
impl IRepresentationItem for Ellipse {
    fn name(&self) -> &Label {
        &self.name
    }
}
impl IGeometricRepresentationItem for Ellipse {}
impl ICurve for Ellipse {}
impl IConic for Ellipse {
    fn position(&self) -> &EntityRef {
        &self.position
    }
}
impl IEllipse for Ellipse {
    fn semi_axis_1(&self) -> &PositiveLengthMeasure {
        &self.semi_axis_1
    }
    fn semi_axis_2(&self) -> &PositiveLengthMeasure {
        &self.semi_axis_2
    }
}
impl Ellipse {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = Ellipse::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => entity.position = parameter.into(),
                2usize => entity.semi_axis_1 = parameter.into(),
                3usize => entity.semi_axis_2 = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IEnvironment {
    fn syntactic_representation(&self) -> &EntityRef;
    fn semantics(&self) -> &EntityRef;
}
#[derive(Default, Debug)]
pub struct Environment {
    syntactic_representation: EntityRef,
    semantics: EntityRef,
}
impl IEnvironment for Environment {
    fn syntactic_representation(&self) -> &EntityRef {
        &self.syntactic_representation
    }
    fn semantics(&self) -> &EntityRef {
        &self.semantics
    }
}
impl Environment {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = Environment::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.syntactic_representation = parameter.into(),
                1usize => entity.semantics = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IEqualsExpression: IBinaryBooleanExpression {}
#[derive(Default, Debug)]
pub struct EqualsExpression {
    operands: Vec<EntityRef>,
}
impl IGenericExpression for EqualsExpression {}
impl IExpression for EqualsExpression {}
impl IBooleanExpression for EqualsExpression {}
impl IBinaryBooleanExpression for EqualsExpression {}
impl IBinaryGenericExpression for EqualsExpression {
    fn operands(&self) -> &Vec<EntityRef> {
        &self.operands
    }
}
impl IEqualsExpression for EqualsExpression {}
impl EqualsExpression {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = EqualsExpression::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.operands = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IEvaluatedDegeneratePcurve: IDegeneratePcurve {
    fn equivalent_point(&self) -> &EntityRef;
}
#[derive(Default, Debug)]
pub struct EvaluatedDegeneratePcurve {
    name: Label,
    basis_surface: EntityRef,
    reference_to_curve: EntityRef,
    equivalent_point: EntityRef,
}
impl IRepresentationItem for EvaluatedDegeneratePcurve {
    fn name(&self) -> &Label {
        &self.name
    }
}
impl IGeometricRepresentationItem for EvaluatedDegeneratePcurve {}
impl IPoint for EvaluatedDegeneratePcurve {}
impl IDegeneratePcurve for EvaluatedDegeneratePcurve {
    fn basis_surface(&self) -> &EntityRef {
        &self.basis_surface
    }
    fn reference_to_curve(&self) -> &EntityRef {
        &self.reference_to_curve
    }
}
impl IEvaluatedDegeneratePcurve for EvaluatedDegeneratePcurve {
    fn equivalent_point(&self) -> &EntityRef {
        &self.equivalent_point
    }
}
impl EvaluatedDegeneratePcurve {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = EvaluatedDegeneratePcurve::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => entity.basis_surface = parameter.into(),
                2usize => entity.reference_to_curve = parameter.into(),
                3usize => entity.equivalent_point = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IEventOccurrence {
    fn id(&self) -> &Identifier;
    fn name(&self) -> &Label;
    fn description(&self) -> &Option<Text>;
}
#[derive(Default, Debug)]
pub struct EventOccurrence {
    id: Identifier,
    name: Label,
    description: Option<Text>,
}
impl IEventOccurrence for EventOccurrence {
    fn id(&self) -> &Identifier {
        &self.id
    }
    fn name(&self) -> &Label {
        &self.name
    }
    fn description(&self) -> &Option<Text> {
        &self.description
    }
}
impl EventOccurrence {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = EventOccurrence::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.id = parameter.into(),
                1usize => entity.name = parameter.into(),
                2usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
}
pub trait IEventOccurrenceAssignment {
    fn assigned_event_occurrence(&self) -> &EntityRef;
    fn role(&self) -> &EntityRef;
}
pub trait IEventOccurrenceContextAssignment {
    fn assigned_event_occurrence_assignment(&self) -> &EntityRef;
    fn role(&self) -> &EntityRef;
}
pub trait IEventOccurrenceContextRole {
    fn name(&self) -> &Label;
    fn description(&self) -> &Option<Text>;
}
#[derive(Default, Debug)]
pub struct EventOccurrenceContextRole {
    name: Label,
    description: Option<Text>,
}
impl IEventOccurrenceContextRole for EventOccurrenceContextRole {
    fn name(&self) -> &Label {
        &self.name
    }
    fn description(&self) -> &Option<Text> {
        &self.description
    }
}
impl EventOccurrenceContextRole {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = EventOccurrenceContextRole::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
}
pub trait IEventOccurrenceRole {
    fn name(&self) -> &Label;
    fn description(&self) -> &Option<Text>;
}
#[derive(Default, Debug)]
pub struct EventOccurrenceRole {
    name: Label,
    description: Option<Text>,
}
impl IEventOccurrenceRole for EventOccurrenceRole {
    fn name(&self) -> &Label {
        &self.name
    }
    fn description(&self) -> &Option<Text> {
        &self.description
    }
}
impl EventOccurrenceRole {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = EventOccurrenceRole::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
}
pub trait IExclusiveProductConceptFeatureCategory: IProductConceptFeatureCategory {}
#[derive(Default, Debug)]
pub struct ExclusiveProductConceptFeatureCategory {
    name: Label,
    description: Option<Text>,
}
impl IGroup for ExclusiveProductConceptFeatureCategory {
    fn name(&self) -> &Label {
        &self.name
    }
    fn description(&self) -> &Option<Text> {
        &self.description
    }
}
impl IProductConceptFeatureCategory for ExclusiveProductConceptFeatureCategory {}
impl IExclusiveProductConceptFeatureCategory for ExclusiveProductConceptFeatureCategory {}
impl ExclusiveProductConceptFeatureCategory {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = ExclusiveProductConceptFeatureCategory::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
}
pub trait IExecutedAction: IAction {}
#[derive(Default, Debug)]
pub struct ExecutedAction {
    name: Label,
    description: Option<Text>,
    chosen_method: EntityRef,
}
impl IAction for ExecutedAction {
    fn name(&self) -> &Label {
        &self.name
    }
    fn description(&self) -> &Option<Text> {
        &self.description
    }
    fn chosen_method(&self) -> &EntityRef {
        &self.chosen_method
    }
}
impl IExecutedAction for ExecutedAction {}
impl ExecutedAction {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = ExecutedAction::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => entity.chosen_method = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IExpFunction: IUnaryFunctionCall {}
#[derive(Default, Debug)]
pub struct ExpFunction {
    operand: EntityRef,
}
impl IGenericExpression for ExpFunction {}
impl IExpression for ExpFunction {}
impl INumericExpression for ExpFunction {}
impl IUnaryNumericExpression for ExpFunction {
    fn operand(&self) -> &EntityRef {
        &self.operand
    }
}
impl IUnaryGenericExpression for ExpFunction {
    fn operand(&self) -> &EntityRef {
        &self.operand
    }
}
impl IUnaryFunctionCall for ExpFunction {}
impl IExpFunction for ExpFunction {}
impl ExpFunction {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = ExpFunction::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.operand = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IExpression: IGenericExpression {}
pub trait IExpressionConversionBasedUnit: IContextDependentUnit + IVariableSemantics {}
#[derive(Default, Debug)]
pub struct ExpressionConversionBasedUnit {
    dimensions: EntityRef,
    name: Label,
}
impl INamedUnit for ExpressionConversionBasedUnit {
    fn dimensions(&self) -> &EntityRef {
        &self.dimensions
    }
}
impl IContextDependentUnit for ExpressionConversionBasedUnit {
    fn name(&self) -> &Label {
        &self.name
    }
}
impl IVariableSemantics for ExpressionConversionBasedUnit {}
impl IExpressionConversionBasedUnit for ExpressionConversionBasedUnit {}
impl ExpressionConversionBasedUnit {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = ExpressionConversionBasedUnit::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.dimensions = parameter.into(),
                1usize => entity.name = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IExtension: IDerivedShapeAspect {}
#[derive(Default, Debug)]
pub struct Extension {
    name: Label,
    description: Option<Text>,
    of_shape: EntityRef,
    product_definitional: Option<bool>,
}
impl IShapeAspect for Extension {
    fn name(&self) -> &Label {
        &self.name
    }
    fn description(&self) -> &Option<Text> {
        &self.description
    }
    fn of_shape(&self) -> &EntityRef {
        &self.of_shape
    }
    fn product_definitional(&self) -> Option<bool> {
        self.product_definitional
    }
}
impl IDerivedShapeAspect for Extension {}
impl IExtension for Extension {}
impl Extension {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = Extension::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => entity.of_shape = parameter.into(),
                3usize => entity.product_definitional = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IExternalIdentificationAssignment: IIdentificationAssignment {
    fn source(&self) -> &EntityRef;
}
pub trait IExternalSource {
    fn source_id(&self) -> &SourceItem;
}
#[derive(Default, Debug)]
pub struct ExternalSource {
    source_id: SourceItem,
}
impl IExternalSource for ExternalSource {
    fn source_id(&self) -> &SourceItem {
        &self.source_id
    }
}
impl ExternalSource {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = ExternalSource::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.source_id = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IExternallyDefinedCharacterGlyph: IExternallyDefinedItem {}
#[derive(Default, Debug)]
pub struct ExternallyDefinedCharacterGlyph {
    item_id: SourceItem,
    source: EntityRef,
}
impl IExternallyDefinedItem for ExternallyDefinedCharacterGlyph {
    fn item_id(&self) -> &SourceItem {
        &self.item_id
    }
    fn source(&self) -> &EntityRef {
        &self.source
    }
}
impl IExternallyDefinedCharacterGlyph for ExternallyDefinedCharacterGlyph {}
impl ExternallyDefinedCharacterGlyph {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = ExternallyDefinedCharacterGlyph::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.item_id = parameter.into(),
                1usize => entity.source = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IExternallyDefinedClass: IClass + IExternallyDefinedItem {}
#[derive(Default, Debug)]
pub struct ExternallyDefinedClass {
    name: Label,
    description: Option<Text>,
    item_id: SourceItem,
    source: EntityRef,
}
impl IGroup for ExternallyDefinedClass {
    fn name(&self) -> &Label {
        &self.name
    }
    fn description(&self) -> &Option<Text> {
        &self.description
    }
}
impl IClass for ExternallyDefinedClass {}
impl IExternallyDefinedItem for ExternallyDefinedClass {
    fn item_id(&self) -> &SourceItem {
        &self.item_id
    }
    fn source(&self) -> &EntityRef {
        &self.source
    }
}
impl IExternallyDefinedClass for ExternallyDefinedClass {}
impl ExternallyDefinedClass {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = ExternallyDefinedClass::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => entity.item_id = parameter.into(),
                3usize => entity.source = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IExternallyDefinedCurveFont: IExternallyDefinedItem {}
#[derive(Default, Debug)]
pub struct ExternallyDefinedCurveFont {
    item_id: SourceItem,
    source: EntityRef,
}
impl IExternallyDefinedItem for ExternallyDefinedCurveFont {
    fn item_id(&self) -> &SourceItem {
        &self.item_id
    }
    fn source(&self) -> &EntityRef {
        &self.source
    }
}
impl IExternallyDefinedCurveFont for ExternallyDefinedCurveFont {}
impl ExternallyDefinedCurveFont {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = ExternallyDefinedCurveFont::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.item_id = parameter.into(),
                1usize => entity.source = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IExternallyDefinedDimensionDefinition: IDimensionalSize + IExternallyDefinedItem {}
#[derive(Default, Debug)]
pub struct ExternallyDefinedDimensionDefinition {
    applies_to: EntityRef,
    name: Label,
    item_id: SourceItem,
    source: EntityRef,
}
impl IDimensionalSize for ExternallyDefinedDimensionDefinition {
    fn applies_to(&self) -> &EntityRef {
        &self.applies_to
    }
    fn name(&self) -> &Label {
        &self.name
    }
}
impl IExternallyDefinedItem for ExternallyDefinedDimensionDefinition {
    fn item_id(&self) -> &SourceItem {
        &self.item_id
    }
    fn source(&self) -> &EntityRef {
        &self.source
    }
}
impl IExternallyDefinedDimensionDefinition for ExternallyDefinedDimensionDefinition {}
impl ExternallyDefinedDimensionDefinition {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = ExternallyDefinedDimensionDefinition::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.applies_to = parameter.into(),
                1usize => entity.name = parameter.into(),
                2usize => entity.item_id = parameter.into(),
                3usize => entity.source = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IExternallyDefinedFeatureDefinition: IFeatureDefinition + IExternallyDefinedItem {}
#[derive(Default, Debug)]
pub struct ExternallyDefinedFeatureDefinition {
    name: Label,
    description: Option<Text>,
    item_id: SourceItem,
    source: EntityRef,
}
impl ICharacterizedObject for ExternallyDefinedFeatureDefinition {
    fn name(&self) -> &Label {
        &self.name
    }
    fn description(&self) -> &Option<Text> {
        &self.description
    }
}
impl IFeatureDefinition for ExternallyDefinedFeatureDefinition {}
impl IExternallyDefinedItem for ExternallyDefinedFeatureDefinition {
    fn item_id(&self) -> &SourceItem {
        &self.item_id
    }
    fn source(&self) -> &EntityRef {
        &self.source
    }
}
impl IExternallyDefinedFeatureDefinition for ExternallyDefinedFeatureDefinition {}
impl ExternallyDefinedFeatureDefinition {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = ExternallyDefinedFeatureDefinition::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => entity.item_id = parameter.into(),
                3usize => entity.source = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IExternallyDefinedGeneralProperty: IGeneralProperty + IExternallyDefinedItem {}
#[derive(Default, Debug)]
pub struct ExternallyDefinedGeneralProperty {
    id: Identifier,
    name: Label,
    description: Option<Text>,
    item_id: SourceItem,
    source: EntityRef,
}
impl IGeneralProperty for ExternallyDefinedGeneralProperty {
    fn id(&self) -> &Identifier {
        &self.id
    }
    fn name(&self) -> &Label {
        &self.name
    }
    fn description(&self) -> &Option<Text> {
        &self.description
    }
}
impl IExternallyDefinedItem for ExternallyDefinedGeneralProperty {
    fn item_id(&self) -> &SourceItem {
        &self.item_id
    }
    fn source(&self) -> &EntityRef {
        &self.source
    }
}
impl IExternallyDefinedGeneralProperty for ExternallyDefinedGeneralProperty {}
impl ExternallyDefinedGeneralProperty {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = ExternallyDefinedGeneralProperty::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.id = parameter.into(),
                1usize => entity.name = parameter.into(),
                2usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => entity.item_id = parameter.into(),
                4usize => entity.source = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IExternallyDefinedHatchStyle: IExternallyDefinedItem + IGeometricRepresentationItem {}
#[derive(Default, Debug)]
pub struct ExternallyDefinedHatchStyle {
    item_id: SourceItem,
    source: EntityRef,
    name: Label,
}
impl IExternallyDefinedItem for ExternallyDefinedHatchStyle {
    fn item_id(&self) -> &SourceItem {
        &self.item_id
    }
    fn source(&self) -> &EntityRef {
        &self.source
    }
}
impl IRepresentationItem for ExternallyDefinedHatchStyle {
    fn name(&self) -> &Label {
        &self.name
    }
}
impl IGeometricRepresentationItem for ExternallyDefinedHatchStyle {}
impl IExternallyDefinedHatchStyle for ExternallyDefinedHatchStyle {}
impl ExternallyDefinedHatchStyle {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = ExternallyDefinedHatchStyle::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.item_id = parameter.into(),
                1usize => entity.source = parameter.into(),
                2usize => entity.name = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IExternallyDefinedItem {
    fn item_id(&self) -> &SourceItem;
    fn source(&self) -> &EntityRef;
}
#[derive(Default, Debug)]
pub struct ExternallyDefinedItem {
    item_id: SourceItem,
    source: EntityRef,
}
impl IExternallyDefinedItem for ExternallyDefinedItem {
    fn item_id(&self) -> &SourceItem {
        &self.item_id
    }
    fn source(&self) -> &EntityRef {
        &self.source
    }
}
impl ExternallyDefinedItem {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = ExternallyDefinedItem::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.item_id = parameter.into(),
                1usize => entity.source = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IExternallyDefinedItemRelationship {
    fn name(&self) -> &Label;
    fn description(&self) -> &Option<Text>;
    fn relating_item(&self) -> &EntityRef;
    fn related_item(&self) -> &EntityRef;
}
#[derive(Default, Debug)]
pub struct ExternallyDefinedItemRelationship {
    name: Label,
    description: Option<Text>,
    relating_item: EntityRef,
    related_item: EntityRef,
}
impl IExternallyDefinedItemRelationship for ExternallyDefinedItemRelationship {
    fn name(&self) -> &Label {
        &self.name
    }
    fn description(&self) -> &Option<Text> {
        &self.description
    }
    fn relating_item(&self) -> &EntityRef {
        &self.relating_item
    }
    fn related_item(&self) -> &EntityRef {
        &self.related_item
    }
}
impl ExternallyDefinedItemRelationship {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = ExternallyDefinedItemRelationship::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => entity.relating_item = parameter.into(),
                3usize => entity.related_item = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IExternallyDefinedStyle: IExternallyDefinedItem + IFoundedItem {}
#[derive(Default, Debug)]
pub struct ExternallyDefinedStyle {
    item_id: SourceItem,
    source: EntityRef,
}
impl IExternallyDefinedItem for ExternallyDefinedStyle {
    fn item_id(&self) -> &SourceItem {
        &self.item_id
    }
    fn source(&self) -> &EntityRef {
        &self.source
    }
}
impl IFoundedItem for ExternallyDefinedStyle {}
impl IExternallyDefinedStyle for ExternallyDefinedStyle {}
impl ExternallyDefinedStyle {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = ExternallyDefinedStyle::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.item_id = parameter.into(),
                1usize => entity.source = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IExternallyDefinedSymbol: IExternallyDefinedItem {}
#[derive(Default, Debug)]
pub struct ExternallyDefinedSymbol {
    item_id: SourceItem,
    source: EntityRef,
}
impl IExternallyDefinedItem for ExternallyDefinedSymbol {
    fn item_id(&self) -> &SourceItem {
        &self.item_id
    }
    fn source(&self) -> &EntityRef {
        &self.source
    }
}
impl IExternallyDefinedSymbol for ExternallyDefinedSymbol {}
impl ExternallyDefinedSymbol {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = ExternallyDefinedSymbol::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.item_id = parameter.into(),
                1usize => entity.source = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IExternallyDefinedTextFont: IExternallyDefinedItem {}
#[derive(Default, Debug)]
pub struct ExternallyDefinedTextFont {
    item_id: SourceItem,
    source: EntityRef,
}
impl IExternallyDefinedItem for ExternallyDefinedTextFont {
    fn item_id(&self) -> &SourceItem {
        &self.item_id
    }
    fn source(&self) -> &EntityRef {
        &self.source
    }
}
impl IExternallyDefinedTextFont for ExternallyDefinedTextFont {}
impl ExternallyDefinedTextFont {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = ExternallyDefinedTextFont::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.item_id = parameter.into(),
                1usize => entity.source = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IExternallyDefinedTileStyle: IExternallyDefinedItem + IGeometricRepresentationItem {}
#[derive(Default, Debug)]
pub struct ExternallyDefinedTileStyle {
    item_id: SourceItem,
    source: EntityRef,
    name: Label,
}
impl IExternallyDefinedItem for ExternallyDefinedTileStyle {
    fn item_id(&self) -> &SourceItem {
        &self.item_id
    }
    fn source(&self) -> &EntityRef {
        &self.source
    }
}
impl IRepresentationItem for ExternallyDefinedTileStyle {
    fn name(&self) -> &Label {
        &self.name
    }
}
impl IGeometricRepresentationItem for ExternallyDefinedTileStyle {}
impl IExternallyDefinedTileStyle for ExternallyDefinedTileStyle {}
impl ExternallyDefinedTileStyle {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = ExternallyDefinedTileStyle::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.item_id = parameter.into(),
                1usize => entity.source = parameter.into(),
                2usize => entity.name = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IExtrudedAreaSolid: ISweptAreaSolid {
    fn extruded_direction(&self) -> &EntityRef;
    fn depth(&self) -> &PositiveLengthMeasure;
}
#[derive(Default, Debug)]
pub struct ExtrudedAreaSolid {
    name: Label,
    swept_area: EntityRef,
    extruded_direction: EntityRef,
    depth: PositiveLengthMeasure,
}
impl IRepresentationItem for ExtrudedAreaSolid {
    fn name(&self) -> &Label {
        &self.name
    }
}
impl IGeometricRepresentationItem for ExtrudedAreaSolid {}
impl ISolidModel for ExtrudedAreaSolid {}
impl ISweptAreaSolid for ExtrudedAreaSolid {
    fn swept_area(&self) -> &EntityRef {
        &self.swept_area
    }
}
impl IExtrudedAreaSolid for ExtrudedAreaSolid {
    fn extruded_direction(&self) -> &EntityRef {
        &self.extruded_direction
    }
    fn depth(&self) -> &PositiveLengthMeasure {
        &self.depth
    }
}
impl ExtrudedAreaSolid {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = ExtrudedAreaSolid::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => entity.swept_area = parameter.into(),
                2usize => entity.extruded_direction = parameter.into(),
                3usize => entity.depth = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IExtrudedFaceSolid: ISweptFaceSolid {
    fn extruded_direction(&self) -> &EntityRef;
    fn depth(&self) -> &PositiveLengthMeasure;
}
#[derive(Default, Debug)]
pub struct ExtrudedFaceSolid {
    name: Label,
    swept_face: EntityRef,
    extruded_direction: EntityRef,
    depth: PositiveLengthMeasure,
}
impl IRepresentationItem for ExtrudedFaceSolid {
    fn name(&self) -> &Label {
        &self.name
    }
}
impl IGeometricRepresentationItem for ExtrudedFaceSolid {}
impl ISolidModel for ExtrudedFaceSolid {}
impl ISweptFaceSolid for ExtrudedFaceSolid {
    fn swept_face(&self) -> &EntityRef {
        &self.swept_face
    }
}
impl IExtrudedFaceSolid for ExtrudedFaceSolid {
    fn extruded_direction(&self) -> &EntityRef {
        &self.extruded_direction
    }
    fn depth(&self) -> &PositiveLengthMeasure {
        &self.depth
    }
}
impl ExtrudedFaceSolid {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = ExtrudedFaceSolid::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => entity.swept_face = parameter.into(),
                2usize => entity.extruded_direction = parameter.into(),
                3usize => entity.depth = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IFace: ITopologicalRepresentationItem {
    fn bounds(&self) -> &HashSet<EntityRef>;
}
#[derive(Default, Debug)]
pub struct Face {
    name: Label,
    bounds: HashSet<EntityRef>,
}
impl IRepresentationItem for Face {
    fn name(&self) -> &Label {
        &self.name
    }
}
impl ITopologicalRepresentationItem for Face {}
impl IFace for Face {
    fn bounds(&self) -> &HashSet<EntityRef> {
        &self.bounds
    }
}
impl Face {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = Face::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => entity.bounds = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IFaceBasedSurfaceModel: IGeometricRepresentationItem {
    fn fbsm_faces(&self) -> &HashSet<EntityRef>;
}
#[derive(Default, Debug)]
pub struct FaceBasedSurfaceModel {
    name: Label,
    fbsm_faces: HashSet<EntityRef>,
}
impl IRepresentationItem for FaceBasedSurfaceModel {
    fn name(&self) -> &Label {
        &self.name
    }
}
impl IGeometricRepresentationItem for FaceBasedSurfaceModel {}
impl IFaceBasedSurfaceModel for FaceBasedSurfaceModel {
    fn fbsm_faces(&self) -> &HashSet<EntityRef> {
        &self.fbsm_faces
    }
}
impl FaceBasedSurfaceModel {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = FaceBasedSurfaceModel::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => entity.fbsm_faces = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IFaceBound: ITopologicalRepresentationItem {
    fn bound(&self) -> &EntityRef;
    fn orientation(&self) -> bool;
}
#[derive(Default, Debug)]
pub struct FaceBound {
    name: Label,
    bound: EntityRef,
    orientation: bool,
}
impl IRepresentationItem for FaceBound {
    fn name(&self) -> &Label {
        &self.name
    }
}
impl ITopologicalRepresentationItem for FaceBound {}
impl IFaceBound for FaceBound {
    fn bound(&self) -> &EntityRef {
        &self.bound
    }
    fn orientation(&self) -> bool {
        self.orientation
    }
}
impl FaceBound {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = FaceBound::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => entity.bound = parameter.into(),
                2usize => entity.orientation = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IFaceOuterBound: IFaceBound {}
#[derive(Default, Debug)]
pub struct FaceOuterBound {
    name: Label,
    bound: EntityRef,
    orientation: bool,
}
impl IRepresentationItem for FaceOuterBound {
    fn name(&self) -> &Label {
        &self.name
    }
}
impl ITopologicalRepresentationItem for FaceOuterBound {}
impl IFaceBound for FaceOuterBound {
    fn bound(&self) -> &EntityRef {
        &self.bound
    }
    fn orientation(&self) -> bool {
        self.orientation
    }
}
impl IFaceOuterBound for FaceOuterBound {}
impl FaceOuterBound {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = FaceOuterBound::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => entity.bound = parameter.into(),
                2usize => entity.orientation = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IFaceShapeRepresentation: IShapeRepresentation {}
#[derive(Default, Debug)]
pub struct FaceShapeRepresentation {
    name: Label,
    items: HashSet<EntityRef>,
    context_of_items: EntityRef,
}
impl IRepresentation for FaceShapeRepresentation {
    fn name(&self) -> &Label {
        &self.name
    }
    fn items(&self) -> &HashSet<EntityRef> {
        &self.items
    }
    fn context_of_items(&self) -> &EntityRef {
        &self.context_of_items
    }
}
impl IShapeRepresentation for FaceShapeRepresentation {}
impl IFaceShapeRepresentation for FaceShapeRepresentation {}
impl FaceShapeRepresentation {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = FaceShapeRepresentation::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => entity.items = parameter.into(),
                2usize => entity.context_of_items = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IFaceSurface: IFace + IGeometricRepresentationItem {
    fn face_geometry(&self) -> &EntityRef;
    fn same_sense(&self) -> bool;
}
#[derive(Default, Debug)]
pub struct FaceSurface {
    name: Label,
    bounds: HashSet<EntityRef>,
    face_geometry: EntityRef,
    same_sense: bool,
}
impl IRepresentationItem for FaceSurface {
    fn name(&self) -> &Label {
        &self.name
    }
}
impl ITopologicalRepresentationItem for FaceSurface {}
impl IFace for FaceSurface {
    fn bounds(&self) -> &HashSet<EntityRef> {
        &self.bounds
    }
}
impl IFaceSurface for FaceSurface {
    fn face_geometry(&self) -> &EntityRef {
        &self.face_geometry
    }
    fn same_sense(&self) -> bool {
        self.same_sense
    }
}
impl IGeometricRepresentationItem for FaceSurface {}
impl FaceSurface {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = FaceSurface::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => entity.bounds = parameter.into(),
                2usize => entity.face_geometry = parameter.into(),
                3usize => entity.same_sense = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IFacetedBrep: IManifoldSolidBrep {}
#[derive(Default, Debug)]
pub struct FacetedBrep {
    name: Label,
    outer: EntityRef,
}
impl IRepresentationItem for FacetedBrep {
    fn name(&self) -> &Label {
        &self.name
    }
}
impl IGeometricRepresentationItem for FacetedBrep {}
impl ISolidModel for FacetedBrep {}
impl IManifoldSolidBrep for FacetedBrep {
    fn outer(&self) -> &EntityRef {
        &self.outer
    }
}
impl IFacetedBrep for FacetedBrep {}
impl FacetedBrep {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = FacetedBrep::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => entity.outer = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IFacetedBrepShapeRepresentation: IShapeRepresentation {}
#[derive(Default, Debug)]
pub struct FacetedBrepShapeRepresentation {
    name: Label,
    items: HashSet<EntityRef>,
    context_of_items: EntityRef,
}
impl IRepresentation for FacetedBrepShapeRepresentation {
    fn name(&self) -> &Label {
        &self.name
    }
    fn items(&self) -> &HashSet<EntityRef> {
        &self.items
    }
    fn context_of_items(&self) -> &EntityRef {
        &self.context_of_items
    }
}
impl IShapeRepresentation for FacetedBrepShapeRepresentation {}
impl IFacetedBrepShapeRepresentation for FacetedBrepShapeRepresentation {}
impl FacetedBrepShapeRepresentation {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = FacetedBrepShapeRepresentation::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => entity.items = parameter.into(),
                2usize => entity.context_of_items = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IFeatureComponentDefinition: ICharacterizedObject {}
#[derive(Default, Debug)]
pub struct FeatureComponentDefinition {
    name: Label,
    description: Option<Text>,
}
impl ICharacterizedObject for FeatureComponentDefinition {
    fn name(&self) -> &Label {
        &self.name
    }
    fn description(&self) -> &Option<Text> {
        &self.description
    }
}
impl IFeatureComponentDefinition for FeatureComponentDefinition {}
impl FeatureComponentDefinition {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = FeatureComponentDefinition::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
}
pub trait IFeatureComponentRelationship: IShapeAspectRelationship {}
#[derive(Default, Debug)]
pub struct FeatureComponentRelationship {
    name: Label,
    description: Option<Text>,
    relating_shape_aspect: EntityRef,
    related_shape_aspect: EntityRef,
}
impl IShapeAspectRelationship for FeatureComponentRelationship {
    fn name(&self) -> &Label {
        &self.name
    }
    fn description(&self) -> &Option<Text> {
        &self.description
    }
    fn relating_shape_aspect(&self) -> &EntityRef {
        &self.relating_shape_aspect
    }
    fn related_shape_aspect(&self) -> &EntityRef {
        &self.related_shape_aspect
    }
}
impl IFeatureComponentRelationship for FeatureComponentRelationship {}
impl FeatureComponentRelationship {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = FeatureComponentRelationship::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => entity.relating_shape_aspect = parameter.into(),
                3usize => entity.related_shape_aspect = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IFeatureDefinition: ICharacterizedObject {}
#[derive(Default, Debug)]
pub struct FeatureDefinition {
    name: Label,
    description: Option<Text>,
}
impl ICharacterizedObject for FeatureDefinition {
    fn name(&self) -> &Label {
        &self.name
    }
    fn description(&self) -> &Option<Text> {
        &self.description
    }
}
impl IFeatureDefinition for FeatureDefinition {}
impl FeatureDefinition {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = FeatureDefinition::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
}
pub trait IFeatureInPanel: IFeatureDefinition {}
#[derive(Default, Debug)]
pub struct FeatureInPanel {
    name: Label,
    description: Option<Text>,
}
impl ICharacterizedObject for FeatureInPanel {
    fn name(&self) -> &Label {
        &self.name
    }
    fn description(&self) -> &Option<Text> {
        &self.description
    }
}
impl IFeatureDefinition for FeatureInPanel {}
impl IFeatureInPanel for FeatureInPanel {}
impl FeatureInPanel {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = FeatureInPanel::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
}
pub trait IFeaturePattern: IReplicateFeature {}
#[derive(Default, Debug)]
pub struct FeaturePattern {
    name: Label,
    description: Option<Text>,
}
impl ICharacterizedObject for FeaturePattern {
    fn name(&self) -> &Label {
        &self.name
    }
    fn description(&self) -> &Option<Text> {
        &self.description
    }
}
impl IFeatureDefinition for FeaturePattern {}
impl IReplicateFeature for FeaturePattern {}
impl IFeaturePattern for FeaturePattern {}
impl FeaturePattern {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = FeaturePattern::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
}
pub trait IFeaturedShape: IProductDefinitionShape {}
#[derive(Default, Debug)]
pub struct FeaturedShape {
    name: Label,
    description: Option<Text>,
    definition: EntityRef,
}
impl IPropertyDefinition for FeaturedShape {
    fn name(&self) -> &Label {
        &self.name
    }
    fn description(&self) -> &Option<Text> {
        &self.description
    }
    fn definition(&self) -> &EntityRef {
        &self.definition
    }
}
impl IProductDefinitionShape for FeaturedShape {}
impl IFeaturedShape for FeaturedShape {}
impl FeaturedShape {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = FeaturedShape::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => entity.definition = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IFillAreaStyle: IFoundedItem {
    fn name(&self) -> &Label;
    fn fill_styles(&self) -> &HashSet<EntityRef>;
}
#[derive(Default, Debug)]
pub struct FillAreaStyle {
    name: Label,
    fill_styles: HashSet<EntityRef>,
}
impl IFoundedItem for FillAreaStyle {}
impl IFillAreaStyle for FillAreaStyle {
    fn name(&self) -> &Label {
        &self.name
    }
    fn fill_styles(&self) -> &HashSet<EntityRef> {
        &self.fill_styles
    }
}
impl FillAreaStyle {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = FillAreaStyle::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => entity.fill_styles = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IFillAreaStyleColour {
    fn name(&self) -> &Label;
    fn fill_colour(&self) -> &EntityRef;
}
#[derive(Default, Debug)]
pub struct FillAreaStyleColour {
    name: Label,
    fill_colour: EntityRef,
}
impl IFillAreaStyleColour for FillAreaStyleColour {
    fn name(&self) -> &Label {
        &self.name
    }
    fn fill_colour(&self) -> &EntityRef {
        &self.fill_colour
    }
}
impl FillAreaStyleColour {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = FillAreaStyleColour::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => entity.fill_colour = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IFillAreaStyleHatching: IGeometricRepresentationItem {
    fn hatch_line_appearance(&self) -> &EntityRef;
    fn start_of_next_hatch_line(&self) -> &EntityRef;
    fn point_of_reference_hatch_line(&self) -> &EntityRef;
    fn pattern_start(&self) -> &EntityRef;
    fn hatch_line_angle(&self) -> &PlaneAngleMeasure;
}
#[derive(Default, Debug)]
pub struct FillAreaStyleHatching {
    name: Label,
    hatch_line_appearance: EntityRef,
    start_of_next_hatch_line: EntityRef,
    point_of_reference_hatch_line: EntityRef,
    pattern_start: EntityRef,
    hatch_line_angle: PlaneAngleMeasure,
}
impl IRepresentationItem for FillAreaStyleHatching {
    fn name(&self) -> &Label {
        &self.name
    }
}
impl IGeometricRepresentationItem for FillAreaStyleHatching {}
impl IFillAreaStyleHatching for FillAreaStyleHatching {
    fn hatch_line_appearance(&self) -> &EntityRef {
        &self.hatch_line_appearance
    }
    fn start_of_next_hatch_line(&self) -> &EntityRef {
        &self.start_of_next_hatch_line
    }
    fn point_of_reference_hatch_line(&self) -> &EntityRef {
        &self.point_of_reference_hatch_line
    }
    fn pattern_start(&self) -> &EntityRef {
        &self.pattern_start
    }
    fn hatch_line_angle(&self) -> &PlaneAngleMeasure {
        &self.hatch_line_angle
    }
}
impl FillAreaStyleHatching {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = FillAreaStyleHatching::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => entity.hatch_line_appearance = parameter.into(),
                2usize => entity.start_of_next_hatch_line = parameter.into(),
                3usize => entity.point_of_reference_hatch_line = parameter.into(),
                4usize => entity.pattern_start = parameter.into(),
                5usize => entity.hatch_line_angle = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IFillAreaStyleTileSymbolWithStyle: IGeometricRepresentationItem {
    fn symbol(&self) -> &EntityRef;
}
#[derive(Default, Debug)]
pub struct FillAreaStyleTileSymbolWithStyle {
    name: Label,
    symbol: EntityRef,
}
impl IRepresentationItem for FillAreaStyleTileSymbolWithStyle {
    fn name(&self) -> &Label {
        &self.name
    }
}
impl IGeometricRepresentationItem for FillAreaStyleTileSymbolWithStyle {}
impl IFillAreaStyleTileSymbolWithStyle for FillAreaStyleTileSymbolWithStyle {
    fn symbol(&self) -> &EntityRef {
        &self.symbol
    }
}
impl FillAreaStyleTileSymbolWithStyle {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = FillAreaStyleTileSymbolWithStyle::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => entity.symbol = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IFillAreaStyleTiles: IGeometricRepresentationItem {
    fn tiling_pattern(&self) -> &EntityRef;
    fn tiles(&self) -> &HashSet<EntityRef>;
    fn tiling_scale(&self) -> &PositiveRatioMeasure;
}
#[derive(Default, Debug)]
pub struct FillAreaStyleTiles {
    name: Label,
    tiling_pattern: EntityRef,
    tiles: HashSet<EntityRef>,
    tiling_scale: PositiveRatioMeasure,
}
impl IRepresentationItem for FillAreaStyleTiles {
    fn name(&self) -> &Label {
        &self.name
    }
}
impl IGeometricRepresentationItem for FillAreaStyleTiles {}
impl IFillAreaStyleTiles for FillAreaStyleTiles {
    fn tiling_pattern(&self) -> &EntityRef {
        &self.tiling_pattern
    }
    fn tiles(&self) -> &HashSet<EntityRef> {
        &self.tiles
    }
    fn tiling_scale(&self) -> &PositiveRatioMeasure {
        &self.tiling_scale
    }
}
impl FillAreaStyleTiles {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = FillAreaStyleTiles::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => entity.tiling_pattern = parameter.into(),
                2usize => entity.tiles = parameter.into(),
                3usize => entity.tiling_scale = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IFillet: ITransitionFeature {}
#[derive(Default, Debug)]
pub struct Fillet {
    name: Label,
    description: Option<Text>,
    of_shape: EntityRef,
    product_definitional: Option<bool>,
}
impl IShapeAspect for Fillet {
    fn name(&self) -> &Label {
        &self.name
    }
    fn description(&self) -> &Option<Text> {
        &self.description
    }
    fn of_shape(&self) -> &EntityRef {
        &self.of_shape
    }
    fn product_definitional(&self) -> Option<bool> {
        self.product_definitional
    }
}
impl ITransitionFeature for Fillet {}
impl IFillet for Fillet {}
impl Fillet {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = Fillet::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => entity.of_shape = parameter.into(),
                3usize => entity.product_definitional = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IFlatnessTolerance: IGeometricTolerance {}
#[derive(Default, Debug)]
pub struct FlatnessTolerance {
    name: Label,
    description: Text,
    magnitude: EntityRef,
    toleranced_shape_aspect: EntityRef,
}
impl IGeometricTolerance for FlatnessTolerance {
    fn name(&self) -> &Label {
        &self.name
    }
    fn description(&self) -> &Text {
        &self.description
    }
    fn magnitude(&self) -> &EntityRef {
        &self.magnitude
    }
    fn toleranced_shape_aspect(&self) -> &EntityRef {
        &self.toleranced_shape_aspect
    }
}
impl IFlatnessTolerance for FlatnessTolerance {}
impl FlatnessTolerance {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = FlatnessTolerance::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => entity.description = parameter.into(),
                2usize => entity.magnitude = parameter.into(),
                3usize => entity.toleranced_shape_aspect = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IFormatFunction: IStringExpression + IBinaryGenericExpression {}
#[derive(Default, Debug)]
pub struct FormatFunction {
    operands: Vec<EntityRef>,
}
impl IGenericExpression for FormatFunction {}
impl IExpression for FormatFunction {}
impl IStringExpression for FormatFunction {}
impl IFormatFunction for FormatFunction {}
impl IBinaryGenericExpression for FormatFunction {
    fn operands(&self) -> &Vec<EntityRef> {
        &self.operands
    }
}
impl FormatFunction {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = FormatFunction::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.operands = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IFoundedItem {}
#[derive(Default, Debug)]
pub struct FoundedItem {}
impl IFoundedItem for FoundedItem {}
impl FoundedItem {
    pub fn form_parameters(_parameters: Vec<Parameter>) -> Self {
        FoundedItem::default()
    }
}
pub trait IFoundedKinematicPath: IRepresentation {
    fn items(&self) -> &HashSet<EntityRef>;
    fn context_of_items(&self) -> &EntityRef;
}
#[derive(Default, Debug)]
pub struct FoundedKinematicPath {
    name: Label,
    items: HashSet<EntityRef>,
    context_of_items: EntityRef,
}
impl IRepresentation for FoundedKinematicPath {
    fn name(&self) -> &Label {
        &self.name
    }
    fn items(&self) -> &HashSet<EntityRef> {
        &self.items
    }
    fn context_of_items(&self) -> &EntityRef {
        &self.context_of_items
    }
}
impl IFoundedKinematicPath for FoundedKinematicPath {
    fn items(&self) -> &HashSet<EntityRef> {
        &self.items
    }
    fn context_of_items(&self) -> &EntityRef {
        &self.context_of_items
    }
}
impl FoundedKinematicPath {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = FoundedKinematicPath::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => entity.items = parameter.into(),
                2usize => entity.context_of_items = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IFullyConstrainedPair: IKinematicPair {}
#[derive(Default, Debug)]
pub struct FullyConstrainedPair {
    name: Label,
    description: Option<Text>,
    transform_item_1: EntityRef,
    transform_item_2: EntityRef,
    joint: EntityRef,
}
impl IItemDefinedTransformation for FullyConstrainedPair {
    fn name(&self) -> &Label {
        &self.name
    }
    fn description(&self) -> &Option<Text> {
        &self.description
    }
    fn transform_item_1(&self) -> &EntityRef {
        &self.transform_item_1
    }
    fn transform_item_2(&self) -> &EntityRef {
        &self.transform_item_2
    }
}
impl IKinematicPair for FullyConstrainedPair {
    fn joint(&self) -> &EntityRef {
        &self.joint
    }
}
impl IFullyConstrainedPair for FullyConstrainedPair {}
impl FullyConstrainedPair {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = FullyConstrainedPair::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => entity.transform_item_1 = parameter.into(),
                3usize => entity.transform_item_2 = parameter.into(),
                4usize => entity.joint = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IFunctionallyDefinedTransformation {
    fn name(&self) -> &Label;
    fn description(&self) -> &Option<Text>;
}
#[derive(Default, Debug)]
pub struct FunctionallyDefinedTransformation {
    name: Label,
    description: Option<Text>,
}
impl IFunctionallyDefinedTransformation for FunctionallyDefinedTransformation {
    fn name(&self) -> &Label {
        &self.name
    }
    fn description(&self) -> &Option<Text> {
        &self.description
    }
}
impl FunctionallyDefinedTransformation {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = FunctionallyDefinedTransformation::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
}
pub trait IGearPair: IKinematicPair {
    fn radius_first_link(&self) -> &LengthMeasure;
    fn radius_second_link(&self) -> &LengthMeasure;
    fn bevel(&self) -> &PlaneAngleMeasure;
    fn helical_angle(&self) -> &PlaneAngleMeasure;
    fn gear_ratio(&self) -> Real;
}
#[derive(Default, Debug)]
pub struct GearPair {
    name: Label,
    description: Option<Text>,
    transform_item_1: EntityRef,
    transform_item_2: EntityRef,
    joint: EntityRef,
    radius_first_link: LengthMeasure,
    radius_second_link: LengthMeasure,
    bevel: PlaneAngleMeasure,
    helical_angle: PlaneAngleMeasure,
    gear_ratio: Real,
}
impl IItemDefinedTransformation for GearPair {
    fn name(&self) -> &Label {
        &self.name
    }
    fn description(&self) -> &Option<Text> {
        &self.description
    }
    fn transform_item_1(&self) -> &EntityRef {
        &self.transform_item_1
    }
    fn transform_item_2(&self) -> &EntityRef {
        &self.transform_item_2
    }
}
impl IKinematicPair for GearPair {
    fn joint(&self) -> &EntityRef {
        &self.joint
    }
}
impl IGearPair for GearPair {
    fn radius_first_link(&self) -> &LengthMeasure {
        &self.radius_first_link
    }
    fn radius_second_link(&self) -> &LengthMeasure {
        &self.radius_second_link
    }
    fn bevel(&self) -> &PlaneAngleMeasure {
        &self.bevel
    }
    fn helical_angle(&self) -> &PlaneAngleMeasure {
        &self.helical_angle
    }
    fn gear_ratio(&self) -> Real {
        self.gear_ratio
    }
}
impl GearPair {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = GearPair::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => entity.transform_item_1 = parameter.into(),
                3usize => entity.transform_item_2 = parameter.into(),
                4usize => entity.joint = parameter.into(),
                5usize => entity.radius_first_link = parameter.into(),
                6usize => entity.radius_second_link = parameter.into(),
                7usize => entity.bevel = parameter.into(),
                8usize => entity.helical_angle = parameter.into(),
                9usize => entity.gear_ratio = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IGearPairRange: ISimplePairRange {
    fn applies_to_pair(&self) -> &EntityRef;
    fn lower_limit_actual_rotation_1(&self) -> &RotationalRangeMeasure;
    fn upper_limit_actual_rotation_1(&self) -> &RotationalRangeMeasure;
}
#[derive(Default, Debug)]
pub struct GearPairRange {
    applies_to_pair: EntityRef,
    lower_limit_actual_rotation_1: RotationalRangeMeasure,
    upper_limit_actual_rotation_1: RotationalRangeMeasure,
}
impl ISimplePairRange for GearPairRange {
    fn applies_to_pair(&self) -> &EntityRef {
        &self.applies_to_pair
    }
}
impl IGearPairRange for GearPairRange {
    fn applies_to_pair(&self) -> &EntityRef {
        &self.applies_to_pair
    }
    fn lower_limit_actual_rotation_1(&self) -> &RotationalRangeMeasure {
        &self.lower_limit_actual_rotation_1
    }
    fn upper_limit_actual_rotation_1(&self) -> &RotationalRangeMeasure {
        &self.upper_limit_actual_rotation_1
    }
}
impl GearPairRange {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = GearPairRange::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.applies_to_pair = parameter.into(),
                1usize => entity.lower_limit_actual_rotation_1 = parameter.into(),
                2usize => entity.upper_limit_actual_rotation_1 = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IGearPairValue: IPairValue {
    fn applies_to_pair(&self) -> &EntityRef;
    fn actual_rotation_1(&self) -> &PlaneAngleMeasure;
}
#[derive(Default, Debug)]
pub struct GearPairValue {
    applies_to_pair: EntityRef,
    actual_rotation_1: PlaneAngleMeasure,
}
impl IPairValue for GearPairValue {
    fn applies_to_pair(&self) -> &EntityRef {
        &self.applies_to_pair
    }
}
impl IGearPairValue for GearPairValue {
    fn applies_to_pair(&self) -> &EntityRef {
        &self.applies_to_pair
    }
    fn actual_rotation_1(&self) -> &PlaneAngleMeasure {
        &self.actual_rotation_1
    }
}
impl GearPairValue {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = GearPairValue::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.applies_to_pair = parameter.into(),
                1usize => entity.actual_rotation_1 = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IGeneralFeature: IFeatureDefinition {}
#[derive(Default, Debug)]
pub struct GeneralFeature {
    name: Label,
    description: Option<Text>,
}
impl ICharacterizedObject for GeneralFeature {
    fn name(&self) -> &Label {
        &self.name
    }
    fn description(&self) -> &Option<Text> {
        &self.description
    }
}
impl IFeatureDefinition for GeneralFeature {}
impl IGeneralFeature for GeneralFeature {}
impl GeneralFeature {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = GeneralFeature::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
}
pub trait IGeneralMaterialProperty: IGeneralProperty {}
#[derive(Default, Debug)]
pub struct GeneralMaterialProperty {
    id: Identifier,
    name: Label,
    description: Option<Text>,
}
impl IGeneralProperty for GeneralMaterialProperty {
    fn id(&self) -> &Identifier {
        &self.id
    }
    fn name(&self) -> &Label {
        &self.name
    }
    fn description(&self) -> &Option<Text> {
        &self.description
    }
}
impl IGeneralMaterialProperty for GeneralMaterialProperty {}
impl GeneralMaterialProperty {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = GeneralMaterialProperty::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.id = parameter.into(),
                1usize => entity.name = parameter.into(),
                2usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
}
pub trait IGeneralProperty {
    fn id(&self) -> &Identifier;
    fn name(&self) -> &Label;
    fn description(&self) -> &Option<Text>;
}
#[derive(Default, Debug)]
pub struct GeneralProperty {
    id: Identifier,
    name: Label,
    description: Option<Text>,
}
impl IGeneralProperty for GeneralProperty {
    fn id(&self) -> &Identifier {
        &self.id
    }
    fn name(&self) -> &Label {
        &self.name
    }
    fn description(&self) -> &Option<Text> {
        &self.description
    }
}
impl GeneralProperty {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = GeneralProperty::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.id = parameter.into(),
                1usize => entity.name = parameter.into(),
                2usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
}
pub trait IGeneralPropertyAssociation {
    fn name(&self) -> &Label;
    fn description(&self) -> &Option<Text>;
    fn base_definition(&self) -> &EntityRef;
    fn derived_definition(&self) -> &EntityRef;
}
#[derive(Default, Debug)]
pub struct GeneralPropertyAssociation {
    name: Label,
    description: Option<Text>,
    base_definition: EntityRef,
    derived_definition: EntityRef,
}
impl IGeneralPropertyAssociation for GeneralPropertyAssociation {
    fn name(&self) -> &Label {
        &self.name
    }
    fn description(&self) -> &Option<Text> {
        &self.description
    }
    fn base_definition(&self) -> &EntityRef {
        &self.base_definition
    }
    fn derived_definition(&self) -> &EntityRef {
        &self.derived_definition
    }
}
impl GeneralPropertyAssociation {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = GeneralPropertyAssociation::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => entity.base_definition = parameter.into(),
                3usize => entity.derived_definition = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IGeneralPropertyRelationship {
    fn name(&self) -> &Label;
    fn description(&self) -> &Option<Text>;
    fn relating_property(&self) -> &EntityRef;
    fn related_property(&self) -> &EntityRef;
}
#[derive(Default, Debug)]
pub struct GeneralPropertyRelationship {
    name: Label,
    description: Option<Text>,
    relating_property: EntityRef,
    related_property: EntityRef,
}
impl IGeneralPropertyRelationship for GeneralPropertyRelationship {
    fn name(&self) -> &Label {
        &self.name
    }
    fn description(&self) -> &Option<Text> {
        &self.description
    }
    fn relating_property(&self) -> &EntityRef {
        &self.relating_property
    }
    fn related_property(&self) -> &EntityRef {
        &self.related_property
    }
}
impl GeneralPropertyRelationship {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = GeneralPropertyRelationship::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => entity.relating_property = parameter.into(),
                3usize => entity.related_property = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IGenericCharacterGlyphSymbol: ISymbolRepresentation {}
pub trait IGenericExpression {}
pub trait IGenericLiteral: ISimpleGenericExpression {}
pub trait IGenericVariable: ISimpleGenericExpression {}
pub trait IGeometricAlignment: IDerivedShapeAspect {}
#[derive(Default, Debug)]
pub struct GeometricAlignment {
    name: Label,
    description: Option<Text>,
    of_shape: EntityRef,
    product_definitional: Option<bool>,
}
impl IShapeAspect for GeometricAlignment {
    fn name(&self) -> &Label {
        &self.name
    }
    fn description(&self) -> &Option<Text> {
        &self.description
    }
    fn of_shape(&self) -> &EntityRef {
        &self.of_shape
    }
    fn product_definitional(&self) -> Option<bool> {
        self.product_definitional
    }
}
impl IDerivedShapeAspect for GeometricAlignment {}
impl IGeometricAlignment for GeometricAlignment {}
impl GeometricAlignment {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = GeometricAlignment::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => entity.of_shape = parameter.into(),
                3usize => entity.product_definitional = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IGeometricCurveSet: IGeometricSet {}
#[derive(Default, Debug)]
pub struct GeometricCurveSet {
    name: Label,
    elements: HashSet<EntityRef>,
}
impl IRepresentationItem for GeometricCurveSet {
    fn name(&self) -> &Label {
        &self.name
    }
}
impl IGeometricRepresentationItem for GeometricCurveSet {}
impl IGeometricSet for GeometricCurveSet {
    fn elements(&self) -> &HashSet<EntityRef> {
        &self.elements
    }
}
impl IGeometricCurveSet for GeometricCurveSet {}
impl GeometricCurveSet {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = GeometricCurveSet::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => entity.elements = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IGeometricIntersection: IDerivedShapeAspect {}
#[derive(Default, Debug)]
pub struct GeometricIntersection {
    name: Label,
    description: Option<Text>,
    of_shape: EntityRef,
    product_definitional: Option<bool>,
}
impl IShapeAspect for GeometricIntersection {
    fn name(&self) -> &Label {
        &self.name
    }
    fn description(&self) -> &Option<Text> {
        &self.description
    }
    fn of_shape(&self) -> &EntityRef {
        &self.of_shape
    }
    fn product_definitional(&self) -> Option<bool> {
        self.product_definitional
    }
}
impl IDerivedShapeAspect for GeometricIntersection {}
impl IGeometricIntersection for GeometricIntersection {}
impl GeometricIntersection {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = GeometricIntersection::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => entity.of_shape = parameter.into(),
                3usize => entity.product_definitional = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IGeometricItemSpecificUsage: IItemIdentifiedRepresentationUsage {
    fn definition(&self) -> &EntityRef;
    fn used_representation(&self) -> &EntityRef;
    fn identified_item(&self) -> &EntityRef;
}
#[derive(Default, Debug)]
pub struct GeometricItemSpecificUsage {
    name: Label,
    description: Option<Text>,
    definition: EntityRef,
    used_representation: EntityRef,
    identified_item: EntityRef,
}
impl IItemIdentifiedRepresentationUsage for GeometricItemSpecificUsage {
    fn name(&self) -> &Label {
        &self.name
    }
    fn description(&self) -> &Option<Text> {
        &self.description
    }
    fn definition(&self) -> &EntityRef {
        &self.definition
    }
    fn used_representation(&self) -> &EntityRef {
        &self.used_representation
    }
    fn identified_item(&self) -> &EntityRef {
        &self.identified_item
    }
}
impl IGeometricItemSpecificUsage for GeometricItemSpecificUsage {
    fn definition(&self) -> &EntityRef {
        &self.definition
    }
    fn used_representation(&self) -> &EntityRef {
        &self.used_representation
    }
    fn identified_item(&self) -> &EntityRef {
        &self.identified_item
    }
}
impl GeometricItemSpecificUsage {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = GeometricItemSpecificUsage::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => entity.definition = parameter.into(),
                3usize => entity.used_representation = parameter.into(),
                4usize => entity.identified_item = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IGeometricRepresentationContext: IRepresentationContext {
    fn coordinate_space_dimension(&self) -> &DimensionCount;
}
#[derive(Default, Debug)]
pub struct GeometricRepresentationContext {
    context_identifier: Identifier,
    context_type: Text,
    coordinate_space_dimension: DimensionCount,
}
impl IRepresentationContext for GeometricRepresentationContext {
    fn context_identifier(&self) -> &Identifier {
        &self.context_identifier
    }
    fn context_type(&self) -> &Text {
        &self.context_type
    }
}
impl IGeometricRepresentationContext for GeometricRepresentationContext {
    fn coordinate_space_dimension(&self) -> &DimensionCount {
        &self.coordinate_space_dimension
    }
}
impl GeometricRepresentationContext {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = GeometricRepresentationContext::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.context_identifier = parameter.into(),
                1usize => entity.context_type = parameter.into(),
                2usize => entity.coordinate_space_dimension = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IGeometricRepresentationItem: IRepresentationItem {}
#[derive(Default, Debug)]
pub struct GeometricRepresentationItem {
    name: Label,
}
impl IRepresentationItem for GeometricRepresentationItem {
    fn name(&self) -> &Label {
        &self.name
    }
}
impl IGeometricRepresentationItem for GeometricRepresentationItem {}
impl GeometricRepresentationItem {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = GeometricRepresentationItem::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IGeometricSet: IGeometricRepresentationItem {
    fn elements(&self) -> &HashSet<EntityRef>;
}
#[derive(Default, Debug)]
pub struct GeometricSet {
    name: Label,
    elements: HashSet<EntityRef>,
}
impl IRepresentationItem for GeometricSet {
    fn name(&self) -> &Label {
        &self.name
    }
}
impl IGeometricRepresentationItem for GeometricSet {}
impl IGeometricSet for GeometricSet {
    fn elements(&self) -> &HashSet<EntityRef> {
        &self.elements
    }
}
impl GeometricSet {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = GeometricSet::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => entity.elements = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IGeometricTolerance {
    fn name(&self) -> &Label;
    fn description(&self) -> &Text;
    fn magnitude(&self) -> &EntityRef;
    fn toleranced_shape_aspect(&self) -> &EntityRef;
}
#[derive(Default, Debug)]
pub struct GeometricTolerance {
    name: Label,
    description: Text,
    magnitude: EntityRef,
    toleranced_shape_aspect: EntityRef,
}
impl IGeometricTolerance for GeometricTolerance {
    fn name(&self) -> &Label {
        &self.name
    }
    fn description(&self) -> &Text {
        &self.description
    }
    fn magnitude(&self) -> &EntityRef {
        &self.magnitude
    }
    fn toleranced_shape_aspect(&self) -> &EntityRef {
        &self.toleranced_shape_aspect
    }
}
impl GeometricTolerance {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = GeometricTolerance::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => entity.description = parameter.into(),
                2usize => entity.magnitude = parameter.into(),
                3usize => entity.toleranced_shape_aspect = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IGeometricToleranceRelationship {
    fn name(&self) -> &Label;
    fn description(&self) -> &Text;
    fn relating_geometric_tolerance(&self) -> &EntityRef;
    fn related_geometric_tolerance(&self) -> &EntityRef;
}
#[derive(Default, Debug)]
pub struct GeometricToleranceRelationship {
    name: Label,
    description: Text,
    relating_geometric_tolerance: EntityRef,
    related_geometric_tolerance: EntityRef,
}
impl IGeometricToleranceRelationship for GeometricToleranceRelationship {
    fn name(&self) -> &Label {
        &self.name
    }
    fn description(&self) -> &Text {
        &self.description
    }
    fn relating_geometric_tolerance(&self) -> &EntityRef {
        &self.relating_geometric_tolerance
    }
    fn related_geometric_tolerance(&self) -> &EntityRef {
        &self.related_geometric_tolerance
    }
}
impl GeometricToleranceRelationship {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = GeometricToleranceRelationship::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => entity.description = parameter.into(),
                2usize => entity.relating_geometric_tolerance = parameter.into(),
                3usize => entity.related_geometric_tolerance = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IGeometricToleranceWithDatumReference: IGeometricTolerance {
    fn datum_system(&self) -> &HashSet<EntityRef>;
}
#[derive(Default, Debug)]
pub struct GeometricToleranceWithDatumReference {
    name: Label,
    description: Text,
    magnitude: EntityRef,
    toleranced_shape_aspect: EntityRef,
    datum_system: HashSet<EntityRef>,
}
impl IGeometricTolerance for GeometricToleranceWithDatumReference {
    fn name(&self) -> &Label {
        &self.name
    }
    fn description(&self) -> &Text {
        &self.description
    }
    fn magnitude(&self) -> &EntityRef {
        &self.magnitude
    }
    fn toleranced_shape_aspect(&self) -> &EntityRef {
        &self.toleranced_shape_aspect
    }
}
impl IGeometricToleranceWithDatumReference for GeometricToleranceWithDatumReference {
    fn datum_system(&self) -> &HashSet<EntityRef> {
        &self.datum_system
    }
}
impl GeometricToleranceWithDatumReference {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = GeometricToleranceWithDatumReference::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => entity.description = parameter.into(),
                2usize => entity.magnitude = parameter.into(),
                3usize => entity.toleranced_shape_aspect = parameter.into(),
                4usize => entity.datum_system = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IGeometricToleranceWithDefinedUnit: IGeometricTolerance {
    fn unit_size(&self) -> &EntityRef;
}
#[derive(Default, Debug)]
pub struct GeometricToleranceWithDefinedUnit {
    name: Label,
    description: Text,
    magnitude: EntityRef,
    toleranced_shape_aspect: EntityRef,
    unit_size: EntityRef,
}
impl IGeometricTolerance for GeometricToleranceWithDefinedUnit {
    fn name(&self) -> &Label {
        &self.name
    }
    fn description(&self) -> &Text {
        &self.description
    }
    fn magnitude(&self) -> &EntityRef {
        &self.magnitude
    }
    fn toleranced_shape_aspect(&self) -> &EntityRef {
        &self.toleranced_shape_aspect
    }
}
impl IGeometricToleranceWithDefinedUnit for GeometricToleranceWithDefinedUnit {
    fn unit_size(&self) -> &EntityRef {
        &self.unit_size
    }
}
impl GeometricToleranceWithDefinedUnit {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = GeometricToleranceWithDefinedUnit::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => entity.description = parameter.into(),
                2usize => entity.magnitude = parameter.into(),
                3usize => entity.toleranced_shape_aspect = parameter.into(),
                4usize => entity.unit_size = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IGeometricalToleranceCallout: IDraughtingCallout {}
#[derive(Default, Debug)]
pub struct GeometricalToleranceCallout {
    name: Label,
    contents: HashSet<EntityRef>,
}
impl IRepresentationItem for GeometricalToleranceCallout {
    fn name(&self) -> &Label {
        &self.name
    }
}
impl IGeometricRepresentationItem for GeometricalToleranceCallout {}
impl IDraughtingCallout for GeometricalToleranceCallout {
    fn contents(&self) -> &HashSet<EntityRef> {
        &self.contents
    }
}
impl IGeometricalToleranceCallout for GeometricalToleranceCallout {}
impl GeometricalToleranceCallout {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = GeometricalToleranceCallout::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => entity.contents = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IGeometricallyBounded2dWireframeRepresentation: IShapeRepresentation {}
#[derive(Default, Debug)]
pub struct GeometricallyBounded2dWireframeRepresentation {
    name: Label,
    items: HashSet<EntityRef>,
    context_of_items: EntityRef,
}
impl IRepresentation for GeometricallyBounded2dWireframeRepresentation {
    fn name(&self) -> &Label {
        &self.name
    }
    fn items(&self) -> &HashSet<EntityRef> {
        &self.items
    }
    fn context_of_items(&self) -> &EntityRef {
        &self.context_of_items
    }
}
impl IShapeRepresentation for GeometricallyBounded2dWireframeRepresentation {}
impl IGeometricallyBounded2dWireframeRepresentation for GeometricallyBounded2dWireframeRepresentation {}
impl GeometricallyBounded2dWireframeRepresentation {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = GeometricallyBounded2dWireframeRepresentation::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => entity.items = parameter.into(),
                2usize => entity.context_of_items = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IGeometricallyBoundedSurfaceShapeRepresentation: IShapeRepresentation {}
#[derive(Default, Debug)]
pub struct GeometricallyBoundedSurfaceShapeRepresentation {
    name: Label,
    items: HashSet<EntityRef>,
    context_of_items: EntityRef,
}
impl IRepresentation for GeometricallyBoundedSurfaceShapeRepresentation {
    fn name(&self) -> &Label {
        &self.name
    }
    fn items(&self) -> &HashSet<EntityRef> {
        &self.items
    }
    fn context_of_items(&self) -> &EntityRef {
        &self.context_of_items
    }
}
impl IShapeRepresentation for GeometricallyBoundedSurfaceShapeRepresentation {}
impl IGeometricallyBoundedSurfaceShapeRepresentation for GeometricallyBoundedSurfaceShapeRepresentation {}
impl GeometricallyBoundedSurfaceShapeRepresentation {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = GeometricallyBoundedSurfaceShapeRepresentation::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => entity.items = parameter.into(),
                2usize => entity.context_of_items = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IGeometricallyBoundedWireframeShapeRepresentation: IShapeRepresentation {}
#[derive(Default, Debug)]
pub struct GeometricallyBoundedWireframeShapeRepresentation {
    name: Label,
    items: HashSet<EntityRef>,
    context_of_items: EntityRef,
}
impl IRepresentation for GeometricallyBoundedWireframeShapeRepresentation {
    fn name(&self) -> &Label {
        &self.name
    }
    fn items(&self) -> &HashSet<EntityRef> {
        &self.items
    }
    fn context_of_items(&self) -> &EntityRef {
        &self.context_of_items
    }
}
impl IShapeRepresentation for GeometricallyBoundedWireframeShapeRepresentation {}
impl IGeometricallyBoundedWireframeShapeRepresentation for GeometricallyBoundedWireframeShapeRepresentation {}
impl GeometricallyBoundedWireframeShapeRepresentation {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = GeometricallyBoundedWireframeShapeRepresentation::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => entity.items = parameter.into(),
                2usize => entity.context_of_items = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IGlobalUncertaintyAssignedContext: IRepresentationContext {
    fn uncertainty(&self) -> &HashSet<EntityRef>;
}
#[derive(Default, Debug)]
pub struct GlobalUncertaintyAssignedContext {
    context_identifier: Identifier,
    context_type: Text,
    uncertainty: HashSet<EntityRef>,
}
impl IRepresentationContext for GlobalUncertaintyAssignedContext {
    fn context_identifier(&self) -> &Identifier {
        &self.context_identifier
    }
    fn context_type(&self) -> &Text {
        &self.context_type
    }
}
impl IGlobalUncertaintyAssignedContext for GlobalUncertaintyAssignedContext {
    fn uncertainty(&self) -> &HashSet<EntityRef> {
        &self.uncertainty
    }
}
impl GlobalUncertaintyAssignedContext {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = GlobalUncertaintyAssignedContext::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.context_identifier = parameter.into(),
                1usize => entity.context_type = parameter.into(),
                2usize => entity.uncertainty = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IGlobalUnitAssignedContext: IRepresentationContext {
    fn units(&self) -> &HashSet<EntityRef>;
}
#[derive(Default, Debug)]
pub struct GlobalUnitAssignedContext {
    context_identifier: Identifier,
    context_type: Text,
    units: HashSet<EntityRef>,
}
impl IRepresentationContext for GlobalUnitAssignedContext {
    fn context_identifier(&self) -> &Identifier {
        &self.context_identifier
    }
    fn context_type(&self) -> &Text {
        &self.context_type
    }
}
impl IGlobalUnitAssignedContext for GlobalUnitAssignedContext {
    fn units(&self) -> &HashSet<EntityRef> {
        &self.units
    }
}
impl GlobalUnitAssignedContext {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = GlobalUnitAssignedContext::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.context_identifier = parameter.into(),
                1usize => entity.context_type = parameter.into(),
                2usize => entity.units = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IGroup {
    fn name(&self) -> &Label;
    fn description(&self) -> &Option<Text>;
}
#[derive(Default, Debug)]
pub struct Group {
    name: Label,
    description: Option<Text>,
}
impl IGroup for Group {
    fn name(&self) -> &Label {
        &self.name
    }
    fn description(&self) -> &Option<Text> {
        &self.description
    }
}
impl Group {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = Group::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
}
pub trait IGroupAssignment {
    fn assigned_group(&self) -> &EntityRef;
}
pub trait IGroupRelationship {
    fn name(&self) -> &Label;
    fn description(&self) -> &Option<Text>;
    fn relating_group(&self) -> &EntityRef;
    fn related_group(&self) -> &EntityRef;
}
#[derive(Default, Debug)]
pub struct GroupRelationship {
    name: Label,
    description: Option<Text>,
    relating_group: EntityRef,
    related_group: EntityRef,
}
impl IGroupRelationship for GroupRelationship {
    fn name(&self) -> &Label {
        &self.name
    }
    fn description(&self) -> &Option<Text> {
        &self.description
    }
    fn relating_group(&self) -> &EntityRef {
        &self.relating_group
    }
    fn related_group(&self) -> &EntityRef {
        &self.related_group
    }
}
impl GroupRelationship {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = GroupRelationship::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => entity.relating_group = parameter.into(),
                3usize => entity.related_group = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IHalfSpaceSolid: IGeometricRepresentationItem {
    fn base_surface(&self) -> &EntityRef;
    fn agreement_flag(&self) -> bool;
}
#[derive(Default, Debug)]
pub struct HalfSpaceSolid {
    name: Label,
    base_surface: EntityRef,
    agreement_flag: bool,
}
impl IRepresentationItem for HalfSpaceSolid {
    fn name(&self) -> &Label {
        &self.name
    }
}
impl IGeometricRepresentationItem for HalfSpaceSolid {}
impl IHalfSpaceSolid for HalfSpaceSolid {
    fn base_surface(&self) -> &EntityRef {
        &self.base_surface
    }
    fn agreement_flag(&self) -> bool {
        self.agreement_flag
    }
}
impl HalfSpaceSolid {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = HalfSpaceSolid::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => entity.base_surface = parameter.into(),
                2usize => entity.agreement_flag = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IHardnessRepresentation: IRepresentation {}
#[derive(Default, Debug)]
pub struct HardnessRepresentation {
    name: Label,
    items: HashSet<EntityRef>,
    context_of_items: EntityRef,
}
impl IRepresentation for HardnessRepresentation {
    fn name(&self) -> &Label {
        &self.name
    }
    fn items(&self) -> &HashSet<EntityRef> {
        &self.items
    }
    fn context_of_items(&self) -> &EntityRef {
        &self.context_of_items
    }
}
impl IHardnessRepresentation for HardnessRepresentation {}
impl HardnessRepresentation {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = HardnessRepresentation::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => entity.items = parameter.into(),
                2usize => entity.context_of_items = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IHiddenElementOverRidingStyledItem: IContextDependentOverRidingStyledItem {}
#[derive(Default, Debug)]
pub struct HiddenElementOverRidingStyledItem {
    name: Label,
    styles: HashSet<EntityRef>,
    item: EntityRef,
    over_ridden_style: EntityRef,
    style_context: Vec<EntityRef>,
}
impl IRepresentationItem for HiddenElementOverRidingStyledItem {
    fn name(&self) -> &Label {
        &self.name
    }
}
impl IStyledItem for HiddenElementOverRidingStyledItem {
    fn styles(&self) -> &HashSet<EntityRef> {
        &self.styles
    }
    fn item(&self) -> &EntityRef {
        &self.item
    }
}
impl IOverRidingStyledItem for HiddenElementOverRidingStyledItem {
    fn over_ridden_style(&self) -> &EntityRef {
        &self.over_ridden_style
    }
}
impl IContextDependentOverRidingStyledItem for HiddenElementOverRidingStyledItem {
    fn style_context(&self) -> &Vec<EntityRef> {
        &self.style_context
    }
}
impl IHiddenElementOverRidingStyledItem for HiddenElementOverRidingStyledItem {}
impl HiddenElementOverRidingStyledItem {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = HiddenElementOverRidingStyledItem::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => entity.styles = parameter.into(),
                2usize => entity.item = parameter.into(),
                3usize => entity.over_ridden_style = parameter.into(),
                4usize => entity.style_context = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IHoleBottom: IShapeAspect {}
#[derive(Default, Debug)]
pub struct HoleBottom {
    name: Label,
    description: Option<Text>,
    of_shape: EntityRef,
    product_definitional: Option<bool>,
}
impl IShapeAspect for HoleBottom {
    fn name(&self) -> &Label {
        &self.name
    }
    fn description(&self) -> &Option<Text> {
        &self.description
    }
    fn of_shape(&self) -> &EntityRef {
        &self.of_shape
    }
    fn product_definitional(&self) -> Option<bool> {
        self.product_definitional
    }
}
impl IHoleBottom for HoleBottom {}
impl HoleBottom {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = HoleBottom::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => entity.of_shape = parameter.into(),
                3usize => entity.product_definitional = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IHoleInPanel: IFeatureDefinition {}
#[derive(Default, Debug)]
pub struct HoleInPanel {
    name: Label,
    description: Option<Text>,
}
impl ICharacterizedObject for HoleInPanel {
    fn name(&self) -> &Label {
        &self.name
    }
    fn description(&self) -> &Option<Text> {
        &self.description
    }
}
impl IFeatureDefinition for HoleInPanel {}
impl IHoleInPanel for HoleInPanel {}
impl HoleInPanel {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = HoleInPanel::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
}
pub trait IHomokineticPair: IUniversalPair {}
#[derive(Default, Debug)]
pub struct HomokineticPair {
    name: Label,
    description: Option<Text>,
    transform_item_1: EntityRef,
    transform_item_2: EntityRef,
    joint: EntityRef,
    input_skew_angle: Option<PlaneAngleMeasure>,
}
impl IItemDefinedTransformation for HomokineticPair {
    fn name(&self) -> &Label {
        &self.name
    }
    fn description(&self) -> &Option<Text> {
        &self.description
    }
    fn transform_item_1(&self) -> &EntityRef {
        &self.transform_item_1
    }
    fn transform_item_2(&self) -> &EntityRef {
        &self.transform_item_2
    }
}
impl IKinematicPair for HomokineticPair {
    fn joint(&self) -> &EntityRef {
        &self.joint
    }
}
impl IUniversalPair for HomokineticPair {
    fn input_skew_angle(&self) -> &Option<PlaneAngleMeasure> {
        &self.input_skew_angle
    }
}
impl IHomokineticPair for HomokineticPair {}
impl HomokineticPair {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = HomokineticPair::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => entity.transform_item_1 = parameter.into(),
                3usize => entity.transform_item_2 = parameter.into(),
                4usize => entity.joint = parameter.into(),
                5usize => {
                    entity.input_skew_angle = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
}
pub trait IHyperbola: IConic {
    fn semi_axis(&self) -> &PositiveLengthMeasure;
    fn semi_imag_axis(&self) -> &PositiveLengthMeasure;
}
#[derive(Default, Debug)]
pub struct Hyperbola {
    name: Label,
    position: EntityRef,
    semi_axis: PositiveLengthMeasure,
    semi_imag_axis: PositiveLengthMeasure,
}
impl IRepresentationItem for Hyperbola {
    fn name(&self) -> &Label {
        &self.name
    }
}
impl IGeometricRepresentationItem for Hyperbola {}
impl ICurve for Hyperbola {}
impl IConic for Hyperbola {
    fn position(&self) -> &EntityRef {
        &self.position
    }
}
impl IHyperbola for Hyperbola {
    fn semi_axis(&self) -> &PositiveLengthMeasure {
        &self.semi_axis
    }
    fn semi_imag_axis(&self) -> &PositiveLengthMeasure {
        &self.semi_imag_axis
    }
}
impl Hyperbola {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = Hyperbola::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => entity.position = parameter.into(),
                2usize => entity.semi_axis = parameter.into(),
                3usize => entity.semi_imag_axis = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IIdAttribute {
    fn attribute_value(&self) -> &Identifier;
    fn identified_item(&self) -> &EntityRef;
}
#[derive(Default, Debug)]
pub struct IdAttribute {
    attribute_value: Identifier,
    identified_item: EntityRef,
}
impl IIdAttribute for IdAttribute {
    fn attribute_value(&self) -> &Identifier {
        &self.attribute_value
    }
    fn identified_item(&self) -> &EntityRef {
        &self.identified_item
    }
}
impl IdAttribute {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IdAttribute::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.attribute_value = parameter.into(),
                1usize => entity.identified_item = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IIdentificationAssignment {
    fn assigned_id(&self) -> &Identifier;
    fn role(&self) -> &EntityRef;
}
pub trait IIdentificationRole {
    fn name(&self) -> &Label;
    fn description(&self) -> &Option<Text>;
}
#[derive(Default, Debug)]
pub struct IdentificationRole {
    name: Label,
    description: Option<Text>,
}
impl IIdentificationRole for IdentificationRole {
    fn name(&self) -> &Label {
        &self.name
    }
    fn description(&self) -> &Option<Text> {
        &self.description
    }
}
impl IdentificationRole {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IdentificationRole::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
}
pub trait IInclusionProductConceptFeature: IConditionalConceptFeature {}
#[derive(Default, Debug)]
pub struct InclusionProductConceptFeature {
    id: Identifier,
    name: Label,
    description: Option<Text>,
    condition: EntityRef,
}
impl IProductConceptFeature for InclusionProductConceptFeature {
    fn id(&self) -> &Identifier {
        &self.id
    }
    fn name(&self) -> &Label {
        &self.name
    }
    fn description(&self) -> &Option<Text> {
        &self.description
    }
}
impl IConditionalConceptFeature for InclusionProductConceptFeature {
    fn condition(&self) -> &EntityRef {
        &self.condition
    }
}
impl IInclusionProductConceptFeature for InclusionProductConceptFeature {}
impl InclusionProductConceptFeature {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = InclusionProductConceptFeature::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.id = parameter.into(),
                1usize => entity.name = parameter.into(),
                2usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => entity.condition = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IIndexExpression: IStringExpression + IBinaryGenericExpression {}
#[derive(Default, Debug)]
pub struct IndexExpression {
    operands: Vec<EntityRef>,
}
impl IGenericExpression for IndexExpression {}
impl IExpression for IndexExpression {}
impl IStringExpression for IndexExpression {}
impl IIndexExpression for IndexExpression {}
impl IBinaryGenericExpression for IndexExpression {
    fn operands(&self) -> &Vec<EntityRef> {
        &self.operands
    }
}
impl IndexExpression {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IndexExpression::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.operands = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IInitialState {
    fn applies_to_mechanism(&self) -> &EntityRef;
    fn pair_values(&self) -> &HashSet<EntityRef>;
}
#[derive(Default, Debug)]
pub struct InitialState {
    applies_to_mechanism: EntityRef,
    pair_values: HashSet<EntityRef>,
}
impl IInitialState for InitialState {
    fn applies_to_mechanism(&self) -> &EntityRef {
        &self.applies_to_mechanism
    }
    fn pair_values(&self) -> &HashSet<EntityRef> {
        &self.pair_values
    }
}
impl InitialState {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = InitialState::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.applies_to_mechanism = parameter.into(),
                1usize => entity.pair_values = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IInstancedFeature: IShapeAspect + IFeatureDefinition {}
#[derive(Default, Debug)]
pub struct InstancedFeature {
    name: Label,
    description: Option<Text>,
    of_shape: EntityRef,
    product_definitional: Option<bool>,
}
impl IShapeAspect for InstancedFeature {
    fn name(&self) -> &Label {
        &self.name
    }
    fn description(&self) -> &Option<Text> {
        &self.description
    }
    fn of_shape(&self) -> &EntityRef {
        &self.of_shape
    }
    fn product_definitional(&self) -> Option<bool> {
        self.product_definitional
    }
}
impl ICharacterizedObject for InstancedFeature {
    fn name(&self) -> &Label {
        &self.name
    }
    fn description(&self) -> &Option<Text> {
        &self.description
    }
}
impl IFeatureDefinition for InstancedFeature {}
impl IInstancedFeature for InstancedFeature {}
impl InstancedFeature {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = InstancedFeature::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => entity.of_shape = parameter.into(),
                3usize => entity.product_definitional = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IIntLiteral: ILiteralNumber {
    fn the_value(&self) -> i64;
}
#[derive(Default, Debug)]
pub struct IntLiteral {
    the_value: i64,
}
impl IGenericExpression for IntLiteral {}
impl IExpression for IntLiteral {}
impl INumericExpression for IntLiteral {}
impl ISimpleNumericExpression for IntLiteral {}
impl ISimpleGenericExpression for IntLiteral {}
impl ILiteralNumber for IntLiteral {
    fn the_value(&self) -> Real {
        Real(self.the_value as f64)
    }
}
impl IGenericLiteral for IntLiteral {}
impl IIntLiteral for IntLiteral {
    fn the_value(&self) -> i64 {
        self.the_value
    }
}
impl IntLiteral {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IntLiteral::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.the_value = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IIntNumericVariable: INumericVariable {}
#[derive(Default, Debug)]
pub struct IntNumericVariable {}
impl IGenericExpression for IntNumericVariable {}
impl IExpression for IntNumericVariable {}
impl INumericExpression for IntNumericVariable {}
impl ISimpleNumericExpression for IntNumericVariable {}
impl ISimpleGenericExpression for IntNumericVariable {}
impl INumericVariable for IntNumericVariable {}
impl IVariable for IntNumericVariable {}
impl IGenericVariable for IntNumericVariable {}
impl IIntNumericVariable for IntNumericVariable {}
impl IntNumericVariable {
    pub fn form_parameters(_parameters: Vec<Parameter>) -> Self {
        IntNumericVariable::default()
    }
}
pub trait IIntValueFunction: IValueFunction {}
#[derive(Default, Debug)]
pub struct IntValueFunction {
    operand: EntityRef,
}
impl IGenericExpression for IntValueFunction {}
impl IExpression for IntValueFunction {}
impl INumericExpression for IntValueFunction {}
impl IValueFunction for IntValueFunction {
    fn operand(&self) -> &EntityRef {
        &self.operand
    }
}
impl IUnaryGenericExpression for IntValueFunction {
    fn operand(&self) -> &EntityRef {
        &self.operand
    }
}
impl IIntValueFunction for IntValueFunction {}
impl IntValueFunction {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IntValueFunction::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.operand = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IIntegerDefinedFunction: INumericDefinedFunction {}
pub trait IInterpolatedConfigurationSequence {
    fn interpolation(&self) -> &HashSet<EntityRef>;
}
#[derive(Default, Debug)]
pub struct InterpolatedConfigurationSequence {
    interpolation: HashSet<EntityRef>,
}
impl IInterpolatedConfigurationSequence for InterpolatedConfigurationSequence {
    fn interpolation(&self) -> &HashSet<EntityRef> {
        &self.interpolation
    }
}
impl InterpolatedConfigurationSequence {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = InterpolatedConfigurationSequence::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.interpolation = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IIntersectionCurve: ISurfaceCurve {}
#[derive(Default, Debug)]
pub struct IntersectionCurve {
    name: Label,
    curve_3d: EntityRef,
    associated_geometry: Vec<EntityRef>,
    master_representation: PreferredSurfaceCurveRepresentation,
}
impl IRepresentationItem for IntersectionCurve {
    fn name(&self) -> &Label {
        &self.name
    }
}
impl IGeometricRepresentationItem for IntersectionCurve {}
impl ICurve for IntersectionCurve {}
impl ISurfaceCurve for IntersectionCurve {
    fn curve_3d(&self) -> &EntityRef {
        &self.curve_3d
    }
    fn associated_geometry(&self) -> &Vec<EntityRef> {
        &self.associated_geometry
    }
    fn master_representation(&self) -> &PreferredSurfaceCurveRepresentation {
        &self.master_representation
    }
}
impl IIntersectionCurve for IntersectionCurve {}
impl IntersectionCurve {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IntersectionCurve::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => entity.curve_3d = parameter.into(),
                2usize => entity.associated_geometry = parameter.into(),
                3usize => entity.master_representation = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IIntervalExpression: IBooleanExpression + IMultipleArityGenericExpression {}
#[derive(Default, Debug)]
pub struct IntervalExpression {
    operands: Vec<EntityRef>,
}
impl IGenericExpression for IntervalExpression {}
impl IExpression for IntervalExpression {}
impl IBooleanExpression for IntervalExpression {}
impl IIntervalExpression for IntervalExpression {}
impl IMultipleArityGenericExpression for IntervalExpression {
    fn operands(&self) -> &Vec<EntityRef> {
        &self.operands
    }
}
impl IntervalExpression {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IntervalExpression::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.operands = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IInvisibility {
    fn invisible_items(&self) -> &HashSet<EntityRef>;
}
#[derive(Default, Debug)]
pub struct Invisibility {
    invisible_items: HashSet<EntityRef>,
}
impl IInvisibility for Invisibility {
    fn invisible_items(&self) -> &HashSet<EntityRef> {
        &self.invisible_items
    }
}
impl Invisibility {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = Invisibility::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.invisible_items = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IItemDefinedTransformation {
    fn name(&self) -> &Label;
    fn description(&self) -> &Option<Text>;
    fn transform_item_1(&self) -> &EntityRef;
    fn transform_item_2(&self) -> &EntityRef;
}
#[derive(Default, Debug)]
pub struct ItemDefinedTransformation {
    name: Label,
    description: Option<Text>,
    transform_item_1: EntityRef,
    transform_item_2: EntityRef,
}
impl IItemDefinedTransformation for ItemDefinedTransformation {
    fn name(&self) -> &Label {
        &self.name
    }
    fn description(&self) -> &Option<Text> {
        &self.description
    }
    fn transform_item_1(&self) -> &EntityRef {
        &self.transform_item_1
    }
    fn transform_item_2(&self) -> &EntityRef {
        &self.transform_item_2
    }
}
impl ItemDefinedTransformation {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = ItemDefinedTransformation::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => entity.transform_item_1 = parameter.into(),
                3usize => entity.transform_item_2 = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IItemIdentifiedRepresentationUsage {
    fn name(&self) -> &Label;
    fn description(&self) -> &Option<Text>;
    fn definition(&self) -> &EntityRef;
    fn used_representation(&self) -> &EntityRef;
    fn identified_item(&self) -> &EntityRef;
}
#[derive(Default, Debug)]
pub struct ItemIdentifiedRepresentationUsage {
    name: Label,
    description: Option<Text>,
    definition: EntityRef,
    used_representation: EntityRef,
    identified_item: EntityRef,
}
impl IItemIdentifiedRepresentationUsage for ItemIdentifiedRepresentationUsage {
    fn name(&self) -> &Label {
        &self.name
    }
    fn description(&self) -> &Option<Text> {
        &self.description
    }
    fn definition(&self) -> &EntityRef {
        &self.definition
    }
    fn used_representation(&self) -> &EntityRef {
        &self.used_representation
    }
    fn identified_item(&self) -> &EntityRef {
        &self.identified_item
    }
}
impl ItemIdentifiedRepresentationUsage {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = ItemIdentifiedRepresentationUsage::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => entity.definition = parameter.into(),
                3usize => entity.used_representation = parameter.into(),
                4usize => entity.identified_item = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IJoggle: IFeatureDefinition {}
#[derive(Default, Debug)]
pub struct Joggle {
    name: Label,
    description: Option<Text>,
}
impl ICharacterizedObject for Joggle {
    fn name(&self) -> &Label {
        &self.name
    }
    fn description(&self) -> &Option<Text> {
        &self.description
    }
}
impl IFeatureDefinition for Joggle {}
impl IJoggle for Joggle {}
impl Joggle {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = Joggle::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
}
pub trait IJoggleTermination: IShapeAspect {}
#[derive(Default, Debug)]
pub struct JoggleTermination {
    name: Label,
    description: Option<Text>,
    of_shape: EntityRef,
    product_definitional: Option<bool>,
}
impl IShapeAspect for JoggleTermination {
    fn name(&self) -> &Label {
        &self.name
    }
    fn description(&self) -> &Option<Text> {
        &self.description
    }
    fn of_shape(&self) -> &EntityRef {
        &self.of_shape
    }
    fn product_definitional(&self) -> Option<bool> {
        self.product_definitional
    }
}
impl IJoggleTermination for JoggleTermination {}
impl JoggleTermination {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = JoggleTermination::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => entity.of_shape = parameter.into(),
                3usize => entity.product_definitional = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IKinematicAnalysisConsistency {
    fn control(&self) -> &EntityRef;
    fn result(&self) -> &EntityRef;
}
#[derive(Default, Debug)]
pub struct KinematicAnalysisConsistency {
    control: EntityRef,
    result: EntityRef,
}
impl IKinematicAnalysisConsistency for KinematicAnalysisConsistency {
    fn control(&self) -> &EntityRef {
        &self.control
    }
    fn result(&self) -> &EntityRef {
        &self.result
    }
}
impl KinematicAnalysisConsistency {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = KinematicAnalysisConsistency::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.control = parameter.into(),
                1usize => entity.result = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IKinematicAnalysisResult {
    fn analysed_mechanism(&self) -> &EntityRef;
    fn contained_kinematic_results(&self) -> &HashSet<EntityRef>;
}
#[derive(Default, Debug)]
pub struct KinematicAnalysisResult {
    analysed_mechanism: EntityRef,
    contained_kinematic_results: HashSet<EntityRef>,
}
impl IKinematicAnalysisResult for KinematicAnalysisResult {
    fn analysed_mechanism(&self) -> &EntityRef {
        &self.analysed_mechanism
    }
    fn contained_kinematic_results(&self) -> &HashSet<EntityRef> {
        &self.contained_kinematic_results
    }
}
impl KinematicAnalysisResult {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = KinematicAnalysisResult::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.analysed_mechanism = parameter.into(),
                1usize => entity.contained_kinematic_results = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IKinematicControl {
    fn controlled_mechanism(&self) -> &EntityRef;
    fn contained_kinematic_programs(&self) -> &HashSet<EntityRef>;
}
#[derive(Default, Debug)]
pub struct KinematicControl {
    controlled_mechanism: EntityRef,
    contained_kinematic_programs: HashSet<EntityRef>,
}
impl IKinematicControl for KinematicControl {
    fn controlled_mechanism(&self) -> &EntityRef {
        &self.controlled_mechanism
    }
    fn contained_kinematic_programs(&self) -> &HashSet<EntityRef> {
        &self.contained_kinematic_programs
    }
}
impl KinematicControl {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = KinematicControl::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.controlled_mechanism = parameter.into(),
                1usize => entity.contained_kinematic_programs = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IKinematicFrameBackgroundRepresentation: IRepresentation {
    fn items(&self) -> &HashSet<EntityRef>;
    fn context_of_items(&self) -> &EntityRef;
}
#[derive(Default, Debug)]
pub struct KinematicFrameBackgroundRepresentation {
    name: Label,
    items: HashSet<EntityRef>,
    context_of_items: EntityRef,
}
impl IRepresentation for KinematicFrameBackgroundRepresentation {
    fn name(&self) -> &Label {
        &self.name
    }
    fn items(&self) -> &HashSet<EntityRef> {
        &self.items
    }
    fn context_of_items(&self) -> &EntityRef {
        &self.context_of_items
    }
}
impl IKinematicFrameBackgroundRepresentation for KinematicFrameBackgroundRepresentation {
    fn items(&self) -> &HashSet<EntityRef> {
        &self.items
    }
    fn context_of_items(&self) -> &EntityRef {
        &self.context_of_items
    }
}
impl KinematicFrameBackgroundRepresentation {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = KinematicFrameBackgroundRepresentation::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => entity.items = parameter.into(),
                2usize => entity.context_of_items = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IKinematicFrameBackgroundRepresentationAssociation: IRepresentationRelationshipWithTransformation {
    fn transformation_operator(&self) -> &EntityRef;
}
#[derive(Default, Debug)]
pub struct KinematicFrameBackgroundRepresentationAssociation {
    name: Label,
    description: Option<Text>,
    rep_1: EntityRef,
    rep_2: EntityRef,
    transformation_operator: EntityRef,
}
impl IRepresentationRelationship for KinematicFrameBackgroundRepresentationAssociation {
    fn name(&self) -> &Label {
        &self.name
    }
    fn description(&self) -> &Option<Text> {
        &self.description
    }
    fn rep_1(&self) -> &EntityRef {
        &self.rep_1
    }
    fn rep_2(&self) -> &EntityRef {
        &self.rep_2
    }
}
impl IRepresentationRelationshipWithTransformation for KinematicFrameBackgroundRepresentationAssociation {
    fn transformation_operator(&self) -> &EntityRef {
        &self.transformation_operator
    }
}
impl IKinematicFrameBackgroundRepresentationAssociation for KinematicFrameBackgroundRepresentationAssociation {
    fn transformation_operator(&self) -> &EntityRef {
        &self.transformation_operator
    }
}
impl KinematicFrameBackgroundRepresentationAssociation {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = KinematicFrameBackgroundRepresentationAssociation::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => entity.rep_1 = parameter.into(),
                3usize => entity.rep_2 = parameter.into(),
                4usize => entity.transformation_operator = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IKinematicFrameBasedTransformation:
    IGeometricRepresentationItem + IFunctionallyDefinedTransformation
{
    fn transformator(&self) -> &EntityRef;
}
#[derive(Default, Debug)]
pub struct KinematicFrameBasedTransformation {
    name: Label,
    description: Option<Text>,
    transformator: EntityRef,
}
impl IRepresentationItem for KinematicFrameBasedTransformation {
    fn name(&self) -> &Label {
        &self.name
    }
}
impl IGeometricRepresentationItem for KinematicFrameBasedTransformation {}
impl IFunctionallyDefinedTransformation for KinematicFrameBasedTransformation {
    fn name(&self) -> &Label {
        &self.name
    }
    fn description(&self) -> &Option<Text> {
        &self.description
    }
}
impl IKinematicFrameBasedTransformation for KinematicFrameBasedTransformation {
    fn transformator(&self) -> &EntityRef {
        &self.transformator
    }
}
impl KinematicFrameBasedTransformation {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = KinematicFrameBasedTransformation::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => entity.transformator = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IKinematicGroundRepresentation: IRepresentation {}
#[derive(Default, Debug)]
pub struct KinematicGroundRepresentation {
    name: Label,
    items: HashSet<EntityRef>,
    context_of_items: EntityRef,
}
impl IRepresentation for KinematicGroundRepresentation {
    fn name(&self) -> &Label {
        &self.name
    }
    fn items(&self) -> &HashSet<EntityRef> {
        &self.items
    }
    fn context_of_items(&self) -> &EntityRef {
        &self.context_of_items
    }
}
impl IKinematicGroundRepresentation for KinematicGroundRepresentation {}
impl KinematicGroundRepresentation {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = KinematicGroundRepresentation::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => entity.items = parameter.into(),
                2usize => entity.context_of_items = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IKinematicJoint {
    fn first_link(&self) -> &EntityRef;
    fn second_link(&self) -> &EntityRef;
}
#[derive(Default, Debug)]
pub struct KinematicJoint {
    first_link: EntityRef,
    second_link: EntityRef,
}
impl IKinematicJoint for KinematicJoint {
    fn first_link(&self) -> &EntityRef {
        &self.first_link
    }
    fn second_link(&self) -> &EntityRef {
        &self.second_link
    }
}
impl KinematicJoint {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = KinematicJoint::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.first_link = parameter.into(),
                1usize => entity.second_link = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IKinematicLink {}
#[derive(Default, Debug)]
pub struct KinematicLink {}
impl IKinematicLink for KinematicLink {}
impl KinematicLink {
    pub fn form_parameters(_parameters: Vec<Parameter>) -> Self {
        KinematicLink::default()
    }
}
pub trait IKinematicLinkRepresentation: IRepresentation {
    fn context_of_items(&self) -> &EntityRef;
}
#[derive(Default, Debug)]
pub struct KinematicLinkRepresentation {
    name: Label,
    items: HashSet<EntityRef>,
    context_of_items: EntityRef,
}
impl IRepresentation for KinematicLinkRepresentation {
    fn name(&self) -> &Label {
        &self.name
    }
    fn items(&self) -> &HashSet<EntityRef> {
        &self.items
    }
    fn context_of_items(&self) -> &EntityRef {
        &self.context_of_items
    }
}
impl IKinematicLinkRepresentation for KinematicLinkRepresentation {
    fn context_of_items(&self) -> &EntityRef {
        &self.context_of_items
    }
}
impl KinematicLinkRepresentation {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = KinematicLinkRepresentation::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => entity.items = parameter.into(),
                2usize => entity.context_of_items = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IKinematicLinkRepresentationAssociation: IRepresentationRelationship {
    fn rep_1(&self) -> &EntityRef;
}
#[derive(Default, Debug)]
pub struct KinematicLinkRepresentationAssociation {
    name: Label,
    description: Option<Text>,
    rep_2: EntityRef,
    rep_1: EntityRef,
}
impl IRepresentationRelationship for KinematicLinkRepresentationAssociation {
    fn name(&self) -> &Label {
        &self.name
    }
    fn description(&self) -> &Option<Text> {
        &self.description
    }
    fn rep_1(&self) -> &EntityRef {
        &self.rep_1
    }
    fn rep_2(&self) -> &EntityRef {
        &self.rep_2
    }
}
impl IKinematicLinkRepresentationAssociation for KinematicLinkRepresentationAssociation {
    fn rep_1(&self) -> &EntityRef {
        &self.rep_1
    }
}
impl KinematicLinkRepresentationAssociation {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = KinematicLinkRepresentationAssociation::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => entity.rep_2 = parameter.into(),
                3usize => entity.rep_1 = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IKinematicLinkRepresentationRelation {
    fn topological_aspects(&self) -> &EntityRef;
    fn geometric_aspects(&self) -> &EntityRef;
}
#[derive(Default, Debug)]
pub struct KinematicLinkRepresentationRelation {
    topological_aspects: EntityRef,
    geometric_aspects: EntityRef,
}
impl IKinematicLinkRepresentationRelation for KinematicLinkRepresentationRelation {
    fn topological_aspects(&self) -> &EntityRef {
        &self.topological_aspects
    }
    fn geometric_aspects(&self) -> &EntityRef {
        &self.geometric_aspects
    }
}
impl KinematicLinkRepresentationRelation {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = KinematicLinkRepresentationRelation::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.topological_aspects = parameter.into(),
                1usize => entity.geometric_aspects = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IKinematicPair: IItemDefinedTransformation {
    fn joint(&self) -> &EntityRef;
}
#[derive(Default, Debug)]
pub struct KinematicPair {
    name: Label,
    description: Option<Text>,
    transform_item_1: EntityRef,
    transform_item_2: EntityRef,
    joint: EntityRef,
}
impl IItemDefinedTransformation for KinematicPair {
    fn name(&self) -> &Label {
        &self.name
    }
    fn description(&self) -> &Option<Text> {
        &self.description
    }
    fn transform_item_1(&self) -> &EntityRef {
        &self.transform_item_1
    }
    fn transform_item_2(&self) -> &EntityRef {
        &self.transform_item_2
    }
}
impl IKinematicPair for KinematicPair {
    fn joint(&self) -> &EntityRef {
        &self.joint
    }
}
impl KinematicPair {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = KinematicPair::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => entity.transform_item_1 = parameter.into(),
                3usize => entity.transform_item_2 = parameter.into(),
                4usize => entity.joint = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IKinematicPath: IRepresentationItem {}
#[derive(Default, Debug)]
pub struct KinematicPath {
    name: Label,
}
impl IRepresentationItem for KinematicPath {
    fn name(&self) -> &Label {
        &self.name
    }
}
impl IKinematicPath for KinematicPath {}
impl KinematicPath {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = KinematicPath::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IKinematicPropertyDefinition: IPropertyDefinition {
    fn ground_definition(&self) -> &EntityRef;
}
#[derive(Default, Debug)]
pub struct KinematicPropertyDefinition {
    name: Label,
    description: Option<Text>,
    definition: EntityRef,
    ground_definition: EntityRef,
}
impl IPropertyDefinition for KinematicPropertyDefinition {
    fn name(&self) -> &Label {
        &self.name
    }
    fn description(&self) -> &Option<Text> {
        &self.description
    }
    fn definition(&self) -> &EntityRef {
        &self.definition
    }
}
impl IKinematicPropertyDefinition for KinematicPropertyDefinition {
    fn ground_definition(&self) -> &EntityRef {
        &self.ground_definition
    }
}
impl KinematicPropertyDefinition {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = KinematicPropertyDefinition::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => entity.definition = parameter.into(),
                3usize => entity.ground_definition = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IKinematicPropertyRepresentationRelation: IPropertyDefinitionRepresentation {}
#[derive(Default, Debug)]
pub struct KinematicPropertyRepresentationRelation {
    definition: EntityRef,
    used_representation: EntityRef,
}
impl IPropertyDefinitionRepresentation for KinematicPropertyRepresentationRelation {
    fn definition(&self) -> &EntityRef {
        &self.definition
    }
    fn used_representation(&self) -> &EntityRef {
        &self.used_representation
    }
}
impl IKinematicPropertyRepresentationRelation for KinematicPropertyRepresentationRelation {}
impl KinematicPropertyRepresentationRelation {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = KinematicPropertyRepresentationRelation::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.definition = parameter.into(),
                1usize => entity.used_representation = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IKinematicStructure {
    fn joints(&self) -> &HashSet<EntityRef>;
}
#[derive(Default, Debug)]
pub struct KinematicStructure {
    joints: HashSet<EntityRef>,
}
impl IKinematicStructure for KinematicStructure {
    fn joints(&self) -> &HashSet<EntityRef> {
        &self.joints
    }
}
impl KinematicStructure {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = KinematicStructure::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.joints = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IKnownSource: IExternalSource + IPreDefinedItem {}
#[derive(Default, Debug)]
pub struct KnownSource {
    source_id: SourceItem,
    name: Label,
}
impl IExternalSource for KnownSource {
    fn source_id(&self) -> &SourceItem {
        &self.source_id
    }
}
impl IPreDefinedItem for KnownSource {
    fn name(&self) -> &Label {
        &self.name
    }
}
impl IKnownSource for KnownSource {}
impl KnownSource {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = KnownSource::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.source_id = parameter.into(),
                1usize => entity.name = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait ILanguage: IGroup {}
#[derive(Default, Debug)]
pub struct Language {
    name: Label,
    description: Option<Text>,
}
impl IGroup for Language {
    fn name(&self) -> &Label {
        &self.name
    }
    fn description(&self) -> &Option<Text> {
        &self.description
    }
}
impl ILanguage for Language {}
impl Language {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = Language::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
}
pub trait ILanguageAssignment: IClassificationAssignment {
    fn items(&self) -> &HashSet<EntityRef>;
}
#[derive(Default, Debug)]
pub struct LanguageAssignment {
    assigned_class: EntityRef,
    role: EntityRef,
    items: HashSet<EntityRef>,
}
impl IClassificationAssignment for LanguageAssignment {
    fn assigned_class(&self) -> &EntityRef {
        &self.assigned_class
    }
    fn role(&self) -> &EntityRef {
        &self.role
    }
}
impl ILanguageAssignment for LanguageAssignment {
    fn items(&self) -> &HashSet<EntityRef> {
        &self.items
    }
}
impl LanguageAssignment {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = LanguageAssignment::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.assigned_class = parameter.into(),
                1usize => entity.role = parameter.into(),
                2usize => entity.items = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait ILeaderCurve: IAnnotationCurveOccurrence {}
#[derive(Default, Debug)]
pub struct LeaderCurve {
    name: Label,
    styles: HashSet<EntityRef>,
    item: EntityRef,
}
impl IRepresentationItem for LeaderCurve {
    fn name(&self) -> &Label {
        &self.name
    }
}
impl IStyledItem for LeaderCurve {
    fn styles(&self) -> &HashSet<EntityRef> {
        &self.styles
    }
    fn item(&self) -> &EntityRef {
        &self.item
    }
}
impl IAnnotationOccurrence for LeaderCurve {}
impl IAnnotationCurveOccurrence for LeaderCurve {
    fn item(&self) -> &EntityRef {
        &self.item
    }
}
impl ILeaderCurve for LeaderCurve {}
impl LeaderCurve {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = LeaderCurve::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => entity.styles = parameter.into(),
                2usize => entity.item = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait ILeaderDirectedCallout: IDraughtingCallout {}
#[derive(Default, Debug)]
pub struct LeaderDirectedCallout {
    name: Label,
    contents: HashSet<EntityRef>,
}
impl IRepresentationItem for LeaderDirectedCallout {
    fn name(&self) -> &Label {
        &self.name
    }
}
impl IGeometricRepresentationItem for LeaderDirectedCallout {}
impl IDraughtingCallout for LeaderDirectedCallout {
    fn contents(&self) -> &HashSet<EntityRef> {
        &self.contents
    }
}
impl ILeaderDirectedCallout for LeaderDirectedCallout {}
impl LeaderDirectedCallout {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = LeaderDirectedCallout::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => entity.contents = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait ILeaderDirectedDimension: ILeaderDirectedCallout {}
#[derive(Default, Debug)]
pub struct LeaderDirectedDimension {
    name: Label,
    contents: HashSet<EntityRef>,
}
impl IRepresentationItem for LeaderDirectedDimension {
    fn name(&self) -> &Label {
        &self.name
    }
}
impl IGeometricRepresentationItem for LeaderDirectedDimension {}
impl IDraughtingCallout for LeaderDirectedDimension {
    fn contents(&self) -> &HashSet<EntityRef> {
        &self.contents
    }
}
impl ILeaderDirectedCallout for LeaderDirectedDimension {}
impl ILeaderDirectedDimension for LeaderDirectedDimension {}
impl LeaderDirectedDimension {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = LeaderDirectedDimension::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => entity.contents = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait ILeaderTerminator: ITerminatorSymbol {}
#[derive(Default, Debug)]
pub struct LeaderTerminator {
    name: Label,
    styles: HashSet<EntityRef>,
    item: EntityRef,
    annotated_curve: EntityRef,
}
impl IRepresentationItem for LeaderTerminator {
    fn name(&self) -> &Label {
        &self.name
    }
}
impl IStyledItem for LeaderTerminator {
    fn styles(&self) -> &HashSet<EntityRef> {
        &self.styles
    }
    fn item(&self) -> &EntityRef {
        &self.item
    }
}
impl IAnnotationOccurrence for LeaderTerminator {}
impl IAnnotationSymbolOccurrence for LeaderTerminator {
    fn item(&self) -> &EntityRef {
        &self.item
    }
}
impl ITerminatorSymbol for LeaderTerminator {
    fn annotated_curve(&self) -> &EntityRef {
        &self.annotated_curve
    }
}
impl ILeaderTerminator for LeaderTerminator {}
impl LeaderTerminator {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = LeaderTerminator::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => entity.styles = parameter.into(),
                2usize => entity.item = parameter.into(),
                3usize => entity.annotated_curve = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait ILengthFunction: INumericExpression + IUnaryGenericExpression {
    fn operand(&self) -> &EntityRef;
}
#[derive(Default, Debug)]
pub struct LengthFunction {
    operand: EntityRef,
}
impl IGenericExpression for LengthFunction {}
impl IExpression for LengthFunction {}
impl INumericExpression for LengthFunction {}
impl ILengthFunction for LengthFunction {
    fn operand(&self) -> &EntityRef {
        &self.operand
    }
}
impl IUnaryGenericExpression for LengthFunction {
    fn operand(&self) -> &EntityRef {
        &self.operand
    }
}
impl LengthFunction {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = LengthFunction::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.operand = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait ILengthMeasureWithUnit: IMeasureWithUnit {}
#[derive(Default, Debug)]
pub struct LengthMeasureWithUnit {
    value_component: MeasureValue,
    unit_component: EntityRef,
}
impl IMeasureWithUnit for LengthMeasureWithUnit {
    fn value_component(&self) -> &MeasureValue {
        &self.value_component
    }
    fn unit_component(&self) -> &EntityRef {
        &self.unit_component
    }
}
impl ILengthMeasureWithUnit for LengthMeasureWithUnit {}
impl LengthMeasureWithUnit {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = LengthMeasureWithUnit::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.value_component = parameter.into(),
                1usize => entity.unit_component = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait ILengthUnit: INamedUnit {}
#[derive(Default, Debug)]
pub struct LengthUnit {
    dimensions: EntityRef,
}
impl INamedUnit for LengthUnit {
    fn dimensions(&self) -> &EntityRef {
        &self.dimensions
    }
}
impl ILengthUnit for LengthUnit {}
impl LengthUnit {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = LengthUnit::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.dimensions = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait ILightSource: IGeometricRepresentationItem {
    fn light_colour(&self) -> &EntityRef;
}
#[derive(Default, Debug)]
pub struct LightSource {
    name: Label,
    light_colour: EntityRef,
}
impl IRepresentationItem for LightSource {
    fn name(&self) -> &Label {
        &self.name
    }
}
impl IGeometricRepresentationItem for LightSource {}
impl ILightSource for LightSource {
    fn light_colour(&self) -> &EntityRef {
        &self.light_colour
    }
}
impl LightSource {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = LightSource::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => entity.light_colour = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait ILightSourceAmbient: ILightSource {}
#[derive(Default, Debug)]
pub struct LightSourceAmbient {
    name: Label,
    light_colour: EntityRef,
}
impl IRepresentationItem for LightSourceAmbient {
    fn name(&self) -> &Label {
        &self.name
    }
}
impl IGeometricRepresentationItem for LightSourceAmbient {}
impl ILightSource for LightSourceAmbient {
    fn light_colour(&self) -> &EntityRef {
        &self.light_colour
    }
}
impl ILightSourceAmbient for LightSourceAmbient {}
impl LightSourceAmbient {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = LightSourceAmbient::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => entity.light_colour = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait ILightSourceDirectional: ILightSource {
    fn orientation(&self) -> &EntityRef;
}
#[derive(Default, Debug)]
pub struct LightSourceDirectional {
    name: Label,
    light_colour: EntityRef,
    orientation: EntityRef,
}
impl IRepresentationItem for LightSourceDirectional {
    fn name(&self) -> &Label {
        &self.name
    }
}
impl IGeometricRepresentationItem for LightSourceDirectional {}
impl ILightSource for LightSourceDirectional {
    fn light_colour(&self) -> &EntityRef {
        &self.light_colour
    }
}
impl ILightSourceDirectional for LightSourceDirectional {
    fn orientation(&self) -> &EntityRef {
        &self.orientation
    }
}
impl LightSourceDirectional {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = LightSourceDirectional::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => entity.light_colour = parameter.into(),
                2usize => entity.orientation = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait ILightSourcePositional: ILightSource {
    fn position(&self) -> &EntityRef;
    fn constant_attenuation(&self) -> Real;
    fn distance_attenuation(&self) -> Real;
}
#[derive(Default, Debug)]
pub struct LightSourcePositional {
    name: Label,
    light_colour: EntityRef,
    position: EntityRef,
    constant_attenuation: Real,
    distance_attenuation: Real,
}
impl IRepresentationItem for LightSourcePositional {
    fn name(&self) -> &Label {
        &self.name
    }
}
impl IGeometricRepresentationItem for LightSourcePositional {}
impl ILightSource for LightSourcePositional {
    fn light_colour(&self) -> &EntityRef {
        &self.light_colour
    }
}
impl ILightSourcePositional for LightSourcePositional {
    fn position(&self) -> &EntityRef {
        &self.position
    }
    fn constant_attenuation(&self) -> Real {
        self.constant_attenuation
    }
    fn distance_attenuation(&self) -> Real {
        self.distance_attenuation
    }
}
impl LightSourcePositional {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = LightSourcePositional::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => entity.light_colour = parameter.into(),
                2usize => entity.position = parameter.into(),
                3usize => entity.constant_attenuation = parameter.into(),
                4usize => entity.distance_attenuation = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait ILightSourceSpot: ILightSource {
    fn position(&self) -> &EntityRef;
    fn orientation(&self) -> &EntityRef;
    fn concentration_exponent(&self) -> Real;
    fn constant_attenuation(&self) -> Real;
    fn distance_attenuation(&self) -> Real;
    fn spread_angle(&self) -> &PositivePlaneAngleMeasure;
}
#[derive(Default, Debug)]
pub struct LightSourceSpot {
    name: Label,
    light_colour: EntityRef,
    position: EntityRef,
    orientation: EntityRef,
    concentration_exponent: Real,
    constant_attenuation: Real,
    distance_attenuation: Real,
    spread_angle: PositivePlaneAngleMeasure,
}
impl IRepresentationItem for LightSourceSpot {
    fn name(&self) -> &Label {
        &self.name
    }
}
impl IGeometricRepresentationItem for LightSourceSpot {}
impl ILightSource for LightSourceSpot {
    fn light_colour(&self) -> &EntityRef {
        &self.light_colour
    }
}
impl ILightSourceSpot for LightSourceSpot {
    fn position(&self) -> &EntityRef {
        &self.position
    }
    fn orientation(&self) -> &EntityRef {
        &self.orientation
    }
    fn concentration_exponent(&self) -> Real {
        self.concentration_exponent
    }
    fn constant_attenuation(&self) -> Real {
        self.constant_attenuation
    }
    fn distance_attenuation(&self) -> Real {
        self.distance_attenuation
    }
    fn spread_angle(&self) -> &PositivePlaneAngleMeasure {
        &self.spread_angle
    }
}
impl LightSourceSpot {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = LightSourceSpot::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => entity.light_colour = parameter.into(),
                2usize => entity.position = parameter.into(),
                3usize => entity.orientation = parameter.into(),
                4usize => entity.concentration_exponent = parameter.into(),
                5usize => entity.constant_attenuation = parameter.into(),
                6usize => entity.distance_attenuation = parameter.into(),
                7usize => entity.spread_angle = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait ILikeExpression: IComparisonExpression {}
#[derive(Default, Debug)]
pub struct LikeExpression {
    operands: Vec<EntityRef>,
}
impl IGenericExpression for LikeExpression {}
impl IExpression for LikeExpression {}
impl IBooleanExpression for LikeExpression {}
impl IComparisonExpression for LikeExpression {
    fn operands(&self) -> &Vec<EntityRef> {
        &self.operands
    }
}
impl IBinaryGenericExpression for LikeExpression {
    fn operands(&self) -> &Vec<EntityRef> {
        &self.operands
    }
}
impl ILikeExpression for LikeExpression {}
impl LikeExpression {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = LikeExpression::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.operands = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait ILimitsAndFits {
    fn form_variance(&self) -> &Label;
    fn zone_variance(&self) -> &Label;
    fn grade(&self) -> &Label;
    fn source(&self) -> &Text;
}
#[derive(Default, Debug)]
pub struct LimitsAndFits {
    form_variance: Label,
    zone_variance: Label,
    grade: Label,
    source: Text,
}
impl ILimitsAndFits for LimitsAndFits {
    fn form_variance(&self) -> &Label {
        &self.form_variance
    }
    fn zone_variance(&self) -> &Label {
        &self.zone_variance
    }
    fn grade(&self) -> &Label {
        &self.grade
    }
    fn source(&self) -> &Text {
        &self.source
    }
}
impl LimitsAndFits {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = LimitsAndFits::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.form_variance = parameter.into(),
                1usize => entity.zone_variance = parameter.into(),
                2usize => entity.grade = parameter.into(),
                3usize => entity.source = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait ILine: ICurve {
    fn pnt(&self) -> &EntityRef;
    fn dir(&self) -> &EntityRef;
}
#[derive(Default, Debug)]
pub struct Line {
    name: Label,
    pnt: EntityRef,
    dir: EntityRef,
}
impl IRepresentationItem for Line {
    fn name(&self) -> &Label {
        &self.name
    }
}
impl IGeometricRepresentationItem for Line {}
impl ICurve for Line {}
impl ILine for Line {
    fn pnt(&self) -> &EntityRef {
        &self.pnt
    }
    fn dir(&self) -> &EntityRef {
        &self.dir
    }
}
impl Line {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = Line::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => entity.pnt = parameter.into(),
                2usize => entity.dir = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait ILineProfileTolerance: IGeometricTolerance {}
#[derive(Default, Debug)]
pub struct LineProfileTolerance {
    name: Label,
    description: Text,
    magnitude: EntityRef,
    toleranced_shape_aspect: EntityRef,
}
impl IGeometricTolerance for LineProfileTolerance {
    fn name(&self) -> &Label {
        &self.name
    }
    fn description(&self) -> &Text {
        &self.description
    }
    fn magnitude(&self) -> &EntityRef {
        &self.magnitude
    }
    fn toleranced_shape_aspect(&self) -> &EntityRef {
        &self.toleranced_shape_aspect
    }
}
impl ILineProfileTolerance for LineProfileTolerance {}
impl LineProfileTolerance {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = LineProfileTolerance::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => entity.description = parameter.into(),
                2usize => entity.magnitude = parameter.into(),
                3usize => entity.toleranced_shape_aspect = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait ILinearDimension: IDimensionCurveDirectedCallout {}
#[derive(Default, Debug)]
pub struct LinearDimension {
    name: Label,
    contents: HashSet<EntityRef>,
}
impl IRepresentationItem for LinearDimension {
    fn name(&self) -> &Label {
        &self.name
    }
}
impl IGeometricRepresentationItem for LinearDimension {}
impl IDraughtingCallout for LinearDimension {
    fn contents(&self) -> &HashSet<EntityRef> {
        &self.contents
    }
}
impl IDimensionCurveDirectedCallout for LinearDimension {}
impl ILinearDimension for LinearDimension {}
impl LinearDimension {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = LinearDimension::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => entity.contents = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait ILiteralNumber: ISimpleNumericExpression + IGenericLiteral {
    fn the_value(&self) -> Real;
}
pub trait ILocalTime {
    fn hour_component(&self) -> &HourInDay;
    fn minute_component(&self) -> &Option<MinuteInHour>;
    fn second_component(&self) -> &Option<SecondInMinute>;
    fn zone(&self) -> &EntityRef;
}
#[derive(Default, Debug)]
pub struct LocalTime {
    hour_component: HourInDay,
    minute_component: Option<MinuteInHour>,
    second_component: Option<SecondInMinute>,
    zone: EntityRef,
}
impl ILocalTime for LocalTime {
    fn hour_component(&self) -> &HourInDay {
        &self.hour_component
    }
    fn minute_component(&self) -> &Option<MinuteInHour> {
        &self.minute_component
    }
    fn second_component(&self) -> &Option<SecondInMinute> {
        &self.second_component
    }
    fn zone(&self) -> &EntityRef {
        &self.zone
    }
}
impl LocalTime {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = LocalTime::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.hour_component = parameter.into(),
                1usize => {
                    entity.minute_component = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => {
                    entity.second_component = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => entity.zone = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait ILocationShapeRepresentation: IShapeRepresentation {}
#[derive(Default, Debug)]
pub struct LocationShapeRepresentation {
    name: Label,
    items: HashSet<EntityRef>,
    context_of_items: EntityRef,
}
impl IRepresentation for LocationShapeRepresentation {
    fn name(&self) -> &Label {
        &self.name
    }
    fn items(&self) -> &HashSet<EntityRef> {
        &self.items
    }
    fn context_of_items(&self) -> &EntityRef {
        &self.context_of_items
    }
}
impl IShapeRepresentation for LocationShapeRepresentation {}
impl ILocationShapeRepresentation for LocationShapeRepresentation {}
impl LocationShapeRepresentation {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = LocationShapeRepresentation::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => entity.items = parameter.into(),
                2usize => entity.context_of_items = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait ILocator: IFeatureDefinition {}
#[derive(Default, Debug)]
pub struct Locator {
    name: Label,
    description: Option<Text>,
}
impl ICharacterizedObject for Locator {
    fn name(&self) -> &Label {
        &self.name
    }
    fn description(&self) -> &Option<Text> {
        &self.description
    }
}
impl IFeatureDefinition for Locator {}
impl ILocator for Locator {}
impl Locator {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = Locator::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
}
pub trait ILog10Function: IUnaryFunctionCall {}
#[derive(Default, Debug)]
pub struct Log10Function {
    operand: EntityRef,
}
impl IGenericExpression for Log10Function {}
impl IExpression for Log10Function {}
impl INumericExpression for Log10Function {}
impl IUnaryNumericExpression for Log10Function {
    fn operand(&self) -> &EntityRef {
        &self.operand
    }
}
impl IUnaryGenericExpression for Log10Function {
    fn operand(&self) -> &EntityRef {
        &self.operand
    }
}
impl IUnaryFunctionCall for Log10Function {}
impl ILog10Function for Log10Function {}
impl Log10Function {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = Log10Function::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.operand = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait ILog2Function: IUnaryFunctionCall {}
#[derive(Default, Debug)]
pub struct Log2Function {
    operand: EntityRef,
}
impl IGenericExpression for Log2Function {}
impl IExpression for Log2Function {}
impl INumericExpression for Log2Function {}
impl IUnaryNumericExpression for Log2Function {
    fn operand(&self) -> &EntityRef {
        &self.operand
    }
}
impl IUnaryGenericExpression for Log2Function {
    fn operand(&self) -> &EntityRef {
        &self.operand
    }
}
impl IUnaryFunctionCall for Log2Function {}
impl ILog2Function for Log2Function {}
impl Log2Function {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = Log2Function::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.operand = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait ILogFunction: IUnaryFunctionCall {}
#[derive(Default, Debug)]
pub struct LogFunction {
    operand: EntityRef,
}
impl IGenericExpression for LogFunction {}
impl IExpression for LogFunction {}
impl INumericExpression for LogFunction {}
impl IUnaryNumericExpression for LogFunction {
    fn operand(&self) -> &EntityRef {
        &self.operand
    }
}
impl IUnaryGenericExpression for LogFunction {
    fn operand(&self) -> &EntityRef {
        &self.operand
    }
}
impl IUnaryFunctionCall for LogFunction {}
impl ILogFunction for LogFunction {}
impl LogFunction {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = LogFunction::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.operand = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait ILoop: ITopologicalRepresentationItem {}
#[derive(Default, Debug)]
pub struct Loop {
    name: Label,
}
impl IRepresentationItem for Loop {
    fn name(&self) -> &Label {
        &self.name
    }
}
impl ITopologicalRepresentationItem for Loop {}
impl ILoop for Loop {}
impl Loop {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = Loop::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait ILotEffectivity: IEffectivity {
    fn effectivity_lot_id(&self) -> &Identifier;
    fn effectivity_lot_size(&self) -> &EntityRef;
}
#[derive(Default, Debug)]
pub struct LotEffectivity {
    id: Identifier,
    effectivity_lot_id: Identifier,
    effectivity_lot_size: EntityRef,
}
impl IEffectivity for LotEffectivity {
    fn id(&self) -> &Identifier {
        &self.id
    }
}
impl ILotEffectivity for LotEffectivity {
    fn effectivity_lot_id(&self) -> &Identifier {
        &self.effectivity_lot_id
    }
    fn effectivity_lot_size(&self) -> &EntityRef {
        &self.effectivity_lot_size
    }
}
impl LotEffectivity {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = LotEffectivity::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.id = parameter.into(),
                1usize => entity.effectivity_lot_id = parameter.into(),
                2usize => entity.effectivity_lot_size = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait ILuminousIntensityMeasureWithUnit: IMeasureWithUnit {}
#[derive(Default, Debug)]
pub struct LuminousIntensityMeasureWithUnit {
    value_component: MeasureValue,
    unit_component: EntityRef,
}
impl IMeasureWithUnit for LuminousIntensityMeasureWithUnit {
    fn value_component(&self) -> &MeasureValue {
        &self.value_component
    }
    fn unit_component(&self) -> &EntityRef {
        &self.unit_component
    }
}
impl ILuminousIntensityMeasureWithUnit for LuminousIntensityMeasureWithUnit {}
impl LuminousIntensityMeasureWithUnit {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = LuminousIntensityMeasureWithUnit::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.value_component = parameter.into(),
                1usize => entity.unit_component = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait ILuminousIntensityUnit: INamedUnit {}
#[derive(Default, Debug)]
pub struct LuminousIntensityUnit {
    dimensions: EntityRef,
}
impl INamedUnit for LuminousIntensityUnit {
    fn dimensions(&self) -> &EntityRef {
        &self.dimensions
    }
}
impl ILuminousIntensityUnit for LuminousIntensityUnit {}
impl LuminousIntensityUnit {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = LuminousIntensityUnit::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.dimensions = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IMakeFromUsageOption: IProductDefinitionUsage {
    fn ranking(&self) -> i64;
    fn ranking_rationale(&self) -> &Text;
    fn quantity(&self) -> &EntityRef;
}
#[derive(Default, Debug)]
pub struct MakeFromUsageOption {
    id: Identifier,
    name: Label,
    description: Option<Text>,
    relating_product_definition: EntityRef,
    related_product_definition: EntityRef,
    ranking: i64,
    ranking_rationale: Text,
    quantity: EntityRef,
}
impl IProductDefinitionRelationship for MakeFromUsageOption {
    fn id(&self) -> &Identifier {
        &self.id
    }
    fn name(&self) -> &Label {
        &self.name
    }
    fn description(&self) -> &Option<Text> {
        &self.description
    }
    fn relating_product_definition(&self) -> &EntityRef {
        &self.relating_product_definition
    }
    fn related_product_definition(&self) -> &EntityRef {
        &self.related_product_definition
    }
}
impl IProductDefinitionUsage for MakeFromUsageOption {}
impl IMakeFromUsageOption for MakeFromUsageOption {
    fn ranking(&self) -> i64 {
        self.ranking
    }
    fn ranking_rationale(&self) -> &Text {
        &self.ranking_rationale
    }
    fn quantity(&self) -> &EntityRef {
        &self.quantity
    }
}
impl MakeFromUsageOption {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = MakeFromUsageOption::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.id = parameter.into(),
                1usize => entity.name = parameter.into(),
                2usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => entity.relating_product_definition = parameter.into(),
                4usize => entity.related_product_definition = parameter.into(),
                5usize => entity.ranking = parameter.into(),
                6usize => entity.ranking_rationale = parameter.into(),
                7usize => entity.quantity = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IManifoldSolidBrep: ISolidModel {
    fn outer(&self) -> &EntityRef;
}
#[derive(Default, Debug)]
pub struct ManifoldSolidBrep {
    name: Label,
    outer: EntityRef,
}
impl IRepresentationItem for ManifoldSolidBrep {
    fn name(&self) -> &Label {
        &self.name
    }
}
impl IGeometricRepresentationItem for ManifoldSolidBrep {}
impl ISolidModel for ManifoldSolidBrep {}
impl IManifoldSolidBrep for ManifoldSolidBrep {
    fn outer(&self) -> &EntityRef {
        &self.outer
    }
}
impl ManifoldSolidBrep {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = ManifoldSolidBrep::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => entity.outer = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IManifoldSubsurfaceShapeRepresentation: IShapeRepresentation {}
#[derive(Default, Debug)]
pub struct ManifoldSubsurfaceShapeRepresentation {
    name: Label,
    items: HashSet<EntityRef>,
    context_of_items: EntityRef,
}
impl IRepresentation for ManifoldSubsurfaceShapeRepresentation {
    fn name(&self) -> &Label {
        &self.name
    }
    fn items(&self) -> &HashSet<EntityRef> {
        &self.items
    }
    fn context_of_items(&self) -> &EntityRef {
        &self.context_of_items
    }
}
impl IShapeRepresentation for ManifoldSubsurfaceShapeRepresentation {}
impl IManifoldSubsurfaceShapeRepresentation for ManifoldSubsurfaceShapeRepresentation {}
impl ManifoldSubsurfaceShapeRepresentation {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = ManifoldSubsurfaceShapeRepresentation::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => entity.items = parameter.into(),
                2usize => entity.context_of_items = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IManifoldSurfaceShapeRepresentation: IShapeRepresentation {}
#[derive(Default, Debug)]
pub struct ManifoldSurfaceShapeRepresentation {
    name: Label,
    items: HashSet<EntityRef>,
    context_of_items: EntityRef,
}
impl IRepresentation for ManifoldSurfaceShapeRepresentation {
    fn name(&self) -> &Label {
        &self.name
    }
    fn items(&self) -> &HashSet<EntityRef> {
        &self.items
    }
    fn context_of_items(&self) -> &EntityRef {
        &self.context_of_items
    }
}
impl IShapeRepresentation for ManifoldSurfaceShapeRepresentation {}
impl IManifoldSurfaceShapeRepresentation for ManifoldSurfaceShapeRepresentation {}
impl ManifoldSurfaceShapeRepresentation {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = ManifoldSurfaceShapeRepresentation::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => entity.items = parameter.into(),
                2usize => entity.context_of_items = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IMappedItem: IRepresentationItem {
    fn mapping_source(&self) -> &EntityRef;
    fn mapping_target(&self) -> &EntityRef;
}
#[derive(Default, Debug)]
pub struct MappedItem {
    name: Label,
    mapping_source: EntityRef,
    mapping_target: EntityRef,
}
impl IRepresentationItem for MappedItem {
    fn name(&self) -> &Label {
        &self.name
    }
}
impl IMappedItem for MappedItem {
    fn mapping_source(&self) -> &EntityRef {
        &self.mapping_source
    }
    fn mapping_target(&self) -> &EntityRef {
        &self.mapping_target
    }
}
impl MappedItem {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = MappedItem::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => entity.mapping_source = parameter.into(),
                2usize => entity.mapping_target = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IMassMeasureWithUnit: IMeasureWithUnit {}
#[derive(Default, Debug)]
pub struct MassMeasureWithUnit {
    value_component: MeasureValue,
    unit_component: EntityRef,
}
impl IMeasureWithUnit for MassMeasureWithUnit {
    fn value_component(&self) -> &MeasureValue {
        &self.value_component
    }
    fn unit_component(&self) -> &EntityRef {
        &self.unit_component
    }
}
impl IMassMeasureWithUnit for MassMeasureWithUnit {}
impl MassMeasureWithUnit {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = MassMeasureWithUnit::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.value_component = parameter.into(),
                1usize => entity.unit_component = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IMassUnit: INamedUnit {}
#[derive(Default, Debug)]
pub struct MassUnit {
    dimensions: EntityRef,
}
impl INamedUnit for MassUnit {
    fn dimensions(&self) -> &EntityRef {
        &self.dimensions
    }
}
impl IMassUnit for MassUnit {}
impl MassUnit {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = MassUnit::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.dimensions = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IMaterialDesignation {
    fn name(&self) -> &Label;
    fn definitions(&self) -> &HashSet<EntityRef>;
}
#[derive(Default, Debug)]
pub struct MaterialDesignation {
    name: Label,
    definitions: HashSet<EntityRef>,
}
impl IMaterialDesignation for MaterialDesignation {
    fn name(&self) -> &Label {
        &self.name
    }
    fn definitions(&self) -> &HashSet<EntityRef> {
        &self.definitions
    }
}
impl MaterialDesignation {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = MaterialDesignation::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => entity.definitions = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IMaterialDesignationCharacterization {
    fn name(&self) -> &Label;
    fn description(&self) -> &Text;
    fn designation(&self) -> &EntityRef;
    fn property(&self) -> &EntityRef;
}
#[derive(Default, Debug)]
pub struct MaterialDesignationCharacterization {
    name: Label,
    description: Text,
    designation: EntityRef,
    property: EntityRef,
}
impl IMaterialDesignationCharacterization for MaterialDesignationCharacterization {
    fn name(&self) -> &Label {
        &self.name
    }
    fn description(&self) -> &Text {
        &self.description
    }
    fn designation(&self) -> &EntityRef {
        &self.designation
    }
    fn property(&self) -> &EntityRef {
        &self.property
    }
}
impl MaterialDesignationCharacterization {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = MaterialDesignationCharacterization::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => entity.description = parameter.into(),
                2usize => entity.designation = parameter.into(),
                3usize => entity.property = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IMaterialProperty: IPropertyDefinition {}
#[derive(Default, Debug)]
pub struct MaterialProperty {
    name: Label,
    description: Option<Text>,
    definition: EntityRef,
}
impl IPropertyDefinition for MaterialProperty {
    fn name(&self) -> &Label {
        &self.name
    }
    fn description(&self) -> &Option<Text> {
        &self.description
    }
    fn definition(&self) -> &EntityRef {
        &self.definition
    }
}
impl IMaterialProperty for MaterialProperty {}
impl MaterialProperty {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = MaterialProperty::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => entity.definition = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IMaterialPropertyRepresentation: IPropertyDefinitionRepresentation {
    fn dependent_environment(&self) -> &EntityRef;
}
#[derive(Default, Debug)]
pub struct MaterialPropertyRepresentation {
    definition: EntityRef,
    used_representation: EntityRef,
    dependent_environment: EntityRef,
}
impl IPropertyDefinitionRepresentation for MaterialPropertyRepresentation {
    fn definition(&self) -> &EntityRef {
        &self.definition
    }
    fn used_representation(&self) -> &EntityRef {
        &self.used_representation
    }
}
impl IMaterialPropertyRepresentation for MaterialPropertyRepresentation {
    fn dependent_environment(&self) -> &EntityRef {
        &self.dependent_environment
    }
}
impl MaterialPropertyRepresentation {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = MaterialPropertyRepresentation::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.definition = parameter.into(),
                1usize => entity.used_representation = parameter.into(),
                2usize => entity.dependent_environment = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IMaximumFunction: IMultipleArityFunctionCall {}
#[derive(Default, Debug)]
pub struct MaximumFunction {
    operands: Vec<EntityRef>,
}
impl IGenericExpression for MaximumFunction {}
impl IExpression for MaximumFunction {}
impl INumericExpression for MaximumFunction {}
impl IMultipleArityNumericExpression for MaximumFunction {
    fn operands(&self) -> &Vec<EntityRef> {
        &self.operands
    }
}
impl IMultipleArityGenericExpression for MaximumFunction {
    fn operands(&self) -> &Vec<EntityRef> {
        &self.operands
    }
}
impl IMultipleArityFunctionCall for MaximumFunction {}
impl IMaximumFunction for MaximumFunction {}
impl MaximumFunction {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = MaximumFunction::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.operands = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IMeasureQualification {
    fn name(&self) -> &Label;
    fn description(&self) -> &Text;
    fn qualified_measure(&self) -> &EntityRef;
    fn qualifiers(&self) -> &HashSet<EntityRef>;
}
#[derive(Default, Debug)]
pub struct MeasureQualification {
    name: Label,
    description: Text,
    qualified_measure: EntityRef,
    qualifiers: HashSet<EntityRef>,
}
impl IMeasureQualification for MeasureQualification {
    fn name(&self) -> &Label {
        &self.name
    }
    fn description(&self) -> &Text {
        &self.description
    }
    fn qualified_measure(&self) -> &EntityRef {
        &self.qualified_measure
    }
    fn qualifiers(&self) -> &HashSet<EntityRef> {
        &self.qualifiers
    }
}
impl MeasureQualification {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = MeasureQualification::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => entity.description = parameter.into(),
                2usize => entity.qualified_measure = parameter.into(),
                3usize => entity.qualifiers = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IMeasureRepresentationItem: IRepresentationItem + IMeasureWithUnit {}
#[derive(Default, Debug)]
pub struct MeasureRepresentationItem {
    name: Label,
    value_component: MeasureValue,
    unit_component: EntityRef,
}
impl IRepresentationItem for MeasureRepresentationItem {
    fn name(&self) -> &Label {
        &self.name
    }
}
impl IMeasureWithUnit for MeasureRepresentationItem {
    fn value_component(&self) -> &MeasureValue {
        &self.value_component
    }
    fn unit_component(&self) -> &EntityRef {
        &self.unit_component
    }
}
impl IMeasureRepresentationItem for MeasureRepresentationItem {}
impl MeasureRepresentationItem {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = MeasureRepresentationItem::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => entity.value_component = parameter.into(),
                2usize => entity.unit_component = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IMeasureWithUnit {
    fn value_component(&self) -> &MeasureValue;
    fn unit_component(&self) -> &EntityRef;
}
#[derive(Default, Debug)]
pub struct MeasureWithUnit {
    value_component: MeasureValue,
    unit_component: EntityRef,
}
impl IMeasureWithUnit for MeasureWithUnit {
    fn value_component(&self) -> &MeasureValue {
        &self.value_component
    }
    fn unit_component(&self) -> &EntityRef {
        &self.unit_component
    }
}
impl MeasureWithUnit {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = MeasureWithUnit::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.value_component = parameter.into(),
                1usize => entity.unit_component = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IMechanicalDesignGeometricPresentationArea: IPresentationArea {}
#[derive(Default, Debug)]
pub struct MechanicalDesignGeometricPresentationArea {
    name: Label,
    items: HashSet<EntityRef>,
    context_of_items: EntityRef,
}
impl IRepresentation for MechanicalDesignGeometricPresentationArea {
    fn name(&self) -> &Label {
        &self.name
    }
    fn items(&self) -> &HashSet<EntityRef> {
        &self.items
    }
    fn context_of_items(&self) -> &EntityRef {
        &self.context_of_items
    }
}
impl IPresentationRepresentation for MechanicalDesignGeometricPresentationArea {
    fn context_of_items(&self) -> &EntityRef {
        &self.context_of_items
    }
}
impl IPresentationArea for MechanicalDesignGeometricPresentationArea {}
impl IMechanicalDesignGeometricPresentationArea for MechanicalDesignGeometricPresentationArea {}
impl MechanicalDesignGeometricPresentationArea {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = MechanicalDesignGeometricPresentationArea::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => entity.items = parameter.into(),
                2usize => entity.context_of_items = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IMechanicalDesignGeometricPresentationRepresentation: IRepresentation {}
#[derive(Default, Debug)]
pub struct MechanicalDesignGeometricPresentationRepresentation {
    name: Label,
    items: HashSet<EntityRef>,
    context_of_items: EntityRef,
}
impl IRepresentation for MechanicalDesignGeometricPresentationRepresentation {
    fn name(&self) -> &Label {
        &self.name
    }
    fn items(&self) -> &HashSet<EntityRef> {
        &self.items
    }
    fn context_of_items(&self) -> &EntityRef {
        &self.context_of_items
    }
}
impl IMechanicalDesignGeometricPresentationRepresentation for MechanicalDesignGeometricPresentationRepresentation {}
impl MechanicalDesignGeometricPresentationRepresentation {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = MechanicalDesignGeometricPresentationRepresentation::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => entity.items = parameter.into(),
                2usize => entity.context_of_items = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IMechanism {
    fn structure_definition(&self) -> &EntityRef;
    fn base(&self) -> &EntityRef;
    fn containing_property(&self) -> &EntityRef;
}
#[derive(Default, Debug)]
pub struct Mechanism {
    structure_definition: EntityRef,
    base: EntityRef,
    containing_property: EntityRef,
}
impl IMechanism for Mechanism {
    fn structure_definition(&self) -> &EntityRef {
        &self.structure_definition
    }
    fn base(&self) -> &EntityRef {
        &self.base
    }
    fn containing_property(&self) -> &EntityRef {
        &self.containing_property
    }
}
impl Mechanism {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = Mechanism::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.structure_definition = parameter.into(),
                1usize => entity.base = parameter.into(),
                2usize => entity.containing_property = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IMechanismBasePlacement: IRepresentationRelationshipWithTransformation {
    fn base_of_mechanism(&self) -> &EntityRef;
    fn transformation_operator(&self) -> &EntityRef;
}
#[derive(Default, Debug)]
pub struct MechanismBasePlacement {
    name: Label,
    description: Option<Text>,
    rep_1: EntityRef,
    rep_2: EntityRef,
    base_of_mechanism: EntityRef,
    transformation_operator: EntityRef,
}
impl IRepresentationRelationship for MechanismBasePlacement {
    fn name(&self) -> &Label {
        &self.name
    }
    fn description(&self) -> &Option<Text> {
        &self.description
    }
    fn rep_1(&self) -> &EntityRef {
        &self.rep_1
    }
    fn rep_2(&self) -> &EntityRef {
        &self.rep_2
    }
}
impl IRepresentationRelationshipWithTransformation for MechanismBasePlacement {
    fn transformation_operator(&self) -> &EntityRef {
        &self.transformation_operator
    }
}
impl IMechanismBasePlacement for MechanismBasePlacement {
    fn base_of_mechanism(&self) -> &EntityRef {
        &self.base_of_mechanism
    }
    fn transformation_operator(&self) -> &EntityRef {
        &self.transformation_operator
    }
}
impl MechanismBasePlacement {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = MechanismBasePlacement::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => entity.rep_1 = parameter.into(),
                3usize => entity.rep_2 = parameter.into(),
                4usize => entity.base_of_mechanism = parameter.into(),
                5usize => entity.transformation_operator = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IMinimumFunction: IMultipleArityFunctionCall {}
#[derive(Default, Debug)]
pub struct MinimumFunction {
    operands: Vec<EntityRef>,
}
impl IGenericExpression for MinimumFunction {}
impl IExpression for MinimumFunction {}
impl INumericExpression for MinimumFunction {}
impl IMultipleArityNumericExpression for MinimumFunction {
    fn operands(&self) -> &Vec<EntityRef> {
        &self.operands
    }
}
impl IMultipleArityGenericExpression for MinimumFunction {
    fn operands(&self) -> &Vec<EntityRef> {
        &self.operands
    }
}
impl IMultipleArityFunctionCall for MinimumFunction {}
impl IMinimumFunction for MinimumFunction {}
impl MinimumFunction {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = MinimumFunction::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.operands = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IMinusExpression: IBinaryNumericExpression {}
#[derive(Default, Debug)]
pub struct MinusExpression {
    operands: Vec<EntityRef>,
}
impl IGenericExpression for MinusExpression {}
impl IExpression for MinusExpression {}
impl INumericExpression for MinusExpression {}
impl IBinaryNumericExpression for MinusExpression {
    fn operands(&self) -> &Vec<EntityRef> {
        &self.operands
    }
}
impl IBinaryGenericExpression for MinusExpression {
    fn operands(&self) -> &Vec<EntityRef> {
        &self.operands
    }
}
impl IMinusExpression for MinusExpression {}
impl MinusExpression {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = MinusExpression::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.operands = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IMinusFunction: IUnaryFunctionCall {}
#[derive(Default, Debug)]
pub struct MinusFunction {
    operand: EntityRef,
}
impl IGenericExpression for MinusFunction {}
impl IExpression for MinusFunction {}
impl INumericExpression for MinusFunction {}
impl IUnaryNumericExpression for MinusFunction {
    fn operand(&self) -> &EntityRef {
        &self.operand
    }
}
impl IUnaryGenericExpression for MinusFunction {
    fn operand(&self) -> &EntityRef {
        &self.operand
    }
}
impl IUnaryFunctionCall for MinusFunction {}
impl IMinusFunction for MinusFunction {}
impl MinusFunction {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = MinusFunction::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.operand = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IModExpression: IBinaryNumericExpression {}
#[derive(Default, Debug)]
pub struct ModExpression {
    operands: Vec<EntityRef>,
}
impl IGenericExpression for ModExpression {}
impl IExpression for ModExpression {}
impl INumericExpression for ModExpression {}
impl IBinaryNumericExpression for ModExpression {
    fn operands(&self) -> &Vec<EntityRef> {
        &self.operands
    }
}
impl IBinaryGenericExpression for ModExpression {
    fn operands(&self) -> &Vec<EntityRef> {
        &self.operands
    }
}
impl IModExpression for ModExpression {}
impl ModExpression {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = ModExpression::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.operands = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IModifiedGeometricTolerance: IGeometricTolerance {
    fn modifier(&self) -> &LimitCondition;
}
#[derive(Default, Debug)]
pub struct ModifiedGeometricTolerance {
    name: Label,
    description: Text,
    magnitude: EntityRef,
    toleranced_shape_aspect: EntityRef,
    modifier: LimitCondition,
}
impl IGeometricTolerance for ModifiedGeometricTolerance {
    fn name(&self) -> &Label {
        &self.name
    }
    fn description(&self) -> &Text {
        &self.description
    }
    fn magnitude(&self) -> &EntityRef {
        &self.magnitude
    }
    fn toleranced_shape_aspect(&self) -> &EntityRef {
        &self.toleranced_shape_aspect
    }
}
impl IModifiedGeometricTolerance for ModifiedGeometricTolerance {
    fn modifier(&self) -> &LimitCondition {
        &self.modifier
    }
}
impl ModifiedGeometricTolerance {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = ModifiedGeometricTolerance::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => entity.description = parameter.into(),
                2usize => entity.magnitude = parameter.into(),
                3usize => entity.toleranced_shape_aspect = parameter.into(),
                4usize => entity.modifier = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IModifiedPattern: IReplicateFeature {}
#[derive(Default, Debug)]
pub struct ModifiedPattern {
    name: Label,
    description: Option<Text>,
}
impl ICharacterizedObject for ModifiedPattern {
    fn name(&self) -> &Label {
        &self.name
    }
    fn description(&self) -> &Option<Text> {
        &self.description
    }
}
impl IFeatureDefinition for ModifiedPattern {}
impl IReplicateFeature for ModifiedPattern {}
impl IModifiedPattern for ModifiedPattern {}
impl ModifiedPattern {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = ModifiedPattern::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
}
pub trait IMomentsOfInertiaRepresentation: IRepresentation {}
#[derive(Default, Debug)]
pub struct MomentsOfInertiaRepresentation {
    name: Label,
    items: HashSet<EntityRef>,
    context_of_items: EntityRef,
}
impl IRepresentation for MomentsOfInertiaRepresentation {
    fn name(&self) -> &Label {
        &self.name
    }
    fn items(&self) -> &HashSet<EntityRef> {
        &self.items
    }
    fn context_of_items(&self) -> &EntityRef {
        &self.context_of_items
    }
}
impl IMomentsOfInertiaRepresentation for MomentsOfInertiaRepresentation {}
impl MomentsOfInertiaRepresentation {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = MomentsOfInertiaRepresentation::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => entity.items = parameter.into(),
                2usize => entity.context_of_items = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IMotionLinkRelationship: IRepresentationRelationship {
    fn rep_1(&self) -> &EntityRef;
    fn rep_2(&self) -> &EntityRef;
    fn related_frame(&self) -> &EntityRef;
}
#[derive(Default, Debug)]
pub struct MotionLinkRelationship {
    name: Label,
    description: Option<Text>,
    rep_1: EntityRef,
    rep_2: EntityRef,
    related_frame: EntityRef,
}
impl IRepresentationRelationship for MotionLinkRelationship {
    fn name(&self) -> &Label {
        &self.name
    }
    fn description(&self) -> &Option<Text> {
        &self.description
    }
    fn rep_1(&self) -> &EntityRef {
        &self.rep_1
    }
    fn rep_2(&self) -> &EntityRef {
        &self.rep_2
    }
}
impl IMotionLinkRelationship for MotionLinkRelationship {
    fn rep_1(&self) -> &EntityRef {
        &self.rep_1
    }
    fn rep_2(&self) -> &EntityRef {
        &self.rep_2
    }
    fn related_frame(&self) -> &EntityRef {
        &self.related_frame
    }
}
impl MotionLinkRelationship {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = MotionLinkRelationship::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => entity.rep_1 = parameter.into(),
                3usize => entity.rep_2 = parameter.into(),
                4usize => entity.related_frame = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IMultExpression: IMultipleArityNumericExpression {}
#[derive(Default, Debug)]
pub struct MultExpression {
    operands: Vec<EntityRef>,
}
impl IGenericExpression for MultExpression {}
impl IExpression for MultExpression {}
impl INumericExpression for MultExpression {}
impl IMultipleArityNumericExpression for MultExpression {
    fn operands(&self) -> &Vec<EntityRef> {
        &self.operands
    }
}
impl IMultipleArityGenericExpression for MultExpression {
    fn operands(&self) -> &Vec<EntityRef> {
        &self.operands
    }
}
impl IMultExpression for MultExpression {}
impl MultExpression {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = MultExpression::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.operands = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IMultiLanguageAttributeAssignment: IAttributeValueAssignment {
    fn items(&self) -> &HashSet<EntityRef>;
}
#[derive(Default, Debug)]
pub struct MultiLanguageAttributeAssignment {
    attribute_name: Label,
    attribute_value: AttributeType,
    role: EntityRef,
    items: HashSet<EntityRef>,
}
impl IAttributeValueAssignment for MultiLanguageAttributeAssignment {
    fn attribute_name(&self) -> &Label {
        &self.attribute_name
    }
    fn attribute_value(&self) -> &AttributeType {
        &self.attribute_value
    }
    fn role(&self) -> &EntityRef {
        &self.role
    }
}
impl IMultiLanguageAttributeAssignment for MultiLanguageAttributeAssignment {
    fn items(&self) -> &HashSet<EntityRef> {
        &self.items
    }
}
impl MultiLanguageAttributeAssignment {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = MultiLanguageAttributeAssignment::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.attribute_name = parameter.into(),
                1usize => entity.attribute_value = parameter.into(),
                2usize => entity.role = parameter.into(),
                3usize => entity.items = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IMultipleArityBooleanExpression: IBooleanExpression + IMultipleArityGenericExpression {
    fn operands(&self) -> &Vec<EntityRef>;
}
pub trait IMultipleArityFunctionCall: IMultipleArityNumericExpression {}
pub trait IMultipleArityGenericExpression: IGenericExpression {
    fn operands(&self) -> &Vec<EntityRef>;
}
pub trait IMultipleArityNumericExpression: INumericExpression + IMultipleArityGenericExpression {
    fn operands(&self) -> &Vec<EntityRef>;
}
pub trait INameAssignment {
    fn assigned_name(&self) -> &Label;
}
pub trait INameAttribute {
    fn attribute_value(&self) -> &Label;
    fn named_item(&self) -> &EntityRef;
}
#[derive(Default, Debug)]
pub struct NameAttribute {
    attribute_value: Label,
    named_item: EntityRef,
}
impl INameAttribute for NameAttribute {
    fn attribute_value(&self) -> &Label {
        &self.attribute_value
    }
    fn named_item(&self) -> &EntityRef {
        &self.named_item
    }
}
impl NameAttribute {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = NameAttribute::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.attribute_value = parameter.into(),
                1usize => entity.named_item = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait INamedUnit {
    fn dimensions(&self) -> &EntityRef;
}
#[derive(Default, Debug)]
pub struct NamedUnit {
    dimensions: EntityRef,
}
impl INamedUnit for NamedUnit {
    fn dimensions(&self) -> &EntityRef {
        &self.dimensions
    }
}
impl NamedUnit {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = NamedUnit::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.dimensions = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait INamedUnitVariable: INamedUnit + IVariableSemantics {}
#[derive(Default, Debug)]
pub struct NamedUnitVariable {
    dimensions: EntityRef,
}
impl INamedUnit for NamedUnitVariable {
    fn dimensions(&self) -> &EntityRef {
        &self.dimensions
    }
}
impl IVariableSemantics for NamedUnitVariable {}
impl INamedUnitVariable for NamedUnitVariable {}
impl NamedUnitVariable {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = NamedUnitVariable::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.dimensions = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait INextAssemblyUsageOccurrence: IAssemblyComponentUsage {}
#[derive(Default, Debug)]
pub struct NextAssemblyUsageOccurrence {
    id: Identifier,
    name: Label,
    description: Option<Text>,
    relating_product_definition: EntityRef,
    related_product_definition: EntityRef,
    reference_designator: Option<Identifier>,
}
impl IProductDefinitionRelationship for NextAssemblyUsageOccurrence {
    fn id(&self) -> &Identifier {
        &self.id
    }
    fn name(&self) -> &Label {
        &self.name
    }
    fn description(&self) -> &Option<Text> {
        &self.description
    }
    fn relating_product_definition(&self) -> &EntityRef {
        &self.relating_product_definition
    }
    fn related_product_definition(&self) -> &EntityRef {
        &self.related_product_definition
    }
}
impl IProductDefinitionUsage for NextAssemblyUsageOccurrence {}
impl IAssemblyComponentUsage for NextAssemblyUsageOccurrence {
    fn reference_designator(&self) -> &Option<Identifier> {
        &self.reference_designator
    }
}
impl INextAssemblyUsageOccurrence for NextAssemblyUsageOccurrence {}
impl NextAssemblyUsageOccurrence {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = NextAssemblyUsageOccurrence::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.id = parameter.into(),
                1usize => entity.name = parameter.into(),
                2usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => entity.relating_product_definition = parameter.into(),
                4usize => entity.related_product_definition = parameter.into(),
                5usize => {
                    entity.reference_designator = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
}
pub trait INgonClosedProfile: IShapeAspect {}
#[derive(Default, Debug)]
pub struct NgonClosedProfile {
    name: Label,
    description: Option<Text>,
    of_shape: EntityRef,
    product_definitional: Option<bool>,
}
impl IShapeAspect for NgonClosedProfile {
    fn name(&self) -> &Label {
        &self.name
    }
    fn description(&self) -> &Option<Text> {
        &self.description
    }
    fn of_shape(&self) -> &EntityRef {
        &self.of_shape
    }
    fn product_definitional(&self) -> Option<bool> {
        self.product_definitional
    }
}
impl INgonClosedProfile for NgonClosedProfile {}
impl NgonClosedProfile {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = NgonClosedProfile::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => entity.of_shape = parameter.into(),
                3usize => entity.product_definitional = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait INonManifoldSurfaceShapeRepresentation: IShapeRepresentation {}
#[derive(Default, Debug)]
pub struct NonManifoldSurfaceShapeRepresentation {
    name: Label,
    items: HashSet<EntityRef>,
    context_of_items: EntityRef,
}
impl IRepresentation for NonManifoldSurfaceShapeRepresentation {
    fn name(&self) -> &Label {
        &self.name
    }
    fn items(&self) -> &HashSet<EntityRef> {
        &self.items
    }
    fn context_of_items(&self) -> &EntityRef {
        &self.context_of_items
    }
}
impl IShapeRepresentation for NonManifoldSurfaceShapeRepresentation {}
impl INonManifoldSurfaceShapeRepresentation for NonManifoldSurfaceShapeRepresentation {}
impl NonManifoldSurfaceShapeRepresentation {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = NonManifoldSurfaceShapeRepresentation::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => entity.items = parameter.into(),
                2usize => entity.context_of_items = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait INotExpression: IUnaryBooleanExpression {
    fn operand(&self) -> &EntityRef;
}
#[derive(Default, Debug)]
pub struct NotExpression {
    operand: EntityRef,
}
impl IGenericExpression for NotExpression {}
impl IExpression for NotExpression {}
impl IBooleanExpression for NotExpression {}
impl IUnaryBooleanExpression for NotExpression {}
impl IUnaryGenericExpression for NotExpression {
    fn operand(&self) -> &EntityRef {
        &self.operand
    }
}
impl INotExpression for NotExpression {
    fn operand(&self) -> &EntityRef {
        &self.operand
    }
}
impl NotExpression {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = NotExpression::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.operand = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait INumericDefinedFunction: INumericExpression + IDefinedFunction {}
pub trait INumericExpression: IExpression {}
pub trait INumericVariable: ISimpleNumericExpression + IVariable {}
#[derive(Default, Debug)]
pub struct NumericVariable {}
impl IGenericExpression for NumericVariable {}
impl IExpression for NumericVariable {}
impl INumericExpression for NumericVariable {}
impl ISimpleNumericExpression for NumericVariable {}
impl ISimpleGenericExpression for NumericVariable {}
impl INumericVariable for NumericVariable {}
impl IVariable for NumericVariable {}
impl IGenericVariable for NumericVariable {}
impl NumericVariable {
    pub fn form_parameters(_parameters: Vec<Parameter>) -> Self {
        NumericVariable::default()
    }
}
pub trait IObjectRole {
    fn name(&self) -> &Label;
    fn description(&self) -> &Option<Text>;
}
#[derive(Default, Debug)]
pub struct ObjectRole {
    name: Label,
    description: Option<Text>,
}
impl IObjectRole for ObjectRole {
    fn name(&self) -> &Label {
        &self.name
    }
    fn description(&self) -> &Option<Text> {
        &self.description
    }
}
impl ObjectRole {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = ObjectRole::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
}
pub trait IOddFunction: IUnaryBooleanExpression {
    fn operand(&self) -> &EntityRef;
}
#[derive(Default, Debug)]
pub struct OddFunction {
    operand: EntityRef,
}
impl IGenericExpression for OddFunction {}
impl IExpression for OddFunction {}
impl IBooleanExpression for OddFunction {}
impl IUnaryBooleanExpression for OddFunction {}
impl IUnaryGenericExpression for OddFunction {
    fn operand(&self) -> &EntityRef {
        &self.operand
    }
}
impl IOddFunction for OddFunction {
    fn operand(&self) -> &EntityRef {
        &self.operand
    }
}
impl OddFunction {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = OddFunction::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.operand = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IOffsetCurve2d: ICurve {
    fn basis_curve(&self) -> &EntityRef;
    fn distance(&self) -> &LengthMeasure;
    fn self_intersect(&self) -> Option<bool>;
}
#[derive(Default, Debug)]
pub struct OffsetCurve2d {
    name: Label,
    basis_curve: EntityRef,
    distance: LengthMeasure,
    self_intersect: Option<bool>,
}
impl IRepresentationItem for OffsetCurve2d {
    fn name(&self) -> &Label {
        &self.name
    }
}
impl IGeometricRepresentationItem for OffsetCurve2d {}
impl ICurve for OffsetCurve2d {}
impl IOffsetCurve2d for OffsetCurve2d {
    fn basis_curve(&self) -> &EntityRef {
        &self.basis_curve
    }
    fn distance(&self) -> &LengthMeasure {
        &self.distance
    }
    fn self_intersect(&self) -> Option<bool> {
        self.self_intersect
    }
}
impl OffsetCurve2d {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = OffsetCurve2d::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => entity.basis_curve = parameter.into(),
                2usize => entity.distance = parameter.into(),
                3usize => entity.self_intersect = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IOffsetCurve3d: ICurve {
    fn basis_curve(&self) -> &EntityRef;
    fn distance(&self) -> &LengthMeasure;
    fn self_intersect(&self) -> Option<bool>;
    fn ref_direction(&self) -> &EntityRef;
}
#[derive(Default, Debug)]
pub struct OffsetCurve3d {
    name: Label,
    basis_curve: EntityRef,
    distance: LengthMeasure,
    self_intersect: Option<bool>,
    ref_direction: EntityRef,
}
impl IRepresentationItem for OffsetCurve3d {
    fn name(&self) -> &Label {
        &self.name
    }
}
impl IGeometricRepresentationItem for OffsetCurve3d {}
impl ICurve for OffsetCurve3d {}
impl IOffsetCurve3d for OffsetCurve3d {
    fn basis_curve(&self) -> &EntityRef {
        &self.basis_curve
    }
    fn distance(&self) -> &LengthMeasure {
        &self.distance
    }
    fn self_intersect(&self) -> Option<bool> {
        self.self_intersect
    }
    fn ref_direction(&self) -> &EntityRef {
        &self.ref_direction
    }
}
impl OffsetCurve3d {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = OffsetCurve3d::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => entity.basis_curve = parameter.into(),
                2usize => entity.distance = parameter.into(),
                3usize => entity.self_intersect = parameter.into(),
                4usize => entity.ref_direction = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IOffsetSurface: ISurface {
    fn basis_surface(&self) -> &EntityRef;
    fn distance(&self) -> &LengthMeasure;
    fn self_intersect(&self) -> Option<bool>;
}
#[derive(Default, Debug)]
pub struct OffsetSurface {
    name: Label,
    basis_surface: EntityRef,
    distance: LengthMeasure,
    self_intersect: Option<bool>,
}
impl IRepresentationItem for OffsetSurface {
    fn name(&self) -> &Label {
        &self.name
    }
}
impl IGeometricRepresentationItem for OffsetSurface {}
impl ISurface for OffsetSurface {}
impl IOffsetSurface for OffsetSurface {
    fn basis_surface(&self) -> &EntityRef {
        &self.basis_surface
    }
    fn distance(&self) -> &LengthMeasure {
        &self.distance
    }
    fn self_intersect(&self) -> Option<bool> {
        self.self_intersect
    }
}
impl OffsetSurface {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = OffsetSurface::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => entity.basis_surface = parameter.into(),
                2usize => entity.distance = parameter.into(),
                3usize => entity.self_intersect = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IOneDirectionRepeatFactor: IGeometricRepresentationItem {
    fn repeat_factor(&self) -> &EntityRef;
}
#[derive(Default, Debug)]
pub struct OneDirectionRepeatFactor {
    name: Label,
    repeat_factor: EntityRef,
}
impl IRepresentationItem for OneDirectionRepeatFactor {
    fn name(&self) -> &Label {
        &self.name
    }
}
impl IGeometricRepresentationItem for OneDirectionRepeatFactor {}
impl IOneDirectionRepeatFactor for OneDirectionRepeatFactor {
    fn repeat_factor(&self) -> &EntityRef {
        &self.repeat_factor
    }
}
impl OneDirectionRepeatFactor {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = OneDirectionRepeatFactor::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => entity.repeat_factor = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IOpenPathProfile: IShapeAspect {}
#[derive(Default, Debug)]
pub struct OpenPathProfile {
    name: Label,
    description: Option<Text>,
    of_shape: EntityRef,
    product_definitional: Option<bool>,
}
impl IShapeAspect for OpenPathProfile {
    fn name(&self) -> &Label {
        &self.name
    }
    fn description(&self) -> &Option<Text> {
        &self.description
    }
    fn of_shape(&self) -> &EntityRef {
        &self.of_shape
    }
    fn product_definitional(&self) -> Option<bool> {
        self.product_definitional
    }
}
impl IOpenPathProfile for OpenPathProfile {}
impl OpenPathProfile {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = OpenPathProfile::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => entity.of_shape = parameter.into(),
                3usize => entity.product_definitional = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IOpenShell: IConnectedFaceSet {}
#[derive(Default, Debug)]
pub struct OpenShell {
    name: Label,
    cfs_faces: HashSet<EntityRef>,
}
impl IRepresentationItem for OpenShell {
    fn name(&self) -> &Label {
        &self.name
    }
}
impl ITopologicalRepresentationItem for OpenShell {}
impl IConnectedFaceSet for OpenShell {
    fn cfs_faces(&self) -> &HashSet<EntityRef> {
        &self.cfs_faces
    }
}
impl IOpenShell for OpenShell {}
impl OpenShell {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = OpenShell::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => entity.cfs_faces = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IOrExpression: IMultipleArityBooleanExpression {}
#[derive(Default, Debug)]
pub struct OrExpression {
    operands: Vec<EntityRef>,
}
impl IGenericExpression for OrExpression {}
impl IExpression for OrExpression {}
impl IBooleanExpression for OrExpression {}
impl IMultipleArityBooleanExpression for OrExpression {
    fn operands(&self) -> &Vec<EntityRef> {
        &self.operands
    }
}
impl IMultipleArityGenericExpression for OrExpression {
    fn operands(&self) -> &Vec<EntityRef> {
        &self.operands
    }
}
impl IOrExpression for OrExpression {}
impl OrExpression {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = OrExpression::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.operands = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IOrdinateDimension: IProjectionDirectedCallout {}
#[derive(Default, Debug)]
pub struct OrdinateDimension {
    name: Label,
    contents: HashSet<EntityRef>,
}
impl IRepresentationItem for OrdinateDimension {
    fn name(&self) -> &Label {
        &self.name
    }
}
impl IGeometricRepresentationItem for OrdinateDimension {}
impl IDraughtingCallout for OrdinateDimension {
    fn contents(&self) -> &HashSet<EntityRef> {
        &self.contents
    }
}
impl IProjectionDirectedCallout for OrdinateDimension {}
impl IOrdinateDimension for OrdinateDimension {}
impl OrdinateDimension {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = OrdinateDimension::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => entity.contents = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IOrganization {
    fn id(&self) -> &Option<Identifier>;
    fn name(&self) -> &Label;
    fn description(&self) -> &Option<Text>;
}
#[derive(Default, Debug)]
pub struct Organization {
    id: Option<Identifier>,
    name: Label,
    description: Option<Text>,
}
impl IOrganization for Organization {
    fn id(&self) -> &Option<Identifier> {
        &self.id
    }
    fn name(&self) -> &Label {
        &self.name
    }
    fn description(&self) -> &Option<Text> {
        &self.description
    }
}
impl Organization {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = Organization::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => {
                    entity.id = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                1usize => entity.name = parameter.into(),
                2usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
}
pub trait IOrganizationAssignment {
    fn assigned_organization(&self) -> &EntityRef;
    fn role(&self) -> &EntityRef;
}
pub trait IOrganizationRelationship {
    fn name(&self) -> &Label;
    fn description(&self) -> &Option<Text>;
    fn relating_organization(&self) -> &EntityRef;
    fn related_organization(&self) -> &EntityRef;
}
#[derive(Default, Debug)]
pub struct OrganizationRelationship {
    name: Label,
    description: Option<Text>,
    relating_organization: EntityRef,
    related_organization: EntityRef,
}
impl IOrganizationRelationship for OrganizationRelationship {
    fn name(&self) -> &Label {
        &self.name
    }
    fn description(&self) -> &Option<Text> {
        &self.description
    }
    fn relating_organization(&self) -> &EntityRef {
        &self.relating_organization
    }
    fn related_organization(&self) -> &EntityRef {
        &self.related_organization
    }
}
impl OrganizationRelationship {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = OrganizationRelationship::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => entity.relating_organization = parameter.into(),
                3usize => entity.related_organization = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IOrganizationRole {
    fn name(&self) -> &Label;
}
#[derive(Default, Debug)]
pub struct OrganizationRole {
    name: Label,
}
impl IOrganizationRole for OrganizationRole {
    fn name(&self) -> &Label {
        &self.name
    }
}
impl OrganizationRole {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = OrganizationRole::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IOrganizationalAddress: IAddress {
    fn organizations(&self) -> &HashSet<EntityRef>;
    fn description(&self) -> &Option<Text>;
}
#[derive(Default, Debug)]
pub struct OrganizationalAddress {
    internal_location: Option<Label>,
    street_number: Option<Label>,
    street: Option<Label>,
    postal_box: Option<Label>,
    town: Option<Label>,
    region: Option<Label>,
    postal_code: Option<Label>,
    country: Option<Label>,
    facsimile_number: Option<Label>,
    telephone_number: Option<Label>,
    electronic_mail_address: Option<Label>,
    telex_number: Option<Label>,
    organizations: HashSet<EntityRef>,
    description: Option<Text>,
}
impl IAddress for OrganizationalAddress {
    fn internal_location(&self) -> &Option<Label> {
        &self.internal_location
    }
    fn street_number(&self) -> &Option<Label> {
        &self.street_number
    }
    fn street(&self) -> &Option<Label> {
        &self.street
    }
    fn postal_box(&self) -> &Option<Label> {
        &self.postal_box
    }
    fn town(&self) -> &Option<Label> {
        &self.town
    }
    fn region(&self) -> &Option<Label> {
        &self.region
    }
    fn postal_code(&self) -> &Option<Label> {
        &self.postal_code
    }
    fn country(&self) -> &Option<Label> {
        &self.country
    }
    fn facsimile_number(&self) -> &Option<Label> {
        &self.facsimile_number
    }
    fn telephone_number(&self) -> &Option<Label> {
        &self.telephone_number
    }
    fn electronic_mail_address(&self) -> &Option<Label> {
        &self.electronic_mail_address
    }
    fn telex_number(&self) -> &Option<Label> {
        &self.telex_number
    }
}
impl IOrganizationalAddress for OrganizationalAddress {
    fn organizations(&self) -> &HashSet<EntityRef> {
        &self.organizations
    }
    fn description(&self) -> &Option<Text> {
        &self.description
    }
}
impl OrganizationalAddress {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = OrganizationalAddress::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => {
                    entity.internal_location = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                1usize => {
                    entity.street_number = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => {
                    entity.street = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.postal_box = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => {
                    entity.town = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                5usize => {
                    entity.region = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                6usize => {
                    entity.postal_code = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                7usize => {
                    entity.country = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                8usize => {
                    entity.facsimile_number = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                9usize => {
                    entity.telephone_number = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                10usize => {
                    entity.electronic_mail_address = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                11usize => {
                    entity.telex_number = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                12usize => entity.organizations = parameter.into(),
                13usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
}
pub trait IOrganizationalProject {
    fn name(&self) -> &Label;
    fn description(&self) -> &Option<Text>;
    fn responsible_organizations(&self) -> &HashSet<EntityRef>;
}
#[derive(Default, Debug)]
pub struct OrganizationalProject {
    name: Label,
    description: Option<Text>,
    responsible_organizations: HashSet<EntityRef>,
}
impl IOrganizationalProject for OrganizationalProject {
    fn name(&self) -> &Label {
        &self.name
    }
    fn description(&self) -> &Option<Text> {
        &self.description
    }
    fn responsible_organizations(&self) -> &HashSet<EntityRef> {
        &self.responsible_organizations
    }
}
impl OrganizationalProject {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = OrganizationalProject::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => entity.responsible_organizations = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IOrganizationalProjectAssignment {
    fn assigned_organizational_project(&self) -> &EntityRef;
    fn role(&self) -> &EntityRef;
}
pub trait IOrganizationalProjectRelationship {
    fn name(&self) -> &Label;
    fn description(&self) -> &Option<Text>;
    fn relating_organizational_project(&self) -> &EntityRef;
    fn related_organizational_project(&self) -> &EntityRef;
}
#[derive(Default, Debug)]
pub struct OrganizationalProjectRelationship {
    name: Label,
    description: Option<Text>,
    relating_organizational_project: EntityRef,
    related_organizational_project: EntityRef,
}
impl IOrganizationalProjectRelationship for OrganizationalProjectRelationship {
    fn name(&self) -> &Label {
        &self.name
    }
    fn description(&self) -> &Option<Text> {
        &self.description
    }
    fn relating_organizational_project(&self) -> &EntityRef {
        &self.relating_organizational_project
    }
    fn related_organizational_project(&self) -> &EntityRef {
        &self.related_organizational_project
    }
}
impl OrganizationalProjectRelationship {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = OrganizationalProjectRelationship::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => entity.relating_organizational_project = parameter.into(),
                3usize => entity.related_organizational_project = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IOrganizationalProjectRole {
    fn name(&self) -> &Label;
    fn description(&self) -> &Option<Text>;
}
#[derive(Default, Debug)]
pub struct OrganizationalProjectRole {
    name: Label,
    description: Option<Text>,
}
impl IOrganizationalProjectRole for OrganizationalProjectRole {
    fn name(&self) -> &Label {
        &self.name
    }
    fn description(&self) -> &Option<Text> {
        &self.description
    }
}
impl OrganizationalProjectRole {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = OrganizationalProjectRole::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
}
pub trait IOrientedClosedShell: IClosedShell {
    fn closed_shell_element(&self) -> &EntityRef;
    fn orientation(&self) -> bool;
}
#[derive(Default, Debug)]
pub struct OrientedClosedShell {
    name: Label,
    cfs_faces: HashSet<EntityRef>,
    closed_shell_element: EntityRef,
    orientation: bool,
}
impl IRepresentationItem for OrientedClosedShell {
    fn name(&self) -> &Label {
        &self.name
    }
}
impl ITopologicalRepresentationItem for OrientedClosedShell {}
impl IConnectedFaceSet for OrientedClosedShell {
    fn cfs_faces(&self) -> &HashSet<EntityRef> {
        &self.cfs_faces
    }
}
impl IClosedShell for OrientedClosedShell {}
impl IOrientedClosedShell for OrientedClosedShell {
    fn closed_shell_element(&self) -> &EntityRef {
        &self.closed_shell_element
    }
    fn orientation(&self) -> bool {
        self.orientation
    }
}
impl OrientedClosedShell {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = OrientedClosedShell::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => entity.cfs_faces = parameter.into(),
                2usize => entity.closed_shell_element = parameter.into(),
                3usize => entity.orientation = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IOrientedEdge: IEdge {
    fn edge_element(&self) -> &EntityRef;
    fn orientation(&self) -> bool;
}
#[derive(Default, Debug)]
pub struct OrientedEdge {
    name: Label,
    edge_start: EntityRef,
    edge_end: EntityRef,
    edge_element: EntityRef,
    orientation: bool,
}
impl IRepresentationItem for OrientedEdge {
    fn name(&self) -> &Label {
        &self.name
    }
}
impl ITopologicalRepresentationItem for OrientedEdge {}
impl IEdge for OrientedEdge {
    fn edge_start(&self) -> &EntityRef {
        &self.edge_start
    }
    fn edge_end(&self) -> &EntityRef {
        &self.edge_end
    }
}
impl IOrientedEdge for OrientedEdge {
    fn edge_element(&self) -> &EntityRef {
        &self.edge_element
    }
    fn orientation(&self) -> bool {
        self.orientation
    }
}
impl OrientedEdge {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = OrientedEdge::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => entity.edge_start = parameter.into(),
                2usize => entity.edge_end = parameter.into(),
                3usize => entity.edge_element = parameter.into(),
                4usize => entity.orientation = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IOrientedFace: IFace {
    fn face_element(&self) -> &EntityRef;
    fn orientation(&self) -> bool;
}
#[derive(Default, Debug)]
pub struct OrientedFace {
    name: Label,
    bounds: HashSet<EntityRef>,
    face_element: EntityRef,
    orientation: bool,
}
impl IRepresentationItem for OrientedFace {
    fn name(&self) -> &Label {
        &self.name
    }
}
impl ITopologicalRepresentationItem for OrientedFace {}
impl IFace for OrientedFace {
    fn bounds(&self) -> &HashSet<EntityRef> {
        &self.bounds
    }
}
impl IOrientedFace for OrientedFace {
    fn face_element(&self) -> &EntityRef {
        &self.face_element
    }
    fn orientation(&self) -> bool {
        self.orientation
    }
}
impl OrientedFace {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = OrientedFace::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => entity.bounds = parameter.into(),
                2usize => entity.face_element = parameter.into(),
                3usize => entity.orientation = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IOrientedOpenShell: IOpenShell {
    fn open_shell_element(&self) -> &EntityRef;
    fn orientation(&self) -> bool;
}
#[derive(Default, Debug)]
pub struct OrientedOpenShell {
    name: Label,
    cfs_faces: HashSet<EntityRef>,
    open_shell_element: EntityRef,
    orientation: bool,
}
impl IRepresentationItem for OrientedOpenShell {
    fn name(&self) -> &Label {
        &self.name
    }
}
impl ITopologicalRepresentationItem for OrientedOpenShell {}
impl IConnectedFaceSet for OrientedOpenShell {
    fn cfs_faces(&self) -> &HashSet<EntityRef> {
        &self.cfs_faces
    }
}
impl IOpenShell for OrientedOpenShell {}
impl IOrientedOpenShell for OrientedOpenShell {
    fn open_shell_element(&self) -> &EntityRef {
        &self.open_shell_element
    }
    fn orientation(&self) -> bool {
        self.orientation
    }
}
impl OrientedOpenShell {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = OrientedOpenShell::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => entity.cfs_faces = parameter.into(),
                2usize => entity.open_shell_element = parameter.into(),
                3usize => entity.orientation = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IOrientedPath: IPath {
    fn path_element(&self) -> &EntityRef;
    fn orientation(&self) -> bool;
}
#[derive(Default, Debug)]
pub struct OrientedPath {
    name: Label,
    edge_list: Vec<EntityRef>,
    path_element: EntityRef,
    orientation: bool,
}
impl IRepresentationItem for OrientedPath {
    fn name(&self) -> &Label {
        &self.name
    }
}
impl ITopologicalRepresentationItem for OrientedPath {}
impl IPath for OrientedPath {
    fn edge_list(&self) -> &Vec<EntityRef> {
        &self.edge_list
    }
}
impl IOrientedPath for OrientedPath {
    fn path_element(&self) -> &EntityRef {
        &self.path_element
    }
    fn orientation(&self) -> bool {
        self.orientation
    }
}
impl OrientedPath {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = OrientedPath::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => entity.edge_list = parameter.into(),
                2usize => entity.path_element = parameter.into(),
                3usize => entity.orientation = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IOrientedSurface: ISurface {
    fn orientation(&self) -> bool;
}
#[derive(Default, Debug)]
pub struct OrientedSurface {
    name: Label,
    orientation: bool,
}
impl IRepresentationItem for OrientedSurface {
    fn name(&self) -> &Label {
        &self.name
    }
}
impl IGeometricRepresentationItem for OrientedSurface {}
impl ISurface for OrientedSurface {}
impl IOrientedSurface for OrientedSurface {
    fn orientation(&self) -> bool {
        self.orientation
    }
}
impl OrientedSurface {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = OrientedSurface::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => entity.orientation = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IOuterBoundaryCurve: IBoundaryCurve {}
#[derive(Default, Debug)]
pub struct OuterBoundaryCurve {
    name: Label,
    segments: Vec<EntityRef>,
    self_intersect: Option<bool>,
}
impl IRepresentationItem for OuterBoundaryCurve {
    fn name(&self) -> &Label {
        &self.name
    }
}
impl IGeometricRepresentationItem for OuterBoundaryCurve {}
impl ICurve for OuterBoundaryCurve {}
impl IBoundedCurve for OuterBoundaryCurve {}
impl ICompositeCurve for OuterBoundaryCurve {
    fn segments(&self) -> &Vec<EntityRef> {
        &self.segments
    }
    fn self_intersect(&self) -> Option<bool> {
        self.self_intersect
    }
}
impl ICompositeCurveOnSurface for OuterBoundaryCurve {}
impl IBoundaryCurve for OuterBoundaryCurve {}
impl IOuterBoundaryCurve for OuterBoundaryCurve {}
impl OuterBoundaryCurve {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = OuterBoundaryCurve::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => entity.segments = parameter.into(),
                2usize => entity.self_intersect = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IOverRidingStyledItem: IStyledItem {
    fn over_ridden_style(&self) -> &EntityRef;
}
#[derive(Default, Debug)]
pub struct OverRidingStyledItem {
    name: Label,
    styles: HashSet<EntityRef>,
    item: EntityRef,
    over_ridden_style: EntityRef,
}
impl IRepresentationItem for OverRidingStyledItem {
    fn name(&self) -> &Label {
        &self.name
    }
}
impl IStyledItem for OverRidingStyledItem {
    fn styles(&self) -> &HashSet<EntityRef> {
        &self.styles
    }
    fn item(&self) -> &EntityRef {
        &self.item
    }
}
impl IOverRidingStyledItem for OverRidingStyledItem {
    fn over_ridden_style(&self) -> &EntityRef {
        &self.over_ridden_style
    }
}
impl OverRidingStyledItem {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = OverRidingStyledItem::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => entity.styles = parameter.into(),
                2usize => entity.item = parameter.into(),
                3usize => entity.over_ridden_style = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IPackageProductConceptFeature: IProductConceptFeature {}
#[derive(Default, Debug)]
pub struct PackageProductConceptFeature {
    id: Identifier,
    name: Label,
    description: Option<Text>,
}
impl IProductConceptFeature for PackageProductConceptFeature {
    fn id(&self) -> &Identifier {
        &self.id
    }
    fn name(&self) -> &Label {
        &self.name
    }
    fn description(&self) -> &Option<Text> {
        &self.description
    }
}
impl IPackageProductConceptFeature for PackageProductConceptFeature {}
impl PackageProductConceptFeature {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = PackageProductConceptFeature::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.id = parameter.into(),
                1usize => entity.name = parameter.into(),
                2usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
}
pub trait IPairActuator {
    fn actuated_pair(&self) -> &EntityRef;
    fn name(&self) -> &Label;
}
#[derive(Default, Debug)]
pub struct PairActuator {
    actuated_pair: EntityRef,
    name: Label,
}
impl IPairActuator for PairActuator {
    fn actuated_pair(&self) -> &EntityRef {
        &self.actuated_pair
    }
    fn name(&self) -> &Label {
        &self.name
    }
}
impl PairActuator {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = PairActuator::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.actuated_pair = parameter.into(),
                1usize => entity.name = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IPairValue {
    fn applies_to_pair(&self) -> &EntityRef;
}
#[derive(Default, Debug)]
pub struct PairValue {
    applies_to_pair: EntityRef,
}
impl IPairValue for PairValue {
    fn applies_to_pair(&self) -> &EntityRef {
        &self.applies_to_pair
    }
}
impl PairValue {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = PairValue::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.applies_to_pair = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IParabola: IConic {
    fn focal_dist(&self) -> &LengthMeasure;
}
#[derive(Default, Debug)]
pub struct Parabola {
    name: Label,
    position: EntityRef,
    focal_dist: LengthMeasure,
}
impl IRepresentationItem for Parabola {
    fn name(&self) -> &Label {
        &self.name
    }
}
impl IGeometricRepresentationItem for Parabola {}
impl ICurve for Parabola {}
impl IConic for Parabola {
    fn position(&self) -> &EntityRef {
        &self.position
    }
}
impl IParabola for Parabola {
    fn focal_dist(&self) -> &LengthMeasure {
        &self.focal_dist
    }
}
impl Parabola {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = Parabola::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => entity.position = parameter.into(),
                2usize => entity.focal_dist = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IParallelOffset: IDerivedShapeAspect {
    fn offset(&self) -> &EntityRef;
}
#[derive(Default, Debug)]
pub struct ParallelOffset {
    name: Label,
    description: Option<Text>,
    of_shape: EntityRef,
    product_definitional: Option<bool>,
    offset: EntityRef,
}
impl IShapeAspect for ParallelOffset {
    fn name(&self) -> &Label {
        &self.name
    }
    fn description(&self) -> &Option<Text> {
        &self.description
    }
    fn of_shape(&self) -> &EntityRef {
        &self.of_shape
    }
    fn product_definitional(&self) -> Option<bool> {
        self.product_definitional
    }
}
impl IDerivedShapeAspect for ParallelOffset {}
impl IParallelOffset for ParallelOffset {
    fn offset(&self) -> &EntityRef {
        &self.offset
    }
}
impl ParallelOffset {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = ParallelOffset::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => entity.of_shape = parameter.into(),
                3usize => entity.product_definitional = parameter.into(),
                4usize => entity.offset = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IParallelismTolerance: IGeometricToleranceWithDatumReference {}
#[derive(Default, Debug)]
pub struct ParallelismTolerance {
    name: Label,
    description: Text,
    magnitude: EntityRef,
    toleranced_shape_aspect: EntityRef,
    datum_system: HashSet<EntityRef>,
}
impl IGeometricTolerance for ParallelismTolerance {
    fn name(&self) -> &Label {
        &self.name
    }
    fn description(&self) -> &Text {
        &self.description
    }
    fn magnitude(&self) -> &EntityRef {
        &self.magnitude
    }
    fn toleranced_shape_aspect(&self) -> &EntityRef {
        &self.toleranced_shape_aspect
    }
}
impl IGeometricToleranceWithDatumReference for ParallelismTolerance {
    fn datum_system(&self) -> &HashSet<EntityRef> {
        &self.datum_system
    }
}
impl IParallelismTolerance for ParallelismTolerance {}
impl ParallelismTolerance {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = ParallelismTolerance::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => entity.description = parameter.into(),
                2usize => entity.magnitude = parameter.into(),
                3usize => entity.toleranced_shape_aspect = parameter.into(),
                4usize => entity.datum_system = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IParametricRepresentationContext: IRepresentationContext {}
#[derive(Default, Debug)]
pub struct ParametricRepresentationContext {
    context_identifier: Identifier,
    context_type: Text,
}
impl IRepresentationContext for ParametricRepresentationContext {
    fn context_identifier(&self) -> &Identifier {
        &self.context_identifier
    }
    fn context_type(&self) -> &Text {
        &self.context_type
    }
}
impl IParametricRepresentationContext for ParametricRepresentationContext {}
impl ParametricRepresentationContext {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = ParametricRepresentationContext::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.context_identifier = parameter.into(),
                1usize => entity.context_type = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IPartialCircularProfile: IShapeAspect {}
#[derive(Default, Debug)]
pub struct PartialCircularProfile {
    name: Label,
    description: Option<Text>,
    of_shape: EntityRef,
    product_definitional: Option<bool>,
}
impl IShapeAspect for PartialCircularProfile {
    fn name(&self) -> &Label {
        &self.name
    }
    fn description(&self) -> &Option<Text> {
        &self.description
    }
    fn of_shape(&self) -> &EntityRef {
        &self.of_shape
    }
    fn product_definitional(&self) -> Option<bool> {
        self.product_definitional
    }
}
impl IPartialCircularProfile for PartialCircularProfile {}
impl PartialCircularProfile {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = PartialCircularProfile::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => entity.of_shape = parameter.into(),
                3usize => entity.product_definitional = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IPath: ITopologicalRepresentationItem {
    fn edge_list(&self) -> &Vec<EntityRef>;
}
#[derive(Default, Debug)]
pub struct Path {
    name: Label,
    edge_list: Vec<EntityRef>,
}
impl IRepresentationItem for Path {
    fn name(&self) -> &Label {
        &self.name
    }
}
impl ITopologicalRepresentationItem for Path {}
impl IPath for Path {
    fn edge_list(&self) -> &Vec<EntityRef> {
        &self.edge_list
    }
}
impl Path {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = Path::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => entity.edge_list = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IPathFeatureComponent: IShapeAspect {}
#[derive(Default, Debug)]
pub struct PathFeatureComponent {
    name: Label,
    description: Option<Text>,
    of_shape: EntityRef,
    product_definitional: Option<bool>,
}
impl IShapeAspect for PathFeatureComponent {
    fn name(&self) -> &Label {
        &self.name
    }
    fn description(&self) -> &Option<Text> {
        &self.description
    }
    fn of_shape(&self) -> &EntityRef {
        &self.of_shape
    }
    fn product_definitional(&self) -> Option<bool> {
        self.product_definitional
    }
}
impl IPathFeatureComponent for PathFeatureComponent {}
impl PathFeatureComponent {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = PathFeatureComponent::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => entity.of_shape = parameter.into(),
                3usize => entity.product_definitional = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IPathShapeRepresentation: IShapeRepresentation {}
#[derive(Default, Debug)]
pub struct PathShapeRepresentation {
    name: Label,
    items: HashSet<EntityRef>,
    context_of_items: EntityRef,
}
impl IRepresentation for PathShapeRepresentation {
    fn name(&self) -> &Label {
        &self.name
    }
    fn items(&self) -> &HashSet<EntityRef> {
        &self.items
    }
    fn context_of_items(&self) -> &EntityRef {
        &self.context_of_items
    }
}
impl IShapeRepresentation for PathShapeRepresentation {}
impl IPathShapeRepresentation for PathShapeRepresentation {}
impl PathShapeRepresentation {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = PathShapeRepresentation::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => entity.items = parameter.into(),
                2usize => entity.context_of_items = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IPatternOffsetMembership: IFeatureComponentRelationship {}
#[derive(Default, Debug)]
pub struct PatternOffsetMembership {
    name: Label,
    description: Option<Text>,
    relating_shape_aspect: EntityRef,
    related_shape_aspect: EntityRef,
}
impl IShapeAspectRelationship for PatternOffsetMembership {
    fn name(&self) -> &Label {
        &self.name
    }
    fn description(&self) -> &Option<Text> {
        &self.description
    }
    fn relating_shape_aspect(&self) -> &EntityRef {
        &self.relating_shape_aspect
    }
    fn related_shape_aspect(&self) -> &EntityRef {
        &self.related_shape_aspect
    }
}
impl IFeatureComponentRelationship for PatternOffsetMembership {}
impl IPatternOffsetMembership for PatternOffsetMembership {}
impl PatternOffsetMembership {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = PatternOffsetMembership::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => entity.relating_shape_aspect = parameter.into(),
                3usize => entity.related_shape_aspect = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IPatternOmitMembership: IFeatureComponentRelationship {}
#[derive(Default, Debug)]
pub struct PatternOmitMembership {
    name: Label,
    description: Option<Text>,
    relating_shape_aspect: EntityRef,
    related_shape_aspect: EntityRef,
}
impl IShapeAspectRelationship for PatternOmitMembership {
    fn name(&self) -> &Label {
        &self.name
    }
    fn description(&self) -> &Option<Text> {
        &self.description
    }
    fn relating_shape_aspect(&self) -> &EntityRef {
        &self.relating_shape_aspect
    }
    fn related_shape_aspect(&self) -> &EntityRef {
        &self.related_shape_aspect
    }
}
impl IFeatureComponentRelationship for PatternOmitMembership {}
impl IPatternOmitMembership for PatternOmitMembership {}
impl PatternOmitMembership {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = PatternOmitMembership::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => entity.relating_shape_aspect = parameter.into(),
                3usize => entity.related_shape_aspect = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IPcurve: ICurve {
    fn basis_surface(&self) -> &EntityRef;
    fn reference_to_curve(&self) -> &EntityRef;
}
#[derive(Default, Debug)]
pub struct Pcurve {
    name: Label,
    basis_surface: EntityRef,
    reference_to_curve: EntityRef,
}
impl IRepresentationItem for Pcurve {
    fn name(&self) -> &Label {
        &self.name
    }
}
impl IGeometricRepresentationItem for Pcurve {}
impl ICurve for Pcurve {}
impl IPcurve for Pcurve {
    fn basis_surface(&self) -> &EntityRef {
        &self.basis_surface
    }
    fn reference_to_curve(&self) -> &EntityRef {
        &self.reference_to_curve
    }
}
impl Pcurve {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = Pcurve::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => entity.basis_surface = parameter.into(),
                2usize => entity.reference_to_curve = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IPerpendicularTo: IDerivedShapeAspect {}
#[derive(Default, Debug)]
pub struct PerpendicularTo {
    name: Label,
    description: Option<Text>,
    of_shape: EntityRef,
    product_definitional: Option<bool>,
}
impl IShapeAspect for PerpendicularTo {
    fn name(&self) -> &Label {
        &self.name
    }
    fn description(&self) -> &Option<Text> {
        &self.description
    }
    fn of_shape(&self) -> &EntityRef {
        &self.of_shape
    }
    fn product_definitional(&self) -> Option<bool> {
        self.product_definitional
    }
}
impl IDerivedShapeAspect for PerpendicularTo {}
impl IPerpendicularTo for PerpendicularTo {}
impl PerpendicularTo {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = PerpendicularTo::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => entity.of_shape = parameter.into(),
                3usize => entity.product_definitional = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IPerpendicularityTolerance: IGeometricToleranceWithDatumReference {}
#[derive(Default, Debug)]
pub struct PerpendicularityTolerance {
    name: Label,
    description: Text,
    magnitude: EntityRef,
    toleranced_shape_aspect: EntityRef,
    datum_system: HashSet<EntityRef>,
}
impl IGeometricTolerance for PerpendicularityTolerance {
    fn name(&self) -> &Label {
        &self.name
    }
    fn description(&self) -> &Text {
        &self.description
    }
    fn magnitude(&self) -> &EntityRef {
        &self.magnitude
    }
    fn toleranced_shape_aspect(&self) -> &EntityRef {
        &self.toleranced_shape_aspect
    }
}
impl IGeometricToleranceWithDatumReference for PerpendicularityTolerance {
    fn datum_system(&self) -> &HashSet<EntityRef> {
        &self.datum_system
    }
}
impl IPerpendicularityTolerance for PerpendicularityTolerance {}
impl PerpendicularityTolerance {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = PerpendicularityTolerance::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => entity.description = parameter.into(),
                2usize => entity.magnitude = parameter.into(),
                3usize => entity.toleranced_shape_aspect = parameter.into(),
                4usize => entity.datum_system = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IPerson {
    fn id(&self) -> &Identifier;
    fn last_name(&self) -> &Option<Label>;
    fn first_name(&self) -> &Option<Label>;
    fn middle_names(&self) -> &Option<Vec<Label>>;
    fn prefix_titles(&self) -> &Option<Vec<Label>>;
    fn suffix_titles(&self) -> &Option<Vec<Label>>;
}
#[derive(Default, Debug)]
pub struct Person {
    id: Identifier,
    last_name: Option<Label>,
    first_name: Option<Label>,
    middle_names: Option<Vec<Label>>,
    prefix_titles: Option<Vec<Label>>,
    suffix_titles: Option<Vec<Label>>,
}
impl IPerson for Person {
    fn id(&self) -> &Identifier {
        &self.id
    }
    fn last_name(&self) -> &Option<Label> {
        &self.last_name
    }
    fn first_name(&self) -> &Option<Label> {
        &self.first_name
    }
    fn middle_names(&self) -> &Option<Vec<Label>> {
        &self.middle_names
    }
    fn prefix_titles(&self) -> &Option<Vec<Label>> {
        &self.prefix_titles
    }
    fn suffix_titles(&self) -> &Option<Vec<Label>> {
        &self.suffix_titles
    }
}
impl Person {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = Person::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.id = parameter.into(),
                1usize => {
                    entity.last_name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => {
                    entity.first_name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.middle_names = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => {
                    entity.prefix_titles = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                5usize => {
                    entity.suffix_titles = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
}
pub trait IPersonAndOrganization {
    fn the_person(&self) -> &EntityRef;
    fn the_organization(&self) -> &EntityRef;
}
#[derive(Default, Debug)]
pub struct PersonAndOrganization {
    the_person: EntityRef,
    the_organization: EntityRef,
}
impl IPersonAndOrganization for PersonAndOrganization {
    fn the_person(&self) -> &EntityRef {
        &self.the_person
    }
    fn the_organization(&self) -> &EntityRef {
        &self.the_organization
    }
}
impl PersonAndOrganization {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = PersonAndOrganization::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.the_person = parameter.into(),
                1usize => entity.the_organization = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IPersonAndOrganizationAddress: IOrganizationalAddress + IPersonalAddress {}
#[derive(Default, Debug)]
pub struct PersonAndOrganizationAddress {
    internal_location: Option<Label>,
    street_number: Option<Label>,
    street: Option<Label>,
    postal_box: Option<Label>,
    town: Option<Label>,
    region: Option<Label>,
    postal_code: Option<Label>,
    country: Option<Label>,
    facsimile_number: Option<Label>,
    telephone_number: Option<Label>,
    electronic_mail_address: Option<Label>,
    telex_number: Option<Label>,
    organizations: HashSet<EntityRef>,
    description: Option<Text>,
    people: HashSet<EntityRef>,
}
impl IAddress for PersonAndOrganizationAddress {
    fn internal_location(&self) -> &Option<Label> {
        &self.internal_location
    }
    fn street_number(&self) -> &Option<Label> {
        &self.street_number
    }
    fn street(&self) -> &Option<Label> {
        &self.street
    }
    fn postal_box(&self) -> &Option<Label> {
        &self.postal_box
    }
    fn town(&self) -> &Option<Label> {
        &self.town
    }
    fn region(&self) -> &Option<Label> {
        &self.region
    }
    fn postal_code(&self) -> &Option<Label> {
        &self.postal_code
    }
    fn country(&self) -> &Option<Label> {
        &self.country
    }
    fn facsimile_number(&self) -> &Option<Label> {
        &self.facsimile_number
    }
    fn telephone_number(&self) -> &Option<Label> {
        &self.telephone_number
    }
    fn electronic_mail_address(&self) -> &Option<Label> {
        &self.electronic_mail_address
    }
    fn telex_number(&self) -> &Option<Label> {
        &self.telex_number
    }
}
impl IOrganizationalAddress for PersonAndOrganizationAddress {
    fn organizations(&self) -> &HashSet<EntityRef> {
        &self.organizations
    }
    fn description(&self) -> &Option<Text> {
        &self.description
    }
}
impl IPersonAndOrganizationAddress for PersonAndOrganizationAddress {}
impl IPersonalAddress for PersonAndOrganizationAddress {
    fn people(&self) -> &HashSet<EntityRef> {
        &self.people
    }
    fn description(&self) -> &Option<Text> {
        &self.description
    }
}
impl PersonAndOrganizationAddress {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = PersonAndOrganizationAddress::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => {
                    entity.internal_location = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                1usize => {
                    entity.street_number = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => {
                    entity.street = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.postal_box = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => {
                    entity.town = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                5usize => {
                    entity.region = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                6usize => {
                    entity.postal_code = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                7usize => {
                    entity.country = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                8usize => {
                    entity.facsimile_number = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                9usize => {
                    entity.telephone_number = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                10usize => {
                    entity.electronic_mail_address = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                11usize => {
                    entity.telex_number = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                12usize => entity.organizations = parameter.into(),
                13usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                14usize => entity.people = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IPersonAndOrganizationAssignment {
    fn assigned_person_and_organization(&self) -> &EntityRef;
    fn role(&self) -> &EntityRef;
}
pub trait IPersonAndOrganizationRole {
    fn name(&self) -> &Label;
}
#[derive(Default, Debug)]
pub struct PersonAndOrganizationRole {
    name: Label,
}
impl IPersonAndOrganizationRole for PersonAndOrganizationRole {
    fn name(&self) -> &Label {
        &self.name
    }
}
impl PersonAndOrganizationRole {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = PersonAndOrganizationRole::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IPersonalAddress: IAddress {
    fn people(&self) -> &HashSet<EntityRef>;
    fn description(&self) -> &Option<Text>;
}
#[derive(Default, Debug)]
pub struct PersonalAddress {
    internal_location: Option<Label>,
    street_number: Option<Label>,
    street: Option<Label>,
    postal_box: Option<Label>,
    town: Option<Label>,
    region: Option<Label>,
    postal_code: Option<Label>,
    country: Option<Label>,
    facsimile_number: Option<Label>,
    telephone_number: Option<Label>,
    electronic_mail_address: Option<Label>,
    telex_number: Option<Label>,
    people: HashSet<EntityRef>,
    description: Option<Text>,
}
impl IAddress for PersonalAddress {
    fn internal_location(&self) -> &Option<Label> {
        &self.internal_location
    }
    fn street_number(&self) -> &Option<Label> {
        &self.street_number
    }
    fn street(&self) -> &Option<Label> {
        &self.street
    }
    fn postal_box(&self) -> &Option<Label> {
        &self.postal_box
    }
    fn town(&self) -> &Option<Label> {
        &self.town
    }
    fn region(&self) -> &Option<Label> {
        &self.region
    }
    fn postal_code(&self) -> &Option<Label> {
        &self.postal_code
    }
    fn country(&self) -> &Option<Label> {
        &self.country
    }
    fn facsimile_number(&self) -> &Option<Label> {
        &self.facsimile_number
    }
    fn telephone_number(&self) -> &Option<Label> {
        &self.telephone_number
    }
    fn electronic_mail_address(&self) -> &Option<Label> {
        &self.electronic_mail_address
    }
    fn telex_number(&self) -> &Option<Label> {
        &self.telex_number
    }
}
impl IPersonalAddress for PersonalAddress {
    fn people(&self) -> &HashSet<EntityRef> {
        &self.people
    }
    fn description(&self) -> &Option<Text> {
        &self.description
    }
}
impl PersonalAddress {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = PersonalAddress::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => {
                    entity.internal_location = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                1usize => {
                    entity.street_number = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => {
                    entity.street = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.postal_box = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => {
                    entity.town = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                5usize => {
                    entity.region = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                6usize => {
                    entity.postal_code = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                7usize => {
                    entity.country = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                8usize => {
                    entity.facsimile_number = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                9usize => {
                    entity.telephone_number = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                10usize => {
                    entity.electronic_mail_address = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                11usize => {
                    entity.telex_number = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                12usize => entity.people = parameter.into(),
                13usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
}
pub trait IPhysicallyModelledProductDefinition: IProductDefinitionWithAssociatedDocuments {}
#[derive(Default, Debug)]
pub struct PhysicallyModelledProductDefinition {
    id: Identifier,
    description: Option<Text>,
    formation: EntityRef,
    frame_of_reference: EntityRef,
    documentation_ids: HashSet<EntityRef>,
}
impl IProductDefinition for PhysicallyModelledProductDefinition {
    fn id(&self) -> &Identifier {
        &self.id
    }
    fn description(&self) -> &Option<Text> {
        &self.description
    }
    fn formation(&self) -> &EntityRef {
        &self.formation
    }
    fn frame_of_reference(&self) -> &EntityRef {
        &self.frame_of_reference
    }
}
impl IProductDefinitionWithAssociatedDocuments for PhysicallyModelledProductDefinition {
    fn documentation_ids(&self) -> &HashSet<EntityRef> {
        &self.documentation_ids
    }
}
impl IPhysicallyModelledProductDefinition for PhysicallyModelledProductDefinition {}
impl PhysicallyModelledProductDefinition {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = PhysicallyModelledProductDefinition::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.id = parameter.into(),
                1usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => entity.formation = parameter.into(),
                3usize => entity.frame_of_reference = parameter.into(),
                4usize => entity.documentation_ids = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IPlacedDatumTargetFeature: IDatumTarget {}
#[derive(Default, Debug)]
pub struct PlacedDatumTargetFeature {
    name: Label,
    description: Option<Text>,
    of_shape: EntityRef,
    product_definitional: Option<bool>,
    target_id: Identifier,
}
impl IShapeAspect for PlacedDatumTargetFeature {
    fn name(&self) -> &Label {
        &self.name
    }
    fn description(&self) -> &Option<Text> {
        &self.description
    }
    fn of_shape(&self) -> &EntityRef {
        &self.of_shape
    }
    fn product_definitional(&self) -> Option<bool> {
        self.product_definitional
    }
}
impl IDatumTarget for PlacedDatumTargetFeature {
    fn target_id(&self) -> &Identifier {
        &self.target_id
    }
}
impl IPlacedDatumTargetFeature for PlacedDatumTargetFeature {}
impl PlacedDatumTargetFeature {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = PlacedDatumTargetFeature::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => entity.of_shape = parameter.into(),
                3usize => entity.product_definitional = parameter.into(),
                4usize => entity.target_id = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IPlacedFeature: IShapeAspect {}
#[derive(Default, Debug)]
pub struct PlacedFeature {
    name: Label,
    description: Option<Text>,
    of_shape: EntityRef,
    product_definitional: Option<bool>,
}
impl IShapeAspect for PlacedFeature {
    fn name(&self) -> &Label {
        &self.name
    }
    fn description(&self) -> &Option<Text> {
        &self.description
    }
    fn of_shape(&self) -> &EntityRef {
        &self.of_shape
    }
    fn product_definitional(&self) -> Option<bool> {
        self.product_definitional
    }
}
impl IPlacedFeature for PlacedFeature {}
impl PlacedFeature {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = PlacedFeature::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => entity.of_shape = parameter.into(),
                3usize => entity.product_definitional = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IPlacement: IGeometricRepresentationItem {
    fn location(&self) -> &EntityRef;
}
#[derive(Default, Debug)]
pub struct Placement {
    name: Label,
    location: EntityRef,
}
impl IRepresentationItem for Placement {
    fn name(&self) -> &Label {
        &self.name
    }
}
impl IGeometricRepresentationItem for Placement {}
impl IPlacement for Placement {
    fn location(&self) -> &EntityRef {
        &self.location
    }
}
impl Placement {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = Placement::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => entity.location = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IPlanarBox: IPlanarExtent {
    fn placement(&self) -> &EntityRef;
}
#[derive(Default, Debug)]
pub struct PlanarBox {
    name: Label,
    size_in_x: LengthMeasure,
    size_in_y: LengthMeasure,
    placement: EntityRef,
}
impl IRepresentationItem for PlanarBox {
    fn name(&self) -> &Label {
        &self.name
    }
}
impl IGeometricRepresentationItem for PlanarBox {}
impl IPlanarExtent for PlanarBox {
    fn size_in_x(&self) -> &LengthMeasure {
        &self.size_in_x
    }
    fn size_in_y(&self) -> &LengthMeasure {
        &self.size_in_y
    }
}
impl IPlanarBox for PlanarBox {
    fn placement(&self) -> &EntityRef {
        &self.placement
    }
}
impl PlanarBox {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = PlanarBox::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => entity.size_in_x = parameter.into(),
                2usize => entity.size_in_y = parameter.into(),
                3usize => entity.placement = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IPlanarCurvePair: IKinematicPair {
    fn curve_1(&self) -> &EntityRef;
    fn curve_2(&self) -> &EntityRef;
    fn orientation(&self) -> bool;
}
#[derive(Default, Debug)]
pub struct PlanarCurvePair {
    name: Label,
    description: Option<Text>,
    transform_item_1: EntityRef,
    transform_item_2: EntityRef,
    joint: EntityRef,
    curve_1: EntityRef,
    curve_2: EntityRef,
    orientation: bool,
}
impl IItemDefinedTransformation for PlanarCurvePair {
    fn name(&self) -> &Label {
        &self.name
    }
    fn description(&self) -> &Option<Text> {
        &self.description
    }
    fn transform_item_1(&self) -> &EntityRef {
        &self.transform_item_1
    }
    fn transform_item_2(&self) -> &EntityRef {
        &self.transform_item_2
    }
}
impl IKinematicPair for PlanarCurvePair {
    fn joint(&self) -> &EntityRef {
        &self.joint
    }
}
impl IPlanarCurvePair for PlanarCurvePair {
    fn curve_1(&self) -> &EntityRef {
        &self.curve_1
    }
    fn curve_2(&self) -> &EntityRef {
        &self.curve_2
    }
    fn orientation(&self) -> bool {
        self.orientation
    }
}
impl PlanarCurvePair {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = PlanarCurvePair::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => entity.transform_item_1 = parameter.into(),
                3usize => entity.transform_item_2 = parameter.into(),
                4usize => entity.joint = parameter.into(),
                5usize => entity.curve_1 = parameter.into(),
                6usize => entity.curve_2 = parameter.into(),
                7usize => entity.orientation = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IPlanarCurvePairRange: ISimplePairRange {
    fn applies_to_pair(&self) -> &EntityRef;
    fn range_on_curve_1(&self) -> &EntityRef;
    fn range_on_curve_2(&self) -> &EntityRef;
}
#[derive(Default, Debug)]
pub struct PlanarCurvePairRange {
    applies_to_pair: EntityRef,
    range_on_curve_1: EntityRef,
    range_on_curve_2: EntityRef,
}
impl ISimplePairRange for PlanarCurvePairRange {
    fn applies_to_pair(&self) -> &EntityRef {
        &self.applies_to_pair
    }
}
impl IPlanarCurvePairRange for PlanarCurvePairRange {
    fn applies_to_pair(&self) -> &EntityRef {
        &self.applies_to_pair
    }
    fn range_on_curve_1(&self) -> &EntityRef {
        &self.range_on_curve_1
    }
    fn range_on_curve_2(&self) -> &EntityRef {
        &self.range_on_curve_2
    }
}
impl PlanarCurvePairRange {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = PlanarCurvePairRange::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.applies_to_pair = parameter.into(),
                1usize => entity.range_on_curve_1 = parameter.into(),
                2usize => entity.range_on_curve_2 = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IPlanarExtent: IGeometricRepresentationItem {
    fn size_in_x(&self) -> &LengthMeasure;
    fn size_in_y(&self) -> &LengthMeasure;
}
#[derive(Default, Debug)]
pub struct PlanarExtent {
    name: Label,
    size_in_x: LengthMeasure,
    size_in_y: LengthMeasure,
}
impl IRepresentationItem for PlanarExtent {
    fn name(&self) -> &Label {
        &self.name
    }
}
impl IGeometricRepresentationItem for PlanarExtent {}
impl IPlanarExtent for PlanarExtent {
    fn size_in_x(&self) -> &LengthMeasure {
        &self.size_in_x
    }
    fn size_in_y(&self) -> &LengthMeasure {
        &self.size_in_y
    }
}
impl PlanarExtent {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = PlanarExtent::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => entity.size_in_x = parameter.into(),
                2usize => entity.size_in_y = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IPlanarPair: IKinematicPair {}
#[derive(Default, Debug)]
pub struct PlanarPair {
    name: Label,
    description: Option<Text>,
    transform_item_1: EntityRef,
    transform_item_2: EntityRef,
    joint: EntityRef,
}
impl IItemDefinedTransformation for PlanarPair {
    fn name(&self) -> &Label {
        &self.name
    }
    fn description(&self) -> &Option<Text> {
        &self.description
    }
    fn transform_item_1(&self) -> &EntityRef {
        &self.transform_item_1
    }
    fn transform_item_2(&self) -> &EntityRef {
        &self.transform_item_2
    }
}
impl IKinematicPair for PlanarPair {
    fn joint(&self) -> &EntityRef {
        &self.joint
    }
}
impl IPlanarPair for PlanarPair {}
impl PlanarPair {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = PlanarPair::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => entity.transform_item_1 = parameter.into(),
                3usize => entity.transform_item_2 = parameter.into(),
                4usize => entity.joint = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IPlanarPairRange: ISimplePairRange {
    fn applies_to_pair(&self) -> &EntityRef;
    fn lower_limit_actual_rotation(&self) -> &RotationalRangeMeasure;
    fn upper_limit_actual_rotation(&self) -> &RotationalRangeMeasure;
    fn lower_limit_actual_translation_x(&self) -> &TranslationalRangeMeasure;
    fn upper_limit_actual_translation_x(&self) -> &TranslationalRangeMeasure;
    fn lower_limit_actual_translation_y(&self) -> &TranslationalRangeMeasure;
    fn upper_limit_actual_translation_y(&self) -> &TranslationalRangeMeasure;
}
#[derive(Default, Debug)]
pub struct PlanarPairRange {
    applies_to_pair: EntityRef,
    lower_limit_actual_rotation: RotationalRangeMeasure,
    upper_limit_actual_rotation: RotationalRangeMeasure,
    lower_limit_actual_translation_x: TranslationalRangeMeasure,
    upper_limit_actual_translation_x: TranslationalRangeMeasure,
    lower_limit_actual_translation_y: TranslationalRangeMeasure,
    upper_limit_actual_translation_y: TranslationalRangeMeasure,
}
impl ISimplePairRange for PlanarPairRange {
    fn applies_to_pair(&self) -> &EntityRef {
        &self.applies_to_pair
    }
}
impl IPlanarPairRange for PlanarPairRange {
    fn applies_to_pair(&self) -> &EntityRef {
        &self.applies_to_pair
    }
    fn lower_limit_actual_rotation(&self) -> &RotationalRangeMeasure {
        &self.lower_limit_actual_rotation
    }
    fn upper_limit_actual_rotation(&self) -> &RotationalRangeMeasure {
        &self.upper_limit_actual_rotation
    }
    fn lower_limit_actual_translation_x(&self) -> &TranslationalRangeMeasure {
        &self.lower_limit_actual_translation_x
    }
    fn upper_limit_actual_translation_x(&self) -> &TranslationalRangeMeasure {
        &self.upper_limit_actual_translation_x
    }
    fn lower_limit_actual_translation_y(&self) -> &TranslationalRangeMeasure {
        &self.lower_limit_actual_translation_y
    }
    fn upper_limit_actual_translation_y(&self) -> &TranslationalRangeMeasure {
        &self.upper_limit_actual_translation_y
    }
}
impl PlanarPairRange {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = PlanarPairRange::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.applies_to_pair = parameter.into(),
                1usize => entity.lower_limit_actual_rotation = parameter.into(),
                2usize => entity.upper_limit_actual_rotation = parameter.into(),
                3usize => entity.lower_limit_actual_translation_x = parameter.into(),
                4usize => entity.upper_limit_actual_translation_x = parameter.into(),
                5usize => entity.lower_limit_actual_translation_y = parameter.into(),
                6usize => entity.upper_limit_actual_translation_y = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IPlanarPairValue: IPairValue {
    fn applies_to_pair(&self) -> &EntityRef;
    fn actual_rotation(&self) -> &PlaneAngleMeasure;
    fn actual_translation_x(&self) -> &LengthMeasure;
    fn actual_translation_y(&self) -> &LengthMeasure;
}
#[derive(Default, Debug)]
pub struct PlanarPairValue {
    applies_to_pair: EntityRef,
    actual_rotation: PlaneAngleMeasure,
    actual_translation_x: LengthMeasure,
    actual_translation_y: LengthMeasure,
}
impl IPairValue for PlanarPairValue {
    fn applies_to_pair(&self) -> &EntityRef {
        &self.applies_to_pair
    }
}
impl IPlanarPairValue for PlanarPairValue {
    fn applies_to_pair(&self) -> &EntityRef {
        &self.applies_to_pair
    }
    fn actual_rotation(&self) -> &PlaneAngleMeasure {
        &self.actual_rotation
    }
    fn actual_translation_x(&self) -> &LengthMeasure {
        &self.actual_translation_x
    }
    fn actual_translation_y(&self) -> &LengthMeasure {
        &self.actual_translation_y
    }
}
impl PlanarPairValue {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = PlanarPairValue::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.applies_to_pair = parameter.into(),
                1usize => entity.actual_rotation = parameter.into(),
                2usize => entity.actual_translation_x = parameter.into(),
                3usize => entity.actual_translation_y = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IPlanarShapeRepresentation: IShapeRepresentation {}
#[derive(Default, Debug)]
pub struct PlanarShapeRepresentation {
    name: Label,
    items: HashSet<EntityRef>,
    context_of_items: EntityRef,
}
impl IRepresentation for PlanarShapeRepresentation {
    fn name(&self) -> &Label {
        &self.name
    }
    fn items(&self) -> &HashSet<EntityRef> {
        &self.items
    }
    fn context_of_items(&self) -> &EntityRef {
        &self.context_of_items
    }
}
impl IShapeRepresentation for PlanarShapeRepresentation {}
impl IPlanarShapeRepresentation for PlanarShapeRepresentation {}
impl PlanarShapeRepresentation {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = PlanarShapeRepresentation::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => entity.items = parameter.into(),
                2usize => entity.context_of_items = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IPlane: IElementarySurface {}
#[derive(Default, Debug)]
pub struct Plane {
    name: Label,
    position: EntityRef,
}
impl IRepresentationItem for Plane {
    fn name(&self) -> &Label {
        &self.name
    }
}
impl IGeometricRepresentationItem for Plane {}
impl ISurface for Plane {}
impl IElementarySurface for Plane {
    fn position(&self) -> &EntityRef {
        &self.position
    }
}
impl IPlane for Plane {}
impl Plane {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = Plane::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => entity.position = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IPlaneAngleMeasureWithUnit: IMeasureWithUnit {}
#[derive(Default, Debug)]
pub struct PlaneAngleMeasureWithUnit {
    value_component: MeasureValue,
    unit_component: EntityRef,
}
impl IMeasureWithUnit for PlaneAngleMeasureWithUnit {
    fn value_component(&self) -> &MeasureValue {
        &self.value_component
    }
    fn unit_component(&self) -> &EntityRef {
        &self.unit_component
    }
}
impl IPlaneAngleMeasureWithUnit for PlaneAngleMeasureWithUnit {}
impl PlaneAngleMeasureWithUnit {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = PlaneAngleMeasureWithUnit::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.value_component = parameter.into(),
                1usize => entity.unit_component = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IPlaneAngleUnit: INamedUnit {}
#[derive(Default, Debug)]
pub struct PlaneAngleUnit {
    dimensions: EntityRef,
}
impl INamedUnit for PlaneAngleUnit {
    fn dimensions(&self) -> &EntityRef {
        &self.dimensions
    }
}
impl IPlaneAngleUnit for PlaneAngleUnit {}
impl PlaneAngleUnit {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = PlaneAngleUnit::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.dimensions = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IPlusExpression: IMultipleArityNumericExpression {}
#[derive(Default, Debug)]
pub struct PlusExpression {
    operands: Vec<EntityRef>,
}
impl IGenericExpression for PlusExpression {}
impl IExpression for PlusExpression {}
impl INumericExpression for PlusExpression {}
impl IMultipleArityNumericExpression for PlusExpression {
    fn operands(&self) -> &Vec<EntityRef> {
        &self.operands
    }
}
impl IMultipleArityGenericExpression for PlusExpression {
    fn operands(&self) -> &Vec<EntityRef> {
        &self.operands
    }
}
impl IPlusExpression for PlusExpression {}
impl PlusExpression {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = PlusExpression::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.operands = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IPlusMinusTolerance {
    fn range(&self) -> &EntityRef;
    fn toleranced_dimension(&self) -> &EntityRef;
}
#[derive(Default, Debug)]
pub struct PlusMinusTolerance {
    range: EntityRef,
    toleranced_dimension: EntityRef,
}
impl IPlusMinusTolerance for PlusMinusTolerance {
    fn range(&self) -> &EntityRef {
        &self.range
    }
    fn toleranced_dimension(&self) -> &EntityRef {
        &self.toleranced_dimension
    }
}
impl PlusMinusTolerance {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = PlusMinusTolerance::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.range = parameter.into(),
                1usize => entity.toleranced_dimension = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IPocket: IFeatureDefinition {}
#[derive(Default, Debug)]
pub struct Pocket {
    name: Label,
    description: Option<Text>,
}
impl ICharacterizedObject for Pocket {
    fn name(&self) -> &Label {
        &self.name
    }
    fn description(&self) -> &Option<Text> {
        &self.description
    }
}
impl IFeatureDefinition for Pocket {}
impl IPocket for Pocket {}
impl Pocket {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = Pocket::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
}
pub trait IPocketBottom: IShapeAspect {}
#[derive(Default, Debug)]
pub struct PocketBottom {
    name: Label,
    description: Option<Text>,
    of_shape: EntityRef,
    product_definitional: Option<bool>,
}
impl IShapeAspect for PocketBottom {
    fn name(&self) -> &Label {
        &self.name
    }
    fn description(&self) -> &Option<Text> {
        &self.description
    }
    fn of_shape(&self) -> &EntityRef {
        &self.of_shape
    }
    fn product_definitional(&self) -> Option<bool> {
        self.product_definitional
    }
}
impl IPocketBottom for PocketBottom {}
impl PocketBottom {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = PocketBottom::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => entity.of_shape = parameter.into(),
                3usize => entity.product_definitional = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IPoint: IGeometricRepresentationItem {}
#[derive(Default, Debug)]
pub struct Point {
    name: Label,
}
impl IRepresentationItem for Point {
    fn name(&self) -> &Label {
        &self.name
    }
}
impl IGeometricRepresentationItem for Point {}
impl IPoint for Point {}
impl Point {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = Point::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IPointOnCurve: IPoint {
    fn basis_curve(&self) -> &EntityRef;
    fn point_parameter(&self) -> &ParameterValue;
}
#[derive(Default, Debug)]
pub struct PointOnCurve {
    name: Label,
    basis_curve: EntityRef,
    point_parameter: ParameterValue,
}
impl IRepresentationItem for PointOnCurve {
    fn name(&self) -> &Label {
        &self.name
    }
}
impl IGeometricRepresentationItem for PointOnCurve {}
impl IPoint for PointOnCurve {}
impl IPointOnCurve for PointOnCurve {
    fn basis_curve(&self) -> &EntityRef {
        &self.basis_curve
    }
    fn point_parameter(&self) -> &ParameterValue {
        &self.point_parameter
    }
}
impl PointOnCurve {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = PointOnCurve::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => entity.basis_curve = parameter.into(),
                2usize => entity.point_parameter = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IPointOnPlanarCurvePair: IKinematicPair {
    fn pair_curve(&self) -> &EntityRef;
    fn orientation(&self) -> bool;
}
#[derive(Default, Debug)]
pub struct PointOnPlanarCurvePair {
    name: Label,
    description: Option<Text>,
    transform_item_1: EntityRef,
    transform_item_2: EntityRef,
    joint: EntityRef,
    pair_curve: EntityRef,
    orientation: bool,
}
impl IItemDefinedTransformation for PointOnPlanarCurvePair {
    fn name(&self) -> &Label {
        &self.name
    }
    fn description(&self) -> &Option<Text> {
        &self.description
    }
    fn transform_item_1(&self) -> &EntityRef {
        &self.transform_item_1
    }
    fn transform_item_2(&self) -> &EntityRef {
        &self.transform_item_2
    }
}
impl IKinematicPair for PointOnPlanarCurvePair {
    fn joint(&self) -> &EntityRef {
        &self.joint
    }
}
impl IPointOnPlanarCurvePair for PointOnPlanarCurvePair {
    fn pair_curve(&self) -> &EntityRef {
        &self.pair_curve
    }
    fn orientation(&self) -> bool {
        self.orientation
    }
}
impl PointOnPlanarCurvePair {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = PointOnPlanarCurvePair::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => entity.transform_item_1 = parameter.into(),
                3usize => entity.transform_item_2 = parameter.into(),
                4usize => entity.joint = parameter.into(),
                5usize => entity.pair_curve = parameter.into(),
                6usize => entity.orientation = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IPointOnPlanarCurvePairRange: ISimplePairRange {
    fn applies_to_pair(&self) -> &EntityRef;
    fn range_on_pair_curve(&self) -> &EntityRef;
    fn lower_limit_yaw(&self) -> &RotationalRangeMeasure;
    fn upper_limit_yaw(&self) -> &RotationalRangeMeasure;
    fn lower_limit_pitch(&self) -> &RotationalRangeMeasure;
    fn upper_limit_pitch(&self) -> &RotationalRangeMeasure;
    fn lower_limit_roll(&self) -> &RotationalRangeMeasure;
    fn upper_limit_roll(&self) -> &RotationalRangeMeasure;
}
#[derive(Default, Debug)]
pub struct PointOnPlanarCurvePairRange {
    applies_to_pair: EntityRef,
    range_on_pair_curve: EntityRef,
    lower_limit_yaw: RotationalRangeMeasure,
    upper_limit_yaw: RotationalRangeMeasure,
    lower_limit_pitch: RotationalRangeMeasure,
    upper_limit_pitch: RotationalRangeMeasure,
    lower_limit_roll: RotationalRangeMeasure,
    upper_limit_roll: RotationalRangeMeasure,
}
impl ISimplePairRange for PointOnPlanarCurvePairRange {
    fn applies_to_pair(&self) -> &EntityRef {
        &self.applies_to_pair
    }
}
impl IPointOnPlanarCurvePairRange for PointOnPlanarCurvePairRange {
    fn applies_to_pair(&self) -> &EntityRef {
        &self.applies_to_pair
    }
    fn range_on_pair_curve(&self) -> &EntityRef {
        &self.range_on_pair_curve
    }
    fn lower_limit_yaw(&self) -> &RotationalRangeMeasure {
        &self.lower_limit_yaw
    }
    fn upper_limit_yaw(&self) -> &RotationalRangeMeasure {
        &self.upper_limit_yaw
    }
    fn lower_limit_pitch(&self) -> &RotationalRangeMeasure {
        &self.lower_limit_pitch
    }
    fn upper_limit_pitch(&self) -> &RotationalRangeMeasure {
        &self.upper_limit_pitch
    }
    fn lower_limit_roll(&self) -> &RotationalRangeMeasure {
        &self.lower_limit_roll
    }
    fn upper_limit_roll(&self) -> &RotationalRangeMeasure {
        &self.upper_limit_roll
    }
}
impl PointOnPlanarCurvePairRange {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = PointOnPlanarCurvePairRange::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.applies_to_pair = parameter.into(),
                1usize => entity.range_on_pair_curve = parameter.into(),
                2usize => entity.lower_limit_yaw = parameter.into(),
                3usize => entity.upper_limit_yaw = parameter.into(),
                4usize => entity.lower_limit_pitch = parameter.into(),
                5usize => entity.upper_limit_pitch = parameter.into(),
                6usize => entity.lower_limit_roll = parameter.into(),
                7usize => entity.upper_limit_roll = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IPointOnPlanarCurvePairValue: IPairValue {
    fn applies_to_pair(&self) -> &EntityRef;
    fn actual_point_on_curve(&self) -> &EntityRef;
    fn input_orientation(&self) -> &SpatialRotation;
}
#[derive(Default, Debug)]
pub struct PointOnPlanarCurvePairValue {
    applies_to_pair: EntityRef,
    actual_point_on_curve: EntityRef,
    input_orientation: SpatialRotation,
}
impl IPairValue for PointOnPlanarCurvePairValue {
    fn applies_to_pair(&self) -> &EntityRef {
        &self.applies_to_pair
    }
}
impl IPointOnPlanarCurvePairValue for PointOnPlanarCurvePairValue {
    fn applies_to_pair(&self) -> &EntityRef {
        &self.applies_to_pair
    }
    fn actual_point_on_curve(&self) -> &EntityRef {
        &self.actual_point_on_curve
    }
    fn input_orientation(&self) -> &SpatialRotation {
        &self.input_orientation
    }
}
impl PointOnPlanarCurvePairValue {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = PointOnPlanarCurvePairValue::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.applies_to_pair = parameter.into(),
                1usize => entity.actual_point_on_curve = parameter.into(),
                2usize => entity.input_orientation = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IPointOnSurface: IPoint {
    fn basis_surface(&self) -> &EntityRef;
    fn point_parameter_u(&self) -> &ParameterValue;
    fn point_parameter_v(&self) -> &ParameterValue;
}
#[derive(Default, Debug)]
pub struct PointOnSurface {
    name: Label,
    basis_surface: EntityRef,
    point_parameter_u: ParameterValue,
    point_parameter_v: ParameterValue,
}
impl IRepresentationItem for PointOnSurface {
    fn name(&self) -> &Label {
        &self.name
    }
}
impl IGeometricRepresentationItem for PointOnSurface {}
impl IPoint for PointOnSurface {}
impl IPointOnSurface for PointOnSurface {
    fn basis_surface(&self) -> &EntityRef {
        &self.basis_surface
    }
    fn point_parameter_u(&self) -> &ParameterValue {
        &self.point_parameter_u
    }
    fn point_parameter_v(&self) -> &ParameterValue {
        &self.point_parameter_v
    }
}
impl PointOnSurface {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = PointOnSurface::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => entity.basis_surface = parameter.into(),
                2usize => entity.point_parameter_u = parameter.into(),
                3usize => entity.point_parameter_v = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IPointOnSurfacePair: IKinematicPair {
    fn pair_surface(&self) -> &EntityRef;
}
#[derive(Default, Debug)]
pub struct PointOnSurfacePair {
    name: Label,
    description: Option<Text>,
    transform_item_1: EntityRef,
    transform_item_2: EntityRef,
    joint: EntityRef,
    pair_surface: EntityRef,
}
impl IItemDefinedTransformation for PointOnSurfacePair {
    fn name(&self) -> &Label {
        &self.name
    }
    fn description(&self) -> &Option<Text> {
        &self.description
    }
    fn transform_item_1(&self) -> &EntityRef {
        &self.transform_item_1
    }
    fn transform_item_2(&self) -> &EntityRef {
        &self.transform_item_2
    }
}
impl IKinematicPair for PointOnSurfacePair {
    fn joint(&self) -> &EntityRef {
        &self.joint
    }
}
impl IPointOnSurfacePair for PointOnSurfacePair {
    fn pair_surface(&self) -> &EntityRef {
        &self.pair_surface
    }
}
impl PointOnSurfacePair {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = PointOnSurfacePair::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => entity.transform_item_1 = parameter.into(),
                3usize => entity.transform_item_2 = parameter.into(),
                4usize => entity.joint = parameter.into(),
                5usize => entity.pair_surface = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IPointOnSurfacePairRange: ISimplePairRange {
    fn applies_to_pair(&self) -> &EntityRef;
    fn range_on_pair_surface(&self) -> &EntityRef;
    fn lower_limit_yaw(&self) -> &RotationalRangeMeasure;
    fn upper_limit_yaw(&self) -> &RotationalRangeMeasure;
    fn lower_limit_pitch(&self) -> &RotationalRangeMeasure;
    fn upper_limit_pitch(&self) -> &RotationalRangeMeasure;
    fn lower_limit_roll(&self) -> &RotationalRangeMeasure;
    fn upper_limit_roll(&self) -> &RotationalRangeMeasure;
}
#[derive(Default, Debug)]
pub struct PointOnSurfacePairRange {
    applies_to_pair: EntityRef,
    range_on_pair_surface: EntityRef,
    lower_limit_yaw: RotationalRangeMeasure,
    upper_limit_yaw: RotationalRangeMeasure,
    lower_limit_pitch: RotationalRangeMeasure,
    upper_limit_pitch: RotationalRangeMeasure,
    lower_limit_roll: RotationalRangeMeasure,
    upper_limit_roll: RotationalRangeMeasure,
}
impl ISimplePairRange for PointOnSurfacePairRange {
    fn applies_to_pair(&self) -> &EntityRef {
        &self.applies_to_pair
    }
}
impl IPointOnSurfacePairRange for PointOnSurfacePairRange {
    fn applies_to_pair(&self) -> &EntityRef {
        &self.applies_to_pair
    }
    fn range_on_pair_surface(&self) -> &EntityRef {
        &self.range_on_pair_surface
    }
    fn lower_limit_yaw(&self) -> &RotationalRangeMeasure {
        &self.lower_limit_yaw
    }
    fn upper_limit_yaw(&self) -> &RotationalRangeMeasure {
        &self.upper_limit_yaw
    }
    fn lower_limit_pitch(&self) -> &RotationalRangeMeasure {
        &self.lower_limit_pitch
    }
    fn upper_limit_pitch(&self) -> &RotationalRangeMeasure {
        &self.upper_limit_pitch
    }
    fn lower_limit_roll(&self) -> &RotationalRangeMeasure {
        &self.lower_limit_roll
    }
    fn upper_limit_roll(&self) -> &RotationalRangeMeasure {
        &self.upper_limit_roll
    }
}
impl PointOnSurfacePairRange {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = PointOnSurfacePairRange::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.applies_to_pair = parameter.into(),
                1usize => entity.range_on_pair_surface = parameter.into(),
                2usize => entity.lower_limit_yaw = parameter.into(),
                3usize => entity.upper_limit_yaw = parameter.into(),
                4usize => entity.lower_limit_pitch = parameter.into(),
                5usize => entity.upper_limit_pitch = parameter.into(),
                6usize => entity.lower_limit_roll = parameter.into(),
                7usize => entity.upper_limit_roll = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IPointOnSurfacePairValue: IPairValue {
    fn applies_to_pair(&self) -> &EntityRef;
    fn actual_point_on_surface(&self) -> &EntityRef;
    fn input_orientation(&self) -> &SpatialRotation;
}
#[derive(Default, Debug)]
pub struct PointOnSurfacePairValue {
    applies_to_pair: EntityRef,
    actual_point_on_surface: EntityRef,
    input_orientation: SpatialRotation,
}
impl IPairValue for PointOnSurfacePairValue {
    fn applies_to_pair(&self) -> &EntityRef {
        &self.applies_to_pair
    }
}
impl IPointOnSurfacePairValue for PointOnSurfacePairValue {
    fn applies_to_pair(&self) -> &EntityRef {
        &self.applies_to_pair
    }
    fn actual_point_on_surface(&self) -> &EntityRef {
        &self.actual_point_on_surface
    }
    fn input_orientation(&self) -> &SpatialRotation {
        &self.input_orientation
    }
}
impl PointOnSurfacePairValue {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = PointOnSurfacePairValue::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.applies_to_pair = parameter.into(),
                1usize => entity.actual_point_on_surface = parameter.into(),
                2usize => entity.input_orientation = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IPointPlacementShapeRepresentation: IShapeRepresentation {}
#[derive(Default, Debug)]
pub struct PointPlacementShapeRepresentation {
    name: Label,
    items: HashSet<EntityRef>,
    context_of_items: EntityRef,
}
impl IRepresentation for PointPlacementShapeRepresentation {
    fn name(&self) -> &Label {
        &self.name
    }
    fn items(&self) -> &HashSet<EntityRef> {
        &self.items
    }
    fn context_of_items(&self) -> &EntityRef {
        &self.context_of_items
    }
}
impl IShapeRepresentation for PointPlacementShapeRepresentation {}
impl IPointPlacementShapeRepresentation for PointPlacementShapeRepresentation {}
impl PointPlacementShapeRepresentation {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = PointPlacementShapeRepresentation::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => entity.items = parameter.into(),
                2usize => entity.context_of_items = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IPointReplica: IPoint {
    fn parent_pt(&self) -> &EntityRef;
    fn transformation(&self) -> &EntityRef;
}
#[derive(Default, Debug)]
pub struct PointReplica {
    name: Label,
    parent_pt: EntityRef,
    transformation: EntityRef,
}
impl IRepresentationItem for PointReplica {
    fn name(&self) -> &Label {
        &self.name
    }
}
impl IGeometricRepresentationItem for PointReplica {}
impl IPoint for PointReplica {}
impl IPointReplica for PointReplica {
    fn parent_pt(&self) -> &EntityRef {
        &self.parent_pt
    }
    fn transformation(&self) -> &EntityRef {
        &self.transformation
    }
}
impl PointReplica {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = PointReplica::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => entity.parent_pt = parameter.into(),
                2usize => entity.transformation = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IPointStyle: IFoundedItem {
    fn name(&self) -> &Label;
    fn marker(&self) -> &MarkerSelect;
    fn marker_size(&self) -> &SizeSelect;
    fn marker_colour(&self) -> &EntityRef;
}
#[derive(Default, Debug)]
pub struct PointStyle {
    name: Label,
    marker: MarkerSelect,
    marker_size: SizeSelect,
    marker_colour: EntityRef,
}
impl IFoundedItem for PointStyle {}
impl IPointStyle for PointStyle {
    fn name(&self) -> &Label {
        &self.name
    }
    fn marker(&self) -> &MarkerSelect {
        &self.marker
    }
    fn marker_size(&self) -> &SizeSelect {
        &self.marker_size
    }
    fn marker_colour(&self) -> &EntityRef {
        &self.marker_colour
    }
}
impl PointStyle {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = PointStyle::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => entity.marker = parameter.into(),
                2usize => entity.marker_size = parameter.into(),
                3usize => entity.marker_colour = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IPolyLoop: ILoop + IGeometricRepresentationItem {
    fn polygon(&self) -> &Vec<EntityRef>;
}
#[derive(Default, Debug)]
pub struct PolyLoop {
    name: Label,
    polygon: Vec<EntityRef>,
}
impl IRepresentationItem for PolyLoop {
    fn name(&self) -> &Label {
        &self.name
    }
}
impl ITopologicalRepresentationItem for PolyLoop {}
impl ILoop for PolyLoop {}
impl IPolyLoop for PolyLoop {
    fn polygon(&self) -> &Vec<EntityRef> {
        &self.polygon
    }
}
impl IGeometricRepresentationItem for PolyLoop {}
impl PolyLoop {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = PolyLoop::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => entity.polygon = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IPolyline: IBoundedCurve {
    fn points(&self) -> &Vec<EntityRef>;
}
#[derive(Default, Debug)]
pub struct Polyline {
    name: Label,
    points: Vec<EntityRef>,
}
impl IRepresentationItem for Polyline {
    fn name(&self) -> &Label {
        &self.name
    }
}
impl IGeometricRepresentationItem for Polyline {}
impl ICurve for Polyline {}
impl IBoundedCurve for Polyline {}
impl IPolyline for Polyline {
    fn points(&self) -> &Vec<EntityRef> {
        &self.points
    }
}
impl Polyline {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = Polyline::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => entity.points = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IPositionTolerance: IGeometricTolerance {}
#[derive(Default, Debug)]
pub struct PositionTolerance {
    name: Label,
    description: Text,
    magnitude: EntityRef,
    toleranced_shape_aspect: EntityRef,
}
impl IGeometricTolerance for PositionTolerance {
    fn name(&self) -> &Label {
        &self.name
    }
    fn description(&self) -> &Text {
        &self.description
    }
    fn magnitude(&self) -> &EntityRef {
        &self.magnitude
    }
    fn toleranced_shape_aspect(&self) -> &EntityRef {
        &self.toleranced_shape_aspect
    }
}
impl IPositionTolerance for PositionTolerance {}
impl PositionTolerance {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = PositionTolerance::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => entity.description = parameter.into(),
                2usize => entity.magnitude = parameter.into(),
                3usize => entity.toleranced_shape_aspect = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IPowerExpression: IBinaryNumericExpression {}
#[derive(Default, Debug)]
pub struct PowerExpression {
    operands: Vec<EntityRef>,
}
impl IGenericExpression for PowerExpression {}
impl IExpression for PowerExpression {}
impl INumericExpression for PowerExpression {}
impl IBinaryNumericExpression for PowerExpression {
    fn operands(&self) -> &Vec<EntityRef> {
        &self.operands
    }
}
impl IBinaryGenericExpression for PowerExpression {
    fn operands(&self) -> &Vec<EntityRef> {
        &self.operands
    }
}
impl IPowerExpression for PowerExpression {}
impl PowerExpression {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = PowerExpression::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.operands = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IPreDefinedColour: IPreDefinedItem + IColour {}
#[derive(Default, Debug)]
pub struct PreDefinedColour {
    name: Label,
}
impl IPreDefinedItem for PreDefinedColour {
    fn name(&self) -> &Label {
        &self.name
    }
}
impl IColour for PreDefinedColour {}
impl IPreDefinedColour for PreDefinedColour {}
impl PreDefinedColour {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = PreDefinedColour::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IPreDefinedCurveFont: IPreDefinedItem {}
#[derive(Default, Debug)]
pub struct PreDefinedCurveFont {
    name: Label,
}
impl IPreDefinedItem for PreDefinedCurveFont {
    fn name(&self) -> &Label {
        &self.name
    }
}
impl IPreDefinedCurveFont for PreDefinedCurveFont {}
impl PreDefinedCurveFont {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = PreDefinedCurveFont::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IPreDefinedDimensionSymbol: IPreDefinedSymbol {}
#[derive(Default, Debug)]
pub struct PreDefinedDimensionSymbol {
    name: Label,
}
impl IPreDefinedItem for PreDefinedDimensionSymbol {
    fn name(&self) -> &Label {
        &self.name
    }
}
impl IPreDefinedSymbol for PreDefinedDimensionSymbol {}
impl IPreDefinedDimensionSymbol for PreDefinedDimensionSymbol {}
impl PreDefinedDimensionSymbol {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = PreDefinedDimensionSymbol::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IPreDefinedGeometricalToleranceSymbol: IPreDefinedSymbol {}
#[derive(Default, Debug)]
pub struct PreDefinedGeometricalToleranceSymbol {
    name: Label,
}
impl IPreDefinedItem for PreDefinedGeometricalToleranceSymbol {
    fn name(&self) -> &Label {
        &self.name
    }
}
impl IPreDefinedSymbol for PreDefinedGeometricalToleranceSymbol {}
impl IPreDefinedGeometricalToleranceSymbol for PreDefinedGeometricalToleranceSymbol {}
impl PreDefinedGeometricalToleranceSymbol {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = PreDefinedGeometricalToleranceSymbol::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IPreDefinedItem {
    fn name(&self) -> &Label;
}
#[derive(Default, Debug)]
pub struct PreDefinedItem {
    name: Label,
}
impl IPreDefinedItem for PreDefinedItem {
    fn name(&self) -> &Label {
        &self.name
    }
}
impl PreDefinedItem {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = PreDefinedItem::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IPreDefinedMarker: IPreDefinedItem {}
#[derive(Default, Debug)]
pub struct PreDefinedMarker {
    name: Label,
}
impl IPreDefinedItem for PreDefinedMarker {
    fn name(&self) -> &Label {
        &self.name
    }
}
impl IPreDefinedMarker for PreDefinedMarker {}
impl PreDefinedMarker {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = PreDefinedMarker::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IPreDefinedPointMarkerSymbol: IPreDefinedMarker + IPreDefinedSymbol {}
#[derive(Default, Debug)]
pub struct PreDefinedPointMarkerSymbol {
    name: Label,
}
impl IPreDefinedItem for PreDefinedPointMarkerSymbol {
    fn name(&self) -> &Label {
        &self.name
    }
}
impl IPreDefinedMarker for PreDefinedPointMarkerSymbol {}
impl IPreDefinedPointMarkerSymbol for PreDefinedPointMarkerSymbol {}
impl IPreDefinedSymbol for PreDefinedPointMarkerSymbol {}
impl PreDefinedPointMarkerSymbol {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = PreDefinedPointMarkerSymbol::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IPreDefinedPresentationStyle: IFoundedItem + IPreDefinedItem {}
#[derive(Default, Debug)]
pub struct PreDefinedPresentationStyle {
    name: Label,
}
impl IFoundedItem for PreDefinedPresentationStyle {}
impl IPreDefinedItem for PreDefinedPresentationStyle {
    fn name(&self) -> &Label {
        &self.name
    }
}
impl IPreDefinedPresentationStyle for PreDefinedPresentationStyle {}
impl PreDefinedPresentationStyle {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = PreDefinedPresentationStyle::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IPreDefinedSurfaceConditionSymbol: IPreDefinedSymbol {}
#[derive(Default, Debug)]
pub struct PreDefinedSurfaceConditionSymbol {
    name: Label,
}
impl IPreDefinedItem for PreDefinedSurfaceConditionSymbol {
    fn name(&self) -> &Label {
        &self.name
    }
}
impl IPreDefinedSymbol for PreDefinedSurfaceConditionSymbol {}
impl IPreDefinedSurfaceConditionSymbol for PreDefinedSurfaceConditionSymbol {}
impl PreDefinedSurfaceConditionSymbol {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = PreDefinedSurfaceConditionSymbol::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IPreDefinedSymbol: IPreDefinedItem {}
#[derive(Default, Debug)]
pub struct PreDefinedSymbol {
    name: Label,
}
impl IPreDefinedItem for PreDefinedSymbol {
    fn name(&self) -> &Label {
        &self.name
    }
}
impl IPreDefinedSymbol for PreDefinedSymbol {}
impl PreDefinedSymbol {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = PreDefinedSymbol::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IPreDefinedTerminatorSymbol: IPreDefinedSymbol {}
#[derive(Default, Debug)]
pub struct PreDefinedTerminatorSymbol {
    name: Label,
}
impl IPreDefinedItem for PreDefinedTerminatorSymbol {
    fn name(&self) -> &Label {
        &self.name
    }
}
impl IPreDefinedSymbol for PreDefinedTerminatorSymbol {}
impl IPreDefinedTerminatorSymbol for PreDefinedTerminatorSymbol {}
impl PreDefinedTerminatorSymbol {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = PreDefinedTerminatorSymbol::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IPreDefinedTextFont: IPreDefinedItem {}
#[derive(Default, Debug)]
pub struct PreDefinedTextFont {
    name: Label,
}
impl IPreDefinedItem for PreDefinedTextFont {
    fn name(&self) -> &Label {
        &self.name
    }
}
impl IPreDefinedTextFont for PreDefinedTextFont {}
impl PreDefinedTextFont {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = PreDefinedTextFont::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IPrecisionQualifier {
    fn precision_value(&self) -> i64;
}
#[derive(Default, Debug)]
pub struct PrecisionQualifier {
    precision_value: i64,
}
impl IPrecisionQualifier for PrecisionQualifier {
    fn precision_value(&self) -> i64 {
        self.precision_value
    }
}
impl PrecisionQualifier {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = PrecisionQualifier::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.precision_value = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IPresentationArea: IPresentationRepresentation {}
#[derive(Default, Debug)]
pub struct PresentationArea {
    name: Label,
    items: HashSet<EntityRef>,
    context_of_items: EntityRef,
}
impl IRepresentation for PresentationArea {
    fn name(&self) -> &Label {
        &self.name
    }
    fn items(&self) -> &HashSet<EntityRef> {
        &self.items
    }
    fn context_of_items(&self) -> &EntityRef {
        &self.context_of_items
    }
}
impl IPresentationRepresentation for PresentationArea {
    fn context_of_items(&self) -> &EntityRef {
        &self.context_of_items
    }
}
impl IPresentationArea for PresentationArea {}
impl PresentationArea {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = PresentationArea::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => entity.items = parameter.into(),
                2usize => entity.context_of_items = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IPresentationLayerAssignment {
    fn name(&self) -> &Label;
    fn description(&self) -> &Text;
    fn assigned_items(&self) -> &HashSet<EntityRef>;
}
#[derive(Default, Debug)]
pub struct PresentationLayerAssignment {
    name: Label,
    description: Text,
    assigned_items: HashSet<EntityRef>,
}
impl IPresentationLayerAssignment for PresentationLayerAssignment {
    fn name(&self) -> &Label {
        &self.name
    }
    fn description(&self) -> &Text {
        &self.description
    }
    fn assigned_items(&self) -> &HashSet<EntityRef> {
        &self.assigned_items
    }
}
impl PresentationLayerAssignment {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = PresentationLayerAssignment::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => entity.description = parameter.into(),
                2usize => entity.assigned_items = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IPresentationRepresentation: IRepresentation {
    fn context_of_items(&self) -> &EntityRef;
}
#[derive(Default, Debug)]
pub struct PresentationRepresentation {
    name: Label,
    items: HashSet<EntityRef>,
    context_of_items: EntityRef,
}
impl IRepresentation for PresentationRepresentation {
    fn name(&self) -> &Label {
        &self.name
    }
    fn items(&self) -> &HashSet<EntityRef> {
        &self.items
    }
    fn context_of_items(&self) -> &EntityRef {
        &self.context_of_items
    }
}
impl IPresentationRepresentation for PresentationRepresentation {
    fn context_of_items(&self) -> &EntityRef {
        &self.context_of_items
    }
}
impl PresentationRepresentation {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = PresentationRepresentation::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => entity.items = parameter.into(),
                2usize => entity.context_of_items = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IPresentationSet {}
#[derive(Default, Debug)]
pub struct PresentationSet {}
impl IPresentationSet for PresentationSet {}
impl PresentationSet {
    pub fn form_parameters(_parameters: Vec<Parameter>) -> Self {
        PresentationSet::default()
    }
}
pub trait IPresentationSize {
    fn unit(&self) -> &EntityRef;
    fn size(&self) -> &EntityRef;
}
#[derive(Default, Debug)]
pub struct PresentationSize {
    unit: EntityRef,
    size: EntityRef,
}
impl IPresentationSize for PresentationSize {
    fn unit(&self) -> &EntityRef {
        &self.unit
    }
    fn size(&self) -> &EntityRef {
        &self.size
    }
}
impl PresentationSize {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = PresentationSize::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.unit = parameter.into(),
                1usize => entity.size = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IPresentationStyleAssignment: IFoundedItem {
    fn styles(&self) -> &HashSet<PresentationStyleSelect>;
}
#[derive(Default, Debug)]
pub struct PresentationStyleAssignment {
    styles: HashSet<PresentationStyleSelect>,
}
impl IFoundedItem for PresentationStyleAssignment {}
impl IPresentationStyleAssignment for PresentationStyleAssignment {
    fn styles(&self) -> &HashSet<PresentationStyleSelect> {
        &self.styles
    }
}
impl PresentationStyleAssignment {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = PresentationStyleAssignment::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.styles = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IPresentationStyleByContext: IPresentationStyleAssignment {
    fn style_context(&self) -> &EntityRef;
}
#[derive(Default, Debug)]
pub struct PresentationStyleByContext {
    styles: HashSet<PresentationStyleSelect>,
    style_context: EntityRef,
}
impl IFoundedItem for PresentationStyleByContext {}
impl IPresentationStyleAssignment for PresentationStyleByContext {
    fn styles(&self) -> &HashSet<PresentationStyleSelect> {
        &self.styles
    }
}
impl IPresentationStyleByContext for PresentationStyleByContext {
    fn style_context(&self) -> &EntityRef {
        &self.style_context
    }
}
impl PresentationStyleByContext {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = PresentationStyleByContext::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.styles = parameter.into(),
                1usize => entity.style_context = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IPresentationView: IPresentationRepresentation {}
#[derive(Default, Debug)]
pub struct PresentationView {
    name: Label,
    items: HashSet<EntityRef>,
    context_of_items: EntityRef,
}
impl IRepresentation for PresentationView {
    fn name(&self) -> &Label {
        &self.name
    }
    fn items(&self) -> &HashSet<EntityRef> {
        &self.items
    }
    fn context_of_items(&self) -> &EntityRef {
        &self.context_of_items
    }
}
impl IPresentationRepresentation for PresentationView {
    fn context_of_items(&self) -> &EntityRef {
        &self.context_of_items
    }
}
impl IPresentationView for PresentationView {}
impl PresentationView {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = PresentationView::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => entity.items = parameter.into(),
                2usize => entity.context_of_items = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IPresentedItem {}
pub trait IPresentedItemRepresentation {
    fn presentation(&self) -> &EntityRef;
    fn item(&self) -> &EntityRef;
}
#[derive(Default, Debug)]
pub struct PresentedItemRepresentation {
    presentation: EntityRef,
    item: EntityRef,
}
impl IPresentedItemRepresentation for PresentedItemRepresentation {
    fn presentation(&self) -> &EntityRef {
        &self.presentation
    }
    fn item(&self) -> &EntityRef {
        &self.item
    }
}
impl PresentedItemRepresentation {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = PresentedItemRepresentation::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.presentation = parameter.into(),
                1usize => entity.item = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IPrismaticPair: IKinematicPair {}
#[derive(Default, Debug)]
pub struct PrismaticPair {
    name: Label,
    description: Option<Text>,
    transform_item_1: EntityRef,
    transform_item_2: EntityRef,
    joint: EntityRef,
}
impl IItemDefinedTransformation for PrismaticPair {
    fn name(&self) -> &Label {
        &self.name
    }
    fn description(&self) -> &Option<Text> {
        &self.description
    }
    fn transform_item_1(&self) -> &EntityRef {
        &self.transform_item_1
    }
    fn transform_item_2(&self) -> &EntityRef {
        &self.transform_item_2
    }
}
impl IKinematicPair for PrismaticPair {
    fn joint(&self) -> &EntityRef {
        &self.joint
    }
}
impl IPrismaticPair for PrismaticPair {}
impl PrismaticPair {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = PrismaticPair::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => entity.transform_item_1 = parameter.into(),
                3usize => entity.transform_item_2 = parameter.into(),
                4usize => entity.joint = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IPrismaticPairRange: ISimplePairRange {
    fn applies_to_pair(&self) -> &EntityRef;
    fn lower_limit_actual_translation(&self) -> &TranslationalRangeMeasure;
    fn upper_limit_actual_translation(&self) -> &TranslationalRangeMeasure;
}
#[derive(Default, Debug)]
pub struct PrismaticPairRange {
    applies_to_pair: EntityRef,
    lower_limit_actual_translation: TranslationalRangeMeasure,
    upper_limit_actual_translation: TranslationalRangeMeasure,
}
impl ISimplePairRange for PrismaticPairRange {
    fn applies_to_pair(&self) -> &EntityRef {
        &self.applies_to_pair
    }
}
impl IPrismaticPairRange for PrismaticPairRange {
    fn applies_to_pair(&self) -> &EntityRef {
        &self.applies_to_pair
    }
    fn lower_limit_actual_translation(&self) -> &TranslationalRangeMeasure {
        &self.lower_limit_actual_translation
    }
    fn upper_limit_actual_translation(&self) -> &TranslationalRangeMeasure {
        &self.upper_limit_actual_translation
    }
}
impl PrismaticPairRange {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = PrismaticPairRange::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.applies_to_pair = parameter.into(),
                1usize => entity.lower_limit_actual_translation = parameter.into(),
                2usize => entity.upper_limit_actual_translation = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IPrismaticPairValue: IPairValue {
    fn applies_to_pair(&self) -> &EntityRef;
    fn actual_translation(&self) -> &LengthMeasure;
}
#[derive(Default, Debug)]
pub struct PrismaticPairValue {
    applies_to_pair: EntityRef,
    actual_translation: LengthMeasure,
}
impl IPairValue for PrismaticPairValue {
    fn applies_to_pair(&self) -> &EntityRef {
        &self.applies_to_pair
    }
}
impl IPrismaticPairValue for PrismaticPairValue {
    fn applies_to_pair(&self) -> &EntityRef {
        &self.applies_to_pair
    }
    fn actual_translation(&self) -> &LengthMeasure {
        &self.actual_translation
    }
}
impl PrismaticPairValue {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = PrismaticPairValue::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.applies_to_pair = parameter.into(),
                1usize => entity.actual_translation = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IProcessOperation: IActionMethod {}
#[derive(Default, Debug)]
pub struct ProcessOperation {
    name: Label,
    description: Option<Text>,
    consequence: Text,
    purpose: Text,
}
impl IActionMethod for ProcessOperation {
    fn name(&self) -> &Label {
        &self.name
    }
    fn description(&self) -> &Option<Text> {
        &self.description
    }
    fn consequence(&self) -> &Text {
        &self.consequence
    }
    fn purpose(&self) -> &Text {
        &self.purpose
    }
}
impl IProcessOperation for ProcessOperation {}
impl ProcessOperation {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = ProcessOperation::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => entity.consequence = parameter.into(),
                3usize => entity.purpose = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IProcessPlan: IAction {}
#[derive(Default, Debug)]
pub struct ProcessPlan {
    name: Label,
    description: Option<Text>,
    chosen_method: EntityRef,
}
impl IAction for ProcessPlan {
    fn name(&self) -> &Label {
        &self.name
    }
    fn description(&self) -> &Option<Text> {
        &self.description
    }
    fn chosen_method(&self) -> &EntityRef {
        &self.chosen_method
    }
}
impl IProcessPlan for ProcessPlan {}
impl ProcessPlan {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = ProcessPlan::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => entity.chosen_method = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IProcessProductAssociation {
    fn name(&self) -> &Label;
    fn description(&self) -> &Text;
    fn defined_product(&self) -> &EntityRef;
    fn process(&self) -> &EntityRef;
}
#[derive(Default, Debug)]
pub struct ProcessProductAssociation {
    name: Label,
    description: Text,
    defined_product: EntityRef,
    process: EntityRef,
}
impl IProcessProductAssociation for ProcessProductAssociation {
    fn name(&self) -> &Label {
        &self.name
    }
    fn description(&self) -> &Text {
        &self.description
    }
    fn defined_product(&self) -> &EntityRef {
        &self.defined_product
    }
    fn process(&self) -> &EntityRef {
        &self.process
    }
}
impl ProcessProductAssociation {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = ProcessProductAssociation::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => entity.description = parameter.into(),
                2usize => entity.defined_product = parameter.into(),
                3usize => entity.process = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IProcessPropertyAssociation {
    fn name(&self) -> &Label;
    fn description(&self) -> &Text;
    fn process(&self) -> &EntityRef;
    fn property_or_shape(&self) -> &EntityRef;
}
#[derive(Default, Debug)]
pub struct ProcessPropertyAssociation {
    name: Label,
    description: Text,
    process: EntityRef,
    property_or_shape: EntityRef,
}
impl IProcessPropertyAssociation for ProcessPropertyAssociation {
    fn name(&self) -> &Label {
        &self.name
    }
    fn description(&self) -> &Text {
        &self.description
    }
    fn process(&self) -> &EntityRef {
        &self.process
    }
    fn property_or_shape(&self) -> &EntityRef {
        &self.property_or_shape
    }
}
impl ProcessPropertyAssociation {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = ProcessPropertyAssociation::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => entity.description = parameter.into(),
                2usize => entity.process = parameter.into(),
                3usize => entity.property_or_shape = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IProduct {
    fn id(&self) -> &Identifier;
    fn name(&self) -> &Label;
    fn description(&self) -> &Option<Text>;
    fn frame_of_reference(&self) -> &HashSet<EntityRef>;
}
#[derive(Default, Debug)]
pub struct Product {
    id: Identifier,
    name: Label,
    description: Option<Text>,
    frame_of_reference: HashSet<EntityRef>,
}
impl IProduct for Product {
    fn id(&self) -> &Identifier {
        &self.id
    }
    fn name(&self) -> &Label {
        &self.name
    }
    fn description(&self) -> &Option<Text> {
        &self.description
    }
    fn frame_of_reference(&self) -> &HashSet<EntityRef> {
        &self.frame_of_reference
    }
}
impl Product {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = Product::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.id = parameter.into(),
                1usize => entity.name = parameter.into(),
                2usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => entity.frame_of_reference = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IProductCategory {
    fn name(&self) -> &Label;
    fn description(&self) -> &Option<Text>;
}
#[derive(Default, Debug)]
pub struct ProductCategory {
    name: Label,
    description: Option<Text>,
}
impl IProductCategory for ProductCategory {
    fn name(&self) -> &Label {
        &self.name
    }
    fn description(&self) -> &Option<Text> {
        &self.description
    }
}
impl ProductCategory {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = ProductCategory::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
}
pub trait IProductCategoryRelationship {
    fn name(&self) -> &Label;
    fn description(&self) -> &Option<Text>;
    fn category(&self) -> &EntityRef;
    fn sub_category(&self) -> &EntityRef;
}
#[derive(Default, Debug)]
pub struct ProductCategoryRelationship {
    name: Label,
    description: Option<Text>,
    category: EntityRef,
    sub_category: EntityRef,
}
impl IProductCategoryRelationship for ProductCategoryRelationship {
    fn name(&self) -> &Label {
        &self.name
    }
    fn description(&self) -> &Option<Text> {
        &self.description
    }
    fn category(&self) -> &EntityRef {
        &self.category
    }
    fn sub_category(&self) -> &EntityRef {
        &self.sub_category
    }
}
impl ProductCategoryRelationship {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = ProductCategoryRelationship::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => entity.category = parameter.into(),
                3usize => entity.sub_category = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IProductClass: IProductConcept + ICharacterizedObject {}
#[derive(Default, Debug)]
pub struct ProductClass {
    id: Identifier,
    name: Label,
    description: Option<Text>,
    market_context: EntityRef,
}
impl IProductConcept for ProductClass {
    fn id(&self) -> &Identifier {
        &self.id
    }
    fn name(&self) -> &Label {
        &self.name
    }
    fn description(&self) -> &Option<Text> {
        &self.description
    }
    fn market_context(&self) -> &EntityRef {
        &self.market_context
    }
}
impl ICharacterizedObject for ProductClass {
    fn name(&self) -> &Label {
        &self.name
    }
    fn description(&self) -> &Option<Text> {
        &self.description
    }
}
impl IProductClass for ProductClass {}
impl ProductClass {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = ProductClass::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.id = parameter.into(),
                1usize => entity.name = parameter.into(),
                2usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => entity.market_context = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IProductConcept {
    fn id(&self) -> &Identifier;
    fn name(&self) -> &Label;
    fn description(&self) -> &Option<Text>;
    fn market_context(&self) -> &EntityRef;
}
#[derive(Default, Debug)]
pub struct ProductConcept {
    id: Identifier,
    name: Label,
    description: Option<Text>,
    market_context: EntityRef,
}
impl IProductConcept for ProductConcept {
    fn id(&self) -> &Identifier {
        &self.id
    }
    fn name(&self) -> &Label {
        &self.name
    }
    fn description(&self) -> &Option<Text> {
        &self.description
    }
    fn market_context(&self) -> &EntityRef {
        &self.market_context
    }
}
impl ProductConcept {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = ProductConcept::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.id = parameter.into(),
                1usize => entity.name = parameter.into(),
                2usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => entity.market_context = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IProductConceptContext: IApplicationContextElement {
    fn market_segment_type(&self) -> &Label;
}
#[derive(Default, Debug)]
pub struct ProductConceptContext {
    name: Label,
    frame_of_reference: EntityRef,
    market_segment_type: Label,
}
impl IApplicationContextElement for ProductConceptContext {
    fn name(&self) -> &Label {
        &self.name
    }
    fn frame_of_reference(&self) -> &EntityRef {
        &self.frame_of_reference
    }
}
impl IProductConceptContext for ProductConceptContext {
    fn market_segment_type(&self) -> &Label {
        &self.market_segment_type
    }
}
impl ProductConceptContext {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = ProductConceptContext::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => entity.frame_of_reference = parameter.into(),
                2usize => entity.market_segment_type = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IProductConceptFeature {
    fn id(&self) -> &Identifier;
    fn name(&self) -> &Label;
    fn description(&self) -> &Option<Text>;
}
#[derive(Default, Debug)]
pub struct ProductConceptFeature {
    id: Identifier,
    name: Label,
    description: Option<Text>,
}
impl IProductConceptFeature for ProductConceptFeature {
    fn id(&self) -> &Identifier {
        &self.id
    }
    fn name(&self) -> &Label {
        &self.name
    }
    fn description(&self) -> &Option<Text> {
        &self.description
    }
}
impl ProductConceptFeature {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = ProductConceptFeature::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.id = parameter.into(),
                1usize => entity.name = parameter.into(),
                2usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
}
pub trait IProductConceptFeatureAssociation {
    fn name(&self) -> &Label;
    fn description(&self) -> &Option<Text>;
    fn concept(&self) -> &EntityRef;
    fn feature(&self) -> &EntityRef;
}
#[derive(Default, Debug)]
pub struct ProductConceptFeatureAssociation {
    name: Label,
    description: Option<Text>,
    concept: EntityRef,
    feature: EntityRef,
}
impl IProductConceptFeatureAssociation for ProductConceptFeatureAssociation {
    fn name(&self) -> &Label {
        &self.name
    }
    fn description(&self) -> &Option<Text> {
        &self.description
    }
    fn concept(&self) -> &EntityRef {
        &self.concept
    }
    fn feature(&self) -> &EntityRef {
        &self.feature
    }
}
impl ProductConceptFeatureAssociation {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = ProductConceptFeatureAssociation::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => entity.concept = parameter.into(),
                3usize => entity.feature = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IProductConceptFeatureCategory: IGroup {}
#[derive(Default, Debug)]
pub struct ProductConceptFeatureCategory {
    name: Label,
    description: Option<Text>,
}
impl IGroup for ProductConceptFeatureCategory {
    fn name(&self) -> &Label {
        &self.name
    }
    fn description(&self) -> &Option<Text> {
        &self.description
    }
}
impl IProductConceptFeatureCategory for ProductConceptFeatureCategory {}
impl ProductConceptFeatureCategory {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = ProductConceptFeatureCategory::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
}
pub trait IProductConceptFeatureCategoryUsage: IGroupAssignment {
    fn items(&self) -> &HashSet<EntityRef>;
}
#[derive(Default, Debug)]
pub struct ProductConceptFeatureCategoryUsage {
    assigned_group: EntityRef,
    items: HashSet<EntityRef>,
}
impl IGroupAssignment for ProductConceptFeatureCategoryUsage {
    fn assigned_group(&self) -> &EntityRef {
        &self.assigned_group
    }
}
impl IProductConceptFeatureCategoryUsage for ProductConceptFeatureCategoryUsage {
    fn items(&self) -> &HashSet<EntityRef> {
        &self.items
    }
}
impl ProductConceptFeatureCategoryUsage {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = ProductConceptFeatureCategoryUsage::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.assigned_group = parameter.into(),
                1usize => entity.items = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IProductConceptRelationship {
    fn name(&self) -> &Label;
    fn description(&self) -> &Option<Text>;
    fn relating_product_concept(&self) -> &EntityRef;
    fn related_product_concept(&self) -> &EntityRef;
}
#[derive(Default, Debug)]
pub struct ProductConceptRelationship {
    name: Label,
    description: Option<Text>,
    relating_product_concept: EntityRef,
    related_product_concept: EntityRef,
}
impl IProductConceptRelationship for ProductConceptRelationship {
    fn name(&self) -> &Label {
        &self.name
    }
    fn description(&self) -> &Option<Text> {
        &self.description
    }
    fn relating_product_concept(&self) -> &EntityRef {
        &self.relating_product_concept
    }
    fn related_product_concept(&self) -> &EntityRef {
        &self.related_product_concept
    }
}
impl ProductConceptRelationship {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = ProductConceptRelationship::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => entity.relating_product_concept = parameter.into(),
                3usize => entity.related_product_concept = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IProductContext: IApplicationContextElement {
    fn discipline_type(&self) -> &Label;
}
#[derive(Default, Debug)]
pub struct ProductContext {
    name: Label,
    frame_of_reference: EntityRef,
    discipline_type: Label,
}
impl IApplicationContextElement for ProductContext {
    fn name(&self) -> &Label {
        &self.name
    }
    fn frame_of_reference(&self) -> &EntityRef {
        &self.frame_of_reference
    }
}
impl IProductContext for ProductContext {
    fn discipline_type(&self) -> &Label {
        &self.discipline_type
    }
}
impl ProductContext {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = ProductContext::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => entity.frame_of_reference = parameter.into(),
                2usize => entity.discipline_type = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IProductDefinition {
    fn id(&self) -> &Identifier;
    fn description(&self) -> &Option<Text>;
    fn formation(&self) -> &EntityRef;
    fn frame_of_reference(&self) -> &EntityRef;
}
#[derive(Default, Debug)]
pub struct ProductDefinition {
    id: Identifier,
    description: Option<Text>,
    formation: EntityRef,
    frame_of_reference: EntityRef,
}
impl IProductDefinition for ProductDefinition {
    fn id(&self) -> &Identifier {
        &self.id
    }
    fn description(&self) -> &Option<Text> {
        &self.description
    }
    fn formation(&self) -> &EntityRef {
        &self.formation
    }
    fn frame_of_reference(&self) -> &EntityRef {
        &self.frame_of_reference
    }
}
impl ProductDefinition {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = ProductDefinition::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.id = parameter.into(),
                1usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => entity.formation = parameter.into(),
                3usize => entity.frame_of_reference = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IProductDefinitionContext: IApplicationContextElement {
    fn life_cycle_stage(&self) -> &Label;
}
#[derive(Default, Debug)]
pub struct ProductDefinitionContext {
    name: Label,
    frame_of_reference: EntityRef,
    life_cycle_stage: Label,
}
impl IApplicationContextElement for ProductDefinitionContext {
    fn name(&self) -> &Label {
        &self.name
    }
    fn frame_of_reference(&self) -> &EntityRef {
        &self.frame_of_reference
    }
}
impl IProductDefinitionContext for ProductDefinitionContext {
    fn life_cycle_stage(&self) -> &Label {
        &self.life_cycle_stage
    }
}
impl ProductDefinitionContext {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = ProductDefinitionContext::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => entity.frame_of_reference = parameter.into(),
                2usize => entity.life_cycle_stage = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IProductDefinitionContextAssociation {
    fn definition(&self) -> &EntityRef;
    fn frame_of_reference(&self) -> &EntityRef;
    fn role(&self) -> &EntityRef;
}
#[derive(Default, Debug)]
pub struct ProductDefinitionContextAssociation {
    definition: EntityRef,
    frame_of_reference: EntityRef,
    role: EntityRef,
}
impl IProductDefinitionContextAssociation for ProductDefinitionContextAssociation {
    fn definition(&self) -> &EntityRef {
        &self.definition
    }
    fn frame_of_reference(&self) -> &EntityRef {
        &self.frame_of_reference
    }
    fn role(&self) -> &EntityRef {
        &self.role
    }
}
impl ProductDefinitionContextAssociation {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = ProductDefinitionContextAssociation::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.definition = parameter.into(),
                1usize => entity.frame_of_reference = parameter.into(),
                2usize => entity.role = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IProductDefinitionContextRole {
    fn name(&self) -> &Label;
    fn description(&self) -> &Option<Text>;
}
#[derive(Default, Debug)]
pub struct ProductDefinitionContextRole {
    name: Label,
    description: Option<Text>,
}
impl IProductDefinitionContextRole for ProductDefinitionContextRole {
    fn name(&self) -> &Label {
        &self.name
    }
    fn description(&self) -> &Option<Text> {
        &self.description
    }
}
impl ProductDefinitionContextRole {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = ProductDefinitionContextRole::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
}
pub trait IProductDefinitionEffectivity: IEffectivity {
    fn usage(&self) -> &EntityRef;
}
#[derive(Default, Debug)]
pub struct ProductDefinitionEffectivity {
    id: Identifier,
    usage: EntityRef,
}
impl IEffectivity for ProductDefinitionEffectivity {
    fn id(&self) -> &Identifier {
        &self.id
    }
}
impl IProductDefinitionEffectivity for ProductDefinitionEffectivity {
    fn usage(&self) -> &EntityRef {
        &self.usage
    }
}
impl ProductDefinitionEffectivity {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = ProductDefinitionEffectivity::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.id = parameter.into(),
                1usize => entity.usage = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IProductDefinitionFormation {
    fn id(&self) -> &Identifier;
    fn description(&self) -> &Option<Text>;
    fn of_product(&self) -> &EntityRef;
}
#[derive(Default, Debug)]
pub struct ProductDefinitionFormation {
    id: Identifier,
    description: Option<Text>,
    of_product: EntityRef,
}
impl IProductDefinitionFormation for ProductDefinitionFormation {
    fn id(&self) -> &Identifier {
        &self.id
    }
    fn description(&self) -> &Option<Text> {
        &self.description
    }
    fn of_product(&self) -> &EntityRef {
        &self.of_product
    }
}
impl ProductDefinitionFormation {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = ProductDefinitionFormation::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.id = parameter.into(),
                1usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => entity.of_product = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IProductDefinitionFormationRelationship {
    fn id(&self) -> &Identifier;
    fn name(&self) -> &Label;
    fn description(&self) -> &Option<Text>;
    fn relating_product_definition_formation(&self) -> &EntityRef;
    fn related_product_definition_formation(&self) -> &EntityRef;
}
#[derive(Default, Debug)]
pub struct ProductDefinitionFormationRelationship {
    id: Identifier,
    name: Label,
    description: Option<Text>,
    relating_product_definition_formation: EntityRef,
    related_product_definition_formation: EntityRef,
}
impl IProductDefinitionFormationRelationship for ProductDefinitionFormationRelationship {
    fn id(&self) -> &Identifier {
        &self.id
    }
    fn name(&self) -> &Label {
        &self.name
    }
    fn description(&self) -> &Option<Text> {
        &self.description
    }
    fn relating_product_definition_formation(&self) -> &EntityRef {
        &self.relating_product_definition_formation
    }
    fn related_product_definition_formation(&self) -> &EntityRef {
        &self.related_product_definition_formation
    }
}
impl ProductDefinitionFormationRelationship {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = ProductDefinitionFormationRelationship::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.id = parameter.into(),
                1usize => entity.name = parameter.into(),
                2usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => entity.relating_product_definition_formation = parameter.into(),
                4usize => entity.related_product_definition_formation = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IProductDefinitionFormationWithSpecifiedSource: IProductDefinitionFormation {
    fn make_or_buy(&self) -> &Source;
}
#[derive(Default, Debug)]
pub struct ProductDefinitionFormationWithSpecifiedSource {
    id: Identifier,
    description: Option<Text>,
    of_product: EntityRef,
    make_or_buy: Source,
}
impl IProductDefinitionFormation for ProductDefinitionFormationWithSpecifiedSource {
    fn id(&self) -> &Identifier {
        &self.id
    }
    fn description(&self) -> &Option<Text> {
        &self.description
    }
    fn of_product(&self) -> &EntityRef {
        &self.of_product
    }
}
impl IProductDefinitionFormationWithSpecifiedSource for ProductDefinitionFormationWithSpecifiedSource {
    fn make_or_buy(&self) -> &Source {
        &self.make_or_buy
    }
}
impl ProductDefinitionFormationWithSpecifiedSource {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = ProductDefinitionFormationWithSpecifiedSource::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.id = parameter.into(),
                1usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => entity.of_product = parameter.into(),
                3usize => entity.make_or_buy = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IProductDefinitionOccurrenceRelationship {
    fn name(&self) -> &Label;
    fn description(&self) -> &Option<Text>;
    fn occurrence(&self) -> &EntityRef;
    fn occurrence_usage(&self) -> &EntityRef;
}
#[derive(Default, Debug)]
pub struct ProductDefinitionOccurrenceRelationship {
    name: Label,
    description: Option<Text>,
    occurrence: EntityRef,
    occurrence_usage: EntityRef,
}
impl IProductDefinitionOccurrenceRelationship for ProductDefinitionOccurrenceRelationship {
    fn name(&self) -> &Label {
        &self.name
    }
    fn description(&self) -> &Option<Text> {
        &self.description
    }
    fn occurrence(&self) -> &EntityRef {
        &self.occurrence
    }
    fn occurrence_usage(&self) -> &EntityRef {
        &self.occurrence_usage
    }
}
impl ProductDefinitionOccurrenceRelationship {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = ProductDefinitionOccurrenceRelationship::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => entity.occurrence = parameter.into(),
                3usize => entity.occurrence_usage = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IProductDefinitionProcess: IAction {
    fn identification(&self) -> &Identifier;
}
#[derive(Default, Debug)]
pub struct ProductDefinitionProcess {
    name: Label,
    description: Option<Text>,
    chosen_method: EntityRef,
    identification: Identifier,
}
impl IAction for ProductDefinitionProcess {
    fn name(&self) -> &Label {
        &self.name
    }
    fn description(&self) -> &Option<Text> {
        &self.description
    }
    fn chosen_method(&self) -> &EntityRef {
        &self.chosen_method
    }
}
impl IProductDefinitionProcess for ProductDefinitionProcess {
    fn identification(&self) -> &Identifier {
        &self.identification
    }
}
impl ProductDefinitionProcess {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = ProductDefinitionProcess::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => entity.chosen_method = parameter.into(),
                3usize => entity.identification = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IProductDefinitionRelationship {
    fn id(&self) -> &Identifier;
    fn name(&self) -> &Label;
    fn description(&self) -> &Option<Text>;
    fn relating_product_definition(&self) -> &EntityRef;
    fn related_product_definition(&self) -> &EntityRef;
}
#[derive(Default, Debug)]
pub struct ProductDefinitionRelationship {
    id: Identifier,
    name: Label,
    description: Option<Text>,
    relating_product_definition: EntityRef,
    related_product_definition: EntityRef,
}
impl IProductDefinitionRelationship for ProductDefinitionRelationship {
    fn id(&self) -> &Identifier {
        &self.id
    }
    fn name(&self) -> &Label {
        &self.name
    }
    fn description(&self) -> &Option<Text> {
        &self.description
    }
    fn relating_product_definition(&self) -> &EntityRef {
        &self.relating_product_definition
    }
    fn related_product_definition(&self) -> &EntityRef {
        &self.related_product_definition
    }
}
impl ProductDefinitionRelationship {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = ProductDefinitionRelationship::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.id = parameter.into(),
                1usize => entity.name = parameter.into(),
                2usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => entity.relating_product_definition = parameter.into(),
                4usize => entity.related_product_definition = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IProductDefinitionResource: IActionResource + IProductDefinition {}
#[derive(Default, Debug)]
pub struct ProductDefinitionResource {
    name: Label,
    description: Option<Text>,
    usage: HashSet<EntityRef>,
    kind: EntityRef,
    id: Identifier,
    formation: EntityRef,
    frame_of_reference: EntityRef,
}
impl IActionResource for ProductDefinitionResource {
    fn name(&self) -> &Label {
        &self.name
    }
    fn description(&self) -> &Option<Text> {
        &self.description
    }
    fn usage(&self) -> &HashSet<EntityRef> {
        &self.usage
    }
    fn kind(&self) -> &EntityRef {
        &self.kind
    }
}
impl IProductDefinition for ProductDefinitionResource {
    fn id(&self) -> &Identifier {
        &self.id
    }
    fn description(&self) -> &Option<Text> {
        &self.description
    }
    fn formation(&self) -> &EntityRef {
        &self.formation
    }
    fn frame_of_reference(&self) -> &EntityRef {
        &self.frame_of_reference
    }
}
impl IProductDefinitionResource for ProductDefinitionResource {}
impl ProductDefinitionResource {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = ProductDefinitionResource::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => entity.usage = parameter.into(),
                3usize => entity.kind = parameter.into(),
                4usize => entity.id = parameter.into(),
                5usize => entity.formation = parameter.into(),
                6usize => entity.frame_of_reference = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IProductDefinitionShape: IPropertyDefinition {}
#[derive(Default, Debug)]
pub struct ProductDefinitionShape {
    name: Label,
    description: Option<Text>,
    definition: EntityRef,
}
impl IPropertyDefinition for ProductDefinitionShape {
    fn name(&self) -> &Label {
        &self.name
    }
    fn description(&self) -> &Option<Text> {
        &self.description
    }
    fn definition(&self) -> &EntityRef {
        &self.definition
    }
}
impl IProductDefinitionShape for ProductDefinitionShape {}
impl ProductDefinitionShape {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = ProductDefinitionShape::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => entity.definition = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IProductDefinitionSubstitute {
    fn description(&self) -> &Option<Text>;
    fn context_relationship(&self) -> &EntityRef;
    fn substitute_definition(&self) -> &EntityRef;
}
#[derive(Default, Debug)]
pub struct ProductDefinitionSubstitute {
    description: Option<Text>,
    context_relationship: EntityRef,
    substitute_definition: EntityRef,
}
impl IProductDefinitionSubstitute for ProductDefinitionSubstitute {
    fn description(&self) -> &Option<Text> {
        &self.description
    }
    fn context_relationship(&self) -> &EntityRef {
        &self.context_relationship
    }
    fn substitute_definition(&self) -> &EntityRef {
        &self.substitute_definition
    }
}
impl ProductDefinitionSubstitute {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = ProductDefinitionSubstitute::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                1usize => entity.context_relationship = parameter.into(),
                2usize => entity.substitute_definition = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IProductDefinitionUsage: IProductDefinitionRelationship {}
#[derive(Default, Debug)]
pub struct ProductDefinitionUsage {
    id: Identifier,
    name: Label,
    description: Option<Text>,
    relating_product_definition: EntityRef,
    related_product_definition: EntityRef,
}
impl IProductDefinitionRelationship for ProductDefinitionUsage {
    fn id(&self) -> &Identifier {
        &self.id
    }
    fn name(&self) -> &Label {
        &self.name
    }
    fn description(&self) -> &Option<Text> {
        &self.description
    }
    fn relating_product_definition(&self) -> &EntityRef {
        &self.relating_product_definition
    }
    fn related_product_definition(&self) -> &EntityRef {
        &self.related_product_definition
    }
}
impl IProductDefinitionUsage for ProductDefinitionUsage {}
impl ProductDefinitionUsage {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = ProductDefinitionUsage::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.id = parameter.into(),
                1usize => entity.name = parameter.into(),
                2usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => entity.relating_product_definition = parameter.into(),
                4usize => entity.related_product_definition = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IProductDefinitionWithAssociatedDocuments: IProductDefinition {
    fn documentation_ids(&self) -> &HashSet<EntityRef>;
}
#[derive(Default, Debug)]
pub struct ProductDefinitionWithAssociatedDocuments {
    id: Identifier,
    description: Option<Text>,
    formation: EntityRef,
    frame_of_reference: EntityRef,
    documentation_ids: HashSet<EntityRef>,
}
impl IProductDefinition for ProductDefinitionWithAssociatedDocuments {
    fn id(&self) -> &Identifier {
        &self.id
    }
    fn description(&self) -> &Option<Text> {
        &self.description
    }
    fn formation(&self) -> &EntityRef {
        &self.formation
    }
    fn frame_of_reference(&self) -> &EntityRef {
        &self.frame_of_reference
    }
}
impl IProductDefinitionWithAssociatedDocuments for ProductDefinitionWithAssociatedDocuments {
    fn documentation_ids(&self) -> &HashSet<EntityRef> {
        &self.documentation_ids
    }
}
impl ProductDefinitionWithAssociatedDocuments {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = ProductDefinitionWithAssociatedDocuments::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.id = parameter.into(),
                1usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => entity.formation = parameter.into(),
                3usize => entity.frame_of_reference = parameter.into(),
                4usize => entity.documentation_ids = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IProductIdentification: IConfigurationItem + ICharacterizedObject {}
#[derive(Default, Debug)]
pub struct ProductIdentification {
    id: Identifier,
    name: Label,
    description: Option<Text>,
    item_concept: EntityRef,
    purpose: Option<Label>,
}
impl IConfigurationItem for ProductIdentification {
    fn id(&self) -> &Identifier {
        &self.id
    }
    fn name(&self) -> &Label {
        &self.name
    }
    fn description(&self) -> &Option<Text> {
        &self.description
    }
    fn item_concept(&self) -> &EntityRef {
        &self.item_concept
    }
    fn purpose(&self) -> &Option<Label> {
        &self.purpose
    }
}
impl ICharacterizedObject for ProductIdentification {
    fn name(&self) -> &Label {
        &self.name
    }
    fn description(&self) -> &Option<Text> {
        &self.description
    }
}
impl IProductIdentification for ProductIdentification {}
impl ProductIdentification {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = ProductIdentification::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.id = parameter.into(),
                1usize => entity.name = parameter.into(),
                2usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => entity.item_concept = parameter.into(),
                4usize => {
                    entity.purpose = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
}
pub trait IProductProcessPlan: IProductDefinitionProcess {}
#[derive(Default, Debug)]
pub struct ProductProcessPlan {
    name: Label,
    description: Option<Text>,
    chosen_method: EntityRef,
    identification: Identifier,
}
impl IAction for ProductProcessPlan {
    fn name(&self) -> &Label {
        &self.name
    }
    fn description(&self) -> &Option<Text> {
        &self.description
    }
    fn chosen_method(&self) -> &EntityRef {
        &self.chosen_method
    }
}
impl IProductDefinitionProcess for ProductProcessPlan {
    fn identification(&self) -> &Identifier {
        &self.identification
    }
}
impl IProductProcessPlan for ProductProcessPlan {}
impl ProductProcessPlan {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = ProductProcessPlan::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => entity.chosen_method = parameter.into(),
                3usize => entity.identification = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IProductRelatedProductCategory: IProductCategory {
    fn products(&self) -> &HashSet<EntityRef>;
}
#[derive(Default, Debug)]
pub struct ProductRelatedProductCategory {
    name: Label,
    description: Option<Text>,
    products: HashSet<EntityRef>,
}
impl IProductCategory for ProductRelatedProductCategory {
    fn name(&self) -> &Label {
        &self.name
    }
    fn description(&self) -> &Option<Text> {
        &self.description
    }
}
impl IProductRelatedProductCategory for ProductRelatedProductCategory {
    fn products(&self) -> &HashSet<EntityRef> {
        &self.products
    }
}
impl ProductRelatedProductCategory {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = ProductRelatedProductCategory::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => entity.products = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IProductSpecification: IProductIdentification + IConfigurableItem {}
#[derive(Default, Debug)]
pub struct ProductSpecification {
    id: Identifier,
    name: Label,
    description: Option<Text>,
    item_concept: EntityRef,
    purpose: Option<Label>,
    item_concept_feature: HashSet<EntityRef>,
}
impl IConfigurationItem for ProductSpecification {
    fn id(&self) -> &Identifier {
        &self.id
    }
    fn name(&self) -> &Label {
        &self.name
    }
    fn description(&self) -> &Option<Text> {
        &self.description
    }
    fn item_concept(&self) -> &EntityRef {
        &self.item_concept
    }
    fn purpose(&self) -> &Option<Label> {
        &self.purpose
    }
}
impl ICharacterizedObject for ProductSpecification {
    fn name(&self) -> &Label {
        &self.name
    }
    fn description(&self) -> &Option<Text> {
        &self.description
    }
}
impl IProductIdentification for ProductSpecification {}
impl IProductSpecification for ProductSpecification {}
impl IConfigurableItem for ProductSpecification {
    fn item_concept_feature(&self) -> &HashSet<EntityRef> {
        &self.item_concept_feature
    }
}
impl ProductSpecification {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = ProductSpecification::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.id = parameter.into(),
                1usize => entity.name = parameter.into(),
                2usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => entity.item_concept = parameter.into(),
                4usize => {
                    entity.purpose = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                5usize => entity.item_concept_feature = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IProjectedZoneDefinition: IToleranceZoneDefinition {
    fn projection_end(&self) -> &EntityRef;
    fn projected_length(&self) -> &EntityRef;
}
#[derive(Default, Debug)]
pub struct ProjectedZoneDefinition {
    zone: EntityRef,
    boundaries: HashSet<EntityRef>,
    projection_end: EntityRef,
    projected_length: EntityRef,
}
impl IToleranceZoneDefinition for ProjectedZoneDefinition {
    fn zone(&self) -> &EntityRef {
        &self.zone
    }
    fn boundaries(&self) -> &HashSet<EntityRef> {
        &self.boundaries
    }
}
impl IProjectedZoneDefinition for ProjectedZoneDefinition {
    fn projection_end(&self) -> &EntityRef {
        &self.projection_end
    }
    fn projected_length(&self) -> &EntityRef {
        &self.projected_length
    }
}
impl ProjectedZoneDefinition {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = ProjectedZoneDefinition::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.zone = parameter.into(),
                1usize => entity.boundaries = parameter.into(),
                2usize => entity.projection_end = parameter.into(),
                3usize => entity.projected_length = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IProjectionCurve: IAnnotationCurveOccurrence {}
#[derive(Default, Debug)]
pub struct ProjectionCurve {
    name: Label,
    styles: HashSet<EntityRef>,
    item: EntityRef,
}
impl IRepresentationItem for ProjectionCurve {
    fn name(&self) -> &Label {
        &self.name
    }
}
impl IStyledItem for ProjectionCurve {
    fn styles(&self) -> &HashSet<EntityRef> {
        &self.styles
    }
    fn item(&self) -> &EntityRef {
        &self.item
    }
}
impl IAnnotationOccurrence for ProjectionCurve {}
impl IAnnotationCurveOccurrence for ProjectionCurve {
    fn item(&self) -> &EntityRef {
        &self.item
    }
}
impl IProjectionCurve for ProjectionCurve {}
impl ProjectionCurve {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = ProjectionCurve::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => entity.styles = parameter.into(),
                2usize => entity.item = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IProjectionDirectedCallout: IDraughtingCallout {}
#[derive(Default, Debug)]
pub struct ProjectionDirectedCallout {
    name: Label,
    contents: HashSet<EntityRef>,
}
impl IRepresentationItem for ProjectionDirectedCallout {
    fn name(&self) -> &Label {
        &self.name
    }
}
impl IGeometricRepresentationItem for ProjectionDirectedCallout {}
impl IDraughtingCallout for ProjectionDirectedCallout {
    fn contents(&self) -> &HashSet<EntityRef> {
        &self.contents
    }
}
impl IProjectionDirectedCallout for ProjectionDirectedCallout {}
impl ProjectionDirectedCallout {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = ProjectionDirectedCallout::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => entity.contents = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IPromissoryUsageOccurrence: IAssemblyComponentUsage {}
#[derive(Default, Debug)]
pub struct PromissoryUsageOccurrence {
    id: Identifier,
    name: Label,
    description: Option<Text>,
    relating_product_definition: EntityRef,
    related_product_definition: EntityRef,
    reference_designator: Option<Identifier>,
}
impl IProductDefinitionRelationship for PromissoryUsageOccurrence {
    fn id(&self) -> &Identifier {
        &self.id
    }
    fn name(&self) -> &Label {
        &self.name
    }
    fn description(&self) -> &Option<Text> {
        &self.description
    }
    fn relating_product_definition(&self) -> &EntityRef {
        &self.relating_product_definition
    }
    fn related_product_definition(&self) -> &EntityRef {
        &self.related_product_definition
    }
}
impl IProductDefinitionUsage for PromissoryUsageOccurrence {}
impl IAssemblyComponentUsage for PromissoryUsageOccurrence {
    fn reference_designator(&self) -> &Option<Identifier> {
        &self.reference_designator
    }
}
impl IPromissoryUsageOccurrence for PromissoryUsageOccurrence {}
impl PromissoryUsageOccurrence {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = PromissoryUsageOccurrence::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.id = parameter.into(),
                1usize => entity.name = parameter.into(),
                2usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => entity.relating_product_definition = parameter.into(),
                4usize => entity.related_product_definition = parameter.into(),
                5usize => {
                    entity.reference_designator = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
}
pub trait IPropertyDefinition {
    fn name(&self) -> &Label;
    fn description(&self) -> &Option<Text>;
    fn definition(&self) -> &EntityRef;
}
#[derive(Default, Debug)]
pub struct PropertyDefinition {
    name: Label,
    description: Option<Text>,
    definition: EntityRef,
}
impl IPropertyDefinition for PropertyDefinition {
    fn name(&self) -> &Label {
        &self.name
    }
    fn description(&self) -> &Option<Text> {
        &self.description
    }
    fn definition(&self) -> &EntityRef {
        &self.definition
    }
}
impl PropertyDefinition {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = PropertyDefinition::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => entity.definition = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IPropertyDefinitionRelationship {
    fn name(&self) -> &Label;
    fn description(&self) -> &Text;
    fn relating_property_definition(&self) -> &EntityRef;
    fn related_property_definition(&self) -> &EntityRef;
}
#[derive(Default, Debug)]
pub struct PropertyDefinitionRelationship {
    name: Label,
    description: Text,
    relating_property_definition: EntityRef,
    related_property_definition: EntityRef,
}
impl IPropertyDefinitionRelationship for PropertyDefinitionRelationship {
    fn name(&self) -> &Label {
        &self.name
    }
    fn description(&self) -> &Text {
        &self.description
    }
    fn relating_property_definition(&self) -> &EntityRef {
        &self.relating_property_definition
    }
    fn related_property_definition(&self) -> &EntityRef {
        &self.related_property_definition
    }
}
impl PropertyDefinitionRelationship {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = PropertyDefinitionRelationship::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => entity.description = parameter.into(),
                2usize => entity.relating_property_definition = parameter.into(),
                3usize => entity.related_property_definition = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IPropertyDefinitionRepresentation {
    fn definition(&self) -> &EntityRef;
    fn used_representation(&self) -> &EntityRef;
}
#[derive(Default, Debug)]
pub struct PropertyDefinitionRepresentation {
    definition: EntityRef,
    used_representation: EntityRef,
}
impl IPropertyDefinitionRepresentation for PropertyDefinitionRepresentation {
    fn definition(&self) -> &EntityRef {
        &self.definition
    }
    fn used_representation(&self) -> &EntityRef {
        &self.used_representation
    }
}
impl PropertyDefinitionRepresentation {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = PropertyDefinitionRepresentation::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.definition = parameter.into(),
                1usize => entity.used_representation = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IPropertyProcess: IAction {
    fn identification(&self) -> &Identifier;
}
#[derive(Default, Debug)]
pub struct PropertyProcess {
    name: Label,
    description: Option<Text>,
    chosen_method: EntityRef,
    identification: Identifier,
}
impl IAction for PropertyProcess {
    fn name(&self) -> &Label {
        &self.name
    }
    fn description(&self) -> &Option<Text> {
        &self.description
    }
    fn chosen_method(&self) -> &EntityRef {
        &self.chosen_method
    }
}
impl IPropertyProcess for PropertyProcess {
    fn identification(&self) -> &Identifier {
        &self.identification
    }
}
impl PropertyProcess {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = PropertyProcess::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => entity.chosen_method = parameter.into(),
                3usize => entity.identification = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IQualifiedRepresentationItem: IRepresentationItem {
    fn qualifiers(&self) -> &HashSet<EntityRef>;
}
#[derive(Default, Debug)]
pub struct QualifiedRepresentationItem {
    name: Label,
    qualifiers: HashSet<EntityRef>,
}
impl IRepresentationItem for QualifiedRepresentationItem {
    fn name(&self) -> &Label {
        &self.name
    }
}
impl IQualifiedRepresentationItem for QualifiedRepresentationItem {
    fn qualifiers(&self) -> &HashSet<EntityRef> {
        &self.qualifiers
    }
}
impl QualifiedRepresentationItem {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = QualifiedRepresentationItem::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => entity.qualifiers = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IQualitativeUncertainty: IUncertaintyQualifier {
    fn uncertainty_value(&self) -> &Text;
}
#[derive(Default, Debug)]
pub struct QualitativeUncertainty {
    measure_name: Label,
    description: Text,
    uncertainty_value: Text,
}
impl IUncertaintyQualifier for QualitativeUncertainty {
    fn measure_name(&self) -> &Label {
        &self.measure_name
    }
    fn description(&self) -> &Text {
        &self.description
    }
}
impl IQualitativeUncertainty for QualitativeUncertainty {
    fn uncertainty_value(&self) -> &Text {
        &self.uncertainty_value
    }
}
impl QualitativeUncertainty {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = QualitativeUncertainty::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.measure_name = parameter.into(),
                1usize => entity.description = parameter.into(),
                2usize => entity.uncertainty_value = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IQuantifiedAssemblyComponentUsage: IAssemblyComponentUsage {
    fn quantity(&self) -> &EntityRef;
}
#[derive(Default, Debug)]
pub struct QuantifiedAssemblyComponentUsage {
    id: Identifier,
    name: Label,
    description: Option<Text>,
    relating_product_definition: EntityRef,
    related_product_definition: EntityRef,
    reference_designator: Option<Identifier>,
    quantity: EntityRef,
}
impl IProductDefinitionRelationship for QuantifiedAssemblyComponentUsage {
    fn id(&self) -> &Identifier {
        &self.id
    }
    fn name(&self) -> &Label {
        &self.name
    }
    fn description(&self) -> &Option<Text> {
        &self.description
    }
    fn relating_product_definition(&self) -> &EntityRef {
        &self.relating_product_definition
    }
    fn related_product_definition(&self) -> &EntityRef {
        &self.related_product_definition
    }
}
impl IProductDefinitionUsage for QuantifiedAssemblyComponentUsage {}
impl IAssemblyComponentUsage for QuantifiedAssemblyComponentUsage {
    fn reference_designator(&self) -> &Option<Identifier> {
        &self.reference_designator
    }
}
impl IQuantifiedAssemblyComponentUsage for QuantifiedAssemblyComponentUsage {
    fn quantity(&self) -> &EntityRef {
        &self.quantity
    }
}
impl QuantifiedAssemblyComponentUsage {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = QuantifiedAssemblyComponentUsage::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.id = parameter.into(),
                1usize => entity.name = parameter.into(),
                2usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => entity.relating_product_definition = parameter.into(),
                4usize => entity.related_product_definition = parameter.into(),
                5usize => {
                    entity.reference_designator = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                6usize => entity.quantity = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IQuasiUniformCurve: IBSplineCurve {}
#[derive(Default, Debug)]
pub struct QuasiUniformCurve {
    name: Label,
    degree: i64,
    control_points_list: Vec<EntityRef>,
    curve_form: BSplineCurveForm,
    closed_curve: Option<bool>,
    self_intersect: Option<bool>,
}
impl IRepresentationItem for QuasiUniformCurve {
    fn name(&self) -> &Label {
        &self.name
    }
}
impl IGeometricRepresentationItem for QuasiUniformCurve {}
impl ICurve for QuasiUniformCurve {}
impl IBoundedCurve for QuasiUniformCurve {}
impl IBSplineCurve for QuasiUniformCurve {
    fn degree(&self) -> i64 {
        self.degree
    }
    fn control_points_list(&self) -> &Vec<EntityRef> {
        &self.control_points_list
    }
    fn curve_form(&self) -> &BSplineCurveForm {
        &self.curve_form
    }
    fn closed_curve(&self) -> Option<bool> {
        self.closed_curve
    }
    fn self_intersect(&self) -> Option<bool> {
        self.self_intersect
    }
}
impl IQuasiUniformCurve for QuasiUniformCurve {}
impl QuasiUniformCurve {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = QuasiUniformCurve::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => entity.degree = parameter.into(),
                2usize => entity.control_points_list = parameter.into(),
                3usize => entity.curve_form = parameter.into(),
                4usize => entity.closed_curve = parameter.into(),
                5usize => entity.self_intersect = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IQuasiUniformSurface: IBSplineSurface {}
#[derive(Default, Debug)]
pub struct QuasiUniformSurface {
    name: Label,
    u_degree: i64,
    v_degree: i64,
    control_points_list: Vec<Vec<EntityRef>>,
    surface_form: BSplineSurfaceForm,
    u_closed: Option<bool>,
    v_closed: Option<bool>,
    self_intersect: Option<bool>,
}
impl IRepresentationItem for QuasiUniformSurface {
    fn name(&self) -> &Label {
        &self.name
    }
}
impl IGeometricRepresentationItem for QuasiUniformSurface {}
impl ISurface for QuasiUniformSurface {}
impl IBoundedSurface for QuasiUniformSurface {}
impl IBSplineSurface for QuasiUniformSurface {
    fn u_degree(&self) -> i64 {
        self.u_degree
    }
    fn v_degree(&self) -> i64 {
        self.v_degree
    }
    fn control_points_list(&self) -> &Vec<Vec<EntityRef>> {
        &self.control_points_list
    }
    fn surface_form(&self) -> &BSplineSurfaceForm {
        &self.surface_form
    }
    fn u_closed(&self) -> Option<bool> {
        self.u_closed
    }
    fn v_closed(&self) -> Option<bool> {
        self.v_closed
    }
    fn self_intersect(&self) -> Option<bool> {
        self.self_intersect
    }
}
impl IQuasiUniformSurface for QuasiUniformSurface {}
impl QuasiUniformSurface {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = QuasiUniformSurface::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => entity.u_degree = parameter.into(),
                2usize => entity.v_degree = parameter.into(),
                3usize => entity.control_points_list = parameter.into(),
                4usize => entity.surface_form = parameter.into(),
                5usize => entity.u_closed = parameter.into(),
                6usize => entity.v_closed = parameter.into(),
                7usize => entity.self_intersect = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IRackAndPinionPair: IKinematicPair {
    fn pinion_radius(&self) -> &LengthMeasure;
}
#[derive(Default, Debug)]
pub struct RackAndPinionPair {
    name: Label,
    description: Option<Text>,
    transform_item_1: EntityRef,
    transform_item_2: EntityRef,
    joint: EntityRef,
    pinion_radius: LengthMeasure,
}
impl IItemDefinedTransformation for RackAndPinionPair {
    fn name(&self) -> &Label {
        &self.name
    }
    fn description(&self) -> &Option<Text> {
        &self.description
    }
    fn transform_item_1(&self) -> &EntityRef {
        &self.transform_item_1
    }
    fn transform_item_2(&self) -> &EntityRef {
        &self.transform_item_2
    }
}
impl IKinematicPair for RackAndPinionPair {
    fn joint(&self) -> &EntityRef {
        &self.joint
    }
}
impl IRackAndPinionPair for RackAndPinionPair {
    fn pinion_radius(&self) -> &LengthMeasure {
        &self.pinion_radius
    }
}
impl RackAndPinionPair {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = RackAndPinionPair::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => entity.transform_item_1 = parameter.into(),
                3usize => entity.transform_item_2 = parameter.into(),
                4usize => entity.joint = parameter.into(),
                5usize => entity.pinion_radius = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IRackAndPinionPairRange: ISimplePairRange {
    fn applies_to_pair(&self) -> &EntityRef;
    fn lower_limit_rack_displacement(&self) -> &TranslationalRangeMeasure;
    fn upper_limit_rack_displacement(&self) -> &TranslationalRangeMeasure;
}
#[derive(Default, Debug)]
pub struct RackAndPinionPairRange {
    applies_to_pair: EntityRef,
    lower_limit_rack_displacement: TranslationalRangeMeasure,
    upper_limit_rack_displacement: TranslationalRangeMeasure,
}
impl ISimplePairRange for RackAndPinionPairRange {
    fn applies_to_pair(&self) -> &EntityRef {
        &self.applies_to_pair
    }
}
impl IRackAndPinionPairRange for RackAndPinionPairRange {
    fn applies_to_pair(&self) -> &EntityRef {
        &self.applies_to_pair
    }
    fn lower_limit_rack_displacement(&self) -> &TranslationalRangeMeasure {
        &self.lower_limit_rack_displacement
    }
    fn upper_limit_rack_displacement(&self) -> &TranslationalRangeMeasure {
        &self.upper_limit_rack_displacement
    }
}
impl RackAndPinionPairRange {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = RackAndPinionPairRange::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.applies_to_pair = parameter.into(),
                1usize => entity.lower_limit_rack_displacement = parameter.into(),
                2usize => entity.upper_limit_rack_displacement = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IRackAndPinionPairValue: IPairValue {
    fn applies_to_pair(&self) -> &EntityRef;
    fn actual_displacement(&self) -> &LengthMeasure;
}
#[derive(Default, Debug)]
pub struct RackAndPinionPairValue {
    applies_to_pair: EntityRef,
    actual_displacement: LengthMeasure,
}
impl IPairValue for RackAndPinionPairValue {
    fn applies_to_pair(&self) -> &EntityRef {
        &self.applies_to_pair
    }
}
impl IRackAndPinionPairValue for RackAndPinionPairValue {
    fn applies_to_pair(&self) -> &EntityRef {
        &self.applies_to_pair
    }
    fn actual_displacement(&self) -> &LengthMeasure {
        &self.actual_displacement
    }
}
impl RackAndPinionPairValue {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = RackAndPinionPairValue::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.applies_to_pair = parameter.into(),
                1usize => entity.actual_displacement = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IRadiusDimension: IDimensionCurveDirectedCallout {}
#[derive(Default, Debug)]
pub struct RadiusDimension {
    name: Label,
    contents: HashSet<EntityRef>,
}
impl IRepresentationItem for RadiusDimension {
    fn name(&self) -> &Label {
        &self.name
    }
}
impl IGeometricRepresentationItem for RadiusDimension {}
impl IDraughtingCallout for RadiusDimension {
    fn contents(&self) -> &HashSet<EntityRef> {
        &self.contents
    }
}
impl IDimensionCurveDirectedCallout for RadiusDimension {}
impl IRadiusDimension for RadiusDimension {}
impl RadiusDimension {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = RadiusDimension::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => entity.contents = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IRatioMeasureWithUnit: IMeasureWithUnit {}
#[derive(Default, Debug)]
pub struct RatioMeasureWithUnit {
    value_component: MeasureValue,
    unit_component: EntityRef,
}
impl IMeasureWithUnit for RatioMeasureWithUnit {
    fn value_component(&self) -> &MeasureValue {
        &self.value_component
    }
    fn unit_component(&self) -> &EntityRef {
        &self.unit_component
    }
}
impl IRatioMeasureWithUnit for RatioMeasureWithUnit {}
impl RatioMeasureWithUnit {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = RatioMeasureWithUnit::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.value_component = parameter.into(),
                1usize => entity.unit_component = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IRatioUnit: INamedUnit {}
#[derive(Default, Debug)]
pub struct RatioUnit {
    dimensions: EntityRef,
}
impl INamedUnit for RatioUnit {
    fn dimensions(&self) -> &EntityRef {
        &self.dimensions
    }
}
impl IRatioUnit for RatioUnit {}
impl RatioUnit {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = RatioUnit::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.dimensions = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IRationalBSplineCurve: IBSplineCurve {
    fn weights_data(&self) -> &Vec<Real>;
}
#[derive(Default, Debug)]
pub struct RationalBSplineCurve {
    name: Label,
    degree: i64,
    control_points_list: Vec<EntityRef>,
    curve_form: BSplineCurveForm,
    closed_curve: Option<bool>,
    self_intersect: Option<bool>,
    weights_data: Vec<Real>,
}
impl IRepresentationItem for RationalBSplineCurve {
    fn name(&self) -> &Label {
        &self.name
    }
}
impl IGeometricRepresentationItem for RationalBSplineCurve {}
impl ICurve for RationalBSplineCurve {}
impl IBoundedCurve for RationalBSplineCurve {}
impl IBSplineCurve for RationalBSplineCurve {
    fn degree(&self) -> i64 {
        self.degree
    }
    fn control_points_list(&self) -> &Vec<EntityRef> {
        &self.control_points_list
    }
    fn curve_form(&self) -> &BSplineCurveForm {
        &self.curve_form
    }
    fn closed_curve(&self) -> Option<bool> {
        self.closed_curve
    }
    fn self_intersect(&self) -> Option<bool> {
        self.self_intersect
    }
}
impl IRationalBSplineCurve for RationalBSplineCurve {
    fn weights_data(&self) -> &Vec<Real> {
        &self.weights_data
    }
}
impl RationalBSplineCurve {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = RationalBSplineCurve::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => entity.degree = parameter.into(),
                2usize => entity.control_points_list = parameter.into(),
                3usize => entity.curve_form = parameter.into(),
                4usize => entity.closed_curve = parameter.into(),
                5usize => entity.self_intersect = parameter.into(),
                6usize => entity.weights_data = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IRationalBSplineSurface: IBSplineSurface {
    fn weights_data(&self) -> &Vec<Vec<Real>>;
}
#[derive(Default, Debug)]
pub struct RationalBSplineSurface {
    name: Label,
    u_degree: i64,
    v_degree: i64,
    control_points_list: Vec<Vec<EntityRef>>,
    surface_form: BSplineSurfaceForm,
    u_closed: Option<bool>,
    v_closed: Option<bool>,
    self_intersect: Option<bool>,
    weights_data: Vec<Vec<Real>>,
}
impl IRepresentationItem for RationalBSplineSurface {
    fn name(&self) -> &Label {
        &self.name
    }
}
impl IGeometricRepresentationItem for RationalBSplineSurface {}
impl ISurface for RationalBSplineSurface {}
impl IBoundedSurface for RationalBSplineSurface {}
impl IBSplineSurface for RationalBSplineSurface {
    fn u_degree(&self) -> i64 {
        self.u_degree
    }
    fn v_degree(&self) -> i64 {
        self.v_degree
    }
    fn control_points_list(&self) -> &Vec<Vec<EntityRef>> {
        &self.control_points_list
    }
    fn surface_form(&self) -> &BSplineSurfaceForm {
        &self.surface_form
    }
    fn u_closed(&self) -> Option<bool> {
        self.u_closed
    }
    fn v_closed(&self) -> Option<bool> {
        self.v_closed
    }
    fn self_intersect(&self) -> Option<bool> {
        self.self_intersect
    }
}
impl IRationalBSplineSurface for RationalBSplineSurface {
    fn weights_data(&self) -> &Vec<Vec<Real>> {
        &self.weights_data
    }
}
impl RationalBSplineSurface {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = RationalBSplineSurface::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => entity.u_degree = parameter.into(),
                2usize => entity.v_degree = parameter.into(),
                3usize => entity.control_points_list = parameter.into(),
                4usize => entity.surface_form = parameter.into(),
                5usize => entity.u_closed = parameter.into(),
                6usize => entity.v_closed = parameter.into(),
                7usize => entity.self_intersect = parameter.into(),
                8usize => entity.weights_data = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IRealDefinedFunction: INumericDefinedFunction {}
pub trait IRealLiteral: ILiteralNumber {
    fn the_value(&self) -> Real;
}
#[derive(Default, Debug)]
pub struct RealLiteral {
    the_value: Real,
}
impl IGenericExpression for RealLiteral {}
impl IExpression for RealLiteral {}
impl INumericExpression for RealLiteral {}
impl ISimpleNumericExpression for RealLiteral {}
impl ISimpleGenericExpression for RealLiteral {}
impl ILiteralNumber for RealLiteral {
    fn the_value(&self) -> Real {
        self.the_value
    }
}
impl IGenericLiteral for RealLiteral {}
impl IRealLiteral for RealLiteral {
    fn the_value(&self) -> Real {
        self.the_value
    }
}
impl RealLiteral {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = RealLiteral::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.the_value = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IRealNumericVariable: INumericVariable {}
#[derive(Default, Debug)]
pub struct RealNumericVariable {}
impl IGenericExpression for RealNumericVariable {}
impl IExpression for RealNumericVariable {}
impl INumericExpression for RealNumericVariable {}
impl ISimpleNumericExpression for RealNumericVariable {}
impl ISimpleGenericExpression for RealNumericVariable {}
impl INumericVariable for RealNumericVariable {}
impl IVariable for RealNumericVariable {}
impl IGenericVariable for RealNumericVariable {}
impl IRealNumericVariable for RealNumericVariable {}
impl RealNumericVariable {
    pub fn form_parameters(_parameters: Vec<Parameter>) -> Self {
        RealNumericVariable::default()
    }
}
pub trait IRectangularClosedProfile: IShapeAspect {}
#[derive(Default, Debug)]
pub struct RectangularClosedProfile {
    name: Label,
    description: Option<Text>,
    of_shape: EntityRef,
    product_definitional: Option<bool>,
}
impl IShapeAspect for RectangularClosedProfile {
    fn name(&self) -> &Label {
        &self.name
    }
    fn description(&self) -> &Option<Text> {
        &self.description
    }
    fn of_shape(&self) -> &EntityRef {
        &self.of_shape
    }
    fn product_definitional(&self) -> Option<bool> {
        self.product_definitional
    }
}
impl IRectangularClosedProfile for RectangularClosedProfile {}
impl RectangularClosedProfile {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = RectangularClosedProfile::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => entity.of_shape = parameter.into(),
                3usize => entity.product_definitional = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IRectangularCompositeSurface: IBoundedSurface {
    fn segments(&self) -> &Vec<Vec<EntityRef>>;
}
#[derive(Default, Debug)]
pub struct RectangularCompositeSurface {
    name: Label,
    segments: Vec<Vec<EntityRef>>,
}
impl IRepresentationItem for RectangularCompositeSurface {
    fn name(&self) -> &Label {
        &self.name
    }
}
impl IGeometricRepresentationItem for RectangularCompositeSurface {}
impl ISurface for RectangularCompositeSurface {}
impl IBoundedSurface for RectangularCompositeSurface {}
impl IRectangularCompositeSurface for RectangularCompositeSurface {
    fn segments(&self) -> &Vec<Vec<EntityRef>> {
        &self.segments
    }
}
impl RectangularCompositeSurface {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = RectangularCompositeSurface::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => entity.segments = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IRectangularPattern: IReplicateFeature {}
#[derive(Default, Debug)]
pub struct RectangularPattern {
    name: Label,
    description: Option<Text>,
}
impl ICharacterizedObject for RectangularPattern {
    fn name(&self) -> &Label {
        &self.name
    }
    fn description(&self) -> &Option<Text> {
        &self.description
    }
}
impl IFeatureDefinition for RectangularPattern {}
impl IReplicateFeature for RectangularPattern {}
impl IRectangularPattern for RectangularPattern {}
impl RectangularPattern {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = RectangularPattern::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
}
pub trait IRectangularTrimmedSurface: IBoundedSurface {
    fn basis_surface(&self) -> &EntityRef;
    fn u1(&self) -> &ParameterValue;
    fn u2(&self) -> &ParameterValue;
    fn v1(&self) -> &ParameterValue;
    fn v2(&self) -> &ParameterValue;
    fn usense(&self) -> bool;
    fn vsense(&self) -> bool;
}
#[derive(Default, Debug)]
pub struct RectangularTrimmedSurface {
    name: Label,
    basis_surface: EntityRef,
    u1: ParameterValue,
    u2: ParameterValue,
    v1: ParameterValue,
    v2: ParameterValue,
    usense: bool,
    vsense: bool,
}
impl IRepresentationItem for RectangularTrimmedSurface {
    fn name(&self) -> &Label {
        &self.name
    }
}
impl IGeometricRepresentationItem for RectangularTrimmedSurface {}
impl ISurface for RectangularTrimmedSurface {}
impl IBoundedSurface for RectangularTrimmedSurface {}
impl IRectangularTrimmedSurface for RectangularTrimmedSurface {
    fn basis_surface(&self) -> &EntityRef {
        &self.basis_surface
    }
    fn u1(&self) -> &ParameterValue {
        &self.u1
    }
    fn u2(&self) -> &ParameterValue {
        &self.u2
    }
    fn v1(&self) -> &ParameterValue {
        &self.v1
    }
    fn v2(&self) -> &ParameterValue {
        &self.v2
    }
    fn usense(&self) -> bool {
        self.usense
    }
    fn vsense(&self) -> bool {
        self.vsense
    }
}
impl RectangularTrimmedSurface {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = RectangularTrimmedSurface::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => entity.basis_surface = parameter.into(),
                2usize => entity.u1 = parameter.into(),
                3usize => entity.u2 = parameter.into(),
                4usize => entity.v1 = parameter.into(),
                5usize => entity.v2 = parameter.into(),
                6usize => entity.usense = parameter.into(),
                7usize => entity.vsense = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IReferencedModifiedDatum: IDatumReference {
    fn modifier(&self) -> &LimitCondition;
}
#[derive(Default, Debug)]
pub struct ReferencedModifiedDatum {
    precedence: i64,
    referenced_datum: EntityRef,
    modifier: LimitCondition,
}
impl IDatumReference for ReferencedModifiedDatum {
    fn precedence(&self) -> i64 {
        self.precedence
    }
    fn referenced_datum(&self) -> &EntityRef {
        &self.referenced_datum
    }
}
impl IReferencedModifiedDatum for ReferencedModifiedDatum {
    fn modifier(&self) -> &LimitCondition {
        &self.modifier
    }
}
impl ReferencedModifiedDatum {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = ReferencedModifiedDatum::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.precedence = parameter.into(),
                1usize => entity.referenced_datum = parameter.into(),
                2usize => entity.modifier = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IRelativeEventOccurrence: IEventOccurrence {
    fn base_event(&self) -> &EntityRef;
    fn offset(&self) -> &EntityRef;
}
#[derive(Default, Debug)]
pub struct RelativeEventOccurrence {
    id: Identifier,
    name: Label,
    description: Option<Text>,
    base_event: EntityRef,
    offset: EntityRef,
}
impl IEventOccurrence for RelativeEventOccurrence {
    fn id(&self) -> &Identifier {
        &self.id
    }
    fn name(&self) -> &Label {
        &self.name
    }
    fn description(&self) -> &Option<Text> {
        &self.description
    }
}
impl IRelativeEventOccurrence for RelativeEventOccurrence {
    fn base_event(&self) -> &EntityRef {
        &self.base_event
    }
    fn offset(&self) -> &EntityRef {
        &self.offset
    }
}
impl RelativeEventOccurrence {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = RelativeEventOccurrence::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.id = parameter.into(),
                1usize => entity.name = parameter.into(),
                2usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => entity.base_event = parameter.into(),
                4usize => entity.offset = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IRepItemGroup: IGroup + IRepresentationItem {}
#[derive(Default, Debug)]
pub struct RepItemGroup {
    name: Label,
    description: Option<Text>,
}
impl IGroup for RepItemGroup {
    fn name(&self) -> &Label {
        &self.name
    }
    fn description(&self) -> &Option<Text> {
        &self.description
    }
}
impl IRepresentationItem for RepItemGroup {
    fn name(&self) -> &Label {
        &self.name
    }
}
impl IRepItemGroup for RepItemGroup {}
impl RepItemGroup {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = RepItemGroup::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
}
pub trait IReparametrisedCompositeCurveSegment: ICompositeCurveSegment {
    fn param_length(&self) -> &ParameterValue;
}
#[derive(Default, Debug)]
pub struct ReparametrisedCompositeCurveSegment {
    transition: TransitionCode,
    same_sense: bool,
    parent_curve: EntityRef,
    param_length: ParameterValue,
}
impl IFoundedItem for ReparametrisedCompositeCurveSegment {}
impl ICompositeCurveSegment for ReparametrisedCompositeCurveSegment {
    fn transition(&self) -> &TransitionCode {
        &self.transition
    }
    fn same_sense(&self) -> bool {
        self.same_sense
    }
    fn parent_curve(&self) -> &EntityRef {
        &self.parent_curve
    }
}
impl IReparametrisedCompositeCurveSegment for ReparametrisedCompositeCurveSegment {
    fn param_length(&self) -> &ParameterValue {
        &self.param_length
    }
}
impl ReparametrisedCompositeCurveSegment {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = ReparametrisedCompositeCurveSegment::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.transition = parameter.into(),
                1usize => entity.same_sense = parameter.into(),
                2usize => entity.parent_curve = parameter.into(),
                3usize => entity.param_length = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IReplicateFeature: IFeatureDefinition {}
#[derive(Default, Debug)]
pub struct ReplicateFeature {
    name: Label,
    description: Option<Text>,
}
impl ICharacterizedObject for ReplicateFeature {
    fn name(&self) -> &Label {
        &self.name
    }
    fn description(&self) -> &Option<Text> {
        &self.description
    }
}
impl IFeatureDefinition for ReplicateFeature {}
impl IReplicateFeature for ReplicateFeature {}
impl ReplicateFeature {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = ReplicateFeature::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
}
pub trait IRepresentation {
    fn name(&self) -> &Label;
    fn items(&self) -> &HashSet<EntityRef>;
    fn context_of_items(&self) -> &EntityRef;
}
#[derive(Default, Debug)]
pub struct Representation {
    name: Label,
    items: HashSet<EntityRef>,
    context_of_items: EntityRef,
}
impl IRepresentation for Representation {
    fn name(&self) -> &Label {
        &self.name
    }
    fn items(&self) -> &HashSet<EntityRef> {
        &self.items
    }
    fn context_of_items(&self) -> &EntityRef {
        &self.context_of_items
    }
}
impl Representation {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = Representation::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => entity.items = parameter.into(),
                2usize => entity.context_of_items = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IRepresentationContext {
    fn context_identifier(&self) -> &Identifier;
    fn context_type(&self) -> &Text;
}
#[derive(Default, Debug)]
pub struct RepresentationContext {
    context_identifier: Identifier,
    context_type: Text,
}
impl IRepresentationContext for RepresentationContext {
    fn context_identifier(&self) -> &Identifier {
        &self.context_identifier
    }
    fn context_type(&self) -> &Text {
        &self.context_type
    }
}
impl RepresentationContext {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = RepresentationContext::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.context_identifier = parameter.into(),
                1usize => entity.context_type = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IRepresentationItem {
    fn name(&self) -> &Label;
}
#[derive(Default, Debug)]
pub struct RepresentationItem {
    name: Label,
}
impl IRepresentationItem for RepresentationItem {
    fn name(&self) -> &Label {
        &self.name
    }
}
impl RepresentationItem {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = RepresentationItem::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IRepresentationMap {
    fn mapping_origin(&self) -> &EntityRef;
    fn mapped_representation(&self) -> &EntityRef;
}
#[derive(Default, Debug)]
pub struct RepresentationMap {
    mapping_origin: EntityRef,
    mapped_representation: EntityRef,
}
impl IRepresentationMap for RepresentationMap {
    fn mapping_origin(&self) -> &EntityRef {
        &self.mapping_origin
    }
    fn mapped_representation(&self) -> &EntityRef {
        &self.mapped_representation
    }
}
impl RepresentationMap {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = RepresentationMap::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.mapping_origin = parameter.into(),
                1usize => entity.mapped_representation = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IRepresentationRelationship {
    fn name(&self) -> &Label;
    fn description(&self) -> &Option<Text>;
    fn rep_1(&self) -> &EntityRef;
    fn rep_2(&self) -> &EntityRef;
}
#[derive(Default, Debug)]
pub struct RepresentationRelationship {
    name: Label,
    description: Option<Text>,
    rep_1: EntityRef,
    rep_2: EntityRef,
}
impl IRepresentationRelationship for RepresentationRelationship {
    fn name(&self) -> &Label {
        &self.name
    }
    fn description(&self) -> &Option<Text> {
        &self.description
    }
    fn rep_1(&self) -> &EntityRef {
        &self.rep_1
    }
    fn rep_2(&self) -> &EntityRef {
        &self.rep_2
    }
}
impl RepresentationRelationship {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = RepresentationRelationship::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => entity.rep_1 = parameter.into(),
                3usize => entity.rep_2 = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IRepresentationRelationshipWithTransformation: IRepresentationRelationship {
    fn transformation_operator(&self) -> &EntityRef;
}
#[derive(Default, Debug)]
pub struct RepresentationRelationshipWithTransformation {
    name: Label,
    description: Option<Text>,
    rep_1: EntityRef,
    rep_2: EntityRef,
    transformation_operator: EntityRef,
}
impl IRepresentationRelationship for RepresentationRelationshipWithTransformation {
    fn name(&self) -> &Label {
        &self.name
    }
    fn description(&self) -> &Option<Text> {
        &self.description
    }
    fn rep_1(&self) -> &EntityRef {
        &self.rep_1
    }
    fn rep_2(&self) -> &EntityRef {
        &self.rep_2
    }
}
impl IRepresentationRelationshipWithTransformation for RepresentationRelationshipWithTransformation {
    fn transformation_operator(&self) -> &EntityRef {
        &self.transformation_operator
    }
}
impl RepresentationRelationshipWithTransformation {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = RepresentationRelationshipWithTransformation::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => entity.rep_1 = parameter.into(),
                3usize => entity.rep_2 = parameter.into(),
                4usize => entity.transformation_operator = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IRequirementForActionResource: IActionResourceRequirement {
    fn resources(&self) -> &HashSet<EntityRef>;
}
#[derive(Default, Debug)]
pub struct RequirementForActionResource {
    name: Label,
    description: Text,
    kind: EntityRef,
    operations: HashSet<EntityRef>,
    resources: HashSet<EntityRef>,
}
impl IActionResourceRequirement for RequirementForActionResource {
    fn name(&self) -> &Label {
        &self.name
    }
    fn description(&self) -> &Text {
        &self.description
    }
    fn kind(&self) -> &EntityRef {
        &self.kind
    }
    fn operations(&self) -> &HashSet<EntityRef> {
        &self.operations
    }
}
impl IRequirementForActionResource for RequirementForActionResource {
    fn resources(&self) -> &HashSet<EntityRef> {
        &self.resources
    }
}
impl RequirementForActionResource {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = RequirementForActionResource::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => entity.description = parameter.into(),
                2usize => entity.kind = parameter.into(),
                3usize => entity.operations = parameter.into(),
                4usize => entity.resources = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IResourceProperty {
    fn name(&self) -> &Label;
    fn description(&self) -> &Text;
    fn resource(&self) -> &EntityRef;
}
#[derive(Default, Debug)]
pub struct ResourceProperty {
    name: Label,
    description: Text,
    resource: EntityRef,
}
impl IResourceProperty for ResourceProperty {
    fn name(&self) -> &Label {
        &self.name
    }
    fn description(&self) -> &Text {
        &self.description
    }
    fn resource(&self) -> &EntityRef {
        &self.resource
    }
}
impl ResourceProperty {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = ResourceProperty::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => entity.description = parameter.into(),
                2usize => entity.resource = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IResourcePropertyRepresentation {
    fn name(&self) -> &Label;
    fn description(&self) -> &Text;
    fn property(&self) -> &EntityRef;
    fn representation(&self) -> &EntityRef;
}
#[derive(Default, Debug)]
pub struct ResourcePropertyRepresentation {
    name: Label,
    description: Text,
    property: EntityRef,
    representation: EntityRef,
}
impl IResourcePropertyRepresentation for ResourcePropertyRepresentation {
    fn name(&self) -> &Label {
        &self.name
    }
    fn description(&self) -> &Text {
        &self.description
    }
    fn property(&self) -> &EntityRef {
        &self.property
    }
    fn representation(&self) -> &EntityRef {
        &self.representation
    }
}
impl ResourcePropertyRepresentation {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = ResourcePropertyRepresentation::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => entity.description = parameter.into(),
                2usize => entity.property = parameter.into(),
                3usize => entity.representation = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IResourceRequirementType {
    fn name(&self) -> &Label;
    fn description(&self) -> &Text;
}
#[derive(Default, Debug)]
pub struct ResourceRequirementType {
    name: Label,
    description: Text,
}
impl IResourceRequirementType for ResourceRequirementType {
    fn name(&self) -> &Label {
        &self.name
    }
    fn description(&self) -> &Text {
        &self.description
    }
}
impl ResourceRequirementType {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = ResourceRequirementType::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => entity.description = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IResultingPath: IMotionLinkRelationship {
    fn controlling_joints(&self) -> &HashSet<EntityRef>;
}
#[derive(Default, Debug)]
pub struct ResultingPath {
    name: Label,
    description: Option<Text>,
    rep_1: EntityRef,
    rep_2: EntityRef,
    related_frame: EntityRef,
    controlling_joints: HashSet<EntityRef>,
}
impl IRepresentationRelationship for ResultingPath {
    fn name(&self) -> &Label {
        &self.name
    }
    fn description(&self) -> &Option<Text> {
        &self.description
    }
    fn rep_1(&self) -> &EntityRef {
        &self.rep_1
    }
    fn rep_2(&self) -> &EntityRef {
        &self.rep_2
    }
}
impl IMotionLinkRelationship for ResultingPath {
    fn rep_1(&self) -> &EntityRef {
        &self.rep_1
    }
    fn rep_2(&self) -> &EntityRef {
        &self.rep_2
    }
    fn related_frame(&self) -> &EntityRef {
        &self.related_frame
    }
}
impl IResultingPath for ResultingPath {
    fn controlling_joints(&self) -> &HashSet<EntityRef> {
        &self.controlling_joints
    }
}
impl ResultingPath {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = ResultingPath::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => entity.rep_1 = parameter.into(),
                3usize => entity.rep_2 = parameter.into(),
                4usize => entity.related_frame = parameter.into(),
                5usize => entity.controlling_joints = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IRetention: IAction {}
#[derive(Default, Debug)]
pub struct Retention {
    name: Label,
    description: Option<Text>,
    chosen_method: EntityRef,
}
impl IAction for Retention {
    fn name(&self) -> &Label {
        &self.name
    }
    fn description(&self) -> &Option<Text> {
        &self.description
    }
    fn chosen_method(&self) -> &EntityRef {
        &self.chosen_method
    }
}
impl IRetention for Retention {}
impl Retention {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = Retention::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => entity.chosen_method = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IRevolutePair: IKinematicPair {}
#[derive(Default, Debug)]
pub struct RevolutePair {
    name: Label,
    description: Option<Text>,
    transform_item_1: EntityRef,
    transform_item_2: EntityRef,
    joint: EntityRef,
}
impl IItemDefinedTransformation for RevolutePair {
    fn name(&self) -> &Label {
        &self.name
    }
    fn description(&self) -> &Option<Text> {
        &self.description
    }
    fn transform_item_1(&self) -> &EntityRef {
        &self.transform_item_1
    }
    fn transform_item_2(&self) -> &EntityRef {
        &self.transform_item_2
    }
}
impl IKinematicPair for RevolutePair {
    fn joint(&self) -> &EntityRef {
        &self.joint
    }
}
impl IRevolutePair for RevolutePair {}
impl RevolutePair {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = RevolutePair::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => entity.transform_item_1 = parameter.into(),
                3usize => entity.transform_item_2 = parameter.into(),
                4usize => entity.joint = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IRevolutePairRange: ISimplePairRange {
    fn applies_to_pair(&self) -> &EntityRef;
    fn lower_limit_actual_rotation(&self) -> &RotationalRangeMeasure;
    fn upper_limit_actual_rotation(&self) -> &RotationalRangeMeasure;
}
#[derive(Default, Debug)]
pub struct RevolutePairRange {
    applies_to_pair: EntityRef,
    lower_limit_actual_rotation: RotationalRangeMeasure,
    upper_limit_actual_rotation: RotationalRangeMeasure,
}
impl ISimplePairRange for RevolutePairRange {
    fn applies_to_pair(&self) -> &EntityRef {
        &self.applies_to_pair
    }
}
impl IRevolutePairRange for RevolutePairRange {
    fn applies_to_pair(&self) -> &EntityRef {
        &self.applies_to_pair
    }
    fn lower_limit_actual_rotation(&self) -> &RotationalRangeMeasure {
        &self.lower_limit_actual_rotation
    }
    fn upper_limit_actual_rotation(&self) -> &RotationalRangeMeasure {
        &self.upper_limit_actual_rotation
    }
}
impl RevolutePairRange {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = RevolutePairRange::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.applies_to_pair = parameter.into(),
                1usize => entity.lower_limit_actual_rotation = parameter.into(),
                2usize => entity.upper_limit_actual_rotation = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IRevolutePairValue: IPairValue {
    fn applies_to_pair(&self) -> &EntityRef;
    fn actual_rotation(&self) -> &PlaneAngleMeasure;
}
#[derive(Default, Debug)]
pub struct RevolutePairValue {
    applies_to_pair: EntityRef,
    actual_rotation: PlaneAngleMeasure,
}
impl IPairValue for RevolutePairValue {
    fn applies_to_pair(&self) -> &EntityRef {
        &self.applies_to_pair
    }
}
impl IRevolutePairValue for RevolutePairValue {
    fn applies_to_pair(&self) -> &EntityRef {
        &self.applies_to_pair
    }
    fn actual_rotation(&self) -> &PlaneAngleMeasure {
        &self.actual_rotation
    }
}
impl RevolutePairValue {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = RevolutePairValue::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.applies_to_pair = parameter.into(),
                1usize => entity.actual_rotation = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IRevolvedAreaSolid: ISweptAreaSolid {
    fn axis(&self) -> &EntityRef;
    fn angle(&self) -> &PlaneAngleMeasure;
}
#[derive(Default, Debug)]
pub struct RevolvedAreaSolid {
    name: Label,
    swept_area: EntityRef,
    axis: EntityRef,
    angle: PlaneAngleMeasure,
}
impl IRepresentationItem for RevolvedAreaSolid {
    fn name(&self) -> &Label {
        &self.name
    }
}
impl IGeometricRepresentationItem for RevolvedAreaSolid {}
impl ISolidModel for RevolvedAreaSolid {}
impl ISweptAreaSolid for RevolvedAreaSolid {
    fn swept_area(&self) -> &EntityRef {
        &self.swept_area
    }
}
impl IRevolvedAreaSolid for RevolvedAreaSolid {
    fn axis(&self) -> &EntityRef {
        &self.axis
    }
    fn angle(&self) -> &PlaneAngleMeasure {
        &self.angle
    }
}
impl RevolvedAreaSolid {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = RevolvedAreaSolid::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => entity.swept_area = parameter.into(),
                2usize => entity.axis = parameter.into(),
                3usize => entity.angle = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IRevolvedFaceSolid: ISweptFaceSolid {
    fn axis(&self) -> &EntityRef;
    fn angle(&self) -> &PlaneAngleMeasure;
}
#[derive(Default, Debug)]
pub struct RevolvedFaceSolid {
    name: Label,
    swept_face: EntityRef,
    axis: EntityRef,
    angle: PlaneAngleMeasure,
}
impl IRepresentationItem for RevolvedFaceSolid {
    fn name(&self) -> &Label {
        &self.name
    }
}
impl IGeometricRepresentationItem for RevolvedFaceSolid {}
impl ISolidModel for RevolvedFaceSolid {}
impl ISweptFaceSolid for RevolvedFaceSolid {
    fn swept_face(&self) -> &EntityRef {
        &self.swept_face
    }
}
impl IRevolvedFaceSolid for RevolvedFaceSolid {
    fn axis(&self) -> &EntityRef {
        &self.axis
    }
    fn angle(&self) -> &PlaneAngleMeasure {
        &self.angle
    }
}
impl RevolvedFaceSolid {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = RevolvedFaceSolid::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => entity.swept_face = parameter.into(),
                2usize => entity.axis = parameter.into(),
                3usize => entity.angle = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IRib: IFeatureDefinition {}
#[derive(Default, Debug)]
pub struct Rib {
    name: Label,
    description: Option<Text>,
}
impl ICharacterizedObject for Rib {
    fn name(&self) -> &Label {
        &self.name
    }
    fn description(&self) -> &Option<Text> {
        &self.description
    }
}
impl IFeatureDefinition for Rib {}
impl IRib for Rib {}
impl Rib {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = Rib::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
}
pub trait IRightAngularWedge: IGeometricRepresentationItem {
    fn position(&self) -> &EntityRef;
    fn x(&self) -> &PositiveLengthMeasure;
    fn y(&self) -> &PositiveLengthMeasure;
    fn z(&self) -> &PositiveLengthMeasure;
    fn ltx(&self) -> &LengthMeasure;
}
#[derive(Default, Debug)]
pub struct RightAngularWedge {
    name: Label,
    position: EntityRef,
    x: PositiveLengthMeasure,
    y: PositiveLengthMeasure,
    z: PositiveLengthMeasure,
    ltx: LengthMeasure,
}
impl IRepresentationItem for RightAngularWedge {
    fn name(&self) -> &Label {
        &self.name
    }
}
impl IGeometricRepresentationItem for RightAngularWedge {}
impl IRightAngularWedge for RightAngularWedge {
    fn position(&self) -> &EntityRef {
        &self.position
    }
    fn x(&self) -> &PositiveLengthMeasure {
        &self.x
    }
    fn y(&self) -> &PositiveLengthMeasure {
        &self.y
    }
    fn z(&self) -> &PositiveLengthMeasure {
        &self.z
    }
    fn ltx(&self) -> &LengthMeasure {
        &self.ltx
    }
}
impl RightAngularWedge {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = RightAngularWedge::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => entity.position = parameter.into(),
                2usize => entity.x = parameter.into(),
                3usize => entity.y = parameter.into(),
                4usize => entity.z = parameter.into(),
                5usize => entity.ltx = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IRightCircularCone: IGeometricRepresentationItem {
    fn position(&self) -> &EntityRef;
    fn height(&self) -> &PositiveLengthMeasure;
    fn radius(&self) -> &LengthMeasure;
    fn semi_angle(&self) -> &PlaneAngleMeasure;
}
#[derive(Default, Debug)]
pub struct RightCircularCone {
    name: Label,
    position: EntityRef,
    height: PositiveLengthMeasure,
    radius: LengthMeasure,
    semi_angle: PlaneAngleMeasure,
}
impl IRepresentationItem for RightCircularCone {
    fn name(&self) -> &Label {
        &self.name
    }
}
impl IGeometricRepresentationItem for RightCircularCone {}
impl IRightCircularCone for RightCircularCone {
    fn position(&self) -> &EntityRef {
        &self.position
    }
    fn height(&self) -> &PositiveLengthMeasure {
        &self.height
    }
    fn radius(&self) -> &LengthMeasure {
        &self.radius
    }
    fn semi_angle(&self) -> &PlaneAngleMeasure {
        &self.semi_angle
    }
}
impl RightCircularCone {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = RightCircularCone::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => entity.position = parameter.into(),
                2usize => entity.height = parameter.into(),
                3usize => entity.radius = parameter.into(),
                4usize => entity.semi_angle = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IRightCircularCylinder: IGeometricRepresentationItem {
    fn position(&self) -> &EntityRef;
    fn height(&self) -> &PositiveLengthMeasure;
    fn radius(&self) -> &PositiveLengthMeasure;
}
#[derive(Default, Debug)]
pub struct RightCircularCylinder {
    name: Label,
    position: EntityRef,
    height: PositiveLengthMeasure,
    radius: PositiveLengthMeasure,
}
impl IRepresentationItem for RightCircularCylinder {
    fn name(&self) -> &Label {
        &self.name
    }
}
impl IGeometricRepresentationItem for RightCircularCylinder {}
impl IRightCircularCylinder for RightCircularCylinder {
    fn position(&self) -> &EntityRef {
        &self.position
    }
    fn height(&self) -> &PositiveLengthMeasure {
        &self.height
    }
    fn radius(&self) -> &PositiveLengthMeasure {
        &self.radius
    }
}
impl RightCircularCylinder {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = RightCircularCylinder::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => entity.position = parameter.into(),
                2usize => entity.height = parameter.into(),
                3usize => entity.radius = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IRoleAssociation {
    fn role(&self) -> &EntityRef;
    fn item_with_role(&self) -> &EntityRef;
}
#[derive(Default, Debug)]
pub struct RoleAssociation {
    role: EntityRef,
    item_with_role: EntityRef,
}
impl IRoleAssociation for RoleAssociation {
    fn role(&self) -> &EntityRef {
        &self.role
    }
    fn item_with_role(&self) -> &EntityRef {
        &self.item_with_role
    }
}
impl RoleAssociation {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = RoleAssociation::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.role = parameter.into(),
                1usize => entity.item_with_role = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IRollingCurvePair: IPlanarCurvePair {}
#[derive(Default, Debug)]
pub struct RollingCurvePair {
    name: Label,
    description: Option<Text>,
    transform_item_1: EntityRef,
    transform_item_2: EntityRef,
    joint: EntityRef,
    curve_1: EntityRef,
    curve_2: EntityRef,
    orientation: bool,
}
impl IItemDefinedTransformation for RollingCurvePair {
    fn name(&self) -> &Label {
        &self.name
    }
    fn description(&self) -> &Option<Text> {
        &self.description
    }
    fn transform_item_1(&self) -> &EntityRef {
        &self.transform_item_1
    }
    fn transform_item_2(&self) -> &EntityRef {
        &self.transform_item_2
    }
}
impl IKinematicPair for RollingCurvePair {
    fn joint(&self) -> &EntityRef {
        &self.joint
    }
}
impl IPlanarCurvePair for RollingCurvePair {
    fn curve_1(&self) -> &EntityRef {
        &self.curve_1
    }
    fn curve_2(&self) -> &EntityRef {
        &self.curve_2
    }
    fn orientation(&self) -> bool {
        self.orientation
    }
}
impl IRollingCurvePair for RollingCurvePair {}
impl RollingCurvePair {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = RollingCurvePair::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => entity.transform_item_1 = parameter.into(),
                3usize => entity.transform_item_2 = parameter.into(),
                4usize => entity.joint = parameter.into(),
                5usize => entity.curve_1 = parameter.into(),
                6usize => entity.curve_2 = parameter.into(),
                7usize => entity.orientation = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IRollingCurvePairValue: IPairValue {
    fn applies_to_pair(&self) -> &EntityRef;
    fn actual_point_on_curve_1(&self) -> &EntityRef;
}
#[derive(Default, Debug)]
pub struct RollingCurvePairValue {
    applies_to_pair: EntityRef,
    actual_point_on_curve_1: EntityRef,
}
impl IPairValue for RollingCurvePairValue {
    fn applies_to_pair(&self) -> &EntityRef {
        &self.applies_to_pair
    }
}
impl IRollingCurvePairValue for RollingCurvePairValue {
    fn applies_to_pair(&self) -> &EntityRef {
        &self.applies_to_pair
    }
    fn actual_point_on_curve_1(&self) -> &EntityRef {
        &self.actual_point_on_curve_1
    }
}
impl RollingCurvePairValue {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = RollingCurvePairValue::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.applies_to_pair = parameter.into(),
                1usize => entity.actual_point_on_curve_1 = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IRollingSurfacePair: ISurfacePair {}
#[derive(Default, Debug)]
pub struct RollingSurfacePair {
    name: Label,
    description: Option<Text>,
    transform_item_1: EntityRef,
    transform_item_2: EntityRef,
    joint: EntityRef,
    surface_1: EntityRef,
    surface_2: EntityRef,
    orientation: bool,
}
impl IItemDefinedTransformation for RollingSurfacePair {
    fn name(&self) -> &Label {
        &self.name
    }
    fn description(&self) -> &Option<Text> {
        &self.description
    }
    fn transform_item_1(&self) -> &EntityRef {
        &self.transform_item_1
    }
    fn transform_item_2(&self) -> &EntityRef {
        &self.transform_item_2
    }
}
impl IKinematicPair for RollingSurfacePair {
    fn joint(&self) -> &EntityRef {
        &self.joint
    }
}
impl ISurfacePair for RollingSurfacePair {
    fn surface_1(&self) -> &EntityRef {
        &self.surface_1
    }
    fn surface_2(&self) -> &EntityRef {
        &self.surface_2
    }
    fn orientation(&self) -> bool {
        self.orientation
    }
}
impl IRollingSurfacePair for RollingSurfacePair {}
impl RollingSurfacePair {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = RollingSurfacePair::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => entity.transform_item_1 = parameter.into(),
                3usize => entity.transform_item_2 = parameter.into(),
                4usize => entity.joint = parameter.into(),
                5usize => entity.surface_1 = parameter.into(),
                6usize => entity.surface_2 = parameter.into(),
                7usize => entity.orientation = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IRollingSurfacePairValue: IPairValue {
    fn applies_to_pair(&self) -> &EntityRef;
    fn actual_point_on_surface(&self) -> &EntityRef;
    fn actual_rotation(&self) -> &PlaneAngleMeasure;
}
#[derive(Default, Debug)]
pub struct RollingSurfacePairValue {
    applies_to_pair: EntityRef,
    actual_point_on_surface: EntityRef,
    actual_rotation: PlaneAngleMeasure,
}
impl IPairValue for RollingSurfacePairValue {
    fn applies_to_pair(&self) -> &EntityRef {
        &self.applies_to_pair
    }
}
impl IRollingSurfacePairValue for RollingSurfacePairValue {
    fn applies_to_pair(&self) -> &EntityRef {
        &self.applies_to_pair
    }
    fn actual_point_on_surface(&self) -> &EntityRef {
        &self.actual_point_on_surface
    }
    fn actual_rotation(&self) -> &PlaneAngleMeasure {
        &self.actual_rotation
    }
}
impl RollingSurfacePairValue {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = RollingSurfacePairValue::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.applies_to_pair = parameter.into(),
                1usize => entity.actual_point_on_surface = parameter.into(),
                2usize => entity.actual_rotation = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IRotationAboutDirection {
    fn direction_of_axis(&self) -> &EntityRef;
    fn rotation_angle(&self) -> &PlaneAngleMeasure;
}
#[derive(Default, Debug)]
pub struct RotationAboutDirection {
    direction_of_axis: EntityRef,
    rotation_angle: PlaneAngleMeasure,
}
impl IRotationAboutDirection for RotationAboutDirection {
    fn direction_of_axis(&self) -> &EntityRef {
        &self.direction_of_axis
    }
    fn rotation_angle(&self) -> &PlaneAngleMeasure {
        &self.rotation_angle
    }
}
impl RotationAboutDirection {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = RotationAboutDirection::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.direction_of_axis = parameter.into(),
                1usize => entity.rotation_angle = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IRoundHole: IFeatureDefinition {}
#[derive(Default, Debug)]
pub struct RoundHole {
    name: Label,
    description: Option<Text>,
}
impl ICharacterizedObject for RoundHole {
    fn name(&self) -> &Label {
        &self.name
    }
    fn description(&self) -> &Option<Text> {
        &self.description
    }
}
impl IFeatureDefinition for RoundHole {}
impl IRoundHole for RoundHole {}
impl RoundHole {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = RoundHole::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
}
pub trait IRoundedUProfile: IShapeAspect {}
#[derive(Default, Debug)]
pub struct RoundedUProfile {
    name: Label,
    description: Option<Text>,
    of_shape: EntityRef,
    product_definitional: Option<bool>,
}
impl IShapeAspect for RoundedUProfile {
    fn name(&self) -> &Label {
        &self.name
    }
    fn description(&self) -> &Option<Text> {
        &self.description
    }
    fn of_shape(&self) -> &EntityRef {
        &self.of_shape
    }
    fn product_definitional(&self) -> Option<bool> {
        self.product_definitional
    }
}
impl IRoundedUProfile for RoundedUProfile {}
impl RoundedUProfile {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = RoundedUProfile::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => entity.of_shape = parameter.into(),
                3usize => entity.product_definitional = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IRoundnessTolerance: IGeometricTolerance {}
#[derive(Default, Debug)]
pub struct RoundnessTolerance {
    name: Label,
    description: Text,
    magnitude: EntityRef,
    toleranced_shape_aspect: EntityRef,
}
impl IGeometricTolerance for RoundnessTolerance {
    fn name(&self) -> &Label {
        &self.name
    }
    fn description(&self) -> &Text {
        &self.description
    }
    fn magnitude(&self) -> &EntityRef {
        &self.magnitude
    }
    fn toleranced_shape_aspect(&self) -> &EntityRef {
        &self.toleranced_shape_aspect
    }
}
impl IRoundnessTolerance for RoundnessTolerance {}
impl RoundnessTolerance {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = RoundnessTolerance::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => entity.description = parameter.into(),
                2usize => entity.magnitude = parameter.into(),
                3usize => entity.toleranced_shape_aspect = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IRuledSurfaceSweptAreaSolid: ISurfaceCurveSweptAreaSolid {}
#[derive(Default, Debug)]
pub struct RuledSurfaceSweptAreaSolid {
    name: Label,
    swept_area: EntityRef,
    directrix: EntityRef,
    start_param: Real,
    end_param: Real,
    reference_surface: EntityRef,
}
impl IRepresentationItem for RuledSurfaceSweptAreaSolid {
    fn name(&self) -> &Label {
        &self.name
    }
}
impl IGeometricRepresentationItem for RuledSurfaceSweptAreaSolid {}
impl ISolidModel for RuledSurfaceSweptAreaSolid {}
impl ISweptAreaSolid for RuledSurfaceSweptAreaSolid {
    fn swept_area(&self) -> &EntityRef {
        &self.swept_area
    }
}
impl ISurfaceCurveSweptAreaSolid for RuledSurfaceSweptAreaSolid {
    fn directrix(&self) -> &EntityRef {
        &self.directrix
    }
    fn start_param(&self) -> Real {
        self.start_param
    }
    fn end_param(&self) -> Real {
        self.end_param
    }
    fn reference_surface(&self) -> &EntityRef {
        &self.reference_surface
    }
}
impl IRuledSurfaceSweptAreaSolid for RuledSurfaceSweptAreaSolid {}
impl RuledSurfaceSweptAreaSolid {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = RuledSurfaceSweptAreaSolid::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => entity.swept_area = parameter.into(),
                2usize => entity.directrix = parameter.into(),
                3usize => entity.start_param = parameter.into(),
                4usize => entity.end_param = parameter.into(),
                5usize => entity.reference_surface = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IRunoutZoneDefinition: IToleranceZoneDefinition {
    fn orientation(&self) -> &EntityRef;
}
#[derive(Default, Debug)]
pub struct RunoutZoneDefinition {
    zone: EntityRef,
    boundaries: HashSet<EntityRef>,
    orientation: EntityRef,
}
impl IToleranceZoneDefinition for RunoutZoneDefinition {
    fn zone(&self) -> &EntityRef {
        &self.zone
    }
    fn boundaries(&self) -> &HashSet<EntityRef> {
        &self.boundaries
    }
}
impl IRunoutZoneDefinition for RunoutZoneDefinition {
    fn orientation(&self) -> &EntityRef {
        &self.orientation
    }
}
impl RunoutZoneDefinition {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = RunoutZoneDefinition::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.zone = parameter.into(),
                1usize => entity.boundaries = parameter.into(),
                2usize => entity.orientation = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IRunoutZoneOrientation {
    fn angle(&self) -> &EntityRef;
}
#[derive(Default, Debug)]
pub struct RunoutZoneOrientation {
    angle: EntityRef,
}
impl IRunoutZoneOrientation for RunoutZoneOrientation {
    fn angle(&self) -> &EntityRef {
        &self.angle
    }
}
impl RunoutZoneOrientation {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = RunoutZoneOrientation::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.angle = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IRunoutZoneOrientationReferenceDirection: IRunoutZoneOrientation {
    fn orientation_defining_relationship(&self) -> &EntityRef;
}
#[derive(Default, Debug)]
pub struct RunoutZoneOrientationReferenceDirection {
    angle: EntityRef,
    orientation_defining_relationship: EntityRef,
}
impl IRunoutZoneOrientation for RunoutZoneOrientationReferenceDirection {
    fn angle(&self) -> &EntityRef {
        &self.angle
    }
}
impl IRunoutZoneOrientationReferenceDirection for RunoutZoneOrientationReferenceDirection {
    fn orientation_defining_relationship(&self) -> &EntityRef {
        &self.orientation_defining_relationship
    }
}
impl RunoutZoneOrientationReferenceDirection {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = RunoutZoneOrientationReferenceDirection::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.angle = parameter.into(),
                1usize => entity.orientation_defining_relationship = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IScrewPair: IKinematicPair {
    fn pitch(&self) -> &LengthMeasure;
}
#[derive(Default, Debug)]
pub struct ScrewPair {
    name: Label,
    description: Option<Text>,
    transform_item_1: EntityRef,
    transform_item_2: EntityRef,
    joint: EntityRef,
    pitch: LengthMeasure,
}
impl IItemDefinedTransformation for ScrewPair {
    fn name(&self) -> &Label {
        &self.name
    }
    fn description(&self) -> &Option<Text> {
        &self.description
    }
    fn transform_item_1(&self) -> &EntityRef {
        &self.transform_item_1
    }
    fn transform_item_2(&self) -> &EntityRef {
        &self.transform_item_2
    }
}
impl IKinematicPair for ScrewPair {
    fn joint(&self) -> &EntityRef {
        &self.joint
    }
}
impl IScrewPair for ScrewPair {
    fn pitch(&self) -> &LengthMeasure {
        &self.pitch
    }
}
impl ScrewPair {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = ScrewPair::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => entity.transform_item_1 = parameter.into(),
                3usize => entity.transform_item_2 = parameter.into(),
                4usize => entity.joint = parameter.into(),
                5usize => entity.pitch = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IScrewPairRange: ISimplePairRange {
    fn applies_to_pair(&self) -> &EntityRef;
    fn lower_limit_actual_rotation(&self) -> &RotationalRangeMeasure;
    fn upper_limit_actual_rotation(&self) -> &RotationalRangeMeasure;
}
#[derive(Default, Debug)]
pub struct ScrewPairRange {
    applies_to_pair: EntityRef,
    lower_limit_actual_rotation: RotationalRangeMeasure,
    upper_limit_actual_rotation: RotationalRangeMeasure,
}
impl ISimplePairRange for ScrewPairRange {
    fn applies_to_pair(&self) -> &EntityRef {
        &self.applies_to_pair
    }
}
impl IScrewPairRange for ScrewPairRange {
    fn applies_to_pair(&self) -> &EntityRef {
        &self.applies_to_pair
    }
    fn lower_limit_actual_rotation(&self) -> &RotationalRangeMeasure {
        &self.lower_limit_actual_rotation
    }
    fn upper_limit_actual_rotation(&self) -> &RotationalRangeMeasure {
        &self.upper_limit_actual_rotation
    }
}
impl ScrewPairRange {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = ScrewPairRange::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.applies_to_pair = parameter.into(),
                1usize => entity.lower_limit_actual_rotation = parameter.into(),
                2usize => entity.upper_limit_actual_rotation = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IScrewPairValue: IPairValue {
    fn applies_to_pair(&self) -> &EntityRef;
    fn actual_rotation(&self) -> &PlaneAngleMeasure;
}
#[derive(Default, Debug)]
pub struct ScrewPairValue {
    applies_to_pair: EntityRef,
    actual_rotation: PlaneAngleMeasure,
}
impl IPairValue for ScrewPairValue {
    fn applies_to_pair(&self) -> &EntityRef {
        &self.applies_to_pair
    }
}
impl IScrewPairValue for ScrewPairValue {
    fn applies_to_pair(&self) -> &EntityRef {
        &self.applies_to_pair
    }
    fn actual_rotation(&self) -> &PlaneAngleMeasure {
        &self.actual_rotation
    }
}
impl ScrewPairValue {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = ScrewPairValue::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.applies_to_pair = parameter.into(),
                1usize => entity.actual_rotation = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait ISeamCurve: ISurfaceCurve {}
#[derive(Default, Debug)]
pub struct SeamCurve {
    name: Label,
    curve_3d: EntityRef,
    associated_geometry: Vec<EntityRef>,
    master_representation: PreferredSurfaceCurveRepresentation,
}
impl IRepresentationItem for SeamCurve {
    fn name(&self) -> &Label {
        &self.name
    }
}
impl IGeometricRepresentationItem for SeamCurve {}
impl ICurve for SeamCurve {}
impl ISurfaceCurve for SeamCurve {
    fn curve_3d(&self) -> &EntityRef {
        &self.curve_3d
    }
    fn associated_geometry(&self) -> &Vec<EntityRef> {
        &self.associated_geometry
    }
    fn master_representation(&self) -> &PreferredSurfaceCurveRepresentation {
        &self.master_representation
    }
}
impl ISeamCurve for SeamCurve {}
impl SeamCurve {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = SeamCurve::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => entity.curve_3d = parameter.into(),
                2usize => entity.associated_geometry = parameter.into(),
                3usize => entity.master_representation = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait ISeamEdge: IOrientedEdge {
    fn pcurve_reference(&self) -> &EntityRef;
}
#[derive(Default, Debug)]
pub struct SeamEdge {
    name: Label,
    edge_start: EntityRef,
    edge_end: EntityRef,
    edge_element: EntityRef,
    orientation: bool,
    pcurve_reference: EntityRef,
}
impl IRepresentationItem for SeamEdge {
    fn name(&self) -> &Label {
        &self.name
    }
}
impl ITopologicalRepresentationItem for SeamEdge {}
impl IEdge for SeamEdge {
    fn edge_start(&self) -> &EntityRef {
        &self.edge_start
    }
    fn edge_end(&self) -> &EntityRef {
        &self.edge_end
    }
}
impl IOrientedEdge for SeamEdge {
    fn edge_element(&self) -> &EntityRef {
        &self.edge_element
    }
    fn orientation(&self) -> bool {
        self.orientation
    }
}
impl ISeamEdge for SeamEdge {
    fn pcurve_reference(&self) -> &EntityRef {
        &self.pcurve_reference
    }
}
impl SeamEdge {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = SeamEdge::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => entity.edge_start = parameter.into(),
                2usize => entity.edge_end = parameter.into(),
                3usize => entity.edge_element = parameter.into(),
                4usize => entity.orientation = parameter.into(),
                5usize => entity.pcurve_reference = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait ISecurityClassification {
    fn name(&self) -> &Label;
    fn purpose(&self) -> &Text;
    fn security_level(&self) -> &EntityRef;
}
#[derive(Default, Debug)]
pub struct SecurityClassification {
    name: Label,
    purpose: Text,
    security_level: EntityRef,
}
impl ISecurityClassification for SecurityClassification {
    fn name(&self) -> &Label {
        &self.name
    }
    fn purpose(&self) -> &Text {
        &self.purpose
    }
    fn security_level(&self) -> &EntityRef {
        &self.security_level
    }
}
impl SecurityClassification {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = SecurityClassification::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => entity.purpose = parameter.into(),
                2usize => entity.security_level = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait ISecurityClassificationAssignment {
    fn assigned_security_classification(&self) -> &EntityRef;
}
pub trait ISecurityClassificationLevel {
    fn name(&self) -> &Label;
}
#[derive(Default, Debug)]
pub struct SecurityClassificationLevel {
    name: Label,
}
impl ISecurityClassificationLevel for SecurityClassificationLevel {
    fn name(&self) -> &Label {
        &self.name
    }
}
impl SecurityClassificationLevel {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = SecurityClassificationLevel::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait ISerialNumberedEffectivity: IEffectivity {
    fn effectivity_start_id(&self) -> &Identifier;
    fn effectivity_end_id(&self) -> &Option<Identifier>;
}
#[derive(Default, Debug)]
pub struct SerialNumberedEffectivity {
    id: Identifier,
    effectivity_start_id: Identifier,
    effectivity_end_id: Option<Identifier>,
}
impl IEffectivity for SerialNumberedEffectivity {
    fn id(&self) -> &Identifier {
        &self.id
    }
}
impl ISerialNumberedEffectivity for SerialNumberedEffectivity {
    fn effectivity_start_id(&self) -> &Identifier {
        &self.effectivity_start_id
    }
    fn effectivity_end_id(&self) -> &Option<Identifier> {
        &self.effectivity_end_id
    }
}
impl SerialNumberedEffectivity {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = SerialNumberedEffectivity::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.id = parameter.into(),
                1usize => entity.effectivity_start_id = parameter.into(),
                2usize => {
                    entity.effectivity_end_id = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
}
pub trait IShapeAspect {
    fn name(&self) -> &Label;
    fn description(&self) -> &Option<Text>;
    fn of_shape(&self) -> &EntityRef;
    fn product_definitional(&self) -> Option<bool>;
}
#[derive(Default, Debug)]
pub struct ShapeAspect {
    name: Label,
    description: Option<Text>,
    of_shape: EntityRef,
    product_definitional: Option<bool>,
}
impl IShapeAspect for ShapeAspect {
    fn name(&self) -> &Label {
        &self.name
    }
    fn description(&self) -> &Option<Text> {
        &self.description
    }
    fn of_shape(&self) -> &EntityRef {
        &self.of_shape
    }
    fn product_definitional(&self) -> Option<bool> {
        self.product_definitional
    }
}
impl ShapeAspect {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = ShapeAspect::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => entity.of_shape = parameter.into(),
                3usize => entity.product_definitional = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IShapeAspectAssociativity: IShapeAspectRelationship {}
#[derive(Default, Debug)]
pub struct ShapeAspectAssociativity {
    name: Label,
    description: Option<Text>,
    relating_shape_aspect: EntityRef,
    related_shape_aspect: EntityRef,
}
impl IShapeAspectRelationship for ShapeAspectAssociativity {
    fn name(&self) -> &Label {
        &self.name
    }
    fn description(&self) -> &Option<Text> {
        &self.description
    }
    fn relating_shape_aspect(&self) -> &EntityRef {
        &self.relating_shape_aspect
    }
    fn related_shape_aspect(&self) -> &EntityRef {
        &self.related_shape_aspect
    }
}
impl IShapeAspectAssociativity for ShapeAspectAssociativity {}
impl ShapeAspectAssociativity {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = ShapeAspectAssociativity::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => entity.relating_shape_aspect = parameter.into(),
                3usize => entity.related_shape_aspect = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IShapeAspectDerivingRelationship: IShapeAspectRelationship {}
#[derive(Default, Debug)]
pub struct ShapeAspectDerivingRelationship {
    name: Label,
    description: Option<Text>,
    relating_shape_aspect: EntityRef,
    related_shape_aspect: EntityRef,
}
impl IShapeAspectRelationship for ShapeAspectDerivingRelationship {
    fn name(&self) -> &Label {
        &self.name
    }
    fn description(&self) -> &Option<Text> {
        &self.description
    }
    fn relating_shape_aspect(&self) -> &EntityRef {
        &self.relating_shape_aspect
    }
    fn related_shape_aspect(&self) -> &EntityRef {
        &self.related_shape_aspect
    }
}
impl IShapeAspectDerivingRelationship for ShapeAspectDerivingRelationship {}
impl ShapeAspectDerivingRelationship {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = ShapeAspectDerivingRelationship::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => entity.relating_shape_aspect = parameter.into(),
                3usize => entity.related_shape_aspect = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IShapeAspectRelationship {
    fn name(&self) -> &Label;
    fn description(&self) -> &Option<Text>;
    fn relating_shape_aspect(&self) -> &EntityRef;
    fn related_shape_aspect(&self) -> &EntityRef;
}
#[derive(Default, Debug)]
pub struct ShapeAspectRelationship {
    name: Label,
    description: Option<Text>,
    relating_shape_aspect: EntityRef,
    related_shape_aspect: EntityRef,
}
impl IShapeAspectRelationship for ShapeAspectRelationship {
    fn name(&self) -> &Label {
        &self.name
    }
    fn description(&self) -> &Option<Text> {
        &self.description
    }
    fn relating_shape_aspect(&self) -> &EntityRef {
        &self.relating_shape_aspect
    }
    fn related_shape_aspect(&self) -> &EntityRef {
        &self.related_shape_aspect
    }
}
impl ShapeAspectRelationship {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = ShapeAspectRelationship::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => entity.relating_shape_aspect = parameter.into(),
                3usize => entity.related_shape_aspect = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IShapeAspectTransition: IShapeAspectRelationship {}
#[derive(Default, Debug)]
pub struct ShapeAspectTransition {
    name: Label,
    description: Option<Text>,
    relating_shape_aspect: EntityRef,
    related_shape_aspect: EntityRef,
}
impl IShapeAspectRelationship for ShapeAspectTransition {
    fn name(&self) -> &Label {
        &self.name
    }
    fn description(&self) -> &Option<Text> {
        &self.description
    }
    fn relating_shape_aspect(&self) -> &EntityRef {
        &self.relating_shape_aspect
    }
    fn related_shape_aspect(&self) -> &EntityRef {
        &self.related_shape_aspect
    }
}
impl IShapeAspectTransition for ShapeAspectTransition {}
impl ShapeAspectTransition {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = ShapeAspectTransition::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => entity.relating_shape_aspect = parameter.into(),
                3usize => entity.related_shape_aspect = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IShapeDefiningRelationship: IShapeAspectRelationship {}
#[derive(Default, Debug)]
pub struct ShapeDefiningRelationship {
    name: Label,
    description: Option<Text>,
    relating_shape_aspect: EntityRef,
    related_shape_aspect: EntityRef,
}
impl IShapeAspectRelationship for ShapeDefiningRelationship {
    fn name(&self) -> &Label {
        &self.name
    }
    fn description(&self) -> &Option<Text> {
        &self.description
    }
    fn relating_shape_aspect(&self) -> &EntityRef {
        &self.relating_shape_aspect
    }
    fn related_shape_aspect(&self) -> &EntityRef {
        &self.related_shape_aspect
    }
}
impl IShapeDefiningRelationship for ShapeDefiningRelationship {}
impl ShapeDefiningRelationship {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = ShapeDefiningRelationship::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => entity.relating_shape_aspect = parameter.into(),
                3usize => entity.related_shape_aspect = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IShapeDefinitionRepresentation: IPropertyDefinitionRepresentation {}
#[derive(Default, Debug)]
pub struct ShapeDefinitionRepresentation {
    definition: EntityRef,
    used_representation: EntityRef,
}
impl IPropertyDefinitionRepresentation for ShapeDefinitionRepresentation {
    fn definition(&self) -> &EntityRef {
        &self.definition
    }
    fn used_representation(&self) -> &EntityRef {
        &self.used_representation
    }
}
impl IShapeDefinitionRepresentation for ShapeDefinitionRepresentation {}
impl ShapeDefinitionRepresentation {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = ShapeDefinitionRepresentation::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.definition = parameter.into(),
                1usize => entity.used_representation = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IShapeDimensionRepresentation: IShapeRepresentation {}
#[derive(Default, Debug)]
pub struct ShapeDimensionRepresentation {
    name: Label,
    items: HashSet<EntityRef>,
    context_of_items: EntityRef,
}
impl IRepresentation for ShapeDimensionRepresentation {
    fn name(&self) -> &Label {
        &self.name
    }
    fn items(&self) -> &HashSet<EntityRef> {
        &self.items
    }
    fn context_of_items(&self) -> &EntityRef {
        &self.context_of_items
    }
}
impl IShapeRepresentation for ShapeDimensionRepresentation {}
impl IShapeDimensionRepresentation for ShapeDimensionRepresentation {}
impl ShapeDimensionRepresentation {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = ShapeDimensionRepresentation::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => entity.items = parameter.into(),
                2usize => entity.context_of_items = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IShapeRepresentation: IRepresentation {}
#[derive(Default, Debug)]
pub struct ShapeRepresentation {
    name: Label,
    items: HashSet<EntityRef>,
    context_of_items: EntityRef,
}
impl IRepresentation for ShapeRepresentation {
    fn name(&self) -> &Label {
        &self.name
    }
    fn items(&self) -> &HashSet<EntityRef> {
        &self.items
    }
    fn context_of_items(&self) -> &EntityRef {
        &self.context_of_items
    }
}
impl IShapeRepresentation for ShapeRepresentation {}
impl ShapeRepresentation {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = ShapeRepresentation::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => entity.items = parameter.into(),
                2usize => entity.context_of_items = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IShapeRepresentationRelationship: IRepresentationRelationship {}
#[derive(Default, Debug)]
pub struct ShapeRepresentationRelationship {
    name: Label,
    description: Option<Text>,
    rep_1: EntityRef,
    rep_2: EntityRef,
}
impl IRepresentationRelationship for ShapeRepresentationRelationship {
    fn name(&self) -> &Label {
        &self.name
    }
    fn description(&self) -> &Option<Text> {
        &self.description
    }
    fn rep_1(&self) -> &EntityRef {
        &self.rep_1
    }
    fn rep_2(&self) -> &EntityRef {
        &self.rep_2
    }
}
impl IShapeRepresentationRelationship for ShapeRepresentationRelationship {}
impl ShapeRepresentationRelationship {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = ShapeRepresentationRelationship::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => entity.rep_1 = parameter.into(),
                3usize => entity.rep_2 = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IShapeRepresentationWithParameters: IShapeRepresentation {}
#[derive(Default, Debug)]
pub struct ShapeRepresentationWithParameters {
    name: Label,
    items: HashSet<EntityRef>,
    context_of_items: EntityRef,
}
impl IRepresentation for ShapeRepresentationWithParameters {
    fn name(&self) -> &Label {
        &self.name
    }
    fn items(&self) -> &HashSet<EntityRef> {
        &self.items
    }
    fn context_of_items(&self) -> &EntityRef {
        &self.context_of_items
    }
}
impl IShapeRepresentation for ShapeRepresentationWithParameters {}
impl IShapeRepresentationWithParameters for ShapeRepresentationWithParameters {}
impl ShapeRepresentationWithParameters {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = ShapeRepresentationWithParameters::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => entity.items = parameter.into(),
                2usize => entity.context_of_items = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IShellBasedSurfaceModel: IGeometricRepresentationItem {
    fn sbsm_boundary(&self) -> &HashSet<EntityRef>;
}
#[derive(Default, Debug)]
pub struct ShellBasedSurfaceModel {
    name: Label,
    sbsm_boundary: HashSet<EntityRef>,
}
impl IRepresentationItem for ShellBasedSurfaceModel {
    fn name(&self) -> &Label {
        &self.name
    }
}
impl IGeometricRepresentationItem for ShellBasedSurfaceModel {}
impl IShellBasedSurfaceModel for ShellBasedSurfaceModel {
    fn sbsm_boundary(&self) -> &HashSet<EntityRef> {
        &self.sbsm_boundary
    }
}
impl ShellBasedSurfaceModel {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = ShellBasedSurfaceModel::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => entity.sbsm_boundary = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait ISiUnit: INamedUnit {
    fn prefix(&self) -> &Option<SiPrefix>;
    fn name(&self) -> &SiUnitName;
}
#[derive(Default, Debug)]
pub struct SiUnit {
    dimensions: EntityRef,
    prefix: Option<SiPrefix>,
    name: SiUnitName,
}
impl INamedUnit for SiUnit {
    fn dimensions(&self) -> &EntityRef {
        &self.dimensions
    }
}
impl ISiUnit for SiUnit {
    fn prefix(&self) -> &Option<SiPrefix> {
        &self.prefix
    }
    fn name(&self) -> &SiUnitName {
        &self.name
    }
}
impl SiUnit {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = SiUnit::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.dimensions = parameter.into(),
                1usize => {
                    entity.prefix = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => entity.name = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait ISimpleBooleanExpression: IBooleanExpression + ISimpleGenericExpression {}
pub trait ISimpleGenericExpression: IGenericExpression {}
pub trait ISimpleNumericExpression: INumericExpression + ISimpleGenericExpression {}
pub trait ISimplePairRange {
    fn applies_to_pair(&self) -> &EntityRef;
}
#[derive(Default, Debug)]
pub struct SimplePairRange {
    applies_to_pair: EntityRef,
}
impl ISimplePairRange for SimplePairRange {
    fn applies_to_pair(&self) -> &EntityRef {
        &self.applies_to_pair
    }
}
impl SimplePairRange {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = SimplePairRange::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.applies_to_pair = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait ISimpleStringExpression: IStringExpression + ISimpleGenericExpression {}
pub trait ISinFunction: IUnaryFunctionCall {}
#[derive(Default, Debug)]
pub struct SinFunction {
    operand: EntityRef,
}
impl IGenericExpression for SinFunction {}
impl IExpression for SinFunction {}
impl INumericExpression for SinFunction {}
impl IUnaryNumericExpression for SinFunction {
    fn operand(&self) -> &EntityRef {
        &self.operand
    }
}
impl IUnaryGenericExpression for SinFunction {
    fn operand(&self) -> &EntityRef {
        &self.operand
    }
}
impl IUnaryFunctionCall for SinFunction {}
impl ISinFunction for SinFunction {}
impl SinFunction {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = SinFunction::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.operand = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait ISlashExpression: IBinaryNumericExpression {}
#[derive(Default, Debug)]
pub struct SlashExpression {
    operands: Vec<EntityRef>,
}
impl IGenericExpression for SlashExpression {}
impl IExpression for SlashExpression {}
impl INumericExpression for SlashExpression {}
impl IBinaryNumericExpression for SlashExpression {
    fn operands(&self) -> &Vec<EntityRef> {
        &self.operands
    }
}
impl IBinaryGenericExpression for SlashExpression {
    fn operands(&self) -> &Vec<EntityRef> {
        &self.operands
    }
}
impl ISlashExpression for SlashExpression {}
impl SlashExpression {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = SlashExpression::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.operands = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait ISlidingCurvePair: IPlanarCurvePair {}
#[derive(Default, Debug)]
pub struct SlidingCurvePair {
    name: Label,
    description: Option<Text>,
    transform_item_1: EntityRef,
    transform_item_2: EntityRef,
    joint: EntityRef,
    curve_1: EntityRef,
    curve_2: EntityRef,
    orientation: bool,
}
impl IItemDefinedTransformation for SlidingCurvePair {
    fn name(&self) -> &Label {
        &self.name
    }
    fn description(&self) -> &Option<Text> {
        &self.description
    }
    fn transform_item_1(&self) -> &EntityRef {
        &self.transform_item_1
    }
    fn transform_item_2(&self) -> &EntityRef {
        &self.transform_item_2
    }
}
impl IKinematicPair for SlidingCurvePair {
    fn joint(&self) -> &EntityRef {
        &self.joint
    }
}
impl IPlanarCurvePair for SlidingCurvePair {
    fn curve_1(&self) -> &EntityRef {
        &self.curve_1
    }
    fn curve_2(&self) -> &EntityRef {
        &self.curve_2
    }
    fn orientation(&self) -> bool {
        self.orientation
    }
}
impl ISlidingCurvePair for SlidingCurvePair {}
impl SlidingCurvePair {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = SlidingCurvePair::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => entity.transform_item_1 = parameter.into(),
                3usize => entity.transform_item_2 = parameter.into(),
                4usize => entity.joint = parameter.into(),
                5usize => entity.curve_1 = parameter.into(),
                6usize => entity.curve_2 = parameter.into(),
                7usize => entity.orientation = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait ISlidingCurvePairValue: IPairValue {
    fn applies_to_pair(&self) -> &EntityRef;
    fn actual_point_on_curve_1(&self) -> &EntityRef;
    fn actual_point_on_curve_2(&self) -> &EntityRef;
}
#[derive(Default, Debug)]
pub struct SlidingCurvePairValue {
    applies_to_pair: EntityRef,
    actual_point_on_curve_1: EntityRef,
    actual_point_on_curve_2: EntityRef,
}
impl IPairValue for SlidingCurvePairValue {
    fn applies_to_pair(&self) -> &EntityRef {
        &self.applies_to_pair
    }
}
impl ISlidingCurvePairValue for SlidingCurvePairValue {
    fn applies_to_pair(&self) -> &EntityRef {
        &self.applies_to_pair
    }
    fn actual_point_on_curve_1(&self) -> &EntityRef {
        &self.actual_point_on_curve_1
    }
    fn actual_point_on_curve_2(&self) -> &EntityRef {
        &self.actual_point_on_curve_2
    }
}
impl SlidingCurvePairValue {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = SlidingCurvePairValue::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.applies_to_pair = parameter.into(),
                1usize => entity.actual_point_on_curve_1 = parameter.into(),
                2usize => entity.actual_point_on_curve_2 = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait ISlidingSurfacePair: ISurfacePair {}
#[derive(Default, Debug)]
pub struct SlidingSurfacePair {
    name: Label,
    description: Option<Text>,
    transform_item_1: EntityRef,
    transform_item_2: EntityRef,
    joint: EntityRef,
    surface_1: EntityRef,
    surface_2: EntityRef,
    orientation: bool,
}
impl IItemDefinedTransformation for SlidingSurfacePair {
    fn name(&self) -> &Label {
        &self.name
    }
    fn description(&self) -> &Option<Text> {
        &self.description
    }
    fn transform_item_1(&self) -> &EntityRef {
        &self.transform_item_1
    }
    fn transform_item_2(&self) -> &EntityRef {
        &self.transform_item_2
    }
}
impl IKinematicPair for SlidingSurfacePair {
    fn joint(&self) -> &EntityRef {
        &self.joint
    }
}
impl ISurfacePair for SlidingSurfacePair {
    fn surface_1(&self) -> &EntityRef {
        &self.surface_1
    }
    fn surface_2(&self) -> &EntityRef {
        &self.surface_2
    }
    fn orientation(&self) -> bool {
        self.orientation
    }
}
impl ISlidingSurfacePair for SlidingSurfacePair {}
impl SlidingSurfacePair {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = SlidingSurfacePair::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => entity.transform_item_1 = parameter.into(),
                3usize => entity.transform_item_2 = parameter.into(),
                4usize => entity.joint = parameter.into(),
                5usize => entity.surface_1 = parameter.into(),
                6usize => entity.surface_2 = parameter.into(),
                7usize => entity.orientation = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait ISlidingSurfacePairValue: IPairValue {
    fn applies_to_pair(&self) -> &EntityRef;
    fn actual_point_on_surface_1(&self) -> &EntityRef;
    fn actual_point_on_surface_2(&self) -> &EntityRef;
    fn actual_rotation(&self) -> &PlaneAngleMeasure;
}
#[derive(Default, Debug)]
pub struct SlidingSurfacePairValue {
    applies_to_pair: EntityRef,
    actual_point_on_surface_1: EntityRef,
    actual_point_on_surface_2: EntityRef,
    actual_rotation: PlaneAngleMeasure,
}
impl IPairValue for SlidingSurfacePairValue {
    fn applies_to_pair(&self) -> &EntityRef {
        &self.applies_to_pair
    }
}
impl ISlidingSurfacePairValue for SlidingSurfacePairValue {
    fn applies_to_pair(&self) -> &EntityRef {
        &self.applies_to_pair
    }
    fn actual_point_on_surface_1(&self) -> &EntityRef {
        &self.actual_point_on_surface_1
    }
    fn actual_point_on_surface_2(&self) -> &EntityRef {
        &self.actual_point_on_surface_2
    }
    fn actual_rotation(&self) -> &PlaneAngleMeasure {
        &self.actual_rotation
    }
}
impl SlidingSurfacePairValue {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = SlidingSurfacePairValue::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.applies_to_pair = parameter.into(),
                1usize => entity.actual_point_on_surface_1 = parameter.into(),
                2usize => entity.actual_point_on_surface_2 = parameter.into(),
                3usize => entity.actual_rotation = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait ISlot: IFeatureDefinition {}
#[derive(Default, Debug)]
pub struct Slot {
    name: Label,
    description: Option<Text>,
}
impl ICharacterizedObject for Slot {
    fn name(&self) -> &Label {
        &self.name
    }
    fn description(&self) -> &Option<Text> {
        &self.description
    }
}
impl IFeatureDefinition for Slot {}
impl ISlot for Slot {}
impl Slot {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = Slot::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
}
pub trait ISlotEnd: IShapeAspect {}
#[derive(Default, Debug)]
pub struct SlotEnd {
    name: Label,
    description: Option<Text>,
    of_shape: EntityRef,
    product_definitional: Option<bool>,
}
impl IShapeAspect for SlotEnd {
    fn name(&self) -> &Label {
        &self.name
    }
    fn description(&self) -> &Option<Text> {
        &self.description
    }
    fn of_shape(&self) -> &EntityRef {
        &self.of_shape
    }
    fn product_definitional(&self) -> Option<bool> {
        self.product_definitional
    }
}
impl ISlotEnd for SlotEnd {}
impl SlotEnd {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = SlotEnd::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => entity.of_shape = parameter.into(),
                3usize => entity.product_definitional = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait ISolidAngleMeasureWithUnit: IMeasureWithUnit {}
#[derive(Default, Debug)]
pub struct SolidAngleMeasureWithUnit {
    value_component: MeasureValue,
    unit_component: EntityRef,
}
impl IMeasureWithUnit for SolidAngleMeasureWithUnit {
    fn value_component(&self) -> &MeasureValue {
        &self.value_component
    }
    fn unit_component(&self) -> &EntityRef {
        &self.unit_component
    }
}
impl ISolidAngleMeasureWithUnit for SolidAngleMeasureWithUnit {}
impl SolidAngleMeasureWithUnit {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = SolidAngleMeasureWithUnit::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.value_component = parameter.into(),
                1usize => entity.unit_component = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait ISolidAngleUnit: INamedUnit {}
#[derive(Default, Debug)]
pub struct SolidAngleUnit {
    dimensions: EntityRef,
}
impl INamedUnit for SolidAngleUnit {
    fn dimensions(&self) -> &EntityRef {
        &self.dimensions
    }
}
impl ISolidAngleUnit for SolidAngleUnit {}
impl SolidAngleUnit {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = SolidAngleUnit::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.dimensions = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait ISolidModel: IGeometricRepresentationItem {}
#[derive(Default, Debug)]
pub struct SolidModel {
    name: Label,
}
impl IRepresentationItem for SolidModel {
    fn name(&self) -> &Label {
        &self.name
    }
}
impl IGeometricRepresentationItem for SolidModel {}
impl ISolidModel for SolidModel {}
impl SolidModel {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = SolidModel::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait ISolidReplica: ISolidModel {
    fn parent_solid(&self) -> &EntityRef;
    fn transformation(&self) -> &EntityRef;
}
#[derive(Default, Debug)]
pub struct SolidReplica {
    name: Label,
    parent_solid: EntityRef,
    transformation: EntityRef,
}
impl IRepresentationItem for SolidReplica {
    fn name(&self) -> &Label {
        &self.name
    }
}
impl IGeometricRepresentationItem for SolidReplica {}
impl ISolidModel for SolidReplica {}
impl ISolidReplica for SolidReplica {
    fn parent_solid(&self) -> &EntityRef {
        &self.parent_solid
    }
    fn transformation(&self) -> &EntityRef {
        &self.transformation
    }
}
impl SolidReplica {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = SolidReplica::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => entity.parent_solid = parameter.into(),
                2usize => entity.transformation = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait ISpecifiedHigherUsageOccurrence: IAssemblyComponentUsage {
    fn upper_usage(&self) -> &EntityRef;
    fn next_usage(&self) -> &EntityRef;
}
#[derive(Default, Debug)]
pub struct SpecifiedHigherUsageOccurrence {
    id: Identifier,
    name: Label,
    description: Option<Text>,
    relating_product_definition: EntityRef,
    related_product_definition: EntityRef,
    reference_designator: Option<Identifier>,
    upper_usage: EntityRef,
    next_usage: EntityRef,
}
impl IProductDefinitionRelationship for SpecifiedHigherUsageOccurrence {
    fn id(&self) -> &Identifier {
        &self.id
    }
    fn name(&self) -> &Label {
        &self.name
    }
    fn description(&self) -> &Option<Text> {
        &self.description
    }
    fn relating_product_definition(&self) -> &EntityRef {
        &self.relating_product_definition
    }
    fn related_product_definition(&self) -> &EntityRef {
        &self.related_product_definition
    }
}
impl IProductDefinitionUsage for SpecifiedHigherUsageOccurrence {}
impl IAssemblyComponentUsage for SpecifiedHigherUsageOccurrence {
    fn reference_designator(&self) -> &Option<Identifier> {
        &self.reference_designator
    }
}
impl ISpecifiedHigherUsageOccurrence for SpecifiedHigherUsageOccurrence {
    fn upper_usage(&self) -> &EntityRef {
        &self.upper_usage
    }
    fn next_usage(&self) -> &EntityRef {
        &self.next_usage
    }
}
impl SpecifiedHigherUsageOccurrence {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = SpecifiedHigherUsageOccurrence::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.id = parameter.into(),
                1usize => entity.name = parameter.into(),
                2usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => entity.relating_product_definition = parameter.into(),
                4usize => entity.related_product_definition = parameter.into(),
                5usize => {
                    entity.reference_designator = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                6usize => entity.upper_usage = parameter.into(),
                7usize => entity.next_usage = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait ISphere: IGeometricRepresentationItem {
    fn radius(&self) -> &PositiveLengthMeasure;
    fn centre(&self) -> &EntityRef;
}
#[derive(Default, Debug)]
pub struct Sphere {
    name: Label,
    radius: PositiveLengthMeasure,
    centre: EntityRef,
}
impl IRepresentationItem for Sphere {
    fn name(&self) -> &Label {
        &self.name
    }
}
impl IGeometricRepresentationItem for Sphere {}
impl ISphere for Sphere {
    fn radius(&self) -> &PositiveLengthMeasure {
        &self.radius
    }
    fn centre(&self) -> &EntityRef {
        &self.centre
    }
}
impl Sphere {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = Sphere::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => entity.radius = parameter.into(),
                2usize => entity.centre = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait ISphericalPair: IKinematicPair {}
#[derive(Default, Debug)]
pub struct SphericalPair {
    name: Label,
    description: Option<Text>,
    transform_item_1: EntityRef,
    transform_item_2: EntityRef,
    joint: EntityRef,
}
impl IItemDefinedTransformation for SphericalPair {
    fn name(&self) -> &Label {
        &self.name
    }
    fn description(&self) -> &Option<Text> {
        &self.description
    }
    fn transform_item_1(&self) -> &EntityRef {
        &self.transform_item_1
    }
    fn transform_item_2(&self) -> &EntityRef {
        &self.transform_item_2
    }
}
impl IKinematicPair for SphericalPair {
    fn joint(&self) -> &EntityRef {
        &self.joint
    }
}
impl ISphericalPair for SphericalPair {}
impl SphericalPair {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = SphericalPair::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => entity.transform_item_1 = parameter.into(),
                3usize => entity.transform_item_2 = parameter.into(),
                4usize => entity.joint = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait ISphericalPairRange: ISimplePairRange {
    fn applies_to_pair(&self) -> &EntityRef;
    fn lower_limit_yaw(&self) -> &RotationalRangeMeasure;
    fn upper_limit_yaw(&self) -> &RotationalRangeMeasure;
    fn lower_limit_pitch(&self) -> &RotationalRangeMeasure;
    fn upper_limit_pitch(&self) -> &RotationalRangeMeasure;
    fn lower_limit_roll(&self) -> &RotationalRangeMeasure;
    fn upper_limit_roll(&self) -> &RotationalRangeMeasure;
}
#[derive(Default, Debug)]
pub struct SphericalPairRange {
    applies_to_pair: EntityRef,
    lower_limit_yaw: RotationalRangeMeasure,
    upper_limit_yaw: RotationalRangeMeasure,
    lower_limit_pitch: RotationalRangeMeasure,
    upper_limit_pitch: RotationalRangeMeasure,
    lower_limit_roll: RotationalRangeMeasure,
    upper_limit_roll: RotationalRangeMeasure,
}
impl ISimplePairRange for SphericalPairRange {
    fn applies_to_pair(&self) -> &EntityRef {
        &self.applies_to_pair
    }
}
impl ISphericalPairRange for SphericalPairRange {
    fn applies_to_pair(&self) -> &EntityRef {
        &self.applies_to_pair
    }
    fn lower_limit_yaw(&self) -> &RotationalRangeMeasure {
        &self.lower_limit_yaw
    }
    fn upper_limit_yaw(&self) -> &RotationalRangeMeasure {
        &self.upper_limit_yaw
    }
    fn lower_limit_pitch(&self) -> &RotationalRangeMeasure {
        &self.lower_limit_pitch
    }
    fn upper_limit_pitch(&self) -> &RotationalRangeMeasure {
        &self.upper_limit_pitch
    }
    fn lower_limit_roll(&self) -> &RotationalRangeMeasure {
        &self.lower_limit_roll
    }
    fn upper_limit_roll(&self) -> &RotationalRangeMeasure {
        &self.upper_limit_roll
    }
}
impl SphericalPairRange {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = SphericalPairRange::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.applies_to_pair = parameter.into(),
                1usize => entity.lower_limit_yaw = parameter.into(),
                2usize => entity.upper_limit_yaw = parameter.into(),
                3usize => entity.lower_limit_pitch = parameter.into(),
                4usize => entity.upper_limit_pitch = parameter.into(),
                5usize => entity.lower_limit_roll = parameter.into(),
                6usize => entity.upper_limit_roll = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait ISphericalPairValue: IPairValue {
    fn applies_to_pair(&self) -> &EntityRef;
    fn input_orientation(&self) -> &SpatialRotation;
}
#[derive(Default, Debug)]
pub struct SphericalPairValue {
    applies_to_pair: EntityRef,
    input_orientation: SpatialRotation,
}
impl IPairValue for SphericalPairValue {
    fn applies_to_pair(&self) -> &EntityRef {
        &self.applies_to_pair
    }
}
impl ISphericalPairValue for SphericalPairValue {
    fn applies_to_pair(&self) -> &EntityRef {
        &self.applies_to_pair
    }
    fn input_orientation(&self) -> &SpatialRotation {
        &self.input_orientation
    }
}
impl SphericalPairValue {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = SphericalPairValue::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.applies_to_pair = parameter.into(),
                1usize => entity.input_orientation = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait ISphericalSurface: IElementarySurface {
    fn radius(&self) -> &PositiveLengthMeasure;
}
#[derive(Default, Debug)]
pub struct SphericalSurface {
    name: Label,
    position: EntityRef,
    radius: PositiveLengthMeasure,
}
impl IRepresentationItem for SphericalSurface {
    fn name(&self) -> &Label {
        &self.name
    }
}
impl IGeometricRepresentationItem for SphericalSurface {}
impl ISurface for SphericalSurface {}
impl IElementarySurface for SphericalSurface {
    fn position(&self) -> &EntityRef {
        &self.position
    }
}
impl ISphericalSurface for SphericalSurface {
    fn radius(&self) -> &PositiveLengthMeasure {
        &self.radius
    }
}
impl SphericalSurface {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = SphericalSurface::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => entity.position = parameter.into(),
                2usize => entity.radius = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait ISqlMappableDefinedFunction: IDefinedFunction {}
pub trait ISquareRootFunction: IUnaryFunctionCall {}
#[derive(Default, Debug)]
pub struct SquareRootFunction {
    operand: EntityRef,
}
impl IGenericExpression for SquareRootFunction {}
impl IExpression for SquareRootFunction {}
impl INumericExpression for SquareRootFunction {}
impl IUnaryNumericExpression for SquareRootFunction {
    fn operand(&self) -> &EntityRef {
        &self.operand
    }
}
impl IUnaryGenericExpression for SquareRootFunction {
    fn operand(&self) -> &EntityRef {
        &self.operand
    }
}
impl IUnaryFunctionCall for SquareRootFunction {}
impl ISquareRootFunction for SquareRootFunction {}
impl SquareRootFunction {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = SquareRootFunction::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.operand = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait ISquareUProfile: IShapeAspect {}
#[derive(Default, Debug)]
pub struct SquareUProfile {
    name: Label,
    description: Option<Text>,
    of_shape: EntityRef,
    product_definitional: Option<bool>,
}
impl IShapeAspect for SquareUProfile {
    fn name(&self) -> &Label {
        &self.name
    }
    fn description(&self) -> &Option<Text> {
        &self.description
    }
    fn of_shape(&self) -> &EntityRef {
        &self.of_shape
    }
    fn product_definitional(&self) -> Option<bool> {
        self.product_definitional
    }
}
impl ISquareUProfile for SquareUProfile {}
impl SquareUProfile {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = SquareUProfile::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => entity.of_shape = parameter.into(),
                3usize => entity.product_definitional = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IStandardUncertainty: IUncertaintyQualifier {
    fn uncertainty_value(&self) -> Real;
}
#[derive(Default, Debug)]
pub struct StandardUncertainty {
    measure_name: Label,
    description: Text,
    uncertainty_value: Real,
}
impl IUncertaintyQualifier for StandardUncertainty {
    fn measure_name(&self) -> &Label {
        &self.measure_name
    }
    fn description(&self) -> &Text {
        &self.description
    }
}
impl IStandardUncertainty for StandardUncertainty {
    fn uncertainty_value(&self) -> Real {
        self.uncertainty_value
    }
}
impl StandardUncertainty {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = StandardUncertainty::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.measure_name = parameter.into(),
                1usize => entity.description = parameter.into(),
                2usize => entity.uncertainty_value = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IStraightnessTolerance: IGeometricTolerance {}
#[derive(Default, Debug)]
pub struct StraightnessTolerance {
    name: Label,
    description: Text,
    magnitude: EntityRef,
    toleranced_shape_aspect: EntityRef,
}
impl IGeometricTolerance for StraightnessTolerance {
    fn name(&self) -> &Label {
        &self.name
    }
    fn description(&self) -> &Text {
        &self.description
    }
    fn magnitude(&self) -> &EntityRef {
        &self.magnitude
    }
    fn toleranced_shape_aspect(&self) -> &EntityRef {
        &self.toleranced_shape_aspect
    }
}
impl IStraightnessTolerance for StraightnessTolerance {}
impl StraightnessTolerance {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = StraightnessTolerance::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => entity.description = parameter.into(),
                2usize => entity.magnitude = parameter.into(),
                3usize => entity.toleranced_shape_aspect = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IStringDefinedFunction: IDefinedFunction + IStringExpression {}
pub trait IStringExpression: IExpression {}
pub trait IStringLiteral: ISimpleStringExpression + IGenericLiteral {
    fn the_value(&self) -> &String;
}
#[derive(Default, Debug)]
pub struct StringLiteral {
    the_value: String,
}
impl IGenericExpression for StringLiteral {}
impl IExpression for StringLiteral {}
impl IStringExpression for StringLiteral {}
impl ISimpleStringExpression for StringLiteral {}
impl ISimpleGenericExpression for StringLiteral {}
impl IStringLiteral for StringLiteral {
    fn the_value(&self) -> &String {
        &self.the_value
    }
}
impl IGenericLiteral for StringLiteral {}
impl StringLiteral {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = StringLiteral::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.the_value = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IStringVariable: ISimpleStringExpression + IVariable {}
#[derive(Default, Debug)]
pub struct StringVariable {}
impl IGenericExpression for StringVariable {}
impl IExpression for StringVariable {}
impl IStringExpression for StringVariable {}
impl ISimpleStringExpression for StringVariable {}
impl ISimpleGenericExpression for StringVariable {}
impl IStringVariable for StringVariable {}
impl IVariable for StringVariable {}
impl IGenericVariable for StringVariable {}
impl StringVariable {
    pub fn form_parameters(_parameters: Vec<Parameter>) -> Self {
        StringVariable::default()
    }
}
pub trait IStructuredDimensionCallout: IDraughtingCallout {}
#[derive(Default, Debug)]
pub struct StructuredDimensionCallout {
    name: Label,
    contents: HashSet<EntityRef>,
}
impl IRepresentationItem for StructuredDimensionCallout {
    fn name(&self) -> &Label {
        &self.name
    }
}
impl IGeometricRepresentationItem for StructuredDimensionCallout {}
impl IDraughtingCallout for StructuredDimensionCallout {
    fn contents(&self) -> &HashSet<EntityRef> {
        &self.contents
    }
}
impl IStructuredDimensionCallout for StructuredDimensionCallout {}
impl StructuredDimensionCallout {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = StructuredDimensionCallout::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => entity.contents = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IStyledItem: IRepresentationItem {
    fn styles(&self) -> &HashSet<EntityRef>;
    fn item(&self) -> &EntityRef;
}
#[derive(Default, Debug)]
pub struct StyledItem {
    name: Label,
    styles: HashSet<EntityRef>,
    item: EntityRef,
}
impl IRepresentationItem for StyledItem {
    fn name(&self) -> &Label {
        &self.name
    }
}
impl IStyledItem for StyledItem {
    fn styles(&self) -> &HashSet<EntityRef> {
        &self.styles
    }
    fn item(&self) -> &EntityRef {
        &self.item
    }
}
impl StyledItem {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = StyledItem::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => entity.styles = parameter.into(),
                2usize => entity.item = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait ISubedge: IEdge {
    fn parent_edge(&self) -> &EntityRef;
}
#[derive(Default, Debug)]
pub struct Subedge {
    name: Label,
    edge_start: EntityRef,
    edge_end: EntityRef,
    parent_edge: EntityRef,
}
impl IRepresentationItem for Subedge {
    fn name(&self) -> &Label {
        &self.name
    }
}
impl ITopologicalRepresentationItem for Subedge {}
impl IEdge for Subedge {
    fn edge_start(&self) -> &EntityRef {
        &self.edge_start
    }
    fn edge_end(&self) -> &EntityRef {
        &self.edge_end
    }
}
impl ISubedge for Subedge {
    fn parent_edge(&self) -> &EntityRef {
        &self.parent_edge
    }
}
impl Subedge {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = Subedge::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => entity.edge_start = parameter.into(),
                2usize => entity.edge_end = parameter.into(),
                3usize => entity.parent_edge = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait ISubface: IFace {
    fn parent_face(&self) -> &EntityRef;
}
#[derive(Default, Debug)]
pub struct Subface {
    name: Label,
    bounds: HashSet<EntityRef>,
    parent_face: EntityRef,
}
impl IRepresentationItem for Subface {
    fn name(&self) -> &Label {
        &self.name
    }
}
impl ITopologicalRepresentationItem for Subface {}
impl IFace for Subface {
    fn bounds(&self) -> &HashSet<EntityRef> {
        &self.bounds
    }
}
impl ISubface for Subface {
    fn parent_face(&self) -> &EntityRef {
        &self.parent_face
    }
}
impl Subface {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = Subface::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => entity.bounds = parameter.into(),
                2usize => entity.parent_face = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait ISubstringExpression: IStringExpression + IMultipleArityGenericExpression {}
#[derive(Default, Debug)]
pub struct SubstringExpression {
    operands: Vec<EntityRef>,
}
impl IGenericExpression for SubstringExpression {}
impl IExpression for SubstringExpression {}
impl IStringExpression for SubstringExpression {}
impl ISubstringExpression for SubstringExpression {}
impl IMultipleArityGenericExpression for SubstringExpression {
    fn operands(&self) -> &Vec<EntityRef> {
        &self.operands
    }
}
impl SubstringExpression {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = SubstringExpression::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.operands = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait ISurface: IGeometricRepresentationItem {}
#[derive(Default, Debug)]
pub struct Surface {
    name: Label,
}
impl IRepresentationItem for Surface {
    fn name(&self) -> &Label {
        &self.name
    }
}
impl IGeometricRepresentationItem for Surface {}
impl ISurface for Surface {}
impl Surface {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = Surface::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait ISurfaceConditionCallout: IDraughtingCallout {}
#[derive(Default, Debug)]
pub struct SurfaceConditionCallout {
    name: Label,
    contents: HashSet<EntityRef>,
}
impl IRepresentationItem for SurfaceConditionCallout {
    fn name(&self) -> &Label {
        &self.name
    }
}
impl IGeometricRepresentationItem for SurfaceConditionCallout {}
impl IDraughtingCallout for SurfaceConditionCallout {
    fn contents(&self) -> &HashSet<EntityRef> {
        &self.contents
    }
}
impl ISurfaceConditionCallout for SurfaceConditionCallout {}
impl SurfaceConditionCallout {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = SurfaceConditionCallout::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => entity.contents = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait ISurfaceCurve: ICurve {
    fn curve_3d(&self) -> &EntityRef;
    fn associated_geometry(&self) -> &Vec<EntityRef>;
    fn master_representation(&self) -> &PreferredSurfaceCurveRepresentation;
}
#[derive(Default, Debug)]
pub struct SurfaceCurve {
    name: Label,
    curve_3d: EntityRef,
    associated_geometry: Vec<EntityRef>,
    master_representation: PreferredSurfaceCurveRepresentation,
}
impl IRepresentationItem for SurfaceCurve {
    fn name(&self) -> &Label {
        &self.name
    }
}
impl IGeometricRepresentationItem for SurfaceCurve {}
impl ICurve for SurfaceCurve {}
impl ISurfaceCurve for SurfaceCurve {
    fn curve_3d(&self) -> &EntityRef {
        &self.curve_3d
    }
    fn associated_geometry(&self) -> &Vec<EntityRef> {
        &self.associated_geometry
    }
    fn master_representation(&self) -> &PreferredSurfaceCurveRepresentation {
        &self.master_representation
    }
}
impl SurfaceCurve {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = SurfaceCurve::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => entity.curve_3d = parameter.into(),
                2usize => entity.associated_geometry = parameter.into(),
                3usize => entity.master_representation = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait ISurfaceCurveSweptAreaSolid: ISweptAreaSolid {
    fn directrix(&self) -> &EntityRef;
    fn start_param(&self) -> Real;
    fn end_param(&self) -> Real;
    fn reference_surface(&self) -> &EntityRef;
}
#[derive(Default, Debug)]
pub struct SurfaceCurveSweptAreaSolid {
    name: Label,
    swept_area: EntityRef,
    directrix: EntityRef,
    start_param: Real,
    end_param: Real,
    reference_surface: EntityRef,
}
impl IRepresentationItem for SurfaceCurveSweptAreaSolid {
    fn name(&self) -> &Label {
        &self.name
    }
}
impl IGeometricRepresentationItem for SurfaceCurveSweptAreaSolid {}
impl ISolidModel for SurfaceCurveSweptAreaSolid {}
impl ISweptAreaSolid for SurfaceCurveSweptAreaSolid {
    fn swept_area(&self) -> &EntityRef {
        &self.swept_area
    }
}
impl ISurfaceCurveSweptAreaSolid for SurfaceCurveSweptAreaSolid {
    fn directrix(&self) -> &EntityRef {
        &self.directrix
    }
    fn start_param(&self) -> Real {
        self.start_param
    }
    fn end_param(&self) -> Real {
        self.end_param
    }
    fn reference_surface(&self) -> &EntityRef {
        &self.reference_surface
    }
}
impl SurfaceCurveSweptAreaSolid {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = SurfaceCurveSweptAreaSolid::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => entity.swept_area = parameter.into(),
                2usize => entity.directrix = parameter.into(),
                3usize => entity.start_param = parameter.into(),
                4usize => entity.end_param = parameter.into(),
                5usize => entity.reference_surface = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait ISurfaceOfLinearExtrusion: ISweptSurface {
    fn extrusion_axis(&self) -> &EntityRef;
}
#[derive(Default, Debug)]
pub struct SurfaceOfLinearExtrusion {
    name: Label,
    swept_curve: EntityRef,
    extrusion_axis: EntityRef,
}
impl IRepresentationItem for SurfaceOfLinearExtrusion {
    fn name(&self) -> &Label {
        &self.name
    }
}
impl IGeometricRepresentationItem for SurfaceOfLinearExtrusion {}
impl ISurface for SurfaceOfLinearExtrusion {}
impl ISweptSurface for SurfaceOfLinearExtrusion {
    fn swept_curve(&self) -> &EntityRef {
        &self.swept_curve
    }
}
impl ISurfaceOfLinearExtrusion for SurfaceOfLinearExtrusion {
    fn extrusion_axis(&self) -> &EntityRef {
        &self.extrusion_axis
    }
}
impl SurfaceOfLinearExtrusion {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = SurfaceOfLinearExtrusion::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => entity.swept_curve = parameter.into(),
                2usize => entity.extrusion_axis = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait ISurfaceOfRevolution: ISweptSurface {
    fn axis_position(&self) -> &EntityRef;
}
#[derive(Default, Debug)]
pub struct SurfaceOfRevolution {
    name: Label,
    swept_curve: EntityRef,
    axis_position: EntityRef,
}
impl IRepresentationItem for SurfaceOfRevolution {
    fn name(&self) -> &Label {
        &self.name
    }
}
impl IGeometricRepresentationItem for SurfaceOfRevolution {}
impl ISurface for SurfaceOfRevolution {}
impl ISweptSurface for SurfaceOfRevolution {
    fn swept_curve(&self) -> &EntityRef {
        &self.swept_curve
    }
}
impl ISurfaceOfRevolution for SurfaceOfRevolution {
    fn axis_position(&self) -> &EntityRef {
        &self.axis_position
    }
}
impl SurfaceOfRevolution {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = SurfaceOfRevolution::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => entity.swept_curve = parameter.into(),
                2usize => entity.axis_position = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait ISurfacePair: IKinematicPair {
    fn surface_1(&self) -> &EntityRef;
    fn surface_2(&self) -> &EntityRef;
    fn orientation(&self) -> bool;
}
#[derive(Default, Debug)]
pub struct SurfacePair {
    name: Label,
    description: Option<Text>,
    transform_item_1: EntityRef,
    transform_item_2: EntityRef,
    joint: EntityRef,
    surface_1: EntityRef,
    surface_2: EntityRef,
    orientation: bool,
}
impl IItemDefinedTransformation for SurfacePair {
    fn name(&self) -> &Label {
        &self.name
    }
    fn description(&self) -> &Option<Text> {
        &self.description
    }
    fn transform_item_1(&self) -> &EntityRef {
        &self.transform_item_1
    }
    fn transform_item_2(&self) -> &EntityRef {
        &self.transform_item_2
    }
}
impl IKinematicPair for SurfacePair {
    fn joint(&self) -> &EntityRef {
        &self.joint
    }
}
impl ISurfacePair for SurfacePair {
    fn surface_1(&self) -> &EntityRef {
        &self.surface_1
    }
    fn surface_2(&self) -> &EntityRef {
        &self.surface_2
    }
    fn orientation(&self) -> bool {
        self.orientation
    }
}
impl SurfacePair {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = SurfacePair::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => entity.transform_item_1 = parameter.into(),
                3usize => entity.transform_item_2 = parameter.into(),
                4usize => entity.joint = parameter.into(),
                5usize => entity.surface_1 = parameter.into(),
                6usize => entity.surface_2 = parameter.into(),
                7usize => entity.orientation = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait ISurfacePairRange: ISimplePairRange {
    fn applies_to_pair(&self) -> &EntityRef;
    fn range_on_surface_1(&self) -> &EntityRef;
    fn range_on_surface_2(&self) -> &EntityRef;
    fn lower_limit_actual_rotation(&self) -> &RotationalRangeMeasure;
    fn upper_limit_actual_rotation(&self) -> &RotationalRangeMeasure;
}
#[derive(Default, Debug)]
pub struct SurfacePairRange {
    applies_to_pair: EntityRef,
    range_on_surface_1: EntityRef,
    range_on_surface_2: EntityRef,
    lower_limit_actual_rotation: RotationalRangeMeasure,
    upper_limit_actual_rotation: RotationalRangeMeasure,
}
impl ISimplePairRange for SurfacePairRange {
    fn applies_to_pair(&self) -> &EntityRef {
        &self.applies_to_pair
    }
}
impl ISurfacePairRange for SurfacePairRange {
    fn applies_to_pair(&self) -> &EntityRef {
        &self.applies_to_pair
    }
    fn range_on_surface_1(&self) -> &EntityRef {
        &self.range_on_surface_1
    }
    fn range_on_surface_2(&self) -> &EntityRef {
        &self.range_on_surface_2
    }
    fn lower_limit_actual_rotation(&self) -> &RotationalRangeMeasure {
        &self.lower_limit_actual_rotation
    }
    fn upper_limit_actual_rotation(&self) -> &RotationalRangeMeasure {
        &self.upper_limit_actual_rotation
    }
}
impl SurfacePairRange {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = SurfacePairRange::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.applies_to_pair = parameter.into(),
                1usize => entity.range_on_surface_1 = parameter.into(),
                2usize => entity.range_on_surface_2 = parameter.into(),
                3usize => entity.lower_limit_actual_rotation = parameter.into(),
                4usize => entity.upper_limit_actual_rotation = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait ISurfacePatch: IFoundedItem {
    fn parent_surface(&self) -> &EntityRef;
    fn u_transition(&self) -> &TransitionCode;
    fn v_transition(&self) -> &TransitionCode;
    fn u_sense(&self) -> bool;
    fn v_sense(&self) -> bool;
}
#[derive(Default, Debug)]
pub struct SurfacePatch {
    parent_surface: EntityRef,
    u_transition: TransitionCode,
    v_transition: TransitionCode,
    u_sense: bool,
    v_sense: bool,
}
impl IFoundedItem for SurfacePatch {}
impl ISurfacePatch for SurfacePatch {
    fn parent_surface(&self) -> &EntityRef {
        &self.parent_surface
    }
    fn u_transition(&self) -> &TransitionCode {
        &self.u_transition
    }
    fn v_transition(&self) -> &TransitionCode {
        &self.v_transition
    }
    fn u_sense(&self) -> bool {
        self.u_sense
    }
    fn v_sense(&self) -> bool {
        self.v_sense
    }
}
impl SurfacePatch {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = SurfacePatch::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.parent_surface = parameter.into(),
                1usize => entity.u_transition = parameter.into(),
                2usize => entity.v_transition = parameter.into(),
                3usize => entity.u_sense = parameter.into(),
                4usize => entity.v_sense = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait ISurfaceProfileTolerance: IGeometricTolerance {}
#[derive(Default, Debug)]
pub struct SurfaceProfileTolerance {
    name: Label,
    description: Text,
    magnitude: EntityRef,
    toleranced_shape_aspect: EntityRef,
}
impl IGeometricTolerance for SurfaceProfileTolerance {
    fn name(&self) -> &Label {
        &self.name
    }
    fn description(&self) -> &Text {
        &self.description
    }
    fn magnitude(&self) -> &EntityRef {
        &self.magnitude
    }
    fn toleranced_shape_aspect(&self) -> &EntityRef {
        &self.toleranced_shape_aspect
    }
}
impl ISurfaceProfileTolerance for SurfaceProfileTolerance {}
impl SurfaceProfileTolerance {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = SurfaceProfileTolerance::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => entity.description = parameter.into(),
                2usize => entity.magnitude = parameter.into(),
                3usize => entity.toleranced_shape_aspect = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait ISurfaceRenderingProperties {
    fn rendered_colour(&self) -> &EntityRef;
}
#[derive(Default, Debug)]
pub struct SurfaceRenderingProperties {
    rendered_colour: EntityRef,
}
impl ISurfaceRenderingProperties for SurfaceRenderingProperties {
    fn rendered_colour(&self) -> &EntityRef {
        &self.rendered_colour
    }
}
impl SurfaceRenderingProperties {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = SurfaceRenderingProperties::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.rendered_colour = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait ISurfaceReplica: ISurface {
    fn parent_surface(&self) -> &EntityRef;
    fn transformation(&self) -> &EntityRef;
}
#[derive(Default, Debug)]
pub struct SurfaceReplica {
    name: Label,
    parent_surface: EntityRef,
    transformation: EntityRef,
}
impl IRepresentationItem for SurfaceReplica {
    fn name(&self) -> &Label {
        &self.name
    }
}
impl IGeometricRepresentationItem for SurfaceReplica {}
impl ISurface for SurfaceReplica {}
impl ISurfaceReplica for SurfaceReplica {
    fn parent_surface(&self) -> &EntityRef {
        &self.parent_surface
    }
    fn transformation(&self) -> &EntityRef {
        &self.transformation
    }
}
impl SurfaceReplica {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = SurfaceReplica::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => entity.parent_surface = parameter.into(),
                2usize => entity.transformation = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait ISurfaceSideStyle: IFoundedItem {
    fn name(&self) -> &Label;
    fn styles(&self) -> &HashSet<EntityRef>;
}
#[derive(Default, Debug)]
pub struct SurfaceSideStyle {
    name: Label,
    styles: HashSet<EntityRef>,
}
impl IFoundedItem for SurfaceSideStyle {}
impl ISurfaceSideStyle for SurfaceSideStyle {
    fn name(&self) -> &Label {
        &self.name
    }
    fn styles(&self) -> &HashSet<EntityRef> {
        &self.styles
    }
}
impl SurfaceSideStyle {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = SurfaceSideStyle::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => entity.styles = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait ISurfaceStyleBoundary: IFoundedItem {
    fn style_of_boundary(&self) -> &EntityRef;
}
#[derive(Default, Debug)]
pub struct SurfaceStyleBoundary {
    style_of_boundary: EntityRef,
}
impl IFoundedItem for SurfaceStyleBoundary {}
impl ISurfaceStyleBoundary for SurfaceStyleBoundary {
    fn style_of_boundary(&self) -> &EntityRef {
        &self.style_of_boundary
    }
}
impl SurfaceStyleBoundary {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = SurfaceStyleBoundary::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.style_of_boundary = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait ISurfaceStyleControlGrid: IFoundedItem {
    fn style_of_control_grid(&self) -> &EntityRef;
}
#[derive(Default, Debug)]
pub struct SurfaceStyleControlGrid {
    style_of_control_grid: EntityRef,
}
impl IFoundedItem for SurfaceStyleControlGrid {}
impl ISurfaceStyleControlGrid for SurfaceStyleControlGrid {
    fn style_of_control_grid(&self) -> &EntityRef {
        &self.style_of_control_grid
    }
}
impl SurfaceStyleControlGrid {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = SurfaceStyleControlGrid::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.style_of_control_grid = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait ISurfaceStyleFillArea: IFoundedItem {
    fn fill_area(&self) -> &EntityRef;
}
#[derive(Default, Debug)]
pub struct SurfaceStyleFillArea {
    fill_area: EntityRef,
}
impl IFoundedItem for SurfaceStyleFillArea {}
impl ISurfaceStyleFillArea for SurfaceStyleFillArea {
    fn fill_area(&self) -> &EntityRef {
        &self.fill_area
    }
}
impl SurfaceStyleFillArea {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = SurfaceStyleFillArea::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.fill_area = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait ISurfaceStyleParameterLine: IFoundedItem {
    fn style_of_parameter_lines(&self) -> &EntityRef;
    fn direction_counts(&self) -> &HashSet<DirectionCountSelect>;
}
#[derive(Default, Debug)]
pub struct SurfaceStyleParameterLine {
    style_of_parameter_lines: EntityRef,
    direction_counts: HashSet<DirectionCountSelect>,
}
impl IFoundedItem for SurfaceStyleParameterLine {}
impl ISurfaceStyleParameterLine for SurfaceStyleParameterLine {
    fn style_of_parameter_lines(&self) -> &EntityRef {
        &self.style_of_parameter_lines
    }
    fn direction_counts(&self) -> &HashSet<DirectionCountSelect> {
        &self.direction_counts
    }
}
impl SurfaceStyleParameterLine {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = SurfaceStyleParameterLine::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.style_of_parameter_lines = parameter.into(),
                1usize => entity.direction_counts = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait ISurfaceStyleReflectanceAmbient {
    fn ambient_reflectance(&self) -> Real;
}
#[derive(Default, Debug)]
pub struct SurfaceStyleReflectanceAmbient {
    ambient_reflectance: Real,
}
impl ISurfaceStyleReflectanceAmbient for SurfaceStyleReflectanceAmbient {
    fn ambient_reflectance(&self) -> Real {
        self.ambient_reflectance
    }
}
impl SurfaceStyleReflectanceAmbient {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = SurfaceStyleReflectanceAmbient::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.ambient_reflectance = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait ISurfaceStyleReflectanceAmbientDiffuse: ISurfaceStyleReflectanceAmbient {
    fn diffuse_reflectance(&self) -> Real;
}
#[derive(Default, Debug)]
pub struct SurfaceStyleReflectanceAmbientDiffuse {
    ambient_reflectance: Real,
    diffuse_reflectance: Real,
}
impl ISurfaceStyleReflectanceAmbient for SurfaceStyleReflectanceAmbientDiffuse {
    fn ambient_reflectance(&self) -> Real {
        self.ambient_reflectance
    }
}
impl ISurfaceStyleReflectanceAmbientDiffuse for SurfaceStyleReflectanceAmbientDiffuse {
    fn diffuse_reflectance(&self) -> Real {
        self.diffuse_reflectance
    }
}
impl SurfaceStyleReflectanceAmbientDiffuse {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = SurfaceStyleReflectanceAmbientDiffuse::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.ambient_reflectance = parameter.into(),
                1usize => entity.diffuse_reflectance = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait ISurfaceStyleReflectanceAmbientDiffuseSpecular: ISurfaceStyleReflectanceAmbientDiffuse {
    fn specular_reflectance(&self) -> Real;
    fn specular_exponent(&self) -> Real;
    fn specular_colour(&self) -> &EntityRef;
}
#[derive(Default, Debug)]
pub struct SurfaceStyleReflectanceAmbientDiffuseSpecular {
    ambient_reflectance: Real,
    diffuse_reflectance: Real,
    specular_reflectance: Real,
    specular_exponent: Real,
    specular_colour: EntityRef,
}
impl ISurfaceStyleReflectanceAmbient for SurfaceStyleReflectanceAmbientDiffuseSpecular {
    fn ambient_reflectance(&self) -> Real {
        self.ambient_reflectance
    }
}
impl ISurfaceStyleReflectanceAmbientDiffuse for SurfaceStyleReflectanceAmbientDiffuseSpecular {
    fn diffuse_reflectance(&self) -> Real {
        self.diffuse_reflectance
    }
}
impl ISurfaceStyleReflectanceAmbientDiffuseSpecular for SurfaceStyleReflectanceAmbientDiffuseSpecular {
    fn specular_reflectance(&self) -> Real {
        self.specular_reflectance
    }
    fn specular_exponent(&self) -> Real {
        self.specular_exponent
    }
    fn specular_colour(&self) -> &EntityRef {
        &self.specular_colour
    }
}
impl SurfaceStyleReflectanceAmbientDiffuseSpecular {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = SurfaceStyleReflectanceAmbientDiffuseSpecular::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.ambient_reflectance = parameter.into(),
                1usize => entity.diffuse_reflectance = parameter.into(),
                2usize => entity.specular_reflectance = parameter.into(),
                3usize => entity.specular_exponent = parameter.into(),
                4usize => entity.specular_colour = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait ISurfaceStyleRendering {
    fn rendering_method(&self) -> &ShadingSurfaceMethod;
    fn surface_colour(&self) -> &EntityRef;
}
#[derive(Default, Debug)]
pub struct SurfaceStyleRendering {
    rendering_method: ShadingSurfaceMethod,
    surface_colour: EntityRef,
}
impl ISurfaceStyleRendering for SurfaceStyleRendering {
    fn rendering_method(&self) -> &ShadingSurfaceMethod {
        &self.rendering_method
    }
    fn surface_colour(&self) -> &EntityRef {
        &self.surface_colour
    }
}
impl SurfaceStyleRendering {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = SurfaceStyleRendering::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.rendering_method = parameter.into(),
                1usize => entity.surface_colour = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait ISurfaceStyleRenderingWithProperties: ISurfaceStyleRendering {
    fn properties(&self) -> &HashSet<EntityRef>;
}
#[derive(Default, Debug)]
pub struct SurfaceStyleRenderingWithProperties {
    rendering_method: ShadingSurfaceMethod,
    surface_colour: EntityRef,
    properties: HashSet<EntityRef>,
}
impl ISurfaceStyleRendering for SurfaceStyleRenderingWithProperties {
    fn rendering_method(&self) -> &ShadingSurfaceMethod {
        &self.rendering_method
    }
    fn surface_colour(&self) -> &EntityRef {
        &self.surface_colour
    }
}
impl ISurfaceStyleRenderingWithProperties for SurfaceStyleRenderingWithProperties {
    fn properties(&self) -> &HashSet<EntityRef> {
        &self.properties
    }
}
impl SurfaceStyleRenderingWithProperties {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = SurfaceStyleRenderingWithProperties::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.rendering_method = parameter.into(),
                1usize => entity.surface_colour = parameter.into(),
                2usize => entity.properties = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait ISurfaceStyleSegmentationCurve: IFoundedItem {
    fn style_of_segmentation_curve(&self) -> &EntityRef;
}
#[derive(Default, Debug)]
pub struct SurfaceStyleSegmentationCurve {
    style_of_segmentation_curve: EntityRef,
}
impl IFoundedItem for SurfaceStyleSegmentationCurve {}
impl ISurfaceStyleSegmentationCurve for SurfaceStyleSegmentationCurve {
    fn style_of_segmentation_curve(&self) -> &EntityRef {
        &self.style_of_segmentation_curve
    }
}
impl SurfaceStyleSegmentationCurve {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = SurfaceStyleSegmentationCurve::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.style_of_segmentation_curve = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait ISurfaceStyleSilhouette: IFoundedItem {
    fn style_of_silhouette(&self) -> &EntityRef;
}
#[derive(Default, Debug)]
pub struct SurfaceStyleSilhouette {
    style_of_silhouette: EntityRef,
}
impl IFoundedItem for SurfaceStyleSilhouette {}
impl ISurfaceStyleSilhouette for SurfaceStyleSilhouette {
    fn style_of_silhouette(&self) -> &EntityRef {
        &self.style_of_silhouette
    }
}
impl SurfaceStyleSilhouette {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = SurfaceStyleSilhouette::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.style_of_silhouette = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait ISurfaceStyleTransparent {
    fn transparency(&self) -> Real;
}
#[derive(Default, Debug)]
pub struct SurfaceStyleTransparent {
    transparency: Real,
}
impl ISurfaceStyleTransparent for SurfaceStyleTransparent {
    fn transparency(&self) -> Real {
        self.transparency
    }
}
impl SurfaceStyleTransparent {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = SurfaceStyleTransparent::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.transparency = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait ISurfaceStyleUsage: IFoundedItem {
    fn side(&self) -> &SurfaceSide;
    fn style(&self) -> &EntityRef;
}
#[derive(Default, Debug)]
pub struct SurfaceStyleUsage {
    side: SurfaceSide,
    style: EntityRef,
}
impl IFoundedItem for SurfaceStyleUsage {}
impl ISurfaceStyleUsage for SurfaceStyleUsage {
    fn side(&self) -> &SurfaceSide {
        &self.side
    }
    fn style(&self) -> &EntityRef {
        &self.style
    }
}
impl SurfaceStyleUsage {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = SurfaceStyleUsage::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.side = parameter.into(),
                1usize => entity.style = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait ISurfaceTextureRepresentation: IRepresentation {}
#[derive(Default, Debug)]
pub struct SurfaceTextureRepresentation {
    name: Label,
    items: HashSet<EntityRef>,
    context_of_items: EntityRef,
}
impl IRepresentation for SurfaceTextureRepresentation {
    fn name(&self) -> &Label {
        &self.name
    }
    fn items(&self) -> &HashSet<EntityRef> {
        &self.items
    }
    fn context_of_items(&self) -> &EntityRef {
        &self.context_of_items
    }
}
impl ISurfaceTextureRepresentation for SurfaceTextureRepresentation {}
impl SurfaceTextureRepresentation {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = SurfaceTextureRepresentation::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => entity.items = parameter.into(),
                2usize => entity.context_of_items = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait ISweptAreaSolid: ISolidModel {
    fn swept_area(&self) -> &EntityRef;
}
#[derive(Default, Debug)]
pub struct SweptAreaSolid {
    name: Label,
    swept_area: EntityRef,
}
impl IRepresentationItem for SweptAreaSolid {
    fn name(&self) -> &Label {
        &self.name
    }
}
impl IGeometricRepresentationItem for SweptAreaSolid {}
impl ISolidModel for SweptAreaSolid {}
impl ISweptAreaSolid for SweptAreaSolid {
    fn swept_area(&self) -> &EntityRef {
        &self.swept_area
    }
}
impl SweptAreaSolid {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = SweptAreaSolid::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => entity.swept_area = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait ISweptDiskSolid: ISolidModel {
    fn directrix(&self) -> &EntityRef;
    fn radius(&self) -> &PositiveLengthMeasure;
    fn inner_radius(&self) -> &Option<PositiveLengthMeasure>;
    fn start_param(&self) -> Real;
    fn end_param(&self) -> Real;
}
#[derive(Default, Debug)]
pub struct SweptDiskSolid {
    name: Label,
    directrix: EntityRef,
    radius: PositiveLengthMeasure,
    inner_radius: Option<PositiveLengthMeasure>,
    start_param: Real,
    end_param: Real,
}
impl IRepresentationItem for SweptDiskSolid {
    fn name(&self) -> &Label {
        &self.name
    }
}
impl IGeometricRepresentationItem for SweptDiskSolid {}
impl ISolidModel for SweptDiskSolid {}
impl ISweptDiskSolid for SweptDiskSolid {
    fn directrix(&self) -> &EntityRef {
        &self.directrix
    }
    fn radius(&self) -> &PositiveLengthMeasure {
        &self.radius
    }
    fn inner_radius(&self) -> &Option<PositiveLengthMeasure> {
        &self.inner_radius
    }
    fn start_param(&self) -> Real {
        self.start_param
    }
    fn end_param(&self) -> Real {
        self.end_param
    }
}
impl SweptDiskSolid {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = SweptDiskSolid::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => entity.directrix = parameter.into(),
                2usize => entity.radius = parameter.into(),
                3usize => {
                    entity.inner_radius = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => entity.start_param = parameter.into(),
                5usize => entity.end_param = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait ISweptFaceSolid: ISolidModel {
    fn swept_face(&self) -> &EntityRef;
}
#[derive(Default, Debug)]
pub struct SweptFaceSolid {
    name: Label,
    swept_face: EntityRef,
}
impl IRepresentationItem for SweptFaceSolid {
    fn name(&self) -> &Label {
        &self.name
    }
}
impl IGeometricRepresentationItem for SweptFaceSolid {}
impl ISolidModel for SweptFaceSolid {}
impl ISweptFaceSolid for SweptFaceSolid {
    fn swept_face(&self) -> &EntityRef {
        &self.swept_face
    }
}
impl SweptFaceSolid {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = SweptFaceSolid::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => entity.swept_face = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait ISweptSurface: ISurface {
    fn swept_curve(&self) -> &EntityRef;
}
#[derive(Default, Debug)]
pub struct SweptSurface {
    name: Label,
    swept_curve: EntityRef,
}
impl IRepresentationItem for SweptSurface {
    fn name(&self) -> &Label {
        &self.name
    }
}
impl IGeometricRepresentationItem for SweptSurface {}
impl ISurface for SweptSurface {}
impl ISweptSurface for SweptSurface {
    fn swept_curve(&self) -> &EntityRef {
        &self.swept_curve
    }
}
impl SweptSurface {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = SweptSurface::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => entity.swept_curve = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait ISymbolColour {
    fn colour_of_symbol(&self) -> &EntityRef;
}
#[derive(Default, Debug)]
pub struct SymbolColour {
    colour_of_symbol: EntityRef,
}
impl ISymbolColour for SymbolColour {
    fn colour_of_symbol(&self) -> &EntityRef {
        &self.colour_of_symbol
    }
}
impl SymbolColour {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = SymbolColour::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.colour_of_symbol = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait ISymbolRepresentation: IRepresentation {}
#[derive(Default, Debug)]
pub struct SymbolRepresentation {
    name: Label,
    items: HashSet<EntityRef>,
    context_of_items: EntityRef,
}
impl IRepresentation for SymbolRepresentation {
    fn name(&self) -> &Label {
        &self.name
    }
    fn items(&self) -> &HashSet<EntityRef> {
        &self.items
    }
    fn context_of_items(&self) -> &EntityRef {
        &self.context_of_items
    }
}
impl ISymbolRepresentation for SymbolRepresentation {}
impl SymbolRepresentation {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = SymbolRepresentation::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => entity.items = parameter.into(),
                2usize => entity.context_of_items = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait ISymbolRepresentationMap: IRepresentationMap {
    fn mapped_representation(&self) -> &EntityRef;
    fn mapping_origin(&self) -> &EntityRef;
}
#[derive(Default, Debug)]
pub struct SymbolRepresentationMap {
    mapped_representation: EntityRef,
    mapping_origin: EntityRef,
}
impl IRepresentationMap for SymbolRepresentationMap {
    fn mapping_origin(&self) -> &EntityRef {
        &self.mapping_origin
    }
    fn mapped_representation(&self) -> &EntityRef {
        &self.mapped_representation
    }
}
impl ISymbolRepresentationMap for SymbolRepresentationMap {
    fn mapped_representation(&self) -> &EntityRef {
        &self.mapped_representation
    }
    fn mapping_origin(&self) -> &EntityRef {
        &self.mapping_origin
    }
}
impl SymbolRepresentationMap {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = SymbolRepresentationMap::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.mapped_representation = parameter.into(),
                1usize => entity.mapping_origin = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait ISymbolStyle: IFoundedItem {
    fn name(&self) -> &Label;
    fn style_of_symbol(&self) -> &EntityRef;
}
#[derive(Default, Debug)]
pub struct SymbolStyle {
    name: Label,
    style_of_symbol: EntityRef,
}
impl IFoundedItem for SymbolStyle {}
impl ISymbolStyle for SymbolStyle {
    fn name(&self) -> &Label {
        &self.name
    }
    fn style_of_symbol(&self) -> &EntityRef {
        &self.style_of_symbol
    }
}
impl SymbolStyle {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = SymbolStyle::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => entity.style_of_symbol = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait ISymbolTarget: IGeometricRepresentationItem {
    fn placement(&self) -> &EntityRef;
    fn x_scale(&self) -> &PositiveRatioMeasure;
    fn y_scale(&self) -> &PositiveRatioMeasure;
}
#[derive(Default, Debug)]
pub struct SymbolTarget {
    name: Label,
    placement: EntityRef,
    x_scale: PositiveRatioMeasure,
    y_scale: PositiveRatioMeasure,
}
impl IRepresentationItem for SymbolTarget {
    fn name(&self) -> &Label {
        &self.name
    }
}
impl IGeometricRepresentationItem for SymbolTarget {}
impl ISymbolTarget for SymbolTarget {
    fn placement(&self) -> &EntityRef {
        &self.placement
    }
    fn x_scale(&self) -> &PositiveRatioMeasure {
        &self.x_scale
    }
    fn y_scale(&self) -> &PositiveRatioMeasure {
        &self.y_scale
    }
}
impl SymbolTarget {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = SymbolTarget::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => entity.placement = parameter.into(),
                2usize => entity.x_scale = parameter.into(),
                3usize => entity.y_scale = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait ISymmetricShapeAspect: IShapeAspect {}
#[derive(Default, Debug)]
pub struct SymmetricShapeAspect {
    name: Label,
    description: Option<Text>,
    of_shape: EntityRef,
    product_definitional: Option<bool>,
}
impl IShapeAspect for SymmetricShapeAspect {
    fn name(&self) -> &Label {
        &self.name
    }
    fn description(&self) -> &Option<Text> {
        &self.description
    }
    fn of_shape(&self) -> &EntityRef {
        &self.of_shape
    }
    fn product_definitional(&self) -> Option<bool> {
        self.product_definitional
    }
}
impl ISymmetricShapeAspect for SymmetricShapeAspect {}
impl SymmetricShapeAspect {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = SymmetricShapeAspect::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => entity.of_shape = parameter.into(),
                3usize => entity.product_definitional = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait ISymmetryTolerance: IGeometricToleranceWithDatumReference {}
#[derive(Default, Debug)]
pub struct SymmetryTolerance {
    name: Label,
    description: Text,
    magnitude: EntityRef,
    toleranced_shape_aspect: EntityRef,
    datum_system: HashSet<EntityRef>,
}
impl IGeometricTolerance for SymmetryTolerance {
    fn name(&self) -> &Label {
        &self.name
    }
    fn description(&self) -> &Text {
        &self.description
    }
    fn magnitude(&self) -> &EntityRef {
        &self.magnitude
    }
    fn toleranced_shape_aspect(&self) -> &EntityRef {
        &self.toleranced_shape_aspect
    }
}
impl IGeometricToleranceWithDatumReference for SymmetryTolerance {
    fn datum_system(&self) -> &HashSet<EntityRef> {
        &self.datum_system
    }
}
impl ISymmetryTolerance for SymmetryTolerance {}
impl SymmetryTolerance {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = SymmetryTolerance::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => entity.description = parameter.into(),
                2usize => entity.magnitude = parameter.into(),
                3usize => entity.toleranced_shape_aspect = parameter.into(),
                4usize => entity.datum_system = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait ITactileAppearanceRepresentation: IRepresentation {}
#[derive(Default, Debug)]
pub struct TactileAppearanceRepresentation {
    name: Label,
    items: HashSet<EntityRef>,
    context_of_items: EntityRef,
}
impl IRepresentation for TactileAppearanceRepresentation {
    fn name(&self) -> &Label {
        &self.name
    }
    fn items(&self) -> &HashSet<EntityRef> {
        &self.items
    }
    fn context_of_items(&self) -> &EntityRef {
        &self.context_of_items
    }
}
impl ITactileAppearanceRepresentation for TactileAppearanceRepresentation {}
impl TactileAppearanceRepresentation {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = TactileAppearanceRepresentation::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => entity.items = parameter.into(),
                2usize => entity.context_of_items = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait ITanFunction: IUnaryFunctionCall {}
#[derive(Default, Debug)]
pub struct TanFunction {
    operand: EntityRef,
}
impl IGenericExpression for TanFunction {}
impl IExpression for TanFunction {}
impl INumericExpression for TanFunction {}
impl IUnaryNumericExpression for TanFunction {
    fn operand(&self) -> &EntityRef {
        &self.operand
    }
}
impl IUnaryGenericExpression for TanFunction {
    fn operand(&self) -> &EntityRef {
        &self.operand
    }
}
impl IUnaryFunctionCall for TanFunction {}
impl ITanFunction for TanFunction {}
impl TanFunction {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = TanFunction::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.operand = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait ITangent: IDerivedShapeAspect {}
#[derive(Default, Debug)]
pub struct Tangent {
    name: Label,
    description: Option<Text>,
    of_shape: EntityRef,
    product_definitional: Option<bool>,
}
impl IShapeAspect for Tangent {
    fn name(&self) -> &Label {
        &self.name
    }
    fn description(&self) -> &Option<Text> {
        &self.description
    }
    fn of_shape(&self) -> &EntityRef {
        &self.of_shape
    }
    fn product_definitional(&self) -> Option<bool> {
        self.product_definitional
    }
}
impl IDerivedShapeAspect for Tangent {}
impl ITangent for Tangent {}
impl Tangent {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = Tangent::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => entity.of_shape = parameter.into(),
                3usize => entity.product_definitional = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait ITaper: IShapeAspect {}
#[derive(Default, Debug)]
pub struct Taper {
    name: Label,
    description: Option<Text>,
    of_shape: EntityRef,
    product_definitional: Option<bool>,
}
impl IShapeAspect for Taper {
    fn name(&self) -> &Label {
        &self.name
    }
    fn description(&self) -> &Option<Text> {
        &self.description
    }
    fn of_shape(&self) -> &EntityRef {
        &self.of_shape
    }
    fn product_definitional(&self) -> Option<bool> {
        self.product_definitional
    }
}
impl ITaper for Taper {}
impl Taper {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = Taper::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => entity.of_shape = parameter.into(),
                3usize => entity.product_definitional = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait ITeeProfile: IShapeAspect {}
#[derive(Default, Debug)]
pub struct TeeProfile {
    name: Label,
    description: Option<Text>,
    of_shape: EntityRef,
    product_definitional: Option<bool>,
}
impl IShapeAspect for TeeProfile {
    fn name(&self) -> &Label {
        &self.name
    }
    fn description(&self) -> &Option<Text> {
        &self.description
    }
    fn of_shape(&self) -> &EntityRef {
        &self.of_shape
    }
    fn product_definitional(&self) -> Option<bool> {
        self.product_definitional
    }
}
impl ITeeProfile for TeeProfile {}
impl TeeProfile {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = TeeProfile::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => entity.of_shape = parameter.into(),
                3usize => entity.product_definitional = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait ITerminatorSymbol: IAnnotationSymbolOccurrence {
    fn annotated_curve(&self) -> &EntityRef;
}
#[derive(Default, Debug)]
pub struct TerminatorSymbol {
    name: Label,
    styles: HashSet<EntityRef>,
    item: EntityRef,
    annotated_curve: EntityRef,
}
impl IRepresentationItem for TerminatorSymbol {
    fn name(&self) -> &Label {
        &self.name
    }
}
impl IStyledItem for TerminatorSymbol {
    fn styles(&self) -> &HashSet<EntityRef> {
        &self.styles
    }
    fn item(&self) -> &EntityRef {
        &self.item
    }
}
impl IAnnotationOccurrence for TerminatorSymbol {}
impl IAnnotationSymbolOccurrence for TerminatorSymbol {
    fn item(&self) -> &EntityRef {
        &self.item
    }
}
impl ITerminatorSymbol for TerminatorSymbol {
    fn annotated_curve(&self) -> &EntityRef {
        &self.annotated_curve
    }
}
impl TerminatorSymbol {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = TerminatorSymbol::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => entity.styles = parameter.into(),
                2usize => entity.item = parameter.into(),
                3usize => entity.annotated_curve = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait ITextLiteral: IGeometricRepresentationItem {
    fn literal(&self) -> &PresentableText;
    fn placement(&self) -> &EntityRef;
    fn alignment(&self) -> &TextAlignment;
    fn path(&self) -> &TextPath;
    fn font(&self) -> &EntityRef;
}
#[derive(Default, Debug)]
pub struct TextLiteral {
    name: Label,
    literal: PresentableText,
    placement: EntityRef,
    alignment: TextAlignment,
    path: TextPath,
    font: EntityRef,
}
impl IRepresentationItem for TextLiteral {
    fn name(&self) -> &Label {
        &self.name
    }
}
impl IGeometricRepresentationItem for TextLiteral {}
impl ITextLiteral for TextLiteral {
    fn literal(&self) -> &PresentableText {
        &self.literal
    }
    fn placement(&self) -> &EntityRef {
        &self.placement
    }
    fn alignment(&self) -> &TextAlignment {
        &self.alignment
    }
    fn path(&self) -> &TextPath {
        &self.path
    }
    fn font(&self) -> &EntityRef {
        &self.font
    }
}
impl TextLiteral {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = TextLiteral::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => entity.literal = parameter.into(),
                2usize => entity.placement = parameter.into(),
                3usize => entity.alignment = parameter.into(),
                4usize => entity.path = parameter.into(),
                5usize => entity.font = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait ITextLiteralWithAssociatedCurves: ITextLiteral {
    fn associated_curves(&self) -> &HashSet<EntityRef>;
}
#[derive(Default, Debug)]
pub struct TextLiteralWithAssociatedCurves {
    name: Label,
    literal: PresentableText,
    placement: EntityRef,
    alignment: TextAlignment,
    path: TextPath,
    font: EntityRef,
    associated_curves: HashSet<EntityRef>,
}
impl IRepresentationItem for TextLiteralWithAssociatedCurves {
    fn name(&self) -> &Label {
        &self.name
    }
}
impl IGeometricRepresentationItem for TextLiteralWithAssociatedCurves {}
impl ITextLiteral for TextLiteralWithAssociatedCurves {
    fn literal(&self) -> &PresentableText {
        &self.literal
    }
    fn placement(&self) -> &EntityRef {
        &self.placement
    }
    fn alignment(&self) -> &TextAlignment {
        &self.alignment
    }
    fn path(&self) -> &TextPath {
        &self.path
    }
    fn font(&self) -> &EntityRef {
        &self.font
    }
}
impl ITextLiteralWithAssociatedCurves for TextLiteralWithAssociatedCurves {
    fn associated_curves(&self) -> &HashSet<EntityRef> {
        &self.associated_curves
    }
}
impl TextLiteralWithAssociatedCurves {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = TextLiteralWithAssociatedCurves::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => entity.literal = parameter.into(),
                2usize => entity.placement = parameter.into(),
                3usize => entity.alignment = parameter.into(),
                4usize => entity.path = parameter.into(),
                5usize => entity.font = parameter.into(),
                6usize => entity.associated_curves = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait ITextLiteralWithBlankingBox: ITextLiteral {
    fn blanking(&self) -> &EntityRef;
}
#[derive(Default, Debug)]
pub struct TextLiteralWithBlankingBox {
    name: Label,
    literal: PresentableText,
    placement: EntityRef,
    alignment: TextAlignment,
    path: TextPath,
    font: EntityRef,
    blanking: EntityRef,
}
impl IRepresentationItem for TextLiteralWithBlankingBox {
    fn name(&self) -> &Label {
        &self.name
    }
}
impl IGeometricRepresentationItem for TextLiteralWithBlankingBox {}
impl ITextLiteral for TextLiteralWithBlankingBox {
    fn literal(&self) -> &PresentableText {
        &self.literal
    }
    fn placement(&self) -> &EntityRef {
        &self.placement
    }
    fn alignment(&self) -> &TextAlignment {
        &self.alignment
    }
    fn path(&self) -> &TextPath {
        &self.path
    }
    fn font(&self) -> &EntityRef {
        &self.font
    }
}
impl ITextLiteralWithBlankingBox for TextLiteralWithBlankingBox {
    fn blanking(&self) -> &EntityRef {
        &self.blanking
    }
}
impl TextLiteralWithBlankingBox {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = TextLiteralWithBlankingBox::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => entity.literal = parameter.into(),
                2usize => entity.placement = parameter.into(),
                3usize => entity.alignment = parameter.into(),
                4usize => entity.path = parameter.into(),
                5usize => entity.font = parameter.into(),
                6usize => entity.blanking = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait ITextLiteralWithDelineation: ITextLiteral {
    fn delineation(&self) -> &TextDelineation;
}
#[derive(Default, Debug)]
pub struct TextLiteralWithDelineation {
    name: Label,
    literal: PresentableText,
    placement: EntityRef,
    alignment: TextAlignment,
    path: TextPath,
    font: EntityRef,
    delineation: TextDelineation,
}
impl IRepresentationItem for TextLiteralWithDelineation {
    fn name(&self) -> &Label {
        &self.name
    }
}
impl IGeometricRepresentationItem for TextLiteralWithDelineation {}
impl ITextLiteral for TextLiteralWithDelineation {
    fn literal(&self) -> &PresentableText {
        &self.literal
    }
    fn placement(&self) -> &EntityRef {
        &self.placement
    }
    fn alignment(&self) -> &TextAlignment {
        &self.alignment
    }
    fn path(&self) -> &TextPath {
        &self.path
    }
    fn font(&self) -> &EntityRef {
        &self.font
    }
}
impl ITextLiteralWithDelineation for TextLiteralWithDelineation {
    fn delineation(&self) -> &TextDelineation {
        &self.delineation
    }
}
impl TextLiteralWithDelineation {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = TextLiteralWithDelineation::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => entity.literal = parameter.into(),
                2usize => entity.placement = parameter.into(),
                3usize => entity.alignment = parameter.into(),
                4usize => entity.path = parameter.into(),
                5usize => entity.font = parameter.into(),
                6usize => entity.delineation = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait ITextLiteralWithExtent: ITextLiteral {
    fn extent(&self) -> &EntityRef;
}
#[derive(Default, Debug)]
pub struct TextLiteralWithExtent {
    name: Label,
    literal: PresentableText,
    placement: EntityRef,
    alignment: TextAlignment,
    path: TextPath,
    font: EntityRef,
    extent: EntityRef,
}
impl IRepresentationItem for TextLiteralWithExtent {
    fn name(&self) -> &Label {
        &self.name
    }
}
impl IGeometricRepresentationItem for TextLiteralWithExtent {}
impl ITextLiteral for TextLiteralWithExtent {
    fn literal(&self) -> &PresentableText {
        &self.literal
    }
    fn placement(&self) -> &EntityRef {
        &self.placement
    }
    fn alignment(&self) -> &TextAlignment {
        &self.alignment
    }
    fn path(&self) -> &TextPath {
        &self.path
    }
    fn font(&self) -> &EntityRef {
        &self.font
    }
}
impl ITextLiteralWithExtent for TextLiteralWithExtent {
    fn extent(&self) -> &EntityRef {
        &self.extent
    }
}
impl TextLiteralWithExtent {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = TextLiteralWithExtent::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => entity.literal = parameter.into(),
                2usize => entity.placement = parameter.into(),
                3usize => entity.alignment = parameter.into(),
                4usize => entity.path = parameter.into(),
                5usize => entity.font = parameter.into(),
                6usize => entity.extent = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait ITextStringRepresentation: IRepresentation {
    fn items(&self) -> &HashSet<EntityRef>;
}
#[derive(Default, Debug)]
pub struct TextStringRepresentation {
    name: Label,
    context_of_items: EntityRef,
    items: HashSet<EntityRef>,
}
impl IRepresentation for TextStringRepresentation {
    fn name(&self) -> &Label {
        &self.name
    }
    fn items(&self) -> &HashSet<EntityRef> {
        &self.items
    }
    fn context_of_items(&self) -> &EntityRef {
        &self.context_of_items
    }
}
impl ITextStringRepresentation for TextStringRepresentation {
    fn items(&self) -> &HashSet<EntityRef> {
        &self.items
    }
}
impl TextStringRepresentation {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = TextStringRepresentation::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => entity.context_of_items = parameter.into(),
                2usize => entity.items = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait ITextStyle: IFoundedItem {
    fn name(&self) -> &Label;
    fn character_appearance(&self) -> &EntityRef;
}
#[derive(Default, Debug)]
pub struct TextStyle {
    name: Label,
    character_appearance: EntityRef,
}
impl IFoundedItem for TextStyle {}
impl ITextStyle for TextStyle {
    fn name(&self) -> &Label {
        &self.name
    }
    fn character_appearance(&self) -> &EntityRef {
        &self.character_appearance
    }
}
impl TextStyle {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = TextStyle::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => entity.character_appearance = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait ITextStyleForDefinedFont {
    fn text_colour(&self) -> &EntityRef;
}
#[derive(Default, Debug)]
pub struct TextStyleForDefinedFont {
    text_colour: EntityRef,
}
impl ITextStyleForDefinedFont for TextStyleForDefinedFont {
    fn text_colour(&self) -> &EntityRef {
        &self.text_colour
    }
}
impl TextStyleForDefinedFont {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = TextStyleForDefinedFont::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.text_colour = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait ITextStyleWithBoxCharacteristics: ITextStyle {
    fn characteristics(&self) -> &HashSet<BoxCharacteristicSelect>;
}
#[derive(Default, Debug)]
pub struct TextStyleWithBoxCharacteristics {
    name: Label,
    character_appearance: EntityRef,
    characteristics: HashSet<BoxCharacteristicSelect>,
}
impl IFoundedItem for TextStyleWithBoxCharacteristics {}
impl ITextStyle for TextStyleWithBoxCharacteristics {
    fn name(&self) -> &Label {
        &self.name
    }
    fn character_appearance(&self) -> &EntityRef {
        &self.character_appearance
    }
}
impl ITextStyleWithBoxCharacteristics for TextStyleWithBoxCharacteristics {
    fn characteristics(&self) -> &HashSet<BoxCharacteristicSelect> {
        &self.characteristics
    }
}
impl TextStyleWithBoxCharacteristics {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = TextStyleWithBoxCharacteristics::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => entity.character_appearance = parameter.into(),
                2usize => entity.characteristics = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait ITextStyleWithMirror: ITextStyle {
    fn mirror_placement(&self) -> &EntityRef;
}
#[derive(Default, Debug)]
pub struct TextStyleWithMirror {
    name: Label,
    character_appearance: EntityRef,
    mirror_placement: EntityRef,
}
impl IFoundedItem for TextStyleWithMirror {}
impl ITextStyle for TextStyleWithMirror {
    fn name(&self) -> &Label {
        &self.name
    }
    fn character_appearance(&self) -> &EntityRef {
        &self.character_appearance
    }
}
impl ITextStyleWithMirror for TextStyleWithMirror {
    fn mirror_placement(&self) -> &EntityRef {
        &self.mirror_placement
    }
}
impl TextStyleWithMirror {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = TextStyleWithMirror::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => entity.character_appearance = parameter.into(),
                2usize => entity.mirror_placement = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait ITextStyleWithSpacing: ITextStyle {
    fn character_spacing(&self) -> &CharacterSpacingSelect;
}
#[derive(Default, Debug)]
pub struct TextStyleWithSpacing {
    name: Label,
    character_appearance: EntityRef,
    character_spacing: CharacterSpacingSelect,
}
impl IFoundedItem for TextStyleWithSpacing {}
impl ITextStyle for TextStyleWithSpacing {
    fn name(&self) -> &Label {
        &self.name
    }
    fn character_appearance(&self) -> &EntityRef {
        &self.character_appearance
    }
}
impl ITextStyleWithSpacing for TextStyleWithSpacing {
    fn character_spacing(&self) -> &CharacterSpacingSelect {
        &self.character_spacing
    }
}
impl TextStyleWithSpacing {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = TextStyleWithSpacing::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => entity.character_appearance = parameter.into(),
                2usize => entity.character_spacing = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IThermodynamicTemperatureMeasureWithUnit: IMeasureWithUnit {}
#[derive(Default, Debug)]
pub struct ThermodynamicTemperatureMeasureWithUnit {
    value_component: MeasureValue,
    unit_component: EntityRef,
}
impl IMeasureWithUnit for ThermodynamicTemperatureMeasureWithUnit {
    fn value_component(&self) -> &MeasureValue {
        &self.value_component
    }
    fn unit_component(&self) -> &EntityRef {
        &self.unit_component
    }
}
impl IThermodynamicTemperatureMeasureWithUnit for ThermodynamicTemperatureMeasureWithUnit {}
impl ThermodynamicTemperatureMeasureWithUnit {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = ThermodynamicTemperatureMeasureWithUnit::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.value_component = parameter.into(),
                1usize => entity.unit_component = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IThermodynamicTemperatureUnit: INamedUnit {}
#[derive(Default, Debug)]
pub struct ThermodynamicTemperatureUnit {
    dimensions: EntityRef,
}
impl INamedUnit for ThermodynamicTemperatureUnit {
    fn dimensions(&self) -> &EntityRef {
        &self.dimensions
    }
}
impl IThermodynamicTemperatureUnit for ThermodynamicTemperatureUnit {}
impl ThermodynamicTemperatureUnit {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = ThermodynamicTemperatureUnit::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.dimensions = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IThread: IFeatureDefinition {}
#[derive(Default, Debug)]
pub struct Thread {
    name: Label,
    description: Option<Text>,
}
impl ICharacterizedObject for Thread {
    fn name(&self) -> &Label {
        &self.name
    }
    fn description(&self) -> &Option<Text> {
        &self.description
    }
}
impl IFeatureDefinition for Thread {}
impl IThread for Thread {}
impl Thread {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = Thread::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
}
pub trait ITimeInterval {
    fn id(&self) -> &Identifier;
    fn name(&self) -> &Label;
    fn description(&self) -> &Option<Text>;
}
#[derive(Default, Debug)]
pub struct TimeInterval {
    id: Identifier,
    name: Label,
    description: Option<Text>,
}
impl ITimeInterval for TimeInterval {
    fn id(&self) -> &Identifier {
        &self.id
    }
    fn name(&self) -> &Label {
        &self.name
    }
    fn description(&self) -> &Option<Text> {
        &self.description
    }
}
impl TimeInterval {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = TimeInterval::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.id = parameter.into(),
                1usize => entity.name = parameter.into(),
                2usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
}
pub trait ITimeIntervalAssignment {
    fn assigned_time_interval(&self) -> &EntityRef;
    fn role(&self) -> &EntityRef;
}
pub trait ITimeIntervalBasedEffectivity: IEffectivity {
    fn effectivity_period(&self) -> &EntityRef;
}
#[derive(Default, Debug)]
pub struct TimeIntervalBasedEffectivity {
    id: Identifier,
    effectivity_period: EntityRef,
}
impl IEffectivity for TimeIntervalBasedEffectivity {
    fn id(&self) -> &Identifier {
        &self.id
    }
}
impl ITimeIntervalBasedEffectivity for TimeIntervalBasedEffectivity {
    fn effectivity_period(&self) -> &EntityRef {
        &self.effectivity_period
    }
}
impl TimeIntervalBasedEffectivity {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = TimeIntervalBasedEffectivity::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.id = parameter.into(),
                1usize => entity.effectivity_period = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait ITimeIntervalRole {
    fn name(&self) -> &Label;
    fn description(&self) -> &Option<Text>;
}
#[derive(Default, Debug)]
pub struct TimeIntervalRole {
    name: Label,
    description: Option<Text>,
}
impl ITimeIntervalRole for TimeIntervalRole {
    fn name(&self) -> &Label {
        &self.name
    }
    fn description(&self) -> &Option<Text> {
        &self.description
    }
}
impl TimeIntervalRole {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = TimeIntervalRole::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
}
pub trait ITimeIntervalWithBounds: ITimeInterval {
    fn primary_bound(&self) -> &Option<EntityRef>;
    fn secondary_bound(&self) -> &Option<EntityRef>;
    fn duration(&self) -> &Option<EntityRef>;
}
#[derive(Default, Debug)]
pub struct TimeIntervalWithBounds {
    id: Identifier,
    name: Label,
    description: Option<Text>,
    primary_bound: Option<EntityRef>,
    secondary_bound: Option<EntityRef>,
    duration: Option<EntityRef>,
}
impl ITimeInterval for TimeIntervalWithBounds {
    fn id(&self) -> &Identifier {
        &self.id
    }
    fn name(&self) -> &Label {
        &self.name
    }
    fn description(&self) -> &Option<Text> {
        &self.description
    }
}
impl ITimeIntervalWithBounds for TimeIntervalWithBounds {
    fn primary_bound(&self) -> &Option<EntityRef> {
        &self.primary_bound
    }
    fn secondary_bound(&self) -> &Option<EntityRef> {
        &self.secondary_bound
    }
    fn duration(&self) -> &Option<EntityRef> {
        &self.duration
    }
}
impl TimeIntervalWithBounds {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = TimeIntervalWithBounds::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.id = parameter.into(),
                1usize => entity.name = parameter.into(),
                2usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.primary_bound = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => {
                    entity.secondary_bound = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                5usize => {
                    entity.duration = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
}
pub trait ITimeMeasureWithUnit: IMeasureWithUnit {}
#[derive(Default, Debug)]
pub struct TimeMeasureWithUnit {
    value_component: MeasureValue,
    unit_component: EntityRef,
}
impl IMeasureWithUnit for TimeMeasureWithUnit {
    fn value_component(&self) -> &MeasureValue {
        &self.value_component
    }
    fn unit_component(&self) -> &EntityRef {
        &self.unit_component
    }
}
impl ITimeMeasureWithUnit for TimeMeasureWithUnit {}
impl TimeMeasureWithUnit {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = TimeMeasureWithUnit::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.value_component = parameter.into(),
                1usize => entity.unit_component = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait ITimeUnit: INamedUnit {}
#[derive(Default, Debug)]
pub struct TimeUnit {
    dimensions: EntityRef,
}
impl INamedUnit for TimeUnit {
    fn dimensions(&self) -> &EntityRef {
        &self.dimensions
    }
}
impl ITimeUnit for TimeUnit {}
impl TimeUnit {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = TimeUnit::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.dimensions = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IToleranceValue {
    fn lower_bound(&self) -> &EntityRef;
    fn upper_bound(&self) -> &EntityRef;
}
#[derive(Default, Debug)]
pub struct ToleranceValue {
    lower_bound: EntityRef,
    upper_bound: EntityRef,
}
impl IToleranceValue for ToleranceValue {
    fn lower_bound(&self) -> &EntityRef {
        &self.lower_bound
    }
    fn upper_bound(&self) -> &EntityRef {
        &self.upper_bound
    }
}
impl ToleranceValue {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = ToleranceValue::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.lower_bound = parameter.into(),
                1usize => entity.upper_bound = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IToleranceZone: IShapeAspect {
    fn defining_tolerance(&self) -> &HashSet<EntityRef>;
    fn form(&self) -> &EntityRef;
}
#[derive(Default, Debug)]
pub struct ToleranceZone {
    name: Label,
    description: Option<Text>,
    of_shape: EntityRef,
    product_definitional: Option<bool>,
    defining_tolerance: HashSet<EntityRef>,
    form: EntityRef,
}
impl IShapeAspect for ToleranceZone {
    fn name(&self) -> &Label {
        &self.name
    }
    fn description(&self) -> &Option<Text> {
        &self.description
    }
    fn of_shape(&self) -> &EntityRef {
        &self.of_shape
    }
    fn product_definitional(&self) -> Option<bool> {
        self.product_definitional
    }
}
impl IToleranceZone for ToleranceZone {
    fn defining_tolerance(&self) -> &HashSet<EntityRef> {
        &self.defining_tolerance
    }
    fn form(&self) -> &EntityRef {
        &self.form
    }
}
impl ToleranceZone {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = ToleranceZone::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => entity.of_shape = parameter.into(),
                3usize => entity.product_definitional = parameter.into(),
                4usize => entity.defining_tolerance = parameter.into(),
                5usize => entity.form = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IToleranceZoneDefinition {
    fn zone(&self) -> &EntityRef;
    fn boundaries(&self) -> &HashSet<EntityRef>;
}
#[derive(Default, Debug)]
pub struct ToleranceZoneDefinition {
    zone: EntityRef,
    boundaries: HashSet<EntityRef>,
}
impl IToleranceZoneDefinition for ToleranceZoneDefinition {
    fn zone(&self) -> &EntityRef {
        &self.zone
    }
    fn boundaries(&self) -> &HashSet<EntityRef> {
        &self.boundaries
    }
}
impl ToleranceZoneDefinition {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = ToleranceZoneDefinition::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.zone = parameter.into(),
                1usize => entity.boundaries = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IToleranceZoneForm {
    fn name(&self) -> &Label;
}
#[derive(Default, Debug)]
pub struct ToleranceZoneForm {
    name: Label,
}
impl IToleranceZoneForm for ToleranceZoneForm {
    fn name(&self) -> &Label {
        &self.name
    }
}
impl ToleranceZoneForm {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = ToleranceZoneForm::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait ITopologicalRepresentationItem: IRepresentationItem {}
#[derive(Default, Debug)]
pub struct TopologicalRepresentationItem {
    name: Label,
}
impl IRepresentationItem for TopologicalRepresentationItem {
    fn name(&self) -> &Label {
        &self.name
    }
}
impl ITopologicalRepresentationItem for TopologicalRepresentationItem {}
impl TopologicalRepresentationItem {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = TopologicalRepresentationItem::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IToroidalSurface: IElementarySurface {
    fn major_radius(&self) -> &PositiveLengthMeasure;
    fn minor_radius(&self) -> &PositiveLengthMeasure;
}
#[derive(Default, Debug)]
pub struct ToroidalSurface {
    name: Label,
    position: EntityRef,
    major_radius: PositiveLengthMeasure,
    minor_radius: PositiveLengthMeasure,
}
impl IRepresentationItem for ToroidalSurface {
    fn name(&self) -> &Label {
        &self.name
    }
}
impl IGeometricRepresentationItem for ToroidalSurface {}
impl ISurface for ToroidalSurface {}
impl IElementarySurface for ToroidalSurface {
    fn position(&self) -> &EntityRef {
        &self.position
    }
}
impl IToroidalSurface for ToroidalSurface {
    fn major_radius(&self) -> &PositiveLengthMeasure {
        &self.major_radius
    }
    fn minor_radius(&self) -> &PositiveLengthMeasure {
        &self.minor_radius
    }
}
impl ToroidalSurface {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = ToroidalSurface::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => entity.position = parameter.into(),
                2usize => entity.major_radius = parameter.into(),
                3usize => entity.minor_radius = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait ITorus: IGeometricRepresentationItem {
    fn position(&self) -> &EntityRef;
    fn major_radius(&self) -> &PositiveLengthMeasure;
    fn minor_radius(&self) -> &PositiveLengthMeasure;
}
#[derive(Default, Debug)]
pub struct Torus {
    name: Label,
    position: EntityRef,
    major_radius: PositiveLengthMeasure,
    minor_radius: PositiveLengthMeasure,
}
impl IRepresentationItem for Torus {
    fn name(&self) -> &Label {
        &self.name
    }
}
impl IGeometricRepresentationItem for Torus {}
impl ITorus for Torus {
    fn position(&self) -> &EntityRef {
        &self.position
    }
    fn major_radius(&self) -> &PositiveLengthMeasure {
        &self.major_radius
    }
    fn minor_radius(&self) -> &PositiveLengthMeasure {
        &self.minor_radius
    }
}
impl Torus {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = Torus::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => entity.position = parameter.into(),
                2usize => entity.major_radius = parameter.into(),
                3usize => entity.minor_radius = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait ITotalRunoutTolerance: IGeometricToleranceWithDatumReference {}
#[derive(Default, Debug)]
pub struct TotalRunoutTolerance {
    name: Label,
    description: Text,
    magnitude: EntityRef,
    toleranced_shape_aspect: EntityRef,
    datum_system: HashSet<EntityRef>,
}
impl IGeometricTolerance for TotalRunoutTolerance {
    fn name(&self) -> &Label {
        &self.name
    }
    fn description(&self) -> &Text {
        &self.description
    }
    fn magnitude(&self) -> &EntityRef {
        &self.magnitude
    }
    fn toleranced_shape_aspect(&self) -> &EntityRef {
        &self.toleranced_shape_aspect
    }
}
impl IGeometricToleranceWithDatumReference for TotalRunoutTolerance {
    fn datum_system(&self) -> &HashSet<EntityRef> {
        &self.datum_system
    }
}
impl ITotalRunoutTolerance for TotalRunoutTolerance {}
impl TotalRunoutTolerance {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = TotalRunoutTolerance::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => entity.description = parameter.into(),
                2usize => entity.magnitude = parameter.into(),
                3usize => entity.toleranced_shape_aspect = parameter.into(),
                4usize => entity.datum_system = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait ITransitionFeature: IShapeAspect {}
#[derive(Default, Debug)]
pub struct TransitionFeature {
    name: Label,
    description: Option<Text>,
    of_shape: EntityRef,
    product_definitional: Option<bool>,
}
impl IShapeAspect for TransitionFeature {
    fn name(&self) -> &Label {
        &self.name
    }
    fn description(&self) -> &Option<Text> {
        &self.description
    }
    fn of_shape(&self) -> &EntityRef {
        &self.of_shape
    }
    fn product_definitional(&self) -> Option<bool> {
        self.product_definitional
    }
}
impl ITransitionFeature for TransitionFeature {}
impl TransitionFeature {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = TransitionFeature::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => entity.of_shape = parameter.into(),
                3usize => entity.product_definitional = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait ITrimmedCurve: IBoundedCurve {
    fn basis_curve(&self) -> &EntityRef;
    fn trim_1(&self) -> &HashSet<TrimmingSelect>;
    fn trim_2(&self) -> &HashSet<TrimmingSelect>;
    fn sense_agreement(&self) -> bool;
    fn master_representation(&self) -> &TrimmingPreference;
}
#[derive(Default, Debug)]
pub struct TrimmedCurve {
    name: Label,
    basis_curve: EntityRef,
    trim_1: HashSet<TrimmingSelect>,
    trim_2: HashSet<TrimmingSelect>,
    sense_agreement: bool,
    master_representation: TrimmingPreference,
}
impl IRepresentationItem for TrimmedCurve {
    fn name(&self) -> &Label {
        &self.name
    }
}
impl IGeometricRepresentationItem for TrimmedCurve {}
impl ICurve for TrimmedCurve {}
impl IBoundedCurve for TrimmedCurve {}
impl ITrimmedCurve for TrimmedCurve {
    fn basis_curve(&self) -> &EntityRef {
        &self.basis_curve
    }
    fn trim_1(&self) -> &HashSet<TrimmingSelect> {
        &self.trim_1
    }
    fn trim_2(&self) -> &HashSet<TrimmingSelect> {
        &self.trim_2
    }
    fn sense_agreement(&self) -> bool {
        self.sense_agreement
    }
    fn master_representation(&self) -> &TrimmingPreference {
        &self.master_representation
    }
}
impl TrimmedCurve {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = TrimmedCurve::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => entity.basis_curve = parameter.into(),
                2usize => entity.trim_1 = parameter.into(),
                3usize => entity.trim_2 = parameter.into(),
                4usize => entity.sense_agreement = parameter.into(),
                5usize => entity.master_representation = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait ITwoDirectionRepeatFactor: IOneDirectionRepeatFactor {
    fn second_repeat_factor(&self) -> &EntityRef;
}
#[derive(Default, Debug)]
pub struct TwoDirectionRepeatFactor {
    name: Label,
    repeat_factor: EntityRef,
    second_repeat_factor: EntityRef,
}
impl IRepresentationItem for TwoDirectionRepeatFactor {
    fn name(&self) -> &Label {
        &self.name
    }
}
impl IGeometricRepresentationItem for TwoDirectionRepeatFactor {}
impl IOneDirectionRepeatFactor for TwoDirectionRepeatFactor {
    fn repeat_factor(&self) -> &EntityRef {
        &self.repeat_factor
    }
}
impl ITwoDirectionRepeatFactor for TwoDirectionRepeatFactor {
    fn second_repeat_factor(&self) -> &EntityRef {
        &self.second_repeat_factor
    }
}
impl TwoDirectionRepeatFactor {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = TwoDirectionRepeatFactor::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => entity.repeat_factor = parameter.into(),
                2usize => entity.second_repeat_factor = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait ITypeQualifier {
    fn name(&self) -> &Label;
}
#[derive(Default, Debug)]
pub struct TypeQualifier {
    name: Label,
}
impl ITypeQualifier for TypeQualifier {
    fn name(&self) -> &Label {
        &self.name
    }
}
impl TypeQualifier {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = TypeQualifier::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IUnaryBooleanExpression: IBooleanExpression + IUnaryGenericExpression {}
pub trait IUnaryFunctionCall: IUnaryNumericExpression {}
pub trait IUnaryGenericExpression: IGenericExpression {
    fn operand(&self) -> &EntityRef;
}
pub trait IUnaryNumericExpression: INumericExpression + IUnaryGenericExpression {
    fn operand(&self) -> &EntityRef;
}
pub trait IUncertaintyAssignedRepresentation: IRepresentation {
    fn uncertainty(&self) -> &HashSet<EntityRef>;
}
#[derive(Default, Debug)]
pub struct UncertaintyAssignedRepresentation {
    name: Label,
    items: HashSet<EntityRef>,
    context_of_items: EntityRef,
    uncertainty: HashSet<EntityRef>,
}
impl IRepresentation for UncertaintyAssignedRepresentation {
    fn name(&self) -> &Label {
        &self.name
    }
    fn items(&self) -> &HashSet<EntityRef> {
        &self.items
    }
    fn context_of_items(&self) -> &EntityRef {
        &self.context_of_items
    }
}
impl IUncertaintyAssignedRepresentation for UncertaintyAssignedRepresentation {
    fn uncertainty(&self) -> &HashSet<EntityRef> {
        &self.uncertainty
    }
}
impl UncertaintyAssignedRepresentation {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = UncertaintyAssignedRepresentation::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => entity.items = parameter.into(),
                2usize => entity.context_of_items = parameter.into(),
                3usize => entity.uncertainty = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IUncertaintyMeasureWithUnit: IMeasureWithUnit {
    fn name(&self) -> &Label;
    fn description(&self) -> &Option<Text>;
}
#[derive(Default, Debug)]
pub struct UncertaintyMeasureWithUnit {
    value_component: MeasureValue,
    unit_component: EntityRef,
    name: Label,
    description: Option<Text>,
}
impl IMeasureWithUnit for UncertaintyMeasureWithUnit {
    fn value_component(&self) -> &MeasureValue {
        &self.value_component
    }
    fn unit_component(&self) -> &EntityRef {
        &self.unit_component
    }
}
impl IUncertaintyMeasureWithUnit for UncertaintyMeasureWithUnit {
    fn name(&self) -> &Label {
        &self.name
    }
    fn description(&self) -> &Option<Text> {
        &self.description
    }
}
impl UncertaintyMeasureWithUnit {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = UncertaintyMeasureWithUnit::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.value_component = parameter.into(),
                1usize => entity.unit_component = parameter.into(),
                2usize => entity.name = parameter.into(),
                3usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
}
pub trait IUncertaintyQualifier {
    fn measure_name(&self) -> &Label;
    fn description(&self) -> &Text;
}
#[derive(Default, Debug)]
pub struct UncertaintyQualifier {
    measure_name: Label,
    description: Text,
}
impl IUncertaintyQualifier for UncertaintyQualifier {
    fn measure_name(&self) -> &Label {
        &self.measure_name
    }
    fn description(&self) -> &Text {
        &self.description
    }
}
impl UncertaintyQualifier {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = UncertaintyQualifier::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.measure_name = parameter.into(),
                1usize => entity.description = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IUnconstrainedPair: IKinematicPair {}
#[derive(Default, Debug)]
pub struct UnconstrainedPair {
    name: Label,
    description: Option<Text>,
    transform_item_1: EntityRef,
    transform_item_2: EntityRef,
    joint: EntityRef,
}
impl IItemDefinedTransformation for UnconstrainedPair {
    fn name(&self) -> &Label {
        &self.name
    }
    fn description(&self) -> &Option<Text> {
        &self.description
    }
    fn transform_item_1(&self) -> &EntityRef {
        &self.transform_item_1
    }
    fn transform_item_2(&self) -> &EntityRef {
        &self.transform_item_2
    }
}
impl IKinematicPair for UnconstrainedPair {
    fn joint(&self) -> &EntityRef {
        &self.joint
    }
}
impl IUnconstrainedPair for UnconstrainedPair {}
impl UnconstrainedPair {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = UnconstrainedPair::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => entity.transform_item_1 = parameter.into(),
                3usize => entity.transform_item_2 = parameter.into(),
                4usize => entity.joint = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IUnconstrainedPairValue: IPairValue {
    fn applies_to_pair(&self) -> &EntityRef;
    fn actual_placement(&self) -> &EntityRef;
}
#[derive(Default, Debug)]
pub struct UnconstrainedPairValue {
    applies_to_pair: EntityRef,
    actual_placement: EntityRef,
}
impl IPairValue for UnconstrainedPairValue {
    fn applies_to_pair(&self) -> &EntityRef {
        &self.applies_to_pair
    }
}
impl IUnconstrainedPairValue for UnconstrainedPairValue {
    fn applies_to_pair(&self) -> &EntityRef {
        &self.applies_to_pair
    }
    fn actual_placement(&self) -> &EntityRef {
        &self.actual_placement
    }
}
impl UnconstrainedPairValue {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = UnconstrainedPairValue::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.applies_to_pair = parameter.into(),
                1usize => entity.actual_placement = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IUniformCurve: IBSplineCurve {}
#[derive(Default, Debug)]
pub struct UniformCurve {
    name: Label,
    degree: i64,
    control_points_list: Vec<EntityRef>,
    curve_form: BSplineCurveForm,
    closed_curve: Option<bool>,
    self_intersect: Option<bool>,
}
impl IRepresentationItem for UniformCurve {
    fn name(&self) -> &Label {
        &self.name
    }
}
impl IGeometricRepresentationItem for UniformCurve {}
impl ICurve for UniformCurve {}
impl IBoundedCurve for UniformCurve {}
impl IBSplineCurve for UniformCurve {
    fn degree(&self) -> i64 {
        self.degree
    }
    fn control_points_list(&self) -> &Vec<EntityRef> {
        &self.control_points_list
    }
    fn curve_form(&self) -> &BSplineCurveForm {
        &self.curve_form
    }
    fn closed_curve(&self) -> Option<bool> {
        self.closed_curve
    }
    fn self_intersect(&self) -> Option<bool> {
        self.self_intersect
    }
}
impl IUniformCurve for UniformCurve {}
impl UniformCurve {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = UniformCurve::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => entity.degree = parameter.into(),
                2usize => entity.control_points_list = parameter.into(),
                3usize => entity.curve_form = parameter.into(),
                4usize => entity.closed_curve = parameter.into(),
                5usize => entity.self_intersect = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IUniformSurface: IBSplineSurface {}
#[derive(Default, Debug)]
pub struct UniformSurface {
    name: Label,
    u_degree: i64,
    v_degree: i64,
    control_points_list: Vec<Vec<EntityRef>>,
    surface_form: BSplineSurfaceForm,
    u_closed: Option<bool>,
    v_closed: Option<bool>,
    self_intersect: Option<bool>,
}
impl IRepresentationItem for UniformSurface {
    fn name(&self) -> &Label {
        &self.name
    }
}
impl IGeometricRepresentationItem for UniformSurface {}
impl ISurface for UniformSurface {}
impl IBoundedSurface for UniformSurface {}
impl IBSplineSurface for UniformSurface {
    fn u_degree(&self) -> i64 {
        self.u_degree
    }
    fn v_degree(&self) -> i64 {
        self.v_degree
    }
    fn control_points_list(&self) -> &Vec<Vec<EntityRef>> {
        &self.control_points_list
    }
    fn surface_form(&self) -> &BSplineSurfaceForm {
        &self.surface_form
    }
    fn u_closed(&self) -> Option<bool> {
        self.u_closed
    }
    fn v_closed(&self) -> Option<bool> {
        self.v_closed
    }
    fn self_intersect(&self) -> Option<bool> {
        self.self_intersect
    }
}
impl IUniformSurface for UniformSurface {}
impl UniformSurface {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = UniformSurface::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => entity.u_degree = parameter.into(),
                2usize => entity.v_degree = parameter.into(),
                3usize => entity.control_points_list = parameter.into(),
                4usize => entity.surface_form = parameter.into(),
                5usize => entity.u_closed = parameter.into(),
                6usize => entity.v_closed = parameter.into(),
                7usize => entity.self_intersect = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IUniversalPair: IKinematicPair {
    fn input_skew_angle(&self) -> &Option<PlaneAngleMeasure>;
}
#[derive(Default, Debug)]
pub struct UniversalPair {
    name: Label,
    description: Option<Text>,
    transform_item_1: EntityRef,
    transform_item_2: EntityRef,
    joint: EntityRef,
    input_skew_angle: Option<PlaneAngleMeasure>,
}
impl IItemDefinedTransformation for UniversalPair {
    fn name(&self) -> &Label {
        &self.name
    }
    fn description(&self) -> &Option<Text> {
        &self.description
    }
    fn transform_item_1(&self) -> &EntityRef {
        &self.transform_item_1
    }
    fn transform_item_2(&self) -> &EntityRef {
        &self.transform_item_2
    }
}
impl IKinematicPair for UniversalPair {
    fn joint(&self) -> &EntityRef {
        &self.joint
    }
}
impl IUniversalPair for UniversalPair {
    fn input_skew_angle(&self) -> &Option<PlaneAngleMeasure> {
        &self.input_skew_angle
    }
}
impl UniversalPair {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = UniversalPair::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => entity.transform_item_1 = parameter.into(),
                3usize => entity.transform_item_2 = parameter.into(),
                4usize => entity.joint = parameter.into(),
                5usize => {
                    entity.input_skew_angle = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
}
pub trait IUniversalPairRange: ISimplePairRange {
    fn applies_to_pair(&self) -> &EntityRef;
    fn lower_limit_first_rotation(&self) -> &RotationalRangeMeasure;
    fn upper_limit_first_rotation(&self) -> &RotationalRangeMeasure;
    fn lower_limit_second_rotation(&self) -> &RotationalRangeMeasure;
    fn upper_limit_second_rotation(&self) -> &RotationalRangeMeasure;
}
#[derive(Default, Debug)]
pub struct UniversalPairRange {
    applies_to_pair: EntityRef,
    lower_limit_first_rotation: RotationalRangeMeasure,
    upper_limit_first_rotation: RotationalRangeMeasure,
    lower_limit_second_rotation: RotationalRangeMeasure,
    upper_limit_second_rotation: RotationalRangeMeasure,
}
impl ISimplePairRange for UniversalPairRange {
    fn applies_to_pair(&self) -> &EntityRef {
        &self.applies_to_pair
    }
}
impl IUniversalPairRange for UniversalPairRange {
    fn applies_to_pair(&self) -> &EntityRef {
        &self.applies_to_pair
    }
    fn lower_limit_first_rotation(&self) -> &RotationalRangeMeasure {
        &self.lower_limit_first_rotation
    }
    fn upper_limit_first_rotation(&self) -> &RotationalRangeMeasure {
        &self.upper_limit_first_rotation
    }
    fn lower_limit_second_rotation(&self) -> &RotationalRangeMeasure {
        &self.lower_limit_second_rotation
    }
    fn upper_limit_second_rotation(&self) -> &RotationalRangeMeasure {
        &self.upper_limit_second_rotation
    }
}
impl UniversalPairRange {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = UniversalPairRange::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.applies_to_pair = parameter.into(),
                1usize => entity.lower_limit_first_rotation = parameter.into(),
                2usize => entity.upper_limit_first_rotation = parameter.into(),
                3usize => entity.lower_limit_second_rotation = parameter.into(),
                4usize => entity.upper_limit_second_rotation = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IUniversalPairValue: IPairValue {
    fn applies_to_pair(&self) -> &EntityRef;
    fn first_rotation_angle(&self) -> &PlaneAngleMeasure;
    fn second_rotation_angle(&self) -> &PlaneAngleMeasure;
}
#[derive(Default, Debug)]
pub struct UniversalPairValue {
    applies_to_pair: EntityRef,
    first_rotation_angle: PlaneAngleMeasure,
    second_rotation_angle: PlaneAngleMeasure,
}
impl IPairValue for UniversalPairValue {
    fn applies_to_pair(&self) -> &EntityRef {
        &self.applies_to_pair
    }
}
impl IUniversalPairValue for UniversalPairValue {
    fn applies_to_pair(&self) -> &EntityRef {
        &self.applies_to_pair
    }
    fn first_rotation_angle(&self) -> &PlaneAngleMeasure {
        &self.first_rotation_angle
    }
    fn second_rotation_angle(&self) -> &PlaneAngleMeasure {
        &self.second_rotation_angle
    }
}
impl UniversalPairValue {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = UniversalPairValue::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.applies_to_pair = parameter.into(),
                1usize => entity.first_rotation_angle = parameter.into(),
                2usize => entity.second_rotation_angle = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IValueFunction: INumericExpression + IUnaryGenericExpression {
    fn operand(&self) -> &EntityRef;
}
#[derive(Default, Debug)]
pub struct ValueFunction {
    operand: EntityRef,
}
impl IGenericExpression for ValueFunction {}
impl IExpression for ValueFunction {}
impl INumericExpression for ValueFunction {}
impl IValueFunction for ValueFunction {
    fn operand(&self) -> &EntityRef {
        &self.operand
    }
}
impl IUnaryGenericExpression for ValueFunction {
    fn operand(&self) -> &EntityRef {
        &self.operand
    }
}
impl ValueFunction {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = ValueFunction::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.operand = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IValueRange: ICompoundRepresentationItem {}
#[derive(Default, Debug)]
pub struct ValueRange {
    name: Label,
    item_element: CompoundItemDefinition,
}
impl IRepresentationItem for ValueRange {
    fn name(&self) -> &Label {
        &self.name
    }
}
impl ICompoundRepresentationItem for ValueRange {
    fn item_element(&self) -> &CompoundItemDefinition {
        &self.item_element
    }
}
impl IValueRange for ValueRange {}
impl ValueRange {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = ValueRange::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => entity.item_element = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IValueRepresentationItem: IRepresentationItem {
    fn value_component(&self) -> &MeasureValue;
}
#[derive(Default, Debug)]
pub struct ValueRepresentationItem {
    name: Label,
    value_component: MeasureValue,
}
impl IRepresentationItem for ValueRepresentationItem {
    fn name(&self) -> &Label {
        &self.name
    }
}
impl IValueRepresentationItem for ValueRepresentationItem {
    fn value_component(&self) -> &MeasureValue {
        &self.value_component
    }
}
impl ValueRepresentationItem {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = ValueRepresentationItem::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => entity.value_component = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IVariable: IGenericVariable {}
pub trait IVariableSemantics {}
pub trait IVector: IGeometricRepresentationItem {
    fn orientation(&self) -> &EntityRef;
    fn magnitude(&self) -> &LengthMeasure;
}
#[derive(Default, Debug)]
pub struct Vector {
    name: Label,
    orientation: EntityRef,
    magnitude: LengthMeasure,
}
impl IRepresentationItem for Vector {
    fn name(&self) -> &Label {
        &self.name
    }
}
impl IGeometricRepresentationItem for Vector {}
impl IVector for Vector {
    fn orientation(&self) -> &EntityRef {
        &self.orientation
    }
    fn magnitude(&self) -> &LengthMeasure {
        &self.magnitude
    }
}
impl Vector {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = Vector::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => entity.orientation = parameter.into(),
                2usize => entity.magnitude = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IVectorStyle: IPreDefinedTerminatorSymbol + ICurveStyle {}
#[derive(Default, Debug)]
pub struct VectorStyle {
    name: Label,
    curve_font: EntityRef,
    curve_width: SizeSelect,
    curve_colour: EntityRef,
}
impl IPreDefinedItem for VectorStyle {
    fn name(&self) -> &Label {
        &self.name
    }
}
impl IPreDefinedSymbol for VectorStyle {}
impl IPreDefinedTerminatorSymbol for VectorStyle {}
impl IFoundedItem for VectorStyle {}
impl ICurveStyle for VectorStyle {
    fn name(&self) -> &Label {
        &self.name
    }
    fn curve_font(&self) -> &EntityRef {
        &self.curve_font
    }
    fn curve_width(&self) -> &SizeSelect {
        &self.curve_width
    }
    fn curve_colour(&self) -> &EntityRef {
        &self.curve_colour
    }
}
impl IVectorStyle for VectorStyle {}
impl VectorStyle {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = VectorStyle::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => entity.curve_font = parameter.into(),
                2usize => entity.curve_width = parameter.into(),
                3usize => entity.curve_colour = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IVeeProfile: IShapeAspect {}
#[derive(Default, Debug)]
pub struct VeeProfile {
    name: Label,
    description: Option<Text>,
    of_shape: EntityRef,
    product_definitional: Option<bool>,
}
impl IShapeAspect for VeeProfile {
    fn name(&self) -> &Label {
        &self.name
    }
    fn description(&self) -> &Option<Text> {
        &self.description
    }
    fn of_shape(&self) -> &EntityRef {
        &self.of_shape
    }
    fn product_definitional(&self) -> Option<bool> {
        self.product_definitional
    }
}
impl IVeeProfile for VeeProfile {}
impl VeeProfile {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = VeeProfile::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => entity.of_shape = parameter.into(),
                3usize => entity.product_definitional = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IVersionedActionRequest {
    fn id(&self) -> &Identifier;
    fn version(&self) -> &Label;
    fn purpose(&self) -> &Text;
    fn description(&self) -> &Option<Text>;
}
#[derive(Default, Debug)]
pub struct VersionedActionRequest {
    id: Identifier,
    version: Label,
    purpose: Text,
    description: Option<Text>,
}
impl IVersionedActionRequest for VersionedActionRequest {
    fn id(&self) -> &Identifier {
        &self.id
    }
    fn version(&self) -> &Label {
        &self.version
    }
    fn purpose(&self) -> &Text {
        &self.purpose
    }
    fn description(&self) -> &Option<Text> {
        &self.description
    }
}
impl VersionedActionRequest {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = VersionedActionRequest::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.id = parameter.into(),
                1usize => entity.version = parameter.into(),
                2usize => entity.purpose = parameter.into(),
                3usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
}
pub trait IVersionedActionRequestRelationship {
    fn id(&self) -> &Identifier;
    fn name(&self) -> &Label;
    fn description(&self) -> &Option<Text>;
    fn relating_versioned_action_request(&self) -> &EntityRef;
    fn related_versioned_action_request(&self) -> &EntityRef;
}
#[derive(Default, Debug)]
pub struct VersionedActionRequestRelationship {
    id: Identifier,
    name: Label,
    description: Option<Text>,
    relating_versioned_action_request: EntityRef,
    related_versioned_action_request: EntityRef,
}
impl IVersionedActionRequestRelationship for VersionedActionRequestRelationship {
    fn id(&self) -> &Identifier {
        &self.id
    }
    fn name(&self) -> &Label {
        &self.name
    }
    fn description(&self) -> &Option<Text> {
        &self.description
    }
    fn relating_versioned_action_request(&self) -> &EntityRef {
        &self.relating_versioned_action_request
    }
    fn related_versioned_action_request(&self) -> &EntityRef {
        &self.related_versioned_action_request
    }
}
impl VersionedActionRequestRelationship {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = VersionedActionRequestRelationship::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.id = parameter.into(),
                1usize => entity.name = parameter.into(),
                2usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => entity.relating_versioned_action_request = parameter.into(),
                4usize => entity.related_versioned_action_request = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IVertex: ITopologicalRepresentationItem {}
#[derive(Default, Debug)]
pub struct Vertex {
    name: Label,
}
impl IRepresentationItem for Vertex {
    fn name(&self) -> &Label {
        &self.name
    }
}
impl ITopologicalRepresentationItem for Vertex {}
impl IVertex for Vertex {}
impl Vertex {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = Vertex::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IVertexLoop: ILoop {
    fn loop_vertex(&self) -> &EntityRef;
}
#[derive(Default, Debug)]
pub struct VertexLoop {
    name: Label,
    loop_vertex: EntityRef,
}
impl IRepresentationItem for VertexLoop {
    fn name(&self) -> &Label {
        &self.name
    }
}
impl ITopologicalRepresentationItem for VertexLoop {}
impl ILoop for VertexLoop {}
impl IVertexLoop for VertexLoop {
    fn loop_vertex(&self) -> &EntityRef {
        &self.loop_vertex
    }
}
impl VertexLoop {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = VertexLoop::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => entity.loop_vertex = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IVertexPoint: IVertex + IGeometricRepresentationItem {
    fn vertex_geometry(&self) -> &EntityRef;
}
#[derive(Default, Debug)]
pub struct VertexPoint {
    name: Label,
    vertex_geometry: EntityRef,
}
impl IRepresentationItem for VertexPoint {
    fn name(&self) -> &Label {
        &self.name
    }
}
impl ITopologicalRepresentationItem for VertexPoint {}
impl IVertex for VertexPoint {}
impl IVertexPoint for VertexPoint {
    fn vertex_geometry(&self) -> &EntityRef {
        &self.vertex_geometry
    }
}
impl IGeometricRepresentationItem for VertexPoint {}
impl VertexPoint {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = VertexPoint::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => entity.vertex_geometry = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IViewVolume: IFoundedItem {
    fn projection_type(&self) -> &CentralOrParallel;
    fn projection_point(&self) -> &EntityRef;
    fn view_plane_distance(&self) -> &LengthMeasure;
    fn front_plane_distance(&self) -> &LengthMeasure;
    fn front_plane_clipping(&self) -> bool;
    fn back_plane_distance(&self) -> &LengthMeasure;
    fn back_plane_clipping(&self) -> bool;
    fn view_volume_sides_clipping(&self) -> bool;
    fn view_window(&self) -> &EntityRef;
}
#[derive(Default, Debug)]
pub struct ViewVolume {
    projection_type: CentralOrParallel,
    projection_point: EntityRef,
    view_plane_distance: LengthMeasure,
    front_plane_distance: LengthMeasure,
    front_plane_clipping: bool,
    back_plane_distance: LengthMeasure,
    back_plane_clipping: bool,
    view_volume_sides_clipping: bool,
    view_window: EntityRef,
}
impl IFoundedItem for ViewVolume {}
impl IViewVolume for ViewVolume {
    fn projection_type(&self) -> &CentralOrParallel {
        &self.projection_type
    }
    fn projection_point(&self) -> &EntityRef {
        &self.projection_point
    }
    fn view_plane_distance(&self) -> &LengthMeasure {
        &self.view_plane_distance
    }
    fn front_plane_distance(&self) -> &LengthMeasure {
        &self.front_plane_distance
    }
    fn front_plane_clipping(&self) -> bool {
        self.front_plane_clipping
    }
    fn back_plane_distance(&self) -> &LengthMeasure {
        &self.back_plane_distance
    }
    fn back_plane_clipping(&self) -> bool {
        self.back_plane_clipping
    }
    fn view_volume_sides_clipping(&self) -> bool {
        self.view_volume_sides_clipping
    }
    fn view_window(&self) -> &EntityRef {
        &self.view_window
    }
}
impl ViewVolume {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = ViewVolume::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.projection_type = parameter.into(),
                1usize => entity.projection_point = parameter.into(),
                2usize => entity.view_plane_distance = parameter.into(),
                3usize => entity.front_plane_distance = parameter.into(),
                4usize => entity.front_plane_clipping = parameter.into(),
                5usize => entity.back_plane_distance = parameter.into(),
                6usize => entity.back_plane_clipping = parameter.into(),
                7usize => entity.view_volume_sides_clipping = parameter.into(),
                8usize => entity.view_window = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IVisualAppearanceRepresentation: IRepresentation {}
#[derive(Default, Debug)]
pub struct VisualAppearanceRepresentation {
    name: Label,
    items: HashSet<EntityRef>,
    context_of_items: EntityRef,
}
impl IRepresentation for VisualAppearanceRepresentation {
    fn name(&self) -> &Label {
        &self.name
    }
    fn items(&self) -> &HashSet<EntityRef> {
        &self.items
    }
    fn context_of_items(&self) -> &EntityRef {
        &self.context_of_items
    }
}
impl IVisualAppearanceRepresentation for VisualAppearanceRepresentation {}
impl VisualAppearanceRepresentation {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = VisualAppearanceRepresentation::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => entity.items = parameter.into(),
                2usize => entity.context_of_items = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IVolumeMeasureWithUnit: IMeasureWithUnit {}
#[derive(Default, Debug)]
pub struct VolumeMeasureWithUnit {
    value_component: MeasureValue,
    unit_component: EntityRef,
}
impl IMeasureWithUnit for VolumeMeasureWithUnit {
    fn value_component(&self) -> &MeasureValue {
        &self.value_component
    }
    fn unit_component(&self) -> &EntityRef {
        &self.unit_component
    }
}
impl IVolumeMeasureWithUnit for VolumeMeasureWithUnit {}
impl VolumeMeasureWithUnit {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = VolumeMeasureWithUnit::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.value_component = parameter.into(),
                1usize => entity.unit_component = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IVolumeUnit: IDerivedUnit {}
#[derive(Default, Debug)]
pub struct VolumeUnit {
    elements: HashSet<EntityRef>,
}
impl IDerivedUnit for VolumeUnit {
    fn elements(&self) -> &HashSet<EntityRef> {
        &self.elements
    }
}
impl IVolumeUnit for VolumeUnit {}
impl VolumeUnit {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = VolumeUnit::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.elements = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IXorExpression: IBinaryBooleanExpression {
    fn operands(&self) -> &Vec<EntityRef>;
}
#[derive(Default, Debug)]
pub struct XorExpression {
    operands: Vec<EntityRef>,
}
impl IGenericExpression for XorExpression {}
impl IExpression for XorExpression {}
impl IBooleanExpression for XorExpression {}
impl IBinaryBooleanExpression for XorExpression {}
impl IBinaryGenericExpression for XorExpression {
    fn operands(&self) -> &Vec<EntityRef> {
        &self.operands
    }
}
impl IXorExpression for XorExpression {
    fn operands(&self) -> &Vec<EntityRef> {
        &self.operands
    }
}
impl XorExpression {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = XorExpression::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.operands = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
use std::any::{Any, TypeId};
use std::collections::{BTreeMap, HashMap};
pub struct Ap214Reader {
    pub entities: BTreeMap<i64, Box<dyn Any>>,
    pub type_ids: HashMap<TypeId, Vec<i64>>,
    pub type_names: HashMap<TypeId, &'static str>,
    empty: Vec<i64>,
}

impl Ap214Reader {
    pub fn new() -> Self {
        Ap214Reader {
            entities: BTreeMap::new(),
            type_ids: HashMap::new(),
            type_names: HashMap::new(),
            empty: Vec::new(),
        }
    }
    pub fn add_entity<T: Any>(&mut self, id: i64, entity: T) {
        let type_id = entity.type_id();
        self.entities.insert(id, Box::new(entity));
        self.type_ids.entry(type_id).or_insert(vec![]).push(id);
        self.type_names.entry(type_id).or_insert(std::any::type_name::<T>());
    }
    pub fn get_entity<T: Any>(&self, entity_ref: &EntityRef) -> Option<&T> {
        self.entities
            .get(&entity_ref.0)
            .map(|entity| entity.downcast_ref::<T>())
            .flatten()
    }
    pub fn get_entities<T: Any>(&self) -> impl Iterator<Item = &T> {
        let type_id = TypeId::of::<T>();
        self.type_ids
            .get(&type_id)
            .unwrap_or(&self.empty)
            .iter()
            .map(move |id| self.entities[id].downcast_ref::<T>().unwrap())
    }
    pub fn get_type_name(&self, id: i64) -> &'static str {
        let type_id = (*self.entities[&id]).type_id();
        self.type_names[&type_id]
    }
}
impl StepReader for Ap214Reader {
    fn read_simple_entity(&mut self, id: i64, typed_parameter: TypedParameter) {
        match typed_parameter.type_name.as_str() {
            "ABS_FUNCTION" => {
                let entity = AbsFunction::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "ACOS_FUNCTION" => {
                let entity = AcosFunction::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "ACTION" => {
                let entity = Action::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "ACTION_DIRECTIVE" => {
                let entity = ActionDirective::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "ACTION_METHOD" => {
                let entity = ActionMethod::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "ACTION_METHOD_RELATIONSHIP" => {
                let entity = ActionMethodRelationship::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "ACTION_PROPERTY" => {
                let entity = ActionProperty::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "ACTION_PROPERTY_REPRESENTATION" => {
                let entity = ActionPropertyRepresentation::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "ACTION_RELATIONSHIP" => {
                let entity = ActionRelationship::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "ACTION_REQUEST_SOLUTION" => {
                let entity = ActionRequestSolution::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "ACTION_REQUEST_STATUS" => {
                let entity = ActionRequestStatus::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "ACTION_RESOURCE" => {
                let entity = ActionResource::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "ACTION_RESOURCE_REQUIREMENT" => {
                let entity = ActionResourceRequirement::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "ACTION_RESOURCE_TYPE" => {
                let entity = ActionResourceType::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "ACTION_STATUS" => {
                let entity = ActionStatus::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "ADDRESS" => {
                let entity = Address::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "ADVANCED_BREP_SHAPE_REPRESENTATION" => {
                let entity = AdvancedBrepShapeRepresentation::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "ADVANCED_FACE" => {
                let entity = AdvancedFace::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "ALTERNATE_PRODUCT_RELATIONSHIP" => {
                let entity = AlternateProductRelationship::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "AMOUNT_OF_SUBSTANCE_MEASURE_WITH_UNIT" => {
                let entity = AmountOfSubstanceMeasureWithUnit::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "AMOUNT_OF_SUBSTANCE_UNIT" => {
                let entity = AmountOfSubstanceUnit::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "AND_EXPRESSION" => {
                let entity = AndExpression::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "ANGULAR_DIMENSION" => {
                let entity = AngularDimension::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "ANGULAR_LOCATION" => {
                let entity = AngularLocation::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "ANGULAR_SIZE" => {
                let entity = AngularSize::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "ANGULARITY_TOLERANCE" => {
                let entity = AngularityTolerance::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "ANNOTATION_CURVE_OCCURRENCE" => {
                let entity = AnnotationCurveOccurrence::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "ANNOTATION_FILL_AREA" => {
                let entity = AnnotationFillArea::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "ANNOTATION_FILL_AREA_OCCURRENCE" => {
                let entity = AnnotationFillAreaOccurrence::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "ANNOTATION_OCCURRENCE" => {
                let entity = AnnotationOccurrence::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "ANNOTATION_OCCURRENCE_ASSOCIATIVITY" => {
                let entity = AnnotationOccurrenceAssociativity::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "ANNOTATION_OCCURRENCE_RELATIONSHIP" => {
                let entity = AnnotationOccurrenceRelationship::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "ANNOTATION_PLANE" => {
                let entity = AnnotationPlane::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "ANNOTATION_SUBFIGURE_OCCURRENCE" => {
                let entity = AnnotationSubfigureOccurrence::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "ANNOTATION_SYMBOL" => {
                let entity = AnnotationSymbol::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "ANNOTATION_SYMBOL_OCCURRENCE" => {
                let entity = AnnotationSymbolOccurrence::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "ANNOTATION_TEXT" => {
                let entity = AnnotationText::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "ANNOTATION_TEXT_CHARACTER" => {
                let entity = AnnotationTextCharacter::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "ANNOTATION_TEXT_OCCURRENCE" => {
                let entity = AnnotationTextOccurrence::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "APEX" => {
                let entity = Apex::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "APPLICATION_CONTEXT" => {
                let entity = ApplicationContext::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "APPLICATION_CONTEXT_ELEMENT" => {
                let entity = ApplicationContextElement::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "APPLICATION_CONTEXT_RELATIONSHIP" => {
                let entity = ApplicationContextRelationship::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "APPLICATION_PROTOCOL_DEFINITION" => {
                let entity = ApplicationProtocolDefinition::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "APPLIED_ACTION_ASSIGNMENT" => {
                let entity = AppliedActionAssignment::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "APPLIED_ACTION_REQUEST_ASSIGNMENT" => {
                let entity = AppliedActionRequestAssignment::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "APPLIED_APPROVAL_ASSIGNMENT" => {
                let entity = AppliedApprovalAssignment::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "APPLIED_AREA" => {
                let entity = AppliedArea::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "APPLIED_CERTIFICATION_ASSIGNMENT" => {
                let entity = AppliedCertificationAssignment::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "APPLIED_CLASSIFICATION_ASSIGNMENT" => {
                let entity = AppliedClassificationAssignment::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "APPLIED_CONTRACT_ASSIGNMENT" => {
                let entity = AppliedContractAssignment::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "APPLIED_DATE_AND_TIME_ASSIGNMENT" => {
                let entity = AppliedDateAndTimeAssignment::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "APPLIED_DATE_ASSIGNMENT" => {
                let entity = AppliedDateAssignment::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "APPLIED_DOCUMENT_REFERENCE" => {
                let entity = AppliedDocumentReference::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "APPLIED_DOCUMENT_USAGE_CONSTRAINT_ASSIGNMENT" => {
                let entity = AppliedDocumentUsageConstraintAssignment::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "APPLIED_EFFECTIVITY_ASSIGNMENT" => {
                let entity = AppliedEffectivityAssignment::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "APPLIED_EVENT_OCCURRENCE_ASSIGNMENT" => {
                let entity = AppliedEventOccurrenceAssignment::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "APPLIED_EXTERNAL_IDENTIFICATION_ASSIGNMENT" => {
                let entity = AppliedExternalIdentificationAssignment::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "APPLIED_GROUP_ASSIGNMENT" => {
                let entity = AppliedGroupAssignment::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "APPLIED_IDENTIFICATION_ASSIGNMENT" => {
                let entity = AppliedIdentificationAssignment::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "APPLIED_INEFFECTIVITY_ASSIGNMENT" => {
                let entity = AppliedIneffectivityAssignment::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "APPLIED_NAME_ASSIGNMENT" => {
                let entity = AppliedNameAssignment::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "APPLIED_ORGANIZATION_ASSIGNMENT" => {
                let entity = AppliedOrganizationAssignment::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "APPLIED_ORGANIZATIONAL_PROJECT_ASSIGNMENT" => {
                let entity = AppliedOrganizationalProjectAssignment::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "APPLIED_PERSON_AND_ORGANIZATION_ASSIGNMENT" => {
                let entity = AppliedPersonAndOrganizationAssignment::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "APPLIED_PRESENTED_ITEM" => {
                let entity = AppliedPresentedItem::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "APPLIED_SECURITY_CLASSIFICATION_ASSIGNMENT" => {
                let entity = AppliedSecurityClassificationAssignment::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "APPLIED_TIME_INTERVAL_ASSIGNMENT" => {
                let entity = AppliedTimeIntervalAssignment::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "APPROVAL" => {
                let entity = Approval::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "APPROVAL_DATE_TIME" => {
                let entity = ApprovalDateTime::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "APPROVAL_PERSON_ORGANIZATION" => {
                let entity = ApprovalPersonOrganization::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "APPROVAL_RELATIONSHIP" => {
                let entity = ApprovalRelationship::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "APPROVAL_ROLE" => {
                let entity = ApprovalRole::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "APPROVAL_STATUS" => {
                let entity = ApprovalStatus::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "APPROXIMATION_TOLERANCE" => {
                let entity = ApproximationTolerance::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "APPROXIMATION_TOLERANCE_DEVIATION" => {
                let entity = ApproximationToleranceDeviation::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "APPROXIMATION_TOLERANCE_PARAMETER" => {
                let entity = ApproximationToleranceParameter::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "AREA_IN_SET" => {
                let entity = AreaInSet::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "AREA_MEASURE_WITH_UNIT" => {
                let entity = AreaMeasureWithUnit::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "AREA_UNIT" => {
                let entity = AreaUnit::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "ASIN_FUNCTION" => {
                let entity = AsinFunction::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "ASSEMBLY_COMPONENT_USAGE" => {
                let entity = AssemblyComponentUsage::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "ASSEMBLY_COMPONENT_USAGE_SUBSTITUTE" => {
                let entity = AssemblyComponentUsageSubstitute::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "ATAN_FUNCTION" => {
                let entity = AtanFunction::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "ATTRIBUTE_LANGUAGE_ASSIGNMENT" => {
                let entity = AttributeLanguageAssignment::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "ATTRIBUTE_VALUE_ROLE" => {
                let entity = AttributeValueRole::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "AXIS1_PLACEMENT" => {
                let entity = Axis1Placement::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "AXIS2_PLACEMENT_2D" => {
                let entity = Axis2Placement2d::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "AXIS2_PLACEMENT_3D" => {
                let entity = Axis2Placement3d::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "B_SPLINE_CURVE" => {
                let entity = BSplineCurve::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "B_SPLINE_CURVE_WITH_KNOTS" => {
                let entity = BSplineCurveWithKnots::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "B_SPLINE_SURFACE" => {
                let entity = BSplineSurface::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "B_SPLINE_SURFACE_WITH_KNOTS" => {
                let entity = BSplineSurfaceWithKnots::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "BACKGROUND_COLOUR" => {
                let entity = BackgroundColour::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "BARRING_HOLE" => {
                let entity = BarringHole::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "BEAD" => {
                let entity = Bead::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "BEAD_END" => {
                let entity = BeadEnd::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "BEZIER_CURVE" => {
                let entity = BezierCurve::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "BEZIER_SURFACE" => {
                let entity = BezierSurface::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "BLOCK" => {
                let entity = Block::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "BOOLEAN_LITERAL" => {
                let entity = BooleanLiteral::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "BOOLEAN_RESULT" => {
                let entity = BooleanResult::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "BOOLEAN_VARIABLE" => {
                let entity = BooleanVariable::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "BOSS" => {
                let entity = Boss::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "BOSS_TOP" => {
                let entity = BossTop::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "BOUNDARY_CURVE" => {
                let entity = BoundaryCurve::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "BOUNDED_CURVE" => {
                let entity = BoundedCurve::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "BOUNDED_PCURVE" => {
                let entity = BoundedPcurve::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "BOUNDED_SURFACE" => {
                let entity = BoundedSurface::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "BOUNDED_SURFACE_CURVE" => {
                let entity = BoundedSurfaceCurve::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "BOX_DOMAIN" => {
                let entity = BoxDomain::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "BOXED_HALF_SPACE" => {
                let entity = BoxedHalfSpace::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "BREP_WITH_VOIDS" => {
                let entity = BrepWithVoids::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "CALENDAR_DATE" => {
                let entity = CalendarDate::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "CAMERA_IMAGE" => {
                let entity = CameraImage::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "CAMERA_IMAGE_2D_WITH_SCALE" => {
                let entity = CameraImage2dWithScale::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "CAMERA_IMAGE_3D_WITH_SCALE" => {
                let entity = CameraImage3dWithScale::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "CAMERA_MODEL_D2" => {
                let entity = CameraModelD2::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "CAMERA_MODEL_D3" => {
                let entity = CameraModelD3::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "CAMERA_MODEL_D3_WITH_HLHSR" => {
                let entity = CameraModelD3WithHlhsr::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "CAMERA_USAGE" => {
                let entity = CameraUsage::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "CARTESIAN_POINT" => {
                let entity = CartesianPoint::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "CARTESIAN_TRANSFORMATION_OPERATOR" => {
                let entity = CartesianTransformationOperator::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "CARTESIAN_TRANSFORMATION_OPERATOR_2D" => {
                let entity = CartesianTransformationOperator2d::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "CARTESIAN_TRANSFORMATION_OPERATOR_3D" => {
                let entity = CartesianTransformationOperator3d::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "CELSIUS_TEMPERATURE_MEASURE_WITH_UNIT" => {
                let entity = CelsiusTemperatureMeasureWithUnit::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "CENTRE_OF_SYMMETRY" => {
                let entity = CentreOfSymmetry::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "CERTIFICATION" => {
                let entity = Certification::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "CERTIFICATION_TYPE" => {
                let entity = CertificationType::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "CHAMFER" => {
                let entity = Chamfer::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "CHAMFER_OFFSET" => {
                let entity = ChamferOffset::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "CHARACTER_GLYPH_SYMBOL" => {
                let entity = CharacterGlyphSymbol::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "CHARACTERIZED_CLASS" => {
                let entity = CharacterizedClass::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "CHARACTERIZED_OBJECT" => {
                let entity = CharacterizedObject::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "CIRCLE" => {
                let entity = Circle::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "CIRCULAR_CLOSED_PROFILE" => {
                let entity = CircularClosedProfile::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "CIRCULAR_PATTERN" => {
                let entity = CircularPattern::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "CIRCULAR_RUNOUT_TOLERANCE" => {
                let entity = CircularRunoutTolerance::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "CLASS" => {
                let entity = Class::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "CLASS_SYSTEM" => {
                let entity = ClassSystem::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "CLASS_USAGE_EFFECTIVITY_CONTEXT_ASSIGNMENT" => {
                let entity = ClassUsageEffectivityContextAssignment::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "CLASSIFICATION_ROLE" => {
                let entity = ClassificationRole::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "CLOSED_PATH_PROFILE" => {
                let entity = ClosedPathProfile::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "CLOSED_SHELL" => {
                let entity = ClosedShell::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "COAXIALITY_TOLERANCE" => {
                let entity = CoaxialityTolerance::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "COLOUR" => {
                let entity = Colour::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "COLOUR_RGB" => {
                let entity = ColourRgb::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "COLOUR_SPECIFICATION" => {
                let entity = ColourSpecification::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "COMMON_DATUM" => {
                let entity = CommonDatum::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "COMPARISON_EQUAL" => {
                let entity = ComparisonEqual::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "COMPARISON_GREATER" => {
                let entity = ComparisonGreater::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "COMPARISON_GREATER_EQUAL" => {
                let entity = ComparisonGreaterEqual::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "COMPARISON_LESS" => {
                let entity = ComparisonLess::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "COMPARISON_LESS_EQUAL" => {
                let entity = ComparisonLessEqual::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "COMPARISON_NOT_EQUAL" => {
                let entity = ComparisonNotEqual::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "COMPOSITE_CURVE" => {
                let entity = CompositeCurve::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "COMPOSITE_CURVE_ON_SURFACE" => {
                let entity = CompositeCurveOnSurface::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "COMPOSITE_CURVE_SEGMENT" => {
                let entity = CompositeCurveSegment::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "COMPOSITE_HOLE" => {
                let entity = CompositeHole::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "COMPOSITE_SHAPE_ASPECT" => {
                let entity = CompositeShapeAspect::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "COMPOSITE_TEXT" => {
                let entity = CompositeText::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "COMPOSITE_TEXT_WITH_ASSOCIATED_CURVES" => {
                let entity = CompositeTextWithAssociatedCurves::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "COMPOSITE_TEXT_WITH_BLANKING_BOX" => {
                let entity = CompositeTextWithBlankingBox::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "COMPOSITE_TEXT_WITH_EXTENT" => {
                let entity = CompositeTextWithExtent::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "COMPOUND_FEATURE" => {
                let entity = CompoundFeature::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "COMPOUND_REPRESENTATION_ITEM" => {
                let entity = CompoundRepresentationItem::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "COMPOUND_SHAPE_REPRESENTATION" => {
                let entity = CompoundShapeRepresentation::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "CONCAT_EXPRESSION" => {
                let entity = ConcatExpression::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "CONCENTRICITY_TOLERANCE" => {
                let entity = ConcentricityTolerance::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "CONCEPT_FEATURE_OPERATOR" => {
                let entity = ConceptFeatureOperator::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "CONCEPT_FEATURE_RELATIONSHIP" => {
                let entity = ConceptFeatureRelationship::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "CONCEPT_FEATURE_RELATIONSHIP_WITH_CONDITION" => {
                let entity = ConceptFeatureRelationshipWithCondition::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "CONDITIONAL_CONCEPT_FEATURE" => {
                let entity = ConditionalConceptFeature::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "CONFIGURABLE_ITEM" => {
                let entity = ConfigurableItem::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "CONFIGURATION_DEFINITION" => {
                let entity = ConfigurationDefinition::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "CONFIGURATION_DESIGN" => {
                let entity = ConfigurationDesign::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "CONFIGURATION_EFFECTIVITY" => {
                let entity = ConfigurationEffectivity::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "CONFIGURATION_INTERPOLATION" => {
                let entity = ConfigurationInterpolation::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "CONFIGURATION_ITEM" => {
                let entity = ConfigurationItem::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "CONFIGURED_EFFECTIVITY_ASSIGNMENT" => {
                let entity = ConfiguredEffectivityAssignment::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "CONFIGURED_EFFECTIVITY_CONTEXT_ASSIGNMENT" => {
                let entity = ConfiguredEffectivityContextAssignment::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "CONIC" => {
                let entity = Conic::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "CONICAL_SURFACE" => {
                let entity = ConicalSurface::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "CONNECTED_EDGE_SET" => {
                let entity = ConnectedEdgeSet::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "CONNECTED_FACE_SET" => {
                let entity = ConnectedFaceSet::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "CONNECTED_FACE_SUB_SET" => {
                let entity = ConnectedFaceSubSet::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "CONSTRUCTIVE_GEOMETRY_REPRESENTATION" => {
                let entity = ConstructiveGeometryRepresentation::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "CONSTRUCTIVE_GEOMETRY_REPRESENTATION_RELATIONSHIP" => {
                let entity =
                    ConstructiveGeometryRepresentationRelationship::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "CONTACT_RATIO_REPRESENTATION" => {
                let entity = ContactRatioRepresentation::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "CONTEXT_DEPENDENT_INVISIBILITY" => {
                let entity = ContextDependentInvisibility::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "CONTEXT_DEPENDENT_OVER_RIDING_STYLED_ITEM" => {
                let entity = ContextDependentOverRidingStyledItem::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "CONTEXT_DEPENDENT_SHAPE_REPRESENTATION" => {
                let entity = ContextDependentShapeRepresentation::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "CONTEXT_DEPENDENT_UNIT" => {
                let entity = ContextDependentUnit::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "CONTRACT" => {
                let entity = Contract::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "CONTRACT_TYPE" => {
                let entity = ContractType::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "CONVERSION_BASED_UNIT" => {
                let entity = ConversionBasedUnit::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "COORDINATED_UNIVERSAL_TIME_OFFSET" => {
                let entity = CoordinatedUniversalTimeOffset::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "COS_FUNCTION" => {
                let entity = CosFunction::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "CSG_SHAPE_REPRESENTATION" => {
                let entity = CsgShapeRepresentation::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "CSG_SOLID" => {
                let entity = CsgSolid::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "CURVE" => {
                let entity = Curve::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "CURVE_BOUNDED_SURFACE" => {
                let entity = CurveBoundedSurface::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "CURVE_DIMENSION" => {
                let entity = CurveDimension::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "CURVE_REPLICA" => {
                let entity = CurveReplica::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "CURVE_STYLE" => {
                let entity = CurveStyle::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "CURVE_STYLE_FONT" => {
                let entity = CurveStyleFont::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "CURVE_STYLE_FONT_PATTERN" => {
                let entity = CurveStyleFontPattern::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "CURVE_STYLE_RENDERING" => {
                let entity = CurveStyleRendering::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "CURVE_SWEPT_SOLID_SHAPE_REPRESENTATION" => {
                let entity = CurveSweptSolidShapeRepresentation::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "CYLINDRICAL_PAIR" => {
                let entity = CylindricalPair::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "CYLINDRICAL_PAIR_RANGE" => {
                let entity = CylindricalPairRange::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "CYLINDRICAL_PAIR_VALUE" => {
                let entity = CylindricalPairValue::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "CYLINDRICAL_SURFACE" => {
                let entity = CylindricalSurface::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "CYLINDRICITY_TOLERANCE" => {
                let entity = CylindricityTolerance::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "DATA_ENVIRONMENT" => {
                let entity = DataEnvironment::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "DATE" => {
                let entity = Date::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "DATE_AND_TIME" => {
                let entity = DateAndTime::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "DATE_ROLE" => {
                let entity = DateRole::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "DATE_TIME_ROLE" => {
                let entity = DateTimeRole::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "DATED_EFFECTIVITY" => {
                let entity = DatedEffectivity::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "DATUM" => {
                let entity = Datum::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "DATUM_FEATURE" => {
                let entity = DatumFeature::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "DATUM_FEATURE_CALLOUT" => {
                let entity = DatumFeatureCallout::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "DATUM_REFERENCE" => {
                let entity = DatumReference::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "DATUM_TARGET" => {
                let entity = DatumTarget::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "DATUM_TARGET_CALLOUT" => {
                let entity = DatumTargetCallout::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "DEFAULT_TOLERANCE_TABLE" => {
                let entity = DefaultToleranceTable::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "DEFAULT_TOLERANCE_TABLE_CELL" => {
                let entity = DefaultToleranceTableCell::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "DEFINED_CHARACTER_GLYPH" => {
                let entity = DefinedCharacterGlyph::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "DEFINED_SYMBOL" => {
                let entity = DefinedSymbol::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "DEFINITIONAL_REPRESENTATION" => {
                let entity = DefinitionalRepresentation::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "DEGENERATE_PCURVE" => {
                let entity = DegeneratePcurve::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "DEGENERATE_TOROIDAL_SURFACE" => {
                let entity = DegenerateToroidalSurface::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "DERIVED_SHAPE_ASPECT" => {
                let entity = DerivedShapeAspect::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "DERIVED_UNIT" => {
                let entity = DerivedUnit::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "DERIVED_UNIT_ELEMENT" => {
                let entity = DerivedUnitElement::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "DERIVED_UNIT_VARIABLE" => {
                let entity = DerivedUnitVariable::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "DESCRIPTION_ATTRIBUTE" => {
                let entity = DescriptionAttribute::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "DESCRIPTIVE_REPRESENTATION_ITEM" => {
                let entity = DescriptiveRepresentationItem::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "DIAMETER_DIMENSION" => {
                let entity = DiameterDimension::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "DIMENSION_CALLOUT" => {
                let entity = DimensionCallout::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "DIMENSION_CALLOUT_COMPONENT_RELATIONSHIP" => {
                let entity = DimensionCalloutComponentRelationship::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "DIMENSION_CALLOUT_RELATIONSHIP" => {
                let entity = DimensionCalloutRelationship::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "DIMENSION_CURVE" => {
                let entity = DimensionCurve::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "DIMENSION_CURVE_DIRECTED_CALLOUT" => {
                let entity = DimensionCurveDirectedCallout::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "DIMENSION_CURVE_TERMINATOR" => {
                let entity = DimensionCurveTerminator::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "DIMENSION_PAIR" => {
                let entity = DimensionPair::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "DIMENSION_RELATED_TOLERANCE_ZONE_ELEMENT" => {
                let entity = DimensionRelatedToleranceZoneElement::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "DIMENSION_TEXT_ASSOCIATIVITY" => {
                let entity = DimensionTextAssociativity::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "DIMENSIONAL_CHARACTERISTIC_REPRESENTATION" => {
                let entity = DimensionalCharacteristicRepresentation::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "DIMENSIONAL_EXPONENTS" => {
                let entity = DimensionalExponents::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "DIMENSIONAL_LOCATION" => {
                let entity = DimensionalLocation::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "DIMENSIONAL_LOCATION_WITH_PATH" => {
                let entity = DimensionalLocationWithPath::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "DIMENSIONAL_SIZE" => {
                let entity = DimensionalSize::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "DIMENSIONAL_SIZE_WITH_PATH" => {
                let entity = DimensionalSizeWithPath::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "DIRECTED_ACTION" => {
                let entity = DirectedAction::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "DIRECTED_ANGLE" => {
                let entity = DirectedAngle::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "DIRECTED_DIMENSIONAL_LOCATION" => {
                let entity = DirectedDimensionalLocation::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "DIRECTION" => {
                let entity = Direction::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "DIRECTION_SHAPE_REPRESENTATION" => {
                let entity = DirectionShapeRepresentation::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "DIV_EXPRESSION" => {
                let entity = DivExpression::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "DOCUMENT" => {
                let entity = Document::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "DOCUMENT_FILE" => {
                let entity = DocumentFile::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "DOCUMENT_PRODUCT_ASSOCIATION" => {
                let entity = DocumentProductAssociation::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "DOCUMENT_PRODUCT_EQUIVALENCE" => {
                let entity = DocumentProductEquivalence::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "DOCUMENT_RELATIONSHIP" => {
                let entity = DocumentRelationship::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "DOCUMENT_REPRESENTATION_TYPE" => {
                let entity = DocumentRepresentationType::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "DOCUMENT_TYPE" => {
                let entity = DocumentType::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "DOCUMENT_USAGE_CONSTRAINT" => {
                let entity = DocumentUsageConstraint::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "DOCUMENT_USAGE_ROLE" => {
                let entity = DocumentUsageRole::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "DRAUGHTING_ANNOTATION_OCCURRENCE" => {
                let entity = DraughtingAnnotationOccurrence::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "DRAUGHTING_CALLOUT" => {
                let entity = DraughtingCallout::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "DRAUGHTING_CALLOUT_RELATIONSHIP" => {
                let entity = DraughtingCalloutRelationship::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "DRAUGHTING_ELEMENTS" => {
                let entity = DraughtingElements::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "DRAUGHTING_MODEL" => {
                let entity = DraughtingModel::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "DRAUGHTING_MODEL_ITEM_ASSOCIATION" => {
                let entity = DraughtingModelItemAssociation::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "DRAUGHTING_PRE_DEFINED_COLOUR" => {
                let entity = DraughtingPreDefinedColour::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "DRAUGHTING_PRE_DEFINED_CURVE_FONT" => {
                let entity = DraughtingPreDefinedCurveFont::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "DRAUGHTING_PRE_DEFINED_TEXT_FONT" => {
                let entity = DraughtingPreDefinedTextFont::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "DRAUGHTING_SPECIFICATION_REFERENCE" => {
                let entity = DraughtingSpecificationReference::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "DRAUGHTING_SUBFIGURE_REPRESENTATION" => {
                let entity = DraughtingSubfigureRepresentation::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "DRAUGHTING_SYMBOL_REPRESENTATION" => {
                let entity = DraughtingSymbolRepresentation::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "DRAUGHTING_TEXT_LITERAL_WITH_DELINEATION" => {
                let entity = DraughtingTextLiteralWithDelineation::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "DRAUGHTING_TITLE" => {
                let entity = DraughtingTitle::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "DRAWING_DEFINITION" => {
                let entity = DrawingDefinition::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "DRAWING_REVISION" => {
                let entity = DrawingRevision::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "DRAWING_REVISION_SEQUENCE" => {
                let entity = DrawingRevisionSequence::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "DRAWING_SHEET_LAYOUT" => {
                let entity = DrawingSheetLayout::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "DRAWING_SHEET_REVISION" => {
                let entity = DrawingSheetRevision::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "DRAWING_SHEET_REVISION_USAGE" => {
                let entity = DrawingSheetRevisionUsage::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "EDGE" => {
                let entity = Edge::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "EDGE_BASED_WIREFRAME_MODEL" => {
                let entity = EdgeBasedWireframeModel::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "EDGE_BASED_WIREFRAME_SHAPE_REPRESENTATION" => {
                let entity = EdgeBasedWireframeShapeRepresentation::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "EDGE_CURVE" => {
                let entity = EdgeCurve::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "EDGE_LOOP" => {
                let entity = EdgeLoop::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "EDGE_ROUND" => {
                let entity = EdgeRound::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "EFFECTIVITY" => {
                let entity = Effectivity::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "EFFECTIVITY_CONTEXT_ROLE" => {
                let entity = EffectivityContextRole::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "EFFECTIVITY_RELATIONSHIP" => {
                let entity = EffectivityRelationship::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "ELECTRIC_CURRENT_MEASURE_WITH_UNIT" => {
                let entity = ElectricCurrentMeasureWithUnit::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "ELECTRIC_CURRENT_UNIT" => {
                let entity = ElectricCurrentUnit::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "ELEMENT_DELIVERY" => {
                let entity = ElementDelivery::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "ELEMENTARY_SURFACE" => {
                let entity = ElementarySurface::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "ELLIPSE" => {
                let entity = Ellipse::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "ENVIRONMENT" => {
                let entity = Environment::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "EQUALS_EXPRESSION" => {
                let entity = EqualsExpression::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "EVALUATED_DEGENERATE_PCURVE" => {
                let entity = EvaluatedDegeneratePcurve::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "EVENT_OCCURRENCE" => {
                let entity = EventOccurrence::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "EVENT_OCCURRENCE_CONTEXT_ROLE" => {
                let entity = EventOccurrenceContextRole::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "EVENT_OCCURRENCE_ROLE" => {
                let entity = EventOccurrenceRole::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "EXCLUSIVE_PRODUCT_CONCEPT_FEATURE_CATEGORY" => {
                let entity = ExclusiveProductConceptFeatureCategory::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "EXECUTED_ACTION" => {
                let entity = ExecutedAction::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "EXP_FUNCTION" => {
                let entity = ExpFunction::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "EXPRESSION_CONVERSION_BASED_UNIT" => {
                let entity = ExpressionConversionBasedUnit::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "EXTENSION" => {
                let entity = Extension::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "EXTERNAL_SOURCE" => {
                let entity = ExternalSource::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "EXTERNALLY_DEFINED_CHARACTER_GLYPH" => {
                let entity = ExternallyDefinedCharacterGlyph::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "EXTERNALLY_DEFINED_CLASS" => {
                let entity = ExternallyDefinedClass::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "EXTERNALLY_DEFINED_CURVE_FONT" => {
                let entity = ExternallyDefinedCurveFont::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "EXTERNALLY_DEFINED_DIMENSION_DEFINITION" => {
                let entity = ExternallyDefinedDimensionDefinition::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "EXTERNALLY_DEFINED_FEATURE_DEFINITION" => {
                let entity = ExternallyDefinedFeatureDefinition::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "EXTERNALLY_DEFINED_GENERAL_PROPERTY" => {
                let entity = ExternallyDefinedGeneralProperty::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "EXTERNALLY_DEFINED_HATCH_STYLE" => {
                let entity = ExternallyDefinedHatchStyle::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "EXTERNALLY_DEFINED_ITEM" => {
                let entity = ExternallyDefinedItem::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "EXTERNALLY_DEFINED_ITEM_RELATIONSHIP" => {
                let entity = ExternallyDefinedItemRelationship::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "EXTERNALLY_DEFINED_STYLE" => {
                let entity = ExternallyDefinedStyle::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "EXTERNALLY_DEFINED_SYMBOL" => {
                let entity = ExternallyDefinedSymbol::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "EXTERNALLY_DEFINED_TEXT_FONT" => {
                let entity = ExternallyDefinedTextFont::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "EXTERNALLY_DEFINED_TILE_STYLE" => {
                let entity = ExternallyDefinedTileStyle::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "EXTRUDED_AREA_SOLID" => {
                let entity = ExtrudedAreaSolid::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "EXTRUDED_FACE_SOLID" => {
                let entity = ExtrudedFaceSolid::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "FACE" => {
                let entity = Face::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "FACE_BASED_SURFACE_MODEL" => {
                let entity = FaceBasedSurfaceModel::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "FACE_BOUND" => {
                let entity = FaceBound::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "FACE_OUTER_BOUND" => {
                let entity = FaceOuterBound::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "FACE_SHAPE_REPRESENTATION" => {
                let entity = FaceShapeRepresentation::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "FACE_SURFACE" => {
                let entity = FaceSurface::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "FACETED_BREP" => {
                let entity = FacetedBrep::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "FACETED_BREP_SHAPE_REPRESENTATION" => {
                let entity = FacetedBrepShapeRepresentation::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "FEATURE_COMPONENT_DEFINITION" => {
                let entity = FeatureComponentDefinition::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "FEATURE_COMPONENT_RELATIONSHIP" => {
                let entity = FeatureComponentRelationship::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "FEATURE_DEFINITION" => {
                let entity = FeatureDefinition::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "FEATURE_IN_PANEL" => {
                let entity = FeatureInPanel::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "FEATURE_PATTERN" => {
                let entity = FeaturePattern::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "FEATURED_SHAPE" => {
                let entity = FeaturedShape::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "FILL_AREA_STYLE" => {
                let entity = FillAreaStyle::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "FILL_AREA_STYLE_COLOUR" => {
                let entity = FillAreaStyleColour::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "FILL_AREA_STYLE_HATCHING" => {
                let entity = FillAreaStyleHatching::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "FILL_AREA_STYLE_TILE_SYMBOL_WITH_STYLE" => {
                let entity = FillAreaStyleTileSymbolWithStyle::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "FILL_AREA_STYLE_TILES" => {
                let entity = FillAreaStyleTiles::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "FILLET" => {
                let entity = Fillet::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "FLATNESS_TOLERANCE" => {
                let entity = FlatnessTolerance::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "FORMAT_FUNCTION" => {
                let entity = FormatFunction::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "FOUNDED_ITEM" => {
                let entity = FoundedItem::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "FOUNDED_KINEMATIC_PATH" => {
                let entity = FoundedKinematicPath::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "FULLY_CONSTRAINED_PAIR" => {
                let entity = FullyConstrainedPair::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "FUNCTIONALLY_DEFINED_TRANSFORMATION" => {
                let entity = FunctionallyDefinedTransformation::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "GEAR_PAIR" => {
                let entity = GearPair::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "GEAR_PAIR_RANGE" => {
                let entity = GearPairRange::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "GEAR_PAIR_VALUE" => {
                let entity = GearPairValue::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "GENERAL_FEATURE" => {
                let entity = GeneralFeature::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "GENERAL_MATERIAL_PROPERTY" => {
                let entity = GeneralMaterialProperty::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "GENERAL_PROPERTY" => {
                let entity = GeneralProperty::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "GENERAL_PROPERTY_ASSOCIATION" => {
                let entity = GeneralPropertyAssociation::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "GENERAL_PROPERTY_RELATIONSHIP" => {
                let entity = GeneralPropertyRelationship::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "GEOMETRIC_ALIGNMENT" => {
                let entity = GeometricAlignment::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "GEOMETRIC_CURVE_SET" => {
                let entity = GeometricCurveSet::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "GEOMETRIC_INTERSECTION" => {
                let entity = GeometricIntersection::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "GEOMETRIC_ITEM_SPECIFIC_USAGE" => {
                let entity = GeometricItemSpecificUsage::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "GEOMETRIC_REPRESENTATION_CONTEXT" => {
                let entity = GeometricRepresentationContext::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "GEOMETRIC_REPRESENTATION_ITEM" => {
                let entity = GeometricRepresentationItem::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "GEOMETRIC_SET" => {
                let entity = GeometricSet::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "GEOMETRIC_TOLERANCE" => {
                let entity = GeometricTolerance::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "GEOMETRIC_TOLERANCE_RELATIONSHIP" => {
                let entity = GeometricToleranceRelationship::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "GEOMETRIC_TOLERANCE_WITH_DATUM_REFERENCE" => {
                let entity = GeometricToleranceWithDatumReference::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "GEOMETRIC_TOLERANCE_WITH_DEFINED_UNIT" => {
                let entity = GeometricToleranceWithDefinedUnit::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "GEOMETRICAL_TOLERANCE_CALLOUT" => {
                let entity = GeometricalToleranceCallout::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "GEOMETRICALLY_BOUNDED_2D_WIREFRAME_REPRESENTATION" => {
                let entity = GeometricallyBounded2dWireframeRepresentation::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "GEOMETRICALLY_BOUNDED_SURFACE_SHAPE_REPRESENTATION" => {
                let entity =
                    GeometricallyBoundedSurfaceShapeRepresentation::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "GEOMETRICALLY_BOUNDED_WIREFRAME_SHAPE_REPRESENTATION" => {
                let entity =
                    GeometricallyBoundedWireframeShapeRepresentation::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "GLOBAL_UNCERTAINTY_ASSIGNED_CONTEXT" => {
                let entity = GlobalUncertaintyAssignedContext::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "GLOBAL_UNIT_ASSIGNED_CONTEXT" => {
                let entity = GlobalUnitAssignedContext::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "GROUP" => {
                let entity = Group::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "GROUP_RELATIONSHIP" => {
                let entity = GroupRelationship::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "HALF_SPACE_SOLID" => {
                let entity = HalfSpaceSolid::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "HARDNESS_REPRESENTATION" => {
                let entity = HardnessRepresentation::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "HIDDEN_ELEMENT_OVER_RIDING_STYLED_ITEM" => {
                let entity = HiddenElementOverRidingStyledItem::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "HOLE_BOTTOM" => {
                let entity = HoleBottom::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "HOLE_IN_PANEL" => {
                let entity = HoleInPanel::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "HOMOKINETIC_PAIR" => {
                let entity = HomokineticPair::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "HYPERBOLA" => {
                let entity = Hyperbola::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "ID_ATTRIBUTE" => {
                let entity = IdAttribute::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "IDENTIFICATION_ROLE" => {
                let entity = IdentificationRole::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "INCLUSION_PRODUCT_CONCEPT_FEATURE" => {
                let entity = InclusionProductConceptFeature::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "INDEX_EXPRESSION" => {
                let entity = IndexExpression::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "INITIAL_STATE" => {
                let entity = InitialState::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "INSTANCED_FEATURE" => {
                let entity = InstancedFeature::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "INT_LITERAL" => {
                let entity = IntLiteral::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "INT_NUMERIC_VARIABLE" => {
                let entity = IntNumericVariable::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "INT_VALUE_FUNCTION" => {
                let entity = IntValueFunction::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "INTERPOLATED_CONFIGURATION_SEQUENCE" => {
                let entity = InterpolatedConfigurationSequence::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "INTERSECTION_CURVE" => {
                let entity = IntersectionCurve::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "INTERVAL_EXPRESSION" => {
                let entity = IntervalExpression::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "INVISIBILITY" => {
                let entity = Invisibility::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "ITEM_DEFINED_TRANSFORMATION" => {
                let entity = ItemDefinedTransformation::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "ITEM_IDENTIFIED_REPRESENTATION_USAGE" => {
                let entity = ItemIdentifiedRepresentationUsage::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "JOGGLE" => {
                let entity = Joggle::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "JOGGLE_TERMINATION" => {
                let entity = JoggleTermination::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "KINEMATIC_ANALYSIS_CONSISTENCY" => {
                let entity = KinematicAnalysisConsistency::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "KINEMATIC_ANALYSIS_RESULT" => {
                let entity = KinematicAnalysisResult::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "KINEMATIC_CONTROL" => {
                let entity = KinematicControl::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "KINEMATIC_FRAME_BACKGROUND_REPRESENTATION" => {
                let entity = KinematicFrameBackgroundRepresentation::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "KINEMATIC_FRAME_BACKGROUND_REPRESENTATION_ASSOCIATION" => {
                let entity =
                    KinematicFrameBackgroundRepresentationAssociation::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "KINEMATIC_FRAME_BASED_TRANSFORMATION" => {
                let entity = KinematicFrameBasedTransformation::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "KINEMATIC_GROUND_REPRESENTATION" => {
                let entity = KinematicGroundRepresentation::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "KINEMATIC_JOINT" => {
                let entity = KinematicJoint::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "KINEMATIC_LINK" => {
                let entity = KinematicLink::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "KINEMATIC_LINK_REPRESENTATION" => {
                let entity = KinematicLinkRepresentation::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "KINEMATIC_LINK_REPRESENTATION_ASSOCIATION" => {
                let entity = KinematicLinkRepresentationAssociation::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "KINEMATIC_LINK_REPRESENTATION_RELATION" => {
                let entity = KinematicLinkRepresentationRelation::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "KINEMATIC_PAIR" => {
                let entity = KinematicPair::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "KINEMATIC_PATH" => {
                let entity = KinematicPath::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "KINEMATIC_PROPERTY_DEFINITION" => {
                let entity = KinematicPropertyDefinition::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "KINEMATIC_PROPERTY_REPRESENTATION_RELATION" => {
                let entity = KinematicPropertyRepresentationRelation::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "KINEMATIC_STRUCTURE" => {
                let entity = KinematicStructure::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "KNOWN_SOURCE" => {
                let entity = KnownSource::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "LANGUAGE" => {
                let entity = Language::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "LANGUAGE_ASSIGNMENT" => {
                let entity = LanguageAssignment::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "LEADER_CURVE" => {
                let entity = LeaderCurve::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "LEADER_DIRECTED_CALLOUT" => {
                let entity = LeaderDirectedCallout::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "LEADER_DIRECTED_DIMENSION" => {
                let entity = LeaderDirectedDimension::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "LEADER_TERMINATOR" => {
                let entity = LeaderTerminator::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "LENGTH_FUNCTION" => {
                let entity = LengthFunction::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "LENGTH_MEASURE_WITH_UNIT" => {
                let entity = LengthMeasureWithUnit::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "LENGTH_UNIT" => {
                let entity = LengthUnit::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "LIGHT_SOURCE" => {
                let entity = LightSource::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "LIGHT_SOURCE_AMBIENT" => {
                let entity = LightSourceAmbient::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "LIGHT_SOURCE_DIRECTIONAL" => {
                let entity = LightSourceDirectional::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "LIGHT_SOURCE_POSITIONAL" => {
                let entity = LightSourcePositional::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "LIGHT_SOURCE_SPOT" => {
                let entity = LightSourceSpot::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "LIKE_EXPRESSION" => {
                let entity = LikeExpression::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "LIMITS_AND_FITS" => {
                let entity = LimitsAndFits::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "LINE" => {
                let entity = Line::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "LINE_PROFILE_TOLERANCE" => {
                let entity = LineProfileTolerance::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "LINEAR_DIMENSION" => {
                let entity = LinearDimension::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "LOCAL_TIME" => {
                let entity = LocalTime::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "LOCATION_SHAPE_REPRESENTATION" => {
                let entity = LocationShapeRepresentation::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "LOCATOR" => {
                let entity = Locator::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "LOG10_FUNCTION" => {
                let entity = Log10Function::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "LOG2_FUNCTION" => {
                let entity = Log2Function::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "LOG_FUNCTION" => {
                let entity = LogFunction::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "LOOP" => {
                let entity = Loop::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "LOT_EFFECTIVITY" => {
                let entity = LotEffectivity::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "LUMINOUS_INTENSITY_MEASURE_WITH_UNIT" => {
                let entity = LuminousIntensityMeasureWithUnit::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "LUMINOUS_INTENSITY_UNIT" => {
                let entity = LuminousIntensityUnit::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "MAKE_FROM_USAGE_OPTION" => {
                let entity = MakeFromUsageOption::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "MANIFOLD_SOLID_BREP" => {
                let entity = ManifoldSolidBrep::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "MANIFOLD_SUBSURFACE_SHAPE_REPRESENTATION" => {
                let entity = ManifoldSubsurfaceShapeRepresentation::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "MANIFOLD_SURFACE_SHAPE_REPRESENTATION" => {
                let entity = ManifoldSurfaceShapeRepresentation::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "MAPPED_ITEM" => {
                let entity = MappedItem::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "MASS_MEASURE_WITH_UNIT" => {
                let entity = MassMeasureWithUnit::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "MASS_UNIT" => {
                let entity = MassUnit::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "MATERIAL_DESIGNATION" => {
                let entity = MaterialDesignation::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "MATERIAL_DESIGNATION_CHARACTERIZATION" => {
                let entity = MaterialDesignationCharacterization::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "MATERIAL_PROPERTY" => {
                let entity = MaterialProperty::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "MATERIAL_PROPERTY_REPRESENTATION" => {
                let entity = MaterialPropertyRepresentation::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "MAXIMUM_FUNCTION" => {
                let entity = MaximumFunction::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "MEASURE_QUALIFICATION" => {
                let entity = MeasureQualification::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "MEASURE_REPRESENTATION_ITEM" => {
                let entity = MeasureRepresentationItem::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "MEASURE_WITH_UNIT" => {
                let entity = MeasureWithUnit::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "MECHANICAL_DESIGN_GEOMETRIC_PRESENTATION_AREA" => {
                let entity = MechanicalDesignGeometricPresentationArea::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "MECHANICAL_DESIGN_GEOMETRIC_PRESENTATION_REPRESENTATION" => {
                let entity =
                    MechanicalDesignGeometricPresentationRepresentation::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "MECHANISM" => {
                let entity = Mechanism::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "MECHANISM_BASE_PLACEMENT" => {
                let entity = MechanismBasePlacement::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "MINIMUM_FUNCTION" => {
                let entity = MinimumFunction::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "MINUS_EXPRESSION" => {
                let entity = MinusExpression::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "MINUS_FUNCTION" => {
                let entity = MinusFunction::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "MOD_EXPRESSION" => {
                let entity = ModExpression::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "MODIFIED_GEOMETRIC_TOLERANCE" => {
                let entity = ModifiedGeometricTolerance::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "MODIFIED_PATTERN" => {
                let entity = ModifiedPattern::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "MOMENTS_OF_INERTIA_REPRESENTATION" => {
                let entity = MomentsOfInertiaRepresentation::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "MOTION_LINK_RELATIONSHIP" => {
                let entity = MotionLinkRelationship::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "MULT_EXPRESSION" => {
                let entity = MultExpression::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "MULTI_LANGUAGE_ATTRIBUTE_ASSIGNMENT" => {
                let entity = MultiLanguageAttributeAssignment::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "NAME_ATTRIBUTE" => {
                let entity = NameAttribute::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "NAMED_UNIT" => {
                let entity = NamedUnit::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "NAMED_UNIT_VARIABLE" => {
                let entity = NamedUnitVariable::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "NEXT_ASSEMBLY_USAGE_OCCURRENCE" => {
                let entity = NextAssemblyUsageOccurrence::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "NGON_CLOSED_PROFILE" => {
                let entity = NgonClosedProfile::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "NON_MANIFOLD_SURFACE_SHAPE_REPRESENTATION" => {
                let entity = NonManifoldSurfaceShapeRepresentation::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "NOT_EXPRESSION" => {
                let entity = NotExpression::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "NUMERIC_VARIABLE" => {
                let entity = NumericVariable::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "OBJECT_ROLE" => {
                let entity = ObjectRole::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "ODD_FUNCTION" => {
                let entity = OddFunction::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "OFFSET_CURVE_2D" => {
                let entity = OffsetCurve2d::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "OFFSET_CURVE_3D" => {
                let entity = OffsetCurve3d::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "OFFSET_SURFACE" => {
                let entity = OffsetSurface::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "ONE_DIRECTION_REPEAT_FACTOR" => {
                let entity = OneDirectionRepeatFactor::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "OPEN_PATH_PROFILE" => {
                let entity = OpenPathProfile::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "OPEN_SHELL" => {
                let entity = OpenShell::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "OR_EXPRESSION" => {
                let entity = OrExpression::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "ORDINATE_DIMENSION" => {
                let entity = OrdinateDimension::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "ORGANIZATION" => {
                let entity = Organization::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "ORGANIZATION_RELATIONSHIP" => {
                let entity = OrganizationRelationship::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "ORGANIZATION_ROLE" => {
                let entity = OrganizationRole::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "ORGANIZATIONAL_ADDRESS" => {
                let entity = OrganizationalAddress::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "ORGANIZATIONAL_PROJECT" => {
                let entity = OrganizationalProject::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "ORGANIZATIONAL_PROJECT_RELATIONSHIP" => {
                let entity = OrganizationalProjectRelationship::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "ORGANIZATIONAL_PROJECT_ROLE" => {
                let entity = OrganizationalProjectRole::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "ORIENTED_CLOSED_SHELL" => {
                let entity = OrientedClosedShell::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "ORIENTED_EDGE" => {
                let entity = OrientedEdge::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "ORIENTED_FACE" => {
                let entity = OrientedFace::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "ORIENTED_OPEN_SHELL" => {
                let entity = OrientedOpenShell::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "ORIENTED_PATH" => {
                let entity = OrientedPath::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "ORIENTED_SURFACE" => {
                let entity = OrientedSurface::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "OUTER_BOUNDARY_CURVE" => {
                let entity = OuterBoundaryCurve::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "OVER_RIDING_STYLED_ITEM" => {
                let entity = OverRidingStyledItem::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "PACKAGE_PRODUCT_CONCEPT_FEATURE" => {
                let entity = PackageProductConceptFeature::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "PAIR_ACTUATOR" => {
                let entity = PairActuator::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "PAIR_VALUE" => {
                let entity = PairValue::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "PARABOLA" => {
                let entity = Parabola::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "PARALLEL_OFFSET" => {
                let entity = ParallelOffset::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "PARALLELISM_TOLERANCE" => {
                let entity = ParallelismTolerance::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "PARAMETRIC_REPRESENTATION_CONTEXT" => {
                let entity = ParametricRepresentationContext::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "PARTIAL_CIRCULAR_PROFILE" => {
                let entity = PartialCircularProfile::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "PATH" => {
                let entity = Path::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "PATH_FEATURE_COMPONENT" => {
                let entity = PathFeatureComponent::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "PATH_SHAPE_REPRESENTATION" => {
                let entity = PathShapeRepresentation::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "PATTERN_OFFSET_MEMBERSHIP" => {
                let entity = PatternOffsetMembership::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "PATTERN_OMIT_MEMBERSHIP" => {
                let entity = PatternOmitMembership::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "PCURVE" => {
                let entity = Pcurve::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "PERPENDICULAR_TO" => {
                let entity = PerpendicularTo::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "PERPENDICULARITY_TOLERANCE" => {
                let entity = PerpendicularityTolerance::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "PERSON" => {
                let entity = Person::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "PERSON_AND_ORGANIZATION" => {
                let entity = PersonAndOrganization::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "PERSON_AND_ORGANIZATION_ADDRESS" => {
                let entity = PersonAndOrganizationAddress::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "PERSON_AND_ORGANIZATION_ROLE" => {
                let entity = PersonAndOrganizationRole::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "PERSONAL_ADDRESS" => {
                let entity = PersonalAddress::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "PHYSICALLY_MODELLED_PRODUCT_DEFINITION" => {
                let entity = PhysicallyModelledProductDefinition::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "PLACED_DATUM_TARGET_FEATURE" => {
                let entity = PlacedDatumTargetFeature::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "PLACED_FEATURE" => {
                let entity = PlacedFeature::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "PLACEMENT" => {
                let entity = Placement::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "PLANAR_BOX" => {
                let entity = PlanarBox::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "PLANAR_CURVE_PAIR" => {
                let entity = PlanarCurvePair::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "PLANAR_CURVE_PAIR_RANGE" => {
                let entity = PlanarCurvePairRange::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "PLANAR_EXTENT" => {
                let entity = PlanarExtent::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "PLANAR_PAIR" => {
                let entity = PlanarPair::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "PLANAR_PAIR_RANGE" => {
                let entity = PlanarPairRange::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "PLANAR_PAIR_VALUE" => {
                let entity = PlanarPairValue::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "PLANAR_SHAPE_REPRESENTATION" => {
                let entity = PlanarShapeRepresentation::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "PLANE" => {
                let entity = Plane::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "PLANE_ANGLE_MEASURE_WITH_UNIT" => {
                let entity = PlaneAngleMeasureWithUnit::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "PLANE_ANGLE_UNIT" => {
                let entity = PlaneAngleUnit::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "PLUS_EXPRESSION" => {
                let entity = PlusExpression::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "PLUS_MINUS_TOLERANCE" => {
                let entity = PlusMinusTolerance::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "POCKET" => {
                let entity = Pocket::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "POCKET_BOTTOM" => {
                let entity = PocketBottom::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "POINT" => {
                let entity = Point::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "POINT_ON_CURVE" => {
                let entity = PointOnCurve::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "POINT_ON_PLANAR_CURVE_PAIR" => {
                let entity = PointOnPlanarCurvePair::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "POINT_ON_PLANAR_CURVE_PAIR_RANGE" => {
                let entity = PointOnPlanarCurvePairRange::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "POINT_ON_PLANAR_CURVE_PAIR_VALUE" => {
                let entity = PointOnPlanarCurvePairValue::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "POINT_ON_SURFACE" => {
                let entity = PointOnSurface::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "POINT_ON_SURFACE_PAIR" => {
                let entity = PointOnSurfacePair::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "POINT_ON_SURFACE_PAIR_RANGE" => {
                let entity = PointOnSurfacePairRange::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "POINT_ON_SURFACE_PAIR_VALUE" => {
                let entity = PointOnSurfacePairValue::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "POINT_PLACEMENT_SHAPE_REPRESENTATION" => {
                let entity = PointPlacementShapeRepresentation::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "POINT_REPLICA" => {
                let entity = PointReplica::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "POINT_STYLE" => {
                let entity = PointStyle::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "POLY_LOOP" => {
                let entity = PolyLoop::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "POLYLINE" => {
                let entity = Polyline::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "POSITION_TOLERANCE" => {
                let entity = PositionTolerance::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "POWER_EXPRESSION" => {
                let entity = PowerExpression::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "PRE_DEFINED_COLOUR" => {
                let entity = PreDefinedColour::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "PRE_DEFINED_CURVE_FONT" => {
                let entity = PreDefinedCurveFont::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "PRE_DEFINED_DIMENSION_SYMBOL" => {
                let entity = PreDefinedDimensionSymbol::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "PRE_DEFINED_GEOMETRICAL_TOLERANCE_SYMBOL" => {
                let entity = PreDefinedGeometricalToleranceSymbol::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "PRE_DEFINED_ITEM" => {
                let entity = PreDefinedItem::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "PRE_DEFINED_MARKER" => {
                let entity = PreDefinedMarker::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "PRE_DEFINED_POINT_MARKER_SYMBOL" => {
                let entity = PreDefinedPointMarkerSymbol::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "PRE_DEFINED_PRESENTATION_STYLE" => {
                let entity = PreDefinedPresentationStyle::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "PRE_DEFINED_SURFACE_CONDITION_SYMBOL" => {
                let entity = PreDefinedSurfaceConditionSymbol::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "PRE_DEFINED_SYMBOL" => {
                let entity = PreDefinedSymbol::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "PRE_DEFINED_TERMINATOR_SYMBOL" => {
                let entity = PreDefinedTerminatorSymbol::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "PRE_DEFINED_TEXT_FONT" => {
                let entity = PreDefinedTextFont::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "PRECISION_QUALIFIER" => {
                let entity = PrecisionQualifier::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "PRESENTATION_AREA" => {
                let entity = PresentationArea::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "PRESENTATION_LAYER_ASSIGNMENT" => {
                let entity = PresentationLayerAssignment::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "PRESENTATION_REPRESENTATION" => {
                let entity = PresentationRepresentation::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "PRESENTATION_SET" => {
                let entity = PresentationSet::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "PRESENTATION_SIZE" => {
                let entity = PresentationSize::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "PRESENTATION_STYLE_ASSIGNMENT" => {
                let entity = PresentationStyleAssignment::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "PRESENTATION_STYLE_BY_CONTEXT" => {
                let entity = PresentationStyleByContext::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "PRESENTATION_VIEW" => {
                let entity = PresentationView::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "PRESENTED_ITEM_REPRESENTATION" => {
                let entity = PresentedItemRepresentation::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "PRISMATIC_PAIR" => {
                let entity = PrismaticPair::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "PRISMATIC_PAIR_RANGE" => {
                let entity = PrismaticPairRange::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "PRISMATIC_PAIR_VALUE" => {
                let entity = PrismaticPairValue::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "PROCESS_OPERATION" => {
                let entity = ProcessOperation::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "PROCESS_PLAN" => {
                let entity = ProcessPlan::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "PROCESS_PRODUCT_ASSOCIATION" => {
                let entity = ProcessProductAssociation::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "PROCESS_PROPERTY_ASSOCIATION" => {
                let entity = ProcessPropertyAssociation::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "PRODUCT" => {
                let entity = Product::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "PRODUCT_CATEGORY" => {
                let entity = ProductCategory::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "PRODUCT_CATEGORY_RELATIONSHIP" => {
                let entity = ProductCategoryRelationship::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "PRODUCT_CLASS" => {
                let entity = ProductClass::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "PRODUCT_CONCEPT" => {
                let entity = ProductConcept::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "PRODUCT_CONCEPT_CONTEXT" => {
                let entity = ProductConceptContext::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "PRODUCT_CONCEPT_FEATURE" => {
                let entity = ProductConceptFeature::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "PRODUCT_CONCEPT_FEATURE_ASSOCIATION" => {
                let entity = ProductConceptFeatureAssociation::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "PRODUCT_CONCEPT_FEATURE_CATEGORY" => {
                let entity = ProductConceptFeatureCategory::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "PRODUCT_CONCEPT_FEATURE_CATEGORY_USAGE" => {
                let entity = ProductConceptFeatureCategoryUsage::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "PRODUCT_CONCEPT_RELATIONSHIP" => {
                let entity = ProductConceptRelationship::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "PRODUCT_CONTEXT" => {
                let entity = ProductContext::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "PRODUCT_DEFINITION" => {
                let entity = ProductDefinition::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "PRODUCT_DEFINITION_CONTEXT" => {
                let entity = ProductDefinitionContext::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "PRODUCT_DEFINITION_CONTEXT_ASSOCIATION" => {
                let entity = ProductDefinitionContextAssociation::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "PRODUCT_DEFINITION_CONTEXT_ROLE" => {
                let entity = ProductDefinitionContextRole::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "PRODUCT_DEFINITION_EFFECTIVITY" => {
                let entity = ProductDefinitionEffectivity::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "PRODUCT_DEFINITION_FORMATION" => {
                let entity = ProductDefinitionFormation::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "PRODUCT_DEFINITION_FORMATION_RELATIONSHIP" => {
                let entity = ProductDefinitionFormationRelationship::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "PRODUCT_DEFINITION_FORMATION_WITH_SPECIFIED_SOURCE" => {
                let entity = ProductDefinitionFormationWithSpecifiedSource::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "PRODUCT_DEFINITION_OCCURRENCE_RELATIONSHIP" => {
                let entity = ProductDefinitionOccurrenceRelationship::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "PRODUCT_DEFINITION_PROCESS" => {
                let entity = ProductDefinitionProcess::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "PRODUCT_DEFINITION_RELATIONSHIP" => {
                let entity = ProductDefinitionRelationship::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "PRODUCT_DEFINITION_RESOURCE" => {
                let entity = ProductDefinitionResource::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "PRODUCT_DEFINITION_SHAPE" => {
                let entity = ProductDefinitionShape::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "PRODUCT_DEFINITION_SUBSTITUTE" => {
                let entity = ProductDefinitionSubstitute::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "PRODUCT_DEFINITION_USAGE" => {
                let entity = ProductDefinitionUsage::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "PRODUCT_DEFINITION_WITH_ASSOCIATED_DOCUMENTS" => {
                let entity = ProductDefinitionWithAssociatedDocuments::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "PRODUCT_IDENTIFICATION" => {
                let entity = ProductIdentification::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "PRODUCT_PROCESS_PLAN" => {
                let entity = ProductProcessPlan::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "PRODUCT_RELATED_PRODUCT_CATEGORY" => {
                let entity = ProductRelatedProductCategory::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "PRODUCT_SPECIFICATION" => {
                let entity = ProductSpecification::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "PROJECTED_ZONE_DEFINITION" => {
                let entity = ProjectedZoneDefinition::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "PROJECTION_CURVE" => {
                let entity = ProjectionCurve::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "PROJECTION_DIRECTED_CALLOUT" => {
                let entity = ProjectionDirectedCallout::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "PROMISSORY_USAGE_OCCURRENCE" => {
                let entity = PromissoryUsageOccurrence::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "PROPERTY_DEFINITION" => {
                let entity = PropertyDefinition::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "PROPERTY_DEFINITION_RELATIONSHIP" => {
                let entity = PropertyDefinitionRelationship::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "PROPERTY_DEFINITION_REPRESENTATION" => {
                let entity = PropertyDefinitionRepresentation::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "PROPERTY_PROCESS" => {
                let entity = PropertyProcess::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "QUALIFIED_REPRESENTATION_ITEM" => {
                let entity = QualifiedRepresentationItem::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "QUALITATIVE_UNCERTAINTY" => {
                let entity = QualitativeUncertainty::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "QUANTIFIED_ASSEMBLY_COMPONENT_USAGE" => {
                let entity = QuantifiedAssemblyComponentUsage::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "QUASI_UNIFORM_CURVE" => {
                let entity = QuasiUniformCurve::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "QUASI_UNIFORM_SURFACE" => {
                let entity = QuasiUniformSurface::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "RACK_AND_PINION_PAIR" => {
                let entity = RackAndPinionPair::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "RACK_AND_PINION_PAIR_RANGE" => {
                let entity = RackAndPinionPairRange::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "RACK_AND_PINION_PAIR_VALUE" => {
                let entity = RackAndPinionPairValue::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "RADIUS_DIMENSION" => {
                let entity = RadiusDimension::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "RATIO_MEASURE_WITH_UNIT" => {
                let entity = RatioMeasureWithUnit::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "RATIO_UNIT" => {
                let entity = RatioUnit::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "RATIONAL_B_SPLINE_CURVE" => {
                let entity = RationalBSplineCurve::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "RATIONAL_B_SPLINE_SURFACE" => {
                let entity = RationalBSplineSurface::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "REAL_LITERAL" => {
                let entity = RealLiteral::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "REAL_NUMERIC_VARIABLE" => {
                let entity = RealNumericVariable::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "RECTANGULAR_CLOSED_PROFILE" => {
                let entity = RectangularClosedProfile::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "RECTANGULAR_COMPOSITE_SURFACE" => {
                let entity = RectangularCompositeSurface::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "RECTANGULAR_PATTERN" => {
                let entity = RectangularPattern::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "RECTANGULAR_TRIMMED_SURFACE" => {
                let entity = RectangularTrimmedSurface::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "REFERENCED_MODIFIED_DATUM" => {
                let entity = ReferencedModifiedDatum::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "RELATIVE_EVENT_OCCURRENCE" => {
                let entity = RelativeEventOccurrence::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "REP_ITEM_GROUP" => {
                let entity = RepItemGroup::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "REPARAMETRISED_COMPOSITE_CURVE_SEGMENT" => {
                let entity = ReparametrisedCompositeCurveSegment::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "REPLICATE_FEATURE" => {
                let entity = ReplicateFeature::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "REPRESENTATION" => {
                let entity = Representation::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "REPRESENTATION_CONTEXT" => {
                let entity = RepresentationContext::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "REPRESENTATION_ITEM" => {
                let entity = RepresentationItem::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "REPRESENTATION_MAP" => {
                let entity = RepresentationMap::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "REPRESENTATION_RELATIONSHIP" => {
                let entity = RepresentationRelationship::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "REPRESENTATION_RELATIONSHIP_WITH_TRANSFORMATION" => {
                let entity = RepresentationRelationshipWithTransformation::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "REQUIREMENT_FOR_ACTION_RESOURCE" => {
                let entity = RequirementForActionResource::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "RESOURCE_PROPERTY" => {
                let entity = ResourceProperty::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "RESOURCE_PROPERTY_REPRESENTATION" => {
                let entity = ResourcePropertyRepresentation::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "RESOURCE_REQUIREMENT_TYPE" => {
                let entity = ResourceRequirementType::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "RESULTING_PATH" => {
                let entity = ResultingPath::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "RETENTION" => {
                let entity = Retention::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "REVOLUTE_PAIR" => {
                let entity = RevolutePair::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "REVOLUTE_PAIR_RANGE" => {
                let entity = RevolutePairRange::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "REVOLUTE_PAIR_VALUE" => {
                let entity = RevolutePairValue::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "REVOLVED_AREA_SOLID" => {
                let entity = RevolvedAreaSolid::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "REVOLVED_FACE_SOLID" => {
                let entity = RevolvedFaceSolid::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "RIB" => {
                let entity = Rib::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "RIGHT_ANGULAR_WEDGE" => {
                let entity = RightAngularWedge::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "RIGHT_CIRCULAR_CONE" => {
                let entity = RightCircularCone::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "RIGHT_CIRCULAR_CYLINDER" => {
                let entity = RightCircularCylinder::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "ROLE_ASSOCIATION" => {
                let entity = RoleAssociation::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "ROLLING_CURVE_PAIR" => {
                let entity = RollingCurvePair::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "ROLLING_CURVE_PAIR_VALUE" => {
                let entity = RollingCurvePairValue::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "ROLLING_SURFACE_PAIR" => {
                let entity = RollingSurfacePair::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "ROLLING_SURFACE_PAIR_VALUE" => {
                let entity = RollingSurfacePairValue::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "ROTATION_ABOUT_DIRECTION" => {
                let entity = RotationAboutDirection::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "ROUND_HOLE" => {
                let entity = RoundHole::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "ROUNDED_U_PROFILE" => {
                let entity = RoundedUProfile::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "ROUNDNESS_TOLERANCE" => {
                let entity = RoundnessTolerance::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "RULED_SURFACE_SWEPT_AREA_SOLID" => {
                let entity = RuledSurfaceSweptAreaSolid::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "RUNOUT_ZONE_DEFINITION" => {
                let entity = RunoutZoneDefinition::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "RUNOUT_ZONE_ORIENTATION" => {
                let entity = RunoutZoneOrientation::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "RUNOUT_ZONE_ORIENTATION_REFERENCE_DIRECTION" => {
                let entity = RunoutZoneOrientationReferenceDirection::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "SCREW_PAIR" => {
                let entity = ScrewPair::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "SCREW_PAIR_RANGE" => {
                let entity = ScrewPairRange::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "SCREW_PAIR_VALUE" => {
                let entity = ScrewPairValue::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "SEAM_CURVE" => {
                let entity = SeamCurve::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "SEAM_EDGE" => {
                let entity = SeamEdge::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "SECURITY_CLASSIFICATION" => {
                let entity = SecurityClassification::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "SECURITY_CLASSIFICATION_LEVEL" => {
                let entity = SecurityClassificationLevel::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "SERIAL_NUMBERED_EFFECTIVITY" => {
                let entity = SerialNumberedEffectivity::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "SHAPE_ASPECT" => {
                let entity = ShapeAspect::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "SHAPE_ASPECT_ASSOCIATIVITY" => {
                let entity = ShapeAspectAssociativity::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "SHAPE_ASPECT_DERIVING_RELATIONSHIP" => {
                let entity = ShapeAspectDerivingRelationship::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "SHAPE_ASPECT_RELATIONSHIP" => {
                let entity = ShapeAspectRelationship::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "SHAPE_ASPECT_TRANSITION" => {
                let entity = ShapeAspectTransition::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "SHAPE_DEFINING_RELATIONSHIP" => {
                let entity = ShapeDefiningRelationship::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "SHAPE_DEFINITION_REPRESENTATION" => {
                let entity = ShapeDefinitionRepresentation::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "SHAPE_DIMENSION_REPRESENTATION" => {
                let entity = ShapeDimensionRepresentation::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "SHAPE_REPRESENTATION" => {
                let entity = ShapeRepresentation::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "SHAPE_REPRESENTATION_RELATIONSHIP" => {
                let entity = ShapeRepresentationRelationship::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "SHAPE_REPRESENTATION_WITH_PARAMETERS" => {
                let entity = ShapeRepresentationWithParameters::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "SHELL_BASED_SURFACE_MODEL" => {
                let entity = ShellBasedSurfaceModel::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "SI_UNIT" => {
                let entity = SiUnit::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "SIMPLE_PAIR_RANGE" => {
                let entity = SimplePairRange::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "SIN_FUNCTION" => {
                let entity = SinFunction::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "SLASH_EXPRESSION" => {
                let entity = SlashExpression::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "SLIDING_CURVE_PAIR" => {
                let entity = SlidingCurvePair::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "SLIDING_CURVE_PAIR_VALUE" => {
                let entity = SlidingCurvePairValue::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "SLIDING_SURFACE_PAIR" => {
                let entity = SlidingSurfacePair::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "SLIDING_SURFACE_PAIR_VALUE" => {
                let entity = SlidingSurfacePairValue::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "SLOT" => {
                let entity = Slot::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "SLOT_END" => {
                let entity = SlotEnd::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "SOLID_ANGLE_MEASURE_WITH_UNIT" => {
                let entity = SolidAngleMeasureWithUnit::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "SOLID_ANGLE_UNIT" => {
                let entity = SolidAngleUnit::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "SOLID_MODEL" => {
                let entity = SolidModel::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "SOLID_REPLICA" => {
                let entity = SolidReplica::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "SPECIFIED_HIGHER_USAGE_OCCURRENCE" => {
                let entity = SpecifiedHigherUsageOccurrence::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "SPHERE" => {
                let entity = Sphere::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "SPHERICAL_PAIR" => {
                let entity = SphericalPair::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "SPHERICAL_PAIR_RANGE" => {
                let entity = SphericalPairRange::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "SPHERICAL_PAIR_VALUE" => {
                let entity = SphericalPairValue::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "SPHERICAL_SURFACE" => {
                let entity = SphericalSurface::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "SQUARE_ROOT_FUNCTION" => {
                let entity = SquareRootFunction::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "SQUARE_U_PROFILE" => {
                let entity = SquareUProfile::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "STANDARD_UNCERTAINTY" => {
                let entity = StandardUncertainty::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "STRAIGHTNESS_TOLERANCE" => {
                let entity = StraightnessTolerance::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "STRING_LITERAL" => {
                let entity = StringLiteral::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "STRING_VARIABLE" => {
                let entity = StringVariable::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "STRUCTURED_DIMENSION_CALLOUT" => {
                let entity = StructuredDimensionCallout::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "STYLED_ITEM" => {
                let entity = StyledItem::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "SUBEDGE" => {
                let entity = Subedge::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "SUBFACE" => {
                let entity = Subface::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "SUBSTRING_EXPRESSION" => {
                let entity = SubstringExpression::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "SURFACE" => {
                let entity = Surface::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "SURFACE_CONDITION_CALLOUT" => {
                let entity = SurfaceConditionCallout::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "SURFACE_CURVE" => {
                let entity = SurfaceCurve::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "SURFACE_CURVE_SWEPT_AREA_SOLID" => {
                let entity = SurfaceCurveSweptAreaSolid::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "SURFACE_OF_LINEAR_EXTRUSION" => {
                let entity = SurfaceOfLinearExtrusion::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "SURFACE_OF_REVOLUTION" => {
                let entity = SurfaceOfRevolution::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "SURFACE_PAIR" => {
                let entity = SurfacePair::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "SURFACE_PAIR_RANGE" => {
                let entity = SurfacePairRange::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "SURFACE_PATCH" => {
                let entity = SurfacePatch::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "SURFACE_PROFILE_TOLERANCE" => {
                let entity = SurfaceProfileTolerance::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "SURFACE_RENDERING_PROPERTIES" => {
                let entity = SurfaceRenderingProperties::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "SURFACE_REPLICA" => {
                let entity = SurfaceReplica::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "SURFACE_SIDE_STYLE" => {
                let entity = SurfaceSideStyle::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "SURFACE_STYLE_BOUNDARY" => {
                let entity = SurfaceStyleBoundary::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "SURFACE_STYLE_CONTROL_GRID" => {
                let entity = SurfaceStyleControlGrid::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "SURFACE_STYLE_FILL_AREA" => {
                let entity = SurfaceStyleFillArea::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "SURFACE_STYLE_PARAMETER_LINE" => {
                let entity = SurfaceStyleParameterLine::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "SURFACE_STYLE_REFLECTANCE_AMBIENT" => {
                let entity = SurfaceStyleReflectanceAmbient::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "SURFACE_STYLE_REFLECTANCE_AMBIENT_DIFFUSE" => {
                let entity = SurfaceStyleReflectanceAmbientDiffuse::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "SURFACE_STYLE_REFLECTANCE_AMBIENT_DIFFUSE_SPECULAR" => {
                let entity = SurfaceStyleReflectanceAmbientDiffuseSpecular::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "SURFACE_STYLE_RENDERING" => {
                let entity = SurfaceStyleRendering::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "SURFACE_STYLE_RENDERING_WITH_PROPERTIES" => {
                let entity = SurfaceStyleRenderingWithProperties::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "SURFACE_STYLE_SEGMENTATION_CURVE" => {
                let entity = SurfaceStyleSegmentationCurve::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "SURFACE_STYLE_SILHOUETTE" => {
                let entity = SurfaceStyleSilhouette::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "SURFACE_STYLE_TRANSPARENT" => {
                let entity = SurfaceStyleTransparent::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "SURFACE_STYLE_USAGE" => {
                let entity = SurfaceStyleUsage::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "SURFACE_TEXTURE_REPRESENTATION" => {
                let entity = SurfaceTextureRepresentation::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "SWEPT_AREA_SOLID" => {
                let entity = SweptAreaSolid::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "SWEPT_DISK_SOLID" => {
                let entity = SweptDiskSolid::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "SWEPT_FACE_SOLID" => {
                let entity = SweptFaceSolid::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "SWEPT_SURFACE" => {
                let entity = SweptSurface::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "SYMBOL_COLOUR" => {
                let entity = SymbolColour::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "SYMBOL_REPRESENTATION" => {
                let entity = SymbolRepresentation::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "SYMBOL_REPRESENTATION_MAP" => {
                let entity = SymbolRepresentationMap::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "SYMBOL_STYLE" => {
                let entity = SymbolStyle::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "SYMBOL_TARGET" => {
                let entity = SymbolTarget::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "SYMMETRIC_SHAPE_ASPECT" => {
                let entity = SymmetricShapeAspect::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "SYMMETRY_TOLERANCE" => {
                let entity = SymmetryTolerance::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "TACTILE_APPEARANCE_REPRESENTATION" => {
                let entity = TactileAppearanceRepresentation::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "TAN_FUNCTION" => {
                let entity = TanFunction::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "TANGENT" => {
                let entity = Tangent::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "TAPER" => {
                let entity = Taper::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "TEE_PROFILE" => {
                let entity = TeeProfile::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "TERMINATOR_SYMBOL" => {
                let entity = TerminatorSymbol::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "TEXT_LITERAL" => {
                let entity = TextLiteral::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "TEXT_LITERAL_WITH_ASSOCIATED_CURVES" => {
                let entity = TextLiteralWithAssociatedCurves::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "TEXT_LITERAL_WITH_BLANKING_BOX" => {
                let entity = TextLiteralWithBlankingBox::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "TEXT_LITERAL_WITH_DELINEATION" => {
                let entity = TextLiteralWithDelineation::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "TEXT_LITERAL_WITH_EXTENT" => {
                let entity = TextLiteralWithExtent::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "TEXT_STRING_REPRESENTATION" => {
                let entity = TextStringRepresentation::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "TEXT_STYLE" => {
                let entity = TextStyle::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "TEXT_STYLE_FOR_DEFINED_FONT" => {
                let entity = TextStyleForDefinedFont::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "TEXT_STYLE_WITH_BOX_CHARACTERISTICS" => {
                let entity = TextStyleWithBoxCharacteristics::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "TEXT_STYLE_WITH_MIRROR" => {
                let entity = TextStyleWithMirror::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "TEXT_STYLE_WITH_SPACING" => {
                let entity = TextStyleWithSpacing::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "THERMODYNAMIC_TEMPERATURE_MEASURE_WITH_UNIT" => {
                let entity = ThermodynamicTemperatureMeasureWithUnit::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "THERMODYNAMIC_TEMPERATURE_UNIT" => {
                let entity = ThermodynamicTemperatureUnit::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "THREAD" => {
                let entity = Thread::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "TIME_INTERVAL" => {
                let entity = TimeInterval::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "TIME_INTERVAL_BASED_EFFECTIVITY" => {
                let entity = TimeIntervalBasedEffectivity::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "TIME_INTERVAL_ROLE" => {
                let entity = TimeIntervalRole::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "TIME_INTERVAL_WITH_BOUNDS" => {
                let entity = TimeIntervalWithBounds::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "TIME_MEASURE_WITH_UNIT" => {
                let entity = TimeMeasureWithUnit::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "TIME_UNIT" => {
                let entity = TimeUnit::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "TOLERANCE_VALUE" => {
                let entity = ToleranceValue::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "TOLERANCE_ZONE" => {
                let entity = ToleranceZone::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "TOLERANCE_ZONE_DEFINITION" => {
                let entity = ToleranceZoneDefinition::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "TOLERANCE_ZONE_FORM" => {
                let entity = ToleranceZoneForm::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "TOPOLOGICAL_REPRESENTATION_ITEM" => {
                let entity = TopologicalRepresentationItem::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "TOROIDAL_SURFACE" => {
                let entity = ToroidalSurface::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "TORUS" => {
                let entity = Torus::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "TOTAL_RUNOUT_TOLERANCE" => {
                let entity = TotalRunoutTolerance::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "TRANSITION_FEATURE" => {
                let entity = TransitionFeature::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "TRIMMED_CURVE" => {
                let entity = TrimmedCurve::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "TWO_DIRECTION_REPEAT_FACTOR" => {
                let entity = TwoDirectionRepeatFactor::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "TYPE_QUALIFIER" => {
                let entity = TypeQualifier::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "UNCERTAINTY_ASSIGNED_REPRESENTATION" => {
                let entity = UncertaintyAssignedRepresentation::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "UNCERTAINTY_MEASURE_WITH_UNIT" => {
                let entity = UncertaintyMeasureWithUnit::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "UNCERTAINTY_QUALIFIER" => {
                let entity = UncertaintyQualifier::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "UNCONSTRAINED_PAIR" => {
                let entity = UnconstrainedPair::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "UNCONSTRAINED_PAIR_VALUE" => {
                let entity = UnconstrainedPairValue::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "UNIFORM_CURVE" => {
                let entity = UniformCurve::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "UNIFORM_SURFACE" => {
                let entity = UniformSurface::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "UNIVERSAL_PAIR" => {
                let entity = UniversalPair::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "UNIVERSAL_PAIR_RANGE" => {
                let entity = UniversalPairRange::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "UNIVERSAL_PAIR_VALUE" => {
                let entity = UniversalPairValue::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "VALUE_FUNCTION" => {
                let entity = ValueFunction::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "VALUE_RANGE" => {
                let entity = ValueRange::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "VALUE_REPRESENTATION_ITEM" => {
                let entity = ValueRepresentationItem::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "VECTOR" => {
                let entity = Vector::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "VECTOR_STYLE" => {
                let entity = VectorStyle::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "VEE_PROFILE" => {
                let entity = VeeProfile::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "VERSIONED_ACTION_REQUEST" => {
                let entity = VersionedActionRequest::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "VERSIONED_ACTION_REQUEST_RELATIONSHIP" => {
                let entity = VersionedActionRequestRelationship::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "VERTEX" => {
                let entity = Vertex::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "VERTEX_LOOP" => {
                let entity = VertexLoop::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "VERTEX_POINT" => {
                let entity = VertexPoint::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "VIEW_VOLUME" => {
                let entity = ViewVolume::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "VISUAL_APPEARANCE_REPRESENTATION" => {
                let entity = VisualAppearanceRepresentation::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "VOLUME_MEASURE_WITH_UNIT" => {
                let entity = VolumeMeasureWithUnit::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "VOLUME_UNIT" => {
                let entity = VolumeUnit::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "XOR_EXPRESSION" => {
                let entity = XorExpression::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            _ => println!("{} is not implemented", typed_parameter.type_name),
        }
    }
}
