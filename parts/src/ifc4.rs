#![doc = r" This file is generated. Do not edit."]
#![allow(dead_code)]
use iso_10303::step::*;
use std::collections::HashSet;
#[derive(Default, Debug)]
pub struct Unimplemented {}
impl From<Parameter> for Unimplemented {
    fn from(_parameter: Parameter) -> Self {
        Unimplemented {}
    }
}
type IfcStrippedOptional = bool;
type IfcAbsorbedDoseMeasure = Real;
type IfcAccelerationMeasure = Real;
type IfcAmountOfSubstanceMeasure = Real;
type IfcAngularVelocityMeasure = Real;
type IfcArcIndex = Vec<IfcPositiveInteger>;
type IfcAreaDensityMeasure = Real;
type IfcAreaMeasure = Real;
type IfcBinary = Unimplemented;
type IfcBoolean = bool;
type IfcBoxAlignment = IfcLabel;
type IfcCardinalPointReference = i64;
type IfcComplexNumber = Vec<Real>;
type IfcCompoundPlaneAngleMeasure = Vec<i64>;
type IfcContextDependentMeasure = Real;
type IfcCountMeasure = Real;
type IfcCurvatureMeasure = Real;
type IfcDate = String;
type IfcDateTime = String;
type IfcDayInMonthNumber = i64;
type IfcDayInWeekNumber = i64;
type IfcDescriptiveMeasure = String;
type IfcDimensionCount = i64;
type IfcDoseEquivalentMeasure = Real;
type IfcDuration = String;
type IfcDynamicViscosityMeasure = Real;
type IfcElectricCapacitanceMeasure = Real;
type IfcElectricChargeMeasure = Real;
type IfcElectricConductanceMeasure = Real;
type IfcElectricCurrentMeasure = Real;
type IfcElectricResistanceMeasure = Real;
type IfcElectricVoltageMeasure = Real;
type IfcEnergyMeasure = Real;
type IfcFontStyle = String;
type IfcFontVariant = String;
type IfcFontWeight = String;
type IfcForceMeasure = Real;
type IfcFrequencyMeasure = Real;
type IfcGloballyUniqueId = String;
type IfcHeatFluxDensityMeasure = Real;
type IfcHeatingValueMeasure = Real;
type IfcIdentifier = String;
type IfcIlluminanceMeasure = Real;
type IfcInductanceMeasure = Real;
type IfcInteger = i64;
type IfcIntegerCountRateMeasure = i64;
type IfcIonConcentrationMeasure = Real;
type IfcIsothermalMoistureCapacityMeasure = Real;
type IfcKinematicViscosityMeasure = Real;
type IfcLabel = String;
type IfcLanguageId = IfcIdentifier;
type IfcLengthMeasure = Real;
type IfcLineIndex = Vec<IfcPositiveInteger>;
type IfcLinearForceMeasure = Real;
type IfcLinearMomentMeasure = Real;
type IfcLinearStiffnessMeasure = Real;
type IfcLinearVelocityMeasure = Real;
type IfcLogical = Option<bool>;
type IfcLuminousFluxMeasure = Real;
type IfcLuminousIntensityDistributionMeasure = Real;
type IfcLuminousIntensityMeasure = Real;
type IfcMagneticFluxDensityMeasure = Real;
type IfcMagneticFluxMeasure = Real;
type IfcMassDensityMeasure = Real;
type IfcMassFlowRateMeasure = Real;
type IfcMassMeasure = Real;
type IfcMassPerLengthMeasure = Real;
type IfcModulusOfElasticityMeasure = Real;
type IfcModulusOfLinearSubgradeReactionMeasure = Real;
type IfcModulusOfRotationalSubgradeReactionMeasure = Real;
type IfcModulusOfSubgradeReactionMeasure = Real;
type IfcMoistureDiffusivityMeasure = Real;
type IfcMolecularWeightMeasure = Real;
type IfcMomentOfInertiaMeasure = Real;
type IfcMonetaryMeasure = Real;
type IfcMonthInYearNumber = i64;
type IfcNonNegativeLengthMeasure = IfcLengthMeasure;
type IfcNormalisedRatioMeasure = IfcRatioMeasure;
type IfcNumericMeasure = Real;
type IfcPhMeasure = Real;
type IfcParameterValue = Real;
type IfcPlanarForceMeasure = Real;
type IfcPlaneAngleMeasure = Real;
type IfcPositiveInteger = IfcInteger;
type IfcPositiveLengthMeasure = IfcLengthMeasure;
type IfcPositivePlaneAngleMeasure = IfcPlaneAngleMeasure;
type IfcPositiveRatioMeasure = IfcRatioMeasure;
type IfcPowerMeasure = Real;
type IfcPresentableText = String;
type IfcPressureMeasure = Real;
type IfcPropertySetDefinitionSet = HashSet<EntityRef>;
type IfcRadioActivityMeasure = Real;
type IfcRatioMeasure = Real;
type IfcReal = Real;
type IfcRotationalFrequencyMeasure = Real;
type IfcRotationalMassMeasure = Real;
type IfcRotationalStiffnessMeasure = Real;
type IfcSectionModulusMeasure = Real;
type IfcSectionalAreaIntegralMeasure = Real;
type IfcShearModulusMeasure = Real;
type IfcSolidAngleMeasure = Real;
type IfcSoundPowerLevelMeasure = Real;
type IfcSoundPowerMeasure = Real;
type IfcSoundPressureLevelMeasure = Real;
type IfcSoundPressureMeasure = Real;
type IfcSpecificHeatCapacityMeasure = Real;
type IfcSpecularExponent = Real;
type IfcSpecularRoughness = Real;
type IfcTemperatureGradientMeasure = Real;
type IfcTemperatureRateOfChangeMeasure = Real;
type IfcText = String;
type IfcTextAlignment = String;
type IfcTextDecoration = String;
type IfcTextFontName = String;
type IfcTextTransformation = String;
type IfcThermalAdmittanceMeasure = Real;
type IfcThermalConductivityMeasure = Real;
type IfcThermalExpansionCoefficientMeasure = Real;
type IfcThermalResistanceMeasure = Real;
type IfcThermalTransmittanceMeasure = Real;
type IfcThermodynamicTemperatureMeasure = Real;
type IfcTime = String;
type IfcTimeMeasure = Real;
type IfcTimeStamp = i64;
type IfcTorqueMeasure = Real;
type IfcUriReference = String;
type IfcVaporPermeabilityMeasure = Real;
type IfcVolumeMeasure = Real;
type IfcVolumetricFlowRateMeasure = Real;
type IfcWarpingConstantMeasure = Real;
type IfcWarpingMomentMeasure = Real;
#[derive(Eq, PartialEq, Hash, Debug)]
pub enum IfcActionRequestTypeEnum {
    Email,
    Fax,
    Phone,
    Post,
    Verbal,
    Userdefined,
    Notdefined,
}
impl Default for IfcActionRequestTypeEnum {
    fn default() -> Self {
        IfcActionRequestTypeEnum::Email
    }
}
impl From<String> for IfcActionRequestTypeEnum {
    fn from(value: String) -> Self {
        match value.as_str() {
            "EMAIL" => IfcActionRequestTypeEnum::Email,
            "FAX" => IfcActionRequestTypeEnum::Fax,
            "PHONE" => IfcActionRequestTypeEnum::Phone,
            "POST" => IfcActionRequestTypeEnum::Post,
            "VERBAL" => IfcActionRequestTypeEnum::Verbal,
            "USERDEFINED" => IfcActionRequestTypeEnum::Userdefined,
            "NOTDEFINED" => IfcActionRequestTypeEnum::Notdefined,
            _ => panic!("{} is not a valid value", value),
        }
    }
}
impl From<Parameter> for IfcActionRequestTypeEnum {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EnumValue(value) => value.into(),
                _ => panic!("parameter is not an enum value"),
            },
            Parameter::OmittedParameter => IfcActionRequestTypeEnum::default(),
            _ => panic!("parameter is not an enum value"),
        }
    }
}
#[derive(Eq, PartialEq, Hash, Debug)]
pub enum IfcActionSourceTypeEnum {
    DeadLoadG,
    CompletionG1,
    LiveLoadQ,
    SnowS,
    WindW,
    PrestressingP,
    SettlementU,
    TemperatureT,
    EarthquakeE,
    Fire,
    Impulse,
    Impact,
    Transport,
    Erection,
    Propping,
    SystemImperfection,
    Shrinkage,
    Creep,
    LackOfFit,
    Buoyancy,
    Ice,
    Current,
    Wave,
    Rain,
    Brakes,
    Userdefined,
    Notdefined,
}
impl Default for IfcActionSourceTypeEnum {
    fn default() -> Self {
        IfcActionSourceTypeEnum::DeadLoadG
    }
}
impl From<String> for IfcActionSourceTypeEnum {
    fn from(value: String) -> Self {
        match value.as_str() {
            "DEAD_LOAD_G" => IfcActionSourceTypeEnum::DeadLoadG,
            "COMPLETION_G1" => IfcActionSourceTypeEnum::CompletionG1,
            "LIVE_LOAD_Q" => IfcActionSourceTypeEnum::LiveLoadQ,
            "SNOW_S" => IfcActionSourceTypeEnum::SnowS,
            "WIND_W" => IfcActionSourceTypeEnum::WindW,
            "PRESTRESSING_P" => IfcActionSourceTypeEnum::PrestressingP,
            "SETTLEMENT_U" => IfcActionSourceTypeEnum::SettlementU,
            "TEMPERATURE_T" => IfcActionSourceTypeEnum::TemperatureT,
            "EARTHQUAKE_E" => IfcActionSourceTypeEnum::EarthquakeE,
            "FIRE" => IfcActionSourceTypeEnum::Fire,
            "IMPULSE" => IfcActionSourceTypeEnum::Impulse,
            "IMPACT" => IfcActionSourceTypeEnum::Impact,
            "TRANSPORT" => IfcActionSourceTypeEnum::Transport,
            "ERECTION" => IfcActionSourceTypeEnum::Erection,
            "PROPPING" => IfcActionSourceTypeEnum::Propping,
            "SYSTEM_IMPERFECTION" => IfcActionSourceTypeEnum::SystemImperfection,
            "SHRINKAGE" => IfcActionSourceTypeEnum::Shrinkage,
            "CREEP" => IfcActionSourceTypeEnum::Creep,
            "LACK_OF_FIT" => IfcActionSourceTypeEnum::LackOfFit,
            "BUOYANCY" => IfcActionSourceTypeEnum::Buoyancy,
            "ICE" => IfcActionSourceTypeEnum::Ice,
            "CURRENT" => IfcActionSourceTypeEnum::Current,
            "WAVE" => IfcActionSourceTypeEnum::Wave,
            "RAIN" => IfcActionSourceTypeEnum::Rain,
            "BRAKES" => IfcActionSourceTypeEnum::Brakes,
            "USERDEFINED" => IfcActionSourceTypeEnum::Userdefined,
            "NOTDEFINED" => IfcActionSourceTypeEnum::Notdefined,
            _ => panic!("{} is not a valid value", value),
        }
    }
}
impl From<Parameter> for IfcActionSourceTypeEnum {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EnumValue(value) => value.into(),
                _ => panic!("parameter is not an enum value"),
            },
            Parameter::OmittedParameter => IfcActionSourceTypeEnum::default(),
            _ => panic!("parameter is not an enum value"),
        }
    }
}
#[derive(Eq, PartialEq, Hash, Debug)]
pub enum IfcActionTypeEnum {
    PermanentG,
    VariableQ,
    ExtraordinaryA,
    Userdefined,
    Notdefined,
}
impl Default for IfcActionTypeEnum {
    fn default() -> Self {
        IfcActionTypeEnum::PermanentG
    }
}
impl From<String> for IfcActionTypeEnum {
    fn from(value: String) -> Self {
        match value.as_str() {
            "PERMANENT_G" => IfcActionTypeEnum::PermanentG,
            "VARIABLE_Q" => IfcActionTypeEnum::VariableQ,
            "EXTRAORDINARY_A" => IfcActionTypeEnum::ExtraordinaryA,
            "USERDEFINED" => IfcActionTypeEnum::Userdefined,
            "NOTDEFINED" => IfcActionTypeEnum::Notdefined,
            _ => panic!("{} is not a valid value", value),
        }
    }
}
impl From<Parameter> for IfcActionTypeEnum {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EnumValue(value) => value.into(),
                _ => panic!("parameter is not an enum value"),
            },
            Parameter::OmittedParameter => IfcActionTypeEnum::default(),
            _ => panic!("parameter is not an enum value"),
        }
    }
}
#[derive(Eq, PartialEq, Hash, Debug)]
pub enum IfcActuatorTypeEnum {
    Electricactuator,
    Handoperatedactuator,
    Hydraulicactuator,
    Pneumaticactuator,
    Thermostaticactuator,
    Userdefined,
    Notdefined,
}
impl Default for IfcActuatorTypeEnum {
    fn default() -> Self {
        IfcActuatorTypeEnum::Electricactuator
    }
}
impl From<String> for IfcActuatorTypeEnum {
    fn from(value: String) -> Self {
        match value.as_str() {
            "ELECTRICACTUATOR" => IfcActuatorTypeEnum::Electricactuator,
            "HANDOPERATEDACTUATOR" => IfcActuatorTypeEnum::Handoperatedactuator,
            "HYDRAULICACTUATOR" => IfcActuatorTypeEnum::Hydraulicactuator,
            "PNEUMATICACTUATOR" => IfcActuatorTypeEnum::Pneumaticactuator,
            "THERMOSTATICACTUATOR" => IfcActuatorTypeEnum::Thermostaticactuator,
            "USERDEFINED" => IfcActuatorTypeEnum::Userdefined,
            "NOTDEFINED" => IfcActuatorTypeEnum::Notdefined,
            _ => panic!("{} is not a valid value", value),
        }
    }
}
impl From<Parameter> for IfcActuatorTypeEnum {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EnumValue(value) => value.into(),
                _ => panic!("parameter is not an enum value"),
            },
            Parameter::OmittedParameter => IfcActuatorTypeEnum::default(),
            _ => panic!("parameter is not an enum value"),
        }
    }
}
#[derive(Eq, PartialEq, Hash, Debug)]
pub enum IfcAddressTypeEnum {
    Office,
    Site,
    Home,
    Distributionpoint,
    Userdefined,
}
impl Default for IfcAddressTypeEnum {
    fn default() -> Self {
        IfcAddressTypeEnum::Office
    }
}
impl From<String> for IfcAddressTypeEnum {
    fn from(value: String) -> Self {
        match value.as_str() {
            "OFFICE" => IfcAddressTypeEnum::Office,
            "SITE" => IfcAddressTypeEnum::Site,
            "HOME" => IfcAddressTypeEnum::Home,
            "DISTRIBUTIONPOINT" => IfcAddressTypeEnum::Distributionpoint,
            "USERDEFINED" => IfcAddressTypeEnum::Userdefined,
            _ => panic!("{} is not a valid value", value),
        }
    }
}
impl From<Parameter> for IfcAddressTypeEnum {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EnumValue(value) => value.into(),
                _ => panic!("parameter is not an enum value"),
            },
            Parameter::OmittedParameter => IfcAddressTypeEnum::default(),
            _ => panic!("parameter is not an enum value"),
        }
    }
}
#[derive(Eq, PartialEq, Hash, Debug)]
pub enum IfcAirTerminalBoxTypeEnum {
    Constantflow,
    Variableflowpressuredependant,
    Variableflowpressureindependant,
    Userdefined,
    Notdefined,
}
impl Default for IfcAirTerminalBoxTypeEnum {
    fn default() -> Self {
        IfcAirTerminalBoxTypeEnum::Constantflow
    }
}
impl From<String> for IfcAirTerminalBoxTypeEnum {
    fn from(value: String) -> Self {
        match value.as_str() {
            "CONSTANTFLOW" => IfcAirTerminalBoxTypeEnum::Constantflow,
            "VARIABLEFLOWPRESSUREDEPENDANT" => IfcAirTerminalBoxTypeEnum::Variableflowpressuredependant,
            "VARIABLEFLOWPRESSUREINDEPENDANT" => IfcAirTerminalBoxTypeEnum::Variableflowpressureindependant,
            "USERDEFINED" => IfcAirTerminalBoxTypeEnum::Userdefined,
            "NOTDEFINED" => IfcAirTerminalBoxTypeEnum::Notdefined,
            _ => panic!("{} is not a valid value", value),
        }
    }
}
impl From<Parameter> for IfcAirTerminalBoxTypeEnum {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EnumValue(value) => value.into(),
                _ => panic!("parameter is not an enum value"),
            },
            Parameter::OmittedParameter => IfcAirTerminalBoxTypeEnum::default(),
            _ => panic!("parameter is not an enum value"),
        }
    }
}
#[derive(Eq, PartialEq, Hash, Debug)]
pub enum IfcAirTerminalTypeEnum {
    Diffuser,
    Grille,
    Louvre,
    Register,
    Userdefined,
    Notdefined,
}
impl Default for IfcAirTerminalTypeEnum {
    fn default() -> Self {
        IfcAirTerminalTypeEnum::Diffuser
    }
}
impl From<String> for IfcAirTerminalTypeEnum {
    fn from(value: String) -> Self {
        match value.as_str() {
            "DIFFUSER" => IfcAirTerminalTypeEnum::Diffuser,
            "GRILLE" => IfcAirTerminalTypeEnum::Grille,
            "LOUVRE" => IfcAirTerminalTypeEnum::Louvre,
            "REGISTER" => IfcAirTerminalTypeEnum::Register,
            "USERDEFINED" => IfcAirTerminalTypeEnum::Userdefined,
            "NOTDEFINED" => IfcAirTerminalTypeEnum::Notdefined,
            _ => panic!("{} is not a valid value", value),
        }
    }
}
impl From<Parameter> for IfcAirTerminalTypeEnum {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EnumValue(value) => value.into(),
                _ => panic!("parameter is not an enum value"),
            },
            Parameter::OmittedParameter => IfcAirTerminalTypeEnum::default(),
            _ => panic!("parameter is not an enum value"),
        }
    }
}
#[derive(Eq, PartialEq, Hash, Debug)]
pub enum IfcAirToAirHeatRecoveryTypeEnum {
    Fixedplatecounterflowexchanger,
    Fixedplatecrossflowexchanger,
    Fixedplateparallelflowexchanger,
    Rotarywheel,
    Runaroundcoilloop,
    Heatpipe,
    Twintowerenthalpyrecoveryloops,
    Thermosiphonsealedtubeheatexchangers,
    Thermosiphoncoiltypeheatexchangers,
    Userdefined,
    Notdefined,
}
impl Default for IfcAirToAirHeatRecoveryTypeEnum {
    fn default() -> Self {
        IfcAirToAirHeatRecoveryTypeEnum::Fixedplatecounterflowexchanger
    }
}
impl From<String> for IfcAirToAirHeatRecoveryTypeEnum {
    fn from(value: String) -> Self {
        match value.as_str() {
            "FIXEDPLATECOUNTERFLOWEXCHANGER" => IfcAirToAirHeatRecoveryTypeEnum::Fixedplatecounterflowexchanger,
            "FIXEDPLATECROSSFLOWEXCHANGER" => IfcAirToAirHeatRecoveryTypeEnum::Fixedplatecrossflowexchanger,
            "FIXEDPLATEPARALLELFLOWEXCHANGER" => IfcAirToAirHeatRecoveryTypeEnum::Fixedplateparallelflowexchanger,
            "ROTARYWHEEL" => IfcAirToAirHeatRecoveryTypeEnum::Rotarywheel,
            "RUNAROUNDCOILLOOP" => IfcAirToAirHeatRecoveryTypeEnum::Runaroundcoilloop,
            "HEATPIPE" => IfcAirToAirHeatRecoveryTypeEnum::Heatpipe,
            "TWINTOWERENTHALPYRECOVERYLOOPS" => IfcAirToAirHeatRecoveryTypeEnum::Twintowerenthalpyrecoveryloops,
            "THERMOSIPHONSEALEDTUBEHEATEXCHANGERS" => {
                IfcAirToAirHeatRecoveryTypeEnum::Thermosiphonsealedtubeheatexchangers
            }
            "THERMOSIPHONCOILTYPEHEATEXCHANGERS" => IfcAirToAirHeatRecoveryTypeEnum::Thermosiphoncoiltypeheatexchangers,
            "USERDEFINED" => IfcAirToAirHeatRecoveryTypeEnum::Userdefined,
            "NOTDEFINED" => IfcAirToAirHeatRecoveryTypeEnum::Notdefined,
            _ => panic!("{} is not a valid value", value),
        }
    }
}
impl From<Parameter> for IfcAirToAirHeatRecoveryTypeEnum {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EnumValue(value) => value.into(),
                _ => panic!("parameter is not an enum value"),
            },
            Parameter::OmittedParameter => IfcAirToAirHeatRecoveryTypeEnum::default(),
            _ => panic!("parameter is not an enum value"),
        }
    }
}
#[derive(Eq, PartialEq, Hash, Debug)]
pub enum IfcAlarmTypeEnum {
    Bell,
    Breakglassbutton,
    Light,
    Manualpullbox,
    Siren,
    Whistle,
    Userdefined,
    Notdefined,
}
impl Default for IfcAlarmTypeEnum {
    fn default() -> Self {
        IfcAlarmTypeEnum::Bell
    }
}
impl From<String> for IfcAlarmTypeEnum {
    fn from(value: String) -> Self {
        match value.as_str() {
            "BELL" => IfcAlarmTypeEnum::Bell,
            "BREAKGLASSBUTTON" => IfcAlarmTypeEnum::Breakglassbutton,
            "LIGHT" => IfcAlarmTypeEnum::Light,
            "MANUALPULLBOX" => IfcAlarmTypeEnum::Manualpullbox,
            "SIREN" => IfcAlarmTypeEnum::Siren,
            "WHISTLE" => IfcAlarmTypeEnum::Whistle,
            "USERDEFINED" => IfcAlarmTypeEnum::Userdefined,
            "NOTDEFINED" => IfcAlarmTypeEnum::Notdefined,
            _ => panic!("{} is not a valid value", value),
        }
    }
}
impl From<Parameter> for IfcAlarmTypeEnum {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EnumValue(value) => value.into(),
                _ => panic!("parameter is not an enum value"),
            },
            Parameter::OmittedParameter => IfcAlarmTypeEnum::default(),
            _ => panic!("parameter is not an enum value"),
        }
    }
}
#[derive(Eq, PartialEq, Hash, Debug)]
pub enum IfcAnalysisModelTypeEnum {
    InPlaneLoading2d,
    OutPlaneLoading2d,
    Loading3d,
    Userdefined,
    Notdefined,
}
impl Default for IfcAnalysisModelTypeEnum {
    fn default() -> Self {
        IfcAnalysisModelTypeEnum::InPlaneLoading2d
    }
}
impl From<String> for IfcAnalysisModelTypeEnum {
    fn from(value: String) -> Self {
        match value.as_str() {
            "IN_PLANE_LOADING_2D" => IfcAnalysisModelTypeEnum::InPlaneLoading2d,
            "OUT_PLANE_LOADING_2D" => IfcAnalysisModelTypeEnum::OutPlaneLoading2d,
            "LOADING_3D" => IfcAnalysisModelTypeEnum::Loading3d,
            "USERDEFINED" => IfcAnalysisModelTypeEnum::Userdefined,
            "NOTDEFINED" => IfcAnalysisModelTypeEnum::Notdefined,
            _ => panic!("{} is not a valid value", value),
        }
    }
}
impl From<Parameter> for IfcAnalysisModelTypeEnum {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EnumValue(value) => value.into(),
                _ => panic!("parameter is not an enum value"),
            },
            Parameter::OmittedParameter => IfcAnalysisModelTypeEnum::default(),
            _ => panic!("parameter is not an enum value"),
        }
    }
}
#[derive(Eq, PartialEq, Hash, Debug)]
pub enum IfcAnalysisTheoryTypeEnum {
    FirstOrderTheory,
    SecondOrderTheory,
    ThirdOrderTheory,
    FullNonlinearTheory,
    Userdefined,
    Notdefined,
}
impl Default for IfcAnalysisTheoryTypeEnum {
    fn default() -> Self {
        IfcAnalysisTheoryTypeEnum::FirstOrderTheory
    }
}
impl From<String> for IfcAnalysisTheoryTypeEnum {
    fn from(value: String) -> Self {
        match value.as_str() {
            "FIRST_ORDER_THEORY" => IfcAnalysisTheoryTypeEnum::FirstOrderTheory,
            "SECOND_ORDER_THEORY" => IfcAnalysisTheoryTypeEnum::SecondOrderTheory,
            "THIRD_ORDER_THEORY" => IfcAnalysisTheoryTypeEnum::ThirdOrderTheory,
            "FULL_NONLINEAR_THEORY" => IfcAnalysisTheoryTypeEnum::FullNonlinearTheory,
            "USERDEFINED" => IfcAnalysisTheoryTypeEnum::Userdefined,
            "NOTDEFINED" => IfcAnalysisTheoryTypeEnum::Notdefined,
            _ => panic!("{} is not a valid value", value),
        }
    }
}
impl From<Parameter> for IfcAnalysisTheoryTypeEnum {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EnumValue(value) => value.into(),
                _ => panic!("parameter is not an enum value"),
            },
            Parameter::OmittedParameter => IfcAnalysisTheoryTypeEnum::default(),
            _ => panic!("parameter is not an enum value"),
        }
    }
}
#[derive(Eq, PartialEq, Hash, Debug)]
pub enum IfcArithmeticOperatorEnum {
    Add,
    Divide,
    Multiply,
    Subtract,
}
impl Default for IfcArithmeticOperatorEnum {
    fn default() -> Self {
        IfcArithmeticOperatorEnum::Add
    }
}
impl From<String> for IfcArithmeticOperatorEnum {
    fn from(value: String) -> Self {
        match value.as_str() {
            "ADD" => IfcArithmeticOperatorEnum::Add,
            "DIVIDE" => IfcArithmeticOperatorEnum::Divide,
            "MULTIPLY" => IfcArithmeticOperatorEnum::Multiply,
            "SUBTRACT" => IfcArithmeticOperatorEnum::Subtract,
            _ => panic!("{} is not a valid value", value),
        }
    }
}
impl From<Parameter> for IfcArithmeticOperatorEnum {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EnumValue(value) => value.into(),
                _ => panic!("parameter is not an enum value"),
            },
            Parameter::OmittedParameter => IfcArithmeticOperatorEnum::default(),
            _ => panic!("parameter is not an enum value"),
        }
    }
}
#[derive(Eq, PartialEq, Hash, Debug)]
pub enum IfcAssemblyPlaceEnum {
    Site,
    Factory,
    Notdefined,
}
impl Default for IfcAssemblyPlaceEnum {
    fn default() -> Self {
        IfcAssemblyPlaceEnum::Site
    }
}
impl From<String> for IfcAssemblyPlaceEnum {
    fn from(value: String) -> Self {
        match value.as_str() {
            "SITE" => IfcAssemblyPlaceEnum::Site,
            "FACTORY" => IfcAssemblyPlaceEnum::Factory,
            "NOTDEFINED" => IfcAssemblyPlaceEnum::Notdefined,
            _ => panic!("{} is not a valid value", value),
        }
    }
}
impl From<Parameter> for IfcAssemblyPlaceEnum {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EnumValue(value) => value.into(),
                _ => panic!("parameter is not an enum value"),
            },
            Parameter::OmittedParameter => IfcAssemblyPlaceEnum::default(),
            _ => panic!("parameter is not an enum value"),
        }
    }
}
#[derive(Eq, PartialEq, Hash, Debug)]
pub enum IfcAudioVisualApplianceTypeEnum {
    Amplifier,
    Camera,
    Display,
    Microphone,
    Player,
    Projector,
    Receiver,
    Speaker,
    Switcher,
    Telephone,
    Tuner,
    Userdefined,
    Notdefined,
}
impl Default for IfcAudioVisualApplianceTypeEnum {
    fn default() -> Self {
        IfcAudioVisualApplianceTypeEnum::Amplifier
    }
}
impl From<String> for IfcAudioVisualApplianceTypeEnum {
    fn from(value: String) -> Self {
        match value.as_str() {
            "AMPLIFIER" => IfcAudioVisualApplianceTypeEnum::Amplifier,
            "CAMERA" => IfcAudioVisualApplianceTypeEnum::Camera,
            "DISPLAY" => IfcAudioVisualApplianceTypeEnum::Display,
            "MICROPHONE" => IfcAudioVisualApplianceTypeEnum::Microphone,
            "PLAYER" => IfcAudioVisualApplianceTypeEnum::Player,
            "PROJECTOR" => IfcAudioVisualApplianceTypeEnum::Projector,
            "RECEIVER" => IfcAudioVisualApplianceTypeEnum::Receiver,
            "SPEAKER" => IfcAudioVisualApplianceTypeEnum::Speaker,
            "SWITCHER" => IfcAudioVisualApplianceTypeEnum::Switcher,
            "TELEPHONE" => IfcAudioVisualApplianceTypeEnum::Telephone,
            "TUNER" => IfcAudioVisualApplianceTypeEnum::Tuner,
            "USERDEFINED" => IfcAudioVisualApplianceTypeEnum::Userdefined,
            "NOTDEFINED" => IfcAudioVisualApplianceTypeEnum::Notdefined,
            _ => panic!("{} is not a valid value", value),
        }
    }
}
impl From<Parameter> for IfcAudioVisualApplianceTypeEnum {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EnumValue(value) => value.into(),
                _ => panic!("parameter is not an enum value"),
            },
            Parameter::OmittedParameter => IfcAudioVisualApplianceTypeEnum::default(),
            _ => panic!("parameter is not an enum value"),
        }
    }
}
#[derive(Eq, PartialEq, Hash, Debug)]
pub enum IfcBSplineCurveForm {
    PolylineForm,
    CircularArc,
    EllipticArc,
    ParabolicArc,
    HyperbolicArc,
    Unspecified,
}
impl Default for IfcBSplineCurveForm {
    fn default() -> Self {
        IfcBSplineCurveForm::PolylineForm
    }
}
impl From<String> for IfcBSplineCurveForm {
    fn from(value: String) -> Self {
        match value.as_str() {
            "POLYLINE_FORM" => IfcBSplineCurveForm::PolylineForm,
            "CIRCULAR_ARC" => IfcBSplineCurveForm::CircularArc,
            "ELLIPTIC_ARC" => IfcBSplineCurveForm::EllipticArc,
            "PARABOLIC_ARC" => IfcBSplineCurveForm::ParabolicArc,
            "HYPERBOLIC_ARC" => IfcBSplineCurveForm::HyperbolicArc,
            "UNSPECIFIED" => IfcBSplineCurveForm::Unspecified,
            _ => panic!("{} is not a valid value", value),
        }
    }
}
impl From<Parameter> for IfcBSplineCurveForm {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EnumValue(value) => value.into(),
                _ => panic!("parameter is not an enum value"),
            },
            Parameter::OmittedParameter => IfcBSplineCurveForm::default(),
            _ => panic!("parameter is not an enum value"),
        }
    }
}
#[derive(Eq, PartialEq, Hash, Debug)]
pub enum IfcBSplineSurfaceForm {
    PlaneSurf,
    CylindricalSurf,
    ConicalSurf,
    SphericalSurf,
    ToroidalSurf,
    SurfOfRevolution,
    RuledSurf,
    GeneralisedCone,
    QuadricSurf,
    SurfOfLinearExtrusion,
    Unspecified,
}
impl Default for IfcBSplineSurfaceForm {
    fn default() -> Self {
        IfcBSplineSurfaceForm::PlaneSurf
    }
}
impl From<String> for IfcBSplineSurfaceForm {
    fn from(value: String) -> Self {
        match value.as_str() {
            "PLANE_SURF" => IfcBSplineSurfaceForm::PlaneSurf,
            "CYLINDRICAL_SURF" => IfcBSplineSurfaceForm::CylindricalSurf,
            "CONICAL_SURF" => IfcBSplineSurfaceForm::ConicalSurf,
            "SPHERICAL_SURF" => IfcBSplineSurfaceForm::SphericalSurf,
            "TOROIDAL_SURF" => IfcBSplineSurfaceForm::ToroidalSurf,
            "SURF_OF_REVOLUTION" => IfcBSplineSurfaceForm::SurfOfRevolution,
            "RULED_SURF" => IfcBSplineSurfaceForm::RuledSurf,
            "GENERALISED_CONE" => IfcBSplineSurfaceForm::GeneralisedCone,
            "QUADRIC_SURF" => IfcBSplineSurfaceForm::QuadricSurf,
            "SURF_OF_LINEAR_EXTRUSION" => IfcBSplineSurfaceForm::SurfOfLinearExtrusion,
            "UNSPECIFIED" => IfcBSplineSurfaceForm::Unspecified,
            _ => panic!("{} is not a valid value", value),
        }
    }
}
impl From<Parameter> for IfcBSplineSurfaceForm {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EnumValue(value) => value.into(),
                _ => panic!("parameter is not an enum value"),
            },
            Parameter::OmittedParameter => IfcBSplineSurfaceForm::default(),
            _ => panic!("parameter is not an enum value"),
        }
    }
}
#[derive(Eq, PartialEq, Hash, Debug)]
pub enum IfcBeamTypeEnum {
    Beam,
    Joist,
    Hollowcore,
    Lintel,
    Spandrel,
    TBeam,
    Userdefined,
    Notdefined,
}
impl Default for IfcBeamTypeEnum {
    fn default() -> Self {
        IfcBeamTypeEnum::Beam
    }
}
impl From<String> for IfcBeamTypeEnum {
    fn from(value: String) -> Self {
        match value.as_str() {
            "BEAM" => IfcBeamTypeEnum::Beam,
            "JOIST" => IfcBeamTypeEnum::Joist,
            "HOLLOWCORE" => IfcBeamTypeEnum::Hollowcore,
            "LINTEL" => IfcBeamTypeEnum::Lintel,
            "SPANDREL" => IfcBeamTypeEnum::Spandrel,
            "T_BEAM" => IfcBeamTypeEnum::TBeam,
            "USERDEFINED" => IfcBeamTypeEnum::Userdefined,
            "NOTDEFINED" => IfcBeamTypeEnum::Notdefined,
            _ => panic!("{} is not a valid value", value),
        }
    }
}
impl From<Parameter> for IfcBeamTypeEnum {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EnumValue(value) => value.into(),
                _ => panic!("parameter is not an enum value"),
            },
            Parameter::OmittedParameter => IfcBeamTypeEnum::default(),
            _ => panic!("parameter is not an enum value"),
        }
    }
}
#[derive(Eq, PartialEq, Hash, Debug)]
pub enum IfcBenchmarkEnum {
    Greaterthan,
    Greaterthanorequalto,
    Lessthan,
    Lessthanorequalto,
    Equalto,
    Notequalto,
    Includes,
    Notincludes,
    Includedin,
    Notincludedin,
}
impl Default for IfcBenchmarkEnum {
    fn default() -> Self {
        IfcBenchmarkEnum::Greaterthan
    }
}
impl From<String> for IfcBenchmarkEnum {
    fn from(value: String) -> Self {
        match value.as_str() {
            "GREATERTHAN" => IfcBenchmarkEnum::Greaterthan,
            "GREATERTHANOREQUALTO" => IfcBenchmarkEnum::Greaterthanorequalto,
            "LESSTHAN" => IfcBenchmarkEnum::Lessthan,
            "LESSTHANOREQUALTO" => IfcBenchmarkEnum::Lessthanorequalto,
            "EQUALTO" => IfcBenchmarkEnum::Equalto,
            "NOTEQUALTO" => IfcBenchmarkEnum::Notequalto,
            "INCLUDES" => IfcBenchmarkEnum::Includes,
            "NOTINCLUDES" => IfcBenchmarkEnum::Notincludes,
            "INCLUDEDIN" => IfcBenchmarkEnum::Includedin,
            "NOTINCLUDEDIN" => IfcBenchmarkEnum::Notincludedin,
            _ => panic!("{} is not a valid value", value),
        }
    }
}
impl From<Parameter> for IfcBenchmarkEnum {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EnumValue(value) => value.into(),
                _ => panic!("parameter is not an enum value"),
            },
            Parameter::OmittedParameter => IfcBenchmarkEnum::default(),
            _ => panic!("parameter is not an enum value"),
        }
    }
}
#[derive(Eq, PartialEq, Hash, Debug)]
pub enum IfcBoilerTypeEnum {
    Water,
    Steam,
    Userdefined,
    Notdefined,
}
impl Default for IfcBoilerTypeEnum {
    fn default() -> Self {
        IfcBoilerTypeEnum::Water
    }
}
impl From<String> for IfcBoilerTypeEnum {
    fn from(value: String) -> Self {
        match value.as_str() {
            "WATER" => IfcBoilerTypeEnum::Water,
            "STEAM" => IfcBoilerTypeEnum::Steam,
            "USERDEFINED" => IfcBoilerTypeEnum::Userdefined,
            "NOTDEFINED" => IfcBoilerTypeEnum::Notdefined,
            _ => panic!("{} is not a valid value", value),
        }
    }
}
impl From<Parameter> for IfcBoilerTypeEnum {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EnumValue(value) => value.into(),
                _ => panic!("parameter is not an enum value"),
            },
            Parameter::OmittedParameter => IfcBoilerTypeEnum::default(),
            _ => panic!("parameter is not an enum value"),
        }
    }
}
#[derive(Eq, PartialEq, Hash, Debug)]
pub enum IfcBooleanOperator {
    Union,
    Intersection,
    Difference,
}
impl Default for IfcBooleanOperator {
    fn default() -> Self {
        IfcBooleanOperator::Union
    }
}
impl From<String> for IfcBooleanOperator {
    fn from(value: String) -> Self {
        match value.as_str() {
            "UNION" => IfcBooleanOperator::Union,
            "INTERSECTION" => IfcBooleanOperator::Intersection,
            "DIFFERENCE" => IfcBooleanOperator::Difference,
            _ => panic!("{} is not a valid value", value),
        }
    }
}
impl From<Parameter> for IfcBooleanOperator {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EnumValue(value) => value.into(),
                _ => panic!("parameter is not an enum value"),
            },
            Parameter::OmittedParameter => IfcBooleanOperator::default(),
            _ => panic!("parameter is not an enum value"),
        }
    }
}
#[derive(Eq, PartialEq, Hash, Debug)]
pub enum IfcBuildingElementPartTypeEnum {
    Insulation,
    Precastpanel,
    Userdefined,
    Notdefined,
}
impl Default for IfcBuildingElementPartTypeEnum {
    fn default() -> Self {
        IfcBuildingElementPartTypeEnum::Insulation
    }
}
impl From<String> for IfcBuildingElementPartTypeEnum {
    fn from(value: String) -> Self {
        match value.as_str() {
            "INSULATION" => IfcBuildingElementPartTypeEnum::Insulation,
            "PRECASTPANEL" => IfcBuildingElementPartTypeEnum::Precastpanel,
            "USERDEFINED" => IfcBuildingElementPartTypeEnum::Userdefined,
            "NOTDEFINED" => IfcBuildingElementPartTypeEnum::Notdefined,
            _ => panic!("{} is not a valid value", value),
        }
    }
}
impl From<Parameter> for IfcBuildingElementPartTypeEnum {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EnumValue(value) => value.into(),
                _ => panic!("parameter is not an enum value"),
            },
            Parameter::OmittedParameter => IfcBuildingElementPartTypeEnum::default(),
            _ => panic!("parameter is not an enum value"),
        }
    }
}
#[derive(Eq, PartialEq, Hash, Debug)]
pub enum IfcBuildingElementProxyTypeEnum {
    Complex,
    Element,
    Partial,
    Provisionforvoid,
    Provisionforspace,
    Userdefined,
    Notdefined,
}
impl Default for IfcBuildingElementProxyTypeEnum {
    fn default() -> Self {
        IfcBuildingElementProxyTypeEnum::Complex
    }
}
impl From<String> for IfcBuildingElementProxyTypeEnum {
    fn from(value: String) -> Self {
        match value.as_str() {
            "COMPLEX" => IfcBuildingElementProxyTypeEnum::Complex,
            "ELEMENT" => IfcBuildingElementProxyTypeEnum::Element,
            "PARTIAL" => IfcBuildingElementProxyTypeEnum::Partial,
            "PROVISIONFORVOID" => IfcBuildingElementProxyTypeEnum::Provisionforvoid,
            "PROVISIONFORSPACE" => IfcBuildingElementProxyTypeEnum::Provisionforspace,
            "USERDEFINED" => IfcBuildingElementProxyTypeEnum::Userdefined,
            "NOTDEFINED" => IfcBuildingElementProxyTypeEnum::Notdefined,
            _ => panic!("{} is not a valid value", value),
        }
    }
}
impl From<Parameter> for IfcBuildingElementProxyTypeEnum {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EnumValue(value) => value.into(),
                _ => panic!("parameter is not an enum value"),
            },
            Parameter::OmittedParameter => IfcBuildingElementProxyTypeEnum::default(),
            _ => panic!("parameter is not an enum value"),
        }
    }
}
#[derive(Eq, PartialEq, Hash, Debug)]
pub enum IfcBuildingSystemTypeEnum {
    Fenestration,
    Foundation,
    Loadbearing,
    Outershell,
    Shading,
    Transport,
    Userdefined,
    Notdefined,
}
impl Default for IfcBuildingSystemTypeEnum {
    fn default() -> Self {
        IfcBuildingSystemTypeEnum::Fenestration
    }
}
impl From<String> for IfcBuildingSystemTypeEnum {
    fn from(value: String) -> Self {
        match value.as_str() {
            "FENESTRATION" => IfcBuildingSystemTypeEnum::Fenestration,
            "FOUNDATION" => IfcBuildingSystemTypeEnum::Foundation,
            "LOADBEARING" => IfcBuildingSystemTypeEnum::Loadbearing,
            "OUTERSHELL" => IfcBuildingSystemTypeEnum::Outershell,
            "SHADING" => IfcBuildingSystemTypeEnum::Shading,
            "TRANSPORT" => IfcBuildingSystemTypeEnum::Transport,
            "USERDEFINED" => IfcBuildingSystemTypeEnum::Userdefined,
            "NOTDEFINED" => IfcBuildingSystemTypeEnum::Notdefined,
            _ => panic!("{} is not a valid value", value),
        }
    }
}
impl From<Parameter> for IfcBuildingSystemTypeEnum {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EnumValue(value) => value.into(),
                _ => panic!("parameter is not an enum value"),
            },
            Parameter::OmittedParameter => IfcBuildingSystemTypeEnum::default(),
            _ => panic!("parameter is not an enum value"),
        }
    }
}
#[derive(Eq, PartialEq, Hash, Debug)]
pub enum IfcBurnerTypeEnum {
    Userdefined,
    Notdefined,
}
impl Default for IfcBurnerTypeEnum {
    fn default() -> Self {
        IfcBurnerTypeEnum::Userdefined
    }
}
impl From<String> for IfcBurnerTypeEnum {
    fn from(value: String) -> Self {
        match value.as_str() {
            "USERDEFINED" => IfcBurnerTypeEnum::Userdefined,
            "NOTDEFINED" => IfcBurnerTypeEnum::Notdefined,
            _ => panic!("{} is not a valid value", value),
        }
    }
}
impl From<Parameter> for IfcBurnerTypeEnum {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EnumValue(value) => value.into(),
                _ => panic!("parameter is not an enum value"),
            },
            Parameter::OmittedParameter => IfcBurnerTypeEnum::default(),
            _ => panic!("parameter is not an enum value"),
        }
    }
}
#[derive(Eq, PartialEq, Hash, Debug)]
pub enum IfcCableCarrierFittingTypeEnum {
    Bend,
    Cross,
    Reducer,
    Tee,
    Userdefined,
    Notdefined,
}
impl Default for IfcCableCarrierFittingTypeEnum {
    fn default() -> Self {
        IfcCableCarrierFittingTypeEnum::Bend
    }
}
impl From<String> for IfcCableCarrierFittingTypeEnum {
    fn from(value: String) -> Self {
        match value.as_str() {
            "BEND" => IfcCableCarrierFittingTypeEnum::Bend,
            "CROSS" => IfcCableCarrierFittingTypeEnum::Cross,
            "REDUCER" => IfcCableCarrierFittingTypeEnum::Reducer,
            "TEE" => IfcCableCarrierFittingTypeEnum::Tee,
            "USERDEFINED" => IfcCableCarrierFittingTypeEnum::Userdefined,
            "NOTDEFINED" => IfcCableCarrierFittingTypeEnum::Notdefined,
            _ => panic!("{} is not a valid value", value),
        }
    }
}
impl From<Parameter> for IfcCableCarrierFittingTypeEnum {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EnumValue(value) => value.into(),
                _ => panic!("parameter is not an enum value"),
            },
            Parameter::OmittedParameter => IfcCableCarrierFittingTypeEnum::default(),
            _ => panic!("parameter is not an enum value"),
        }
    }
}
#[derive(Eq, PartialEq, Hash, Debug)]
pub enum IfcCableCarrierSegmentTypeEnum {
    Cableladdersegment,
    Cabletraysegment,
    Cabletrunkingsegment,
    Conduitsegment,
    Userdefined,
    Notdefined,
}
impl Default for IfcCableCarrierSegmentTypeEnum {
    fn default() -> Self {
        IfcCableCarrierSegmentTypeEnum::Cableladdersegment
    }
}
impl From<String> for IfcCableCarrierSegmentTypeEnum {
    fn from(value: String) -> Self {
        match value.as_str() {
            "CABLELADDERSEGMENT" => IfcCableCarrierSegmentTypeEnum::Cableladdersegment,
            "CABLETRAYSEGMENT" => IfcCableCarrierSegmentTypeEnum::Cabletraysegment,
            "CABLETRUNKINGSEGMENT" => IfcCableCarrierSegmentTypeEnum::Cabletrunkingsegment,
            "CONDUITSEGMENT" => IfcCableCarrierSegmentTypeEnum::Conduitsegment,
            "USERDEFINED" => IfcCableCarrierSegmentTypeEnum::Userdefined,
            "NOTDEFINED" => IfcCableCarrierSegmentTypeEnum::Notdefined,
            _ => panic!("{} is not a valid value", value),
        }
    }
}
impl From<Parameter> for IfcCableCarrierSegmentTypeEnum {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EnumValue(value) => value.into(),
                _ => panic!("parameter is not an enum value"),
            },
            Parameter::OmittedParameter => IfcCableCarrierSegmentTypeEnum::default(),
            _ => panic!("parameter is not an enum value"),
        }
    }
}
#[derive(Eq, PartialEq, Hash, Debug)]
pub enum IfcCableFittingTypeEnum {
    Connector,
    Entry,
    Exit,
    Junction,
    Transition,
    Userdefined,
    Notdefined,
}
impl Default for IfcCableFittingTypeEnum {
    fn default() -> Self {
        IfcCableFittingTypeEnum::Connector
    }
}
impl From<String> for IfcCableFittingTypeEnum {
    fn from(value: String) -> Self {
        match value.as_str() {
            "CONNECTOR" => IfcCableFittingTypeEnum::Connector,
            "ENTRY" => IfcCableFittingTypeEnum::Entry,
            "EXIT" => IfcCableFittingTypeEnum::Exit,
            "JUNCTION" => IfcCableFittingTypeEnum::Junction,
            "TRANSITION" => IfcCableFittingTypeEnum::Transition,
            "USERDEFINED" => IfcCableFittingTypeEnum::Userdefined,
            "NOTDEFINED" => IfcCableFittingTypeEnum::Notdefined,
            _ => panic!("{} is not a valid value", value),
        }
    }
}
impl From<Parameter> for IfcCableFittingTypeEnum {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EnumValue(value) => value.into(),
                _ => panic!("parameter is not an enum value"),
            },
            Parameter::OmittedParameter => IfcCableFittingTypeEnum::default(),
            _ => panic!("parameter is not an enum value"),
        }
    }
}
#[derive(Eq, PartialEq, Hash, Debug)]
pub enum IfcCableSegmentTypeEnum {
    Busbarsegment,
    Cablesegment,
    Conductorsegment,
    Coresegment,
    Userdefined,
    Notdefined,
}
impl Default for IfcCableSegmentTypeEnum {
    fn default() -> Self {
        IfcCableSegmentTypeEnum::Busbarsegment
    }
}
impl From<String> for IfcCableSegmentTypeEnum {
    fn from(value: String) -> Self {
        match value.as_str() {
            "BUSBARSEGMENT" => IfcCableSegmentTypeEnum::Busbarsegment,
            "CABLESEGMENT" => IfcCableSegmentTypeEnum::Cablesegment,
            "CONDUCTORSEGMENT" => IfcCableSegmentTypeEnum::Conductorsegment,
            "CORESEGMENT" => IfcCableSegmentTypeEnum::Coresegment,
            "USERDEFINED" => IfcCableSegmentTypeEnum::Userdefined,
            "NOTDEFINED" => IfcCableSegmentTypeEnum::Notdefined,
            _ => panic!("{} is not a valid value", value),
        }
    }
}
impl From<Parameter> for IfcCableSegmentTypeEnum {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EnumValue(value) => value.into(),
                _ => panic!("parameter is not an enum value"),
            },
            Parameter::OmittedParameter => IfcCableSegmentTypeEnum::default(),
            _ => panic!("parameter is not an enum value"),
        }
    }
}
#[derive(Eq, PartialEq, Hash, Debug)]
pub enum IfcChangeActionEnum {
    Nochange,
    Modified,
    Added,
    Deleted,
    Notdefined,
}
impl Default for IfcChangeActionEnum {
    fn default() -> Self {
        IfcChangeActionEnum::Nochange
    }
}
impl From<String> for IfcChangeActionEnum {
    fn from(value: String) -> Self {
        match value.as_str() {
            "NOCHANGE" => IfcChangeActionEnum::Nochange,
            "MODIFIED" => IfcChangeActionEnum::Modified,
            "ADDED" => IfcChangeActionEnum::Added,
            "DELETED" => IfcChangeActionEnum::Deleted,
            "NOTDEFINED" => IfcChangeActionEnum::Notdefined,
            _ => panic!("{} is not a valid value", value),
        }
    }
}
impl From<Parameter> for IfcChangeActionEnum {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EnumValue(value) => value.into(),
                _ => panic!("parameter is not an enum value"),
            },
            Parameter::OmittedParameter => IfcChangeActionEnum::default(),
            _ => panic!("parameter is not an enum value"),
        }
    }
}
#[derive(Eq, PartialEq, Hash, Debug)]
pub enum IfcChillerTypeEnum {
    Aircooled,
    Watercooled,
    Heatrecovery,
    Userdefined,
    Notdefined,
}
impl Default for IfcChillerTypeEnum {
    fn default() -> Self {
        IfcChillerTypeEnum::Aircooled
    }
}
impl From<String> for IfcChillerTypeEnum {
    fn from(value: String) -> Self {
        match value.as_str() {
            "AIRCOOLED" => IfcChillerTypeEnum::Aircooled,
            "WATERCOOLED" => IfcChillerTypeEnum::Watercooled,
            "HEATRECOVERY" => IfcChillerTypeEnum::Heatrecovery,
            "USERDEFINED" => IfcChillerTypeEnum::Userdefined,
            "NOTDEFINED" => IfcChillerTypeEnum::Notdefined,
            _ => panic!("{} is not a valid value", value),
        }
    }
}
impl From<Parameter> for IfcChillerTypeEnum {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EnumValue(value) => value.into(),
                _ => panic!("parameter is not an enum value"),
            },
            Parameter::OmittedParameter => IfcChillerTypeEnum::default(),
            _ => panic!("parameter is not an enum value"),
        }
    }
}
#[derive(Eq, PartialEq, Hash, Debug)]
pub enum IfcChimneyTypeEnum {
    Userdefined,
    Notdefined,
}
impl Default for IfcChimneyTypeEnum {
    fn default() -> Self {
        IfcChimneyTypeEnum::Userdefined
    }
}
impl From<String> for IfcChimneyTypeEnum {
    fn from(value: String) -> Self {
        match value.as_str() {
            "USERDEFINED" => IfcChimneyTypeEnum::Userdefined,
            "NOTDEFINED" => IfcChimneyTypeEnum::Notdefined,
            _ => panic!("{} is not a valid value", value),
        }
    }
}
impl From<Parameter> for IfcChimneyTypeEnum {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EnumValue(value) => value.into(),
                _ => panic!("parameter is not an enum value"),
            },
            Parameter::OmittedParameter => IfcChimneyTypeEnum::default(),
            _ => panic!("parameter is not an enum value"),
        }
    }
}
#[derive(Eq, PartialEq, Hash, Debug)]
pub enum IfcCoilTypeEnum {
    Dxcoolingcoil,
    Electricheatingcoil,
    Gasheatingcoil,
    Hydroniccoil,
    Steamheatingcoil,
    Watercoolingcoil,
    Waterheatingcoil,
    Userdefined,
    Notdefined,
}
impl Default for IfcCoilTypeEnum {
    fn default() -> Self {
        IfcCoilTypeEnum::Dxcoolingcoil
    }
}
impl From<String> for IfcCoilTypeEnum {
    fn from(value: String) -> Self {
        match value.as_str() {
            "DXCOOLINGCOIL" => IfcCoilTypeEnum::Dxcoolingcoil,
            "ELECTRICHEATINGCOIL" => IfcCoilTypeEnum::Electricheatingcoil,
            "GASHEATINGCOIL" => IfcCoilTypeEnum::Gasheatingcoil,
            "HYDRONICCOIL" => IfcCoilTypeEnum::Hydroniccoil,
            "STEAMHEATINGCOIL" => IfcCoilTypeEnum::Steamheatingcoil,
            "WATERCOOLINGCOIL" => IfcCoilTypeEnum::Watercoolingcoil,
            "WATERHEATINGCOIL" => IfcCoilTypeEnum::Waterheatingcoil,
            "USERDEFINED" => IfcCoilTypeEnum::Userdefined,
            "NOTDEFINED" => IfcCoilTypeEnum::Notdefined,
            _ => panic!("{} is not a valid value", value),
        }
    }
}
impl From<Parameter> for IfcCoilTypeEnum {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EnumValue(value) => value.into(),
                _ => panic!("parameter is not an enum value"),
            },
            Parameter::OmittedParameter => IfcCoilTypeEnum::default(),
            _ => panic!("parameter is not an enum value"),
        }
    }
}
#[derive(Eq, PartialEq, Hash, Debug)]
pub enum IfcColumnTypeEnum {
    Column,
    Pilaster,
    Userdefined,
    Notdefined,
}
impl Default for IfcColumnTypeEnum {
    fn default() -> Self {
        IfcColumnTypeEnum::Column
    }
}
impl From<String> for IfcColumnTypeEnum {
    fn from(value: String) -> Self {
        match value.as_str() {
            "COLUMN" => IfcColumnTypeEnum::Column,
            "PILASTER" => IfcColumnTypeEnum::Pilaster,
            "USERDEFINED" => IfcColumnTypeEnum::Userdefined,
            "NOTDEFINED" => IfcColumnTypeEnum::Notdefined,
            _ => panic!("{} is not a valid value", value),
        }
    }
}
impl From<Parameter> for IfcColumnTypeEnum {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EnumValue(value) => value.into(),
                _ => panic!("parameter is not an enum value"),
            },
            Parameter::OmittedParameter => IfcColumnTypeEnum::default(),
            _ => panic!("parameter is not an enum value"),
        }
    }
}
#[derive(Eq, PartialEq, Hash, Debug)]
pub enum IfcCommunicationsApplianceTypeEnum {
    Antenna,
    Computer,
    Fax,
    Gateway,
    Modem,
    Networkappliance,
    Networkbridge,
    Networkhub,
    Printer,
    Repeater,
    Router,
    Scanner,
    Userdefined,
    Notdefined,
}
impl Default for IfcCommunicationsApplianceTypeEnum {
    fn default() -> Self {
        IfcCommunicationsApplianceTypeEnum::Antenna
    }
}
impl From<String> for IfcCommunicationsApplianceTypeEnum {
    fn from(value: String) -> Self {
        match value.as_str() {
            "ANTENNA" => IfcCommunicationsApplianceTypeEnum::Antenna,
            "COMPUTER" => IfcCommunicationsApplianceTypeEnum::Computer,
            "FAX" => IfcCommunicationsApplianceTypeEnum::Fax,
            "GATEWAY" => IfcCommunicationsApplianceTypeEnum::Gateway,
            "MODEM" => IfcCommunicationsApplianceTypeEnum::Modem,
            "NETWORKAPPLIANCE" => IfcCommunicationsApplianceTypeEnum::Networkappliance,
            "NETWORKBRIDGE" => IfcCommunicationsApplianceTypeEnum::Networkbridge,
            "NETWORKHUB" => IfcCommunicationsApplianceTypeEnum::Networkhub,
            "PRINTER" => IfcCommunicationsApplianceTypeEnum::Printer,
            "REPEATER" => IfcCommunicationsApplianceTypeEnum::Repeater,
            "ROUTER" => IfcCommunicationsApplianceTypeEnum::Router,
            "SCANNER" => IfcCommunicationsApplianceTypeEnum::Scanner,
            "USERDEFINED" => IfcCommunicationsApplianceTypeEnum::Userdefined,
            "NOTDEFINED" => IfcCommunicationsApplianceTypeEnum::Notdefined,
            _ => panic!("{} is not a valid value", value),
        }
    }
}
impl From<Parameter> for IfcCommunicationsApplianceTypeEnum {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EnumValue(value) => value.into(),
                _ => panic!("parameter is not an enum value"),
            },
            Parameter::OmittedParameter => IfcCommunicationsApplianceTypeEnum::default(),
            _ => panic!("parameter is not an enum value"),
        }
    }
}
#[derive(Eq, PartialEq, Hash, Debug)]
pub enum IfcComplexPropertyTemplateTypeEnum {
    PComplex,
    QComplex,
}
impl Default for IfcComplexPropertyTemplateTypeEnum {
    fn default() -> Self {
        IfcComplexPropertyTemplateTypeEnum::PComplex
    }
}
impl From<String> for IfcComplexPropertyTemplateTypeEnum {
    fn from(value: String) -> Self {
        match value.as_str() {
            "P_COMPLEX" => IfcComplexPropertyTemplateTypeEnum::PComplex,
            "Q_COMPLEX" => IfcComplexPropertyTemplateTypeEnum::QComplex,
            _ => panic!("{} is not a valid value", value),
        }
    }
}
impl From<Parameter> for IfcComplexPropertyTemplateTypeEnum {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EnumValue(value) => value.into(),
                _ => panic!("parameter is not an enum value"),
            },
            Parameter::OmittedParameter => IfcComplexPropertyTemplateTypeEnum::default(),
            _ => panic!("parameter is not an enum value"),
        }
    }
}
#[derive(Eq, PartialEq, Hash, Debug)]
pub enum IfcCompressorTypeEnum {
    Dynamic,
    Reciprocating,
    Rotary,
    Scroll,
    Trochoidal,
    Singlestage,
    Booster,
    Opentype,
    Hermetic,
    Semihermetic,
    Weldedshellhermetic,
    Rollingpiston,
    Rotaryvane,
    Singlescrew,
    Twinscrew,
    Userdefined,
    Notdefined,
}
impl Default for IfcCompressorTypeEnum {
    fn default() -> Self {
        IfcCompressorTypeEnum::Dynamic
    }
}
impl From<String> for IfcCompressorTypeEnum {
    fn from(value: String) -> Self {
        match value.as_str() {
            "DYNAMIC" => IfcCompressorTypeEnum::Dynamic,
            "RECIPROCATING" => IfcCompressorTypeEnum::Reciprocating,
            "ROTARY" => IfcCompressorTypeEnum::Rotary,
            "SCROLL" => IfcCompressorTypeEnum::Scroll,
            "TROCHOIDAL" => IfcCompressorTypeEnum::Trochoidal,
            "SINGLESTAGE" => IfcCompressorTypeEnum::Singlestage,
            "BOOSTER" => IfcCompressorTypeEnum::Booster,
            "OPENTYPE" => IfcCompressorTypeEnum::Opentype,
            "HERMETIC" => IfcCompressorTypeEnum::Hermetic,
            "SEMIHERMETIC" => IfcCompressorTypeEnum::Semihermetic,
            "WELDEDSHELLHERMETIC" => IfcCompressorTypeEnum::Weldedshellhermetic,
            "ROLLINGPISTON" => IfcCompressorTypeEnum::Rollingpiston,
            "ROTARYVANE" => IfcCompressorTypeEnum::Rotaryvane,
            "SINGLESCREW" => IfcCompressorTypeEnum::Singlescrew,
            "TWINSCREW" => IfcCompressorTypeEnum::Twinscrew,
            "USERDEFINED" => IfcCompressorTypeEnum::Userdefined,
            "NOTDEFINED" => IfcCompressorTypeEnum::Notdefined,
            _ => panic!("{} is not a valid value", value),
        }
    }
}
impl From<Parameter> for IfcCompressorTypeEnum {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EnumValue(value) => value.into(),
                _ => panic!("parameter is not an enum value"),
            },
            Parameter::OmittedParameter => IfcCompressorTypeEnum::default(),
            _ => panic!("parameter is not an enum value"),
        }
    }
}
#[derive(Eq, PartialEq, Hash, Debug)]
pub enum IfcCondenserTypeEnum {
    Aircooled,
    Evaporativecooled,
    Watercooled,
    Watercooledbrazedplate,
    Watercooledshellcoil,
    Watercooledshelltube,
    Watercooledtubeintube,
    Userdefined,
    Notdefined,
}
impl Default for IfcCondenserTypeEnum {
    fn default() -> Self {
        IfcCondenserTypeEnum::Aircooled
    }
}
impl From<String> for IfcCondenserTypeEnum {
    fn from(value: String) -> Self {
        match value.as_str() {
            "AIRCOOLED" => IfcCondenserTypeEnum::Aircooled,
            "EVAPORATIVECOOLED" => IfcCondenserTypeEnum::Evaporativecooled,
            "WATERCOOLED" => IfcCondenserTypeEnum::Watercooled,
            "WATERCOOLEDBRAZEDPLATE" => IfcCondenserTypeEnum::Watercooledbrazedplate,
            "WATERCOOLEDSHELLCOIL" => IfcCondenserTypeEnum::Watercooledshellcoil,
            "WATERCOOLEDSHELLTUBE" => IfcCondenserTypeEnum::Watercooledshelltube,
            "WATERCOOLEDTUBEINTUBE" => IfcCondenserTypeEnum::Watercooledtubeintube,
            "USERDEFINED" => IfcCondenserTypeEnum::Userdefined,
            "NOTDEFINED" => IfcCondenserTypeEnum::Notdefined,
            _ => panic!("{} is not a valid value", value),
        }
    }
}
impl From<Parameter> for IfcCondenserTypeEnum {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EnumValue(value) => value.into(),
                _ => panic!("parameter is not an enum value"),
            },
            Parameter::OmittedParameter => IfcCondenserTypeEnum::default(),
            _ => panic!("parameter is not an enum value"),
        }
    }
}
#[derive(Eq, PartialEq, Hash, Debug)]
pub enum IfcConnectionTypeEnum {
    Atpath,
    Atstart,
    Atend,
    Notdefined,
}
impl Default for IfcConnectionTypeEnum {
    fn default() -> Self {
        IfcConnectionTypeEnum::Atpath
    }
}
impl From<String> for IfcConnectionTypeEnum {
    fn from(value: String) -> Self {
        match value.as_str() {
            "ATPATH" => IfcConnectionTypeEnum::Atpath,
            "ATSTART" => IfcConnectionTypeEnum::Atstart,
            "ATEND" => IfcConnectionTypeEnum::Atend,
            "NOTDEFINED" => IfcConnectionTypeEnum::Notdefined,
            _ => panic!("{} is not a valid value", value),
        }
    }
}
impl From<Parameter> for IfcConnectionTypeEnum {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EnumValue(value) => value.into(),
                _ => panic!("parameter is not an enum value"),
            },
            Parameter::OmittedParameter => IfcConnectionTypeEnum::default(),
            _ => panic!("parameter is not an enum value"),
        }
    }
}
#[derive(Eq, PartialEq, Hash, Debug)]
pub enum IfcConstraintEnum {
    Hard,
    Soft,
    Advisory,
    Userdefined,
    Notdefined,
}
impl Default for IfcConstraintEnum {
    fn default() -> Self {
        IfcConstraintEnum::Hard
    }
}
impl From<String> for IfcConstraintEnum {
    fn from(value: String) -> Self {
        match value.as_str() {
            "HARD" => IfcConstraintEnum::Hard,
            "SOFT" => IfcConstraintEnum::Soft,
            "ADVISORY" => IfcConstraintEnum::Advisory,
            "USERDEFINED" => IfcConstraintEnum::Userdefined,
            "NOTDEFINED" => IfcConstraintEnum::Notdefined,
            _ => panic!("{} is not a valid value", value),
        }
    }
}
impl From<Parameter> for IfcConstraintEnum {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EnumValue(value) => value.into(),
                _ => panic!("parameter is not an enum value"),
            },
            Parameter::OmittedParameter => IfcConstraintEnum::default(),
            _ => panic!("parameter is not an enum value"),
        }
    }
}
#[derive(Eq, PartialEq, Hash, Debug)]
pub enum IfcConstructionEquipmentResourceTypeEnum {
    Demolishing,
    Earthmoving,
    Erecting,
    Heating,
    Lighting,
    Paving,
    Pumping,
    Transporting,
    Userdefined,
    Notdefined,
}
impl Default for IfcConstructionEquipmentResourceTypeEnum {
    fn default() -> Self {
        IfcConstructionEquipmentResourceTypeEnum::Demolishing
    }
}
impl From<String> for IfcConstructionEquipmentResourceTypeEnum {
    fn from(value: String) -> Self {
        match value.as_str() {
            "DEMOLISHING" => IfcConstructionEquipmentResourceTypeEnum::Demolishing,
            "EARTHMOVING" => IfcConstructionEquipmentResourceTypeEnum::Earthmoving,
            "ERECTING" => IfcConstructionEquipmentResourceTypeEnum::Erecting,
            "HEATING" => IfcConstructionEquipmentResourceTypeEnum::Heating,
            "LIGHTING" => IfcConstructionEquipmentResourceTypeEnum::Lighting,
            "PAVING" => IfcConstructionEquipmentResourceTypeEnum::Paving,
            "PUMPING" => IfcConstructionEquipmentResourceTypeEnum::Pumping,
            "TRANSPORTING" => IfcConstructionEquipmentResourceTypeEnum::Transporting,
            "USERDEFINED" => IfcConstructionEquipmentResourceTypeEnum::Userdefined,
            "NOTDEFINED" => IfcConstructionEquipmentResourceTypeEnum::Notdefined,
            _ => panic!("{} is not a valid value", value),
        }
    }
}
impl From<Parameter> for IfcConstructionEquipmentResourceTypeEnum {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EnumValue(value) => value.into(),
                _ => panic!("parameter is not an enum value"),
            },
            Parameter::OmittedParameter => IfcConstructionEquipmentResourceTypeEnum::default(),
            _ => panic!("parameter is not an enum value"),
        }
    }
}
#[derive(Eq, PartialEq, Hash, Debug)]
pub enum IfcConstructionMaterialResourceTypeEnum {
    Aggregates,
    Concrete,
    Drywall,
    Fuel,
    Gypsum,
    Masonry,
    Metal,
    Plastic,
    Wood,
    Notdefined,
    Userdefined,
}
impl Default for IfcConstructionMaterialResourceTypeEnum {
    fn default() -> Self {
        IfcConstructionMaterialResourceTypeEnum::Aggregates
    }
}
impl From<String> for IfcConstructionMaterialResourceTypeEnum {
    fn from(value: String) -> Self {
        match value.as_str() {
            "AGGREGATES" => IfcConstructionMaterialResourceTypeEnum::Aggregates,
            "CONCRETE" => IfcConstructionMaterialResourceTypeEnum::Concrete,
            "DRYWALL" => IfcConstructionMaterialResourceTypeEnum::Drywall,
            "FUEL" => IfcConstructionMaterialResourceTypeEnum::Fuel,
            "GYPSUM" => IfcConstructionMaterialResourceTypeEnum::Gypsum,
            "MASONRY" => IfcConstructionMaterialResourceTypeEnum::Masonry,
            "METAL" => IfcConstructionMaterialResourceTypeEnum::Metal,
            "PLASTIC" => IfcConstructionMaterialResourceTypeEnum::Plastic,
            "WOOD" => IfcConstructionMaterialResourceTypeEnum::Wood,
            "NOTDEFINED" => IfcConstructionMaterialResourceTypeEnum::Notdefined,
            "USERDEFINED" => IfcConstructionMaterialResourceTypeEnum::Userdefined,
            _ => panic!("{} is not a valid value", value),
        }
    }
}
impl From<Parameter> for IfcConstructionMaterialResourceTypeEnum {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EnumValue(value) => value.into(),
                _ => panic!("parameter is not an enum value"),
            },
            Parameter::OmittedParameter => IfcConstructionMaterialResourceTypeEnum::default(),
            _ => panic!("parameter is not an enum value"),
        }
    }
}
#[derive(Eq, PartialEq, Hash, Debug)]
pub enum IfcConstructionProductResourceTypeEnum {
    Assembly,
    Formwork,
    Userdefined,
    Notdefined,
}
impl Default for IfcConstructionProductResourceTypeEnum {
    fn default() -> Self {
        IfcConstructionProductResourceTypeEnum::Assembly
    }
}
impl From<String> for IfcConstructionProductResourceTypeEnum {
    fn from(value: String) -> Self {
        match value.as_str() {
            "ASSEMBLY" => IfcConstructionProductResourceTypeEnum::Assembly,
            "FORMWORK" => IfcConstructionProductResourceTypeEnum::Formwork,
            "USERDEFINED" => IfcConstructionProductResourceTypeEnum::Userdefined,
            "NOTDEFINED" => IfcConstructionProductResourceTypeEnum::Notdefined,
            _ => panic!("{} is not a valid value", value),
        }
    }
}
impl From<Parameter> for IfcConstructionProductResourceTypeEnum {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EnumValue(value) => value.into(),
                _ => panic!("parameter is not an enum value"),
            },
            Parameter::OmittedParameter => IfcConstructionProductResourceTypeEnum::default(),
            _ => panic!("parameter is not an enum value"),
        }
    }
}
#[derive(Eq, PartialEq, Hash, Debug)]
pub enum IfcControllerTypeEnum {
    Floating,
    Programmable,
    Proportional,
    Multiposition,
    Twoposition,
    Userdefined,
    Notdefined,
}
impl Default for IfcControllerTypeEnum {
    fn default() -> Self {
        IfcControllerTypeEnum::Floating
    }
}
impl From<String> for IfcControllerTypeEnum {
    fn from(value: String) -> Self {
        match value.as_str() {
            "FLOATING" => IfcControllerTypeEnum::Floating,
            "PROGRAMMABLE" => IfcControllerTypeEnum::Programmable,
            "PROPORTIONAL" => IfcControllerTypeEnum::Proportional,
            "MULTIPOSITION" => IfcControllerTypeEnum::Multiposition,
            "TWOPOSITION" => IfcControllerTypeEnum::Twoposition,
            "USERDEFINED" => IfcControllerTypeEnum::Userdefined,
            "NOTDEFINED" => IfcControllerTypeEnum::Notdefined,
            _ => panic!("{} is not a valid value", value),
        }
    }
}
impl From<Parameter> for IfcControllerTypeEnum {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EnumValue(value) => value.into(),
                _ => panic!("parameter is not an enum value"),
            },
            Parameter::OmittedParameter => IfcControllerTypeEnum::default(),
            _ => panic!("parameter is not an enum value"),
        }
    }
}
#[derive(Eq, PartialEq, Hash, Debug)]
pub enum IfcCooledBeamTypeEnum {
    Active,
    Passive,
    Userdefined,
    Notdefined,
}
impl Default for IfcCooledBeamTypeEnum {
    fn default() -> Self {
        IfcCooledBeamTypeEnum::Active
    }
}
impl From<String> for IfcCooledBeamTypeEnum {
    fn from(value: String) -> Self {
        match value.as_str() {
            "ACTIVE" => IfcCooledBeamTypeEnum::Active,
            "PASSIVE" => IfcCooledBeamTypeEnum::Passive,
            "USERDEFINED" => IfcCooledBeamTypeEnum::Userdefined,
            "NOTDEFINED" => IfcCooledBeamTypeEnum::Notdefined,
            _ => panic!("{} is not a valid value", value),
        }
    }
}
impl From<Parameter> for IfcCooledBeamTypeEnum {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EnumValue(value) => value.into(),
                _ => panic!("parameter is not an enum value"),
            },
            Parameter::OmittedParameter => IfcCooledBeamTypeEnum::default(),
            _ => panic!("parameter is not an enum value"),
        }
    }
}
#[derive(Eq, PartialEq, Hash, Debug)]
pub enum IfcCoolingTowerTypeEnum {
    Naturaldraft,
    Mechanicalinduceddraft,
    Mechanicalforceddraft,
    Userdefined,
    Notdefined,
}
impl Default for IfcCoolingTowerTypeEnum {
    fn default() -> Self {
        IfcCoolingTowerTypeEnum::Naturaldraft
    }
}
impl From<String> for IfcCoolingTowerTypeEnum {
    fn from(value: String) -> Self {
        match value.as_str() {
            "NATURALDRAFT" => IfcCoolingTowerTypeEnum::Naturaldraft,
            "MECHANICALINDUCEDDRAFT" => IfcCoolingTowerTypeEnum::Mechanicalinduceddraft,
            "MECHANICALFORCEDDRAFT" => IfcCoolingTowerTypeEnum::Mechanicalforceddraft,
            "USERDEFINED" => IfcCoolingTowerTypeEnum::Userdefined,
            "NOTDEFINED" => IfcCoolingTowerTypeEnum::Notdefined,
            _ => panic!("{} is not a valid value", value),
        }
    }
}
impl From<Parameter> for IfcCoolingTowerTypeEnum {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EnumValue(value) => value.into(),
                _ => panic!("parameter is not an enum value"),
            },
            Parameter::OmittedParameter => IfcCoolingTowerTypeEnum::default(),
            _ => panic!("parameter is not an enum value"),
        }
    }
}
#[derive(Eq, PartialEq, Hash, Debug)]
pub enum IfcCostItemTypeEnum {
    Userdefined,
    Notdefined,
}
impl Default for IfcCostItemTypeEnum {
    fn default() -> Self {
        IfcCostItemTypeEnum::Userdefined
    }
}
impl From<String> for IfcCostItemTypeEnum {
    fn from(value: String) -> Self {
        match value.as_str() {
            "USERDEFINED" => IfcCostItemTypeEnum::Userdefined,
            "NOTDEFINED" => IfcCostItemTypeEnum::Notdefined,
            _ => panic!("{} is not a valid value", value),
        }
    }
}
impl From<Parameter> for IfcCostItemTypeEnum {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EnumValue(value) => value.into(),
                _ => panic!("parameter is not an enum value"),
            },
            Parameter::OmittedParameter => IfcCostItemTypeEnum::default(),
            _ => panic!("parameter is not an enum value"),
        }
    }
}
#[derive(Eq, PartialEq, Hash, Debug)]
pub enum IfcCostScheduleTypeEnum {
    Budget,
    Costplan,
    Estimate,
    Tender,
    Pricedbillofquantities,
    Unpricedbillofquantities,
    Scheduleofrates,
    Userdefined,
    Notdefined,
}
impl Default for IfcCostScheduleTypeEnum {
    fn default() -> Self {
        IfcCostScheduleTypeEnum::Budget
    }
}
impl From<String> for IfcCostScheduleTypeEnum {
    fn from(value: String) -> Self {
        match value.as_str() {
            "BUDGET" => IfcCostScheduleTypeEnum::Budget,
            "COSTPLAN" => IfcCostScheduleTypeEnum::Costplan,
            "ESTIMATE" => IfcCostScheduleTypeEnum::Estimate,
            "TENDER" => IfcCostScheduleTypeEnum::Tender,
            "PRICEDBILLOFQUANTITIES" => IfcCostScheduleTypeEnum::Pricedbillofquantities,
            "UNPRICEDBILLOFQUANTITIES" => IfcCostScheduleTypeEnum::Unpricedbillofquantities,
            "SCHEDULEOFRATES" => IfcCostScheduleTypeEnum::Scheduleofrates,
            "USERDEFINED" => IfcCostScheduleTypeEnum::Userdefined,
            "NOTDEFINED" => IfcCostScheduleTypeEnum::Notdefined,
            _ => panic!("{} is not a valid value", value),
        }
    }
}
impl From<Parameter> for IfcCostScheduleTypeEnum {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EnumValue(value) => value.into(),
                _ => panic!("parameter is not an enum value"),
            },
            Parameter::OmittedParameter => IfcCostScheduleTypeEnum::default(),
            _ => panic!("parameter is not an enum value"),
        }
    }
}
#[derive(Eq, PartialEq, Hash, Debug)]
pub enum IfcCoveringTypeEnum {
    Ceiling,
    Flooring,
    Cladding,
    Roofing,
    Molding,
    Skirtingboard,
    Insulation,
    Membrane,
    Sleeving,
    Wrapping,
    Userdefined,
    Notdefined,
}
impl Default for IfcCoveringTypeEnum {
    fn default() -> Self {
        IfcCoveringTypeEnum::Ceiling
    }
}
impl From<String> for IfcCoveringTypeEnum {
    fn from(value: String) -> Self {
        match value.as_str() {
            "CEILING" => IfcCoveringTypeEnum::Ceiling,
            "FLOORING" => IfcCoveringTypeEnum::Flooring,
            "CLADDING" => IfcCoveringTypeEnum::Cladding,
            "ROOFING" => IfcCoveringTypeEnum::Roofing,
            "MOLDING" => IfcCoveringTypeEnum::Molding,
            "SKIRTINGBOARD" => IfcCoveringTypeEnum::Skirtingboard,
            "INSULATION" => IfcCoveringTypeEnum::Insulation,
            "MEMBRANE" => IfcCoveringTypeEnum::Membrane,
            "SLEEVING" => IfcCoveringTypeEnum::Sleeving,
            "WRAPPING" => IfcCoveringTypeEnum::Wrapping,
            "USERDEFINED" => IfcCoveringTypeEnum::Userdefined,
            "NOTDEFINED" => IfcCoveringTypeEnum::Notdefined,
            _ => panic!("{} is not a valid value", value),
        }
    }
}
impl From<Parameter> for IfcCoveringTypeEnum {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EnumValue(value) => value.into(),
                _ => panic!("parameter is not an enum value"),
            },
            Parameter::OmittedParameter => IfcCoveringTypeEnum::default(),
            _ => panic!("parameter is not an enum value"),
        }
    }
}
#[derive(Eq, PartialEq, Hash, Debug)]
pub enum IfcCrewResourceTypeEnum {
    Office,
    Site,
    Userdefined,
    Notdefined,
}
impl Default for IfcCrewResourceTypeEnum {
    fn default() -> Self {
        IfcCrewResourceTypeEnum::Office
    }
}
impl From<String> for IfcCrewResourceTypeEnum {
    fn from(value: String) -> Self {
        match value.as_str() {
            "OFFICE" => IfcCrewResourceTypeEnum::Office,
            "SITE" => IfcCrewResourceTypeEnum::Site,
            "USERDEFINED" => IfcCrewResourceTypeEnum::Userdefined,
            "NOTDEFINED" => IfcCrewResourceTypeEnum::Notdefined,
            _ => panic!("{} is not a valid value", value),
        }
    }
}
impl From<Parameter> for IfcCrewResourceTypeEnum {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EnumValue(value) => value.into(),
                _ => panic!("parameter is not an enum value"),
            },
            Parameter::OmittedParameter => IfcCrewResourceTypeEnum::default(),
            _ => panic!("parameter is not an enum value"),
        }
    }
}
#[derive(Eq, PartialEq, Hash, Debug)]
pub enum IfcCurtainWallTypeEnum {
    Userdefined,
    Notdefined,
}
impl Default for IfcCurtainWallTypeEnum {
    fn default() -> Self {
        IfcCurtainWallTypeEnum::Userdefined
    }
}
impl From<String> for IfcCurtainWallTypeEnum {
    fn from(value: String) -> Self {
        match value.as_str() {
            "USERDEFINED" => IfcCurtainWallTypeEnum::Userdefined,
            "NOTDEFINED" => IfcCurtainWallTypeEnum::Notdefined,
            _ => panic!("{} is not a valid value", value),
        }
    }
}
impl From<Parameter> for IfcCurtainWallTypeEnum {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EnumValue(value) => value.into(),
                _ => panic!("parameter is not an enum value"),
            },
            Parameter::OmittedParameter => IfcCurtainWallTypeEnum::default(),
            _ => panic!("parameter is not an enum value"),
        }
    }
}
#[derive(Eq, PartialEq, Hash, Debug)]
pub enum IfcCurveInterpolationEnum {
    Linear,
    LogLinear,
    LogLog,
    Notdefined,
}
impl Default for IfcCurveInterpolationEnum {
    fn default() -> Self {
        IfcCurveInterpolationEnum::Linear
    }
}
impl From<String> for IfcCurveInterpolationEnum {
    fn from(value: String) -> Self {
        match value.as_str() {
            "LINEAR" => IfcCurveInterpolationEnum::Linear,
            "LOG_LINEAR" => IfcCurveInterpolationEnum::LogLinear,
            "LOG_LOG" => IfcCurveInterpolationEnum::LogLog,
            "NOTDEFINED" => IfcCurveInterpolationEnum::Notdefined,
            _ => panic!("{} is not a valid value", value),
        }
    }
}
impl From<Parameter> for IfcCurveInterpolationEnum {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EnumValue(value) => value.into(),
                _ => panic!("parameter is not an enum value"),
            },
            Parameter::OmittedParameter => IfcCurveInterpolationEnum::default(),
            _ => panic!("parameter is not an enum value"),
        }
    }
}
#[derive(Eq, PartialEq, Hash, Debug)]
pub enum IfcDamperTypeEnum {
    Backdraftdamper,
    Balancingdamper,
    Blastdamper,
    Controldamper,
    Firedamper,
    Firesmokedamper,
    Fumehoodexhaust,
    Gravitydamper,
    Gravityreliefdamper,
    Reliefdamper,
    Smokedamper,
    Userdefined,
    Notdefined,
}
impl Default for IfcDamperTypeEnum {
    fn default() -> Self {
        IfcDamperTypeEnum::Backdraftdamper
    }
}
impl From<String> for IfcDamperTypeEnum {
    fn from(value: String) -> Self {
        match value.as_str() {
            "BACKDRAFTDAMPER" => IfcDamperTypeEnum::Backdraftdamper,
            "BALANCINGDAMPER" => IfcDamperTypeEnum::Balancingdamper,
            "BLASTDAMPER" => IfcDamperTypeEnum::Blastdamper,
            "CONTROLDAMPER" => IfcDamperTypeEnum::Controldamper,
            "FIREDAMPER" => IfcDamperTypeEnum::Firedamper,
            "FIRESMOKEDAMPER" => IfcDamperTypeEnum::Firesmokedamper,
            "FUMEHOODEXHAUST" => IfcDamperTypeEnum::Fumehoodexhaust,
            "GRAVITYDAMPER" => IfcDamperTypeEnum::Gravitydamper,
            "GRAVITYRELIEFDAMPER" => IfcDamperTypeEnum::Gravityreliefdamper,
            "RELIEFDAMPER" => IfcDamperTypeEnum::Reliefdamper,
            "SMOKEDAMPER" => IfcDamperTypeEnum::Smokedamper,
            "USERDEFINED" => IfcDamperTypeEnum::Userdefined,
            "NOTDEFINED" => IfcDamperTypeEnum::Notdefined,
            _ => panic!("{} is not a valid value", value),
        }
    }
}
impl From<Parameter> for IfcDamperTypeEnum {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EnumValue(value) => value.into(),
                _ => panic!("parameter is not an enum value"),
            },
            Parameter::OmittedParameter => IfcDamperTypeEnum::default(),
            _ => panic!("parameter is not an enum value"),
        }
    }
}
#[derive(Eq, PartialEq, Hash, Debug)]
pub enum IfcDataOriginEnum {
    Measured,
    Predicted,
    Simulated,
    Userdefined,
    Notdefined,
}
impl Default for IfcDataOriginEnum {
    fn default() -> Self {
        IfcDataOriginEnum::Measured
    }
}
impl From<String> for IfcDataOriginEnum {
    fn from(value: String) -> Self {
        match value.as_str() {
            "MEASURED" => IfcDataOriginEnum::Measured,
            "PREDICTED" => IfcDataOriginEnum::Predicted,
            "SIMULATED" => IfcDataOriginEnum::Simulated,
            "USERDEFINED" => IfcDataOriginEnum::Userdefined,
            "NOTDEFINED" => IfcDataOriginEnum::Notdefined,
            _ => panic!("{} is not a valid value", value),
        }
    }
}
impl From<Parameter> for IfcDataOriginEnum {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EnumValue(value) => value.into(),
                _ => panic!("parameter is not an enum value"),
            },
            Parameter::OmittedParameter => IfcDataOriginEnum::default(),
            _ => panic!("parameter is not an enum value"),
        }
    }
}
#[derive(Eq, PartialEq, Hash, Debug)]
pub enum IfcDerivedUnitEnum {
    Angularvelocityunit,
    Areadensityunit,
    Compoundplaneangleunit,
    Dynamicviscosityunit,
    Heatfluxdensityunit,
    Integercountrateunit,
    Isothermalmoisturecapacityunit,
    Kinematicviscosityunit,
    Linearvelocityunit,
    Massdensityunit,
    Massflowrateunit,
    Moisturediffusivityunit,
    Molecularweightunit,
    Specificheatcapacityunit,
    Thermaladmittanceunit,
    Thermalconductanceunit,
    Thermalresistanceunit,
    Thermaltransmittanceunit,
    Vaporpermeabilityunit,
    Volumetricflowrateunit,
    Rotationalfrequencyunit,
    Torqueunit,
    Momentofinertiaunit,
    Linearmomentunit,
    Linearforceunit,
    Planarforceunit,
    Modulusofelasticityunit,
    Shearmodulusunit,
    Linearstiffnessunit,
    Rotationalstiffnessunit,
    Modulusofsubgradereactionunit,
    Accelerationunit,
    Curvatureunit,
    Heatingvalueunit,
    Ionconcentrationunit,
    Luminousintensitydistributionunit,
    Massperlengthunit,
    Modulusoflinearsubgradereactionunit,
    Modulusofrotationalsubgradereactionunit,
    Phunit,
    Rotationalmassunit,
    Sectionareaintegralunit,
    Sectionmodulusunit,
    Soundpowerlevelunit,
    Soundpowerunit,
    Soundpressurelevelunit,
    Soundpressureunit,
    Temperaturegradientunit,
    Temperaturerateofchangeunit,
    Thermalexpansioncoefficientunit,
    Warpingconstantunit,
    Warpingmomentunit,
    Userdefined,
}
impl Default for IfcDerivedUnitEnum {
    fn default() -> Self {
        IfcDerivedUnitEnum::Angularvelocityunit
    }
}
impl From<String> for IfcDerivedUnitEnum {
    fn from(value: String) -> Self {
        match value.as_str() {
            "ANGULARVELOCITYUNIT" => IfcDerivedUnitEnum::Angularvelocityunit,
            "AREADENSITYUNIT" => IfcDerivedUnitEnum::Areadensityunit,
            "COMPOUNDPLANEANGLEUNIT" => IfcDerivedUnitEnum::Compoundplaneangleunit,
            "DYNAMICVISCOSITYUNIT" => IfcDerivedUnitEnum::Dynamicviscosityunit,
            "HEATFLUXDENSITYUNIT" => IfcDerivedUnitEnum::Heatfluxdensityunit,
            "INTEGERCOUNTRATEUNIT" => IfcDerivedUnitEnum::Integercountrateunit,
            "ISOTHERMALMOISTURECAPACITYUNIT" => IfcDerivedUnitEnum::Isothermalmoisturecapacityunit,
            "KINEMATICVISCOSITYUNIT" => IfcDerivedUnitEnum::Kinematicviscosityunit,
            "LINEARVELOCITYUNIT" => IfcDerivedUnitEnum::Linearvelocityunit,
            "MASSDENSITYUNIT" => IfcDerivedUnitEnum::Massdensityunit,
            "MASSFLOWRATEUNIT" => IfcDerivedUnitEnum::Massflowrateunit,
            "MOISTUREDIFFUSIVITYUNIT" => IfcDerivedUnitEnum::Moisturediffusivityunit,
            "MOLECULARWEIGHTUNIT" => IfcDerivedUnitEnum::Molecularweightunit,
            "SPECIFICHEATCAPACITYUNIT" => IfcDerivedUnitEnum::Specificheatcapacityunit,
            "THERMALADMITTANCEUNIT" => IfcDerivedUnitEnum::Thermaladmittanceunit,
            "THERMALCONDUCTANCEUNIT" => IfcDerivedUnitEnum::Thermalconductanceunit,
            "THERMALRESISTANCEUNIT" => IfcDerivedUnitEnum::Thermalresistanceunit,
            "THERMALTRANSMITTANCEUNIT" => IfcDerivedUnitEnum::Thermaltransmittanceunit,
            "VAPORPERMEABILITYUNIT" => IfcDerivedUnitEnum::Vaporpermeabilityunit,
            "VOLUMETRICFLOWRATEUNIT" => IfcDerivedUnitEnum::Volumetricflowrateunit,
            "ROTATIONALFREQUENCYUNIT" => IfcDerivedUnitEnum::Rotationalfrequencyunit,
            "TORQUEUNIT" => IfcDerivedUnitEnum::Torqueunit,
            "MOMENTOFINERTIAUNIT" => IfcDerivedUnitEnum::Momentofinertiaunit,
            "LINEARMOMENTUNIT" => IfcDerivedUnitEnum::Linearmomentunit,
            "LINEARFORCEUNIT" => IfcDerivedUnitEnum::Linearforceunit,
            "PLANARFORCEUNIT" => IfcDerivedUnitEnum::Planarforceunit,
            "MODULUSOFELASTICITYUNIT" => IfcDerivedUnitEnum::Modulusofelasticityunit,
            "SHEARMODULUSUNIT" => IfcDerivedUnitEnum::Shearmodulusunit,
            "LINEARSTIFFNESSUNIT" => IfcDerivedUnitEnum::Linearstiffnessunit,
            "ROTATIONALSTIFFNESSUNIT" => IfcDerivedUnitEnum::Rotationalstiffnessunit,
            "MODULUSOFSUBGRADEREACTIONUNIT" => IfcDerivedUnitEnum::Modulusofsubgradereactionunit,
            "ACCELERATIONUNIT" => IfcDerivedUnitEnum::Accelerationunit,
            "CURVATUREUNIT" => IfcDerivedUnitEnum::Curvatureunit,
            "HEATINGVALUEUNIT" => IfcDerivedUnitEnum::Heatingvalueunit,
            "IONCONCENTRATIONUNIT" => IfcDerivedUnitEnum::Ionconcentrationunit,
            "LUMINOUSINTENSITYDISTRIBUTIONUNIT" => IfcDerivedUnitEnum::Luminousintensitydistributionunit,
            "MASSPERLENGTHUNIT" => IfcDerivedUnitEnum::Massperlengthunit,
            "MODULUSOFLINEARSUBGRADEREACTIONUNIT" => IfcDerivedUnitEnum::Modulusoflinearsubgradereactionunit,
            "MODULUSOFROTATIONALSUBGRADEREACTIONUNIT" => IfcDerivedUnitEnum::Modulusofrotationalsubgradereactionunit,
            "PHUNIT" => IfcDerivedUnitEnum::Phunit,
            "ROTATIONALMASSUNIT" => IfcDerivedUnitEnum::Rotationalmassunit,
            "SECTIONAREAINTEGRALUNIT" => IfcDerivedUnitEnum::Sectionareaintegralunit,
            "SECTIONMODULUSUNIT" => IfcDerivedUnitEnum::Sectionmodulusunit,
            "SOUNDPOWERLEVELUNIT" => IfcDerivedUnitEnum::Soundpowerlevelunit,
            "SOUNDPOWERUNIT" => IfcDerivedUnitEnum::Soundpowerunit,
            "SOUNDPRESSURELEVELUNIT" => IfcDerivedUnitEnum::Soundpressurelevelunit,
            "SOUNDPRESSUREUNIT" => IfcDerivedUnitEnum::Soundpressureunit,
            "TEMPERATUREGRADIENTUNIT" => IfcDerivedUnitEnum::Temperaturegradientunit,
            "TEMPERATURERATEOFCHANGEUNIT" => IfcDerivedUnitEnum::Temperaturerateofchangeunit,
            "THERMALEXPANSIONCOEFFICIENTUNIT" => IfcDerivedUnitEnum::Thermalexpansioncoefficientunit,
            "WARPINGCONSTANTUNIT" => IfcDerivedUnitEnum::Warpingconstantunit,
            "WARPINGMOMENTUNIT" => IfcDerivedUnitEnum::Warpingmomentunit,
            "USERDEFINED" => IfcDerivedUnitEnum::Userdefined,
            _ => panic!("{} is not a valid value", value),
        }
    }
}
impl From<Parameter> for IfcDerivedUnitEnum {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EnumValue(value) => value.into(),
                _ => panic!("parameter is not an enum value"),
            },
            Parameter::OmittedParameter => IfcDerivedUnitEnum::default(),
            _ => panic!("parameter is not an enum value"),
        }
    }
}
#[derive(Eq, PartialEq, Hash, Debug)]
pub enum IfcDirectionSenseEnum {
    Positive,
    Negative,
}
impl Default for IfcDirectionSenseEnum {
    fn default() -> Self {
        IfcDirectionSenseEnum::Positive
    }
}
impl From<String> for IfcDirectionSenseEnum {
    fn from(value: String) -> Self {
        match value.as_str() {
            "POSITIVE" => IfcDirectionSenseEnum::Positive,
            "NEGATIVE" => IfcDirectionSenseEnum::Negative,
            _ => panic!("{} is not a valid value", value),
        }
    }
}
impl From<Parameter> for IfcDirectionSenseEnum {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EnumValue(value) => value.into(),
                _ => panic!("parameter is not an enum value"),
            },
            Parameter::OmittedParameter => IfcDirectionSenseEnum::default(),
            _ => panic!("parameter is not an enum value"),
        }
    }
}
#[derive(Eq, PartialEq, Hash, Debug)]
pub enum IfcDiscreteAccessoryTypeEnum {
    Anchorplate,
    Bracket,
    Shoe,
    Userdefined,
    Notdefined,
}
impl Default for IfcDiscreteAccessoryTypeEnum {
    fn default() -> Self {
        IfcDiscreteAccessoryTypeEnum::Anchorplate
    }
}
impl From<String> for IfcDiscreteAccessoryTypeEnum {
    fn from(value: String) -> Self {
        match value.as_str() {
            "ANCHORPLATE" => IfcDiscreteAccessoryTypeEnum::Anchorplate,
            "BRACKET" => IfcDiscreteAccessoryTypeEnum::Bracket,
            "SHOE" => IfcDiscreteAccessoryTypeEnum::Shoe,
            "USERDEFINED" => IfcDiscreteAccessoryTypeEnum::Userdefined,
            "NOTDEFINED" => IfcDiscreteAccessoryTypeEnum::Notdefined,
            _ => panic!("{} is not a valid value", value),
        }
    }
}
impl From<Parameter> for IfcDiscreteAccessoryTypeEnum {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EnumValue(value) => value.into(),
                _ => panic!("parameter is not an enum value"),
            },
            Parameter::OmittedParameter => IfcDiscreteAccessoryTypeEnum::default(),
            _ => panic!("parameter is not an enum value"),
        }
    }
}
#[derive(Eq, PartialEq, Hash, Debug)]
pub enum IfcDistributionChamberElementTypeEnum {
    Formedduct,
    Inspectionchamber,
    Inspectionpit,
    Manhole,
    Meterchamber,
    Sump,
    Trench,
    Valvechamber,
    Userdefined,
    Notdefined,
}
impl Default for IfcDistributionChamberElementTypeEnum {
    fn default() -> Self {
        IfcDistributionChamberElementTypeEnum::Formedduct
    }
}
impl From<String> for IfcDistributionChamberElementTypeEnum {
    fn from(value: String) -> Self {
        match value.as_str() {
            "FORMEDDUCT" => IfcDistributionChamberElementTypeEnum::Formedduct,
            "INSPECTIONCHAMBER" => IfcDistributionChamberElementTypeEnum::Inspectionchamber,
            "INSPECTIONPIT" => IfcDistributionChamberElementTypeEnum::Inspectionpit,
            "MANHOLE" => IfcDistributionChamberElementTypeEnum::Manhole,
            "METERCHAMBER" => IfcDistributionChamberElementTypeEnum::Meterchamber,
            "SUMP" => IfcDistributionChamberElementTypeEnum::Sump,
            "TRENCH" => IfcDistributionChamberElementTypeEnum::Trench,
            "VALVECHAMBER" => IfcDistributionChamberElementTypeEnum::Valvechamber,
            "USERDEFINED" => IfcDistributionChamberElementTypeEnum::Userdefined,
            "NOTDEFINED" => IfcDistributionChamberElementTypeEnum::Notdefined,
            _ => panic!("{} is not a valid value", value),
        }
    }
}
impl From<Parameter> for IfcDistributionChamberElementTypeEnum {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EnumValue(value) => value.into(),
                _ => panic!("parameter is not an enum value"),
            },
            Parameter::OmittedParameter => IfcDistributionChamberElementTypeEnum::default(),
            _ => panic!("parameter is not an enum value"),
        }
    }
}
#[derive(Eq, PartialEq, Hash, Debug)]
pub enum IfcDistributionPortTypeEnum {
    Cable,
    Cablecarrier,
    Duct,
    Pipe,
    Userdefined,
    Notdefined,
}
impl Default for IfcDistributionPortTypeEnum {
    fn default() -> Self {
        IfcDistributionPortTypeEnum::Cable
    }
}
impl From<String> for IfcDistributionPortTypeEnum {
    fn from(value: String) -> Self {
        match value.as_str() {
            "CABLE" => IfcDistributionPortTypeEnum::Cable,
            "CABLECARRIER" => IfcDistributionPortTypeEnum::Cablecarrier,
            "DUCT" => IfcDistributionPortTypeEnum::Duct,
            "PIPE" => IfcDistributionPortTypeEnum::Pipe,
            "USERDEFINED" => IfcDistributionPortTypeEnum::Userdefined,
            "NOTDEFINED" => IfcDistributionPortTypeEnum::Notdefined,
            _ => panic!("{} is not a valid value", value),
        }
    }
}
impl From<Parameter> for IfcDistributionPortTypeEnum {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EnumValue(value) => value.into(),
                _ => panic!("parameter is not an enum value"),
            },
            Parameter::OmittedParameter => IfcDistributionPortTypeEnum::default(),
            _ => panic!("parameter is not an enum value"),
        }
    }
}
#[derive(Eq, PartialEq, Hash, Debug)]
pub enum IfcDistributionSystemEnum {
    Airconditioning,
    Audiovisual,
    Chemical,
    Chilledwater,
    Communication,
    Compressedair,
    Condenserwater,
    Control,
    Conveying,
    Data,
    Disposal,
    Domesticcoldwater,
    Domestichotwater,
    Drainage,
    Earthing,
    Electrical,
    Electroacoustic,
    Exhaust,
    Fireprotection,
    Fuel,
    Gas,
    Hazardous,
    Heating,
    Lighting,
    Lightningprotection,
    Municipalsolidwaste,
    Oil,
    Operational,
    Powergeneration,
    Rainwater,
    Refrigeration,
    Security,
    Sewage,
    Signal,
    Stormwater,
    Telephone,
    Tv,
    Vacuum,
    Vent,
    Ventilation,
    Wastewater,
    Watersupply,
    Userdefined,
    Notdefined,
}
impl Default for IfcDistributionSystemEnum {
    fn default() -> Self {
        IfcDistributionSystemEnum::Airconditioning
    }
}
impl From<String> for IfcDistributionSystemEnum {
    fn from(value: String) -> Self {
        match value.as_str() {
            "AIRCONDITIONING" => IfcDistributionSystemEnum::Airconditioning,
            "AUDIOVISUAL" => IfcDistributionSystemEnum::Audiovisual,
            "CHEMICAL" => IfcDistributionSystemEnum::Chemical,
            "CHILLEDWATER" => IfcDistributionSystemEnum::Chilledwater,
            "COMMUNICATION" => IfcDistributionSystemEnum::Communication,
            "COMPRESSEDAIR" => IfcDistributionSystemEnum::Compressedair,
            "CONDENSERWATER" => IfcDistributionSystemEnum::Condenserwater,
            "CONTROL" => IfcDistributionSystemEnum::Control,
            "CONVEYING" => IfcDistributionSystemEnum::Conveying,
            "DATA" => IfcDistributionSystemEnum::Data,
            "DISPOSAL" => IfcDistributionSystemEnum::Disposal,
            "DOMESTICCOLDWATER" => IfcDistributionSystemEnum::Domesticcoldwater,
            "DOMESTICHOTWATER" => IfcDistributionSystemEnum::Domestichotwater,
            "DRAINAGE" => IfcDistributionSystemEnum::Drainage,
            "EARTHING" => IfcDistributionSystemEnum::Earthing,
            "ELECTRICAL" => IfcDistributionSystemEnum::Electrical,
            "ELECTROACOUSTIC" => IfcDistributionSystemEnum::Electroacoustic,
            "EXHAUST" => IfcDistributionSystemEnum::Exhaust,
            "FIREPROTECTION" => IfcDistributionSystemEnum::Fireprotection,
            "FUEL" => IfcDistributionSystemEnum::Fuel,
            "GAS" => IfcDistributionSystemEnum::Gas,
            "HAZARDOUS" => IfcDistributionSystemEnum::Hazardous,
            "HEATING" => IfcDistributionSystemEnum::Heating,
            "LIGHTING" => IfcDistributionSystemEnum::Lighting,
            "LIGHTNINGPROTECTION" => IfcDistributionSystemEnum::Lightningprotection,
            "MUNICIPALSOLIDWASTE" => IfcDistributionSystemEnum::Municipalsolidwaste,
            "OIL" => IfcDistributionSystemEnum::Oil,
            "OPERATIONAL" => IfcDistributionSystemEnum::Operational,
            "POWERGENERATION" => IfcDistributionSystemEnum::Powergeneration,
            "RAINWATER" => IfcDistributionSystemEnum::Rainwater,
            "REFRIGERATION" => IfcDistributionSystemEnum::Refrigeration,
            "SECURITY" => IfcDistributionSystemEnum::Security,
            "SEWAGE" => IfcDistributionSystemEnum::Sewage,
            "SIGNAL" => IfcDistributionSystemEnum::Signal,
            "STORMWATER" => IfcDistributionSystemEnum::Stormwater,
            "TELEPHONE" => IfcDistributionSystemEnum::Telephone,
            "TV" => IfcDistributionSystemEnum::Tv,
            "VACUUM" => IfcDistributionSystemEnum::Vacuum,
            "VENT" => IfcDistributionSystemEnum::Vent,
            "VENTILATION" => IfcDistributionSystemEnum::Ventilation,
            "WASTEWATER" => IfcDistributionSystemEnum::Wastewater,
            "WATERSUPPLY" => IfcDistributionSystemEnum::Watersupply,
            "USERDEFINED" => IfcDistributionSystemEnum::Userdefined,
            "NOTDEFINED" => IfcDistributionSystemEnum::Notdefined,
            _ => panic!("{} is not a valid value", value),
        }
    }
}
impl From<Parameter> for IfcDistributionSystemEnum {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EnumValue(value) => value.into(),
                _ => panic!("parameter is not an enum value"),
            },
            Parameter::OmittedParameter => IfcDistributionSystemEnum::default(),
            _ => panic!("parameter is not an enum value"),
        }
    }
}
#[derive(Eq, PartialEq, Hash, Debug)]
pub enum IfcDocumentConfidentialityEnum {
    Public,
    Restricted,
    Confidential,
    Personal,
    Userdefined,
    Notdefined,
}
impl Default for IfcDocumentConfidentialityEnum {
    fn default() -> Self {
        IfcDocumentConfidentialityEnum::Public
    }
}
impl From<String> for IfcDocumentConfidentialityEnum {
    fn from(value: String) -> Self {
        match value.as_str() {
            "PUBLIC" => IfcDocumentConfidentialityEnum::Public,
            "RESTRICTED" => IfcDocumentConfidentialityEnum::Restricted,
            "CONFIDENTIAL" => IfcDocumentConfidentialityEnum::Confidential,
            "PERSONAL" => IfcDocumentConfidentialityEnum::Personal,
            "USERDEFINED" => IfcDocumentConfidentialityEnum::Userdefined,
            "NOTDEFINED" => IfcDocumentConfidentialityEnum::Notdefined,
            _ => panic!("{} is not a valid value", value),
        }
    }
}
impl From<Parameter> for IfcDocumentConfidentialityEnum {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EnumValue(value) => value.into(),
                _ => panic!("parameter is not an enum value"),
            },
            Parameter::OmittedParameter => IfcDocumentConfidentialityEnum::default(),
            _ => panic!("parameter is not an enum value"),
        }
    }
}
#[derive(Eq, PartialEq, Hash, Debug)]
pub enum IfcDocumentStatusEnum {
    Draft,
    Finaldraft,
    Final,
    Revision,
    Notdefined,
}
impl Default for IfcDocumentStatusEnum {
    fn default() -> Self {
        IfcDocumentStatusEnum::Draft
    }
}
impl From<String> for IfcDocumentStatusEnum {
    fn from(value: String) -> Self {
        match value.as_str() {
            "DRAFT" => IfcDocumentStatusEnum::Draft,
            "FINALDRAFT" => IfcDocumentStatusEnum::Finaldraft,
            "FINAL" => IfcDocumentStatusEnum::Final,
            "REVISION" => IfcDocumentStatusEnum::Revision,
            "NOTDEFINED" => IfcDocumentStatusEnum::Notdefined,
            _ => panic!("{} is not a valid value", value),
        }
    }
}
impl From<Parameter> for IfcDocumentStatusEnum {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EnumValue(value) => value.into(),
                _ => panic!("parameter is not an enum value"),
            },
            Parameter::OmittedParameter => IfcDocumentStatusEnum::default(),
            _ => panic!("parameter is not an enum value"),
        }
    }
}
#[derive(Eq, PartialEq, Hash, Debug)]
pub enum IfcDoorPanelOperationEnum {
    Swinging,
    DoubleActing,
    Sliding,
    Folding,
    Revolving,
    Rollingup,
    Fixedpanel,
    Userdefined,
    Notdefined,
}
impl Default for IfcDoorPanelOperationEnum {
    fn default() -> Self {
        IfcDoorPanelOperationEnum::Swinging
    }
}
impl From<String> for IfcDoorPanelOperationEnum {
    fn from(value: String) -> Self {
        match value.as_str() {
            "SWINGING" => IfcDoorPanelOperationEnum::Swinging,
            "DOUBLE_ACTING" => IfcDoorPanelOperationEnum::DoubleActing,
            "SLIDING" => IfcDoorPanelOperationEnum::Sliding,
            "FOLDING" => IfcDoorPanelOperationEnum::Folding,
            "REVOLVING" => IfcDoorPanelOperationEnum::Revolving,
            "ROLLINGUP" => IfcDoorPanelOperationEnum::Rollingup,
            "FIXEDPANEL" => IfcDoorPanelOperationEnum::Fixedpanel,
            "USERDEFINED" => IfcDoorPanelOperationEnum::Userdefined,
            "NOTDEFINED" => IfcDoorPanelOperationEnum::Notdefined,
            _ => panic!("{} is not a valid value", value),
        }
    }
}
impl From<Parameter> for IfcDoorPanelOperationEnum {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EnumValue(value) => value.into(),
                _ => panic!("parameter is not an enum value"),
            },
            Parameter::OmittedParameter => IfcDoorPanelOperationEnum::default(),
            _ => panic!("parameter is not an enum value"),
        }
    }
}
#[derive(Eq, PartialEq, Hash, Debug)]
pub enum IfcDoorPanelPositionEnum {
    Left,
    Middle,
    Right,
    Notdefined,
}
impl Default for IfcDoorPanelPositionEnum {
    fn default() -> Self {
        IfcDoorPanelPositionEnum::Left
    }
}
impl From<String> for IfcDoorPanelPositionEnum {
    fn from(value: String) -> Self {
        match value.as_str() {
            "LEFT" => IfcDoorPanelPositionEnum::Left,
            "MIDDLE" => IfcDoorPanelPositionEnum::Middle,
            "RIGHT" => IfcDoorPanelPositionEnum::Right,
            "NOTDEFINED" => IfcDoorPanelPositionEnum::Notdefined,
            _ => panic!("{} is not a valid value", value),
        }
    }
}
impl From<Parameter> for IfcDoorPanelPositionEnum {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EnumValue(value) => value.into(),
                _ => panic!("parameter is not an enum value"),
            },
            Parameter::OmittedParameter => IfcDoorPanelPositionEnum::default(),
            _ => panic!("parameter is not an enum value"),
        }
    }
}
#[derive(Eq, PartialEq, Hash, Debug)]
pub enum IfcDoorStyleConstructionEnum {
    Aluminium,
    HighGradeSteel,
    Steel,
    Wood,
    AluminiumWood,
    AluminiumPlastic,
    Plastic,
    Userdefined,
    Notdefined,
}
impl Default for IfcDoorStyleConstructionEnum {
    fn default() -> Self {
        IfcDoorStyleConstructionEnum::Aluminium
    }
}
impl From<String> for IfcDoorStyleConstructionEnum {
    fn from(value: String) -> Self {
        match value.as_str() {
            "ALUMINIUM" => IfcDoorStyleConstructionEnum::Aluminium,
            "HIGH_GRADE_STEEL" => IfcDoorStyleConstructionEnum::HighGradeSteel,
            "STEEL" => IfcDoorStyleConstructionEnum::Steel,
            "WOOD" => IfcDoorStyleConstructionEnum::Wood,
            "ALUMINIUM_WOOD" => IfcDoorStyleConstructionEnum::AluminiumWood,
            "ALUMINIUM_PLASTIC" => IfcDoorStyleConstructionEnum::AluminiumPlastic,
            "PLASTIC" => IfcDoorStyleConstructionEnum::Plastic,
            "USERDEFINED" => IfcDoorStyleConstructionEnum::Userdefined,
            "NOTDEFINED" => IfcDoorStyleConstructionEnum::Notdefined,
            _ => panic!("{} is not a valid value", value),
        }
    }
}
impl From<Parameter> for IfcDoorStyleConstructionEnum {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EnumValue(value) => value.into(),
                _ => panic!("parameter is not an enum value"),
            },
            Parameter::OmittedParameter => IfcDoorStyleConstructionEnum::default(),
            _ => panic!("parameter is not an enum value"),
        }
    }
}
#[derive(Eq, PartialEq, Hash, Debug)]
pub enum IfcDoorStyleOperationEnum {
    SingleSwingLeft,
    SingleSwingRight,
    DoubleDoorSingleSwing,
    DoubleDoorSingleSwingOppositeLeft,
    DoubleDoorSingleSwingOppositeRight,
    DoubleSwingLeft,
    DoubleSwingRight,
    DoubleDoorDoubleSwing,
    SlidingToLeft,
    SlidingToRight,
    DoubleDoorSliding,
    FoldingToLeft,
    FoldingToRight,
    DoubleDoorFolding,
    Revolving,
    Rollingup,
    Userdefined,
    Notdefined,
}
impl Default for IfcDoorStyleOperationEnum {
    fn default() -> Self {
        IfcDoorStyleOperationEnum::SingleSwingLeft
    }
}
impl From<String> for IfcDoorStyleOperationEnum {
    fn from(value: String) -> Self {
        match value.as_str() {
            "SINGLE_SWING_LEFT" => IfcDoorStyleOperationEnum::SingleSwingLeft,
            "SINGLE_SWING_RIGHT" => IfcDoorStyleOperationEnum::SingleSwingRight,
            "DOUBLE_DOOR_SINGLE_SWING" => IfcDoorStyleOperationEnum::DoubleDoorSingleSwing,
            "DOUBLE_DOOR_SINGLE_SWING_OPPOSITE_LEFT" => IfcDoorStyleOperationEnum::DoubleDoorSingleSwingOppositeLeft,
            "DOUBLE_DOOR_SINGLE_SWING_OPPOSITE_RIGHT" => IfcDoorStyleOperationEnum::DoubleDoorSingleSwingOppositeRight,
            "DOUBLE_SWING_LEFT" => IfcDoorStyleOperationEnum::DoubleSwingLeft,
            "DOUBLE_SWING_RIGHT" => IfcDoorStyleOperationEnum::DoubleSwingRight,
            "DOUBLE_DOOR_DOUBLE_SWING" => IfcDoorStyleOperationEnum::DoubleDoorDoubleSwing,
            "SLIDING_TO_LEFT" => IfcDoorStyleOperationEnum::SlidingToLeft,
            "SLIDING_TO_RIGHT" => IfcDoorStyleOperationEnum::SlidingToRight,
            "DOUBLE_DOOR_SLIDING" => IfcDoorStyleOperationEnum::DoubleDoorSliding,
            "FOLDING_TO_LEFT" => IfcDoorStyleOperationEnum::FoldingToLeft,
            "FOLDING_TO_RIGHT" => IfcDoorStyleOperationEnum::FoldingToRight,
            "DOUBLE_DOOR_FOLDING" => IfcDoorStyleOperationEnum::DoubleDoorFolding,
            "REVOLVING" => IfcDoorStyleOperationEnum::Revolving,
            "ROLLINGUP" => IfcDoorStyleOperationEnum::Rollingup,
            "USERDEFINED" => IfcDoorStyleOperationEnum::Userdefined,
            "NOTDEFINED" => IfcDoorStyleOperationEnum::Notdefined,
            _ => panic!("{} is not a valid value", value),
        }
    }
}
impl From<Parameter> for IfcDoorStyleOperationEnum {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EnumValue(value) => value.into(),
                _ => panic!("parameter is not an enum value"),
            },
            Parameter::OmittedParameter => IfcDoorStyleOperationEnum::default(),
            _ => panic!("parameter is not an enum value"),
        }
    }
}
#[derive(Eq, PartialEq, Hash, Debug)]
pub enum IfcDoorTypeEnum {
    Door,
    Gate,
    Trapdoor,
    Userdefined,
    Notdefined,
}
impl Default for IfcDoorTypeEnum {
    fn default() -> Self {
        IfcDoorTypeEnum::Door
    }
}
impl From<String> for IfcDoorTypeEnum {
    fn from(value: String) -> Self {
        match value.as_str() {
            "DOOR" => IfcDoorTypeEnum::Door,
            "GATE" => IfcDoorTypeEnum::Gate,
            "TRAPDOOR" => IfcDoorTypeEnum::Trapdoor,
            "USERDEFINED" => IfcDoorTypeEnum::Userdefined,
            "NOTDEFINED" => IfcDoorTypeEnum::Notdefined,
            _ => panic!("{} is not a valid value", value),
        }
    }
}
impl From<Parameter> for IfcDoorTypeEnum {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EnumValue(value) => value.into(),
                _ => panic!("parameter is not an enum value"),
            },
            Parameter::OmittedParameter => IfcDoorTypeEnum::default(),
            _ => panic!("parameter is not an enum value"),
        }
    }
}
#[derive(Eq, PartialEq, Hash, Debug)]
pub enum IfcDoorTypeOperationEnum {
    SingleSwingLeft,
    SingleSwingRight,
    DoubleDoorSingleSwing,
    DoubleDoorSingleSwingOppositeLeft,
    DoubleDoorSingleSwingOppositeRight,
    DoubleSwingLeft,
    DoubleSwingRight,
    DoubleDoorDoubleSwing,
    SlidingToLeft,
    SlidingToRight,
    DoubleDoorSliding,
    FoldingToLeft,
    FoldingToRight,
    DoubleDoorFolding,
    Revolving,
    Rollingup,
    SwingFixedLeft,
    SwingFixedRight,
    Userdefined,
    Notdefined,
}
impl Default for IfcDoorTypeOperationEnum {
    fn default() -> Self {
        IfcDoorTypeOperationEnum::SingleSwingLeft
    }
}
impl From<String> for IfcDoorTypeOperationEnum {
    fn from(value: String) -> Self {
        match value.as_str() {
            "SINGLE_SWING_LEFT" => IfcDoorTypeOperationEnum::SingleSwingLeft,
            "SINGLE_SWING_RIGHT" => IfcDoorTypeOperationEnum::SingleSwingRight,
            "DOUBLE_DOOR_SINGLE_SWING" => IfcDoorTypeOperationEnum::DoubleDoorSingleSwing,
            "DOUBLE_DOOR_SINGLE_SWING_OPPOSITE_LEFT" => IfcDoorTypeOperationEnum::DoubleDoorSingleSwingOppositeLeft,
            "DOUBLE_DOOR_SINGLE_SWING_OPPOSITE_RIGHT" => IfcDoorTypeOperationEnum::DoubleDoorSingleSwingOppositeRight,
            "DOUBLE_SWING_LEFT" => IfcDoorTypeOperationEnum::DoubleSwingLeft,
            "DOUBLE_SWING_RIGHT" => IfcDoorTypeOperationEnum::DoubleSwingRight,
            "DOUBLE_DOOR_DOUBLE_SWING" => IfcDoorTypeOperationEnum::DoubleDoorDoubleSwing,
            "SLIDING_TO_LEFT" => IfcDoorTypeOperationEnum::SlidingToLeft,
            "SLIDING_TO_RIGHT" => IfcDoorTypeOperationEnum::SlidingToRight,
            "DOUBLE_DOOR_SLIDING" => IfcDoorTypeOperationEnum::DoubleDoorSliding,
            "FOLDING_TO_LEFT" => IfcDoorTypeOperationEnum::FoldingToLeft,
            "FOLDING_TO_RIGHT" => IfcDoorTypeOperationEnum::FoldingToRight,
            "DOUBLE_DOOR_FOLDING" => IfcDoorTypeOperationEnum::DoubleDoorFolding,
            "REVOLVING" => IfcDoorTypeOperationEnum::Revolving,
            "ROLLINGUP" => IfcDoorTypeOperationEnum::Rollingup,
            "SWING_FIXED_LEFT" => IfcDoorTypeOperationEnum::SwingFixedLeft,
            "SWING_FIXED_RIGHT" => IfcDoorTypeOperationEnum::SwingFixedRight,
            "USERDEFINED" => IfcDoorTypeOperationEnum::Userdefined,
            "NOTDEFINED" => IfcDoorTypeOperationEnum::Notdefined,
            _ => panic!("{} is not a valid value", value),
        }
    }
}
impl From<Parameter> for IfcDoorTypeOperationEnum {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EnumValue(value) => value.into(),
                _ => panic!("parameter is not an enum value"),
            },
            Parameter::OmittedParameter => IfcDoorTypeOperationEnum::default(),
            _ => panic!("parameter is not an enum value"),
        }
    }
}
#[derive(Eq, PartialEq, Hash, Debug)]
pub enum IfcDuctFittingTypeEnum {
    Bend,
    Connector,
    Entry,
    Exit,
    Junction,
    Obstruction,
    Transition,
    Userdefined,
    Notdefined,
}
impl Default for IfcDuctFittingTypeEnum {
    fn default() -> Self {
        IfcDuctFittingTypeEnum::Bend
    }
}
impl From<String> for IfcDuctFittingTypeEnum {
    fn from(value: String) -> Self {
        match value.as_str() {
            "BEND" => IfcDuctFittingTypeEnum::Bend,
            "CONNECTOR" => IfcDuctFittingTypeEnum::Connector,
            "ENTRY" => IfcDuctFittingTypeEnum::Entry,
            "EXIT" => IfcDuctFittingTypeEnum::Exit,
            "JUNCTION" => IfcDuctFittingTypeEnum::Junction,
            "OBSTRUCTION" => IfcDuctFittingTypeEnum::Obstruction,
            "TRANSITION" => IfcDuctFittingTypeEnum::Transition,
            "USERDEFINED" => IfcDuctFittingTypeEnum::Userdefined,
            "NOTDEFINED" => IfcDuctFittingTypeEnum::Notdefined,
            _ => panic!("{} is not a valid value", value),
        }
    }
}
impl From<Parameter> for IfcDuctFittingTypeEnum {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EnumValue(value) => value.into(),
                _ => panic!("parameter is not an enum value"),
            },
            Parameter::OmittedParameter => IfcDuctFittingTypeEnum::default(),
            _ => panic!("parameter is not an enum value"),
        }
    }
}
#[derive(Eq, PartialEq, Hash, Debug)]
pub enum IfcDuctSegmentTypeEnum {
    Rigidsegment,
    Flexiblesegment,
    Userdefined,
    Notdefined,
}
impl Default for IfcDuctSegmentTypeEnum {
    fn default() -> Self {
        IfcDuctSegmentTypeEnum::Rigidsegment
    }
}
impl From<String> for IfcDuctSegmentTypeEnum {
    fn from(value: String) -> Self {
        match value.as_str() {
            "RIGIDSEGMENT" => IfcDuctSegmentTypeEnum::Rigidsegment,
            "FLEXIBLESEGMENT" => IfcDuctSegmentTypeEnum::Flexiblesegment,
            "USERDEFINED" => IfcDuctSegmentTypeEnum::Userdefined,
            "NOTDEFINED" => IfcDuctSegmentTypeEnum::Notdefined,
            _ => panic!("{} is not a valid value", value),
        }
    }
}
impl From<Parameter> for IfcDuctSegmentTypeEnum {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EnumValue(value) => value.into(),
                _ => panic!("parameter is not an enum value"),
            },
            Parameter::OmittedParameter => IfcDuctSegmentTypeEnum::default(),
            _ => panic!("parameter is not an enum value"),
        }
    }
}
#[derive(Eq, PartialEq, Hash, Debug)]
pub enum IfcDuctSilencerTypeEnum {
    Flatoval,
    Rectangular,
    Round,
    Userdefined,
    Notdefined,
}
impl Default for IfcDuctSilencerTypeEnum {
    fn default() -> Self {
        IfcDuctSilencerTypeEnum::Flatoval
    }
}
impl From<String> for IfcDuctSilencerTypeEnum {
    fn from(value: String) -> Self {
        match value.as_str() {
            "FLATOVAL" => IfcDuctSilencerTypeEnum::Flatoval,
            "RECTANGULAR" => IfcDuctSilencerTypeEnum::Rectangular,
            "ROUND" => IfcDuctSilencerTypeEnum::Round,
            "USERDEFINED" => IfcDuctSilencerTypeEnum::Userdefined,
            "NOTDEFINED" => IfcDuctSilencerTypeEnum::Notdefined,
            _ => panic!("{} is not a valid value", value),
        }
    }
}
impl From<Parameter> for IfcDuctSilencerTypeEnum {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EnumValue(value) => value.into(),
                _ => panic!("parameter is not an enum value"),
            },
            Parameter::OmittedParameter => IfcDuctSilencerTypeEnum::default(),
            _ => panic!("parameter is not an enum value"),
        }
    }
}
#[derive(Eq, PartialEq, Hash, Debug)]
pub enum IfcElectricApplianceTypeEnum {
    Dishwasher,
    Electriccooker,
    Freestandingelectricheater,
    Freestandingfan,
    Freestandingwaterheater,
    Freestandingwatercooler,
    Freezer,
    FridgeFreezer,
    Handdryer,
    Kitchenmachine,
    Microwave,
    Photocopier,
    Refrigerator,
    Tumbledryer,
    Vendingmachine,
    Washingmachine,
    Userdefined,
    Notdefined,
}
impl Default for IfcElectricApplianceTypeEnum {
    fn default() -> Self {
        IfcElectricApplianceTypeEnum::Dishwasher
    }
}
impl From<String> for IfcElectricApplianceTypeEnum {
    fn from(value: String) -> Self {
        match value.as_str() {
            "DISHWASHER" => IfcElectricApplianceTypeEnum::Dishwasher,
            "ELECTRICCOOKER" => IfcElectricApplianceTypeEnum::Electriccooker,
            "FREESTANDINGELECTRICHEATER" => IfcElectricApplianceTypeEnum::Freestandingelectricheater,
            "FREESTANDINGFAN" => IfcElectricApplianceTypeEnum::Freestandingfan,
            "FREESTANDINGWATERHEATER" => IfcElectricApplianceTypeEnum::Freestandingwaterheater,
            "FREESTANDINGWATERCOOLER" => IfcElectricApplianceTypeEnum::Freestandingwatercooler,
            "FREEZER" => IfcElectricApplianceTypeEnum::Freezer,
            "FRIDGE_FREEZER" => IfcElectricApplianceTypeEnum::FridgeFreezer,
            "HANDDRYER" => IfcElectricApplianceTypeEnum::Handdryer,
            "KITCHENMACHINE" => IfcElectricApplianceTypeEnum::Kitchenmachine,
            "MICROWAVE" => IfcElectricApplianceTypeEnum::Microwave,
            "PHOTOCOPIER" => IfcElectricApplianceTypeEnum::Photocopier,
            "REFRIGERATOR" => IfcElectricApplianceTypeEnum::Refrigerator,
            "TUMBLEDRYER" => IfcElectricApplianceTypeEnum::Tumbledryer,
            "VENDINGMACHINE" => IfcElectricApplianceTypeEnum::Vendingmachine,
            "WASHINGMACHINE" => IfcElectricApplianceTypeEnum::Washingmachine,
            "USERDEFINED" => IfcElectricApplianceTypeEnum::Userdefined,
            "NOTDEFINED" => IfcElectricApplianceTypeEnum::Notdefined,
            _ => panic!("{} is not a valid value", value),
        }
    }
}
impl From<Parameter> for IfcElectricApplianceTypeEnum {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EnumValue(value) => value.into(),
                _ => panic!("parameter is not an enum value"),
            },
            Parameter::OmittedParameter => IfcElectricApplianceTypeEnum::default(),
            _ => panic!("parameter is not an enum value"),
        }
    }
}
#[derive(Eq, PartialEq, Hash, Debug)]
pub enum IfcElectricDistributionBoardTypeEnum {
    Consumerunit,
    Distributionboard,
    Motorcontrolcentre,
    Switchboard,
    Userdefined,
    Notdefined,
}
impl Default for IfcElectricDistributionBoardTypeEnum {
    fn default() -> Self {
        IfcElectricDistributionBoardTypeEnum::Consumerunit
    }
}
impl From<String> for IfcElectricDistributionBoardTypeEnum {
    fn from(value: String) -> Self {
        match value.as_str() {
            "CONSUMERUNIT" => IfcElectricDistributionBoardTypeEnum::Consumerunit,
            "DISTRIBUTIONBOARD" => IfcElectricDistributionBoardTypeEnum::Distributionboard,
            "MOTORCONTROLCENTRE" => IfcElectricDistributionBoardTypeEnum::Motorcontrolcentre,
            "SWITCHBOARD" => IfcElectricDistributionBoardTypeEnum::Switchboard,
            "USERDEFINED" => IfcElectricDistributionBoardTypeEnum::Userdefined,
            "NOTDEFINED" => IfcElectricDistributionBoardTypeEnum::Notdefined,
            _ => panic!("{} is not a valid value", value),
        }
    }
}
impl From<Parameter> for IfcElectricDistributionBoardTypeEnum {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EnumValue(value) => value.into(),
                _ => panic!("parameter is not an enum value"),
            },
            Parameter::OmittedParameter => IfcElectricDistributionBoardTypeEnum::default(),
            _ => panic!("parameter is not an enum value"),
        }
    }
}
#[derive(Eq, PartialEq, Hash, Debug)]
pub enum IfcElectricFlowStorageDeviceTypeEnum {
    Battery,
    Capacitorbank,
    Harmonicfilter,
    Inductorbank,
    Ups,
    Userdefined,
    Notdefined,
}
impl Default for IfcElectricFlowStorageDeviceTypeEnum {
    fn default() -> Self {
        IfcElectricFlowStorageDeviceTypeEnum::Battery
    }
}
impl From<String> for IfcElectricFlowStorageDeviceTypeEnum {
    fn from(value: String) -> Self {
        match value.as_str() {
            "BATTERY" => IfcElectricFlowStorageDeviceTypeEnum::Battery,
            "CAPACITORBANK" => IfcElectricFlowStorageDeviceTypeEnum::Capacitorbank,
            "HARMONICFILTER" => IfcElectricFlowStorageDeviceTypeEnum::Harmonicfilter,
            "INDUCTORBANK" => IfcElectricFlowStorageDeviceTypeEnum::Inductorbank,
            "UPS" => IfcElectricFlowStorageDeviceTypeEnum::Ups,
            "USERDEFINED" => IfcElectricFlowStorageDeviceTypeEnum::Userdefined,
            "NOTDEFINED" => IfcElectricFlowStorageDeviceTypeEnum::Notdefined,
            _ => panic!("{} is not a valid value", value),
        }
    }
}
impl From<Parameter> for IfcElectricFlowStorageDeviceTypeEnum {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EnumValue(value) => value.into(),
                _ => panic!("parameter is not an enum value"),
            },
            Parameter::OmittedParameter => IfcElectricFlowStorageDeviceTypeEnum::default(),
            _ => panic!("parameter is not an enum value"),
        }
    }
}
#[derive(Eq, PartialEq, Hash, Debug)]
pub enum IfcElectricGeneratorTypeEnum {
    Chp,
    Enginegenerator,
    Standalone,
    Userdefined,
    Notdefined,
}
impl Default for IfcElectricGeneratorTypeEnum {
    fn default() -> Self {
        IfcElectricGeneratorTypeEnum::Chp
    }
}
impl From<String> for IfcElectricGeneratorTypeEnum {
    fn from(value: String) -> Self {
        match value.as_str() {
            "CHP" => IfcElectricGeneratorTypeEnum::Chp,
            "ENGINEGENERATOR" => IfcElectricGeneratorTypeEnum::Enginegenerator,
            "STANDALONE" => IfcElectricGeneratorTypeEnum::Standalone,
            "USERDEFINED" => IfcElectricGeneratorTypeEnum::Userdefined,
            "NOTDEFINED" => IfcElectricGeneratorTypeEnum::Notdefined,
            _ => panic!("{} is not a valid value", value),
        }
    }
}
impl From<Parameter> for IfcElectricGeneratorTypeEnum {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EnumValue(value) => value.into(),
                _ => panic!("parameter is not an enum value"),
            },
            Parameter::OmittedParameter => IfcElectricGeneratorTypeEnum::default(),
            _ => panic!("parameter is not an enum value"),
        }
    }
}
#[derive(Eq, PartialEq, Hash, Debug)]
pub enum IfcElectricMotorTypeEnum {
    Dc,
    Induction,
    Polyphase,
    Reluctancesynchronous,
    Synchronous,
    Userdefined,
    Notdefined,
}
impl Default for IfcElectricMotorTypeEnum {
    fn default() -> Self {
        IfcElectricMotorTypeEnum::Dc
    }
}
impl From<String> for IfcElectricMotorTypeEnum {
    fn from(value: String) -> Self {
        match value.as_str() {
            "DC" => IfcElectricMotorTypeEnum::Dc,
            "INDUCTION" => IfcElectricMotorTypeEnum::Induction,
            "POLYPHASE" => IfcElectricMotorTypeEnum::Polyphase,
            "RELUCTANCESYNCHRONOUS" => IfcElectricMotorTypeEnum::Reluctancesynchronous,
            "SYNCHRONOUS" => IfcElectricMotorTypeEnum::Synchronous,
            "USERDEFINED" => IfcElectricMotorTypeEnum::Userdefined,
            "NOTDEFINED" => IfcElectricMotorTypeEnum::Notdefined,
            _ => panic!("{} is not a valid value", value),
        }
    }
}
impl From<Parameter> for IfcElectricMotorTypeEnum {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EnumValue(value) => value.into(),
                _ => panic!("parameter is not an enum value"),
            },
            Parameter::OmittedParameter => IfcElectricMotorTypeEnum::default(),
            _ => panic!("parameter is not an enum value"),
        }
    }
}
#[derive(Eq, PartialEq, Hash, Debug)]
pub enum IfcElectricTimeControlTypeEnum {
    Timeclock,
    Timedelay,
    Relay,
    Userdefined,
    Notdefined,
}
impl Default for IfcElectricTimeControlTypeEnum {
    fn default() -> Self {
        IfcElectricTimeControlTypeEnum::Timeclock
    }
}
impl From<String> for IfcElectricTimeControlTypeEnum {
    fn from(value: String) -> Self {
        match value.as_str() {
            "TIMECLOCK" => IfcElectricTimeControlTypeEnum::Timeclock,
            "TIMEDELAY" => IfcElectricTimeControlTypeEnum::Timedelay,
            "RELAY" => IfcElectricTimeControlTypeEnum::Relay,
            "USERDEFINED" => IfcElectricTimeControlTypeEnum::Userdefined,
            "NOTDEFINED" => IfcElectricTimeControlTypeEnum::Notdefined,
            _ => panic!("{} is not a valid value", value),
        }
    }
}
impl From<Parameter> for IfcElectricTimeControlTypeEnum {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EnumValue(value) => value.into(),
                _ => panic!("parameter is not an enum value"),
            },
            Parameter::OmittedParameter => IfcElectricTimeControlTypeEnum::default(),
            _ => panic!("parameter is not an enum value"),
        }
    }
}
#[derive(Eq, PartialEq, Hash, Debug)]
pub enum IfcElementAssemblyTypeEnum {
    AccessoryAssembly,
    Arch,
    BeamGrid,
    BracedFrame,
    Girder,
    ReinforcementUnit,
    RigidFrame,
    SlabField,
    Truss,
    Userdefined,
    Notdefined,
}
impl Default for IfcElementAssemblyTypeEnum {
    fn default() -> Self {
        IfcElementAssemblyTypeEnum::AccessoryAssembly
    }
}
impl From<String> for IfcElementAssemblyTypeEnum {
    fn from(value: String) -> Self {
        match value.as_str() {
            "ACCESSORY_ASSEMBLY" => IfcElementAssemblyTypeEnum::AccessoryAssembly,
            "ARCH" => IfcElementAssemblyTypeEnum::Arch,
            "BEAM_GRID" => IfcElementAssemblyTypeEnum::BeamGrid,
            "BRACED_FRAME" => IfcElementAssemblyTypeEnum::BracedFrame,
            "GIRDER" => IfcElementAssemblyTypeEnum::Girder,
            "REINFORCEMENT_UNIT" => IfcElementAssemblyTypeEnum::ReinforcementUnit,
            "RIGID_FRAME" => IfcElementAssemblyTypeEnum::RigidFrame,
            "SLAB_FIELD" => IfcElementAssemblyTypeEnum::SlabField,
            "TRUSS" => IfcElementAssemblyTypeEnum::Truss,
            "USERDEFINED" => IfcElementAssemblyTypeEnum::Userdefined,
            "NOTDEFINED" => IfcElementAssemblyTypeEnum::Notdefined,
            _ => panic!("{} is not a valid value", value),
        }
    }
}
impl From<Parameter> for IfcElementAssemblyTypeEnum {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EnumValue(value) => value.into(),
                _ => panic!("parameter is not an enum value"),
            },
            Parameter::OmittedParameter => IfcElementAssemblyTypeEnum::default(),
            _ => panic!("parameter is not an enum value"),
        }
    }
}
#[derive(Eq, PartialEq, Hash, Debug)]
pub enum IfcElementCompositionEnum {
    Complex,
    Element,
    Partial,
}
impl Default for IfcElementCompositionEnum {
    fn default() -> Self {
        IfcElementCompositionEnum::Complex
    }
}
impl From<String> for IfcElementCompositionEnum {
    fn from(value: String) -> Self {
        match value.as_str() {
            "COMPLEX" => IfcElementCompositionEnum::Complex,
            "ELEMENT" => IfcElementCompositionEnum::Element,
            "PARTIAL" => IfcElementCompositionEnum::Partial,
            _ => panic!("{} is not a valid value", value),
        }
    }
}
impl From<Parameter> for IfcElementCompositionEnum {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EnumValue(value) => value.into(),
                _ => panic!("parameter is not an enum value"),
            },
            Parameter::OmittedParameter => IfcElementCompositionEnum::default(),
            _ => panic!("parameter is not an enum value"),
        }
    }
}
#[derive(Eq, PartialEq, Hash, Debug)]
pub enum IfcEngineTypeEnum {
    Externalcombustion,
    Internalcombustion,
    Userdefined,
    Notdefined,
}
impl Default for IfcEngineTypeEnum {
    fn default() -> Self {
        IfcEngineTypeEnum::Externalcombustion
    }
}
impl From<String> for IfcEngineTypeEnum {
    fn from(value: String) -> Self {
        match value.as_str() {
            "EXTERNALCOMBUSTION" => IfcEngineTypeEnum::Externalcombustion,
            "INTERNALCOMBUSTION" => IfcEngineTypeEnum::Internalcombustion,
            "USERDEFINED" => IfcEngineTypeEnum::Userdefined,
            "NOTDEFINED" => IfcEngineTypeEnum::Notdefined,
            _ => panic!("{} is not a valid value", value),
        }
    }
}
impl From<Parameter> for IfcEngineTypeEnum {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EnumValue(value) => value.into(),
                _ => panic!("parameter is not an enum value"),
            },
            Parameter::OmittedParameter => IfcEngineTypeEnum::default(),
            _ => panic!("parameter is not an enum value"),
        }
    }
}
#[derive(Eq, PartialEq, Hash, Debug)]
pub enum IfcEvaporativeCoolerTypeEnum {
    Directevaporativerandommediaaircooler,
    Directevaporativerigidmediaaircooler,
    Directevaporativeslingerspackagedaircooler,
    Directevaporativepackagedrotaryaircooler,
    Directevaporativeairwasher,
    Indirectevaporativepackageaircooler,
    Indirectevaporativewetcoil,
    Indirectevaporativecoolingtowerorcoilcooler,
    Indirectdirectcombination,
    Userdefined,
    Notdefined,
}
impl Default for IfcEvaporativeCoolerTypeEnum {
    fn default() -> Self {
        IfcEvaporativeCoolerTypeEnum::Directevaporativerandommediaaircooler
    }
}
impl From<String> for IfcEvaporativeCoolerTypeEnum {
    fn from(value: String) -> Self {
        match value.as_str() {
            "DIRECTEVAPORATIVERANDOMMEDIAAIRCOOLER" => {
                IfcEvaporativeCoolerTypeEnum::Directevaporativerandommediaaircooler
            }
            "DIRECTEVAPORATIVERIGIDMEDIAAIRCOOLER" => {
                IfcEvaporativeCoolerTypeEnum::Directevaporativerigidmediaaircooler
            }
            "DIRECTEVAPORATIVESLINGERSPACKAGEDAIRCOOLER" => {
                IfcEvaporativeCoolerTypeEnum::Directevaporativeslingerspackagedaircooler
            }
            "DIRECTEVAPORATIVEPACKAGEDROTARYAIRCOOLER" => {
                IfcEvaporativeCoolerTypeEnum::Directevaporativepackagedrotaryaircooler
            }
            "DIRECTEVAPORATIVEAIRWASHER" => IfcEvaporativeCoolerTypeEnum::Directevaporativeairwasher,
            "INDIRECTEVAPORATIVEPACKAGEAIRCOOLER" => IfcEvaporativeCoolerTypeEnum::Indirectevaporativepackageaircooler,
            "INDIRECTEVAPORATIVEWETCOIL" => IfcEvaporativeCoolerTypeEnum::Indirectevaporativewetcoil,
            "INDIRECTEVAPORATIVECOOLINGTOWERORCOILCOOLER" => {
                IfcEvaporativeCoolerTypeEnum::Indirectevaporativecoolingtowerorcoilcooler
            }
            "INDIRECTDIRECTCOMBINATION" => IfcEvaporativeCoolerTypeEnum::Indirectdirectcombination,
            "USERDEFINED" => IfcEvaporativeCoolerTypeEnum::Userdefined,
            "NOTDEFINED" => IfcEvaporativeCoolerTypeEnum::Notdefined,
            _ => panic!("{} is not a valid value", value),
        }
    }
}
impl From<Parameter> for IfcEvaporativeCoolerTypeEnum {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EnumValue(value) => value.into(),
                _ => panic!("parameter is not an enum value"),
            },
            Parameter::OmittedParameter => IfcEvaporativeCoolerTypeEnum::default(),
            _ => panic!("parameter is not an enum value"),
        }
    }
}
#[derive(Eq, PartialEq, Hash, Debug)]
pub enum IfcEvaporatorTypeEnum {
    Directexpansion,
    Directexpansionshellandtube,
    Directexpansiontubeintube,
    Directexpansionbrazedplate,
    Floodedshellandtube,
    Shellandcoil,
    Userdefined,
    Notdefined,
}
impl Default for IfcEvaporatorTypeEnum {
    fn default() -> Self {
        IfcEvaporatorTypeEnum::Directexpansion
    }
}
impl From<String> for IfcEvaporatorTypeEnum {
    fn from(value: String) -> Self {
        match value.as_str() {
            "DIRECTEXPANSION" => IfcEvaporatorTypeEnum::Directexpansion,
            "DIRECTEXPANSIONSHELLANDTUBE" => IfcEvaporatorTypeEnum::Directexpansionshellandtube,
            "DIRECTEXPANSIONTUBEINTUBE" => IfcEvaporatorTypeEnum::Directexpansiontubeintube,
            "DIRECTEXPANSIONBRAZEDPLATE" => IfcEvaporatorTypeEnum::Directexpansionbrazedplate,
            "FLOODEDSHELLANDTUBE" => IfcEvaporatorTypeEnum::Floodedshellandtube,
            "SHELLANDCOIL" => IfcEvaporatorTypeEnum::Shellandcoil,
            "USERDEFINED" => IfcEvaporatorTypeEnum::Userdefined,
            "NOTDEFINED" => IfcEvaporatorTypeEnum::Notdefined,
            _ => panic!("{} is not a valid value", value),
        }
    }
}
impl From<Parameter> for IfcEvaporatorTypeEnum {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EnumValue(value) => value.into(),
                _ => panic!("parameter is not an enum value"),
            },
            Parameter::OmittedParameter => IfcEvaporatorTypeEnum::default(),
            _ => panic!("parameter is not an enum value"),
        }
    }
}
#[derive(Eq, PartialEq, Hash, Debug)]
pub enum IfcEventTriggerTypeEnum {
    Eventrule,
    Eventmessage,
    Eventtime,
    Eventcomplex,
    Userdefined,
    Notdefined,
}
impl Default for IfcEventTriggerTypeEnum {
    fn default() -> Self {
        IfcEventTriggerTypeEnum::Eventrule
    }
}
impl From<String> for IfcEventTriggerTypeEnum {
    fn from(value: String) -> Self {
        match value.as_str() {
            "EVENTRULE" => IfcEventTriggerTypeEnum::Eventrule,
            "EVENTMESSAGE" => IfcEventTriggerTypeEnum::Eventmessage,
            "EVENTTIME" => IfcEventTriggerTypeEnum::Eventtime,
            "EVENTCOMPLEX" => IfcEventTriggerTypeEnum::Eventcomplex,
            "USERDEFINED" => IfcEventTriggerTypeEnum::Userdefined,
            "NOTDEFINED" => IfcEventTriggerTypeEnum::Notdefined,
            _ => panic!("{} is not a valid value", value),
        }
    }
}
impl From<Parameter> for IfcEventTriggerTypeEnum {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EnumValue(value) => value.into(),
                _ => panic!("parameter is not an enum value"),
            },
            Parameter::OmittedParameter => IfcEventTriggerTypeEnum::default(),
            _ => panic!("parameter is not an enum value"),
        }
    }
}
#[derive(Eq, PartialEq, Hash, Debug)]
pub enum IfcEventTypeEnum {
    Startevent,
    Endevent,
    Intermediateevent,
    Userdefined,
    Notdefined,
}
impl Default for IfcEventTypeEnum {
    fn default() -> Self {
        IfcEventTypeEnum::Startevent
    }
}
impl From<String> for IfcEventTypeEnum {
    fn from(value: String) -> Self {
        match value.as_str() {
            "STARTEVENT" => IfcEventTypeEnum::Startevent,
            "ENDEVENT" => IfcEventTypeEnum::Endevent,
            "INTERMEDIATEEVENT" => IfcEventTypeEnum::Intermediateevent,
            "USERDEFINED" => IfcEventTypeEnum::Userdefined,
            "NOTDEFINED" => IfcEventTypeEnum::Notdefined,
            _ => panic!("{} is not a valid value", value),
        }
    }
}
impl From<Parameter> for IfcEventTypeEnum {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EnumValue(value) => value.into(),
                _ => panic!("parameter is not an enum value"),
            },
            Parameter::OmittedParameter => IfcEventTypeEnum::default(),
            _ => panic!("parameter is not an enum value"),
        }
    }
}
#[derive(Eq, PartialEq, Hash, Debug)]
pub enum IfcExternalSpatialElementTypeEnum {
    External,
    ExternalEarth,
    ExternalWater,
    ExternalFire,
    Userdefined,
    Notdefined,
}
impl Default for IfcExternalSpatialElementTypeEnum {
    fn default() -> Self {
        IfcExternalSpatialElementTypeEnum::External
    }
}
impl From<String> for IfcExternalSpatialElementTypeEnum {
    fn from(value: String) -> Self {
        match value.as_str() {
            "EXTERNAL" => IfcExternalSpatialElementTypeEnum::External,
            "EXTERNAL_EARTH" => IfcExternalSpatialElementTypeEnum::ExternalEarth,
            "EXTERNAL_WATER" => IfcExternalSpatialElementTypeEnum::ExternalWater,
            "EXTERNAL_FIRE" => IfcExternalSpatialElementTypeEnum::ExternalFire,
            "USERDEFINED" => IfcExternalSpatialElementTypeEnum::Userdefined,
            "NOTDEFINED" => IfcExternalSpatialElementTypeEnum::Notdefined,
            _ => panic!("{} is not a valid value", value),
        }
    }
}
impl From<Parameter> for IfcExternalSpatialElementTypeEnum {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EnumValue(value) => value.into(),
                _ => panic!("parameter is not an enum value"),
            },
            Parameter::OmittedParameter => IfcExternalSpatialElementTypeEnum::default(),
            _ => panic!("parameter is not an enum value"),
        }
    }
}
#[derive(Eq, PartialEq, Hash, Debug)]
pub enum IfcFanTypeEnum {
    Centrifugalforwardcurved,
    Centrifugalradial,
    Centrifugalbackwardinclinedcurved,
    Centrifugalairfoil,
    Tubeaxial,
    Vaneaxial,
    Propelloraxial,
    Userdefined,
    Notdefined,
}
impl Default for IfcFanTypeEnum {
    fn default() -> Self {
        IfcFanTypeEnum::Centrifugalforwardcurved
    }
}
impl From<String> for IfcFanTypeEnum {
    fn from(value: String) -> Self {
        match value.as_str() {
            "CENTRIFUGALFORWARDCURVED" => IfcFanTypeEnum::Centrifugalforwardcurved,
            "CENTRIFUGALRADIAL" => IfcFanTypeEnum::Centrifugalradial,
            "CENTRIFUGALBACKWARDINCLINEDCURVED" => IfcFanTypeEnum::Centrifugalbackwardinclinedcurved,
            "CENTRIFUGALAIRFOIL" => IfcFanTypeEnum::Centrifugalairfoil,
            "TUBEAXIAL" => IfcFanTypeEnum::Tubeaxial,
            "VANEAXIAL" => IfcFanTypeEnum::Vaneaxial,
            "PROPELLORAXIAL" => IfcFanTypeEnum::Propelloraxial,
            "USERDEFINED" => IfcFanTypeEnum::Userdefined,
            "NOTDEFINED" => IfcFanTypeEnum::Notdefined,
            _ => panic!("{} is not a valid value", value),
        }
    }
}
impl From<Parameter> for IfcFanTypeEnum {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EnumValue(value) => value.into(),
                _ => panic!("parameter is not an enum value"),
            },
            Parameter::OmittedParameter => IfcFanTypeEnum::default(),
            _ => panic!("parameter is not an enum value"),
        }
    }
}
#[derive(Eq, PartialEq, Hash, Debug)]
pub enum IfcFastenerTypeEnum {
    Glue,
    Mortar,
    Weld,
    Userdefined,
    Notdefined,
}
impl Default for IfcFastenerTypeEnum {
    fn default() -> Self {
        IfcFastenerTypeEnum::Glue
    }
}
impl From<String> for IfcFastenerTypeEnum {
    fn from(value: String) -> Self {
        match value.as_str() {
            "GLUE" => IfcFastenerTypeEnum::Glue,
            "MORTAR" => IfcFastenerTypeEnum::Mortar,
            "WELD" => IfcFastenerTypeEnum::Weld,
            "USERDEFINED" => IfcFastenerTypeEnum::Userdefined,
            "NOTDEFINED" => IfcFastenerTypeEnum::Notdefined,
            _ => panic!("{} is not a valid value", value),
        }
    }
}
impl From<Parameter> for IfcFastenerTypeEnum {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EnumValue(value) => value.into(),
                _ => panic!("parameter is not an enum value"),
            },
            Parameter::OmittedParameter => IfcFastenerTypeEnum::default(),
            _ => panic!("parameter is not an enum value"),
        }
    }
}
#[derive(Eq, PartialEq, Hash, Debug)]
pub enum IfcFilterTypeEnum {
    Airparticlefilter,
    Compressedairfilter,
    Odorfilter,
    Oilfilter,
    Strainer,
    Waterfilter,
    Userdefined,
    Notdefined,
}
impl Default for IfcFilterTypeEnum {
    fn default() -> Self {
        IfcFilterTypeEnum::Airparticlefilter
    }
}
impl From<String> for IfcFilterTypeEnum {
    fn from(value: String) -> Self {
        match value.as_str() {
            "AIRPARTICLEFILTER" => IfcFilterTypeEnum::Airparticlefilter,
            "COMPRESSEDAIRFILTER" => IfcFilterTypeEnum::Compressedairfilter,
            "ODORFILTER" => IfcFilterTypeEnum::Odorfilter,
            "OILFILTER" => IfcFilterTypeEnum::Oilfilter,
            "STRAINER" => IfcFilterTypeEnum::Strainer,
            "WATERFILTER" => IfcFilterTypeEnum::Waterfilter,
            "USERDEFINED" => IfcFilterTypeEnum::Userdefined,
            "NOTDEFINED" => IfcFilterTypeEnum::Notdefined,
            _ => panic!("{} is not a valid value", value),
        }
    }
}
impl From<Parameter> for IfcFilterTypeEnum {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EnumValue(value) => value.into(),
                _ => panic!("parameter is not an enum value"),
            },
            Parameter::OmittedParameter => IfcFilterTypeEnum::default(),
            _ => panic!("parameter is not an enum value"),
        }
    }
}
#[derive(Eq, PartialEq, Hash, Debug)]
pub enum IfcFireSuppressionTerminalTypeEnum {
    Breechinginlet,
    Firehydrant,
    Hosereel,
    Sprinkler,
    Sprinklerdeflector,
    Userdefined,
    Notdefined,
}
impl Default for IfcFireSuppressionTerminalTypeEnum {
    fn default() -> Self {
        IfcFireSuppressionTerminalTypeEnum::Breechinginlet
    }
}
impl From<String> for IfcFireSuppressionTerminalTypeEnum {
    fn from(value: String) -> Self {
        match value.as_str() {
            "BREECHINGINLET" => IfcFireSuppressionTerminalTypeEnum::Breechinginlet,
            "FIREHYDRANT" => IfcFireSuppressionTerminalTypeEnum::Firehydrant,
            "HOSEREEL" => IfcFireSuppressionTerminalTypeEnum::Hosereel,
            "SPRINKLER" => IfcFireSuppressionTerminalTypeEnum::Sprinkler,
            "SPRINKLERDEFLECTOR" => IfcFireSuppressionTerminalTypeEnum::Sprinklerdeflector,
            "USERDEFINED" => IfcFireSuppressionTerminalTypeEnum::Userdefined,
            "NOTDEFINED" => IfcFireSuppressionTerminalTypeEnum::Notdefined,
            _ => panic!("{} is not a valid value", value),
        }
    }
}
impl From<Parameter> for IfcFireSuppressionTerminalTypeEnum {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EnumValue(value) => value.into(),
                _ => panic!("parameter is not an enum value"),
            },
            Parameter::OmittedParameter => IfcFireSuppressionTerminalTypeEnum::default(),
            _ => panic!("parameter is not an enum value"),
        }
    }
}
#[derive(Eq, PartialEq, Hash, Debug)]
pub enum IfcFlowDirectionEnum {
    Source,
    Sink,
    Sourceandsink,
    Notdefined,
}
impl Default for IfcFlowDirectionEnum {
    fn default() -> Self {
        IfcFlowDirectionEnum::Source
    }
}
impl From<String> for IfcFlowDirectionEnum {
    fn from(value: String) -> Self {
        match value.as_str() {
            "SOURCE" => IfcFlowDirectionEnum::Source,
            "SINK" => IfcFlowDirectionEnum::Sink,
            "SOURCEANDSINK" => IfcFlowDirectionEnum::Sourceandsink,
            "NOTDEFINED" => IfcFlowDirectionEnum::Notdefined,
            _ => panic!("{} is not a valid value", value),
        }
    }
}
impl From<Parameter> for IfcFlowDirectionEnum {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EnumValue(value) => value.into(),
                _ => panic!("parameter is not an enum value"),
            },
            Parameter::OmittedParameter => IfcFlowDirectionEnum::default(),
            _ => panic!("parameter is not an enum value"),
        }
    }
}
#[derive(Eq, PartialEq, Hash, Debug)]
pub enum IfcFlowInstrumentTypeEnum {
    Pressuregauge,
    Thermometer,
    Ammeter,
    Frequencymeter,
    Powerfactormeter,
    Phaseanglemeter,
    VoltmeterPeak,
    VoltmeterRms,
    Userdefined,
    Notdefined,
}
impl Default for IfcFlowInstrumentTypeEnum {
    fn default() -> Self {
        IfcFlowInstrumentTypeEnum::Pressuregauge
    }
}
impl From<String> for IfcFlowInstrumentTypeEnum {
    fn from(value: String) -> Self {
        match value.as_str() {
            "PRESSUREGAUGE" => IfcFlowInstrumentTypeEnum::Pressuregauge,
            "THERMOMETER" => IfcFlowInstrumentTypeEnum::Thermometer,
            "AMMETER" => IfcFlowInstrumentTypeEnum::Ammeter,
            "FREQUENCYMETER" => IfcFlowInstrumentTypeEnum::Frequencymeter,
            "POWERFACTORMETER" => IfcFlowInstrumentTypeEnum::Powerfactormeter,
            "PHASEANGLEMETER" => IfcFlowInstrumentTypeEnum::Phaseanglemeter,
            "VOLTMETER_PEAK" => IfcFlowInstrumentTypeEnum::VoltmeterPeak,
            "VOLTMETER_RMS" => IfcFlowInstrumentTypeEnum::VoltmeterRms,
            "USERDEFINED" => IfcFlowInstrumentTypeEnum::Userdefined,
            "NOTDEFINED" => IfcFlowInstrumentTypeEnum::Notdefined,
            _ => panic!("{} is not a valid value", value),
        }
    }
}
impl From<Parameter> for IfcFlowInstrumentTypeEnum {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EnumValue(value) => value.into(),
                _ => panic!("parameter is not an enum value"),
            },
            Parameter::OmittedParameter => IfcFlowInstrumentTypeEnum::default(),
            _ => panic!("parameter is not an enum value"),
        }
    }
}
#[derive(Eq, PartialEq, Hash, Debug)]
pub enum IfcFlowMeterTypeEnum {
    Energymeter,
    Gasmeter,
    Oilmeter,
    Watermeter,
    Userdefined,
    Notdefined,
}
impl Default for IfcFlowMeterTypeEnum {
    fn default() -> Self {
        IfcFlowMeterTypeEnum::Energymeter
    }
}
impl From<String> for IfcFlowMeterTypeEnum {
    fn from(value: String) -> Self {
        match value.as_str() {
            "ENERGYMETER" => IfcFlowMeterTypeEnum::Energymeter,
            "GASMETER" => IfcFlowMeterTypeEnum::Gasmeter,
            "OILMETER" => IfcFlowMeterTypeEnum::Oilmeter,
            "WATERMETER" => IfcFlowMeterTypeEnum::Watermeter,
            "USERDEFINED" => IfcFlowMeterTypeEnum::Userdefined,
            "NOTDEFINED" => IfcFlowMeterTypeEnum::Notdefined,
            _ => panic!("{} is not a valid value", value),
        }
    }
}
impl From<Parameter> for IfcFlowMeterTypeEnum {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EnumValue(value) => value.into(),
                _ => panic!("parameter is not an enum value"),
            },
            Parameter::OmittedParameter => IfcFlowMeterTypeEnum::default(),
            _ => panic!("parameter is not an enum value"),
        }
    }
}
#[derive(Eq, PartialEq, Hash, Debug)]
pub enum IfcFootingTypeEnum {
    CaissonFoundation,
    FootingBeam,
    PadFooting,
    PileCap,
    StripFooting,
    Userdefined,
    Notdefined,
}
impl Default for IfcFootingTypeEnum {
    fn default() -> Self {
        IfcFootingTypeEnum::CaissonFoundation
    }
}
impl From<String> for IfcFootingTypeEnum {
    fn from(value: String) -> Self {
        match value.as_str() {
            "CAISSON_FOUNDATION" => IfcFootingTypeEnum::CaissonFoundation,
            "FOOTING_BEAM" => IfcFootingTypeEnum::FootingBeam,
            "PAD_FOOTING" => IfcFootingTypeEnum::PadFooting,
            "PILE_CAP" => IfcFootingTypeEnum::PileCap,
            "STRIP_FOOTING" => IfcFootingTypeEnum::StripFooting,
            "USERDEFINED" => IfcFootingTypeEnum::Userdefined,
            "NOTDEFINED" => IfcFootingTypeEnum::Notdefined,
            _ => panic!("{} is not a valid value", value),
        }
    }
}
impl From<Parameter> for IfcFootingTypeEnum {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EnumValue(value) => value.into(),
                _ => panic!("parameter is not an enum value"),
            },
            Parameter::OmittedParameter => IfcFootingTypeEnum::default(),
            _ => panic!("parameter is not an enum value"),
        }
    }
}
#[derive(Eq, PartialEq, Hash, Debug)]
pub enum IfcFurnitureTypeEnum {
    Chair,
    Table,
    Desk,
    Bed,
    Filecabinet,
    Shelf,
    Sofa,
    Userdefined,
    Notdefined,
}
impl Default for IfcFurnitureTypeEnum {
    fn default() -> Self {
        IfcFurnitureTypeEnum::Chair
    }
}
impl From<String> for IfcFurnitureTypeEnum {
    fn from(value: String) -> Self {
        match value.as_str() {
            "CHAIR" => IfcFurnitureTypeEnum::Chair,
            "TABLE" => IfcFurnitureTypeEnum::Table,
            "DESK" => IfcFurnitureTypeEnum::Desk,
            "BED" => IfcFurnitureTypeEnum::Bed,
            "FILECABINET" => IfcFurnitureTypeEnum::Filecabinet,
            "SHELF" => IfcFurnitureTypeEnum::Shelf,
            "SOFA" => IfcFurnitureTypeEnum::Sofa,
            "USERDEFINED" => IfcFurnitureTypeEnum::Userdefined,
            "NOTDEFINED" => IfcFurnitureTypeEnum::Notdefined,
            _ => panic!("{} is not a valid value", value),
        }
    }
}
impl From<Parameter> for IfcFurnitureTypeEnum {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EnumValue(value) => value.into(),
                _ => panic!("parameter is not an enum value"),
            },
            Parameter::OmittedParameter => IfcFurnitureTypeEnum::default(),
            _ => panic!("parameter is not an enum value"),
        }
    }
}
#[derive(Eq, PartialEq, Hash, Debug)]
pub enum IfcGeographicElementTypeEnum {
    Terrain,
    Userdefined,
    Notdefined,
}
impl Default for IfcGeographicElementTypeEnum {
    fn default() -> Self {
        IfcGeographicElementTypeEnum::Terrain
    }
}
impl From<String> for IfcGeographicElementTypeEnum {
    fn from(value: String) -> Self {
        match value.as_str() {
            "TERRAIN" => IfcGeographicElementTypeEnum::Terrain,
            "USERDEFINED" => IfcGeographicElementTypeEnum::Userdefined,
            "NOTDEFINED" => IfcGeographicElementTypeEnum::Notdefined,
            _ => panic!("{} is not a valid value", value),
        }
    }
}
impl From<Parameter> for IfcGeographicElementTypeEnum {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EnumValue(value) => value.into(),
                _ => panic!("parameter is not an enum value"),
            },
            Parameter::OmittedParameter => IfcGeographicElementTypeEnum::default(),
            _ => panic!("parameter is not an enum value"),
        }
    }
}
#[derive(Eq, PartialEq, Hash, Debug)]
pub enum IfcGeometricProjectionEnum {
    GraphView,
    SketchView,
    ModelView,
    PlanView,
    ReflectedPlanView,
    SectionView,
    ElevationView,
    Userdefined,
    Notdefined,
}
impl Default for IfcGeometricProjectionEnum {
    fn default() -> Self {
        IfcGeometricProjectionEnum::GraphView
    }
}
impl From<String> for IfcGeometricProjectionEnum {
    fn from(value: String) -> Self {
        match value.as_str() {
            "GRAPH_VIEW" => IfcGeometricProjectionEnum::GraphView,
            "SKETCH_VIEW" => IfcGeometricProjectionEnum::SketchView,
            "MODEL_VIEW" => IfcGeometricProjectionEnum::ModelView,
            "PLAN_VIEW" => IfcGeometricProjectionEnum::PlanView,
            "REFLECTED_PLAN_VIEW" => IfcGeometricProjectionEnum::ReflectedPlanView,
            "SECTION_VIEW" => IfcGeometricProjectionEnum::SectionView,
            "ELEVATION_VIEW" => IfcGeometricProjectionEnum::ElevationView,
            "USERDEFINED" => IfcGeometricProjectionEnum::Userdefined,
            "NOTDEFINED" => IfcGeometricProjectionEnum::Notdefined,
            _ => panic!("{} is not a valid value", value),
        }
    }
}
impl From<Parameter> for IfcGeometricProjectionEnum {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EnumValue(value) => value.into(),
                _ => panic!("parameter is not an enum value"),
            },
            Parameter::OmittedParameter => IfcGeometricProjectionEnum::default(),
            _ => panic!("parameter is not an enum value"),
        }
    }
}
#[derive(Eq, PartialEq, Hash, Debug)]
pub enum IfcGlobalOrLocalEnum {
    GlobalCoords,
    LocalCoords,
}
impl Default for IfcGlobalOrLocalEnum {
    fn default() -> Self {
        IfcGlobalOrLocalEnum::GlobalCoords
    }
}
impl From<String> for IfcGlobalOrLocalEnum {
    fn from(value: String) -> Self {
        match value.as_str() {
            "GLOBAL_COORDS" => IfcGlobalOrLocalEnum::GlobalCoords,
            "LOCAL_COORDS" => IfcGlobalOrLocalEnum::LocalCoords,
            _ => panic!("{} is not a valid value", value),
        }
    }
}
impl From<Parameter> for IfcGlobalOrLocalEnum {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EnumValue(value) => value.into(),
                _ => panic!("parameter is not an enum value"),
            },
            Parameter::OmittedParameter => IfcGlobalOrLocalEnum::default(),
            _ => panic!("parameter is not an enum value"),
        }
    }
}
#[derive(Eq, PartialEq, Hash, Debug)]
pub enum IfcGridTypeEnum {
    Rectangular,
    Radial,
    Triangular,
    Irregular,
    Userdefined,
    Notdefined,
}
impl Default for IfcGridTypeEnum {
    fn default() -> Self {
        IfcGridTypeEnum::Rectangular
    }
}
impl From<String> for IfcGridTypeEnum {
    fn from(value: String) -> Self {
        match value.as_str() {
            "RECTANGULAR" => IfcGridTypeEnum::Rectangular,
            "RADIAL" => IfcGridTypeEnum::Radial,
            "TRIANGULAR" => IfcGridTypeEnum::Triangular,
            "IRREGULAR" => IfcGridTypeEnum::Irregular,
            "USERDEFINED" => IfcGridTypeEnum::Userdefined,
            "NOTDEFINED" => IfcGridTypeEnum::Notdefined,
            _ => panic!("{} is not a valid value", value),
        }
    }
}
impl From<Parameter> for IfcGridTypeEnum {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EnumValue(value) => value.into(),
                _ => panic!("parameter is not an enum value"),
            },
            Parameter::OmittedParameter => IfcGridTypeEnum::default(),
            _ => panic!("parameter is not an enum value"),
        }
    }
}
#[derive(Eq, PartialEq, Hash, Debug)]
pub enum IfcHeatExchangerTypeEnum {
    Plate,
    Shellandtube,
    Userdefined,
    Notdefined,
}
impl Default for IfcHeatExchangerTypeEnum {
    fn default() -> Self {
        IfcHeatExchangerTypeEnum::Plate
    }
}
impl From<String> for IfcHeatExchangerTypeEnum {
    fn from(value: String) -> Self {
        match value.as_str() {
            "PLATE" => IfcHeatExchangerTypeEnum::Plate,
            "SHELLANDTUBE" => IfcHeatExchangerTypeEnum::Shellandtube,
            "USERDEFINED" => IfcHeatExchangerTypeEnum::Userdefined,
            "NOTDEFINED" => IfcHeatExchangerTypeEnum::Notdefined,
            _ => panic!("{} is not a valid value", value),
        }
    }
}
impl From<Parameter> for IfcHeatExchangerTypeEnum {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EnumValue(value) => value.into(),
                _ => panic!("parameter is not an enum value"),
            },
            Parameter::OmittedParameter => IfcHeatExchangerTypeEnum::default(),
            _ => panic!("parameter is not an enum value"),
        }
    }
}
#[derive(Eq, PartialEq, Hash, Debug)]
pub enum IfcHumidifierTypeEnum {
    Steaminjection,
    Adiabaticairwasher,
    Adiabaticpan,
    Adiabaticwettedelement,
    Adiabaticatomizing,
    Adiabaticultrasonic,
    Adiabaticrigidmedia,
    Adiabaticcompressedairnozzle,
    Assistedelectric,
    Assistednaturalgas,
    Assistedpropane,
    Assistedbutane,
    Assistedsteam,
    Userdefined,
    Notdefined,
}
impl Default for IfcHumidifierTypeEnum {
    fn default() -> Self {
        IfcHumidifierTypeEnum::Steaminjection
    }
}
impl From<String> for IfcHumidifierTypeEnum {
    fn from(value: String) -> Self {
        match value.as_str() {
            "STEAMINJECTION" => IfcHumidifierTypeEnum::Steaminjection,
            "ADIABATICAIRWASHER" => IfcHumidifierTypeEnum::Adiabaticairwasher,
            "ADIABATICPAN" => IfcHumidifierTypeEnum::Adiabaticpan,
            "ADIABATICWETTEDELEMENT" => IfcHumidifierTypeEnum::Adiabaticwettedelement,
            "ADIABATICATOMIZING" => IfcHumidifierTypeEnum::Adiabaticatomizing,
            "ADIABATICULTRASONIC" => IfcHumidifierTypeEnum::Adiabaticultrasonic,
            "ADIABATICRIGIDMEDIA" => IfcHumidifierTypeEnum::Adiabaticrigidmedia,
            "ADIABATICCOMPRESSEDAIRNOZZLE" => IfcHumidifierTypeEnum::Adiabaticcompressedairnozzle,
            "ASSISTEDELECTRIC" => IfcHumidifierTypeEnum::Assistedelectric,
            "ASSISTEDNATURALGAS" => IfcHumidifierTypeEnum::Assistednaturalgas,
            "ASSISTEDPROPANE" => IfcHumidifierTypeEnum::Assistedpropane,
            "ASSISTEDBUTANE" => IfcHumidifierTypeEnum::Assistedbutane,
            "ASSISTEDSTEAM" => IfcHumidifierTypeEnum::Assistedsteam,
            "USERDEFINED" => IfcHumidifierTypeEnum::Userdefined,
            "NOTDEFINED" => IfcHumidifierTypeEnum::Notdefined,
            _ => panic!("{} is not a valid value", value),
        }
    }
}
impl From<Parameter> for IfcHumidifierTypeEnum {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EnumValue(value) => value.into(),
                _ => panic!("parameter is not an enum value"),
            },
            Parameter::OmittedParameter => IfcHumidifierTypeEnum::default(),
            _ => panic!("parameter is not an enum value"),
        }
    }
}
#[derive(Eq, PartialEq, Hash, Debug)]
pub enum IfcInterceptorTypeEnum {
    Cyclonic,
    Grease,
    Oil,
    Petrol,
    Userdefined,
    Notdefined,
}
impl Default for IfcInterceptorTypeEnum {
    fn default() -> Self {
        IfcInterceptorTypeEnum::Cyclonic
    }
}
impl From<String> for IfcInterceptorTypeEnum {
    fn from(value: String) -> Self {
        match value.as_str() {
            "CYCLONIC" => IfcInterceptorTypeEnum::Cyclonic,
            "GREASE" => IfcInterceptorTypeEnum::Grease,
            "OIL" => IfcInterceptorTypeEnum::Oil,
            "PETROL" => IfcInterceptorTypeEnum::Petrol,
            "USERDEFINED" => IfcInterceptorTypeEnum::Userdefined,
            "NOTDEFINED" => IfcInterceptorTypeEnum::Notdefined,
            _ => panic!("{} is not a valid value", value),
        }
    }
}
impl From<Parameter> for IfcInterceptorTypeEnum {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EnumValue(value) => value.into(),
                _ => panic!("parameter is not an enum value"),
            },
            Parameter::OmittedParameter => IfcInterceptorTypeEnum::default(),
            _ => panic!("parameter is not an enum value"),
        }
    }
}
#[derive(Eq, PartialEq, Hash, Debug)]
pub enum IfcInternalOrExternalEnum {
    Internal,
    External,
    ExternalEarth,
    ExternalWater,
    ExternalFire,
    Notdefined,
}
impl Default for IfcInternalOrExternalEnum {
    fn default() -> Self {
        IfcInternalOrExternalEnum::Internal
    }
}
impl From<String> for IfcInternalOrExternalEnum {
    fn from(value: String) -> Self {
        match value.as_str() {
            "INTERNAL" => IfcInternalOrExternalEnum::Internal,
            "EXTERNAL" => IfcInternalOrExternalEnum::External,
            "EXTERNAL_EARTH" => IfcInternalOrExternalEnum::ExternalEarth,
            "EXTERNAL_WATER" => IfcInternalOrExternalEnum::ExternalWater,
            "EXTERNAL_FIRE" => IfcInternalOrExternalEnum::ExternalFire,
            "NOTDEFINED" => IfcInternalOrExternalEnum::Notdefined,
            _ => panic!("{} is not a valid value", value),
        }
    }
}
impl From<Parameter> for IfcInternalOrExternalEnum {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EnumValue(value) => value.into(),
                _ => panic!("parameter is not an enum value"),
            },
            Parameter::OmittedParameter => IfcInternalOrExternalEnum::default(),
            _ => panic!("parameter is not an enum value"),
        }
    }
}
#[derive(Eq, PartialEq, Hash, Debug)]
pub enum IfcInventoryTypeEnum {
    Assetinventory,
    Spaceinventory,
    Furnitureinventory,
    Userdefined,
    Notdefined,
}
impl Default for IfcInventoryTypeEnum {
    fn default() -> Self {
        IfcInventoryTypeEnum::Assetinventory
    }
}
impl From<String> for IfcInventoryTypeEnum {
    fn from(value: String) -> Self {
        match value.as_str() {
            "ASSETINVENTORY" => IfcInventoryTypeEnum::Assetinventory,
            "SPACEINVENTORY" => IfcInventoryTypeEnum::Spaceinventory,
            "FURNITUREINVENTORY" => IfcInventoryTypeEnum::Furnitureinventory,
            "USERDEFINED" => IfcInventoryTypeEnum::Userdefined,
            "NOTDEFINED" => IfcInventoryTypeEnum::Notdefined,
            _ => panic!("{} is not a valid value", value),
        }
    }
}
impl From<Parameter> for IfcInventoryTypeEnum {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EnumValue(value) => value.into(),
                _ => panic!("parameter is not an enum value"),
            },
            Parameter::OmittedParameter => IfcInventoryTypeEnum::default(),
            _ => panic!("parameter is not an enum value"),
        }
    }
}
#[derive(Eq, PartialEq, Hash, Debug)]
pub enum IfcJunctionBoxTypeEnum {
    Data,
    Power,
    Userdefined,
    Notdefined,
}
impl Default for IfcJunctionBoxTypeEnum {
    fn default() -> Self {
        IfcJunctionBoxTypeEnum::Data
    }
}
impl From<String> for IfcJunctionBoxTypeEnum {
    fn from(value: String) -> Self {
        match value.as_str() {
            "DATA" => IfcJunctionBoxTypeEnum::Data,
            "POWER" => IfcJunctionBoxTypeEnum::Power,
            "USERDEFINED" => IfcJunctionBoxTypeEnum::Userdefined,
            "NOTDEFINED" => IfcJunctionBoxTypeEnum::Notdefined,
            _ => panic!("{} is not a valid value", value),
        }
    }
}
impl From<Parameter> for IfcJunctionBoxTypeEnum {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EnumValue(value) => value.into(),
                _ => panic!("parameter is not an enum value"),
            },
            Parameter::OmittedParameter => IfcJunctionBoxTypeEnum::default(),
            _ => panic!("parameter is not an enum value"),
        }
    }
}
#[derive(Eq, PartialEq, Hash, Debug)]
pub enum IfcKnotType {
    UniformKnots,
    QuasiUniformKnots,
    PiecewiseBezierKnots,
    Unspecified,
}
impl Default for IfcKnotType {
    fn default() -> Self {
        IfcKnotType::UniformKnots
    }
}
impl From<String> for IfcKnotType {
    fn from(value: String) -> Self {
        match value.as_str() {
            "UNIFORM_KNOTS" => IfcKnotType::UniformKnots,
            "QUASI_UNIFORM_KNOTS" => IfcKnotType::QuasiUniformKnots,
            "PIECEWISE_BEZIER_KNOTS" => IfcKnotType::PiecewiseBezierKnots,
            "UNSPECIFIED" => IfcKnotType::Unspecified,
            _ => panic!("{} is not a valid value", value),
        }
    }
}
impl From<Parameter> for IfcKnotType {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EnumValue(value) => value.into(),
                _ => panic!("parameter is not an enum value"),
            },
            Parameter::OmittedParameter => IfcKnotType::default(),
            _ => panic!("parameter is not an enum value"),
        }
    }
}
#[derive(Eq, PartialEq, Hash, Debug)]
pub enum IfcLaborResourceTypeEnum {
    Administration,
    Carpentry,
    Cleaning,
    Concrete,
    Drywall,
    Electric,
    Finishing,
    Flooring,
    General,
    Hvac,
    Landscaping,
    Masonry,
    Painting,
    Paving,
    Plumbing,
    Roofing,
    Sitegrading,
    Steelwork,
    Surveying,
    Userdefined,
    Notdefined,
}
impl Default for IfcLaborResourceTypeEnum {
    fn default() -> Self {
        IfcLaborResourceTypeEnum::Administration
    }
}
impl From<String> for IfcLaborResourceTypeEnum {
    fn from(value: String) -> Self {
        match value.as_str() {
            "ADMINISTRATION" => IfcLaborResourceTypeEnum::Administration,
            "CARPENTRY" => IfcLaborResourceTypeEnum::Carpentry,
            "CLEANING" => IfcLaborResourceTypeEnum::Cleaning,
            "CONCRETE" => IfcLaborResourceTypeEnum::Concrete,
            "DRYWALL" => IfcLaborResourceTypeEnum::Drywall,
            "ELECTRIC" => IfcLaborResourceTypeEnum::Electric,
            "FINISHING" => IfcLaborResourceTypeEnum::Finishing,
            "FLOORING" => IfcLaborResourceTypeEnum::Flooring,
            "GENERAL" => IfcLaborResourceTypeEnum::General,
            "HVAC" => IfcLaborResourceTypeEnum::Hvac,
            "LANDSCAPING" => IfcLaborResourceTypeEnum::Landscaping,
            "MASONRY" => IfcLaborResourceTypeEnum::Masonry,
            "PAINTING" => IfcLaborResourceTypeEnum::Painting,
            "PAVING" => IfcLaborResourceTypeEnum::Paving,
            "PLUMBING" => IfcLaborResourceTypeEnum::Plumbing,
            "ROOFING" => IfcLaborResourceTypeEnum::Roofing,
            "SITEGRADING" => IfcLaborResourceTypeEnum::Sitegrading,
            "STEELWORK" => IfcLaborResourceTypeEnum::Steelwork,
            "SURVEYING" => IfcLaborResourceTypeEnum::Surveying,
            "USERDEFINED" => IfcLaborResourceTypeEnum::Userdefined,
            "NOTDEFINED" => IfcLaborResourceTypeEnum::Notdefined,
            _ => panic!("{} is not a valid value", value),
        }
    }
}
impl From<Parameter> for IfcLaborResourceTypeEnum {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EnumValue(value) => value.into(),
                _ => panic!("parameter is not an enum value"),
            },
            Parameter::OmittedParameter => IfcLaborResourceTypeEnum::default(),
            _ => panic!("parameter is not an enum value"),
        }
    }
}
#[derive(Eq, PartialEq, Hash, Debug)]
pub enum IfcLampTypeEnum {
    Compactfluorescent,
    Fluorescent,
    Halogen,
    Highpressuremercury,
    Highpressuresodium,
    Led,
    Metalhalide,
    Oled,
    Tungstenfilament,
    Userdefined,
    Notdefined,
}
impl Default for IfcLampTypeEnum {
    fn default() -> Self {
        IfcLampTypeEnum::Compactfluorescent
    }
}
impl From<String> for IfcLampTypeEnum {
    fn from(value: String) -> Self {
        match value.as_str() {
            "COMPACTFLUORESCENT" => IfcLampTypeEnum::Compactfluorescent,
            "FLUORESCENT" => IfcLampTypeEnum::Fluorescent,
            "HALOGEN" => IfcLampTypeEnum::Halogen,
            "HIGHPRESSUREMERCURY" => IfcLampTypeEnum::Highpressuremercury,
            "HIGHPRESSURESODIUM" => IfcLampTypeEnum::Highpressuresodium,
            "LED" => IfcLampTypeEnum::Led,
            "METALHALIDE" => IfcLampTypeEnum::Metalhalide,
            "OLED" => IfcLampTypeEnum::Oled,
            "TUNGSTENFILAMENT" => IfcLampTypeEnum::Tungstenfilament,
            "USERDEFINED" => IfcLampTypeEnum::Userdefined,
            "NOTDEFINED" => IfcLampTypeEnum::Notdefined,
            _ => panic!("{} is not a valid value", value),
        }
    }
}
impl From<Parameter> for IfcLampTypeEnum {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EnumValue(value) => value.into(),
                _ => panic!("parameter is not an enum value"),
            },
            Parameter::OmittedParameter => IfcLampTypeEnum::default(),
            _ => panic!("parameter is not an enum value"),
        }
    }
}
#[derive(Eq, PartialEq, Hash, Debug)]
pub enum IfcLayerSetDirectionEnum {
    Axis1,
    Axis2,
    Axis3,
}
impl Default for IfcLayerSetDirectionEnum {
    fn default() -> Self {
        IfcLayerSetDirectionEnum::Axis1
    }
}
impl From<String> for IfcLayerSetDirectionEnum {
    fn from(value: String) -> Self {
        match value.as_str() {
            "AXIS1" => IfcLayerSetDirectionEnum::Axis1,
            "AXIS2" => IfcLayerSetDirectionEnum::Axis2,
            "AXIS3" => IfcLayerSetDirectionEnum::Axis3,
            _ => panic!("{} is not a valid value", value),
        }
    }
}
impl From<Parameter> for IfcLayerSetDirectionEnum {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EnumValue(value) => value.into(),
                _ => panic!("parameter is not an enum value"),
            },
            Parameter::OmittedParameter => IfcLayerSetDirectionEnum::default(),
            _ => panic!("parameter is not an enum value"),
        }
    }
}
#[derive(Eq, PartialEq, Hash, Debug)]
pub enum IfcLightDistributionCurveEnum {
    TypeA,
    TypeB,
    TypeC,
    Notdefined,
}
impl Default for IfcLightDistributionCurveEnum {
    fn default() -> Self {
        IfcLightDistributionCurveEnum::TypeA
    }
}
impl From<String> for IfcLightDistributionCurveEnum {
    fn from(value: String) -> Self {
        match value.as_str() {
            "TYPE_A" => IfcLightDistributionCurveEnum::TypeA,
            "TYPE_B" => IfcLightDistributionCurveEnum::TypeB,
            "TYPE_C" => IfcLightDistributionCurveEnum::TypeC,
            "NOTDEFINED" => IfcLightDistributionCurveEnum::Notdefined,
            _ => panic!("{} is not a valid value", value),
        }
    }
}
impl From<Parameter> for IfcLightDistributionCurveEnum {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EnumValue(value) => value.into(),
                _ => panic!("parameter is not an enum value"),
            },
            Parameter::OmittedParameter => IfcLightDistributionCurveEnum::default(),
            _ => panic!("parameter is not an enum value"),
        }
    }
}
#[derive(Eq, PartialEq, Hash, Debug)]
pub enum IfcLightEmissionSourceEnum {
    Compactfluorescent,
    Fluorescent,
    Highpressuremercury,
    Highpressuresodium,
    Lightemittingdiode,
    Lowpressuresodium,
    Lowvoltagehalogen,
    Mainvoltagehalogen,
    Metalhalide,
    Tungstenfilament,
    Notdefined,
}
impl Default for IfcLightEmissionSourceEnum {
    fn default() -> Self {
        IfcLightEmissionSourceEnum::Compactfluorescent
    }
}
impl From<String> for IfcLightEmissionSourceEnum {
    fn from(value: String) -> Self {
        match value.as_str() {
            "COMPACTFLUORESCENT" => IfcLightEmissionSourceEnum::Compactfluorescent,
            "FLUORESCENT" => IfcLightEmissionSourceEnum::Fluorescent,
            "HIGHPRESSUREMERCURY" => IfcLightEmissionSourceEnum::Highpressuremercury,
            "HIGHPRESSURESODIUM" => IfcLightEmissionSourceEnum::Highpressuresodium,
            "LIGHTEMITTINGDIODE" => IfcLightEmissionSourceEnum::Lightemittingdiode,
            "LOWPRESSURESODIUM" => IfcLightEmissionSourceEnum::Lowpressuresodium,
            "LOWVOLTAGEHALOGEN" => IfcLightEmissionSourceEnum::Lowvoltagehalogen,
            "MAINVOLTAGEHALOGEN" => IfcLightEmissionSourceEnum::Mainvoltagehalogen,
            "METALHALIDE" => IfcLightEmissionSourceEnum::Metalhalide,
            "TUNGSTENFILAMENT" => IfcLightEmissionSourceEnum::Tungstenfilament,
            "NOTDEFINED" => IfcLightEmissionSourceEnum::Notdefined,
            _ => panic!("{} is not a valid value", value),
        }
    }
}
impl From<Parameter> for IfcLightEmissionSourceEnum {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EnumValue(value) => value.into(),
                _ => panic!("parameter is not an enum value"),
            },
            Parameter::OmittedParameter => IfcLightEmissionSourceEnum::default(),
            _ => panic!("parameter is not an enum value"),
        }
    }
}
#[derive(Eq, PartialEq, Hash, Debug)]
pub enum IfcLightFixtureTypeEnum {
    Pointsource,
    Directionsource,
    Securitylighting,
    Userdefined,
    Notdefined,
}
impl Default for IfcLightFixtureTypeEnum {
    fn default() -> Self {
        IfcLightFixtureTypeEnum::Pointsource
    }
}
impl From<String> for IfcLightFixtureTypeEnum {
    fn from(value: String) -> Self {
        match value.as_str() {
            "POINTSOURCE" => IfcLightFixtureTypeEnum::Pointsource,
            "DIRECTIONSOURCE" => IfcLightFixtureTypeEnum::Directionsource,
            "SECURITYLIGHTING" => IfcLightFixtureTypeEnum::Securitylighting,
            "USERDEFINED" => IfcLightFixtureTypeEnum::Userdefined,
            "NOTDEFINED" => IfcLightFixtureTypeEnum::Notdefined,
            _ => panic!("{} is not a valid value", value),
        }
    }
}
impl From<Parameter> for IfcLightFixtureTypeEnum {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EnumValue(value) => value.into(),
                _ => panic!("parameter is not an enum value"),
            },
            Parameter::OmittedParameter => IfcLightFixtureTypeEnum::default(),
            _ => panic!("parameter is not an enum value"),
        }
    }
}
#[derive(Eq, PartialEq, Hash, Debug)]
pub enum IfcLoadGroupTypeEnum {
    LoadGroup,
    LoadCase,
    LoadCombination,
    Userdefined,
    Notdefined,
}
impl Default for IfcLoadGroupTypeEnum {
    fn default() -> Self {
        IfcLoadGroupTypeEnum::LoadGroup
    }
}
impl From<String> for IfcLoadGroupTypeEnum {
    fn from(value: String) -> Self {
        match value.as_str() {
            "LOAD_GROUP" => IfcLoadGroupTypeEnum::LoadGroup,
            "LOAD_CASE" => IfcLoadGroupTypeEnum::LoadCase,
            "LOAD_COMBINATION" => IfcLoadGroupTypeEnum::LoadCombination,
            "USERDEFINED" => IfcLoadGroupTypeEnum::Userdefined,
            "NOTDEFINED" => IfcLoadGroupTypeEnum::Notdefined,
            _ => panic!("{} is not a valid value", value),
        }
    }
}
impl From<Parameter> for IfcLoadGroupTypeEnum {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EnumValue(value) => value.into(),
                _ => panic!("parameter is not an enum value"),
            },
            Parameter::OmittedParameter => IfcLoadGroupTypeEnum::default(),
            _ => panic!("parameter is not an enum value"),
        }
    }
}
#[derive(Eq, PartialEq, Hash, Debug)]
pub enum IfcLogicalOperatorEnum {
    Logicaland,
    Logicalor,
    Logicalxor,
    Logicalnotand,
    Logicalnotor,
}
impl Default for IfcLogicalOperatorEnum {
    fn default() -> Self {
        IfcLogicalOperatorEnum::Logicaland
    }
}
impl From<String> for IfcLogicalOperatorEnum {
    fn from(value: String) -> Self {
        match value.as_str() {
            "LOGICALAND" => IfcLogicalOperatorEnum::Logicaland,
            "LOGICALOR" => IfcLogicalOperatorEnum::Logicalor,
            "LOGICALXOR" => IfcLogicalOperatorEnum::Logicalxor,
            "LOGICALNOTAND" => IfcLogicalOperatorEnum::Logicalnotand,
            "LOGICALNOTOR" => IfcLogicalOperatorEnum::Logicalnotor,
            _ => panic!("{} is not a valid value", value),
        }
    }
}
impl From<Parameter> for IfcLogicalOperatorEnum {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EnumValue(value) => value.into(),
                _ => panic!("parameter is not an enum value"),
            },
            Parameter::OmittedParameter => IfcLogicalOperatorEnum::default(),
            _ => panic!("parameter is not an enum value"),
        }
    }
}
#[derive(Eq, PartialEq, Hash, Debug)]
pub enum IfcMechanicalFastenerTypeEnum {
    Anchorbolt,
    Bolt,
    Dowel,
    Nail,
    Nailplate,
    Rivet,
    Screw,
    Shearconnector,
    Staple,
    Studshearconnector,
    Userdefined,
    Notdefined,
}
impl Default for IfcMechanicalFastenerTypeEnum {
    fn default() -> Self {
        IfcMechanicalFastenerTypeEnum::Anchorbolt
    }
}
impl From<String> for IfcMechanicalFastenerTypeEnum {
    fn from(value: String) -> Self {
        match value.as_str() {
            "ANCHORBOLT" => IfcMechanicalFastenerTypeEnum::Anchorbolt,
            "BOLT" => IfcMechanicalFastenerTypeEnum::Bolt,
            "DOWEL" => IfcMechanicalFastenerTypeEnum::Dowel,
            "NAIL" => IfcMechanicalFastenerTypeEnum::Nail,
            "NAILPLATE" => IfcMechanicalFastenerTypeEnum::Nailplate,
            "RIVET" => IfcMechanicalFastenerTypeEnum::Rivet,
            "SCREW" => IfcMechanicalFastenerTypeEnum::Screw,
            "SHEARCONNECTOR" => IfcMechanicalFastenerTypeEnum::Shearconnector,
            "STAPLE" => IfcMechanicalFastenerTypeEnum::Staple,
            "STUDSHEARCONNECTOR" => IfcMechanicalFastenerTypeEnum::Studshearconnector,
            "USERDEFINED" => IfcMechanicalFastenerTypeEnum::Userdefined,
            "NOTDEFINED" => IfcMechanicalFastenerTypeEnum::Notdefined,
            _ => panic!("{} is not a valid value", value),
        }
    }
}
impl From<Parameter> for IfcMechanicalFastenerTypeEnum {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EnumValue(value) => value.into(),
                _ => panic!("parameter is not an enum value"),
            },
            Parameter::OmittedParameter => IfcMechanicalFastenerTypeEnum::default(),
            _ => panic!("parameter is not an enum value"),
        }
    }
}
#[derive(Eq, PartialEq, Hash, Debug)]
pub enum IfcMedicalDeviceTypeEnum {
    Airstation,
    Feedairunit,
    Oxygengenerator,
    Oxygenplant,
    Vacuumstation,
    Userdefined,
    Notdefined,
}
impl Default for IfcMedicalDeviceTypeEnum {
    fn default() -> Self {
        IfcMedicalDeviceTypeEnum::Airstation
    }
}
impl From<String> for IfcMedicalDeviceTypeEnum {
    fn from(value: String) -> Self {
        match value.as_str() {
            "AIRSTATION" => IfcMedicalDeviceTypeEnum::Airstation,
            "FEEDAIRUNIT" => IfcMedicalDeviceTypeEnum::Feedairunit,
            "OXYGENGENERATOR" => IfcMedicalDeviceTypeEnum::Oxygengenerator,
            "OXYGENPLANT" => IfcMedicalDeviceTypeEnum::Oxygenplant,
            "VACUUMSTATION" => IfcMedicalDeviceTypeEnum::Vacuumstation,
            "USERDEFINED" => IfcMedicalDeviceTypeEnum::Userdefined,
            "NOTDEFINED" => IfcMedicalDeviceTypeEnum::Notdefined,
            _ => panic!("{} is not a valid value", value),
        }
    }
}
impl From<Parameter> for IfcMedicalDeviceTypeEnum {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EnumValue(value) => value.into(),
                _ => panic!("parameter is not an enum value"),
            },
            Parameter::OmittedParameter => IfcMedicalDeviceTypeEnum::default(),
            _ => panic!("parameter is not an enum value"),
        }
    }
}
#[derive(Eq, PartialEq, Hash, Debug)]
pub enum IfcMemberTypeEnum {
    Brace,
    Chord,
    Collar,
    Member,
    Mullion,
    Plate,
    Post,
    Purlin,
    Rafter,
    Stringer,
    Strut,
    Stud,
    Userdefined,
    Notdefined,
}
impl Default for IfcMemberTypeEnum {
    fn default() -> Self {
        IfcMemberTypeEnum::Brace
    }
}
impl From<String> for IfcMemberTypeEnum {
    fn from(value: String) -> Self {
        match value.as_str() {
            "BRACE" => IfcMemberTypeEnum::Brace,
            "CHORD" => IfcMemberTypeEnum::Chord,
            "COLLAR" => IfcMemberTypeEnum::Collar,
            "MEMBER" => IfcMemberTypeEnum::Member,
            "MULLION" => IfcMemberTypeEnum::Mullion,
            "PLATE" => IfcMemberTypeEnum::Plate,
            "POST" => IfcMemberTypeEnum::Post,
            "PURLIN" => IfcMemberTypeEnum::Purlin,
            "RAFTER" => IfcMemberTypeEnum::Rafter,
            "STRINGER" => IfcMemberTypeEnum::Stringer,
            "STRUT" => IfcMemberTypeEnum::Strut,
            "STUD" => IfcMemberTypeEnum::Stud,
            "USERDEFINED" => IfcMemberTypeEnum::Userdefined,
            "NOTDEFINED" => IfcMemberTypeEnum::Notdefined,
            _ => panic!("{} is not a valid value", value),
        }
    }
}
impl From<Parameter> for IfcMemberTypeEnum {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EnumValue(value) => value.into(),
                _ => panic!("parameter is not an enum value"),
            },
            Parameter::OmittedParameter => IfcMemberTypeEnum::default(),
            _ => panic!("parameter is not an enum value"),
        }
    }
}
#[derive(Eq, PartialEq, Hash, Debug)]
pub enum IfcMotorConnectionTypeEnum {
    Beltdrive,
    Coupling,
    Directdrive,
    Userdefined,
    Notdefined,
}
impl Default for IfcMotorConnectionTypeEnum {
    fn default() -> Self {
        IfcMotorConnectionTypeEnum::Beltdrive
    }
}
impl From<String> for IfcMotorConnectionTypeEnum {
    fn from(value: String) -> Self {
        match value.as_str() {
            "BELTDRIVE" => IfcMotorConnectionTypeEnum::Beltdrive,
            "COUPLING" => IfcMotorConnectionTypeEnum::Coupling,
            "DIRECTDRIVE" => IfcMotorConnectionTypeEnum::Directdrive,
            "USERDEFINED" => IfcMotorConnectionTypeEnum::Userdefined,
            "NOTDEFINED" => IfcMotorConnectionTypeEnum::Notdefined,
            _ => panic!("{} is not a valid value", value),
        }
    }
}
impl From<Parameter> for IfcMotorConnectionTypeEnum {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EnumValue(value) => value.into(),
                _ => panic!("parameter is not an enum value"),
            },
            Parameter::OmittedParameter => IfcMotorConnectionTypeEnum::default(),
            _ => panic!("parameter is not an enum value"),
        }
    }
}
#[derive(Eq, PartialEq, Hash, Debug)]
pub enum IfcNullStyle {
    Null,
}
impl Default for IfcNullStyle {
    fn default() -> Self {
        IfcNullStyle::Null
    }
}
impl From<String> for IfcNullStyle {
    fn from(value: String) -> Self {
        match value.as_str() {
            "NULL" => IfcNullStyle::Null,
            _ => panic!("{} is not a valid value", value),
        }
    }
}
impl From<Parameter> for IfcNullStyle {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EnumValue(value) => value.into(),
                _ => panic!("parameter is not an enum value"),
            },
            Parameter::OmittedParameter => IfcNullStyle::default(),
            _ => panic!("parameter is not an enum value"),
        }
    }
}
#[derive(Eq, PartialEq, Hash, Debug)]
pub enum IfcObjectTypeEnum {
    Product,
    Process,
    Control,
    Resource,
    Actor,
    Group,
    Project,
    Notdefined,
}
impl Default for IfcObjectTypeEnum {
    fn default() -> Self {
        IfcObjectTypeEnum::Product
    }
}
impl From<String> for IfcObjectTypeEnum {
    fn from(value: String) -> Self {
        match value.as_str() {
            "PRODUCT" => IfcObjectTypeEnum::Product,
            "PROCESS" => IfcObjectTypeEnum::Process,
            "CONTROL" => IfcObjectTypeEnum::Control,
            "RESOURCE" => IfcObjectTypeEnum::Resource,
            "ACTOR" => IfcObjectTypeEnum::Actor,
            "GROUP" => IfcObjectTypeEnum::Group,
            "PROJECT" => IfcObjectTypeEnum::Project,
            "NOTDEFINED" => IfcObjectTypeEnum::Notdefined,
            _ => panic!("{} is not a valid value", value),
        }
    }
}
impl From<Parameter> for IfcObjectTypeEnum {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EnumValue(value) => value.into(),
                _ => panic!("parameter is not an enum value"),
            },
            Parameter::OmittedParameter => IfcObjectTypeEnum::default(),
            _ => panic!("parameter is not an enum value"),
        }
    }
}
#[derive(Eq, PartialEq, Hash, Debug)]
pub enum IfcObjectiveEnum {
    Codecompliance,
    Codewaiver,
    Designintent,
    External,
    Healthandsafety,
    Mergeconflict,
    Modelview,
    Parameter,
    Requirement,
    Specification,
    Triggercondition,
    Userdefined,
    Notdefined,
}
impl Default for IfcObjectiveEnum {
    fn default() -> Self {
        IfcObjectiveEnum::Codecompliance
    }
}
impl From<String> for IfcObjectiveEnum {
    fn from(value: String) -> Self {
        match value.as_str() {
            "CODECOMPLIANCE" => IfcObjectiveEnum::Codecompliance,
            "CODEWAIVER" => IfcObjectiveEnum::Codewaiver,
            "DESIGNINTENT" => IfcObjectiveEnum::Designintent,
            "EXTERNAL" => IfcObjectiveEnum::External,
            "HEALTHANDSAFETY" => IfcObjectiveEnum::Healthandsafety,
            "MERGECONFLICT" => IfcObjectiveEnum::Mergeconflict,
            "MODELVIEW" => IfcObjectiveEnum::Modelview,
            "PARAMETER" => IfcObjectiveEnum::Parameter,
            "REQUIREMENT" => IfcObjectiveEnum::Requirement,
            "SPECIFICATION" => IfcObjectiveEnum::Specification,
            "TRIGGERCONDITION" => IfcObjectiveEnum::Triggercondition,
            "USERDEFINED" => IfcObjectiveEnum::Userdefined,
            "NOTDEFINED" => IfcObjectiveEnum::Notdefined,
            _ => panic!("{} is not a valid value", value),
        }
    }
}
impl From<Parameter> for IfcObjectiveEnum {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EnumValue(value) => value.into(),
                _ => panic!("parameter is not an enum value"),
            },
            Parameter::OmittedParameter => IfcObjectiveEnum::default(),
            _ => panic!("parameter is not an enum value"),
        }
    }
}
#[derive(Eq, PartialEq, Hash, Debug)]
pub enum IfcOccupantTypeEnum {
    Assignee,
    Assignor,
    Lessee,
    Lessor,
    Lettingagent,
    Owner,
    Tenant,
    Userdefined,
    Notdefined,
}
impl Default for IfcOccupantTypeEnum {
    fn default() -> Self {
        IfcOccupantTypeEnum::Assignee
    }
}
impl From<String> for IfcOccupantTypeEnum {
    fn from(value: String) -> Self {
        match value.as_str() {
            "ASSIGNEE" => IfcOccupantTypeEnum::Assignee,
            "ASSIGNOR" => IfcOccupantTypeEnum::Assignor,
            "LESSEE" => IfcOccupantTypeEnum::Lessee,
            "LESSOR" => IfcOccupantTypeEnum::Lessor,
            "LETTINGAGENT" => IfcOccupantTypeEnum::Lettingagent,
            "OWNER" => IfcOccupantTypeEnum::Owner,
            "TENANT" => IfcOccupantTypeEnum::Tenant,
            "USERDEFINED" => IfcOccupantTypeEnum::Userdefined,
            "NOTDEFINED" => IfcOccupantTypeEnum::Notdefined,
            _ => panic!("{} is not a valid value", value),
        }
    }
}
impl From<Parameter> for IfcOccupantTypeEnum {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EnumValue(value) => value.into(),
                _ => panic!("parameter is not an enum value"),
            },
            Parameter::OmittedParameter => IfcOccupantTypeEnum::default(),
            _ => panic!("parameter is not an enum value"),
        }
    }
}
#[derive(Eq, PartialEq, Hash, Debug)]
pub enum IfcOpeningElementTypeEnum {
    Opening,
    Recess,
    Userdefined,
    Notdefined,
}
impl Default for IfcOpeningElementTypeEnum {
    fn default() -> Self {
        IfcOpeningElementTypeEnum::Opening
    }
}
impl From<String> for IfcOpeningElementTypeEnum {
    fn from(value: String) -> Self {
        match value.as_str() {
            "OPENING" => IfcOpeningElementTypeEnum::Opening,
            "RECESS" => IfcOpeningElementTypeEnum::Recess,
            "USERDEFINED" => IfcOpeningElementTypeEnum::Userdefined,
            "NOTDEFINED" => IfcOpeningElementTypeEnum::Notdefined,
            _ => panic!("{} is not a valid value", value),
        }
    }
}
impl From<Parameter> for IfcOpeningElementTypeEnum {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EnumValue(value) => value.into(),
                _ => panic!("parameter is not an enum value"),
            },
            Parameter::OmittedParameter => IfcOpeningElementTypeEnum::default(),
            _ => panic!("parameter is not an enum value"),
        }
    }
}
#[derive(Eq, PartialEq, Hash, Debug)]
pub enum IfcOutletTypeEnum {
    Audiovisualoutlet,
    Communicationsoutlet,
    Poweroutlet,
    Dataoutlet,
    Telephoneoutlet,
    Userdefined,
    Notdefined,
}
impl Default for IfcOutletTypeEnum {
    fn default() -> Self {
        IfcOutletTypeEnum::Audiovisualoutlet
    }
}
impl From<String> for IfcOutletTypeEnum {
    fn from(value: String) -> Self {
        match value.as_str() {
            "AUDIOVISUALOUTLET" => IfcOutletTypeEnum::Audiovisualoutlet,
            "COMMUNICATIONSOUTLET" => IfcOutletTypeEnum::Communicationsoutlet,
            "POWEROUTLET" => IfcOutletTypeEnum::Poweroutlet,
            "DATAOUTLET" => IfcOutletTypeEnum::Dataoutlet,
            "TELEPHONEOUTLET" => IfcOutletTypeEnum::Telephoneoutlet,
            "USERDEFINED" => IfcOutletTypeEnum::Userdefined,
            "NOTDEFINED" => IfcOutletTypeEnum::Notdefined,
            _ => panic!("{} is not a valid value", value),
        }
    }
}
impl From<Parameter> for IfcOutletTypeEnum {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EnumValue(value) => value.into(),
                _ => panic!("parameter is not an enum value"),
            },
            Parameter::OmittedParameter => IfcOutletTypeEnum::default(),
            _ => panic!("parameter is not an enum value"),
        }
    }
}
#[derive(Eq, PartialEq, Hash, Debug)]
pub enum IfcPerformanceHistoryTypeEnum {
    Userdefined,
    Notdefined,
}
impl Default for IfcPerformanceHistoryTypeEnum {
    fn default() -> Self {
        IfcPerformanceHistoryTypeEnum::Userdefined
    }
}
impl From<String> for IfcPerformanceHistoryTypeEnum {
    fn from(value: String) -> Self {
        match value.as_str() {
            "USERDEFINED" => IfcPerformanceHistoryTypeEnum::Userdefined,
            "NOTDEFINED" => IfcPerformanceHistoryTypeEnum::Notdefined,
            _ => panic!("{} is not a valid value", value),
        }
    }
}
impl From<Parameter> for IfcPerformanceHistoryTypeEnum {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EnumValue(value) => value.into(),
                _ => panic!("parameter is not an enum value"),
            },
            Parameter::OmittedParameter => IfcPerformanceHistoryTypeEnum::default(),
            _ => panic!("parameter is not an enum value"),
        }
    }
}
#[derive(Eq, PartialEq, Hash, Debug)]
pub enum IfcPermeableCoveringOperationEnum {
    Grill,
    Louver,
    Screen,
    Userdefined,
    Notdefined,
}
impl Default for IfcPermeableCoveringOperationEnum {
    fn default() -> Self {
        IfcPermeableCoveringOperationEnum::Grill
    }
}
impl From<String> for IfcPermeableCoveringOperationEnum {
    fn from(value: String) -> Self {
        match value.as_str() {
            "GRILL" => IfcPermeableCoveringOperationEnum::Grill,
            "LOUVER" => IfcPermeableCoveringOperationEnum::Louver,
            "SCREEN" => IfcPermeableCoveringOperationEnum::Screen,
            "USERDEFINED" => IfcPermeableCoveringOperationEnum::Userdefined,
            "NOTDEFINED" => IfcPermeableCoveringOperationEnum::Notdefined,
            _ => panic!("{} is not a valid value", value),
        }
    }
}
impl From<Parameter> for IfcPermeableCoveringOperationEnum {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EnumValue(value) => value.into(),
                _ => panic!("parameter is not an enum value"),
            },
            Parameter::OmittedParameter => IfcPermeableCoveringOperationEnum::default(),
            _ => panic!("parameter is not an enum value"),
        }
    }
}
#[derive(Eq, PartialEq, Hash, Debug)]
pub enum IfcPermitTypeEnum {
    Access,
    Building,
    Work,
    Userdefined,
    Notdefined,
}
impl Default for IfcPermitTypeEnum {
    fn default() -> Self {
        IfcPermitTypeEnum::Access
    }
}
impl From<String> for IfcPermitTypeEnum {
    fn from(value: String) -> Self {
        match value.as_str() {
            "ACCESS" => IfcPermitTypeEnum::Access,
            "BUILDING" => IfcPermitTypeEnum::Building,
            "WORK" => IfcPermitTypeEnum::Work,
            "USERDEFINED" => IfcPermitTypeEnum::Userdefined,
            "NOTDEFINED" => IfcPermitTypeEnum::Notdefined,
            _ => panic!("{} is not a valid value", value),
        }
    }
}
impl From<Parameter> for IfcPermitTypeEnum {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EnumValue(value) => value.into(),
                _ => panic!("parameter is not an enum value"),
            },
            Parameter::OmittedParameter => IfcPermitTypeEnum::default(),
            _ => panic!("parameter is not an enum value"),
        }
    }
}
#[derive(Eq, PartialEq, Hash, Debug)]
pub enum IfcPhysicalOrVirtualEnum {
    Physical,
    Virtual,
    Notdefined,
}
impl Default for IfcPhysicalOrVirtualEnum {
    fn default() -> Self {
        IfcPhysicalOrVirtualEnum::Physical
    }
}
impl From<String> for IfcPhysicalOrVirtualEnum {
    fn from(value: String) -> Self {
        match value.as_str() {
            "PHYSICAL" => IfcPhysicalOrVirtualEnum::Physical,
            "VIRTUAL" => IfcPhysicalOrVirtualEnum::Virtual,
            "NOTDEFINED" => IfcPhysicalOrVirtualEnum::Notdefined,
            _ => panic!("{} is not a valid value", value),
        }
    }
}
impl From<Parameter> for IfcPhysicalOrVirtualEnum {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EnumValue(value) => value.into(),
                _ => panic!("parameter is not an enum value"),
            },
            Parameter::OmittedParameter => IfcPhysicalOrVirtualEnum::default(),
            _ => panic!("parameter is not an enum value"),
        }
    }
}
#[derive(Eq, PartialEq, Hash, Debug)]
pub enum IfcPileConstructionEnum {
    CastInPlace,
    Composite,
    PrecastConcrete,
    PrefabSteel,
    Userdefined,
    Notdefined,
}
impl Default for IfcPileConstructionEnum {
    fn default() -> Self {
        IfcPileConstructionEnum::CastInPlace
    }
}
impl From<String> for IfcPileConstructionEnum {
    fn from(value: String) -> Self {
        match value.as_str() {
            "CAST_IN_PLACE" => IfcPileConstructionEnum::CastInPlace,
            "COMPOSITE" => IfcPileConstructionEnum::Composite,
            "PRECAST_CONCRETE" => IfcPileConstructionEnum::PrecastConcrete,
            "PREFAB_STEEL" => IfcPileConstructionEnum::PrefabSteel,
            "USERDEFINED" => IfcPileConstructionEnum::Userdefined,
            "NOTDEFINED" => IfcPileConstructionEnum::Notdefined,
            _ => panic!("{} is not a valid value", value),
        }
    }
}
impl From<Parameter> for IfcPileConstructionEnum {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EnumValue(value) => value.into(),
                _ => panic!("parameter is not an enum value"),
            },
            Parameter::OmittedParameter => IfcPileConstructionEnum::default(),
            _ => panic!("parameter is not an enum value"),
        }
    }
}
#[derive(Eq, PartialEq, Hash, Debug)]
pub enum IfcPileTypeEnum {
    Bored,
    Driven,
    Jetgrouting,
    Cohesion,
    Friction,
    Support,
    Userdefined,
    Notdefined,
}
impl Default for IfcPileTypeEnum {
    fn default() -> Self {
        IfcPileTypeEnum::Bored
    }
}
impl From<String> for IfcPileTypeEnum {
    fn from(value: String) -> Self {
        match value.as_str() {
            "BORED" => IfcPileTypeEnum::Bored,
            "DRIVEN" => IfcPileTypeEnum::Driven,
            "JETGROUTING" => IfcPileTypeEnum::Jetgrouting,
            "COHESION" => IfcPileTypeEnum::Cohesion,
            "FRICTION" => IfcPileTypeEnum::Friction,
            "SUPPORT" => IfcPileTypeEnum::Support,
            "USERDEFINED" => IfcPileTypeEnum::Userdefined,
            "NOTDEFINED" => IfcPileTypeEnum::Notdefined,
            _ => panic!("{} is not a valid value", value),
        }
    }
}
impl From<Parameter> for IfcPileTypeEnum {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EnumValue(value) => value.into(),
                _ => panic!("parameter is not an enum value"),
            },
            Parameter::OmittedParameter => IfcPileTypeEnum::default(),
            _ => panic!("parameter is not an enum value"),
        }
    }
}
#[derive(Eq, PartialEq, Hash, Debug)]
pub enum IfcPipeFittingTypeEnum {
    Bend,
    Connector,
    Entry,
    Exit,
    Junction,
    Obstruction,
    Transition,
    Userdefined,
    Notdefined,
}
impl Default for IfcPipeFittingTypeEnum {
    fn default() -> Self {
        IfcPipeFittingTypeEnum::Bend
    }
}
impl From<String> for IfcPipeFittingTypeEnum {
    fn from(value: String) -> Self {
        match value.as_str() {
            "BEND" => IfcPipeFittingTypeEnum::Bend,
            "CONNECTOR" => IfcPipeFittingTypeEnum::Connector,
            "ENTRY" => IfcPipeFittingTypeEnum::Entry,
            "EXIT" => IfcPipeFittingTypeEnum::Exit,
            "JUNCTION" => IfcPipeFittingTypeEnum::Junction,
            "OBSTRUCTION" => IfcPipeFittingTypeEnum::Obstruction,
            "TRANSITION" => IfcPipeFittingTypeEnum::Transition,
            "USERDEFINED" => IfcPipeFittingTypeEnum::Userdefined,
            "NOTDEFINED" => IfcPipeFittingTypeEnum::Notdefined,
            _ => panic!("{} is not a valid value", value),
        }
    }
}
impl From<Parameter> for IfcPipeFittingTypeEnum {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EnumValue(value) => value.into(),
                _ => panic!("parameter is not an enum value"),
            },
            Parameter::OmittedParameter => IfcPipeFittingTypeEnum::default(),
            _ => panic!("parameter is not an enum value"),
        }
    }
}
#[derive(Eq, PartialEq, Hash, Debug)]
pub enum IfcPipeSegmentTypeEnum {
    Culvert,
    Flexiblesegment,
    Rigidsegment,
    Gutter,
    Spool,
    Userdefined,
    Notdefined,
}
impl Default for IfcPipeSegmentTypeEnum {
    fn default() -> Self {
        IfcPipeSegmentTypeEnum::Culvert
    }
}
impl From<String> for IfcPipeSegmentTypeEnum {
    fn from(value: String) -> Self {
        match value.as_str() {
            "CULVERT" => IfcPipeSegmentTypeEnum::Culvert,
            "FLEXIBLESEGMENT" => IfcPipeSegmentTypeEnum::Flexiblesegment,
            "RIGIDSEGMENT" => IfcPipeSegmentTypeEnum::Rigidsegment,
            "GUTTER" => IfcPipeSegmentTypeEnum::Gutter,
            "SPOOL" => IfcPipeSegmentTypeEnum::Spool,
            "USERDEFINED" => IfcPipeSegmentTypeEnum::Userdefined,
            "NOTDEFINED" => IfcPipeSegmentTypeEnum::Notdefined,
            _ => panic!("{} is not a valid value", value),
        }
    }
}
impl From<Parameter> for IfcPipeSegmentTypeEnum {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EnumValue(value) => value.into(),
                _ => panic!("parameter is not an enum value"),
            },
            Parameter::OmittedParameter => IfcPipeSegmentTypeEnum::default(),
            _ => panic!("parameter is not an enum value"),
        }
    }
}
#[derive(Eq, PartialEq, Hash, Debug)]
pub enum IfcPlateTypeEnum {
    CurtainPanel,
    Sheet,
    Userdefined,
    Notdefined,
}
impl Default for IfcPlateTypeEnum {
    fn default() -> Self {
        IfcPlateTypeEnum::CurtainPanel
    }
}
impl From<String> for IfcPlateTypeEnum {
    fn from(value: String) -> Self {
        match value.as_str() {
            "CURTAIN_PANEL" => IfcPlateTypeEnum::CurtainPanel,
            "SHEET" => IfcPlateTypeEnum::Sheet,
            "USERDEFINED" => IfcPlateTypeEnum::Userdefined,
            "NOTDEFINED" => IfcPlateTypeEnum::Notdefined,
            _ => panic!("{} is not a valid value", value),
        }
    }
}
impl From<Parameter> for IfcPlateTypeEnum {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EnumValue(value) => value.into(),
                _ => panic!("parameter is not an enum value"),
            },
            Parameter::OmittedParameter => IfcPlateTypeEnum::default(),
            _ => panic!("parameter is not an enum value"),
        }
    }
}
#[derive(Eq, PartialEq, Hash, Debug)]
pub enum IfcPreferredSurfaceCurveRepresentation {
    Curve3d,
    PcurveS1,
    PcurveS2,
}
impl Default for IfcPreferredSurfaceCurveRepresentation {
    fn default() -> Self {
        IfcPreferredSurfaceCurveRepresentation::Curve3d
    }
}
impl From<String> for IfcPreferredSurfaceCurveRepresentation {
    fn from(value: String) -> Self {
        match value.as_str() {
            "CURVE3D" => IfcPreferredSurfaceCurveRepresentation::Curve3d,
            "PCURVE_S1" => IfcPreferredSurfaceCurveRepresentation::PcurveS1,
            "PCURVE_S2" => IfcPreferredSurfaceCurveRepresentation::PcurveS2,
            _ => panic!("{} is not a valid value", value),
        }
    }
}
impl From<Parameter> for IfcPreferredSurfaceCurveRepresentation {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EnumValue(value) => value.into(),
                _ => panic!("parameter is not an enum value"),
            },
            Parameter::OmittedParameter => IfcPreferredSurfaceCurveRepresentation::default(),
            _ => panic!("parameter is not an enum value"),
        }
    }
}
#[derive(Eq, PartialEq, Hash, Debug)]
pub enum IfcProcedureTypeEnum {
    AdviceCaution,
    AdviceNote,
    AdviceWarning,
    Calibration,
    Diagnostic,
    Shutdown,
    Startup,
    Userdefined,
    Notdefined,
}
impl Default for IfcProcedureTypeEnum {
    fn default() -> Self {
        IfcProcedureTypeEnum::AdviceCaution
    }
}
impl From<String> for IfcProcedureTypeEnum {
    fn from(value: String) -> Self {
        match value.as_str() {
            "ADVICE_CAUTION" => IfcProcedureTypeEnum::AdviceCaution,
            "ADVICE_NOTE" => IfcProcedureTypeEnum::AdviceNote,
            "ADVICE_WARNING" => IfcProcedureTypeEnum::AdviceWarning,
            "CALIBRATION" => IfcProcedureTypeEnum::Calibration,
            "DIAGNOSTIC" => IfcProcedureTypeEnum::Diagnostic,
            "SHUTDOWN" => IfcProcedureTypeEnum::Shutdown,
            "STARTUP" => IfcProcedureTypeEnum::Startup,
            "USERDEFINED" => IfcProcedureTypeEnum::Userdefined,
            "NOTDEFINED" => IfcProcedureTypeEnum::Notdefined,
            _ => panic!("{} is not a valid value", value),
        }
    }
}
impl From<Parameter> for IfcProcedureTypeEnum {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EnumValue(value) => value.into(),
                _ => panic!("parameter is not an enum value"),
            },
            Parameter::OmittedParameter => IfcProcedureTypeEnum::default(),
            _ => panic!("parameter is not an enum value"),
        }
    }
}
#[derive(Eq, PartialEq, Hash, Debug)]
pub enum IfcProfileTypeEnum {
    Curve,
    Area,
}
impl Default for IfcProfileTypeEnum {
    fn default() -> Self {
        IfcProfileTypeEnum::Curve
    }
}
impl From<String> for IfcProfileTypeEnum {
    fn from(value: String) -> Self {
        match value.as_str() {
            "CURVE" => IfcProfileTypeEnum::Curve,
            "AREA" => IfcProfileTypeEnum::Area,
            _ => panic!("{} is not a valid value", value),
        }
    }
}
impl From<Parameter> for IfcProfileTypeEnum {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EnumValue(value) => value.into(),
                _ => panic!("parameter is not an enum value"),
            },
            Parameter::OmittedParameter => IfcProfileTypeEnum::default(),
            _ => panic!("parameter is not an enum value"),
        }
    }
}
#[derive(Eq, PartialEq, Hash, Debug)]
pub enum IfcProjectOrderTypeEnum {
    Changeorder,
    Maintenanceworkorder,
    Moveorder,
    Purchaseorder,
    Workorder,
    Userdefined,
    Notdefined,
}
impl Default for IfcProjectOrderTypeEnum {
    fn default() -> Self {
        IfcProjectOrderTypeEnum::Changeorder
    }
}
impl From<String> for IfcProjectOrderTypeEnum {
    fn from(value: String) -> Self {
        match value.as_str() {
            "CHANGEORDER" => IfcProjectOrderTypeEnum::Changeorder,
            "MAINTENANCEWORKORDER" => IfcProjectOrderTypeEnum::Maintenanceworkorder,
            "MOVEORDER" => IfcProjectOrderTypeEnum::Moveorder,
            "PURCHASEORDER" => IfcProjectOrderTypeEnum::Purchaseorder,
            "WORKORDER" => IfcProjectOrderTypeEnum::Workorder,
            "USERDEFINED" => IfcProjectOrderTypeEnum::Userdefined,
            "NOTDEFINED" => IfcProjectOrderTypeEnum::Notdefined,
            _ => panic!("{} is not a valid value", value),
        }
    }
}
impl From<Parameter> for IfcProjectOrderTypeEnum {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EnumValue(value) => value.into(),
                _ => panic!("parameter is not an enum value"),
            },
            Parameter::OmittedParameter => IfcProjectOrderTypeEnum::default(),
            _ => panic!("parameter is not an enum value"),
        }
    }
}
#[derive(Eq, PartialEq, Hash, Debug)]
pub enum IfcProjectedOrTrueLengthEnum {
    ProjectedLength,
    TrueLength,
}
impl Default for IfcProjectedOrTrueLengthEnum {
    fn default() -> Self {
        IfcProjectedOrTrueLengthEnum::ProjectedLength
    }
}
impl From<String> for IfcProjectedOrTrueLengthEnum {
    fn from(value: String) -> Self {
        match value.as_str() {
            "PROJECTED_LENGTH" => IfcProjectedOrTrueLengthEnum::ProjectedLength,
            "TRUE_LENGTH" => IfcProjectedOrTrueLengthEnum::TrueLength,
            _ => panic!("{} is not a valid value", value),
        }
    }
}
impl From<Parameter> for IfcProjectedOrTrueLengthEnum {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EnumValue(value) => value.into(),
                _ => panic!("parameter is not an enum value"),
            },
            Parameter::OmittedParameter => IfcProjectedOrTrueLengthEnum::default(),
            _ => panic!("parameter is not an enum value"),
        }
    }
}
#[derive(Eq, PartialEq, Hash, Debug)]
pub enum IfcProjectionElementTypeEnum {
    Userdefined,
    Notdefined,
}
impl Default for IfcProjectionElementTypeEnum {
    fn default() -> Self {
        IfcProjectionElementTypeEnum::Userdefined
    }
}
impl From<String> for IfcProjectionElementTypeEnum {
    fn from(value: String) -> Self {
        match value.as_str() {
            "USERDEFINED" => IfcProjectionElementTypeEnum::Userdefined,
            "NOTDEFINED" => IfcProjectionElementTypeEnum::Notdefined,
            _ => panic!("{} is not a valid value", value),
        }
    }
}
impl From<Parameter> for IfcProjectionElementTypeEnum {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EnumValue(value) => value.into(),
                _ => panic!("parameter is not an enum value"),
            },
            Parameter::OmittedParameter => IfcProjectionElementTypeEnum::default(),
            _ => panic!("parameter is not an enum value"),
        }
    }
}
#[derive(Eq, PartialEq, Hash, Debug)]
pub enum IfcPropertySetTemplateTypeEnum {
    PsetTypedrivenonly,
    PsetTypedrivenoverride,
    PsetOccurrencedriven,
    PsetPerformancedriven,
    QtoTypedrivenonly,
    QtoTypedrivenoverride,
    QtoOccurrencedriven,
    Notdefined,
}
impl Default for IfcPropertySetTemplateTypeEnum {
    fn default() -> Self {
        IfcPropertySetTemplateTypeEnum::PsetTypedrivenonly
    }
}
impl From<String> for IfcPropertySetTemplateTypeEnum {
    fn from(value: String) -> Self {
        match value.as_str() {
            "PSET_TYPEDRIVENONLY" => IfcPropertySetTemplateTypeEnum::PsetTypedrivenonly,
            "PSET_TYPEDRIVENOVERRIDE" => IfcPropertySetTemplateTypeEnum::PsetTypedrivenoverride,
            "PSET_OCCURRENCEDRIVEN" => IfcPropertySetTemplateTypeEnum::PsetOccurrencedriven,
            "PSET_PERFORMANCEDRIVEN" => IfcPropertySetTemplateTypeEnum::PsetPerformancedriven,
            "QTO_TYPEDRIVENONLY" => IfcPropertySetTemplateTypeEnum::QtoTypedrivenonly,
            "QTO_TYPEDRIVENOVERRIDE" => IfcPropertySetTemplateTypeEnum::QtoTypedrivenoverride,
            "QTO_OCCURRENCEDRIVEN" => IfcPropertySetTemplateTypeEnum::QtoOccurrencedriven,
            "NOTDEFINED" => IfcPropertySetTemplateTypeEnum::Notdefined,
            _ => panic!("{} is not a valid value", value),
        }
    }
}
impl From<Parameter> for IfcPropertySetTemplateTypeEnum {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EnumValue(value) => value.into(),
                _ => panic!("parameter is not an enum value"),
            },
            Parameter::OmittedParameter => IfcPropertySetTemplateTypeEnum::default(),
            _ => panic!("parameter is not an enum value"),
        }
    }
}
#[derive(Eq, PartialEq, Hash, Debug)]
pub enum IfcProtectiveDeviceTrippingUnitTypeEnum {
    Electronic,
    Electromagnetic,
    Residualcurrent,
    Thermal,
    Userdefined,
    Notdefined,
}
impl Default for IfcProtectiveDeviceTrippingUnitTypeEnum {
    fn default() -> Self {
        IfcProtectiveDeviceTrippingUnitTypeEnum::Electronic
    }
}
impl From<String> for IfcProtectiveDeviceTrippingUnitTypeEnum {
    fn from(value: String) -> Self {
        match value.as_str() {
            "ELECTRONIC" => IfcProtectiveDeviceTrippingUnitTypeEnum::Electronic,
            "ELECTROMAGNETIC" => IfcProtectiveDeviceTrippingUnitTypeEnum::Electromagnetic,
            "RESIDUALCURRENT" => IfcProtectiveDeviceTrippingUnitTypeEnum::Residualcurrent,
            "THERMAL" => IfcProtectiveDeviceTrippingUnitTypeEnum::Thermal,
            "USERDEFINED" => IfcProtectiveDeviceTrippingUnitTypeEnum::Userdefined,
            "NOTDEFINED" => IfcProtectiveDeviceTrippingUnitTypeEnum::Notdefined,
            _ => panic!("{} is not a valid value", value),
        }
    }
}
impl From<Parameter> for IfcProtectiveDeviceTrippingUnitTypeEnum {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EnumValue(value) => value.into(),
                _ => panic!("parameter is not an enum value"),
            },
            Parameter::OmittedParameter => IfcProtectiveDeviceTrippingUnitTypeEnum::default(),
            _ => panic!("parameter is not an enum value"),
        }
    }
}
#[derive(Eq, PartialEq, Hash, Debug)]
pub enum IfcProtectiveDeviceTypeEnum {
    Circuitbreaker,
    Earthleakagecircuitbreaker,
    Earthingswitch,
    Fusedisconnector,
    Residualcurrentcircuitbreaker,
    Residualcurrentswitch,
    Varistor,
    Userdefined,
    Notdefined,
}
impl Default for IfcProtectiveDeviceTypeEnum {
    fn default() -> Self {
        IfcProtectiveDeviceTypeEnum::Circuitbreaker
    }
}
impl From<String> for IfcProtectiveDeviceTypeEnum {
    fn from(value: String) -> Self {
        match value.as_str() {
            "CIRCUITBREAKER" => IfcProtectiveDeviceTypeEnum::Circuitbreaker,
            "EARTHLEAKAGECIRCUITBREAKER" => IfcProtectiveDeviceTypeEnum::Earthleakagecircuitbreaker,
            "EARTHINGSWITCH" => IfcProtectiveDeviceTypeEnum::Earthingswitch,
            "FUSEDISCONNECTOR" => IfcProtectiveDeviceTypeEnum::Fusedisconnector,
            "RESIDUALCURRENTCIRCUITBREAKER" => IfcProtectiveDeviceTypeEnum::Residualcurrentcircuitbreaker,
            "RESIDUALCURRENTSWITCH" => IfcProtectiveDeviceTypeEnum::Residualcurrentswitch,
            "VARISTOR" => IfcProtectiveDeviceTypeEnum::Varistor,
            "USERDEFINED" => IfcProtectiveDeviceTypeEnum::Userdefined,
            "NOTDEFINED" => IfcProtectiveDeviceTypeEnum::Notdefined,
            _ => panic!("{} is not a valid value", value),
        }
    }
}
impl From<Parameter> for IfcProtectiveDeviceTypeEnum {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EnumValue(value) => value.into(),
                _ => panic!("parameter is not an enum value"),
            },
            Parameter::OmittedParameter => IfcProtectiveDeviceTypeEnum::default(),
            _ => panic!("parameter is not an enum value"),
        }
    }
}
#[derive(Eq, PartialEq, Hash, Debug)]
pub enum IfcPumpTypeEnum {
    Circulator,
    Endsuction,
    Splitcase,
    Submersiblepump,
    Sumppump,
    Verticalinline,
    Verticalturbine,
    Userdefined,
    Notdefined,
}
impl Default for IfcPumpTypeEnum {
    fn default() -> Self {
        IfcPumpTypeEnum::Circulator
    }
}
impl From<String> for IfcPumpTypeEnum {
    fn from(value: String) -> Self {
        match value.as_str() {
            "CIRCULATOR" => IfcPumpTypeEnum::Circulator,
            "ENDSUCTION" => IfcPumpTypeEnum::Endsuction,
            "SPLITCASE" => IfcPumpTypeEnum::Splitcase,
            "SUBMERSIBLEPUMP" => IfcPumpTypeEnum::Submersiblepump,
            "SUMPPUMP" => IfcPumpTypeEnum::Sumppump,
            "VERTICALINLINE" => IfcPumpTypeEnum::Verticalinline,
            "VERTICALTURBINE" => IfcPumpTypeEnum::Verticalturbine,
            "USERDEFINED" => IfcPumpTypeEnum::Userdefined,
            "NOTDEFINED" => IfcPumpTypeEnum::Notdefined,
            _ => panic!("{} is not a valid value", value),
        }
    }
}
impl From<Parameter> for IfcPumpTypeEnum {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EnumValue(value) => value.into(),
                _ => panic!("parameter is not an enum value"),
            },
            Parameter::OmittedParameter => IfcPumpTypeEnum::default(),
            _ => panic!("parameter is not an enum value"),
        }
    }
}
#[derive(Eq, PartialEq, Hash, Debug)]
pub enum IfcRailingTypeEnum {
    Handrail,
    Guardrail,
    Balustrade,
    Userdefined,
    Notdefined,
}
impl Default for IfcRailingTypeEnum {
    fn default() -> Self {
        IfcRailingTypeEnum::Handrail
    }
}
impl From<String> for IfcRailingTypeEnum {
    fn from(value: String) -> Self {
        match value.as_str() {
            "HANDRAIL" => IfcRailingTypeEnum::Handrail,
            "GUARDRAIL" => IfcRailingTypeEnum::Guardrail,
            "BALUSTRADE" => IfcRailingTypeEnum::Balustrade,
            "USERDEFINED" => IfcRailingTypeEnum::Userdefined,
            "NOTDEFINED" => IfcRailingTypeEnum::Notdefined,
            _ => panic!("{} is not a valid value", value),
        }
    }
}
impl From<Parameter> for IfcRailingTypeEnum {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EnumValue(value) => value.into(),
                _ => panic!("parameter is not an enum value"),
            },
            Parameter::OmittedParameter => IfcRailingTypeEnum::default(),
            _ => panic!("parameter is not an enum value"),
        }
    }
}
#[derive(Eq, PartialEq, Hash, Debug)]
pub enum IfcRampFlightTypeEnum {
    Straight,
    Spiral,
    Userdefined,
    Notdefined,
}
impl Default for IfcRampFlightTypeEnum {
    fn default() -> Self {
        IfcRampFlightTypeEnum::Straight
    }
}
impl From<String> for IfcRampFlightTypeEnum {
    fn from(value: String) -> Self {
        match value.as_str() {
            "STRAIGHT" => IfcRampFlightTypeEnum::Straight,
            "SPIRAL" => IfcRampFlightTypeEnum::Spiral,
            "USERDEFINED" => IfcRampFlightTypeEnum::Userdefined,
            "NOTDEFINED" => IfcRampFlightTypeEnum::Notdefined,
            _ => panic!("{} is not a valid value", value),
        }
    }
}
impl From<Parameter> for IfcRampFlightTypeEnum {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EnumValue(value) => value.into(),
                _ => panic!("parameter is not an enum value"),
            },
            Parameter::OmittedParameter => IfcRampFlightTypeEnum::default(),
            _ => panic!("parameter is not an enum value"),
        }
    }
}
#[derive(Eq, PartialEq, Hash, Debug)]
pub enum IfcRampTypeEnum {
    StraightRunRamp,
    TwoStraightRunRamp,
    QuarterTurnRamp,
    TwoQuarterTurnRamp,
    HalfTurnRamp,
    SpiralRamp,
    Userdefined,
    Notdefined,
}
impl Default for IfcRampTypeEnum {
    fn default() -> Self {
        IfcRampTypeEnum::StraightRunRamp
    }
}
impl From<String> for IfcRampTypeEnum {
    fn from(value: String) -> Self {
        match value.as_str() {
            "STRAIGHT_RUN_RAMP" => IfcRampTypeEnum::StraightRunRamp,
            "TWO_STRAIGHT_RUN_RAMP" => IfcRampTypeEnum::TwoStraightRunRamp,
            "QUARTER_TURN_RAMP" => IfcRampTypeEnum::QuarterTurnRamp,
            "TWO_QUARTER_TURN_RAMP" => IfcRampTypeEnum::TwoQuarterTurnRamp,
            "HALF_TURN_RAMP" => IfcRampTypeEnum::HalfTurnRamp,
            "SPIRAL_RAMP" => IfcRampTypeEnum::SpiralRamp,
            "USERDEFINED" => IfcRampTypeEnum::Userdefined,
            "NOTDEFINED" => IfcRampTypeEnum::Notdefined,
            _ => panic!("{} is not a valid value", value),
        }
    }
}
impl From<Parameter> for IfcRampTypeEnum {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EnumValue(value) => value.into(),
                _ => panic!("parameter is not an enum value"),
            },
            Parameter::OmittedParameter => IfcRampTypeEnum::default(),
            _ => panic!("parameter is not an enum value"),
        }
    }
}
#[derive(Eq, PartialEq, Hash, Debug)]
pub enum IfcRecurrenceTypeEnum {
    Daily,
    Weekly,
    MonthlyByDayOfMonth,
    MonthlyByPosition,
    ByDayCount,
    ByWeekdayCount,
    YearlyByDayOfMonth,
    YearlyByPosition,
}
impl Default for IfcRecurrenceTypeEnum {
    fn default() -> Self {
        IfcRecurrenceTypeEnum::Daily
    }
}
impl From<String> for IfcRecurrenceTypeEnum {
    fn from(value: String) -> Self {
        match value.as_str() {
            "DAILY" => IfcRecurrenceTypeEnum::Daily,
            "WEEKLY" => IfcRecurrenceTypeEnum::Weekly,
            "MONTHLY_BY_DAY_OF_MONTH" => IfcRecurrenceTypeEnum::MonthlyByDayOfMonth,
            "MONTHLY_BY_POSITION" => IfcRecurrenceTypeEnum::MonthlyByPosition,
            "BY_DAY_COUNT" => IfcRecurrenceTypeEnum::ByDayCount,
            "BY_WEEKDAY_COUNT" => IfcRecurrenceTypeEnum::ByWeekdayCount,
            "YEARLY_BY_DAY_OF_MONTH" => IfcRecurrenceTypeEnum::YearlyByDayOfMonth,
            "YEARLY_BY_POSITION" => IfcRecurrenceTypeEnum::YearlyByPosition,
            _ => panic!("{} is not a valid value", value),
        }
    }
}
impl From<Parameter> for IfcRecurrenceTypeEnum {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EnumValue(value) => value.into(),
                _ => panic!("parameter is not an enum value"),
            },
            Parameter::OmittedParameter => IfcRecurrenceTypeEnum::default(),
            _ => panic!("parameter is not an enum value"),
        }
    }
}
#[derive(Eq, PartialEq, Hash, Debug)]
pub enum IfcReflectanceMethodEnum {
    Blinn,
    Flat,
    Glass,
    Matt,
    Metal,
    Mirror,
    Phong,
    Plastic,
    Strauss,
    Notdefined,
}
impl Default for IfcReflectanceMethodEnum {
    fn default() -> Self {
        IfcReflectanceMethodEnum::Blinn
    }
}
impl From<String> for IfcReflectanceMethodEnum {
    fn from(value: String) -> Self {
        match value.as_str() {
            "BLINN" => IfcReflectanceMethodEnum::Blinn,
            "FLAT" => IfcReflectanceMethodEnum::Flat,
            "GLASS" => IfcReflectanceMethodEnum::Glass,
            "MATT" => IfcReflectanceMethodEnum::Matt,
            "METAL" => IfcReflectanceMethodEnum::Metal,
            "MIRROR" => IfcReflectanceMethodEnum::Mirror,
            "PHONG" => IfcReflectanceMethodEnum::Phong,
            "PLASTIC" => IfcReflectanceMethodEnum::Plastic,
            "STRAUSS" => IfcReflectanceMethodEnum::Strauss,
            "NOTDEFINED" => IfcReflectanceMethodEnum::Notdefined,
            _ => panic!("{} is not a valid value", value),
        }
    }
}
impl From<Parameter> for IfcReflectanceMethodEnum {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EnumValue(value) => value.into(),
                _ => panic!("parameter is not an enum value"),
            },
            Parameter::OmittedParameter => IfcReflectanceMethodEnum::default(),
            _ => panic!("parameter is not an enum value"),
        }
    }
}
#[derive(Eq, PartialEq, Hash, Debug)]
pub enum IfcReinforcingBarRoleEnum {
    Main,
    Shear,
    Ligature,
    Stud,
    Punching,
    Edge,
    Ring,
    Anchoring,
    Userdefined,
    Notdefined,
}
impl Default for IfcReinforcingBarRoleEnum {
    fn default() -> Self {
        IfcReinforcingBarRoleEnum::Main
    }
}
impl From<String> for IfcReinforcingBarRoleEnum {
    fn from(value: String) -> Self {
        match value.as_str() {
            "MAIN" => IfcReinforcingBarRoleEnum::Main,
            "SHEAR" => IfcReinforcingBarRoleEnum::Shear,
            "LIGATURE" => IfcReinforcingBarRoleEnum::Ligature,
            "STUD" => IfcReinforcingBarRoleEnum::Stud,
            "PUNCHING" => IfcReinforcingBarRoleEnum::Punching,
            "EDGE" => IfcReinforcingBarRoleEnum::Edge,
            "RING" => IfcReinforcingBarRoleEnum::Ring,
            "ANCHORING" => IfcReinforcingBarRoleEnum::Anchoring,
            "USERDEFINED" => IfcReinforcingBarRoleEnum::Userdefined,
            "NOTDEFINED" => IfcReinforcingBarRoleEnum::Notdefined,
            _ => panic!("{} is not a valid value", value),
        }
    }
}
impl From<Parameter> for IfcReinforcingBarRoleEnum {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EnumValue(value) => value.into(),
                _ => panic!("parameter is not an enum value"),
            },
            Parameter::OmittedParameter => IfcReinforcingBarRoleEnum::default(),
            _ => panic!("parameter is not an enum value"),
        }
    }
}
#[derive(Eq, PartialEq, Hash, Debug)]
pub enum IfcReinforcingBarSurfaceEnum {
    Plain,
    Textured,
}
impl Default for IfcReinforcingBarSurfaceEnum {
    fn default() -> Self {
        IfcReinforcingBarSurfaceEnum::Plain
    }
}
impl From<String> for IfcReinforcingBarSurfaceEnum {
    fn from(value: String) -> Self {
        match value.as_str() {
            "PLAIN" => IfcReinforcingBarSurfaceEnum::Plain,
            "TEXTURED" => IfcReinforcingBarSurfaceEnum::Textured,
            _ => panic!("{} is not a valid value", value),
        }
    }
}
impl From<Parameter> for IfcReinforcingBarSurfaceEnum {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EnumValue(value) => value.into(),
                _ => panic!("parameter is not an enum value"),
            },
            Parameter::OmittedParameter => IfcReinforcingBarSurfaceEnum::default(),
            _ => panic!("parameter is not an enum value"),
        }
    }
}
#[derive(Eq, PartialEq, Hash, Debug)]
pub enum IfcReinforcingBarTypeEnum {
    Anchoring,
    Edge,
    Ligature,
    Main,
    Punching,
    Ring,
    Shear,
    Stud,
    Userdefined,
    Notdefined,
}
impl Default for IfcReinforcingBarTypeEnum {
    fn default() -> Self {
        IfcReinforcingBarTypeEnum::Anchoring
    }
}
impl From<String> for IfcReinforcingBarTypeEnum {
    fn from(value: String) -> Self {
        match value.as_str() {
            "ANCHORING" => IfcReinforcingBarTypeEnum::Anchoring,
            "EDGE" => IfcReinforcingBarTypeEnum::Edge,
            "LIGATURE" => IfcReinforcingBarTypeEnum::Ligature,
            "MAIN" => IfcReinforcingBarTypeEnum::Main,
            "PUNCHING" => IfcReinforcingBarTypeEnum::Punching,
            "RING" => IfcReinforcingBarTypeEnum::Ring,
            "SHEAR" => IfcReinforcingBarTypeEnum::Shear,
            "STUD" => IfcReinforcingBarTypeEnum::Stud,
            "USERDEFINED" => IfcReinforcingBarTypeEnum::Userdefined,
            "NOTDEFINED" => IfcReinforcingBarTypeEnum::Notdefined,
            _ => panic!("{} is not a valid value", value),
        }
    }
}
impl From<Parameter> for IfcReinforcingBarTypeEnum {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EnumValue(value) => value.into(),
                _ => panic!("parameter is not an enum value"),
            },
            Parameter::OmittedParameter => IfcReinforcingBarTypeEnum::default(),
            _ => panic!("parameter is not an enum value"),
        }
    }
}
#[derive(Eq, PartialEq, Hash, Debug)]
pub enum IfcReinforcingMeshTypeEnum {
    Userdefined,
    Notdefined,
}
impl Default for IfcReinforcingMeshTypeEnum {
    fn default() -> Self {
        IfcReinforcingMeshTypeEnum::Userdefined
    }
}
impl From<String> for IfcReinforcingMeshTypeEnum {
    fn from(value: String) -> Self {
        match value.as_str() {
            "USERDEFINED" => IfcReinforcingMeshTypeEnum::Userdefined,
            "NOTDEFINED" => IfcReinforcingMeshTypeEnum::Notdefined,
            _ => panic!("{} is not a valid value", value),
        }
    }
}
impl From<Parameter> for IfcReinforcingMeshTypeEnum {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EnumValue(value) => value.into(),
                _ => panic!("parameter is not an enum value"),
            },
            Parameter::OmittedParameter => IfcReinforcingMeshTypeEnum::default(),
            _ => panic!("parameter is not an enum value"),
        }
    }
}
#[derive(Eq, PartialEq, Hash, Debug)]
pub enum IfcRoleEnum {
    Supplier,
    Manufacturer,
    Contractor,
    Subcontractor,
    Architect,
    Structuralengineer,
    Costengineer,
    Client,
    Buildingowner,
    Buildingoperator,
    Mechanicalengineer,
    Electricalengineer,
    Projectmanager,
    Facilitiesmanager,
    Civilengineer,
    Commissioningengineer,
    Engineer,
    Owner,
    Consultant,
    Constructionmanager,
    Fieldconstructionmanager,
    Reseller,
    Userdefined,
}
impl Default for IfcRoleEnum {
    fn default() -> Self {
        IfcRoleEnum::Supplier
    }
}
impl From<String> for IfcRoleEnum {
    fn from(value: String) -> Self {
        match value.as_str() {
            "SUPPLIER" => IfcRoleEnum::Supplier,
            "MANUFACTURER" => IfcRoleEnum::Manufacturer,
            "CONTRACTOR" => IfcRoleEnum::Contractor,
            "SUBCONTRACTOR" => IfcRoleEnum::Subcontractor,
            "ARCHITECT" => IfcRoleEnum::Architect,
            "STRUCTURALENGINEER" => IfcRoleEnum::Structuralengineer,
            "COSTENGINEER" => IfcRoleEnum::Costengineer,
            "CLIENT" => IfcRoleEnum::Client,
            "BUILDINGOWNER" => IfcRoleEnum::Buildingowner,
            "BUILDINGOPERATOR" => IfcRoleEnum::Buildingoperator,
            "MECHANICALENGINEER" => IfcRoleEnum::Mechanicalengineer,
            "ELECTRICALENGINEER" => IfcRoleEnum::Electricalengineer,
            "PROJECTMANAGER" => IfcRoleEnum::Projectmanager,
            "FACILITIESMANAGER" => IfcRoleEnum::Facilitiesmanager,
            "CIVILENGINEER" => IfcRoleEnum::Civilengineer,
            "COMMISSIONINGENGINEER" => IfcRoleEnum::Commissioningengineer,
            "ENGINEER" => IfcRoleEnum::Engineer,
            "OWNER" => IfcRoleEnum::Owner,
            "CONSULTANT" => IfcRoleEnum::Consultant,
            "CONSTRUCTIONMANAGER" => IfcRoleEnum::Constructionmanager,
            "FIELDCONSTRUCTIONMANAGER" => IfcRoleEnum::Fieldconstructionmanager,
            "RESELLER" => IfcRoleEnum::Reseller,
            "USERDEFINED" => IfcRoleEnum::Userdefined,
            _ => panic!("{} is not a valid value", value),
        }
    }
}
impl From<Parameter> for IfcRoleEnum {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EnumValue(value) => value.into(),
                _ => panic!("parameter is not an enum value"),
            },
            Parameter::OmittedParameter => IfcRoleEnum::default(),
            _ => panic!("parameter is not an enum value"),
        }
    }
}
#[derive(Eq, PartialEq, Hash, Debug)]
pub enum IfcRoofTypeEnum {
    FlatRoof,
    ShedRoof,
    GableRoof,
    HipRoof,
    HippedGableRoof,
    GambrelRoof,
    MansardRoof,
    BarrelRoof,
    RainbowRoof,
    ButterflyRoof,
    PavilionRoof,
    DomeRoof,
    Freeform,
    Userdefined,
    Notdefined,
}
impl Default for IfcRoofTypeEnum {
    fn default() -> Self {
        IfcRoofTypeEnum::FlatRoof
    }
}
impl From<String> for IfcRoofTypeEnum {
    fn from(value: String) -> Self {
        match value.as_str() {
            "FLAT_ROOF" => IfcRoofTypeEnum::FlatRoof,
            "SHED_ROOF" => IfcRoofTypeEnum::ShedRoof,
            "GABLE_ROOF" => IfcRoofTypeEnum::GableRoof,
            "HIP_ROOF" => IfcRoofTypeEnum::HipRoof,
            "HIPPED_GABLE_ROOF" => IfcRoofTypeEnum::HippedGableRoof,
            "GAMBREL_ROOF" => IfcRoofTypeEnum::GambrelRoof,
            "MANSARD_ROOF" => IfcRoofTypeEnum::MansardRoof,
            "BARREL_ROOF" => IfcRoofTypeEnum::BarrelRoof,
            "RAINBOW_ROOF" => IfcRoofTypeEnum::RainbowRoof,
            "BUTTERFLY_ROOF" => IfcRoofTypeEnum::ButterflyRoof,
            "PAVILION_ROOF" => IfcRoofTypeEnum::PavilionRoof,
            "DOME_ROOF" => IfcRoofTypeEnum::DomeRoof,
            "FREEFORM" => IfcRoofTypeEnum::Freeform,
            "USERDEFINED" => IfcRoofTypeEnum::Userdefined,
            "NOTDEFINED" => IfcRoofTypeEnum::Notdefined,
            _ => panic!("{} is not a valid value", value),
        }
    }
}
impl From<Parameter> for IfcRoofTypeEnum {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EnumValue(value) => value.into(),
                _ => panic!("parameter is not an enum value"),
            },
            Parameter::OmittedParameter => IfcRoofTypeEnum::default(),
            _ => panic!("parameter is not an enum value"),
        }
    }
}
#[derive(Eq, PartialEq, Hash, Debug)]
pub enum IfcSiPrefix {
    Exa,
    Peta,
    Tera,
    Giga,
    Mega,
    Kilo,
    Hecto,
    Deca,
    Deci,
    Centi,
    Milli,
    Micro,
    Nano,
    Pico,
    Femto,
    Atto,
}
impl Default for IfcSiPrefix {
    fn default() -> Self {
        IfcSiPrefix::Exa
    }
}
impl From<String> for IfcSiPrefix {
    fn from(value: String) -> Self {
        match value.as_str() {
            "EXA" => IfcSiPrefix::Exa,
            "PETA" => IfcSiPrefix::Peta,
            "TERA" => IfcSiPrefix::Tera,
            "GIGA" => IfcSiPrefix::Giga,
            "MEGA" => IfcSiPrefix::Mega,
            "KILO" => IfcSiPrefix::Kilo,
            "HECTO" => IfcSiPrefix::Hecto,
            "DECA" => IfcSiPrefix::Deca,
            "DECI" => IfcSiPrefix::Deci,
            "CENTI" => IfcSiPrefix::Centi,
            "MILLI" => IfcSiPrefix::Milli,
            "MICRO" => IfcSiPrefix::Micro,
            "NANO" => IfcSiPrefix::Nano,
            "PICO" => IfcSiPrefix::Pico,
            "FEMTO" => IfcSiPrefix::Femto,
            "ATTO" => IfcSiPrefix::Atto,
            _ => panic!("{} is not a valid value", value),
        }
    }
}
impl From<Parameter> for IfcSiPrefix {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EnumValue(value) => value.into(),
                _ => panic!("parameter is not an enum value"),
            },
            Parameter::OmittedParameter => IfcSiPrefix::default(),
            _ => panic!("parameter is not an enum value"),
        }
    }
}
#[derive(Eq, PartialEq, Hash, Debug)]
pub enum IfcSiUnitName {
    Ampere,
    Becquerel,
    Candela,
    Coulomb,
    CubicMetre,
    DegreeCelsius,
    Farad,
    Gram,
    Gray,
    Henry,
    Hertz,
    Joule,
    Kelvin,
    Lumen,
    Lux,
    Metre,
    Mole,
    Newton,
    Ohm,
    Pascal,
    Radian,
    Second,
    Siemens,
    Sievert,
    SquareMetre,
    Steradian,
    Tesla,
    Volt,
    Watt,
    Weber,
}
impl Default for IfcSiUnitName {
    fn default() -> Self {
        IfcSiUnitName::Ampere
    }
}
impl From<String> for IfcSiUnitName {
    fn from(value: String) -> Self {
        match value.as_str() {
            "AMPERE" => IfcSiUnitName::Ampere,
            "BECQUEREL" => IfcSiUnitName::Becquerel,
            "CANDELA" => IfcSiUnitName::Candela,
            "COULOMB" => IfcSiUnitName::Coulomb,
            "CUBIC_METRE" => IfcSiUnitName::CubicMetre,
            "DEGREE_CELSIUS" => IfcSiUnitName::DegreeCelsius,
            "FARAD" => IfcSiUnitName::Farad,
            "GRAM" => IfcSiUnitName::Gram,
            "GRAY" => IfcSiUnitName::Gray,
            "HENRY" => IfcSiUnitName::Henry,
            "HERTZ" => IfcSiUnitName::Hertz,
            "JOULE" => IfcSiUnitName::Joule,
            "KELVIN" => IfcSiUnitName::Kelvin,
            "LUMEN" => IfcSiUnitName::Lumen,
            "LUX" => IfcSiUnitName::Lux,
            "METRE" => IfcSiUnitName::Metre,
            "MOLE" => IfcSiUnitName::Mole,
            "NEWTON" => IfcSiUnitName::Newton,
            "OHM" => IfcSiUnitName::Ohm,
            "PASCAL" => IfcSiUnitName::Pascal,
            "RADIAN" => IfcSiUnitName::Radian,
            "SECOND" => IfcSiUnitName::Second,
            "SIEMENS" => IfcSiUnitName::Siemens,
            "SIEVERT" => IfcSiUnitName::Sievert,
            "SQUARE_METRE" => IfcSiUnitName::SquareMetre,
            "STERADIAN" => IfcSiUnitName::Steradian,
            "TESLA" => IfcSiUnitName::Tesla,
            "VOLT" => IfcSiUnitName::Volt,
            "WATT" => IfcSiUnitName::Watt,
            "WEBER" => IfcSiUnitName::Weber,
            _ => panic!("{} is not a valid value", value),
        }
    }
}
impl From<Parameter> for IfcSiUnitName {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EnumValue(value) => value.into(),
                _ => panic!("parameter is not an enum value"),
            },
            Parameter::OmittedParameter => IfcSiUnitName::default(),
            _ => panic!("parameter is not an enum value"),
        }
    }
}
#[derive(Eq, PartialEq, Hash, Debug)]
pub enum IfcSanitaryTerminalTypeEnum {
    Bath,
    Bidet,
    Cistern,
    Shower,
    Sink,
    Sanitaryfountain,
    Toiletpan,
    Urinal,
    Washhandbasin,
    Wcseat,
    Userdefined,
    Notdefined,
}
impl Default for IfcSanitaryTerminalTypeEnum {
    fn default() -> Self {
        IfcSanitaryTerminalTypeEnum::Bath
    }
}
impl From<String> for IfcSanitaryTerminalTypeEnum {
    fn from(value: String) -> Self {
        match value.as_str() {
            "BATH" => IfcSanitaryTerminalTypeEnum::Bath,
            "BIDET" => IfcSanitaryTerminalTypeEnum::Bidet,
            "CISTERN" => IfcSanitaryTerminalTypeEnum::Cistern,
            "SHOWER" => IfcSanitaryTerminalTypeEnum::Shower,
            "SINK" => IfcSanitaryTerminalTypeEnum::Sink,
            "SANITARYFOUNTAIN" => IfcSanitaryTerminalTypeEnum::Sanitaryfountain,
            "TOILETPAN" => IfcSanitaryTerminalTypeEnum::Toiletpan,
            "URINAL" => IfcSanitaryTerminalTypeEnum::Urinal,
            "WASHHANDBASIN" => IfcSanitaryTerminalTypeEnum::Washhandbasin,
            "WCSEAT" => IfcSanitaryTerminalTypeEnum::Wcseat,
            "USERDEFINED" => IfcSanitaryTerminalTypeEnum::Userdefined,
            "NOTDEFINED" => IfcSanitaryTerminalTypeEnum::Notdefined,
            _ => panic!("{} is not a valid value", value),
        }
    }
}
impl From<Parameter> for IfcSanitaryTerminalTypeEnum {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EnumValue(value) => value.into(),
                _ => panic!("parameter is not an enum value"),
            },
            Parameter::OmittedParameter => IfcSanitaryTerminalTypeEnum::default(),
            _ => panic!("parameter is not an enum value"),
        }
    }
}
#[derive(Eq, PartialEq, Hash, Debug)]
pub enum IfcSectionTypeEnum {
    Uniform,
    Tapered,
}
impl Default for IfcSectionTypeEnum {
    fn default() -> Self {
        IfcSectionTypeEnum::Uniform
    }
}
impl From<String> for IfcSectionTypeEnum {
    fn from(value: String) -> Self {
        match value.as_str() {
            "UNIFORM" => IfcSectionTypeEnum::Uniform,
            "TAPERED" => IfcSectionTypeEnum::Tapered,
            _ => panic!("{} is not a valid value", value),
        }
    }
}
impl From<Parameter> for IfcSectionTypeEnum {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EnumValue(value) => value.into(),
                _ => panic!("parameter is not an enum value"),
            },
            Parameter::OmittedParameter => IfcSectionTypeEnum::default(),
            _ => panic!("parameter is not an enum value"),
        }
    }
}
#[derive(Eq, PartialEq, Hash, Debug)]
pub enum IfcSensorTypeEnum {
    Cosensor,
    Co2sensor,
    Conductancesensor,
    Contactsensor,
    Firesensor,
    Flowsensor,
    Frostsensor,
    Gassensor,
    Heatsensor,
    Humiditysensor,
    Identifiersensor,
    Ionconcentrationsensor,
    Levelsensor,
    Lightsensor,
    Moisturesensor,
    Movementsensor,
    Phsensor,
    Pressuresensor,
    Radiationsensor,
    Radioactivitysensor,
    Smokesensor,
    Soundsensor,
    Temperaturesensor,
    Windsensor,
    Userdefined,
    Notdefined,
}
impl Default for IfcSensorTypeEnum {
    fn default() -> Self {
        IfcSensorTypeEnum::Cosensor
    }
}
impl From<String> for IfcSensorTypeEnum {
    fn from(value: String) -> Self {
        match value.as_str() {
            "COSENSOR" => IfcSensorTypeEnum::Cosensor,
            "CO2SENSOR" => IfcSensorTypeEnum::Co2sensor,
            "CONDUCTANCESENSOR" => IfcSensorTypeEnum::Conductancesensor,
            "CONTACTSENSOR" => IfcSensorTypeEnum::Contactsensor,
            "FIRESENSOR" => IfcSensorTypeEnum::Firesensor,
            "FLOWSENSOR" => IfcSensorTypeEnum::Flowsensor,
            "FROSTSENSOR" => IfcSensorTypeEnum::Frostsensor,
            "GASSENSOR" => IfcSensorTypeEnum::Gassensor,
            "HEATSENSOR" => IfcSensorTypeEnum::Heatsensor,
            "HUMIDITYSENSOR" => IfcSensorTypeEnum::Humiditysensor,
            "IDENTIFIERSENSOR" => IfcSensorTypeEnum::Identifiersensor,
            "IONCONCENTRATIONSENSOR" => IfcSensorTypeEnum::Ionconcentrationsensor,
            "LEVELSENSOR" => IfcSensorTypeEnum::Levelsensor,
            "LIGHTSENSOR" => IfcSensorTypeEnum::Lightsensor,
            "MOISTURESENSOR" => IfcSensorTypeEnum::Moisturesensor,
            "MOVEMENTSENSOR" => IfcSensorTypeEnum::Movementsensor,
            "PHSENSOR" => IfcSensorTypeEnum::Phsensor,
            "PRESSURESENSOR" => IfcSensorTypeEnum::Pressuresensor,
            "RADIATIONSENSOR" => IfcSensorTypeEnum::Radiationsensor,
            "RADIOACTIVITYSENSOR" => IfcSensorTypeEnum::Radioactivitysensor,
            "SMOKESENSOR" => IfcSensorTypeEnum::Smokesensor,
            "SOUNDSENSOR" => IfcSensorTypeEnum::Soundsensor,
            "TEMPERATURESENSOR" => IfcSensorTypeEnum::Temperaturesensor,
            "WINDSENSOR" => IfcSensorTypeEnum::Windsensor,
            "USERDEFINED" => IfcSensorTypeEnum::Userdefined,
            "NOTDEFINED" => IfcSensorTypeEnum::Notdefined,
            _ => panic!("{} is not a valid value", value),
        }
    }
}
impl From<Parameter> for IfcSensorTypeEnum {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EnumValue(value) => value.into(),
                _ => panic!("parameter is not an enum value"),
            },
            Parameter::OmittedParameter => IfcSensorTypeEnum::default(),
            _ => panic!("parameter is not an enum value"),
        }
    }
}
#[derive(Eq, PartialEq, Hash, Debug)]
pub enum IfcSequenceEnum {
    StartStart,
    StartFinish,
    FinishStart,
    FinishFinish,
    Userdefined,
    Notdefined,
}
impl Default for IfcSequenceEnum {
    fn default() -> Self {
        IfcSequenceEnum::StartStart
    }
}
impl From<String> for IfcSequenceEnum {
    fn from(value: String) -> Self {
        match value.as_str() {
            "START_START" => IfcSequenceEnum::StartStart,
            "START_FINISH" => IfcSequenceEnum::StartFinish,
            "FINISH_START" => IfcSequenceEnum::FinishStart,
            "FINISH_FINISH" => IfcSequenceEnum::FinishFinish,
            "USERDEFINED" => IfcSequenceEnum::Userdefined,
            "NOTDEFINED" => IfcSequenceEnum::Notdefined,
            _ => panic!("{} is not a valid value", value),
        }
    }
}
impl From<Parameter> for IfcSequenceEnum {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EnumValue(value) => value.into(),
                _ => panic!("parameter is not an enum value"),
            },
            Parameter::OmittedParameter => IfcSequenceEnum::default(),
            _ => panic!("parameter is not an enum value"),
        }
    }
}
#[derive(Eq, PartialEq, Hash, Debug)]
pub enum IfcShadingDeviceTypeEnum {
    Jalousie,
    Shutter,
    Awning,
    Userdefined,
    Notdefined,
}
impl Default for IfcShadingDeviceTypeEnum {
    fn default() -> Self {
        IfcShadingDeviceTypeEnum::Jalousie
    }
}
impl From<String> for IfcShadingDeviceTypeEnum {
    fn from(value: String) -> Self {
        match value.as_str() {
            "JALOUSIE" => IfcShadingDeviceTypeEnum::Jalousie,
            "SHUTTER" => IfcShadingDeviceTypeEnum::Shutter,
            "AWNING" => IfcShadingDeviceTypeEnum::Awning,
            "USERDEFINED" => IfcShadingDeviceTypeEnum::Userdefined,
            "NOTDEFINED" => IfcShadingDeviceTypeEnum::Notdefined,
            _ => panic!("{} is not a valid value", value),
        }
    }
}
impl From<Parameter> for IfcShadingDeviceTypeEnum {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EnumValue(value) => value.into(),
                _ => panic!("parameter is not an enum value"),
            },
            Parameter::OmittedParameter => IfcShadingDeviceTypeEnum::default(),
            _ => panic!("parameter is not an enum value"),
        }
    }
}
#[derive(Eq, PartialEq, Hash, Debug)]
pub enum IfcSimplePropertyTemplateTypeEnum {
    PSinglevalue,
    PEnumeratedvalue,
    PBoundedvalue,
    PListvalue,
    PTablevalue,
    PReferencevalue,
    QLength,
    QArea,
    QVolume,
    QCount,
    QWeight,
    QTime,
}
impl Default for IfcSimplePropertyTemplateTypeEnum {
    fn default() -> Self {
        IfcSimplePropertyTemplateTypeEnum::PSinglevalue
    }
}
impl From<String> for IfcSimplePropertyTemplateTypeEnum {
    fn from(value: String) -> Self {
        match value.as_str() {
            "P_SINGLEVALUE" => IfcSimplePropertyTemplateTypeEnum::PSinglevalue,
            "P_ENUMERATEDVALUE" => IfcSimplePropertyTemplateTypeEnum::PEnumeratedvalue,
            "P_BOUNDEDVALUE" => IfcSimplePropertyTemplateTypeEnum::PBoundedvalue,
            "P_LISTVALUE" => IfcSimplePropertyTemplateTypeEnum::PListvalue,
            "P_TABLEVALUE" => IfcSimplePropertyTemplateTypeEnum::PTablevalue,
            "P_REFERENCEVALUE" => IfcSimplePropertyTemplateTypeEnum::PReferencevalue,
            "Q_LENGTH" => IfcSimplePropertyTemplateTypeEnum::QLength,
            "Q_AREA" => IfcSimplePropertyTemplateTypeEnum::QArea,
            "Q_VOLUME" => IfcSimplePropertyTemplateTypeEnum::QVolume,
            "Q_COUNT" => IfcSimplePropertyTemplateTypeEnum::QCount,
            "Q_WEIGHT" => IfcSimplePropertyTemplateTypeEnum::QWeight,
            "Q_TIME" => IfcSimplePropertyTemplateTypeEnum::QTime,
            _ => panic!("{} is not a valid value", value),
        }
    }
}
impl From<Parameter> for IfcSimplePropertyTemplateTypeEnum {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EnumValue(value) => value.into(),
                _ => panic!("parameter is not an enum value"),
            },
            Parameter::OmittedParameter => IfcSimplePropertyTemplateTypeEnum::default(),
            _ => panic!("parameter is not an enum value"),
        }
    }
}
#[derive(Eq, PartialEq, Hash, Debug)]
pub enum IfcSlabTypeEnum {
    Floor,
    Roof,
    Landing,
    Baseslab,
    Userdefined,
    Notdefined,
}
impl Default for IfcSlabTypeEnum {
    fn default() -> Self {
        IfcSlabTypeEnum::Floor
    }
}
impl From<String> for IfcSlabTypeEnum {
    fn from(value: String) -> Self {
        match value.as_str() {
            "FLOOR" => IfcSlabTypeEnum::Floor,
            "ROOF" => IfcSlabTypeEnum::Roof,
            "LANDING" => IfcSlabTypeEnum::Landing,
            "BASESLAB" => IfcSlabTypeEnum::Baseslab,
            "USERDEFINED" => IfcSlabTypeEnum::Userdefined,
            "NOTDEFINED" => IfcSlabTypeEnum::Notdefined,
            _ => panic!("{} is not a valid value", value),
        }
    }
}
impl From<Parameter> for IfcSlabTypeEnum {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EnumValue(value) => value.into(),
                _ => panic!("parameter is not an enum value"),
            },
            Parameter::OmittedParameter => IfcSlabTypeEnum::default(),
            _ => panic!("parameter is not an enum value"),
        }
    }
}
#[derive(Eq, PartialEq, Hash, Debug)]
pub enum IfcSolarDeviceTypeEnum {
    Solarcollector,
    Solarpanel,
    Userdefined,
    Notdefined,
}
impl Default for IfcSolarDeviceTypeEnum {
    fn default() -> Self {
        IfcSolarDeviceTypeEnum::Solarcollector
    }
}
impl From<String> for IfcSolarDeviceTypeEnum {
    fn from(value: String) -> Self {
        match value.as_str() {
            "SOLARCOLLECTOR" => IfcSolarDeviceTypeEnum::Solarcollector,
            "SOLARPANEL" => IfcSolarDeviceTypeEnum::Solarpanel,
            "USERDEFINED" => IfcSolarDeviceTypeEnum::Userdefined,
            "NOTDEFINED" => IfcSolarDeviceTypeEnum::Notdefined,
            _ => panic!("{} is not a valid value", value),
        }
    }
}
impl From<Parameter> for IfcSolarDeviceTypeEnum {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EnumValue(value) => value.into(),
                _ => panic!("parameter is not an enum value"),
            },
            Parameter::OmittedParameter => IfcSolarDeviceTypeEnum::default(),
            _ => panic!("parameter is not an enum value"),
        }
    }
}
#[derive(Eq, PartialEq, Hash, Debug)]
pub enum IfcSpaceHeaterTypeEnum {
    Convector,
    Radiator,
    Userdefined,
    Notdefined,
}
impl Default for IfcSpaceHeaterTypeEnum {
    fn default() -> Self {
        IfcSpaceHeaterTypeEnum::Convector
    }
}
impl From<String> for IfcSpaceHeaterTypeEnum {
    fn from(value: String) -> Self {
        match value.as_str() {
            "CONVECTOR" => IfcSpaceHeaterTypeEnum::Convector,
            "RADIATOR" => IfcSpaceHeaterTypeEnum::Radiator,
            "USERDEFINED" => IfcSpaceHeaterTypeEnum::Userdefined,
            "NOTDEFINED" => IfcSpaceHeaterTypeEnum::Notdefined,
            _ => panic!("{} is not a valid value", value),
        }
    }
}
impl From<Parameter> for IfcSpaceHeaterTypeEnum {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EnumValue(value) => value.into(),
                _ => panic!("parameter is not an enum value"),
            },
            Parameter::OmittedParameter => IfcSpaceHeaterTypeEnum::default(),
            _ => panic!("parameter is not an enum value"),
        }
    }
}
#[derive(Eq, PartialEq, Hash, Debug)]
pub enum IfcSpaceTypeEnum {
    Space,
    Parking,
    Gfa,
    Internal,
    External,
    Userdefined,
    Notdefined,
}
impl Default for IfcSpaceTypeEnum {
    fn default() -> Self {
        IfcSpaceTypeEnum::Space
    }
}
impl From<String> for IfcSpaceTypeEnum {
    fn from(value: String) -> Self {
        match value.as_str() {
            "SPACE" => IfcSpaceTypeEnum::Space,
            "PARKING" => IfcSpaceTypeEnum::Parking,
            "GFA" => IfcSpaceTypeEnum::Gfa,
            "INTERNAL" => IfcSpaceTypeEnum::Internal,
            "EXTERNAL" => IfcSpaceTypeEnum::External,
            "USERDEFINED" => IfcSpaceTypeEnum::Userdefined,
            "NOTDEFINED" => IfcSpaceTypeEnum::Notdefined,
            _ => panic!("{} is not a valid value", value),
        }
    }
}
impl From<Parameter> for IfcSpaceTypeEnum {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EnumValue(value) => value.into(),
                _ => panic!("parameter is not an enum value"),
            },
            Parameter::OmittedParameter => IfcSpaceTypeEnum::default(),
            _ => panic!("parameter is not an enum value"),
        }
    }
}
#[derive(Eq, PartialEq, Hash, Debug)]
pub enum IfcSpatialZoneTypeEnum {
    Construction,
    Firesafety,
    Lighting,
    Occupancy,
    Security,
    Thermal,
    Transport,
    Ventilation,
    Userdefined,
    Notdefined,
}
impl Default for IfcSpatialZoneTypeEnum {
    fn default() -> Self {
        IfcSpatialZoneTypeEnum::Construction
    }
}
impl From<String> for IfcSpatialZoneTypeEnum {
    fn from(value: String) -> Self {
        match value.as_str() {
            "CONSTRUCTION" => IfcSpatialZoneTypeEnum::Construction,
            "FIRESAFETY" => IfcSpatialZoneTypeEnum::Firesafety,
            "LIGHTING" => IfcSpatialZoneTypeEnum::Lighting,
            "OCCUPANCY" => IfcSpatialZoneTypeEnum::Occupancy,
            "SECURITY" => IfcSpatialZoneTypeEnum::Security,
            "THERMAL" => IfcSpatialZoneTypeEnum::Thermal,
            "TRANSPORT" => IfcSpatialZoneTypeEnum::Transport,
            "VENTILATION" => IfcSpatialZoneTypeEnum::Ventilation,
            "USERDEFINED" => IfcSpatialZoneTypeEnum::Userdefined,
            "NOTDEFINED" => IfcSpatialZoneTypeEnum::Notdefined,
            _ => panic!("{} is not a valid value", value),
        }
    }
}
impl From<Parameter> for IfcSpatialZoneTypeEnum {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EnumValue(value) => value.into(),
                _ => panic!("parameter is not an enum value"),
            },
            Parameter::OmittedParameter => IfcSpatialZoneTypeEnum::default(),
            _ => panic!("parameter is not an enum value"),
        }
    }
}
#[derive(Eq, PartialEq, Hash, Debug)]
pub enum IfcStackTerminalTypeEnum {
    Birdcage,
    Cowl,
    Rainwaterhopper,
    Userdefined,
    Notdefined,
}
impl Default for IfcStackTerminalTypeEnum {
    fn default() -> Self {
        IfcStackTerminalTypeEnum::Birdcage
    }
}
impl From<String> for IfcStackTerminalTypeEnum {
    fn from(value: String) -> Self {
        match value.as_str() {
            "BIRDCAGE" => IfcStackTerminalTypeEnum::Birdcage,
            "COWL" => IfcStackTerminalTypeEnum::Cowl,
            "RAINWATERHOPPER" => IfcStackTerminalTypeEnum::Rainwaterhopper,
            "USERDEFINED" => IfcStackTerminalTypeEnum::Userdefined,
            "NOTDEFINED" => IfcStackTerminalTypeEnum::Notdefined,
            _ => panic!("{} is not a valid value", value),
        }
    }
}
impl From<Parameter> for IfcStackTerminalTypeEnum {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EnumValue(value) => value.into(),
                _ => panic!("parameter is not an enum value"),
            },
            Parameter::OmittedParameter => IfcStackTerminalTypeEnum::default(),
            _ => panic!("parameter is not an enum value"),
        }
    }
}
#[derive(Eq, PartialEq, Hash, Debug)]
pub enum IfcStairFlightTypeEnum {
    Straight,
    Winder,
    Spiral,
    Curved,
    Freeform,
    Userdefined,
    Notdefined,
}
impl Default for IfcStairFlightTypeEnum {
    fn default() -> Self {
        IfcStairFlightTypeEnum::Straight
    }
}
impl From<String> for IfcStairFlightTypeEnum {
    fn from(value: String) -> Self {
        match value.as_str() {
            "STRAIGHT" => IfcStairFlightTypeEnum::Straight,
            "WINDER" => IfcStairFlightTypeEnum::Winder,
            "SPIRAL" => IfcStairFlightTypeEnum::Spiral,
            "CURVED" => IfcStairFlightTypeEnum::Curved,
            "FREEFORM" => IfcStairFlightTypeEnum::Freeform,
            "USERDEFINED" => IfcStairFlightTypeEnum::Userdefined,
            "NOTDEFINED" => IfcStairFlightTypeEnum::Notdefined,
            _ => panic!("{} is not a valid value", value),
        }
    }
}
impl From<Parameter> for IfcStairFlightTypeEnum {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EnumValue(value) => value.into(),
                _ => panic!("parameter is not an enum value"),
            },
            Parameter::OmittedParameter => IfcStairFlightTypeEnum::default(),
            _ => panic!("parameter is not an enum value"),
        }
    }
}
#[derive(Eq, PartialEq, Hash, Debug)]
pub enum IfcStairTypeEnum {
    StraightRunStair,
    TwoStraightRunStair,
    QuarterWindingStair,
    QuarterTurnStair,
    HalfWindingStair,
    HalfTurnStair,
    TwoQuarterWindingStair,
    TwoQuarterTurnStair,
    ThreeQuarterWindingStair,
    ThreeQuarterTurnStair,
    SpiralStair,
    DoubleReturnStair,
    CurvedRunStair,
    TwoCurvedRunStair,
    Userdefined,
    Notdefined,
}
impl Default for IfcStairTypeEnum {
    fn default() -> Self {
        IfcStairTypeEnum::StraightRunStair
    }
}
impl From<String> for IfcStairTypeEnum {
    fn from(value: String) -> Self {
        match value.as_str() {
            "STRAIGHT_RUN_STAIR" => IfcStairTypeEnum::StraightRunStair,
            "TWO_STRAIGHT_RUN_STAIR" => IfcStairTypeEnum::TwoStraightRunStair,
            "QUARTER_WINDING_STAIR" => IfcStairTypeEnum::QuarterWindingStair,
            "QUARTER_TURN_STAIR" => IfcStairTypeEnum::QuarterTurnStair,
            "HALF_WINDING_STAIR" => IfcStairTypeEnum::HalfWindingStair,
            "HALF_TURN_STAIR" => IfcStairTypeEnum::HalfTurnStair,
            "TWO_QUARTER_WINDING_STAIR" => IfcStairTypeEnum::TwoQuarterWindingStair,
            "TWO_QUARTER_TURN_STAIR" => IfcStairTypeEnum::TwoQuarterTurnStair,
            "THREE_QUARTER_WINDING_STAIR" => IfcStairTypeEnum::ThreeQuarterWindingStair,
            "THREE_QUARTER_TURN_STAIR" => IfcStairTypeEnum::ThreeQuarterTurnStair,
            "SPIRAL_STAIR" => IfcStairTypeEnum::SpiralStair,
            "DOUBLE_RETURN_STAIR" => IfcStairTypeEnum::DoubleReturnStair,
            "CURVED_RUN_STAIR" => IfcStairTypeEnum::CurvedRunStair,
            "TWO_CURVED_RUN_STAIR" => IfcStairTypeEnum::TwoCurvedRunStair,
            "USERDEFINED" => IfcStairTypeEnum::Userdefined,
            "NOTDEFINED" => IfcStairTypeEnum::Notdefined,
            _ => panic!("{} is not a valid value", value),
        }
    }
}
impl From<Parameter> for IfcStairTypeEnum {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EnumValue(value) => value.into(),
                _ => panic!("parameter is not an enum value"),
            },
            Parameter::OmittedParameter => IfcStairTypeEnum::default(),
            _ => panic!("parameter is not an enum value"),
        }
    }
}
#[derive(Eq, PartialEq, Hash, Debug)]
pub enum IfcStateEnum {
    Readwrite,
    Readonly,
    Locked,
    Readwritelocked,
    Readonlylocked,
}
impl Default for IfcStateEnum {
    fn default() -> Self {
        IfcStateEnum::Readwrite
    }
}
impl From<String> for IfcStateEnum {
    fn from(value: String) -> Self {
        match value.as_str() {
            "READWRITE" => IfcStateEnum::Readwrite,
            "READONLY" => IfcStateEnum::Readonly,
            "LOCKED" => IfcStateEnum::Locked,
            "READWRITELOCKED" => IfcStateEnum::Readwritelocked,
            "READONLYLOCKED" => IfcStateEnum::Readonlylocked,
            _ => panic!("{} is not a valid value", value),
        }
    }
}
impl From<Parameter> for IfcStateEnum {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EnumValue(value) => value.into(),
                _ => panic!("parameter is not an enum value"),
            },
            Parameter::OmittedParameter => IfcStateEnum::default(),
            _ => panic!("parameter is not an enum value"),
        }
    }
}
#[derive(Eq, PartialEq, Hash, Debug)]
pub enum IfcStructuralCurveActivityTypeEnum {
    Const,
    Linear,
    Polygonal,
    Equidistant,
    Sinus,
    Parabola,
    Discrete,
    Userdefined,
    Notdefined,
}
impl Default for IfcStructuralCurveActivityTypeEnum {
    fn default() -> Self {
        IfcStructuralCurveActivityTypeEnum::Const
    }
}
impl From<String> for IfcStructuralCurveActivityTypeEnum {
    fn from(value: String) -> Self {
        match value.as_str() {
            "CONST" => IfcStructuralCurveActivityTypeEnum::Const,
            "LINEAR" => IfcStructuralCurveActivityTypeEnum::Linear,
            "POLYGONAL" => IfcStructuralCurveActivityTypeEnum::Polygonal,
            "EQUIDISTANT" => IfcStructuralCurveActivityTypeEnum::Equidistant,
            "SINUS" => IfcStructuralCurveActivityTypeEnum::Sinus,
            "PARABOLA" => IfcStructuralCurveActivityTypeEnum::Parabola,
            "DISCRETE" => IfcStructuralCurveActivityTypeEnum::Discrete,
            "USERDEFINED" => IfcStructuralCurveActivityTypeEnum::Userdefined,
            "NOTDEFINED" => IfcStructuralCurveActivityTypeEnum::Notdefined,
            _ => panic!("{} is not a valid value", value),
        }
    }
}
impl From<Parameter> for IfcStructuralCurveActivityTypeEnum {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EnumValue(value) => value.into(),
                _ => panic!("parameter is not an enum value"),
            },
            Parameter::OmittedParameter => IfcStructuralCurveActivityTypeEnum::default(),
            _ => panic!("parameter is not an enum value"),
        }
    }
}
#[derive(Eq, PartialEq, Hash, Debug)]
pub enum IfcStructuralCurveMemberTypeEnum {
    RigidJoinedMember,
    PinJoinedMember,
    Cable,
    TensionMember,
    CompressionMember,
    Userdefined,
    Notdefined,
}
impl Default for IfcStructuralCurveMemberTypeEnum {
    fn default() -> Self {
        IfcStructuralCurveMemberTypeEnum::RigidJoinedMember
    }
}
impl From<String> for IfcStructuralCurveMemberTypeEnum {
    fn from(value: String) -> Self {
        match value.as_str() {
            "RIGID_JOINED_MEMBER" => IfcStructuralCurveMemberTypeEnum::RigidJoinedMember,
            "PIN_JOINED_MEMBER" => IfcStructuralCurveMemberTypeEnum::PinJoinedMember,
            "CABLE" => IfcStructuralCurveMemberTypeEnum::Cable,
            "TENSION_MEMBER" => IfcStructuralCurveMemberTypeEnum::TensionMember,
            "COMPRESSION_MEMBER" => IfcStructuralCurveMemberTypeEnum::CompressionMember,
            "USERDEFINED" => IfcStructuralCurveMemberTypeEnum::Userdefined,
            "NOTDEFINED" => IfcStructuralCurveMemberTypeEnum::Notdefined,
            _ => panic!("{} is not a valid value", value),
        }
    }
}
impl From<Parameter> for IfcStructuralCurveMemberTypeEnum {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EnumValue(value) => value.into(),
                _ => panic!("parameter is not an enum value"),
            },
            Parameter::OmittedParameter => IfcStructuralCurveMemberTypeEnum::default(),
            _ => panic!("parameter is not an enum value"),
        }
    }
}
#[derive(Eq, PartialEq, Hash, Debug)]
pub enum IfcStructuralSurfaceActivityTypeEnum {
    Const,
    Bilinear,
    Discrete,
    Isocontour,
    Userdefined,
    Notdefined,
}
impl Default for IfcStructuralSurfaceActivityTypeEnum {
    fn default() -> Self {
        IfcStructuralSurfaceActivityTypeEnum::Const
    }
}
impl From<String> for IfcStructuralSurfaceActivityTypeEnum {
    fn from(value: String) -> Self {
        match value.as_str() {
            "CONST" => IfcStructuralSurfaceActivityTypeEnum::Const,
            "BILINEAR" => IfcStructuralSurfaceActivityTypeEnum::Bilinear,
            "DISCRETE" => IfcStructuralSurfaceActivityTypeEnum::Discrete,
            "ISOCONTOUR" => IfcStructuralSurfaceActivityTypeEnum::Isocontour,
            "USERDEFINED" => IfcStructuralSurfaceActivityTypeEnum::Userdefined,
            "NOTDEFINED" => IfcStructuralSurfaceActivityTypeEnum::Notdefined,
            _ => panic!("{} is not a valid value", value),
        }
    }
}
impl From<Parameter> for IfcStructuralSurfaceActivityTypeEnum {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EnumValue(value) => value.into(),
                _ => panic!("parameter is not an enum value"),
            },
            Parameter::OmittedParameter => IfcStructuralSurfaceActivityTypeEnum::default(),
            _ => panic!("parameter is not an enum value"),
        }
    }
}
#[derive(Eq, PartialEq, Hash, Debug)]
pub enum IfcStructuralSurfaceMemberTypeEnum {
    BendingElement,
    MembraneElement,
    Shell,
    Userdefined,
    Notdefined,
}
impl Default for IfcStructuralSurfaceMemberTypeEnum {
    fn default() -> Self {
        IfcStructuralSurfaceMemberTypeEnum::BendingElement
    }
}
impl From<String> for IfcStructuralSurfaceMemberTypeEnum {
    fn from(value: String) -> Self {
        match value.as_str() {
            "BENDING_ELEMENT" => IfcStructuralSurfaceMemberTypeEnum::BendingElement,
            "MEMBRANE_ELEMENT" => IfcStructuralSurfaceMemberTypeEnum::MembraneElement,
            "SHELL" => IfcStructuralSurfaceMemberTypeEnum::Shell,
            "USERDEFINED" => IfcStructuralSurfaceMemberTypeEnum::Userdefined,
            "NOTDEFINED" => IfcStructuralSurfaceMemberTypeEnum::Notdefined,
            _ => panic!("{} is not a valid value", value),
        }
    }
}
impl From<Parameter> for IfcStructuralSurfaceMemberTypeEnum {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EnumValue(value) => value.into(),
                _ => panic!("parameter is not an enum value"),
            },
            Parameter::OmittedParameter => IfcStructuralSurfaceMemberTypeEnum::default(),
            _ => panic!("parameter is not an enum value"),
        }
    }
}
#[derive(Eq, PartialEq, Hash, Debug)]
pub enum IfcSubContractResourceTypeEnum {
    Purchase,
    Work,
    Userdefined,
    Notdefined,
}
impl Default for IfcSubContractResourceTypeEnum {
    fn default() -> Self {
        IfcSubContractResourceTypeEnum::Purchase
    }
}
impl From<String> for IfcSubContractResourceTypeEnum {
    fn from(value: String) -> Self {
        match value.as_str() {
            "PURCHASE" => IfcSubContractResourceTypeEnum::Purchase,
            "WORK" => IfcSubContractResourceTypeEnum::Work,
            "USERDEFINED" => IfcSubContractResourceTypeEnum::Userdefined,
            "NOTDEFINED" => IfcSubContractResourceTypeEnum::Notdefined,
            _ => panic!("{} is not a valid value", value),
        }
    }
}
impl From<Parameter> for IfcSubContractResourceTypeEnum {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EnumValue(value) => value.into(),
                _ => panic!("parameter is not an enum value"),
            },
            Parameter::OmittedParameter => IfcSubContractResourceTypeEnum::default(),
            _ => panic!("parameter is not an enum value"),
        }
    }
}
#[derive(Eq, PartialEq, Hash, Debug)]
pub enum IfcSurfaceFeatureTypeEnum {
    Mark,
    Tag,
    Treatment,
    Userdefined,
    Notdefined,
}
impl Default for IfcSurfaceFeatureTypeEnum {
    fn default() -> Self {
        IfcSurfaceFeatureTypeEnum::Mark
    }
}
impl From<String> for IfcSurfaceFeatureTypeEnum {
    fn from(value: String) -> Self {
        match value.as_str() {
            "MARK" => IfcSurfaceFeatureTypeEnum::Mark,
            "TAG" => IfcSurfaceFeatureTypeEnum::Tag,
            "TREATMENT" => IfcSurfaceFeatureTypeEnum::Treatment,
            "USERDEFINED" => IfcSurfaceFeatureTypeEnum::Userdefined,
            "NOTDEFINED" => IfcSurfaceFeatureTypeEnum::Notdefined,
            _ => panic!("{} is not a valid value", value),
        }
    }
}
impl From<Parameter> for IfcSurfaceFeatureTypeEnum {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EnumValue(value) => value.into(),
                _ => panic!("parameter is not an enum value"),
            },
            Parameter::OmittedParameter => IfcSurfaceFeatureTypeEnum::default(),
            _ => panic!("parameter is not an enum value"),
        }
    }
}
#[derive(Eq, PartialEq, Hash, Debug)]
pub enum IfcSurfaceSide {
    Positive,
    Negative,
    Both,
}
impl Default for IfcSurfaceSide {
    fn default() -> Self {
        IfcSurfaceSide::Positive
    }
}
impl From<String> for IfcSurfaceSide {
    fn from(value: String) -> Self {
        match value.as_str() {
            "POSITIVE" => IfcSurfaceSide::Positive,
            "NEGATIVE" => IfcSurfaceSide::Negative,
            "BOTH" => IfcSurfaceSide::Both,
            _ => panic!("{} is not a valid value", value),
        }
    }
}
impl From<Parameter> for IfcSurfaceSide {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EnumValue(value) => value.into(),
                _ => panic!("parameter is not an enum value"),
            },
            Parameter::OmittedParameter => IfcSurfaceSide::default(),
            _ => panic!("parameter is not an enum value"),
        }
    }
}
#[derive(Eq, PartialEq, Hash, Debug)]
pub enum IfcSwitchingDeviceTypeEnum {
    Contactor,
    Dimmerswitch,
    Emergencystop,
    Keypad,
    Momentaryswitch,
    Selectorswitch,
    Starter,
    Switchdisconnector,
    Toggleswitch,
    Userdefined,
    Notdefined,
}
impl Default for IfcSwitchingDeviceTypeEnum {
    fn default() -> Self {
        IfcSwitchingDeviceTypeEnum::Contactor
    }
}
impl From<String> for IfcSwitchingDeviceTypeEnum {
    fn from(value: String) -> Self {
        match value.as_str() {
            "CONTACTOR" => IfcSwitchingDeviceTypeEnum::Contactor,
            "DIMMERSWITCH" => IfcSwitchingDeviceTypeEnum::Dimmerswitch,
            "EMERGENCYSTOP" => IfcSwitchingDeviceTypeEnum::Emergencystop,
            "KEYPAD" => IfcSwitchingDeviceTypeEnum::Keypad,
            "MOMENTARYSWITCH" => IfcSwitchingDeviceTypeEnum::Momentaryswitch,
            "SELECTORSWITCH" => IfcSwitchingDeviceTypeEnum::Selectorswitch,
            "STARTER" => IfcSwitchingDeviceTypeEnum::Starter,
            "SWITCHDISCONNECTOR" => IfcSwitchingDeviceTypeEnum::Switchdisconnector,
            "TOGGLESWITCH" => IfcSwitchingDeviceTypeEnum::Toggleswitch,
            "USERDEFINED" => IfcSwitchingDeviceTypeEnum::Userdefined,
            "NOTDEFINED" => IfcSwitchingDeviceTypeEnum::Notdefined,
            _ => panic!("{} is not a valid value", value),
        }
    }
}
impl From<Parameter> for IfcSwitchingDeviceTypeEnum {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EnumValue(value) => value.into(),
                _ => panic!("parameter is not an enum value"),
            },
            Parameter::OmittedParameter => IfcSwitchingDeviceTypeEnum::default(),
            _ => panic!("parameter is not an enum value"),
        }
    }
}
#[derive(Eq, PartialEq, Hash, Debug)]
pub enum IfcSystemFurnitureElementTypeEnum {
    Panel,
    Worksurface,
    Userdefined,
    Notdefined,
}
impl Default for IfcSystemFurnitureElementTypeEnum {
    fn default() -> Self {
        IfcSystemFurnitureElementTypeEnum::Panel
    }
}
impl From<String> for IfcSystemFurnitureElementTypeEnum {
    fn from(value: String) -> Self {
        match value.as_str() {
            "PANEL" => IfcSystemFurnitureElementTypeEnum::Panel,
            "WORKSURFACE" => IfcSystemFurnitureElementTypeEnum::Worksurface,
            "USERDEFINED" => IfcSystemFurnitureElementTypeEnum::Userdefined,
            "NOTDEFINED" => IfcSystemFurnitureElementTypeEnum::Notdefined,
            _ => panic!("{} is not a valid value", value),
        }
    }
}
impl From<Parameter> for IfcSystemFurnitureElementTypeEnum {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EnumValue(value) => value.into(),
                _ => panic!("parameter is not an enum value"),
            },
            Parameter::OmittedParameter => IfcSystemFurnitureElementTypeEnum::default(),
            _ => panic!("parameter is not an enum value"),
        }
    }
}
#[derive(Eq, PartialEq, Hash, Debug)]
pub enum IfcTankTypeEnum {
    Basin,
    Breakpressure,
    Expansion,
    Feedandexpansion,
    Pressurevessel,
    Storage,
    Vessel,
    Userdefined,
    Notdefined,
}
impl Default for IfcTankTypeEnum {
    fn default() -> Self {
        IfcTankTypeEnum::Basin
    }
}
impl From<String> for IfcTankTypeEnum {
    fn from(value: String) -> Self {
        match value.as_str() {
            "BASIN" => IfcTankTypeEnum::Basin,
            "BREAKPRESSURE" => IfcTankTypeEnum::Breakpressure,
            "EXPANSION" => IfcTankTypeEnum::Expansion,
            "FEEDANDEXPANSION" => IfcTankTypeEnum::Feedandexpansion,
            "PRESSUREVESSEL" => IfcTankTypeEnum::Pressurevessel,
            "STORAGE" => IfcTankTypeEnum::Storage,
            "VESSEL" => IfcTankTypeEnum::Vessel,
            "USERDEFINED" => IfcTankTypeEnum::Userdefined,
            "NOTDEFINED" => IfcTankTypeEnum::Notdefined,
            _ => panic!("{} is not a valid value", value),
        }
    }
}
impl From<Parameter> for IfcTankTypeEnum {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EnumValue(value) => value.into(),
                _ => panic!("parameter is not an enum value"),
            },
            Parameter::OmittedParameter => IfcTankTypeEnum::default(),
            _ => panic!("parameter is not an enum value"),
        }
    }
}
#[derive(Eq, PartialEq, Hash, Debug)]
pub enum IfcTaskDurationEnum {
    Elapsedtime,
    Worktime,
    Notdefined,
}
impl Default for IfcTaskDurationEnum {
    fn default() -> Self {
        IfcTaskDurationEnum::Elapsedtime
    }
}
impl From<String> for IfcTaskDurationEnum {
    fn from(value: String) -> Self {
        match value.as_str() {
            "ELAPSEDTIME" => IfcTaskDurationEnum::Elapsedtime,
            "WORKTIME" => IfcTaskDurationEnum::Worktime,
            "NOTDEFINED" => IfcTaskDurationEnum::Notdefined,
            _ => panic!("{} is not a valid value", value),
        }
    }
}
impl From<Parameter> for IfcTaskDurationEnum {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EnumValue(value) => value.into(),
                _ => panic!("parameter is not an enum value"),
            },
            Parameter::OmittedParameter => IfcTaskDurationEnum::default(),
            _ => panic!("parameter is not an enum value"),
        }
    }
}
#[derive(Eq, PartialEq, Hash, Debug)]
pub enum IfcTaskTypeEnum {
    Attendance,
    Construction,
    Demolition,
    Dismantle,
    Disposal,
    Installation,
    Logistic,
    Maintenance,
    Move,
    Operation,
    Removal,
    Renovation,
    Userdefined,
    Notdefined,
}
impl Default for IfcTaskTypeEnum {
    fn default() -> Self {
        IfcTaskTypeEnum::Attendance
    }
}
impl From<String> for IfcTaskTypeEnum {
    fn from(value: String) -> Self {
        match value.as_str() {
            "ATTENDANCE" => IfcTaskTypeEnum::Attendance,
            "CONSTRUCTION" => IfcTaskTypeEnum::Construction,
            "DEMOLITION" => IfcTaskTypeEnum::Demolition,
            "DISMANTLE" => IfcTaskTypeEnum::Dismantle,
            "DISPOSAL" => IfcTaskTypeEnum::Disposal,
            "INSTALLATION" => IfcTaskTypeEnum::Installation,
            "LOGISTIC" => IfcTaskTypeEnum::Logistic,
            "MAINTENANCE" => IfcTaskTypeEnum::Maintenance,
            "MOVE" => IfcTaskTypeEnum::Move,
            "OPERATION" => IfcTaskTypeEnum::Operation,
            "REMOVAL" => IfcTaskTypeEnum::Removal,
            "RENOVATION" => IfcTaskTypeEnum::Renovation,
            "USERDEFINED" => IfcTaskTypeEnum::Userdefined,
            "NOTDEFINED" => IfcTaskTypeEnum::Notdefined,
            _ => panic!("{} is not a valid value", value),
        }
    }
}
impl From<Parameter> for IfcTaskTypeEnum {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EnumValue(value) => value.into(),
                _ => panic!("parameter is not an enum value"),
            },
            Parameter::OmittedParameter => IfcTaskTypeEnum::default(),
            _ => panic!("parameter is not an enum value"),
        }
    }
}
#[derive(Eq, PartialEq, Hash, Debug)]
pub enum IfcTendonAnchorTypeEnum {
    Coupler,
    FixedEnd,
    TensioningEnd,
    Userdefined,
    Notdefined,
}
impl Default for IfcTendonAnchorTypeEnum {
    fn default() -> Self {
        IfcTendonAnchorTypeEnum::Coupler
    }
}
impl From<String> for IfcTendonAnchorTypeEnum {
    fn from(value: String) -> Self {
        match value.as_str() {
            "COUPLER" => IfcTendonAnchorTypeEnum::Coupler,
            "FIXED_END" => IfcTendonAnchorTypeEnum::FixedEnd,
            "TENSIONING_END" => IfcTendonAnchorTypeEnum::TensioningEnd,
            "USERDEFINED" => IfcTendonAnchorTypeEnum::Userdefined,
            "NOTDEFINED" => IfcTendonAnchorTypeEnum::Notdefined,
            _ => panic!("{} is not a valid value", value),
        }
    }
}
impl From<Parameter> for IfcTendonAnchorTypeEnum {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EnumValue(value) => value.into(),
                _ => panic!("parameter is not an enum value"),
            },
            Parameter::OmittedParameter => IfcTendonAnchorTypeEnum::default(),
            _ => panic!("parameter is not an enum value"),
        }
    }
}
#[derive(Eq, PartialEq, Hash, Debug)]
pub enum IfcTendonTypeEnum {
    Bar,
    Coated,
    Strand,
    Wire,
    Userdefined,
    Notdefined,
}
impl Default for IfcTendonTypeEnum {
    fn default() -> Self {
        IfcTendonTypeEnum::Bar
    }
}
impl From<String> for IfcTendonTypeEnum {
    fn from(value: String) -> Self {
        match value.as_str() {
            "BAR" => IfcTendonTypeEnum::Bar,
            "COATED" => IfcTendonTypeEnum::Coated,
            "STRAND" => IfcTendonTypeEnum::Strand,
            "WIRE" => IfcTendonTypeEnum::Wire,
            "USERDEFINED" => IfcTendonTypeEnum::Userdefined,
            "NOTDEFINED" => IfcTendonTypeEnum::Notdefined,
            _ => panic!("{} is not a valid value", value),
        }
    }
}
impl From<Parameter> for IfcTendonTypeEnum {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EnumValue(value) => value.into(),
                _ => panic!("parameter is not an enum value"),
            },
            Parameter::OmittedParameter => IfcTendonTypeEnum::default(),
            _ => panic!("parameter is not an enum value"),
        }
    }
}
#[derive(Eq, PartialEq, Hash, Debug)]
pub enum IfcTextPath {
    Left,
    Right,
    Up,
    Down,
}
impl Default for IfcTextPath {
    fn default() -> Self {
        IfcTextPath::Left
    }
}
impl From<String> for IfcTextPath {
    fn from(value: String) -> Self {
        match value.as_str() {
            "LEFT" => IfcTextPath::Left,
            "RIGHT" => IfcTextPath::Right,
            "UP" => IfcTextPath::Up,
            "DOWN" => IfcTextPath::Down,
            _ => panic!("{} is not a valid value", value),
        }
    }
}
impl From<Parameter> for IfcTextPath {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EnumValue(value) => value.into(),
                _ => panic!("parameter is not an enum value"),
            },
            Parameter::OmittedParameter => IfcTextPath::default(),
            _ => panic!("parameter is not an enum value"),
        }
    }
}
#[derive(Eq, PartialEq, Hash, Debug)]
pub enum IfcTimeSeriesDataTypeEnum {
    Continuous,
    Discrete,
    Discretebinary,
    Piecewisebinary,
    Piecewiseconstant,
    Piecewisecontinuous,
    Notdefined,
}
impl Default for IfcTimeSeriesDataTypeEnum {
    fn default() -> Self {
        IfcTimeSeriesDataTypeEnum::Continuous
    }
}
impl From<String> for IfcTimeSeriesDataTypeEnum {
    fn from(value: String) -> Self {
        match value.as_str() {
            "CONTINUOUS" => IfcTimeSeriesDataTypeEnum::Continuous,
            "DISCRETE" => IfcTimeSeriesDataTypeEnum::Discrete,
            "DISCRETEBINARY" => IfcTimeSeriesDataTypeEnum::Discretebinary,
            "PIECEWISEBINARY" => IfcTimeSeriesDataTypeEnum::Piecewisebinary,
            "PIECEWISECONSTANT" => IfcTimeSeriesDataTypeEnum::Piecewiseconstant,
            "PIECEWISECONTINUOUS" => IfcTimeSeriesDataTypeEnum::Piecewisecontinuous,
            "NOTDEFINED" => IfcTimeSeriesDataTypeEnum::Notdefined,
            _ => panic!("{} is not a valid value", value),
        }
    }
}
impl From<Parameter> for IfcTimeSeriesDataTypeEnum {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EnumValue(value) => value.into(),
                _ => panic!("parameter is not an enum value"),
            },
            Parameter::OmittedParameter => IfcTimeSeriesDataTypeEnum::default(),
            _ => panic!("parameter is not an enum value"),
        }
    }
}
#[derive(Eq, PartialEq, Hash, Debug)]
pub enum IfcTransformerTypeEnum {
    Current,
    Frequency,
    Inverter,
    Rectifier,
    Voltage,
    Userdefined,
    Notdefined,
}
impl Default for IfcTransformerTypeEnum {
    fn default() -> Self {
        IfcTransformerTypeEnum::Current
    }
}
impl From<String> for IfcTransformerTypeEnum {
    fn from(value: String) -> Self {
        match value.as_str() {
            "CURRENT" => IfcTransformerTypeEnum::Current,
            "FREQUENCY" => IfcTransformerTypeEnum::Frequency,
            "INVERTER" => IfcTransformerTypeEnum::Inverter,
            "RECTIFIER" => IfcTransformerTypeEnum::Rectifier,
            "VOLTAGE" => IfcTransformerTypeEnum::Voltage,
            "USERDEFINED" => IfcTransformerTypeEnum::Userdefined,
            "NOTDEFINED" => IfcTransformerTypeEnum::Notdefined,
            _ => panic!("{} is not a valid value", value),
        }
    }
}
impl From<Parameter> for IfcTransformerTypeEnum {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EnumValue(value) => value.into(),
                _ => panic!("parameter is not an enum value"),
            },
            Parameter::OmittedParameter => IfcTransformerTypeEnum::default(),
            _ => panic!("parameter is not an enum value"),
        }
    }
}
#[derive(Eq, PartialEq, Hash, Debug)]
pub enum IfcTransitionCode {
    Discontinuous,
    Continuous,
    Contsamegradient,
    Contsamegradientsamecurvature,
}
impl Default for IfcTransitionCode {
    fn default() -> Self {
        IfcTransitionCode::Discontinuous
    }
}
impl From<String> for IfcTransitionCode {
    fn from(value: String) -> Self {
        match value.as_str() {
            "DISCONTINUOUS" => IfcTransitionCode::Discontinuous,
            "CONTINUOUS" => IfcTransitionCode::Continuous,
            "CONTSAMEGRADIENT" => IfcTransitionCode::Contsamegradient,
            "CONTSAMEGRADIENTSAMECURVATURE" => IfcTransitionCode::Contsamegradientsamecurvature,
            _ => panic!("{} is not a valid value", value),
        }
    }
}
impl From<Parameter> for IfcTransitionCode {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EnumValue(value) => value.into(),
                _ => panic!("parameter is not an enum value"),
            },
            Parameter::OmittedParameter => IfcTransitionCode::default(),
            _ => panic!("parameter is not an enum value"),
        }
    }
}
#[derive(Eq, PartialEq, Hash, Debug)]
pub enum IfcTransportElementTypeEnum {
    Elevator,
    Escalator,
    Movingwalkway,
    Craneway,
    Liftinggear,
    Userdefined,
    Notdefined,
}
impl Default for IfcTransportElementTypeEnum {
    fn default() -> Self {
        IfcTransportElementTypeEnum::Elevator
    }
}
impl From<String> for IfcTransportElementTypeEnum {
    fn from(value: String) -> Self {
        match value.as_str() {
            "ELEVATOR" => IfcTransportElementTypeEnum::Elevator,
            "ESCALATOR" => IfcTransportElementTypeEnum::Escalator,
            "MOVINGWALKWAY" => IfcTransportElementTypeEnum::Movingwalkway,
            "CRANEWAY" => IfcTransportElementTypeEnum::Craneway,
            "LIFTINGGEAR" => IfcTransportElementTypeEnum::Liftinggear,
            "USERDEFINED" => IfcTransportElementTypeEnum::Userdefined,
            "NOTDEFINED" => IfcTransportElementTypeEnum::Notdefined,
            _ => panic!("{} is not a valid value", value),
        }
    }
}
impl From<Parameter> for IfcTransportElementTypeEnum {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EnumValue(value) => value.into(),
                _ => panic!("parameter is not an enum value"),
            },
            Parameter::OmittedParameter => IfcTransportElementTypeEnum::default(),
            _ => panic!("parameter is not an enum value"),
        }
    }
}
#[derive(Eq, PartialEq, Hash, Debug)]
pub enum IfcTrimmingPreference {
    Cartesian,
    Parameter,
    Unspecified,
}
impl Default for IfcTrimmingPreference {
    fn default() -> Self {
        IfcTrimmingPreference::Cartesian
    }
}
impl From<String> for IfcTrimmingPreference {
    fn from(value: String) -> Self {
        match value.as_str() {
            "CARTESIAN" => IfcTrimmingPreference::Cartesian,
            "PARAMETER" => IfcTrimmingPreference::Parameter,
            "UNSPECIFIED" => IfcTrimmingPreference::Unspecified,
            _ => panic!("{} is not a valid value", value),
        }
    }
}
impl From<Parameter> for IfcTrimmingPreference {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EnumValue(value) => value.into(),
                _ => panic!("parameter is not an enum value"),
            },
            Parameter::OmittedParameter => IfcTrimmingPreference::default(),
            _ => panic!("parameter is not an enum value"),
        }
    }
}
#[derive(Eq, PartialEq, Hash, Debug)]
pub enum IfcTubeBundleTypeEnum {
    Finned,
    Userdefined,
    Notdefined,
}
impl Default for IfcTubeBundleTypeEnum {
    fn default() -> Self {
        IfcTubeBundleTypeEnum::Finned
    }
}
impl From<String> for IfcTubeBundleTypeEnum {
    fn from(value: String) -> Self {
        match value.as_str() {
            "FINNED" => IfcTubeBundleTypeEnum::Finned,
            "USERDEFINED" => IfcTubeBundleTypeEnum::Userdefined,
            "NOTDEFINED" => IfcTubeBundleTypeEnum::Notdefined,
            _ => panic!("{} is not a valid value", value),
        }
    }
}
impl From<Parameter> for IfcTubeBundleTypeEnum {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EnumValue(value) => value.into(),
                _ => panic!("parameter is not an enum value"),
            },
            Parameter::OmittedParameter => IfcTubeBundleTypeEnum::default(),
            _ => panic!("parameter is not an enum value"),
        }
    }
}
#[derive(Eq, PartialEq, Hash, Debug)]
pub enum IfcUnitEnum {
    Absorbeddoseunit,
    Amountofsubstanceunit,
    Areaunit,
    Doseequivalentunit,
    Electriccapacitanceunit,
    Electricchargeunit,
    Electricconductanceunit,
    Electriccurrentunit,
    Electricresistanceunit,
    Electricvoltageunit,
    Energyunit,
    Forceunit,
    Frequencyunit,
    Illuminanceunit,
    Inductanceunit,
    Lengthunit,
    Luminousfluxunit,
    Luminousintensityunit,
    Magneticfluxdensityunit,
    Magneticfluxunit,
    Massunit,
    Planeangleunit,
    Powerunit,
    Pressureunit,
    Radioactivityunit,
    Solidangleunit,
    Thermodynamictemperatureunit,
    Timeunit,
    Volumeunit,
    Userdefined,
}
impl Default for IfcUnitEnum {
    fn default() -> Self {
        IfcUnitEnum::Absorbeddoseunit
    }
}
impl From<String> for IfcUnitEnum {
    fn from(value: String) -> Self {
        match value.as_str() {
            "ABSORBEDDOSEUNIT" => IfcUnitEnum::Absorbeddoseunit,
            "AMOUNTOFSUBSTANCEUNIT" => IfcUnitEnum::Amountofsubstanceunit,
            "AREAUNIT" => IfcUnitEnum::Areaunit,
            "DOSEEQUIVALENTUNIT" => IfcUnitEnum::Doseequivalentunit,
            "ELECTRICCAPACITANCEUNIT" => IfcUnitEnum::Electriccapacitanceunit,
            "ELECTRICCHARGEUNIT" => IfcUnitEnum::Electricchargeunit,
            "ELECTRICCONDUCTANCEUNIT" => IfcUnitEnum::Electricconductanceunit,
            "ELECTRICCURRENTUNIT" => IfcUnitEnum::Electriccurrentunit,
            "ELECTRICRESISTANCEUNIT" => IfcUnitEnum::Electricresistanceunit,
            "ELECTRICVOLTAGEUNIT" => IfcUnitEnum::Electricvoltageunit,
            "ENERGYUNIT" => IfcUnitEnum::Energyunit,
            "FORCEUNIT" => IfcUnitEnum::Forceunit,
            "FREQUENCYUNIT" => IfcUnitEnum::Frequencyunit,
            "ILLUMINANCEUNIT" => IfcUnitEnum::Illuminanceunit,
            "INDUCTANCEUNIT" => IfcUnitEnum::Inductanceunit,
            "LENGTHUNIT" => IfcUnitEnum::Lengthunit,
            "LUMINOUSFLUXUNIT" => IfcUnitEnum::Luminousfluxunit,
            "LUMINOUSINTENSITYUNIT" => IfcUnitEnum::Luminousintensityunit,
            "MAGNETICFLUXDENSITYUNIT" => IfcUnitEnum::Magneticfluxdensityunit,
            "MAGNETICFLUXUNIT" => IfcUnitEnum::Magneticfluxunit,
            "MASSUNIT" => IfcUnitEnum::Massunit,
            "PLANEANGLEUNIT" => IfcUnitEnum::Planeangleunit,
            "POWERUNIT" => IfcUnitEnum::Powerunit,
            "PRESSUREUNIT" => IfcUnitEnum::Pressureunit,
            "RADIOACTIVITYUNIT" => IfcUnitEnum::Radioactivityunit,
            "SOLIDANGLEUNIT" => IfcUnitEnum::Solidangleunit,
            "THERMODYNAMICTEMPERATUREUNIT" => IfcUnitEnum::Thermodynamictemperatureunit,
            "TIMEUNIT" => IfcUnitEnum::Timeunit,
            "VOLUMEUNIT" => IfcUnitEnum::Volumeunit,
            "USERDEFINED" => IfcUnitEnum::Userdefined,
            _ => panic!("{} is not a valid value", value),
        }
    }
}
impl From<Parameter> for IfcUnitEnum {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EnumValue(value) => value.into(),
                _ => panic!("parameter is not an enum value"),
            },
            Parameter::OmittedParameter => IfcUnitEnum::default(),
            _ => panic!("parameter is not an enum value"),
        }
    }
}
#[derive(Eq, PartialEq, Hash, Debug)]
pub enum IfcUnitaryControlElementTypeEnum {
    Alarmpanel,
    Controlpanel,
    Gasdetectionpanel,
    Indicatorpanel,
    Mimicpanel,
    Humidistat,
    Thermostat,
    Weatherstation,
    Userdefined,
    Notdefined,
}
impl Default for IfcUnitaryControlElementTypeEnum {
    fn default() -> Self {
        IfcUnitaryControlElementTypeEnum::Alarmpanel
    }
}
impl From<String> for IfcUnitaryControlElementTypeEnum {
    fn from(value: String) -> Self {
        match value.as_str() {
            "ALARMPANEL" => IfcUnitaryControlElementTypeEnum::Alarmpanel,
            "CONTROLPANEL" => IfcUnitaryControlElementTypeEnum::Controlpanel,
            "GASDETECTIONPANEL" => IfcUnitaryControlElementTypeEnum::Gasdetectionpanel,
            "INDICATORPANEL" => IfcUnitaryControlElementTypeEnum::Indicatorpanel,
            "MIMICPANEL" => IfcUnitaryControlElementTypeEnum::Mimicpanel,
            "HUMIDISTAT" => IfcUnitaryControlElementTypeEnum::Humidistat,
            "THERMOSTAT" => IfcUnitaryControlElementTypeEnum::Thermostat,
            "WEATHERSTATION" => IfcUnitaryControlElementTypeEnum::Weatherstation,
            "USERDEFINED" => IfcUnitaryControlElementTypeEnum::Userdefined,
            "NOTDEFINED" => IfcUnitaryControlElementTypeEnum::Notdefined,
            _ => panic!("{} is not a valid value", value),
        }
    }
}
impl From<Parameter> for IfcUnitaryControlElementTypeEnum {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EnumValue(value) => value.into(),
                _ => panic!("parameter is not an enum value"),
            },
            Parameter::OmittedParameter => IfcUnitaryControlElementTypeEnum::default(),
            _ => panic!("parameter is not an enum value"),
        }
    }
}
#[derive(Eq, PartialEq, Hash, Debug)]
pub enum IfcUnitaryEquipmentTypeEnum {
    Airhandler,
    Airconditioningunit,
    Dehumidifier,
    Splitsystem,
    Rooftopunit,
    Userdefined,
    Notdefined,
}
impl Default for IfcUnitaryEquipmentTypeEnum {
    fn default() -> Self {
        IfcUnitaryEquipmentTypeEnum::Airhandler
    }
}
impl From<String> for IfcUnitaryEquipmentTypeEnum {
    fn from(value: String) -> Self {
        match value.as_str() {
            "AIRHANDLER" => IfcUnitaryEquipmentTypeEnum::Airhandler,
            "AIRCONDITIONINGUNIT" => IfcUnitaryEquipmentTypeEnum::Airconditioningunit,
            "DEHUMIDIFIER" => IfcUnitaryEquipmentTypeEnum::Dehumidifier,
            "SPLITSYSTEM" => IfcUnitaryEquipmentTypeEnum::Splitsystem,
            "ROOFTOPUNIT" => IfcUnitaryEquipmentTypeEnum::Rooftopunit,
            "USERDEFINED" => IfcUnitaryEquipmentTypeEnum::Userdefined,
            "NOTDEFINED" => IfcUnitaryEquipmentTypeEnum::Notdefined,
            _ => panic!("{} is not a valid value", value),
        }
    }
}
impl From<Parameter> for IfcUnitaryEquipmentTypeEnum {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EnumValue(value) => value.into(),
                _ => panic!("parameter is not an enum value"),
            },
            Parameter::OmittedParameter => IfcUnitaryEquipmentTypeEnum::default(),
            _ => panic!("parameter is not an enum value"),
        }
    }
}
#[derive(Eq, PartialEq, Hash, Debug)]
pub enum IfcValveTypeEnum {
    Airrelease,
    Antivacuum,
    Changeover,
    Check,
    Commissioning,
    Diverting,
    Drawoffcock,
    Doublecheck,
    Doubleregulating,
    Faucet,
    Flushing,
    Gascock,
    Gastap,
    Isolating,
    Mixing,
    Pressurereducing,
    Pressurerelief,
    Regulating,
    Safetycutoff,
    Steamtrap,
    Stopcock,
    Userdefined,
    Notdefined,
}
impl Default for IfcValveTypeEnum {
    fn default() -> Self {
        IfcValveTypeEnum::Airrelease
    }
}
impl From<String> for IfcValveTypeEnum {
    fn from(value: String) -> Self {
        match value.as_str() {
            "AIRRELEASE" => IfcValveTypeEnum::Airrelease,
            "ANTIVACUUM" => IfcValveTypeEnum::Antivacuum,
            "CHANGEOVER" => IfcValveTypeEnum::Changeover,
            "CHECK" => IfcValveTypeEnum::Check,
            "COMMISSIONING" => IfcValveTypeEnum::Commissioning,
            "DIVERTING" => IfcValveTypeEnum::Diverting,
            "DRAWOFFCOCK" => IfcValveTypeEnum::Drawoffcock,
            "DOUBLECHECK" => IfcValveTypeEnum::Doublecheck,
            "DOUBLEREGULATING" => IfcValveTypeEnum::Doubleregulating,
            "FAUCET" => IfcValveTypeEnum::Faucet,
            "FLUSHING" => IfcValveTypeEnum::Flushing,
            "GASCOCK" => IfcValveTypeEnum::Gascock,
            "GASTAP" => IfcValveTypeEnum::Gastap,
            "ISOLATING" => IfcValveTypeEnum::Isolating,
            "MIXING" => IfcValveTypeEnum::Mixing,
            "PRESSUREREDUCING" => IfcValveTypeEnum::Pressurereducing,
            "PRESSURERELIEF" => IfcValveTypeEnum::Pressurerelief,
            "REGULATING" => IfcValveTypeEnum::Regulating,
            "SAFETYCUTOFF" => IfcValveTypeEnum::Safetycutoff,
            "STEAMTRAP" => IfcValveTypeEnum::Steamtrap,
            "STOPCOCK" => IfcValveTypeEnum::Stopcock,
            "USERDEFINED" => IfcValveTypeEnum::Userdefined,
            "NOTDEFINED" => IfcValveTypeEnum::Notdefined,
            _ => panic!("{} is not a valid value", value),
        }
    }
}
impl From<Parameter> for IfcValveTypeEnum {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EnumValue(value) => value.into(),
                _ => panic!("parameter is not an enum value"),
            },
            Parameter::OmittedParameter => IfcValveTypeEnum::default(),
            _ => panic!("parameter is not an enum value"),
        }
    }
}
#[derive(Eq, PartialEq, Hash, Debug)]
pub enum IfcVibrationIsolatorTypeEnum {
    Compression,
    Spring,
    Userdefined,
    Notdefined,
}
impl Default for IfcVibrationIsolatorTypeEnum {
    fn default() -> Self {
        IfcVibrationIsolatorTypeEnum::Compression
    }
}
impl From<String> for IfcVibrationIsolatorTypeEnum {
    fn from(value: String) -> Self {
        match value.as_str() {
            "COMPRESSION" => IfcVibrationIsolatorTypeEnum::Compression,
            "SPRING" => IfcVibrationIsolatorTypeEnum::Spring,
            "USERDEFINED" => IfcVibrationIsolatorTypeEnum::Userdefined,
            "NOTDEFINED" => IfcVibrationIsolatorTypeEnum::Notdefined,
            _ => panic!("{} is not a valid value", value),
        }
    }
}
impl From<Parameter> for IfcVibrationIsolatorTypeEnum {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EnumValue(value) => value.into(),
                _ => panic!("parameter is not an enum value"),
            },
            Parameter::OmittedParameter => IfcVibrationIsolatorTypeEnum::default(),
            _ => panic!("parameter is not an enum value"),
        }
    }
}
#[derive(Eq, PartialEq, Hash, Debug)]
pub enum IfcVoidingFeatureTypeEnum {
    Cutout,
    Notch,
    Hole,
    Miter,
    Chamfer,
    Edge,
    Userdefined,
    Notdefined,
}
impl Default for IfcVoidingFeatureTypeEnum {
    fn default() -> Self {
        IfcVoidingFeatureTypeEnum::Cutout
    }
}
impl From<String> for IfcVoidingFeatureTypeEnum {
    fn from(value: String) -> Self {
        match value.as_str() {
            "CUTOUT" => IfcVoidingFeatureTypeEnum::Cutout,
            "NOTCH" => IfcVoidingFeatureTypeEnum::Notch,
            "HOLE" => IfcVoidingFeatureTypeEnum::Hole,
            "MITER" => IfcVoidingFeatureTypeEnum::Miter,
            "CHAMFER" => IfcVoidingFeatureTypeEnum::Chamfer,
            "EDGE" => IfcVoidingFeatureTypeEnum::Edge,
            "USERDEFINED" => IfcVoidingFeatureTypeEnum::Userdefined,
            "NOTDEFINED" => IfcVoidingFeatureTypeEnum::Notdefined,
            _ => panic!("{} is not a valid value", value),
        }
    }
}
impl From<Parameter> for IfcVoidingFeatureTypeEnum {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EnumValue(value) => value.into(),
                _ => panic!("parameter is not an enum value"),
            },
            Parameter::OmittedParameter => IfcVoidingFeatureTypeEnum::default(),
            _ => panic!("parameter is not an enum value"),
        }
    }
}
#[derive(Eq, PartialEq, Hash, Debug)]
pub enum IfcWallTypeEnum {
    Movable,
    Parapet,
    Partitioning,
    Plumbingwall,
    Shear,
    Solidwall,
    Standard,
    Polygonal,
    Elementedwall,
    Userdefined,
    Notdefined,
}
impl Default for IfcWallTypeEnum {
    fn default() -> Self {
        IfcWallTypeEnum::Movable
    }
}
impl From<String> for IfcWallTypeEnum {
    fn from(value: String) -> Self {
        match value.as_str() {
            "MOVABLE" => IfcWallTypeEnum::Movable,
            "PARAPET" => IfcWallTypeEnum::Parapet,
            "PARTITIONING" => IfcWallTypeEnum::Partitioning,
            "PLUMBINGWALL" => IfcWallTypeEnum::Plumbingwall,
            "SHEAR" => IfcWallTypeEnum::Shear,
            "SOLIDWALL" => IfcWallTypeEnum::Solidwall,
            "STANDARD" => IfcWallTypeEnum::Standard,
            "POLYGONAL" => IfcWallTypeEnum::Polygonal,
            "ELEMENTEDWALL" => IfcWallTypeEnum::Elementedwall,
            "USERDEFINED" => IfcWallTypeEnum::Userdefined,
            "NOTDEFINED" => IfcWallTypeEnum::Notdefined,
            _ => panic!("{} is not a valid value", value),
        }
    }
}
impl From<Parameter> for IfcWallTypeEnum {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EnumValue(value) => value.into(),
                _ => panic!("parameter is not an enum value"),
            },
            Parameter::OmittedParameter => IfcWallTypeEnum::default(),
            _ => panic!("parameter is not an enum value"),
        }
    }
}
#[derive(Eq, PartialEq, Hash, Debug)]
pub enum IfcWasteTerminalTypeEnum {
    Floortrap,
    Floorwaste,
    Gullysump,
    Gullytrap,
    Roofdrain,
    Wastedisposalunit,
    Wastetrap,
    Userdefined,
    Notdefined,
}
impl Default for IfcWasteTerminalTypeEnum {
    fn default() -> Self {
        IfcWasteTerminalTypeEnum::Floortrap
    }
}
impl From<String> for IfcWasteTerminalTypeEnum {
    fn from(value: String) -> Self {
        match value.as_str() {
            "FLOORTRAP" => IfcWasteTerminalTypeEnum::Floortrap,
            "FLOORWASTE" => IfcWasteTerminalTypeEnum::Floorwaste,
            "GULLYSUMP" => IfcWasteTerminalTypeEnum::Gullysump,
            "GULLYTRAP" => IfcWasteTerminalTypeEnum::Gullytrap,
            "ROOFDRAIN" => IfcWasteTerminalTypeEnum::Roofdrain,
            "WASTEDISPOSALUNIT" => IfcWasteTerminalTypeEnum::Wastedisposalunit,
            "WASTETRAP" => IfcWasteTerminalTypeEnum::Wastetrap,
            "USERDEFINED" => IfcWasteTerminalTypeEnum::Userdefined,
            "NOTDEFINED" => IfcWasteTerminalTypeEnum::Notdefined,
            _ => panic!("{} is not a valid value", value),
        }
    }
}
impl From<Parameter> for IfcWasteTerminalTypeEnum {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EnumValue(value) => value.into(),
                _ => panic!("parameter is not an enum value"),
            },
            Parameter::OmittedParameter => IfcWasteTerminalTypeEnum::default(),
            _ => panic!("parameter is not an enum value"),
        }
    }
}
#[derive(Eq, PartialEq, Hash, Debug)]
pub enum IfcWindowPanelOperationEnum {
    Sidehungrighthand,
    Sidehunglefthand,
    Tiltandturnrighthand,
    Tiltandturnlefthand,
    Tophung,
    Bottomhung,
    Pivothorizontal,
    Pivotvertical,
    Slidinghorizontal,
    Slidingvertical,
    Removablecasement,
    Fixedcasement,
    Otheroperation,
    Notdefined,
}
impl Default for IfcWindowPanelOperationEnum {
    fn default() -> Self {
        IfcWindowPanelOperationEnum::Sidehungrighthand
    }
}
impl From<String> for IfcWindowPanelOperationEnum {
    fn from(value: String) -> Self {
        match value.as_str() {
            "SIDEHUNGRIGHTHAND" => IfcWindowPanelOperationEnum::Sidehungrighthand,
            "SIDEHUNGLEFTHAND" => IfcWindowPanelOperationEnum::Sidehunglefthand,
            "TILTANDTURNRIGHTHAND" => IfcWindowPanelOperationEnum::Tiltandturnrighthand,
            "TILTANDTURNLEFTHAND" => IfcWindowPanelOperationEnum::Tiltandturnlefthand,
            "TOPHUNG" => IfcWindowPanelOperationEnum::Tophung,
            "BOTTOMHUNG" => IfcWindowPanelOperationEnum::Bottomhung,
            "PIVOTHORIZONTAL" => IfcWindowPanelOperationEnum::Pivothorizontal,
            "PIVOTVERTICAL" => IfcWindowPanelOperationEnum::Pivotvertical,
            "SLIDINGHORIZONTAL" => IfcWindowPanelOperationEnum::Slidinghorizontal,
            "SLIDINGVERTICAL" => IfcWindowPanelOperationEnum::Slidingvertical,
            "REMOVABLECASEMENT" => IfcWindowPanelOperationEnum::Removablecasement,
            "FIXEDCASEMENT" => IfcWindowPanelOperationEnum::Fixedcasement,
            "OTHEROPERATION" => IfcWindowPanelOperationEnum::Otheroperation,
            "NOTDEFINED" => IfcWindowPanelOperationEnum::Notdefined,
            _ => panic!("{} is not a valid value", value),
        }
    }
}
impl From<Parameter> for IfcWindowPanelOperationEnum {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EnumValue(value) => value.into(),
                _ => panic!("parameter is not an enum value"),
            },
            Parameter::OmittedParameter => IfcWindowPanelOperationEnum::default(),
            _ => panic!("parameter is not an enum value"),
        }
    }
}
#[derive(Eq, PartialEq, Hash, Debug)]
pub enum IfcWindowPanelPositionEnum {
    Left,
    Middle,
    Right,
    Bottom,
    Top,
    Notdefined,
}
impl Default for IfcWindowPanelPositionEnum {
    fn default() -> Self {
        IfcWindowPanelPositionEnum::Left
    }
}
impl From<String> for IfcWindowPanelPositionEnum {
    fn from(value: String) -> Self {
        match value.as_str() {
            "LEFT" => IfcWindowPanelPositionEnum::Left,
            "MIDDLE" => IfcWindowPanelPositionEnum::Middle,
            "RIGHT" => IfcWindowPanelPositionEnum::Right,
            "BOTTOM" => IfcWindowPanelPositionEnum::Bottom,
            "TOP" => IfcWindowPanelPositionEnum::Top,
            "NOTDEFINED" => IfcWindowPanelPositionEnum::Notdefined,
            _ => panic!("{} is not a valid value", value),
        }
    }
}
impl From<Parameter> for IfcWindowPanelPositionEnum {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EnumValue(value) => value.into(),
                _ => panic!("parameter is not an enum value"),
            },
            Parameter::OmittedParameter => IfcWindowPanelPositionEnum::default(),
            _ => panic!("parameter is not an enum value"),
        }
    }
}
#[derive(Eq, PartialEq, Hash, Debug)]
pub enum IfcWindowStyleConstructionEnum {
    Aluminium,
    HighGradeSteel,
    Steel,
    Wood,
    AluminiumWood,
    Plastic,
    OtherConstruction,
    Notdefined,
}
impl Default for IfcWindowStyleConstructionEnum {
    fn default() -> Self {
        IfcWindowStyleConstructionEnum::Aluminium
    }
}
impl From<String> for IfcWindowStyleConstructionEnum {
    fn from(value: String) -> Self {
        match value.as_str() {
            "ALUMINIUM" => IfcWindowStyleConstructionEnum::Aluminium,
            "HIGH_GRADE_STEEL" => IfcWindowStyleConstructionEnum::HighGradeSteel,
            "STEEL" => IfcWindowStyleConstructionEnum::Steel,
            "WOOD" => IfcWindowStyleConstructionEnum::Wood,
            "ALUMINIUM_WOOD" => IfcWindowStyleConstructionEnum::AluminiumWood,
            "PLASTIC" => IfcWindowStyleConstructionEnum::Plastic,
            "OTHER_CONSTRUCTION" => IfcWindowStyleConstructionEnum::OtherConstruction,
            "NOTDEFINED" => IfcWindowStyleConstructionEnum::Notdefined,
            _ => panic!("{} is not a valid value", value),
        }
    }
}
impl From<Parameter> for IfcWindowStyleConstructionEnum {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EnumValue(value) => value.into(),
                _ => panic!("parameter is not an enum value"),
            },
            Parameter::OmittedParameter => IfcWindowStyleConstructionEnum::default(),
            _ => panic!("parameter is not an enum value"),
        }
    }
}
#[derive(Eq, PartialEq, Hash, Debug)]
pub enum IfcWindowStyleOperationEnum {
    SinglePanel,
    DoublePanelVertical,
    DoublePanelHorizontal,
    TriplePanelVertical,
    TriplePanelBottom,
    TriplePanelTop,
    TriplePanelLeft,
    TriplePanelRight,
    TriplePanelHorizontal,
    Userdefined,
    Notdefined,
}
impl Default for IfcWindowStyleOperationEnum {
    fn default() -> Self {
        IfcWindowStyleOperationEnum::SinglePanel
    }
}
impl From<String> for IfcWindowStyleOperationEnum {
    fn from(value: String) -> Self {
        match value.as_str() {
            "SINGLE_PANEL" => IfcWindowStyleOperationEnum::SinglePanel,
            "DOUBLE_PANEL_VERTICAL" => IfcWindowStyleOperationEnum::DoublePanelVertical,
            "DOUBLE_PANEL_HORIZONTAL" => IfcWindowStyleOperationEnum::DoublePanelHorizontal,
            "TRIPLE_PANEL_VERTICAL" => IfcWindowStyleOperationEnum::TriplePanelVertical,
            "TRIPLE_PANEL_BOTTOM" => IfcWindowStyleOperationEnum::TriplePanelBottom,
            "TRIPLE_PANEL_TOP" => IfcWindowStyleOperationEnum::TriplePanelTop,
            "TRIPLE_PANEL_LEFT" => IfcWindowStyleOperationEnum::TriplePanelLeft,
            "TRIPLE_PANEL_RIGHT" => IfcWindowStyleOperationEnum::TriplePanelRight,
            "TRIPLE_PANEL_HORIZONTAL" => IfcWindowStyleOperationEnum::TriplePanelHorizontal,
            "USERDEFINED" => IfcWindowStyleOperationEnum::Userdefined,
            "NOTDEFINED" => IfcWindowStyleOperationEnum::Notdefined,
            _ => panic!("{} is not a valid value", value),
        }
    }
}
impl From<Parameter> for IfcWindowStyleOperationEnum {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EnumValue(value) => value.into(),
                _ => panic!("parameter is not an enum value"),
            },
            Parameter::OmittedParameter => IfcWindowStyleOperationEnum::default(),
            _ => panic!("parameter is not an enum value"),
        }
    }
}
#[derive(Eq, PartialEq, Hash, Debug)]
pub enum IfcWindowTypeEnum {
    Window,
    Skylight,
    Lightdome,
    Userdefined,
    Notdefined,
}
impl Default for IfcWindowTypeEnum {
    fn default() -> Self {
        IfcWindowTypeEnum::Window
    }
}
impl From<String> for IfcWindowTypeEnum {
    fn from(value: String) -> Self {
        match value.as_str() {
            "WINDOW" => IfcWindowTypeEnum::Window,
            "SKYLIGHT" => IfcWindowTypeEnum::Skylight,
            "LIGHTDOME" => IfcWindowTypeEnum::Lightdome,
            "USERDEFINED" => IfcWindowTypeEnum::Userdefined,
            "NOTDEFINED" => IfcWindowTypeEnum::Notdefined,
            _ => panic!("{} is not a valid value", value),
        }
    }
}
impl From<Parameter> for IfcWindowTypeEnum {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EnumValue(value) => value.into(),
                _ => panic!("parameter is not an enum value"),
            },
            Parameter::OmittedParameter => IfcWindowTypeEnum::default(),
            _ => panic!("parameter is not an enum value"),
        }
    }
}
#[derive(Eq, PartialEq, Hash, Debug)]
pub enum IfcWindowTypePartitioningEnum {
    SinglePanel,
    DoublePanelVertical,
    DoublePanelHorizontal,
    TriplePanelVertical,
    TriplePanelBottom,
    TriplePanelTop,
    TriplePanelLeft,
    TriplePanelRight,
    TriplePanelHorizontal,
    Userdefined,
    Notdefined,
}
impl Default for IfcWindowTypePartitioningEnum {
    fn default() -> Self {
        IfcWindowTypePartitioningEnum::SinglePanel
    }
}
impl From<String> for IfcWindowTypePartitioningEnum {
    fn from(value: String) -> Self {
        match value.as_str() {
            "SINGLE_PANEL" => IfcWindowTypePartitioningEnum::SinglePanel,
            "DOUBLE_PANEL_VERTICAL" => IfcWindowTypePartitioningEnum::DoublePanelVertical,
            "DOUBLE_PANEL_HORIZONTAL" => IfcWindowTypePartitioningEnum::DoublePanelHorizontal,
            "TRIPLE_PANEL_VERTICAL" => IfcWindowTypePartitioningEnum::TriplePanelVertical,
            "TRIPLE_PANEL_BOTTOM" => IfcWindowTypePartitioningEnum::TriplePanelBottom,
            "TRIPLE_PANEL_TOP" => IfcWindowTypePartitioningEnum::TriplePanelTop,
            "TRIPLE_PANEL_LEFT" => IfcWindowTypePartitioningEnum::TriplePanelLeft,
            "TRIPLE_PANEL_RIGHT" => IfcWindowTypePartitioningEnum::TriplePanelRight,
            "TRIPLE_PANEL_HORIZONTAL" => IfcWindowTypePartitioningEnum::TriplePanelHorizontal,
            "USERDEFINED" => IfcWindowTypePartitioningEnum::Userdefined,
            "NOTDEFINED" => IfcWindowTypePartitioningEnum::Notdefined,
            _ => panic!("{} is not a valid value", value),
        }
    }
}
impl From<Parameter> for IfcWindowTypePartitioningEnum {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EnumValue(value) => value.into(),
                _ => panic!("parameter is not an enum value"),
            },
            Parameter::OmittedParameter => IfcWindowTypePartitioningEnum::default(),
            _ => panic!("parameter is not an enum value"),
        }
    }
}
#[derive(Eq, PartialEq, Hash, Debug)]
pub enum IfcWorkCalendarTypeEnum {
    Firstshift,
    Secondshift,
    Thirdshift,
    Userdefined,
    Notdefined,
}
impl Default for IfcWorkCalendarTypeEnum {
    fn default() -> Self {
        IfcWorkCalendarTypeEnum::Firstshift
    }
}
impl From<String> for IfcWorkCalendarTypeEnum {
    fn from(value: String) -> Self {
        match value.as_str() {
            "FIRSTSHIFT" => IfcWorkCalendarTypeEnum::Firstshift,
            "SECONDSHIFT" => IfcWorkCalendarTypeEnum::Secondshift,
            "THIRDSHIFT" => IfcWorkCalendarTypeEnum::Thirdshift,
            "USERDEFINED" => IfcWorkCalendarTypeEnum::Userdefined,
            "NOTDEFINED" => IfcWorkCalendarTypeEnum::Notdefined,
            _ => panic!("{} is not a valid value", value),
        }
    }
}
impl From<Parameter> for IfcWorkCalendarTypeEnum {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EnumValue(value) => value.into(),
                _ => panic!("parameter is not an enum value"),
            },
            Parameter::OmittedParameter => IfcWorkCalendarTypeEnum::default(),
            _ => panic!("parameter is not an enum value"),
        }
    }
}
#[derive(Eq, PartialEq, Hash, Debug)]
pub enum IfcWorkPlanTypeEnum {
    Actual,
    Baseline,
    Planned,
    Userdefined,
    Notdefined,
}
impl Default for IfcWorkPlanTypeEnum {
    fn default() -> Self {
        IfcWorkPlanTypeEnum::Actual
    }
}
impl From<String> for IfcWorkPlanTypeEnum {
    fn from(value: String) -> Self {
        match value.as_str() {
            "ACTUAL" => IfcWorkPlanTypeEnum::Actual,
            "BASELINE" => IfcWorkPlanTypeEnum::Baseline,
            "PLANNED" => IfcWorkPlanTypeEnum::Planned,
            "USERDEFINED" => IfcWorkPlanTypeEnum::Userdefined,
            "NOTDEFINED" => IfcWorkPlanTypeEnum::Notdefined,
            _ => panic!("{} is not a valid value", value),
        }
    }
}
impl From<Parameter> for IfcWorkPlanTypeEnum {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EnumValue(value) => value.into(),
                _ => panic!("parameter is not an enum value"),
            },
            Parameter::OmittedParameter => IfcWorkPlanTypeEnum::default(),
            _ => panic!("parameter is not an enum value"),
        }
    }
}
#[derive(Eq, PartialEq, Hash, Debug)]
pub enum IfcWorkScheduleTypeEnum {
    Actual,
    Baseline,
    Planned,
    Userdefined,
    Notdefined,
}
impl Default for IfcWorkScheduleTypeEnum {
    fn default() -> Self {
        IfcWorkScheduleTypeEnum::Actual
    }
}
impl From<String> for IfcWorkScheduleTypeEnum {
    fn from(value: String) -> Self {
        match value.as_str() {
            "ACTUAL" => IfcWorkScheduleTypeEnum::Actual,
            "BASELINE" => IfcWorkScheduleTypeEnum::Baseline,
            "PLANNED" => IfcWorkScheduleTypeEnum::Planned,
            "USERDEFINED" => IfcWorkScheduleTypeEnum::Userdefined,
            "NOTDEFINED" => IfcWorkScheduleTypeEnum::Notdefined,
            _ => panic!("{} is not a valid value", value),
        }
    }
}
impl From<Parameter> for IfcWorkScheduleTypeEnum {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EnumValue(value) => value.into(),
                _ => panic!("parameter is not an enum value"),
            },
            Parameter::OmittedParameter => IfcWorkScheduleTypeEnum::default(),
            _ => panic!("parameter is not an enum value"),
        }
    }
}
#[derive(Eq, PartialEq, Hash, Debug)]
pub enum IfcActorSelect {
    EntityRef(EntityRef),
    IfcOrganization(EntityRef),
    IfcPerson(EntityRef),
    IfcPersonAndOrganization(EntityRef),
}
impl Default for IfcActorSelect {
    fn default() -> Self {
        IfcActorSelect::IfcOrganization(EntityRef::default())
    }
}
impl From<Parameter> for IfcActorSelect {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EntityRef(id) => IfcActorSelect::EntityRef(EntityRef(id)),
                _ => panic!("parameter is not an instance"),
            },
            _ => panic!("parameter is not recognized"),
        }
    }
}
#[derive(Debug)]
pub enum IfcAppliedValueSelect {
    EntityRef(EntityRef),
    IfcMeasureWithUnit(EntityRef),
    IfcReference(EntityRef),
    IfcValue(IfcValue),
}
impl Default for IfcAppliedValueSelect {
    fn default() -> Self {
        IfcAppliedValueSelect::IfcMeasureWithUnit(EntityRef::default())
    }
}
impl From<Parameter> for IfcAppliedValueSelect {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::TypedParameter(typed_parameter) => match typed_parameter.type_name.as_str() {
                "IFC_VALUE" => {
                    IfcAppliedValueSelect::IfcValue(typed_parameter.parameters.into_iter().next().unwrap().into())
                }
                _ => panic!("parameter type is not recognized: {}", typed_parameter.type_name),
            },
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EntityRef(id) => IfcAppliedValueSelect::EntityRef(EntityRef(id)),
                _ => panic!("parameter is not an instance"),
            },
            _ => panic!("parameter is not recognized"),
        }
    }
}
#[derive(Debug)]
pub enum IfcAxis2Placement {
    EntityRef(EntityRef),
    IfcAxis2Placement2D(EntityRef),
    IfcAxis2Placement3D(EntityRef),
}
impl Default for IfcAxis2Placement {
    fn default() -> Self {
        IfcAxis2Placement::IfcAxis2Placement2D(EntityRef::default())
    }
}
impl From<Parameter> for IfcAxis2Placement {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EntityRef(id) => IfcAxis2Placement::EntityRef(EntityRef(id)),
                _ => panic!("parameter is not an instance"),
            },
            _ => panic!("parameter is not recognized"),
        }
    }
}
#[derive(Debug)]
pub enum IfcBendingParameterSelect {
    IfcLengthMeasure(IfcLengthMeasure),
    IfcPlaneAngleMeasure(IfcPlaneAngleMeasure),
}
impl Default for IfcBendingParameterSelect {
    fn default() -> Self {
        IfcBendingParameterSelect::IfcLengthMeasure(IfcLengthMeasure::default())
    }
}
impl From<Parameter> for IfcBendingParameterSelect {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::TypedParameter(typed_parameter) => match typed_parameter.type_name.as_str() {
                "IFC_LENGTH_MEASURE" => IfcBendingParameterSelect::IfcLengthMeasure(
                    typed_parameter.parameters.into_iter().next().unwrap().into(),
                ),
                "IFC_PLANE_ANGLE_MEASURE" => IfcBendingParameterSelect::IfcPlaneAngleMeasure(
                    typed_parameter.parameters.into_iter().next().unwrap().into(),
                ),
                _ => panic!("parameter type is not recognized: {}", typed_parameter.type_name),
            },
            _ => panic!("parameter is not recognized"),
        }
    }
}
#[derive(Debug)]
pub enum IfcBooleanOperand {
    EntityRef(EntityRef),
    IfcBooleanResult(EntityRef),
    IfcCsgPrimitive3D(EntityRef),
    IfcHalfSpaceSolid(EntityRef),
    IfcSolidModel(EntityRef),
    IfcTessellatedFaceSet(EntityRef),
}
impl Default for IfcBooleanOperand {
    fn default() -> Self {
        IfcBooleanOperand::IfcBooleanResult(EntityRef::default())
    }
}
impl From<Parameter> for IfcBooleanOperand {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EntityRef(id) => IfcBooleanOperand::EntityRef(EntityRef(id)),
                _ => panic!("parameter is not an instance"),
            },
            _ => panic!("parameter is not recognized"),
        }
    }
}
#[derive(Debug)]
pub enum IfcClassificationReferenceSelect {
    EntityRef(EntityRef),
    IfcClassification(EntityRef),
    IfcClassificationReference(EntityRef),
}
impl Default for IfcClassificationReferenceSelect {
    fn default() -> Self {
        IfcClassificationReferenceSelect::IfcClassification(EntityRef::default())
    }
}
impl From<Parameter> for IfcClassificationReferenceSelect {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EntityRef(id) => IfcClassificationReferenceSelect::EntityRef(EntityRef(id)),
                _ => panic!("parameter is not an instance"),
            },
            _ => panic!("parameter is not recognized"),
        }
    }
}
#[derive(Eq, PartialEq, Hash, Debug)]
pub enum IfcClassificationSelect {
    EntityRef(EntityRef),
    IfcClassification(EntityRef),
    IfcClassificationReference(EntityRef),
}
impl Default for IfcClassificationSelect {
    fn default() -> Self {
        IfcClassificationSelect::IfcClassification(EntityRef::default())
    }
}
impl From<Parameter> for IfcClassificationSelect {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EntityRef(id) => IfcClassificationSelect::EntityRef(EntityRef(id)),
                _ => panic!("parameter is not an instance"),
            },
            _ => panic!("parameter is not recognized"),
        }
    }
}
#[derive(Eq, PartialEq, Hash, Debug)]
pub enum IfcColour {
    EntityRef(EntityRef),
    IfcColourSpecification(EntityRef),
    IfcPreDefinedColour(EntityRef),
}
impl Default for IfcColour {
    fn default() -> Self {
        IfcColour::IfcColourSpecification(EntityRef::default())
    }
}
impl From<Parameter> for IfcColour {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EntityRef(id) => IfcColour::EntityRef(EntityRef(id)),
                _ => panic!("parameter is not an instance"),
            },
            _ => panic!("parameter is not recognized"),
        }
    }
}
#[derive(Debug)]
pub enum IfcColourOrFactor {
    IfcColourRgb(EntityRef),
    IfcNormalisedRatioMeasure(IfcNormalisedRatioMeasure),
}
impl Default for IfcColourOrFactor {
    fn default() -> Self {
        IfcColourOrFactor::IfcColourRgb(EntityRef::default())
    }
}
impl From<Parameter> for IfcColourOrFactor {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::TypedParameter(typed_parameter) => match typed_parameter.type_name.as_str() {
                "IFC_NORMALISED_RATIO_MEASURE" => IfcColourOrFactor::IfcNormalisedRatioMeasure(
                    typed_parameter.parameters.into_iter().next().unwrap().into(),
                ),
                _ => panic!("parameter type is not recognized: {}", typed_parameter.type_name),
            },
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EntityRef(id) => IfcColourOrFactor::IfcColourRgb(EntityRef(id)),
                _ => panic!("parameter is not an instance"),
            },
            _ => panic!("parameter is not recognized"),
        }
    }
}
#[derive(Debug)]
pub enum IfcCoordinateReferenceSystemSelect {
    EntityRef(EntityRef),
    IfcCoordinateReferenceSystem(EntityRef),
    IfcGeometricRepresentationContext(EntityRef),
}
impl Default for IfcCoordinateReferenceSystemSelect {
    fn default() -> Self {
        IfcCoordinateReferenceSystemSelect::IfcCoordinateReferenceSystem(EntityRef::default())
    }
}
impl From<Parameter> for IfcCoordinateReferenceSystemSelect {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EntityRef(id) => IfcCoordinateReferenceSystemSelect::EntityRef(EntityRef(id)),
                _ => panic!("parameter is not an instance"),
            },
            _ => panic!("parameter is not recognized"),
        }
    }
}
#[derive(Debug)]
pub enum IfcCsgSelect {
    EntityRef(EntityRef),
    IfcBooleanResult(EntityRef),
    IfcCsgPrimitive3D(EntityRef),
}
impl Default for IfcCsgSelect {
    fn default() -> Self {
        IfcCsgSelect::IfcBooleanResult(EntityRef::default())
    }
}
impl From<Parameter> for IfcCsgSelect {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EntityRef(id) => IfcCsgSelect::EntityRef(EntityRef(id)),
                _ => panic!("parameter is not an instance"),
            },
            _ => panic!("parameter is not recognized"),
        }
    }
}
#[derive(Debug)]
pub enum IfcCurveFontOrScaledCurveFontSelect {
    IfcCurveStyleFontAndScaling(EntityRef),
    IfcCurveStyleFontSelect(IfcCurveStyleFontSelect),
}
impl Default for IfcCurveFontOrScaledCurveFontSelect {
    fn default() -> Self {
        IfcCurveFontOrScaledCurveFontSelect::IfcCurveStyleFontAndScaling(EntityRef::default())
    }
}
impl From<Parameter> for IfcCurveFontOrScaledCurveFontSelect {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::TypedParameter(typed_parameter) => match typed_parameter.type_name.as_str() {
                "IFC_CURVE_STYLE_FONT_SELECT" => IfcCurveFontOrScaledCurveFontSelect::IfcCurveStyleFontSelect(
                    typed_parameter.parameters.into_iter().next().unwrap().into(),
                ),
                _ => panic!("parameter type is not recognized: {}", typed_parameter.type_name),
            },
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EntityRef(id) => {
                    IfcCurveFontOrScaledCurveFontSelect::IfcCurveStyleFontAndScaling(EntityRef(id))
                }
                _ => panic!("parameter is not an instance"),
            },
            _ => panic!("parameter is not recognized"),
        }
    }
}
#[derive(Debug)]
pub enum IfcCurveOnSurface {
    EntityRef(EntityRef),
    IfcCompositeCurveOnSurface(EntityRef),
    IfcPcurve(EntityRef),
    IfcSurfaceCurve(EntityRef),
}
impl Default for IfcCurveOnSurface {
    fn default() -> Self {
        IfcCurveOnSurface::IfcCompositeCurveOnSurface(EntityRef::default())
    }
}
impl From<Parameter> for IfcCurveOnSurface {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EntityRef(id) => IfcCurveOnSurface::EntityRef(EntityRef(id)),
                _ => panic!("parameter is not an instance"),
            },
            _ => panic!("parameter is not recognized"),
        }
    }
}
#[derive(Debug)]
pub enum IfcCurveOrEdgeCurve {
    EntityRef(EntityRef),
    IfcBoundedCurve(EntityRef),
    IfcEdgeCurve(EntityRef),
}
impl Default for IfcCurveOrEdgeCurve {
    fn default() -> Self {
        IfcCurveOrEdgeCurve::IfcBoundedCurve(EntityRef::default())
    }
}
impl From<Parameter> for IfcCurveOrEdgeCurve {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EntityRef(id) => IfcCurveOrEdgeCurve::EntityRef(EntityRef(id)),
                _ => panic!("parameter is not an instance"),
            },
            _ => panic!("parameter is not recognized"),
        }
    }
}
#[derive(Debug)]
pub enum IfcCurveStyleFontSelect {
    EntityRef(EntityRef),
    IfcCurveStyleFont(EntityRef),
    IfcPreDefinedCurveFont(EntityRef),
}
impl Default for IfcCurveStyleFontSelect {
    fn default() -> Self {
        IfcCurveStyleFontSelect::IfcCurveStyleFont(EntityRef::default())
    }
}
impl From<Parameter> for IfcCurveStyleFontSelect {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EntityRef(id) => IfcCurveStyleFontSelect::EntityRef(EntityRef(id)),
                _ => panic!("parameter is not an instance"),
            },
            _ => panic!("parameter is not recognized"),
        }
    }
}
#[derive(Eq, PartialEq, Hash, Debug)]
pub enum IfcDefinitionSelect {
    EntityRef(EntityRef),
    IfcObjectDefinition(EntityRef),
    IfcPropertyDefinition(EntityRef),
}
impl Default for IfcDefinitionSelect {
    fn default() -> Self {
        IfcDefinitionSelect::IfcObjectDefinition(EntityRef::default())
    }
}
impl From<Parameter> for IfcDefinitionSelect {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EntityRef(id) => IfcDefinitionSelect::EntityRef(EntityRef(id)),
                _ => panic!("parameter is not an instance"),
            },
            _ => panic!("parameter is not recognized"),
        }
    }
}
#[derive(Debug)]
pub enum IfcDerivedMeasureValue {
    IfcAbsorbedDoseMeasure(IfcAbsorbedDoseMeasure),
    IfcAccelerationMeasure(IfcAccelerationMeasure),
    IfcAngularVelocityMeasure(IfcAngularVelocityMeasure),
    IfcAreaDensityMeasure(IfcAreaDensityMeasure),
    IfcCompoundPlaneAngleMeasure(IfcCompoundPlaneAngleMeasure),
    IfcCurvatureMeasure(IfcCurvatureMeasure),
    IfcDoseEquivalentMeasure(IfcDoseEquivalentMeasure),
    IfcDynamicViscosityMeasure(IfcDynamicViscosityMeasure),
    IfcElectricCapacitanceMeasure(IfcElectricCapacitanceMeasure),
    IfcElectricChargeMeasure(IfcElectricChargeMeasure),
    IfcElectricConductanceMeasure(IfcElectricConductanceMeasure),
    IfcElectricResistanceMeasure(IfcElectricResistanceMeasure),
    IfcElectricVoltageMeasure(IfcElectricVoltageMeasure),
    IfcEnergyMeasure(IfcEnergyMeasure),
    IfcForceMeasure(IfcForceMeasure),
    IfcFrequencyMeasure(IfcFrequencyMeasure),
    IfcHeatFluxDensityMeasure(IfcHeatFluxDensityMeasure),
    IfcHeatingValueMeasure(IfcHeatingValueMeasure),
    IfcIlluminanceMeasure(IfcIlluminanceMeasure),
    IfcInductanceMeasure(IfcInductanceMeasure),
    IfcIntegerCountRateMeasure(IfcIntegerCountRateMeasure),
    IfcIonConcentrationMeasure(IfcIonConcentrationMeasure),
    IfcIsothermalMoistureCapacityMeasure(IfcIsothermalMoistureCapacityMeasure),
    IfcKinematicViscosityMeasure(IfcKinematicViscosityMeasure),
    IfcLinearForceMeasure(IfcLinearForceMeasure),
    IfcLinearMomentMeasure(IfcLinearMomentMeasure),
    IfcLinearStiffnessMeasure(IfcLinearStiffnessMeasure),
    IfcLinearVelocityMeasure(IfcLinearVelocityMeasure),
    IfcLuminousFluxMeasure(IfcLuminousFluxMeasure),
    IfcLuminousIntensityDistributionMeasure(IfcLuminousIntensityDistributionMeasure),
    IfcMagneticFluxDensityMeasure(IfcMagneticFluxDensityMeasure),
    IfcMagneticFluxMeasure(IfcMagneticFluxMeasure),
    IfcMassDensityMeasure(IfcMassDensityMeasure),
    IfcMassFlowRateMeasure(IfcMassFlowRateMeasure),
    IfcMassPerLengthMeasure(IfcMassPerLengthMeasure),
    IfcModulusOfElasticityMeasure(IfcModulusOfElasticityMeasure),
    IfcModulusOfLinearSubgradeReactionMeasure(IfcModulusOfLinearSubgradeReactionMeasure),
    IfcModulusOfRotationalSubgradeReactionMeasure(IfcModulusOfRotationalSubgradeReactionMeasure),
    IfcModulusOfSubgradeReactionMeasure(IfcModulusOfSubgradeReactionMeasure),
    IfcMoistureDiffusivityMeasure(IfcMoistureDiffusivityMeasure),
    IfcMolecularWeightMeasure(IfcMolecularWeightMeasure),
    IfcMomentOfInertiaMeasure(IfcMomentOfInertiaMeasure),
    IfcMonetaryMeasure(IfcMonetaryMeasure),
    IfcPhMeasure(IfcPhMeasure),
    IfcPlanarForceMeasure(IfcPlanarForceMeasure),
    IfcPowerMeasure(IfcPowerMeasure),
    IfcPressureMeasure(IfcPressureMeasure),
    IfcRadioActivityMeasure(IfcRadioActivityMeasure),
    IfcRotationalFrequencyMeasure(IfcRotationalFrequencyMeasure),
    IfcRotationalMassMeasure(IfcRotationalMassMeasure),
    IfcRotationalStiffnessMeasure(IfcRotationalStiffnessMeasure),
    IfcSectionModulusMeasure(IfcSectionModulusMeasure),
    IfcSectionalAreaIntegralMeasure(IfcSectionalAreaIntegralMeasure),
    IfcShearModulusMeasure(IfcShearModulusMeasure),
    IfcSoundPowerLevelMeasure(IfcSoundPowerLevelMeasure),
    IfcSoundPowerMeasure(IfcSoundPowerMeasure),
    IfcSoundPressureLevelMeasure(IfcSoundPressureLevelMeasure),
    IfcSoundPressureMeasure(IfcSoundPressureMeasure),
    IfcSpecificHeatCapacityMeasure(IfcSpecificHeatCapacityMeasure),
    IfcTemperatureGradientMeasure(IfcTemperatureGradientMeasure),
    IfcTemperatureRateOfChangeMeasure(IfcTemperatureRateOfChangeMeasure),
    IfcThermalAdmittanceMeasure(IfcThermalAdmittanceMeasure),
    IfcThermalConductivityMeasure(IfcThermalConductivityMeasure),
    IfcThermalExpansionCoefficientMeasure(IfcThermalExpansionCoefficientMeasure),
    IfcThermalResistanceMeasure(IfcThermalResistanceMeasure),
    IfcThermalTransmittanceMeasure(IfcThermalTransmittanceMeasure),
    IfcTorqueMeasure(IfcTorqueMeasure),
    IfcVaporPermeabilityMeasure(IfcVaporPermeabilityMeasure),
    IfcVolumetricFlowRateMeasure(IfcVolumetricFlowRateMeasure),
    IfcWarpingConstantMeasure(IfcWarpingConstantMeasure),
    IfcWarpingMomentMeasure(IfcWarpingMomentMeasure),
}
impl Default for IfcDerivedMeasureValue {
    fn default() -> Self {
        IfcDerivedMeasureValue::IfcAbsorbedDoseMeasure(IfcAbsorbedDoseMeasure::default())
    }
}
impl From<Parameter> for IfcDerivedMeasureValue {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::TypedParameter(typed_parameter) => match typed_parameter.type_name.as_str() {
                "IFC_ABSORBED_DOSE_MEASURE" => IfcDerivedMeasureValue::IfcAbsorbedDoseMeasure(
                    typed_parameter.parameters.into_iter().next().unwrap().into(),
                ),
                "IFC_ACCELERATION_MEASURE" => IfcDerivedMeasureValue::IfcAccelerationMeasure(
                    typed_parameter.parameters.into_iter().next().unwrap().into(),
                ),
                "IFC_ANGULAR_VELOCITY_MEASURE" => IfcDerivedMeasureValue::IfcAngularVelocityMeasure(
                    typed_parameter.parameters.into_iter().next().unwrap().into(),
                ),
                "IFC_AREA_DENSITY_MEASURE" => IfcDerivedMeasureValue::IfcAreaDensityMeasure(
                    typed_parameter.parameters.into_iter().next().unwrap().into(),
                ),
                "IFC_COMPOUND_PLANE_ANGLE_MEASURE" => IfcDerivedMeasureValue::IfcCompoundPlaneAngleMeasure(
                    typed_parameter.parameters.into_iter().next().unwrap().into(),
                ),
                "IFC_CURVATURE_MEASURE" => IfcDerivedMeasureValue::IfcCurvatureMeasure(
                    typed_parameter.parameters.into_iter().next().unwrap().into(),
                ),
                "IFC_DOSE_EQUIVALENT_MEASURE" => IfcDerivedMeasureValue::IfcDoseEquivalentMeasure(
                    typed_parameter.parameters.into_iter().next().unwrap().into(),
                ),
                "IFC_DYNAMIC_VISCOSITY_MEASURE" => IfcDerivedMeasureValue::IfcDynamicViscosityMeasure(
                    typed_parameter.parameters.into_iter().next().unwrap().into(),
                ),
                "IFC_ELECTRIC_CAPACITANCE_MEASURE" => IfcDerivedMeasureValue::IfcElectricCapacitanceMeasure(
                    typed_parameter.parameters.into_iter().next().unwrap().into(),
                ),
                "IFC_ELECTRIC_CHARGE_MEASURE" => IfcDerivedMeasureValue::IfcElectricChargeMeasure(
                    typed_parameter.parameters.into_iter().next().unwrap().into(),
                ),
                "IFC_ELECTRIC_CONDUCTANCE_MEASURE" => IfcDerivedMeasureValue::IfcElectricConductanceMeasure(
                    typed_parameter.parameters.into_iter().next().unwrap().into(),
                ),
                "IFC_ELECTRIC_RESISTANCE_MEASURE" => IfcDerivedMeasureValue::IfcElectricResistanceMeasure(
                    typed_parameter.parameters.into_iter().next().unwrap().into(),
                ),
                "IFC_ELECTRIC_VOLTAGE_MEASURE" => IfcDerivedMeasureValue::IfcElectricVoltageMeasure(
                    typed_parameter.parameters.into_iter().next().unwrap().into(),
                ),
                "IFC_ENERGY_MEASURE" => IfcDerivedMeasureValue::IfcEnergyMeasure(
                    typed_parameter.parameters.into_iter().next().unwrap().into(),
                ),
                "IFC_FORCE_MEASURE" => IfcDerivedMeasureValue::IfcForceMeasure(
                    typed_parameter.parameters.into_iter().next().unwrap().into(),
                ),
                "IFC_FREQUENCY_MEASURE" => IfcDerivedMeasureValue::IfcFrequencyMeasure(
                    typed_parameter.parameters.into_iter().next().unwrap().into(),
                ),
                "IFC_HEAT_FLUX_DENSITY_MEASURE" => IfcDerivedMeasureValue::IfcHeatFluxDensityMeasure(
                    typed_parameter.parameters.into_iter().next().unwrap().into(),
                ),
                "IFC_HEATING_VALUE_MEASURE" => IfcDerivedMeasureValue::IfcHeatingValueMeasure(
                    typed_parameter.parameters.into_iter().next().unwrap().into(),
                ),
                "IFC_ILLUMINANCE_MEASURE" => IfcDerivedMeasureValue::IfcIlluminanceMeasure(
                    typed_parameter.parameters.into_iter().next().unwrap().into(),
                ),
                "IFC_INDUCTANCE_MEASURE" => IfcDerivedMeasureValue::IfcInductanceMeasure(
                    typed_parameter.parameters.into_iter().next().unwrap().into(),
                ),
                "IFC_INTEGER_COUNT_RATE_MEASURE" => IfcDerivedMeasureValue::IfcIntegerCountRateMeasure(
                    typed_parameter.parameters.into_iter().next().unwrap().into(),
                ),
                "IFC_ION_CONCENTRATION_MEASURE" => IfcDerivedMeasureValue::IfcIonConcentrationMeasure(
                    typed_parameter.parameters.into_iter().next().unwrap().into(),
                ),
                "IFC_ISOTHERMAL_MOISTURE_CAPACITY_MEASURE" => {
                    IfcDerivedMeasureValue::IfcIsothermalMoistureCapacityMeasure(
                        typed_parameter.parameters.into_iter().next().unwrap().into(),
                    )
                }
                "IFC_KINEMATIC_VISCOSITY_MEASURE" => IfcDerivedMeasureValue::IfcKinematicViscosityMeasure(
                    typed_parameter.parameters.into_iter().next().unwrap().into(),
                ),
                "IFC_LINEAR_FORCE_MEASURE" => IfcDerivedMeasureValue::IfcLinearForceMeasure(
                    typed_parameter.parameters.into_iter().next().unwrap().into(),
                ),
                "IFC_LINEAR_MOMENT_MEASURE" => IfcDerivedMeasureValue::IfcLinearMomentMeasure(
                    typed_parameter.parameters.into_iter().next().unwrap().into(),
                ),
                "IFC_LINEAR_STIFFNESS_MEASURE" => IfcDerivedMeasureValue::IfcLinearStiffnessMeasure(
                    typed_parameter.parameters.into_iter().next().unwrap().into(),
                ),
                "IFC_LINEAR_VELOCITY_MEASURE" => IfcDerivedMeasureValue::IfcLinearVelocityMeasure(
                    typed_parameter.parameters.into_iter().next().unwrap().into(),
                ),
                "IFC_LUMINOUS_FLUX_MEASURE" => IfcDerivedMeasureValue::IfcLuminousFluxMeasure(
                    typed_parameter.parameters.into_iter().next().unwrap().into(),
                ),
                "IFC_LUMINOUS_INTENSITY_DISTRIBUTION_MEASURE" => {
                    IfcDerivedMeasureValue::IfcLuminousIntensityDistributionMeasure(
                        typed_parameter.parameters.into_iter().next().unwrap().into(),
                    )
                }
                "IFC_MAGNETIC_FLUX_DENSITY_MEASURE" => IfcDerivedMeasureValue::IfcMagneticFluxDensityMeasure(
                    typed_parameter.parameters.into_iter().next().unwrap().into(),
                ),
                "IFC_MAGNETIC_FLUX_MEASURE" => IfcDerivedMeasureValue::IfcMagneticFluxMeasure(
                    typed_parameter.parameters.into_iter().next().unwrap().into(),
                ),
                "IFC_MASS_DENSITY_MEASURE" => IfcDerivedMeasureValue::IfcMassDensityMeasure(
                    typed_parameter.parameters.into_iter().next().unwrap().into(),
                ),
                "IFC_MASS_FLOW_RATE_MEASURE" => IfcDerivedMeasureValue::IfcMassFlowRateMeasure(
                    typed_parameter.parameters.into_iter().next().unwrap().into(),
                ),
                "IFC_MASS_PER_LENGTH_MEASURE" => IfcDerivedMeasureValue::IfcMassPerLengthMeasure(
                    typed_parameter.parameters.into_iter().next().unwrap().into(),
                ),
                "IFC_MODULUS_OF_ELASTICITY_MEASURE" => IfcDerivedMeasureValue::IfcModulusOfElasticityMeasure(
                    typed_parameter.parameters.into_iter().next().unwrap().into(),
                ),
                "IFC_MODULUS_OF_LINEAR_SUBGRADE_REACTION_MEASURE" => {
                    IfcDerivedMeasureValue::IfcModulusOfLinearSubgradeReactionMeasure(
                        typed_parameter.parameters.into_iter().next().unwrap().into(),
                    )
                }
                "IFC_MODULUS_OF_ROTATIONAL_SUBGRADE_REACTION_MEASURE" => {
                    IfcDerivedMeasureValue::IfcModulusOfRotationalSubgradeReactionMeasure(
                        typed_parameter.parameters.into_iter().next().unwrap().into(),
                    )
                }
                "IFC_MODULUS_OF_SUBGRADE_REACTION_MEASURE" => {
                    IfcDerivedMeasureValue::IfcModulusOfSubgradeReactionMeasure(
                        typed_parameter.parameters.into_iter().next().unwrap().into(),
                    )
                }
                "IFC_MOISTURE_DIFFUSIVITY_MEASURE" => IfcDerivedMeasureValue::IfcMoistureDiffusivityMeasure(
                    typed_parameter.parameters.into_iter().next().unwrap().into(),
                ),
                "IFC_MOLECULAR_WEIGHT_MEASURE" => IfcDerivedMeasureValue::IfcMolecularWeightMeasure(
                    typed_parameter.parameters.into_iter().next().unwrap().into(),
                ),
                "IFC_MOMENT_OF_INERTIA_MEASURE" => IfcDerivedMeasureValue::IfcMomentOfInertiaMeasure(
                    typed_parameter.parameters.into_iter().next().unwrap().into(),
                ),
                "IFC_MONETARY_MEASURE" => IfcDerivedMeasureValue::IfcMonetaryMeasure(
                    typed_parameter.parameters.into_iter().next().unwrap().into(),
                ),
                "IFC_PH_MEASURE" => {
                    IfcDerivedMeasureValue::IfcPhMeasure(typed_parameter.parameters.into_iter().next().unwrap().into())
                }
                "IFC_PLANAR_FORCE_MEASURE" => IfcDerivedMeasureValue::IfcPlanarForceMeasure(
                    typed_parameter.parameters.into_iter().next().unwrap().into(),
                ),
                "IFC_POWER_MEASURE" => IfcDerivedMeasureValue::IfcPowerMeasure(
                    typed_parameter.parameters.into_iter().next().unwrap().into(),
                ),
                "IFC_PRESSURE_MEASURE" => IfcDerivedMeasureValue::IfcPressureMeasure(
                    typed_parameter.parameters.into_iter().next().unwrap().into(),
                ),
                "IFC_RADIO_ACTIVITY_MEASURE" => IfcDerivedMeasureValue::IfcRadioActivityMeasure(
                    typed_parameter.parameters.into_iter().next().unwrap().into(),
                ),
                "IFC_ROTATIONAL_FREQUENCY_MEASURE" => IfcDerivedMeasureValue::IfcRotationalFrequencyMeasure(
                    typed_parameter.parameters.into_iter().next().unwrap().into(),
                ),
                "IFC_ROTATIONAL_MASS_MEASURE" => IfcDerivedMeasureValue::IfcRotationalMassMeasure(
                    typed_parameter.parameters.into_iter().next().unwrap().into(),
                ),
                "IFC_ROTATIONAL_STIFFNESS_MEASURE" => IfcDerivedMeasureValue::IfcRotationalStiffnessMeasure(
                    typed_parameter.parameters.into_iter().next().unwrap().into(),
                ),
                "IFC_SECTION_MODULUS_MEASURE" => IfcDerivedMeasureValue::IfcSectionModulusMeasure(
                    typed_parameter.parameters.into_iter().next().unwrap().into(),
                ),
                "IFC_SECTIONAL_AREA_INTEGRAL_MEASURE" => IfcDerivedMeasureValue::IfcSectionalAreaIntegralMeasure(
                    typed_parameter.parameters.into_iter().next().unwrap().into(),
                ),
                "IFC_SHEAR_MODULUS_MEASURE" => IfcDerivedMeasureValue::IfcShearModulusMeasure(
                    typed_parameter.parameters.into_iter().next().unwrap().into(),
                ),
                "IFC_SOUND_POWER_LEVEL_MEASURE" => IfcDerivedMeasureValue::IfcSoundPowerLevelMeasure(
                    typed_parameter.parameters.into_iter().next().unwrap().into(),
                ),
                "IFC_SOUND_POWER_MEASURE" => IfcDerivedMeasureValue::IfcSoundPowerMeasure(
                    typed_parameter.parameters.into_iter().next().unwrap().into(),
                ),
                "IFC_SOUND_PRESSURE_LEVEL_MEASURE" => IfcDerivedMeasureValue::IfcSoundPressureLevelMeasure(
                    typed_parameter.parameters.into_iter().next().unwrap().into(),
                ),
                "IFC_SOUND_PRESSURE_MEASURE" => IfcDerivedMeasureValue::IfcSoundPressureMeasure(
                    typed_parameter.parameters.into_iter().next().unwrap().into(),
                ),
                "IFC_SPECIFIC_HEAT_CAPACITY_MEASURE" => IfcDerivedMeasureValue::IfcSpecificHeatCapacityMeasure(
                    typed_parameter.parameters.into_iter().next().unwrap().into(),
                ),
                "IFC_TEMPERATURE_GRADIENT_MEASURE" => IfcDerivedMeasureValue::IfcTemperatureGradientMeasure(
                    typed_parameter.parameters.into_iter().next().unwrap().into(),
                ),
                "IFC_TEMPERATURE_RATE_OF_CHANGE_MEASURE" => IfcDerivedMeasureValue::IfcTemperatureRateOfChangeMeasure(
                    typed_parameter.parameters.into_iter().next().unwrap().into(),
                ),
                "IFC_THERMAL_ADMITTANCE_MEASURE" => IfcDerivedMeasureValue::IfcThermalAdmittanceMeasure(
                    typed_parameter.parameters.into_iter().next().unwrap().into(),
                ),
                "IFC_THERMAL_CONDUCTIVITY_MEASURE" => IfcDerivedMeasureValue::IfcThermalConductivityMeasure(
                    typed_parameter.parameters.into_iter().next().unwrap().into(),
                ),
                "IFC_THERMAL_EXPANSION_COEFFICIENT_MEASURE" => {
                    IfcDerivedMeasureValue::IfcThermalExpansionCoefficientMeasure(
                        typed_parameter.parameters.into_iter().next().unwrap().into(),
                    )
                }
                "IFC_THERMAL_RESISTANCE_MEASURE" => IfcDerivedMeasureValue::IfcThermalResistanceMeasure(
                    typed_parameter.parameters.into_iter().next().unwrap().into(),
                ),
                "IFC_THERMAL_TRANSMITTANCE_MEASURE" => IfcDerivedMeasureValue::IfcThermalTransmittanceMeasure(
                    typed_parameter.parameters.into_iter().next().unwrap().into(),
                ),
                "IFC_TORQUE_MEASURE" => IfcDerivedMeasureValue::IfcTorqueMeasure(
                    typed_parameter.parameters.into_iter().next().unwrap().into(),
                ),
                "IFC_VAPOR_PERMEABILITY_MEASURE" => IfcDerivedMeasureValue::IfcVaporPermeabilityMeasure(
                    typed_parameter.parameters.into_iter().next().unwrap().into(),
                ),
                "IFC_VOLUMETRIC_FLOW_RATE_MEASURE" => IfcDerivedMeasureValue::IfcVolumetricFlowRateMeasure(
                    typed_parameter.parameters.into_iter().next().unwrap().into(),
                ),
                "IFC_WARPING_CONSTANT_MEASURE" => IfcDerivedMeasureValue::IfcWarpingConstantMeasure(
                    typed_parameter.parameters.into_iter().next().unwrap().into(),
                ),
                "IFC_WARPING_MOMENT_MEASURE" => IfcDerivedMeasureValue::IfcWarpingMomentMeasure(
                    typed_parameter.parameters.into_iter().next().unwrap().into(),
                ),
                _ => panic!("parameter type is not recognized: {}", typed_parameter.type_name),
            },
            _ => panic!("parameter is not recognized"),
        }
    }
}
#[derive(Debug)]
pub enum IfcDocumentSelect {
    EntityRef(EntityRef),
    IfcDocumentInformation(EntityRef),
    IfcDocumentReference(EntityRef),
}
impl Default for IfcDocumentSelect {
    fn default() -> Self {
        IfcDocumentSelect::IfcDocumentInformation(EntityRef::default())
    }
}
impl From<Parameter> for IfcDocumentSelect {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EntityRef(id) => IfcDocumentSelect::EntityRef(EntityRef(id)),
                _ => panic!("parameter is not an instance"),
            },
            _ => panic!("parameter is not recognized"),
        }
    }
}
#[derive(Eq, PartialEq, Hash, Debug)]
pub enum IfcFillStyleSelect {
    EntityRef(EntityRef),
    IfcColour(IfcColour),
    IfcExternallyDefinedHatchStyle(EntityRef),
    IfcFillAreaStyleHatching(EntityRef),
    IfcFillAreaStyleTiles(EntityRef),
}
impl Default for IfcFillStyleSelect {
    fn default() -> Self {
        IfcFillStyleSelect::IfcColour(IfcColour::default())
    }
}
impl From<Parameter> for IfcFillStyleSelect {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::TypedParameter(typed_parameter) => match typed_parameter.type_name.as_str() {
                "IFC_COLOUR" => {
                    IfcFillStyleSelect::IfcColour(typed_parameter.parameters.into_iter().next().unwrap().into())
                }
                _ => panic!("parameter type is not recognized: {}", typed_parameter.type_name),
            },
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EntityRef(id) => IfcFillStyleSelect::EntityRef(EntityRef(id)),
                _ => panic!("parameter is not an instance"),
            },
            _ => panic!("parameter is not recognized"),
        }
    }
}
#[derive(Eq, PartialEq, Hash, Debug)]
pub enum IfcGeometricSetSelect {
    EntityRef(EntityRef),
    IfcCurve(EntityRef),
    IfcPoint(EntityRef),
    IfcSurface(EntityRef),
}
impl Default for IfcGeometricSetSelect {
    fn default() -> Self {
        IfcGeometricSetSelect::IfcCurve(EntityRef::default())
    }
}
impl From<Parameter> for IfcGeometricSetSelect {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EntityRef(id) => IfcGeometricSetSelect::EntityRef(EntityRef(id)),
                _ => panic!("parameter is not an instance"),
            },
            _ => panic!("parameter is not recognized"),
        }
    }
}
#[derive(Debug)]
pub enum IfcGridPlacementDirectionSelect {
    EntityRef(EntityRef),
    IfcDirection(EntityRef),
    IfcVirtualGridIntersection(EntityRef),
}
impl Default for IfcGridPlacementDirectionSelect {
    fn default() -> Self {
        IfcGridPlacementDirectionSelect::IfcDirection(EntityRef::default())
    }
}
impl From<Parameter> for IfcGridPlacementDirectionSelect {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EntityRef(id) => IfcGridPlacementDirectionSelect::EntityRef(EntityRef(id)),
                _ => panic!("parameter is not an instance"),
            },
            _ => panic!("parameter is not recognized"),
        }
    }
}
#[derive(Debug)]
pub enum IfcHatchLineDistanceSelect {
    IfcPositiveLengthMeasure(IfcPositiveLengthMeasure),
    IfcVector(EntityRef),
}
impl Default for IfcHatchLineDistanceSelect {
    fn default() -> Self {
        IfcHatchLineDistanceSelect::IfcPositiveLengthMeasure(IfcPositiveLengthMeasure::default())
    }
}
impl From<Parameter> for IfcHatchLineDistanceSelect {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::TypedParameter(typed_parameter) => match typed_parameter.type_name.as_str() {
                "IFC_POSITIVE_LENGTH_MEASURE" => IfcHatchLineDistanceSelect::IfcPositiveLengthMeasure(
                    typed_parameter.parameters.into_iter().next().unwrap().into(),
                ),
                _ => panic!("parameter type is not recognized: {}", typed_parameter.type_name),
            },
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EntityRef(id) => IfcHatchLineDistanceSelect::IfcVector(EntityRef(id)),
                _ => panic!("parameter is not an instance"),
            },
            _ => panic!("parameter is not recognized"),
        }
    }
}
#[derive(Eq, PartialEq, Hash, Debug)]
pub enum IfcLayeredItem {
    EntityRef(EntityRef),
    IfcRepresentation(EntityRef),
    IfcRepresentationItem(EntityRef),
}
impl Default for IfcLayeredItem {
    fn default() -> Self {
        IfcLayeredItem::IfcRepresentation(EntityRef::default())
    }
}
impl From<Parameter> for IfcLayeredItem {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EntityRef(id) => IfcLayeredItem::EntityRef(EntityRef(id)),
                _ => panic!("parameter is not an instance"),
            },
            _ => panic!("parameter is not recognized"),
        }
    }
}
#[derive(Debug)]
pub enum IfcLibrarySelect {
    EntityRef(EntityRef),
    IfcLibraryInformation(EntityRef),
    IfcLibraryReference(EntityRef),
}
impl Default for IfcLibrarySelect {
    fn default() -> Self {
        IfcLibrarySelect::IfcLibraryInformation(EntityRef::default())
    }
}
impl From<Parameter> for IfcLibrarySelect {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EntityRef(id) => IfcLibrarySelect::EntityRef(EntityRef(id)),
                _ => panic!("parameter is not an instance"),
            },
            _ => panic!("parameter is not recognized"),
        }
    }
}
#[derive(Debug)]
pub enum IfcLightDistributionDataSourceSelect {
    EntityRef(EntityRef),
    IfcExternalReference(EntityRef),
    IfcLightIntensityDistribution(EntityRef),
}
impl Default for IfcLightDistributionDataSourceSelect {
    fn default() -> Self {
        IfcLightDistributionDataSourceSelect::IfcExternalReference(EntityRef::default())
    }
}
impl From<Parameter> for IfcLightDistributionDataSourceSelect {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EntityRef(id) => IfcLightDistributionDataSourceSelect::EntityRef(EntityRef(id)),
                _ => panic!("parameter is not an instance"),
            },
            _ => panic!("parameter is not recognized"),
        }
    }
}
#[derive(Debug)]
pub enum IfcMaterialSelect {
    EntityRef(EntityRef),
    IfcMaterialDefinition(EntityRef),
    IfcMaterialList(EntityRef),
    IfcMaterialUsageDefinition(EntityRef),
}
impl Default for IfcMaterialSelect {
    fn default() -> Self {
        IfcMaterialSelect::IfcMaterialDefinition(EntityRef::default())
    }
}
impl From<Parameter> for IfcMaterialSelect {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EntityRef(id) => IfcMaterialSelect::EntityRef(EntityRef(id)),
                _ => panic!("parameter is not an instance"),
            },
            _ => panic!("parameter is not recognized"),
        }
    }
}
#[derive(Debug)]
pub enum IfcMeasureValue {
    IfcAmountOfSubstanceMeasure(IfcAmountOfSubstanceMeasure),
    IfcAreaMeasure(IfcAreaMeasure),
    IfcComplexNumber(IfcComplexNumber),
    IfcContextDependentMeasure(IfcContextDependentMeasure),
    IfcCountMeasure(IfcCountMeasure),
    IfcDescriptiveMeasure(IfcDescriptiveMeasure),
    IfcElectricCurrentMeasure(IfcElectricCurrentMeasure),
    IfcLengthMeasure(IfcLengthMeasure),
    IfcLuminousIntensityMeasure(IfcLuminousIntensityMeasure),
    IfcMassMeasure(IfcMassMeasure),
    IfcNonNegativeLengthMeasure(IfcNonNegativeLengthMeasure),
    IfcNormalisedRatioMeasure(IfcNormalisedRatioMeasure),
    IfcNumericMeasure(IfcNumericMeasure),
    IfcParameterValue(IfcParameterValue),
    IfcPlaneAngleMeasure(IfcPlaneAngleMeasure),
    IfcPositiveLengthMeasure(IfcPositiveLengthMeasure),
    IfcPositivePlaneAngleMeasure(IfcPositivePlaneAngleMeasure),
    IfcPositiveRatioMeasure(IfcPositiveRatioMeasure),
    IfcRatioMeasure(IfcRatioMeasure),
    IfcSolidAngleMeasure(IfcSolidAngleMeasure),
    IfcThermodynamicTemperatureMeasure(IfcThermodynamicTemperatureMeasure),
    IfcTimeMeasure(IfcTimeMeasure),
    IfcVolumeMeasure(IfcVolumeMeasure),
}
impl Default for IfcMeasureValue {
    fn default() -> Self {
        IfcMeasureValue::IfcAmountOfSubstanceMeasure(IfcAmountOfSubstanceMeasure::default())
    }
}
impl From<Parameter> for IfcMeasureValue {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::TypedParameter(typed_parameter) => match typed_parameter.type_name.as_str() {
                "IFC_AMOUNT_OF_SUBSTANCE_MEASURE" => IfcMeasureValue::IfcAmountOfSubstanceMeasure(
                    typed_parameter.parameters.into_iter().next().unwrap().into(),
                ),
                "IFC_AREA_MEASURE" => {
                    IfcMeasureValue::IfcAreaMeasure(typed_parameter.parameters.into_iter().next().unwrap().into())
                }
                "IFC_COMPLEX_NUMBER" => {
                    IfcMeasureValue::IfcComplexNumber(typed_parameter.parameters.into_iter().next().unwrap().into())
                }
                "IFC_CONTEXT_DEPENDENT_MEASURE" => IfcMeasureValue::IfcContextDependentMeasure(
                    typed_parameter.parameters.into_iter().next().unwrap().into(),
                ),
                "IFC_COUNT_MEASURE" => {
                    IfcMeasureValue::IfcCountMeasure(typed_parameter.parameters.into_iter().next().unwrap().into())
                }
                "IFC_DESCRIPTIVE_MEASURE" => IfcMeasureValue::IfcDescriptiveMeasure(
                    typed_parameter.parameters.into_iter().next().unwrap().into(),
                ),
                "IFC_ELECTRIC_CURRENT_MEASURE" => IfcMeasureValue::IfcElectricCurrentMeasure(
                    typed_parameter.parameters.into_iter().next().unwrap().into(),
                ),
                "IFC_LENGTH_MEASURE" => {
                    IfcMeasureValue::IfcLengthMeasure(typed_parameter.parameters.into_iter().next().unwrap().into())
                }
                "IFC_LUMINOUS_INTENSITY_MEASURE" => IfcMeasureValue::IfcLuminousIntensityMeasure(
                    typed_parameter.parameters.into_iter().next().unwrap().into(),
                ),
                "IFC_MASS_MEASURE" => {
                    IfcMeasureValue::IfcMassMeasure(typed_parameter.parameters.into_iter().next().unwrap().into())
                }
                "IFC_NON_NEGATIVE_LENGTH_MEASURE" => IfcMeasureValue::IfcNonNegativeLengthMeasure(
                    typed_parameter.parameters.into_iter().next().unwrap().into(),
                ),
                "IFC_NORMALISED_RATIO_MEASURE" => IfcMeasureValue::IfcNormalisedRatioMeasure(
                    typed_parameter.parameters.into_iter().next().unwrap().into(),
                ),
                "IFC_NUMERIC_MEASURE" => {
                    IfcMeasureValue::IfcNumericMeasure(typed_parameter.parameters.into_iter().next().unwrap().into())
                }
                "IFC_PARAMETER_VALUE" => {
                    IfcMeasureValue::IfcParameterValue(typed_parameter.parameters.into_iter().next().unwrap().into())
                }
                "IFC_PLANE_ANGLE_MEASURE" => {
                    IfcMeasureValue::IfcPlaneAngleMeasure(typed_parameter.parameters.into_iter().next().unwrap().into())
                }
                "IFC_POSITIVE_LENGTH_MEASURE" => IfcMeasureValue::IfcPositiveLengthMeasure(
                    typed_parameter.parameters.into_iter().next().unwrap().into(),
                ),
                "IFC_POSITIVE_PLANE_ANGLE_MEASURE" => IfcMeasureValue::IfcPositivePlaneAngleMeasure(
                    typed_parameter.parameters.into_iter().next().unwrap().into(),
                ),
                "IFC_POSITIVE_RATIO_MEASURE" => IfcMeasureValue::IfcPositiveRatioMeasure(
                    typed_parameter.parameters.into_iter().next().unwrap().into(),
                ),
                "IFC_RATIO_MEASURE" => {
                    IfcMeasureValue::IfcRatioMeasure(typed_parameter.parameters.into_iter().next().unwrap().into())
                }
                "IFC_SOLID_ANGLE_MEASURE" => {
                    IfcMeasureValue::IfcSolidAngleMeasure(typed_parameter.parameters.into_iter().next().unwrap().into())
                }
                "IFC_THERMODYNAMIC_TEMPERATURE_MEASURE" => IfcMeasureValue::IfcThermodynamicTemperatureMeasure(
                    typed_parameter.parameters.into_iter().next().unwrap().into(),
                ),
                "IFC_TIME_MEASURE" => {
                    IfcMeasureValue::IfcTimeMeasure(typed_parameter.parameters.into_iter().next().unwrap().into())
                }
                "IFC_VOLUME_MEASURE" => {
                    IfcMeasureValue::IfcVolumeMeasure(typed_parameter.parameters.into_iter().next().unwrap().into())
                }
                _ => panic!("parameter type is not recognized: {}", typed_parameter.type_name),
            },
            _ => panic!("parameter is not recognized"),
        }
    }
}
#[derive(Debug)]
pub enum IfcMetricValueSelect {
    EntityRef(EntityRef),
    IfcAppliedValue(EntityRef),
    IfcMeasureWithUnit(EntityRef),
    IfcReference(EntityRef),
    IfcTable(EntityRef),
    IfcTimeSeries(EntityRef),
    IfcValue(IfcValue),
}
impl Default for IfcMetricValueSelect {
    fn default() -> Self {
        IfcMetricValueSelect::IfcAppliedValue(EntityRef::default())
    }
}
impl From<Parameter> for IfcMetricValueSelect {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::TypedParameter(typed_parameter) => match typed_parameter.type_name.as_str() {
                "IFC_VALUE" => {
                    IfcMetricValueSelect::IfcValue(typed_parameter.parameters.into_iter().next().unwrap().into())
                }
                _ => panic!("parameter type is not recognized: {}", typed_parameter.type_name),
            },
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EntityRef(id) => IfcMetricValueSelect::EntityRef(EntityRef(id)),
                _ => panic!("parameter is not an instance"),
            },
            _ => panic!("parameter is not recognized"),
        }
    }
}
#[derive(Debug)]
pub enum IfcModulusOfRotationalSubgradeReactionSelect {
    IfcBoolean(IfcBoolean),
    IfcModulusOfRotationalSubgradeReactionMeasure(IfcModulusOfRotationalSubgradeReactionMeasure),
}
impl Default for IfcModulusOfRotationalSubgradeReactionSelect {
    fn default() -> Self {
        IfcModulusOfRotationalSubgradeReactionSelect::IfcBoolean(IfcBoolean::default())
    }
}
impl From<Parameter> for IfcModulusOfRotationalSubgradeReactionSelect {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::TypedParameter(typed_parameter) => match typed_parameter.type_name.as_str() {
                "IFC_BOOLEAN" => IfcModulusOfRotationalSubgradeReactionSelect::IfcBoolean(
                    typed_parameter.parameters.into_iter().next().unwrap().into(),
                ),
                "IFC_MODULUS_OF_ROTATIONAL_SUBGRADE_REACTION_MEASURE" => {
                    IfcModulusOfRotationalSubgradeReactionSelect::IfcModulusOfRotationalSubgradeReactionMeasure(
                        typed_parameter.parameters.into_iter().next().unwrap().into(),
                    )
                }
                _ => panic!("parameter type is not recognized: {}", typed_parameter.type_name),
            },
            _ => panic!("parameter is not recognized"),
        }
    }
}
#[derive(Debug)]
pub enum IfcModulusOfSubgradeReactionSelect {
    IfcBoolean(IfcBoolean),
    IfcModulusOfSubgradeReactionMeasure(IfcModulusOfSubgradeReactionMeasure),
}
impl Default for IfcModulusOfSubgradeReactionSelect {
    fn default() -> Self {
        IfcModulusOfSubgradeReactionSelect::IfcBoolean(IfcBoolean::default())
    }
}
impl From<Parameter> for IfcModulusOfSubgradeReactionSelect {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::TypedParameter(typed_parameter) => match typed_parameter.type_name.as_str() {
                "IFC_BOOLEAN" => IfcModulusOfSubgradeReactionSelect::IfcBoolean(
                    typed_parameter.parameters.into_iter().next().unwrap().into(),
                ),
                "IFC_MODULUS_OF_SUBGRADE_REACTION_MEASURE" => {
                    IfcModulusOfSubgradeReactionSelect::IfcModulusOfSubgradeReactionMeasure(
                        typed_parameter.parameters.into_iter().next().unwrap().into(),
                    )
                }
                _ => panic!("parameter type is not recognized: {}", typed_parameter.type_name),
            },
            _ => panic!("parameter is not recognized"),
        }
    }
}
#[derive(Debug)]
pub enum IfcModulusOfTranslationalSubgradeReactionSelect {
    IfcBoolean(IfcBoolean),
    IfcModulusOfLinearSubgradeReactionMeasure(IfcModulusOfLinearSubgradeReactionMeasure),
}
impl Default for IfcModulusOfTranslationalSubgradeReactionSelect {
    fn default() -> Self {
        IfcModulusOfTranslationalSubgradeReactionSelect::IfcBoolean(IfcBoolean::default())
    }
}
impl From<Parameter> for IfcModulusOfTranslationalSubgradeReactionSelect {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::TypedParameter(typed_parameter) => match typed_parameter.type_name.as_str() {
                "IFC_BOOLEAN" => IfcModulusOfTranslationalSubgradeReactionSelect::IfcBoolean(
                    typed_parameter.parameters.into_iter().next().unwrap().into(),
                ),
                "IFC_MODULUS_OF_LINEAR_SUBGRADE_REACTION_MEASURE" => {
                    IfcModulusOfTranslationalSubgradeReactionSelect::IfcModulusOfLinearSubgradeReactionMeasure(
                        typed_parameter.parameters.into_iter().next().unwrap().into(),
                    )
                }
                _ => panic!("parameter type is not recognized: {}", typed_parameter.type_name),
            },
            _ => panic!("parameter is not recognized"),
        }
    }
}
#[derive(Debug)]
pub enum IfcObjectReferenceSelect {
    EntityRef(EntityRef),
    IfcAddress(EntityRef),
    IfcAppliedValue(EntityRef),
    IfcExternalReference(EntityRef),
    IfcMaterialDefinition(EntityRef),
    IfcOrganization(EntityRef),
    IfcPerson(EntityRef),
    IfcPersonAndOrganization(EntityRef),
    IfcTable(EntityRef),
    IfcTimeSeries(EntityRef),
}
impl Default for IfcObjectReferenceSelect {
    fn default() -> Self {
        IfcObjectReferenceSelect::IfcAddress(EntityRef::default())
    }
}
impl From<Parameter> for IfcObjectReferenceSelect {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EntityRef(id) => IfcObjectReferenceSelect::EntityRef(EntityRef(id)),
                _ => panic!("parameter is not an instance"),
            },
            _ => panic!("parameter is not recognized"),
        }
    }
}
#[derive(Debug)]
pub enum IfcPointOrVertexPoint {
    EntityRef(EntityRef),
    IfcPoint(EntityRef),
    IfcVertexPoint(EntityRef),
}
impl Default for IfcPointOrVertexPoint {
    fn default() -> Self {
        IfcPointOrVertexPoint::IfcPoint(EntityRef::default())
    }
}
impl From<Parameter> for IfcPointOrVertexPoint {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EntityRef(id) => IfcPointOrVertexPoint::EntityRef(EntityRef(id)),
                _ => panic!("parameter is not an instance"),
            },
            _ => panic!("parameter is not recognized"),
        }
    }
}
#[derive(Eq, PartialEq, Hash, Debug)]
pub enum IfcPresentationStyleSelect {
    EntityRef(EntityRef),
    IfcCurveStyle(EntityRef),
    IfcFillAreaStyle(EntityRef),
    IfcNullStyle(IfcNullStyle),
    IfcSurfaceStyle(EntityRef),
    IfcTextStyle(EntityRef),
}
impl Default for IfcPresentationStyleSelect {
    fn default() -> Self {
        IfcPresentationStyleSelect::IfcCurveStyle(EntityRef::default())
    }
}
impl From<Parameter> for IfcPresentationStyleSelect {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::TypedParameter(typed_parameter) => match typed_parameter.type_name.as_str() {
                "IFC_NULL_STYLE" => IfcPresentationStyleSelect::IfcNullStyle(
                    typed_parameter.parameters.into_iter().next().unwrap().into(),
                ),
                _ => panic!("parameter type is not recognized: {}", typed_parameter.type_name),
            },
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EntityRef(id) => IfcPresentationStyleSelect::EntityRef(EntityRef(id)),
                _ => panic!("parameter is not an instance"),
            },
            _ => panic!("parameter is not recognized"),
        }
    }
}
#[derive(Debug)]
pub enum IfcProcessSelect {
    EntityRef(EntityRef),
    IfcProcess(EntityRef),
    IfcTypeProcess(EntityRef),
}
impl Default for IfcProcessSelect {
    fn default() -> Self {
        IfcProcessSelect::IfcProcess(EntityRef::default())
    }
}
impl From<Parameter> for IfcProcessSelect {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EntityRef(id) => IfcProcessSelect::EntityRef(EntityRef(id)),
                _ => panic!("parameter is not an instance"),
            },
            _ => panic!("parameter is not recognized"),
        }
    }
}
#[derive(Debug)]
pub enum IfcProductRepresentationSelect {
    EntityRef(EntityRef),
    IfcProductDefinitionShape(EntityRef),
    IfcRepresentationMap(EntityRef),
}
impl Default for IfcProductRepresentationSelect {
    fn default() -> Self {
        IfcProductRepresentationSelect::IfcProductDefinitionShape(EntityRef::default())
    }
}
impl From<Parameter> for IfcProductRepresentationSelect {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EntityRef(id) => IfcProductRepresentationSelect::EntityRef(EntityRef(id)),
                _ => panic!("parameter is not an instance"),
            },
            _ => panic!("parameter is not recognized"),
        }
    }
}
#[derive(Debug)]
pub enum IfcProductSelect {
    EntityRef(EntityRef),
    IfcProduct(EntityRef),
    IfcTypeProduct(EntityRef),
}
impl Default for IfcProductSelect {
    fn default() -> Self {
        IfcProductSelect::IfcProduct(EntityRef::default())
    }
}
impl From<Parameter> for IfcProductSelect {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EntityRef(id) => IfcProductSelect::EntityRef(EntityRef(id)),
                _ => panic!("parameter is not an instance"),
            },
            _ => panic!("parameter is not recognized"),
        }
    }
}
#[derive(Debug)]
pub enum IfcPropertySetDefinitionSelect {
    IfcPropertySetDefinition(EntityRef),
    IfcPropertySetDefinitionSet(IfcPropertySetDefinitionSet),
}
impl Default for IfcPropertySetDefinitionSelect {
    fn default() -> Self {
        IfcPropertySetDefinitionSelect::IfcPropertySetDefinition(EntityRef::default())
    }
}
impl From<Parameter> for IfcPropertySetDefinitionSelect {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::TypedParameter(typed_parameter) => match typed_parameter.type_name.as_str() {
                "IFC_PROPERTY_SET_DEFINITION_SET" => IfcPropertySetDefinitionSelect::IfcPropertySetDefinitionSet(
                    typed_parameter.parameters.into_iter().next().unwrap().into(),
                ),
                _ => panic!("parameter type is not recognized: {}", typed_parameter.type_name),
            },
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EntityRef(id) => {
                    IfcPropertySetDefinitionSelect::IfcPropertySetDefinition(EntityRef(id))
                }
                _ => panic!("parameter is not an instance"),
            },
            _ => panic!("parameter is not recognized"),
        }
    }
}
#[derive(Eq, PartialEq, Hash, Debug)]
pub enum IfcResourceObjectSelect {
    EntityRef(EntityRef),
    IfcActorRole(EntityRef),
    IfcAppliedValue(EntityRef),
    IfcApproval(EntityRef),
    IfcConstraint(EntityRef),
    IfcContextDependentUnit(EntityRef),
    IfcConversionBasedUnit(EntityRef),
    IfcExternalInformation(EntityRef),
    IfcExternalReference(EntityRef),
    IfcMaterialDefinition(EntityRef),
    IfcOrganization(EntityRef),
    IfcPerson(EntityRef),
    IfcPersonAndOrganization(EntityRef),
    IfcPhysicalQuantity(EntityRef),
    IfcProfileDef(EntityRef),
    IfcPropertyAbstraction(EntityRef),
    IfcTimeSeries(EntityRef),
}
impl Default for IfcResourceObjectSelect {
    fn default() -> Self {
        IfcResourceObjectSelect::IfcActorRole(EntityRef::default())
    }
}
impl From<Parameter> for IfcResourceObjectSelect {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EntityRef(id) => IfcResourceObjectSelect::EntityRef(EntityRef(id)),
                _ => panic!("parameter is not an instance"),
            },
            _ => panic!("parameter is not recognized"),
        }
    }
}
#[derive(Debug)]
pub enum IfcResourceSelect {
    EntityRef(EntityRef),
    IfcResource(EntityRef),
    IfcTypeResource(EntityRef),
}
impl Default for IfcResourceSelect {
    fn default() -> Self {
        IfcResourceSelect::IfcResource(EntityRef::default())
    }
}
impl From<Parameter> for IfcResourceSelect {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EntityRef(id) => IfcResourceSelect::EntityRef(EntityRef(id)),
                _ => panic!("parameter is not an instance"),
            },
            _ => panic!("parameter is not recognized"),
        }
    }
}
#[derive(Debug)]
pub enum IfcRotationalStiffnessSelect {
    IfcBoolean(IfcBoolean),
    IfcRotationalStiffnessMeasure(IfcRotationalStiffnessMeasure),
}
impl Default for IfcRotationalStiffnessSelect {
    fn default() -> Self {
        IfcRotationalStiffnessSelect::IfcBoolean(IfcBoolean::default())
    }
}
impl From<Parameter> for IfcRotationalStiffnessSelect {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::TypedParameter(typed_parameter) => match typed_parameter.type_name.as_str() {
                "IFC_BOOLEAN" => IfcRotationalStiffnessSelect::IfcBoolean(
                    typed_parameter.parameters.into_iter().next().unwrap().into(),
                ),
                "IFC_ROTATIONAL_STIFFNESS_MEASURE" => IfcRotationalStiffnessSelect::IfcRotationalStiffnessMeasure(
                    typed_parameter.parameters.into_iter().next().unwrap().into(),
                ),
                _ => panic!("parameter type is not recognized: {}", typed_parameter.type_name),
            },
            _ => panic!("parameter is not recognized"),
        }
    }
}
#[derive(Debug)]
pub enum IfcSegmentIndexSelect {
    IfcArcIndex(IfcArcIndex),
    IfcLineIndex(IfcLineIndex),
}
impl Default for IfcSegmentIndexSelect {
    fn default() -> Self {
        IfcSegmentIndexSelect::IfcArcIndex(IfcArcIndex::default())
    }
}
impl From<Parameter> for IfcSegmentIndexSelect {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::TypedParameter(typed_parameter) => match typed_parameter.type_name.as_str() {
                "IFC_ARC_INDEX" => {
                    IfcSegmentIndexSelect::IfcArcIndex(typed_parameter.parameters.into_iter().next().unwrap().into())
                }
                "IFC_LINE_INDEX" => {
                    IfcSegmentIndexSelect::IfcLineIndex(typed_parameter.parameters.into_iter().next().unwrap().into())
                }
                _ => panic!("parameter type is not recognized: {}", typed_parameter.type_name),
            },
            _ => panic!("parameter is not recognized"),
        }
    }
}
#[derive(Eq, PartialEq, Hash, Debug)]
pub enum IfcShell {
    EntityRef(EntityRef),
    IfcClosedShell(EntityRef),
    IfcOpenShell(EntityRef),
}
impl Default for IfcShell {
    fn default() -> Self {
        IfcShell::IfcClosedShell(EntityRef::default())
    }
}
impl From<Parameter> for IfcShell {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EntityRef(id) => IfcShell::EntityRef(EntityRef(id)),
                _ => panic!("parameter is not an instance"),
            },
            _ => panic!("parameter is not recognized"),
        }
    }
}
#[derive(Debug)]
pub enum IfcSimpleValue {
    IfcBinary(IfcBinary),
    IfcBoolean(IfcBoolean),
    IfcDate(IfcDate),
    IfcDateTime(IfcDateTime),
    IfcDuration(IfcDuration),
    IfcIdentifier(IfcIdentifier),
    IfcInteger(IfcInteger),
    IfcLabel(IfcLabel),
    IfcLogical(IfcLogical),
    IfcPositiveInteger(IfcPositiveInteger),
    IfcReal(IfcReal),
    IfcText(IfcText),
    IfcTime(IfcTime),
    IfcTimeStamp(IfcTimeStamp),
}
impl Default for IfcSimpleValue {
    fn default() -> Self {
        IfcSimpleValue::IfcBinary(IfcBinary::default())
    }
}
impl From<Parameter> for IfcSimpleValue {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::TypedParameter(typed_parameter) => match typed_parameter.type_name.as_str() {
                "IFC_BINARY" => {
                    IfcSimpleValue::IfcBinary(typed_parameter.parameters.into_iter().next().unwrap().into())
                }
                "IFC_BOOLEAN" => {
                    IfcSimpleValue::IfcBoolean(typed_parameter.parameters.into_iter().next().unwrap().into())
                }
                "IFC_DATE" => IfcSimpleValue::IfcDate(typed_parameter.parameters.into_iter().next().unwrap().into()),
                "IFC_DATE_TIME" => {
                    IfcSimpleValue::IfcDateTime(typed_parameter.parameters.into_iter().next().unwrap().into())
                }
                "IFC_DURATION" => {
                    IfcSimpleValue::IfcDuration(typed_parameter.parameters.into_iter().next().unwrap().into())
                }
                "IFC_IDENTIFIER" => {
                    IfcSimpleValue::IfcIdentifier(typed_parameter.parameters.into_iter().next().unwrap().into())
                }
                "IFC_INTEGER" => {
                    IfcSimpleValue::IfcInteger(typed_parameter.parameters.into_iter().next().unwrap().into())
                }
                "IFC_LABEL" => IfcSimpleValue::IfcLabel(typed_parameter.parameters.into_iter().next().unwrap().into()),
                "IFC_LOGICAL" => {
                    IfcSimpleValue::IfcLogical(typed_parameter.parameters.into_iter().next().unwrap().into())
                }
                "IFC_POSITIVE_INTEGER" => {
                    IfcSimpleValue::IfcPositiveInteger(typed_parameter.parameters.into_iter().next().unwrap().into())
                }
                "IFC_REAL" => IfcSimpleValue::IfcReal(typed_parameter.parameters.into_iter().next().unwrap().into()),
                "IFC_TEXT" => IfcSimpleValue::IfcText(typed_parameter.parameters.into_iter().next().unwrap().into()),
                "IFC_TIME" => IfcSimpleValue::IfcTime(typed_parameter.parameters.into_iter().next().unwrap().into()),
                "IFC_TIME_STAMP" => {
                    IfcSimpleValue::IfcTimeStamp(typed_parameter.parameters.into_iter().next().unwrap().into())
                }
                _ => panic!("parameter type is not recognized: {}", typed_parameter.type_name),
            },
            _ => panic!("parameter is not recognized"),
        }
    }
}
#[derive(Debug)]
pub enum IfcSizeSelect {
    IfcDescriptiveMeasure(IfcDescriptiveMeasure),
    IfcLengthMeasure(IfcLengthMeasure),
    IfcNormalisedRatioMeasure(IfcNormalisedRatioMeasure),
    IfcPositiveLengthMeasure(IfcPositiveLengthMeasure),
    IfcPositiveRatioMeasure(IfcPositiveRatioMeasure),
    IfcRatioMeasure(IfcRatioMeasure),
}
impl Default for IfcSizeSelect {
    fn default() -> Self {
        IfcSizeSelect::IfcDescriptiveMeasure(IfcDescriptiveMeasure::default())
    }
}
impl From<Parameter> for IfcSizeSelect {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::TypedParameter(typed_parameter) => match typed_parameter.type_name.as_str() {
                "IFC_DESCRIPTIVE_MEASURE" => {
                    IfcSizeSelect::IfcDescriptiveMeasure(typed_parameter.parameters.into_iter().next().unwrap().into())
                }
                "IFC_LENGTH_MEASURE" => {
                    IfcSizeSelect::IfcLengthMeasure(typed_parameter.parameters.into_iter().next().unwrap().into())
                }
                "IFC_NORMALISED_RATIO_MEASURE" => IfcSizeSelect::IfcNormalisedRatioMeasure(
                    typed_parameter.parameters.into_iter().next().unwrap().into(),
                ),
                "IFC_POSITIVE_LENGTH_MEASURE" => IfcSizeSelect::IfcPositiveLengthMeasure(
                    typed_parameter.parameters.into_iter().next().unwrap().into(),
                ),
                "IFC_POSITIVE_RATIO_MEASURE" => IfcSizeSelect::IfcPositiveRatioMeasure(
                    typed_parameter.parameters.into_iter().next().unwrap().into(),
                ),
                "IFC_RATIO_MEASURE" => {
                    IfcSizeSelect::IfcRatioMeasure(typed_parameter.parameters.into_iter().next().unwrap().into())
                }
                _ => panic!("parameter type is not recognized: {}", typed_parameter.type_name),
            },
            _ => panic!("parameter is not recognized"),
        }
    }
}
#[derive(Debug)]
pub enum IfcSolidOrShell {
    EntityRef(EntityRef),
    IfcClosedShell(EntityRef),
    IfcSolidModel(EntityRef),
}
impl Default for IfcSolidOrShell {
    fn default() -> Self {
        IfcSolidOrShell::IfcClosedShell(EntityRef::default())
    }
}
impl From<Parameter> for IfcSolidOrShell {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EntityRef(id) => IfcSolidOrShell::EntityRef(EntityRef(id)),
                _ => panic!("parameter is not an instance"),
            },
            _ => panic!("parameter is not recognized"),
        }
    }
}
#[derive(Debug)]
pub enum IfcSpaceBoundarySelect {
    EntityRef(EntityRef),
    IfcExternalSpatialElement(EntityRef),
    IfcSpace(EntityRef),
}
impl Default for IfcSpaceBoundarySelect {
    fn default() -> Self {
        IfcSpaceBoundarySelect::IfcExternalSpatialElement(EntityRef::default())
    }
}
impl From<Parameter> for IfcSpaceBoundarySelect {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EntityRef(id) => IfcSpaceBoundarySelect::EntityRef(EntityRef(id)),
                _ => panic!("parameter is not an instance"),
            },
            _ => panic!("parameter is not recognized"),
        }
    }
}
#[derive(Debug)]
pub enum IfcSpecularHighlightSelect {
    IfcSpecularExponent(IfcSpecularExponent),
    IfcSpecularRoughness(IfcSpecularRoughness),
}
impl Default for IfcSpecularHighlightSelect {
    fn default() -> Self {
        IfcSpecularHighlightSelect::IfcSpecularExponent(IfcSpecularExponent::default())
    }
}
impl From<Parameter> for IfcSpecularHighlightSelect {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::TypedParameter(typed_parameter) => match typed_parameter.type_name.as_str() {
                "IFC_SPECULAR_EXPONENT" => IfcSpecularHighlightSelect::IfcSpecularExponent(
                    typed_parameter.parameters.into_iter().next().unwrap().into(),
                ),
                "IFC_SPECULAR_ROUGHNESS" => IfcSpecularHighlightSelect::IfcSpecularRoughness(
                    typed_parameter.parameters.into_iter().next().unwrap().into(),
                ),
                _ => panic!("parameter type is not recognized: {}", typed_parameter.type_name),
            },
            _ => panic!("parameter is not recognized"),
        }
    }
}
#[derive(Debug)]
pub enum IfcStructuralActivityAssignmentSelect {
    EntityRef(EntityRef),
    IfcElement(EntityRef),
    IfcStructuralItem(EntityRef),
}
impl Default for IfcStructuralActivityAssignmentSelect {
    fn default() -> Self {
        IfcStructuralActivityAssignmentSelect::IfcElement(EntityRef::default())
    }
}
impl From<Parameter> for IfcStructuralActivityAssignmentSelect {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EntityRef(id) => IfcStructuralActivityAssignmentSelect::EntityRef(EntityRef(id)),
                _ => panic!("parameter is not an instance"),
            },
            _ => panic!("parameter is not recognized"),
        }
    }
}
#[derive(Eq, PartialEq, Hash, Debug)]
pub enum IfcStyleAssignmentSelect {
    EntityRef(EntityRef),
    IfcPresentationStyle(EntityRef),
    IfcPresentationStyleAssignment(EntityRef),
}
impl Default for IfcStyleAssignmentSelect {
    fn default() -> Self {
        IfcStyleAssignmentSelect::IfcPresentationStyle(EntityRef::default())
    }
}
impl From<Parameter> for IfcStyleAssignmentSelect {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EntityRef(id) => IfcStyleAssignmentSelect::EntityRef(EntityRef(id)),
                _ => panic!("parameter is not an instance"),
            },
            _ => panic!("parameter is not recognized"),
        }
    }
}
#[derive(Debug)]
pub enum IfcSurfaceOrFaceSurface {
    EntityRef(EntityRef),
    IfcFaceBasedSurfaceModel(EntityRef),
    IfcFaceSurface(EntityRef),
    IfcSurface(EntityRef),
}
impl Default for IfcSurfaceOrFaceSurface {
    fn default() -> Self {
        IfcSurfaceOrFaceSurface::IfcFaceBasedSurfaceModel(EntityRef::default())
    }
}
impl From<Parameter> for IfcSurfaceOrFaceSurface {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EntityRef(id) => IfcSurfaceOrFaceSurface::EntityRef(EntityRef(id)),
                _ => panic!("parameter is not an instance"),
            },
            _ => panic!("parameter is not recognized"),
        }
    }
}
#[derive(Eq, PartialEq, Hash, Debug)]
pub enum IfcSurfaceStyleElementSelect {
    EntityRef(EntityRef),
    IfcExternallyDefinedSurfaceStyle(EntityRef),
    IfcSurfaceStyleLighting(EntityRef),
    IfcSurfaceStyleRefraction(EntityRef),
    IfcSurfaceStyleShading(EntityRef),
    IfcSurfaceStyleWithTextures(EntityRef),
}
impl Default for IfcSurfaceStyleElementSelect {
    fn default() -> Self {
        IfcSurfaceStyleElementSelect::IfcExternallyDefinedSurfaceStyle(EntityRef::default())
    }
}
impl From<Parameter> for IfcSurfaceStyleElementSelect {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EntityRef(id) => IfcSurfaceStyleElementSelect::EntityRef(EntityRef(id)),
                _ => panic!("parameter is not an instance"),
            },
            _ => panic!("parameter is not recognized"),
        }
    }
}
#[derive(Debug)]
pub enum IfcTextFontSelect {
    EntityRef(EntityRef),
    IfcExternallyDefinedTextFont(EntityRef),
    IfcPreDefinedTextFont(EntityRef),
}
impl Default for IfcTextFontSelect {
    fn default() -> Self {
        IfcTextFontSelect::IfcExternallyDefinedTextFont(EntityRef::default())
    }
}
impl From<Parameter> for IfcTextFontSelect {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EntityRef(id) => IfcTextFontSelect::EntityRef(EntityRef(id)),
                _ => panic!("parameter is not an instance"),
            },
            _ => panic!("parameter is not recognized"),
        }
    }
}
#[derive(Debug)]
pub enum IfcTimeOrRatioSelect {
    IfcDuration(IfcDuration),
    IfcRatioMeasure(IfcRatioMeasure),
}
impl Default for IfcTimeOrRatioSelect {
    fn default() -> Self {
        IfcTimeOrRatioSelect::IfcDuration(IfcDuration::default())
    }
}
impl From<Parameter> for IfcTimeOrRatioSelect {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::TypedParameter(typed_parameter) => match typed_parameter.type_name.as_str() {
                "IFC_DURATION" => {
                    IfcTimeOrRatioSelect::IfcDuration(typed_parameter.parameters.into_iter().next().unwrap().into())
                }
                "IFC_RATIO_MEASURE" => {
                    IfcTimeOrRatioSelect::IfcRatioMeasure(typed_parameter.parameters.into_iter().next().unwrap().into())
                }
                _ => panic!("parameter type is not recognized: {}", typed_parameter.type_name),
            },
            _ => panic!("parameter is not recognized"),
        }
    }
}
#[derive(Debug)]
pub enum IfcTranslationalStiffnessSelect {
    IfcBoolean(IfcBoolean),
    IfcLinearStiffnessMeasure(IfcLinearStiffnessMeasure),
}
impl Default for IfcTranslationalStiffnessSelect {
    fn default() -> Self {
        IfcTranslationalStiffnessSelect::IfcBoolean(IfcBoolean::default())
    }
}
impl From<Parameter> for IfcTranslationalStiffnessSelect {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::TypedParameter(typed_parameter) => match typed_parameter.type_name.as_str() {
                "IFC_BOOLEAN" => IfcTranslationalStiffnessSelect::IfcBoolean(
                    typed_parameter.parameters.into_iter().next().unwrap().into(),
                ),
                "IFC_LINEAR_STIFFNESS_MEASURE" => IfcTranslationalStiffnessSelect::IfcLinearStiffnessMeasure(
                    typed_parameter.parameters.into_iter().next().unwrap().into(),
                ),
                _ => panic!("parameter type is not recognized: {}", typed_parameter.type_name),
            },
            _ => panic!("parameter is not recognized"),
        }
    }
}
#[derive(Eq, PartialEq, Hash, Debug)]
pub enum IfcTrimmingSelect {
    IfcCartesianPoint(EntityRef),
    IfcParameterValue(IfcParameterValue),
}
impl Default for IfcTrimmingSelect {
    fn default() -> Self {
        IfcTrimmingSelect::IfcCartesianPoint(EntityRef::default())
    }
}
impl From<Parameter> for IfcTrimmingSelect {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::TypedParameter(typed_parameter) => match typed_parameter.type_name.as_str() {
                "IFC_PARAMETER_VALUE" => {
                    IfcTrimmingSelect::IfcParameterValue(typed_parameter.parameters.into_iter().next().unwrap().into())
                }
                _ => panic!("parameter type is not recognized: {}", typed_parameter.type_name),
            },
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EntityRef(id) => IfcTrimmingSelect::IfcCartesianPoint(EntityRef(id)),
                _ => panic!("parameter is not an instance"),
            },
            _ => panic!("parameter is not recognized"),
        }
    }
}
#[derive(Eq, PartialEq, Hash, Debug)]
pub enum IfcUnit {
    EntityRef(EntityRef),
    IfcDerivedUnit(EntityRef),
    IfcMonetaryUnit(EntityRef),
    IfcNamedUnit(EntityRef),
}
impl Default for IfcUnit {
    fn default() -> Self {
        IfcUnit::IfcDerivedUnit(EntityRef::default())
    }
}
impl From<Parameter> for IfcUnit {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EntityRef(id) => IfcUnit::EntityRef(EntityRef(id)),
                _ => panic!("parameter is not an instance"),
            },
            _ => panic!("parameter is not recognized"),
        }
    }
}
#[derive(Debug)]
pub enum IfcValue {
    IfcDerivedMeasureValue(IfcDerivedMeasureValue),
    IfcMeasureValue(IfcMeasureValue),
    IfcSimpleValue(IfcSimpleValue),
}
impl Default for IfcValue {
    fn default() -> Self {
        IfcValue::IfcDerivedMeasureValue(IfcDerivedMeasureValue::default())
    }
}
impl From<Parameter> for IfcValue {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::TypedParameter(typed_parameter) => match typed_parameter.type_name.as_str() {
                "IFC_DERIVED_MEASURE_VALUE" => {
                    IfcValue::IfcDerivedMeasureValue(typed_parameter.parameters.into_iter().next().unwrap().into())
                }
                "IFC_MEASURE_VALUE" => {
                    IfcValue::IfcMeasureValue(typed_parameter.parameters.into_iter().next().unwrap().into())
                }
                "IFC_SIMPLE_VALUE" => {
                    IfcValue::IfcSimpleValue(typed_parameter.parameters.into_iter().next().unwrap().into())
                }
                _ => panic!("parameter type is not recognized: {}", typed_parameter.type_name),
            },
            _ => panic!("parameter is not recognized"),
        }
    }
}
#[derive(Debug)]
pub enum IfcVectorOrDirection {
    EntityRef(EntityRef),
    IfcDirection(EntityRef),
    IfcVector(EntityRef),
}
impl Default for IfcVectorOrDirection {
    fn default() -> Self {
        IfcVectorOrDirection::IfcDirection(EntityRef::default())
    }
}
impl From<Parameter> for IfcVectorOrDirection {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EntityRef(id) => IfcVectorOrDirection::EntityRef(EntityRef(id)),
                _ => panic!("parameter is not an instance"),
            },
            _ => panic!("parameter is not recognized"),
        }
    }
}
#[derive(Debug)]
pub enum IfcWarpingStiffnessSelect {
    IfcBoolean(IfcBoolean),
    IfcWarpingMomentMeasure(IfcWarpingMomentMeasure),
}
impl Default for IfcWarpingStiffnessSelect {
    fn default() -> Self {
        IfcWarpingStiffnessSelect::IfcBoolean(IfcBoolean::default())
    }
}
impl From<Parameter> for IfcWarpingStiffnessSelect {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::TypedParameter(typed_parameter) => match typed_parameter.type_name.as_str() {
                "IFC_BOOLEAN" => {
                    IfcWarpingStiffnessSelect::IfcBoolean(typed_parameter.parameters.into_iter().next().unwrap().into())
                }
                "IFC_WARPING_MOMENT_MEASURE" => IfcWarpingStiffnessSelect::IfcWarpingMomentMeasure(
                    typed_parameter.parameters.into_iter().next().unwrap().into(),
                ),
                _ => panic!("parameter type is not recognized: {}", typed_parameter.type_name),
            },
            _ => panic!("parameter is not recognized"),
        }
    }
}
pub trait IIfcActionRequest: IIfcControl {
    fn predefined_type(&self) -> &Option<IfcActionRequestTypeEnum>;
    fn status(&self) -> &Option<IfcLabel>;
    fn long_description(&self) -> &Option<IfcText>;
}
#[derive(Default, Debug)]
pub struct IfcActionRequest {
    global_id: IfcGloballyUniqueId,
    owner_history: Option<EntityRef>,
    name: Option<IfcLabel>,
    description: Option<IfcText>,
    object_type: Option<IfcLabel>,
    identification: Option<IfcIdentifier>,
    predefined_type: Option<IfcActionRequestTypeEnum>,
    status: Option<IfcLabel>,
    long_description: Option<IfcText>,
}
impl IIfcRoot for IfcActionRequest {
    fn global_id(&self) -> &IfcGloballyUniqueId {
        &self.global_id
    }
    fn owner_history(&self) -> &Option<EntityRef> {
        &self.owner_history
    }
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
}
impl IIfcObjectDefinition for IfcActionRequest {}
impl IIfcObject for IfcActionRequest {
    fn object_type(&self) -> &Option<IfcLabel> {
        &self.object_type
    }
}
impl IIfcControl for IfcActionRequest {
    fn identification(&self) -> &Option<IfcIdentifier> {
        &self.identification
    }
}
impl IIfcActionRequest for IfcActionRequest {
    fn predefined_type(&self) -> &Option<IfcActionRequestTypeEnum> {
        &self.predefined_type
    }
    fn status(&self) -> &Option<IfcLabel> {
        &self.status
    }
    fn long_description(&self) -> &Option<IfcText> {
        &self.long_description
    }
}
impl IfcActionRequest {
    pub fn from_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcActionRequest::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.global_id = parameter.into(),
                1usize => {
                    entity.owner_history = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => {
                    entity.object_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                5usize => {
                    entity.identification = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                6usize => {
                    entity.predefined_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                7usize => {
                    entity.status = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                8usize => {
                    entity.long_description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
    pub fn from_own_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcActionRequest::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => {
                    entity.predefined_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                1usize => {
                    entity.status = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => {
                    entity.long_description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcActor: IIfcObject {
    fn the_actor(&self) -> &EntityRef;
}
#[derive(Default, Debug)]
pub struct IfcActor {
    global_id: IfcGloballyUniqueId,
    owner_history: Option<EntityRef>,
    name: Option<IfcLabel>,
    description: Option<IfcText>,
    object_type: Option<IfcLabel>,
    the_actor: EntityRef,
}
impl IIfcRoot for IfcActor {
    fn global_id(&self) -> &IfcGloballyUniqueId {
        &self.global_id
    }
    fn owner_history(&self) -> &Option<EntityRef> {
        &self.owner_history
    }
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
}
impl IIfcObjectDefinition for IfcActor {}
impl IIfcObject for IfcActor {
    fn object_type(&self) -> &Option<IfcLabel> {
        &self.object_type
    }
}
impl IIfcActor for IfcActor {
    fn the_actor(&self) -> &EntityRef {
        &self.the_actor
    }
}
impl IfcActor {
    pub fn from_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcActor::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.global_id = parameter.into(),
                1usize => {
                    entity.owner_history = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => {
                    entity.object_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                5usize => entity.the_actor = parameter.into(),
                _ => {}
            }
        }
        entity
    }
    pub fn from_own_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcActor::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.the_actor = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcActorRole {
    fn role(&self) -> &IfcRoleEnum;
    fn user_defined_role(&self) -> &Option<IfcLabel>;
    fn description(&self) -> &Option<IfcText>;
}
#[derive(Default, Debug)]
pub struct IfcActorRole {
    role: IfcRoleEnum,
    user_defined_role: Option<IfcLabel>,
    description: Option<IfcText>,
}
impl IIfcActorRole for IfcActorRole {
    fn role(&self) -> &IfcRoleEnum {
        &self.role
    }
    fn user_defined_role(&self) -> &Option<IfcLabel> {
        &self.user_defined_role
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
}
impl IfcActorRole {
    pub fn from_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcActorRole::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.role = parameter.into(),
                1usize => {
                    entity.user_defined_role = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcActuator: IIfcDistributionControlElement {
    fn predefined_type(&self) -> &Option<IfcActuatorTypeEnum>;
}
#[derive(Default, Debug)]
pub struct IfcActuator {
    global_id: IfcGloballyUniqueId,
    owner_history: Option<EntityRef>,
    name: Option<IfcLabel>,
    description: Option<IfcText>,
    object_type: Option<IfcLabel>,
    object_placement: Option<EntityRef>,
    representation: Option<EntityRef>,
    tag: Option<IfcIdentifier>,
    predefined_type: Option<IfcActuatorTypeEnum>,
}
impl IIfcRoot for IfcActuator {
    fn global_id(&self) -> &IfcGloballyUniqueId {
        &self.global_id
    }
    fn owner_history(&self) -> &Option<EntityRef> {
        &self.owner_history
    }
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
}
impl IIfcObjectDefinition for IfcActuator {}
impl IIfcObject for IfcActuator {
    fn object_type(&self) -> &Option<IfcLabel> {
        &self.object_type
    }
}
impl IIfcProduct for IfcActuator {
    fn object_placement(&self) -> &Option<EntityRef> {
        &self.object_placement
    }
    fn representation(&self) -> &Option<EntityRef> {
        &self.representation
    }
}
impl IIfcElement for IfcActuator {
    fn tag(&self) -> &Option<IfcIdentifier> {
        &self.tag
    }
}
impl IIfcDistributionElement for IfcActuator {}
impl IIfcDistributionControlElement for IfcActuator {}
impl IIfcActuator for IfcActuator {
    fn predefined_type(&self) -> &Option<IfcActuatorTypeEnum> {
        &self.predefined_type
    }
}
impl IfcActuator {
    pub fn from_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcActuator::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.global_id = parameter.into(),
                1usize => {
                    entity.owner_history = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => {
                    entity.object_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                5usize => {
                    entity.object_placement = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                6usize => {
                    entity.representation = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                7usize => {
                    entity.tag = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                8usize => {
                    entity.predefined_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
    pub fn from_own_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcActuator::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => {
                    entity.predefined_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcActuatorType: IIfcDistributionControlElementType {
    fn predefined_type(&self) -> &IfcActuatorTypeEnum;
}
#[derive(Default, Debug)]
pub struct IfcActuatorType {
    global_id: IfcGloballyUniqueId,
    owner_history: Option<EntityRef>,
    name: Option<IfcLabel>,
    description: Option<IfcText>,
    applicable_occurrence: Option<IfcIdentifier>,
    has_property_sets: Option<HashSet<EntityRef>>,
    representation_maps: Option<Vec<EntityRef>>,
    tag: Option<IfcLabel>,
    element_type: Option<IfcLabel>,
    predefined_type: IfcActuatorTypeEnum,
}
impl IIfcRoot for IfcActuatorType {
    fn global_id(&self) -> &IfcGloballyUniqueId {
        &self.global_id
    }
    fn owner_history(&self) -> &Option<EntityRef> {
        &self.owner_history
    }
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
}
impl IIfcObjectDefinition for IfcActuatorType {}
impl IIfcTypeObject for IfcActuatorType {
    fn applicable_occurrence(&self) -> &Option<IfcIdentifier> {
        &self.applicable_occurrence
    }
    fn has_property_sets(&self) -> &Option<HashSet<EntityRef>> {
        &self.has_property_sets
    }
}
impl IIfcTypeProduct for IfcActuatorType {
    fn representation_maps(&self) -> &Option<Vec<EntityRef>> {
        &self.representation_maps
    }
    fn tag(&self) -> &Option<IfcLabel> {
        &self.tag
    }
}
impl IIfcElementType for IfcActuatorType {
    fn element_type(&self) -> &Option<IfcLabel> {
        &self.element_type
    }
}
impl IIfcDistributionElementType for IfcActuatorType {}
impl IIfcDistributionControlElementType for IfcActuatorType {}
impl IIfcActuatorType for IfcActuatorType {
    fn predefined_type(&self) -> &IfcActuatorTypeEnum {
        &self.predefined_type
    }
}
impl IfcActuatorType {
    pub fn from_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcActuatorType::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.global_id = parameter.into(),
                1usize => {
                    entity.owner_history = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => {
                    entity.applicable_occurrence = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                5usize => {
                    entity.has_property_sets = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                6usize => {
                    entity.representation_maps = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                7usize => {
                    entity.tag = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                8usize => {
                    entity.element_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                9usize => entity.predefined_type = parameter.into(),
                _ => {}
            }
        }
        entity
    }
    pub fn from_own_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcActuatorType::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.predefined_type = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcAddress {
    fn purpose(&self) -> &Option<IfcAddressTypeEnum>;
    fn description(&self) -> &Option<IfcText>;
    fn user_defined_purpose(&self) -> &Option<IfcLabel>;
}
pub trait IIfcAdvancedBrep: IIfcManifoldSolidBrep {}
#[derive(Default, Debug)]
pub struct IfcAdvancedBrep {
    outer: EntityRef,
}
impl IIfcRepresentationItem for IfcAdvancedBrep {}
impl IIfcGeometricRepresentationItem for IfcAdvancedBrep {}
impl IIfcSolidModel for IfcAdvancedBrep {}
impl IIfcManifoldSolidBrep for IfcAdvancedBrep {
    fn outer(&self) -> &EntityRef {
        &self.outer
    }
}
impl IIfcAdvancedBrep for IfcAdvancedBrep {}
impl IfcAdvancedBrep {
    pub fn from_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcAdvancedBrep::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.outer = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcAdvancedBrepWithVoids: IIfcAdvancedBrep {
    fn voids(&self) -> &HashSet<EntityRef>;
}
#[derive(Default, Debug)]
pub struct IfcAdvancedBrepWithVoids {
    outer: EntityRef,
    voids: HashSet<EntityRef>,
}
impl IIfcRepresentationItem for IfcAdvancedBrepWithVoids {}
impl IIfcGeometricRepresentationItem for IfcAdvancedBrepWithVoids {}
impl IIfcSolidModel for IfcAdvancedBrepWithVoids {}
impl IIfcManifoldSolidBrep for IfcAdvancedBrepWithVoids {
    fn outer(&self) -> &EntityRef {
        &self.outer
    }
}
impl IIfcAdvancedBrep for IfcAdvancedBrepWithVoids {}
impl IIfcAdvancedBrepWithVoids for IfcAdvancedBrepWithVoids {
    fn voids(&self) -> &HashSet<EntityRef> {
        &self.voids
    }
}
impl IfcAdvancedBrepWithVoids {
    pub fn from_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcAdvancedBrepWithVoids::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.outer = parameter.into(),
                1usize => entity.voids = parameter.into(),
                _ => {}
            }
        }
        entity
    }
    pub fn from_own_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcAdvancedBrepWithVoids::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.voids = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcAdvancedFace: IIfcFaceSurface {}
#[derive(Default, Debug)]
pub struct IfcAdvancedFace {
    bounds: HashSet<EntityRef>,
    face_surface: EntityRef,
    same_sense: IfcBoolean,
}
impl IIfcRepresentationItem for IfcAdvancedFace {}
impl IIfcTopologicalRepresentationItem for IfcAdvancedFace {}
impl IIfcFace for IfcAdvancedFace {
    fn bounds(&self) -> &HashSet<EntityRef> {
        &self.bounds
    }
}
impl IIfcFaceSurface for IfcAdvancedFace {
    fn face_surface(&self) -> &EntityRef {
        &self.face_surface
    }
    fn same_sense(&self) -> &IfcBoolean {
        &self.same_sense
    }
}
impl IIfcAdvancedFace for IfcAdvancedFace {}
impl IfcAdvancedFace {
    pub fn from_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcAdvancedFace::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.bounds = parameter.into(),
                1usize => entity.face_surface = parameter.into(),
                2usize => entity.same_sense = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcAirTerminal: IIfcFlowTerminal {
    fn predefined_type(&self) -> &Option<IfcAirTerminalTypeEnum>;
}
#[derive(Default, Debug)]
pub struct IfcAirTerminal {
    global_id: IfcGloballyUniqueId,
    owner_history: Option<EntityRef>,
    name: Option<IfcLabel>,
    description: Option<IfcText>,
    object_type: Option<IfcLabel>,
    object_placement: Option<EntityRef>,
    representation: Option<EntityRef>,
    tag: Option<IfcIdentifier>,
    predefined_type: Option<IfcAirTerminalTypeEnum>,
}
impl IIfcRoot for IfcAirTerminal {
    fn global_id(&self) -> &IfcGloballyUniqueId {
        &self.global_id
    }
    fn owner_history(&self) -> &Option<EntityRef> {
        &self.owner_history
    }
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
}
impl IIfcObjectDefinition for IfcAirTerminal {}
impl IIfcObject for IfcAirTerminal {
    fn object_type(&self) -> &Option<IfcLabel> {
        &self.object_type
    }
}
impl IIfcProduct for IfcAirTerminal {
    fn object_placement(&self) -> &Option<EntityRef> {
        &self.object_placement
    }
    fn representation(&self) -> &Option<EntityRef> {
        &self.representation
    }
}
impl IIfcElement for IfcAirTerminal {
    fn tag(&self) -> &Option<IfcIdentifier> {
        &self.tag
    }
}
impl IIfcDistributionElement for IfcAirTerminal {}
impl IIfcDistributionFlowElement for IfcAirTerminal {}
impl IIfcFlowTerminal for IfcAirTerminal {}
impl IIfcAirTerminal for IfcAirTerminal {
    fn predefined_type(&self) -> &Option<IfcAirTerminalTypeEnum> {
        &self.predefined_type
    }
}
impl IfcAirTerminal {
    pub fn from_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcAirTerminal::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.global_id = parameter.into(),
                1usize => {
                    entity.owner_history = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => {
                    entity.object_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                5usize => {
                    entity.object_placement = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                6usize => {
                    entity.representation = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                7usize => {
                    entity.tag = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                8usize => {
                    entity.predefined_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
    pub fn from_own_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcAirTerminal::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => {
                    entity.predefined_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcAirTerminalBox: IIfcFlowController {
    fn predefined_type(&self) -> &Option<IfcAirTerminalBoxTypeEnum>;
}
#[derive(Default, Debug)]
pub struct IfcAirTerminalBox {
    global_id: IfcGloballyUniqueId,
    owner_history: Option<EntityRef>,
    name: Option<IfcLabel>,
    description: Option<IfcText>,
    object_type: Option<IfcLabel>,
    object_placement: Option<EntityRef>,
    representation: Option<EntityRef>,
    tag: Option<IfcIdentifier>,
    predefined_type: Option<IfcAirTerminalBoxTypeEnum>,
}
impl IIfcRoot for IfcAirTerminalBox {
    fn global_id(&self) -> &IfcGloballyUniqueId {
        &self.global_id
    }
    fn owner_history(&self) -> &Option<EntityRef> {
        &self.owner_history
    }
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
}
impl IIfcObjectDefinition for IfcAirTerminalBox {}
impl IIfcObject for IfcAirTerminalBox {
    fn object_type(&self) -> &Option<IfcLabel> {
        &self.object_type
    }
}
impl IIfcProduct for IfcAirTerminalBox {
    fn object_placement(&self) -> &Option<EntityRef> {
        &self.object_placement
    }
    fn representation(&self) -> &Option<EntityRef> {
        &self.representation
    }
}
impl IIfcElement for IfcAirTerminalBox {
    fn tag(&self) -> &Option<IfcIdentifier> {
        &self.tag
    }
}
impl IIfcDistributionElement for IfcAirTerminalBox {}
impl IIfcDistributionFlowElement for IfcAirTerminalBox {}
impl IIfcFlowController for IfcAirTerminalBox {}
impl IIfcAirTerminalBox for IfcAirTerminalBox {
    fn predefined_type(&self) -> &Option<IfcAirTerminalBoxTypeEnum> {
        &self.predefined_type
    }
}
impl IfcAirTerminalBox {
    pub fn from_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcAirTerminalBox::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.global_id = parameter.into(),
                1usize => {
                    entity.owner_history = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => {
                    entity.object_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                5usize => {
                    entity.object_placement = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                6usize => {
                    entity.representation = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                7usize => {
                    entity.tag = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                8usize => {
                    entity.predefined_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
    pub fn from_own_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcAirTerminalBox::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => {
                    entity.predefined_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcAirTerminalBoxType: IIfcFlowControllerType {
    fn predefined_type(&self) -> &IfcAirTerminalBoxTypeEnum;
}
#[derive(Default, Debug)]
pub struct IfcAirTerminalBoxType {
    global_id: IfcGloballyUniqueId,
    owner_history: Option<EntityRef>,
    name: Option<IfcLabel>,
    description: Option<IfcText>,
    applicable_occurrence: Option<IfcIdentifier>,
    has_property_sets: Option<HashSet<EntityRef>>,
    representation_maps: Option<Vec<EntityRef>>,
    tag: Option<IfcLabel>,
    element_type: Option<IfcLabel>,
    predefined_type: IfcAirTerminalBoxTypeEnum,
}
impl IIfcRoot for IfcAirTerminalBoxType {
    fn global_id(&self) -> &IfcGloballyUniqueId {
        &self.global_id
    }
    fn owner_history(&self) -> &Option<EntityRef> {
        &self.owner_history
    }
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
}
impl IIfcObjectDefinition for IfcAirTerminalBoxType {}
impl IIfcTypeObject for IfcAirTerminalBoxType {
    fn applicable_occurrence(&self) -> &Option<IfcIdentifier> {
        &self.applicable_occurrence
    }
    fn has_property_sets(&self) -> &Option<HashSet<EntityRef>> {
        &self.has_property_sets
    }
}
impl IIfcTypeProduct for IfcAirTerminalBoxType {
    fn representation_maps(&self) -> &Option<Vec<EntityRef>> {
        &self.representation_maps
    }
    fn tag(&self) -> &Option<IfcLabel> {
        &self.tag
    }
}
impl IIfcElementType for IfcAirTerminalBoxType {
    fn element_type(&self) -> &Option<IfcLabel> {
        &self.element_type
    }
}
impl IIfcDistributionElementType for IfcAirTerminalBoxType {}
impl IIfcDistributionFlowElementType for IfcAirTerminalBoxType {}
impl IIfcFlowControllerType for IfcAirTerminalBoxType {}
impl IIfcAirTerminalBoxType for IfcAirTerminalBoxType {
    fn predefined_type(&self) -> &IfcAirTerminalBoxTypeEnum {
        &self.predefined_type
    }
}
impl IfcAirTerminalBoxType {
    pub fn from_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcAirTerminalBoxType::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.global_id = parameter.into(),
                1usize => {
                    entity.owner_history = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => {
                    entity.applicable_occurrence = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                5usize => {
                    entity.has_property_sets = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                6usize => {
                    entity.representation_maps = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                7usize => {
                    entity.tag = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                8usize => {
                    entity.element_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                9usize => entity.predefined_type = parameter.into(),
                _ => {}
            }
        }
        entity
    }
    pub fn from_own_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcAirTerminalBoxType::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.predefined_type = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcAirTerminalType: IIfcFlowTerminalType {
    fn predefined_type(&self) -> &IfcAirTerminalTypeEnum;
}
#[derive(Default, Debug)]
pub struct IfcAirTerminalType {
    global_id: IfcGloballyUniqueId,
    owner_history: Option<EntityRef>,
    name: Option<IfcLabel>,
    description: Option<IfcText>,
    applicable_occurrence: Option<IfcIdentifier>,
    has_property_sets: Option<HashSet<EntityRef>>,
    representation_maps: Option<Vec<EntityRef>>,
    tag: Option<IfcLabel>,
    element_type: Option<IfcLabel>,
    predefined_type: IfcAirTerminalTypeEnum,
}
impl IIfcRoot for IfcAirTerminalType {
    fn global_id(&self) -> &IfcGloballyUniqueId {
        &self.global_id
    }
    fn owner_history(&self) -> &Option<EntityRef> {
        &self.owner_history
    }
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
}
impl IIfcObjectDefinition for IfcAirTerminalType {}
impl IIfcTypeObject for IfcAirTerminalType {
    fn applicable_occurrence(&self) -> &Option<IfcIdentifier> {
        &self.applicable_occurrence
    }
    fn has_property_sets(&self) -> &Option<HashSet<EntityRef>> {
        &self.has_property_sets
    }
}
impl IIfcTypeProduct for IfcAirTerminalType {
    fn representation_maps(&self) -> &Option<Vec<EntityRef>> {
        &self.representation_maps
    }
    fn tag(&self) -> &Option<IfcLabel> {
        &self.tag
    }
}
impl IIfcElementType for IfcAirTerminalType {
    fn element_type(&self) -> &Option<IfcLabel> {
        &self.element_type
    }
}
impl IIfcDistributionElementType for IfcAirTerminalType {}
impl IIfcDistributionFlowElementType for IfcAirTerminalType {}
impl IIfcFlowTerminalType for IfcAirTerminalType {}
impl IIfcAirTerminalType for IfcAirTerminalType {
    fn predefined_type(&self) -> &IfcAirTerminalTypeEnum {
        &self.predefined_type
    }
}
impl IfcAirTerminalType {
    pub fn from_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcAirTerminalType::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.global_id = parameter.into(),
                1usize => {
                    entity.owner_history = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => {
                    entity.applicable_occurrence = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                5usize => {
                    entity.has_property_sets = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                6usize => {
                    entity.representation_maps = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                7usize => {
                    entity.tag = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                8usize => {
                    entity.element_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                9usize => entity.predefined_type = parameter.into(),
                _ => {}
            }
        }
        entity
    }
    pub fn from_own_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcAirTerminalType::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.predefined_type = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcAirToAirHeatRecovery: IIfcEnergyConversionDevice {
    fn predefined_type(&self) -> &Option<IfcAirToAirHeatRecoveryTypeEnum>;
}
#[derive(Default, Debug)]
pub struct IfcAirToAirHeatRecovery {
    global_id: IfcGloballyUniqueId,
    owner_history: Option<EntityRef>,
    name: Option<IfcLabel>,
    description: Option<IfcText>,
    object_type: Option<IfcLabel>,
    object_placement: Option<EntityRef>,
    representation: Option<EntityRef>,
    tag: Option<IfcIdentifier>,
    predefined_type: Option<IfcAirToAirHeatRecoveryTypeEnum>,
}
impl IIfcRoot for IfcAirToAirHeatRecovery {
    fn global_id(&self) -> &IfcGloballyUniqueId {
        &self.global_id
    }
    fn owner_history(&self) -> &Option<EntityRef> {
        &self.owner_history
    }
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
}
impl IIfcObjectDefinition for IfcAirToAirHeatRecovery {}
impl IIfcObject for IfcAirToAirHeatRecovery {
    fn object_type(&self) -> &Option<IfcLabel> {
        &self.object_type
    }
}
impl IIfcProduct for IfcAirToAirHeatRecovery {
    fn object_placement(&self) -> &Option<EntityRef> {
        &self.object_placement
    }
    fn representation(&self) -> &Option<EntityRef> {
        &self.representation
    }
}
impl IIfcElement for IfcAirToAirHeatRecovery {
    fn tag(&self) -> &Option<IfcIdentifier> {
        &self.tag
    }
}
impl IIfcDistributionElement for IfcAirToAirHeatRecovery {}
impl IIfcDistributionFlowElement for IfcAirToAirHeatRecovery {}
impl IIfcEnergyConversionDevice for IfcAirToAirHeatRecovery {}
impl IIfcAirToAirHeatRecovery for IfcAirToAirHeatRecovery {
    fn predefined_type(&self) -> &Option<IfcAirToAirHeatRecoveryTypeEnum> {
        &self.predefined_type
    }
}
impl IfcAirToAirHeatRecovery {
    pub fn from_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcAirToAirHeatRecovery::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.global_id = parameter.into(),
                1usize => {
                    entity.owner_history = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => {
                    entity.object_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                5usize => {
                    entity.object_placement = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                6usize => {
                    entity.representation = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                7usize => {
                    entity.tag = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                8usize => {
                    entity.predefined_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
    pub fn from_own_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcAirToAirHeatRecovery::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => {
                    entity.predefined_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcAirToAirHeatRecoveryType: IIfcEnergyConversionDeviceType {
    fn predefined_type(&self) -> &IfcAirToAirHeatRecoveryTypeEnum;
}
#[derive(Default, Debug)]
pub struct IfcAirToAirHeatRecoveryType {
    global_id: IfcGloballyUniqueId,
    owner_history: Option<EntityRef>,
    name: Option<IfcLabel>,
    description: Option<IfcText>,
    applicable_occurrence: Option<IfcIdentifier>,
    has_property_sets: Option<HashSet<EntityRef>>,
    representation_maps: Option<Vec<EntityRef>>,
    tag: Option<IfcLabel>,
    element_type: Option<IfcLabel>,
    predefined_type: IfcAirToAirHeatRecoveryTypeEnum,
}
impl IIfcRoot for IfcAirToAirHeatRecoveryType {
    fn global_id(&self) -> &IfcGloballyUniqueId {
        &self.global_id
    }
    fn owner_history(&self) -> &Option<EntityRef> {
        &self.owner_history
    }
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
}
impl IIfcObjectDefinition for IfcAirToAirHeatRecoveryType {}
impl IIfcTypeObject for IfcAirToAirHeatRecoveryType {
    fn applicable_occurrence(&self) -> &Option<IfcIdentifier> {
        &self.applicable_occurrence
    }
    fn has_property_sets(&self) -> &Option<HashSet<EntityRef>> {
        &self.has_property_sets
    }
}
impl IIfcTypeProduct for IfcAirToAirHeatRecoveryType {
    fn representation_maps(&self) -> &Option<Vec<EntityRef>> {
        &self.representation_maps
    }
    fn tag(&self) -> &Option<IfcLabel> {
        &self.tag
    }
}
impl IIfcElementType for IfcAirToAirHeatRecoveryType {
    fn element_type(&self) -> &Option<IfcLabel> {
        &self.element_type
    }
}
impl IIfcDistributionElementType for IfcAirToAirHeatRecoveryType {}
impl IIfcDistributionFlowElementType for IfcAirToAirHeatRecoveryType {}
impl IIfcEnergyConversionDeviceType for IfcAirToAirHeatRecoveryType {}
impl IIfcAirToAirHeatRecoveryType for IfcAirToAirHeatRecoveryType {
    fn predefined_type(&self) -> &IfcAirToAirHeatRecoveryTypeEnum {
        &self.predefined_type
    }
}
impl IfcAirToAirHeatRecoveryType {
    pub fn from_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcAirToAirHeatRecoveryType::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.global_id = parameter.into(),
                1usize => {
                    entity.owner_history = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => {
                    entity.applicable_occurrence = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                5usize => {
                    entity.has_property_sets = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                6usize => {
                    entity.representation_maps = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                7usize => {
                    entity.tag = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                8usize => {
                    entity.element_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                9usize => entity.predefined_type = parameter.into(),
                _ => {}
            }
        }
        entity
    }
    pub fn from_own_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcAirToAirHeatRecoveryType::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.predefined_type = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcAlarm: IIfcDistributionControlElement {
    fn predefined_type(&self) -> &Option<IfcAlarmTypeEnum>;
}
#[derive(Default, Debug)]
pub struct IfcAlarm {
    global_id: IfcGloballyUniqueId,
    owner_history: Option<EntityRef>,
    name: Option<IfcLabel>,
    description: Option<IfcText>,
    object_type: Option<IfcLabel>,
    object_placement: Option<EntityRef>,
    representation: Option<EntityRef>,
    tag: Option<IfcIdentifier>,
    predefined_type: Option<IfcAlarmTypeEnum>,
}
impl IIfcRoot for IfcAlarm {
    fn global_id(&self) -> &IfcGloballyUniqueId {
        &self.global_id
    }
    fn owner_history(&self) -> &Option<EntityRef> {
        &self.owner_history
    }
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
}
impl IIfcObjectDefinition for IfcAlarm {}
impl IIfcObject for IfcAlarm {
    fn object_type(&self) -> &Option<IfcLabel> {
        &self.object_type
    }
}
impl IIfcProduct for IfcAlarm {
    fn object_placement(&self) -> &Option<EntityRef> {
        &self.object_placement
    }
    fn representation(&self) -> &Option<EntityRef> {
        &self.representation
    }
}
impl IIfcElement for IfcAlarm {
    fn tag(&self) -> &Option<IfcIdentifier> {
        &self.tag
    }
}
impl IIfcDistributionElement for IfcAlarm {}
impl IIfcDistributionControlElement for IfcAlarm {}
impl IIfcAlarm for IfcAlarm {
    fn predefined_type(&self) -> &Option<IfcAlarmTypeEnum> {
        &self.predefined_type
    }
}
impl IfcAlarm {
    pub fn from_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcAlarm::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.global_id = parameter.into(),
                1usize => {
                    entity.owner_history = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => {
                    entity.object_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                5usize => {
                    entity.object_placement = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                6usize => {
                    entity.representation = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                7usize => {
                    entity.tag = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                8usize => {
                    entity.predefined_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
    pub fn from_own_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcAlarm::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => {
                    entity.predefined_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcAlarmType: IIfcDistributionControlElementType {
    fn predefined_type(&self) -> &IfcAlarmTypeEnum;
}
#[derive(Default, Debug)]
pub struct IfcAlarmType {
    global_id: IfcGloballyUniqueId,
    owner_history: Option<EntityRef>,
    name: Option<IfcLabel>,
    description: Option<IfcText>,
    applicable_occurrence: Option<IfcIdentifier>,
    has_property_sets: Option<HashSet<EntityRef>>,
    representation_maps: Option<Vec<EntityRef>>,
    tag: Option<IfcLabel>,
    element_type: Option<IfcLabel>,
    predefined_type: IfcAlarmTypeEnum,
}
impl IIfcRoot for IfcAlarmType {
    fn global_id(&self) -> &IfcGloballyUniqueId {
        &self.global_id
    }
    fn owner_history(&self) -> &Option<EntityRef> {
        &self.owner_history
    }
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
}
impl IIfcObjectDefinition for IfcAlarmType {}
impl IIfcTypeObject for IfcAlarmType {
    fn applicable_occurrence(&self) -> &Option<IfcIdentifier> {
        &self.applicable_occurrence
    }
    fn has_property_sets(&self) -> &Option<HashSet<EntityRef>> {
        &self.has_property_sets
    }
}
impl IIfcTypeProduct for IfcAlarmType {
    fn representation_maps(&self) -> &Option<Vec<EntityRef>> {
        &self.representation_maps
    }
    fn tag(&self) -> &Option<IfcLabel> {
        &self.tag
    }
}
impl IIfcElementType for IfcAlarmType {
    fn element_type(&self) -> &Option<IfcLabel> {
        &self.element_type
    }
}
impl IIfcDistributionElementType for IfcAlarmType {}
impl IIfcDistributionControlElementType for IfcAlarmType {}
impl IIfcAlarmType for IfcAlarmType {
    fn predefined_type(&self) -> &IfcAlarmTypeEnum {
        &self.predefined_type
    }
}
impl IfcAlarmType {
    pub fn from_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcAlarmType::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.global_id = parameter.into(),
                1usize => {
                    entity.owner_history = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => {
                    entity.applicable_occurrence = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                5usize => {
                    entity.has_property_sets = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                6usize => {
                    entity.representation_maps = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                7usize => {
                    entity.tag = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                8usize => {
                    entity.element_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                9usize => entity.predefined_type = parameter.into(),
                _ => {}
            }
        }
        entity
    }
    pub fn from_own_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcAlarmType::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.predefined_type = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcAnnotation: IIfcProduct {}
#[derive(Default, Debug)]
pub struct IfcAnnotation {
    global_id: IfcGloballyUniqueId,
    owner_history: Option<EntityRef>,
    name: Option<IfcLabel>,
    description: Option<IfcText>,
    object_type: Option<IfcLabel>,
    object_placement: Option<EntityRef>,
    representation: Option<EntityRef>,
}
impl IIfcRoot for IfcAnnotation {
    fn global_id(&self) -> &IfcGloballyUniqueId {
        &self.global_id
    }
    fn owner_history(&self) -> &Option<EntityRef> {
        &self.owner_history
    }
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
}
impl IIfcObjectDefinition for IfcAnnotation {}
impl IIfcObject for IfcAnnotation {
    fn object_type(&self) -> &Option<IfcLabel> {
        &self.object_type
    }
}
impl IIfcProduct for IfcAnnotation {
    fn object_placement(&self) -> &Option<EntityRef> {
        &self.object_placement
    }
    fn representation(&self) -> &Option<EntityRef> {
        &self.representation
    }
}
impl IIfcAnnotation for IfcAnnotation {}
impl IfcAnnotation {
    pub fn from_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcAnnotation::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.global_id = parameter.into(),
                1usize => {
                    entity.owner_history = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => {
                    entity.object_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                5usize => {
                    entity.object_placement = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                6usize => {
                    entity.representation = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcAnnotationFillArea: IIfcGeometricRepresentationItem {
    fn outer_boundary(&self) -> &EntityRef;
    fn inner_boundaries(&self) -> &Option<HashSet<EntityRef>>;
}
#[derive(Default, Debug)]
pub struct IfcAnnotationFillArea {
    outer_boundary: EntityRef,
    inner_boundaries: Option<HashSet<EntityRef>>,
}
impl IIfcRepresentationItem for IfcAnnotationFillArea {}
impl IIfcGeometricRepresentationItem for IfcAnnotationFillArea {}
impl IIfcAnnotationFillArea for IfcAnnotationFillArea {
    fn outer_boundary(&self) -> &EntityRef {
        &self.outer_boundary
    }
    fn inner_boundaries(&self) -> &Option<HashSet<EntityRef>> {
        &self.inner_boundaries
    }
}
impl IfcAnnotationFillArea {
    pub fn from_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcAnnotationFillArea::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.outer_boundary = parameter.into(),
                1usize => {
                    entity.inner_boundaries = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcApplication {
    fn application_developer(&self) -> &EntityRef;
    fn version(&self) -> &IfcLabel;
    fn application_full_name(&self) -> &IfcLabel;
    fn application_identifier(&self) -> &IfcIdentifier;
}
#[derive(Default, Debug)]
pub struct IfcApplication {
    application_developer: EntityRef,
    version: IfcLabel,
    application_full_name: IfcLabel,
    application_identifier: IfcIdentifier,
}
impl IIfcApplication for IfcApplication {
    fn application_developer(&self) -> &EntityRef {
        &self.application_developer
    }
    fn version(&self) -> &IfcLabel {
        &self.version
    }
    fn application_full_name(&self) -> &IfcLabel {
        &self.application_full_name
    }
    fn application_identifier(&self) -> &IfcIdentifier {
        &self.application_identifier
    }
}
impl IfcApplication {
    pub fn from_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcApplication::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.application_developer = parameter.into(),
                1usize => entity.version = parameter.into(),
                2usize => entity.application_full_name = parameter.into(),
                3usize => entity.application_identifier = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcAppliedValue {
    fn name(&self) -> &Option<IfcLabel>;
    fn description(&self) -> &Option<IfcText>;
    fn applied_value(&self) -> &Option<IfcAppliedValueSelect>;
    fn unit_basis(&self) -> &Option<EntityRef>;
    fn applicable_date(&self) -> &Option<IfcDate>;
    fn fixed_until_date(&self) -> &Option<IfcDate>;
    fn category(&self) -> &Option<IfcLabel>;
    fn condition(&self) -> &Option<IfcLabel>;
    fn arithmetic_operator(&self) -> &Option<IfcArithmeticOperatorEnum>;
    fn components(&self) -> &Option<Vec<EntityRef>>;
}
#[derive(Default, Debug)]
pub struct IfcAppliedValue {
    name: Option<IfcLabel>,
    description: Option<IfcText>,
    applied_value: Option<IfcAppliedValueSelect>,
    unit_basis: Option<EntityRef>,
    applicable_date: Option<IfcDate>,
    fixed_until_date: Option<IfcDate>,
    category: Option<IfcLabel>,
    condition: Option<IfcLabel>,
    arithmetic_operator: Option<IfcArithmeticOperatorEnum>,
    components: Option<Vec<EntityRef>>,
}
impl IIfcAppliedValue for IfcAppliedValue {
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
    fn applied_value(&self) -> &Option<IfcAppliedValueSelect> {
        &self.applied_value
    }
    fn unit_basis(&self) -> &Option<EntityRef> {
        &self.unit_basis
    }
    fn applicable_date(&self) -> &Option<IfcDate> {
        &self.applicable_date
    }
    fn fixed_until_date(&self) -> &Option<IfcDate> {
        &self.fixed_until_date
    }
    fn category(&self) -> &Option<IfcLabel> {
        &self.category
    }
    fn condition(&self) -> &Option<IfcLabel> {
        &self.condition
    }
    fn arithmetic_operator(&self) -> &Option<IfcArithmeticOperatorEnum> {
        &self.arithmetic_operator
    }
    fn components(&self) -> &Option<Vec<EntityRef>> {
        &self.components
    }
}
impl IfcAppliedValue {
    pub fn from_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcAppliedValue::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                1usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => {
                    entity.applied_value = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.unit_basis = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => {
                    entity.applicable_date = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                5usize => {
                    entity.fixed_until_date = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                6usize => {
                    entity.category = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                7usize => {
                    entity.condition = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                8usize => {
                    entity.arithmetic_operator = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                9usize => {
                    entity.components = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcApproval {
    fn identifier(&self) -> &Option<IfcIdentifier>;
    fn name(&self) -> &Option<IfcLabel>;
    fn description(&self) -> &Option<IfcText>;
    fn time_of_approval(&self) -> &Option<IfcDateTime>;
    fn status(&self) -> &Option<IfcLabel>;
    fn level(&self) -> &Option<IfcLabel>;
    fn qualifier(&self) -> &Option<IfcText>;
    fn requesting_approval(&self) -> &Option<EntityRef>;
    fn giving_approval(&self) -> &Option<EntityRef>;
}
#[derive(Default, Debug)]
pub struct IfcApproval {
    identifier: Option<IfcIdentifier>,
    name: Option<IfcLabel>,
    description: Option<IfcText>,
    time_of_approval: Option<IfcDateTime>,
    status: Option<IfcLabel>,
    level: Option<IfcLabel>,
    qualifier: Option<IfcText>,
    requesting_approval: Option<EntityRef>,
    giving_approval: Option<EntityRef>,
}
impl IIfcApproval for IfcApproval {
    fn identifier(&self) -> &Option<IfcIdentifier> {
        &self.identifier
    }
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
    fn time_of_approval(&self) -> &Option<IfcDateTime> {
        &self.time_of_approval
    }
    fn status(&self) -> &Option<IfcLabel> {
        &self.status
    }
    fn level(&self) -> &Option<IfcLabel> {
        &self.level
    }
    fn qualifier(&self) -> &Option<IfcText> {
        &self.qualifier
    }
    fn requesting_approval(&self) -> &Option<EntityRef> {
        &self.requesting_approval
    }
    fn giving_approval(&self) -> &Option<EntityRef> {
        &self.giving_approval
    }
}
impl IfcApproval {
    pub fn from_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcApproval::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => {
                    entity.identifier = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                1usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.time_of_approval = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => {
                    entity.status = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                5usize => {
                    entity.level = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                6usize => {
                    entity.qualifier = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                7usize => {
                    entity.requesting_approval = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                8usize => {
                    entity.giving_approval = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcApprovalRelationship: IIfcResourceLevelRelationship {
    fn relating_approval(&self) -> &EntityRef;
    fn related_approvals(&self) -> &HashSet<EntityRef>;
}
#[derive(Default, Debug)]
pub struct IfcApprovalRelationship {
    name: Option<IfcLabel>,
    description: Option<IfcText>,
    relating_approval: EntityRef,
    related_approvals: HashSet<EntityRef>,
}
impl IIfcResourceLevelRelationship for IfcApprovalRelationship {
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
}
impl IIfcApprovalRelationship for IfcApprovalRelationship {
    fn relating_approval(&self) -> &EntityRef {
        &self.relating_approval
    }
    fn related_approvals(&self) -> &HashSet<EntityRef> {
        &self.related_approvals
    }
}
impl IfcApprovalRelationship {
    pub fn from_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcApprovalRelationship::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                1usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => entity.relating_approval = parameter.into(),
                3usize => entity.related_approvals = parameter.into(),
                _ => {}
            }
        }
        entity
    }
    pub fn from_own_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcApprovalRelationship::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.relating_approval = parameter.into(),
                1usize => entity.related_approvals = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcArbitraryClosedProfileDef: IIfcProfileDef {
    fn outer_curve(&self) -> &EntityRef;
}
#[derive(Default, Debug)]
pub struct IfcArbitraryClosedProfileDef {
    profile_type: IfcProfileTypeEnum,
    profile_name: Option<IfcLabel>,
    outer_curve: EntityRef,
}
impl IIfcProfileDef for IfcArbitraryClosedProfileDef {
    fn profile_type(&self) -> &IfcProfileTypeEnum {
        &self.profile_type
    }
    fn profile_name(&self) -> &Option<IfcLabel> {
        &self.profile_name
    }
}
impl IIfcArbitraryClosedProfileDef for IfcArbitraryClosedProfileDef {
    fn outer_curve(&self) -> &EntityRef {
        &self.outer_curve
    }
}
impl IfcArbitraryClosedProfileDef {
    pub fn from_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcArbitraryClosedProfileDef::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.profile_type = parameter.into(),
                1usize => {
                    entity.profile_name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => entity.outer_curve = parameter.into(),
                _ => {}
            }
        }
        entity
    }
    pub fn from_own_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcArbitraryClosedProfileDef::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.outer_curve = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcArbitraryOpenProfileDef: IIfcProfileDef {
    fn curve(&self) -> &EntityRef;
}
#[derive(Default, Debug)]
pub struct IfcArbitraryOpenProfileDef {
    profile_type: IfcProfileTypeEnum,
    profile_name: Option<IfcLabel>,
    curve: EntityRef,
}
impl IIfcProfileDef for IfcArbitraryOpenProfileDef {
    fn profile_type(&self) -> &IfcProfileTypeEnum {
        &self.profile_type
    }
    fn profile_name(&self) -> &Option<IfcLabel> {
        &self.profile_name
    }
}
impl IIfcArbitraryOpenProfileDef for IfcArbitraryOpenProfileDef {
    fn curve(&self) -> &EntityRef {
        &self.curve
    }
}
impl IfcArbitraryOpenProfileDef {
    pub fn from_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcArbitraryOpenProfileDef::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.profile_type = parameter.into(),
                1usize => {
                    entity.profile_name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => entity.curve = parameter.into(),
                _ => {}
            }
        }
        entity
    }
    pub fn from_own_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcArbitraryOpenProfileDef::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.curve = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcArbitraryProfileDefWithVoids: IIfcArbitraryClosedProfileDef {
    fn inner_curves(&self) -> &HashSet<EntityRef>;
}
#[derive(Default, Debug)]
pub struct IfcArbitraryProfileDefWithVoids {
    profile_type: IfcProfileTypeEnum,
    profile_name: Option<IfcLabel>,
    outer_curve: EntityRef,
    inner_curves: HashSet<EntityRef>,
}
impl IIfcProfileDef for IfcArbitraryProfileDefWithVoids {
    fn profile_type(&self) -> &IfcProfileTypeEnum {
        &self.profile_type
    }
    fn profile_name(&self) -> &Option<IfcLabel> {
        &self.profile_name
    }
}
impl IIfcArbitraryClosedProfileDef for IfcArbitraryProfileDefWithVoids {
    fn outer_curve(&self) -> &EntityRef {
        &self.outer_curve
    }
}
impl IIfcArbitraryProfileDefWithVoids for IfcArbitraryProfileDefWithVoids {
    fn inner_curves(&self) -> &HashSet<EntityRef> {
        &self.inner_curves
    }
}
impl IfcArbitraryProfileDefWithVoids {
    pub fn from_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcArbitraryProfileDefWithVoids::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.profile_type = parameter.into(),
                1usize => {
                    entity.profile_name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => entity.outer_curve = parameter.into(),
                3usize => entity.inner_curves = parameter.into(),
                _ => {}
            }
        }
        entity
    }
    pub fn from_own_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcArbitraryProfileDefWithVoids::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.inner_curves = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcAsset: IIfcGroup {
    fn identification(&self) -> &Option<IfcIdentifier>;
    fn original_value(&self) -> &Option<EntityRef>;
    fn current_value(&self) -> &Option<EntityRef>;
    fn total_replacement_cost(&self) -> &Option<EntityRef>;
    fn owner(&self) -> &Option<EntityRef>;
    fn user(&self) -> &Option<EntityRef>;
    fn responsible_person(&self) -> &Option<EntityRef>;
    fn incorporation_date(&self) -> &Option<IfcDate>;
    fn depreciated_value(&self) -> &Option<EntityRef>;
}
#[derive(Default, Debug)]
pub struct IfcAsset {
    global_id: IfcGloballyUniqueId,
    owner_history: Option<EntityRef>,
    name: Option<IfcLabel>,
    description: Option<IfcText>,
    object_type: Option<IfcLabel>,
    identification: Option<IfcIdentifier>,
    original_value: Option<EntityRef>,
    current_value: Option<EntityRef>,
    total_replacement_cost: Option<EntityRef>,
    owner: Option<EntityRef>,
    user: Option<EntityRef>,
    responsible_person: Option<EntityRef>,
    incorporation_date: Option<IfcDate>,
    depreciated_value: Option<EntityRef>,
}
impl IIfcRoot for IfcAsset {
    fn global_id(&self) -> &IfcGloballyUniqueId {
        &self.global_id
    }
    fn owner_history(&self) -> &Option<EntityRef> {
        &self.owner_history
    }
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
}
impl IIfcObjectDefinition for IfcAsset {}
impl IIfcObject for IfcAsset {
    fn object_type(&self) -> &Option<IfcLabel> {
        &self.object_type
    }
}
impl IIfcGroup for IfcAsset {}
impl IIfcAsset for IfcAsset {
    fn identification(&self) -> &Option<IfcIdentifier> {
        &self.identification
    }
    fn original_value(&self) -> &Option<EntityRef> {
        &self.original_value
    }
    fn current_value(&self) -> &Option<EntityRef> {
        &self.current_value
    }
    fn total_replacement_cost(&self) -> &Option<EntityRef> {
        &self.total_replacement_cost
    }
    fn owner(&self) -> &Option<EntityRef> {
        &self.owner
    }
    fn user(&self) -> &Option<EntityRef> {
        &self.user
    }
    fn responsible_person(&self) -> &Option<EntityRef> {
        &self.responsible_person
    }
    fn incorporation_date(&self) -> &Option<IfcDate> {
        &self.incorporation_date
    }
    fn depreciated_value(&self) -> &Option<EntityRef> {
        &self.depreciated_value
    }
}
impl IfcAsset {
    pub fn from_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcAsset::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.global_id = parameter.into(),
                1usize => {
                    entity.owner_history = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => {
                    entity.object_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                5usize => {
                    entity.identification = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                6usize => {
                    entity.original_value = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                7usize => {
                    entity.current_value = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                8usize => {
                    entity.total_replacement_cost = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                9usize => {
                    entity.owner = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                10usize => {
                    entity.user = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                11usize => {
                    entity.responsible_person = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                12usize => {
                    entity.incorporation_date = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                13usize => {
                    entity.depreciated_value = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
    pub fn from_own_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcAsset::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => {
                    entity.identification = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                1usize => {
                    entity.original_value = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => {
                    entity.current_value = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.total_replacement_cost = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => {
                    entity.owner = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                5usize => {
                    entity.user = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                6usize => {
                    entity.responsible_person = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                7usize => {
                    entity.incorporation_date = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                8usize => {
                    entity.depreciated_value = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcAsymmetricIShapeProfileDef: IIfcParameterizedProfileDef {
    fn bottom_flange_width(&self) -> &IfcPositiveLengthMeasure;
    fn overall_depth(&self) -> &IfcPositiveLengthMeasure;
    fn web_thickness(&self) -> &IfcPositiveLengthMeasure;
    fn bottom_flange_thickness(&self) -> &IfcPositiveLengthMeasure;
    fn bottom_flange_fillet_radius(&self) -> &Option<IfcNonNegativeLengthMeasure>;
    fn top_flange_width(&self) -> &IfcPositiveLengthMeasure;
    fn top_flange_thickness(&self) -> &Option<IfcPositiveLengthMeasure>;
    fn top_flange_fillet_radius(&self) -> &Option<IfcNonNegativeLengthMeasure>;
    fn bottom_flange_edge_radius(&self) -> &Option<IfcNonNegativeLengthMeasure>;
    fn bottom_flange_slope(&self) -> &Option<IfcPlaneAngleMeasure>;
    fn top_flange_edge_radius(&self) -> &Option<IfcNonNegativeLengthMeasure>;
    fn top_flange_slope(&self) -> &Option<IfcPlaneAngleMeasure>;
}
#[derive(Default, Debug)]
pub struct IfcAsymmetricIShapeProfileDef {
    profile_type: IfcProfileTypeEnum,
    profile_name: Option<IfcLabel>,
    position: Option<EntityRef>,
    bottom_flange_width: IfcPositiveLengthMeasure,
    overall_depth: IfcPositiveLengthMeasure,
    web_thickness: IfcPositiveLengthMeasure,
    bottom_flange_thickness: IfcPositiveLengthMeasure,
    bottom_flange_fillet_radius: Option<IfcNonNegativeLengthMeasure>,
    top_flange_width: IfcPositiveLengthMeasure,
    top_flange_thickness: Option<IfcPositiveLengthMeasure>,
    top_flange_fillet_radius: Option<IfcNonNegativeLengthMeasure>,
    bottom_flange_edge_radius: Option<IfcNonNegativeLengthMeasure>,
    bottom_flange_slope: Option<IfcPlaneAngleMeasure>,
    top_flange_edge_radius: Option<IfcNonNegativeLengthMeasure>,
    top_flange_slope: Option<IfcPlaneAngleMeasure>,
}
impl IIfcProfileDef for IfcAsymmetricIShapeProfileDef {
    fn profile_type(&self) -> &IfcProfileTypeEnum {
        &self.profile_type
    }
    fn profile_name(&self) -> &Option<IfcLabel> {
        &self.profile_name
    }
}
impl IIfcParameterizedProfileDef for IfcAsymmetricIShapeProfileDef {
    fn position(&self) -> &Option<EntityRef> {
        &self.position
    }
}
impl IIfcAsymmetricIShapeProfileDef for IfcAsymmetricIShapeProfileDef {
    fn bottom_flange_width(&self) -> &IfcPositiveLengthMeasure {
        &self.bottom_flange_width
    }
    fn overall_depth(&self) -> &IfcPositiveLengthMeasure {
        &self.overall_depth
    }
    fn web_thickness(&self) -> &IfcPositiveLengthMeasure {
        &self.web_thickness
    }
    fn bottom_flange_thickness(&self) -> &IfcPositiveLengthMeasure {
        &self.bottom_flange_thickness
    }
    fn bottom_flange_fillet_radius(&self) -> &Option<IfcNonNegativeLengthMeasure> {
        &self.bottom_flange_fillet_radius
    }
    fn top_flange_width(&self) -> &IfcPositiveLengthMeasure {
        &self.top_flange_width
    }
    fn top_flange_thickness(&self) -> &Option<IfcPositiveLengthMeasure> {
        &self.top_flange_thickness
    }
    fn top_flange_fillet_radius(&self) -> &Option<IfcNonNegativeLengthMeasure> {
        &self.top_flange_fillet_radius
    }
    fn bottom_flange_edge_radius(&self) -> &Option<IfcNonNegativeLengthMeasure> {
        &self.bottom_flange_edge_radius
    }
    fn bottom_flange_slope(&self) -> &Option<IfcPlaneAngleMeasure> {
        &self.bottom_flange_slope
    }
    fn top_flange_edge_radius(&self) -> &Option<IfcNonNegativeLengthMeasure> {
        &self.top_flange_edge_radius
    }
    fn top_flange_slope(&self) -> &Option<IfcPlaneAngleMeasure> {
        &self.top_flange_slope
    }
}
impl IfcAsymmetricIShapeProfileDef {
    pub fn from_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcAsymmetricIShapeProfileDef::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.profile_type = parameter.into(),
                1usize => {
                    entity.profile_name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => {
                    entity.position = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => entity.bottom_flange_width = parameter.into(),
                4usize => entity.overall_depth = parameter.into(),
                5usize => entity.web_thickness = parameter.into(),
                6usize => entity.bottom_flange_thickness = parameter.into(),
                7usize => {
                    entity.bottom_flange_fillet_radius = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                8usize => entity.top_flange_width = parameter.into(),
                9usize => {
                    entity.top_flange_thickness = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                10usize => {
                    entity.top_flange_fillet_radius = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                11usize => {
                    entity.bottom_flange_edge_radius = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                12usize => {
                    entity.bottom_flange_slope = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                13usize => {
                    entity.top_flange_edge_radius = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                14usize => {
                    entity.top_flange_slope = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
    pub fn from_own_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcAsymmetricIShapeProfileDef::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.bottom_flange_width = parameter.into(),
                1usize => entity.overall_depth = parameter.into(),
                2usize => entity.web_thickness = parameter.into(),
                3usize => entity.bottom_flange_thickness = parameter.into(),
                4usize => {
                    entity.bottom_flange_fillet_radius = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                5usize => entity.top_flange_width = parameter.into(),
                6usize => {
                    entity.top_flange_thickness = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                7usize => {
                    entity.top_flange_fillet_radius = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                8usize => {
                    entity.bottom_flange_edge_radius = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                9usize => {
                    entity.bottom_flange_slope = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                10usize => {
                    entity.top_flange_edge_radius = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                11usize => {
                    entity.top_flange_slope = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcAudioVisualAppliance: IIfcFlowTerminal {
    fn predefined_type(&self) -> &Option<IfcAudioVisualApplianceTypeEnum>;
}
#[derive(Default, Debug)]
pub struct IfcAudioVisualAppliance {
    global_id: IfcGloballyUniqueId,
    owner_history: Option<EntityRef>,
    name: Option<IfcLabel>,
    description: Option<IfcText>,
    object_type: Option<IfcLabel>,
    object_placement: Option<EntityRef>,
    representation: Option<EntityRef>,
    tag: Option<IfcIdentifier>,
    predefined_type: Option<IfcAudioVisualApplianceTypeEnum>,
}
impl IIfcRoot for IfcAudioVisualAppliance {
    fn global_id(&self) -> &IfcGloballyUniqueId {
        &self.global_id
    }
    fn owner_history(&self) -> &Option<EntityRef> {
        &self.owner_history
    }
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
}
impl IIfcObjectDefinition for IfcAudioVisualAppliance {}
impl IIfcObject for IfcAudioVisualAppliance {
    fn object_type(&self) -> &Option<IfcLabel> {
        &self.object_type
    }
}
impl IIfcProduct for IfcAudioVisualAppliance {
    fn object_placement(&self) -> &Option<EntityRef> {
        &self.object_placement
    }
    fn representation(&self) -> &Option<EntityRef> {
        &self.representation
    }
}
impl IIfcElement for IfcAudioVisualAppliance {
    fn tag(&self) -> &Option<IfcIdentifier> {
        &self.tag
    }
}
impl IIfcDistributionElement for IfcAudioVisualAppliance {}
impl IIfcDistributionFlowElement for IfcAudioVisualAppliance {}
impl IIfcFlowTerminal for IfcAudioVisualAppliance {}
impl IIfcAudioVisualAppliance for IfcAudioVisualAppliance {
    fn predefined_type(&self) -> &Option<IfcAudioVisualApplianceTypeEnum> {
        &self.predefined_type
    }
}
impl IfcAudioVisualAppliance {
    pub fn from_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcAudioVisualAppliance::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.global_id = parameter.into(),
                1usize => {
                    entity.owner_history = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => {
                    entity.object_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                5usize => {
                    entity.object_placement = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                6usize => {
                    entity.representation = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                7usize => {
                    entity.tag = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                8usize => {
                    entity.predefined_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
    pub fn from_own_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcAudioVisualAppliance::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => {
                    entity.predefined_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcAudioVisualApplianceType: IIfcFlowTerminalType {
    fn predefined_type(&self) -> &IfcAudioVisualApplianceTypeEnum;
}
#[derive(Default, Debug)]
pub struct IfcAudioVisualApplianceType {
    global_id: IfcGloballyUniqueId,
    owner_history: Option<EntityRef>,
    name: Option<IfcLabel>,
    description: Option<IfcText>,
    applicable_occurrence: Option<IfcIdentifier>,
    has_property_sets: Option<HashSet<EntityRef>>,
    representation_maps: Option<Vec<EntityRef>>,
    tag: Option<IfcLabel>,
    element_type: Option<IfcLabel>,
    predefined_type: IfcAudioVisualApplianceTypeEnum,
}
impl IIfcRoot for IfcAudioVisualApplianceType {
    fn global_id(&self) -> &IfcGloballyUniqueId {
        &self.global_id
    }
    fn owner_history(&self) -> &Option<EntityRef> {
        &self.owner_history
    }
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
}
impl IIfcObjectDefinition for IfcAudioVisualApplianceType {}
impl IIfcTypeObject for IfcAudioVisualApplianceType {
    fn applicable_occurrence(&self) -> &Option<IfcIdentifier> {
        &self.applicable_occurrence
    }
    fn has_property_sets(&self) -> &Option<HashSet<EntityRef>> {
        &self.has_property_sets
    }
}
impl IIfcTypeProduct for IfcAudioVisualApplianceType {
    fn representation_maps(&self) -> &Option<Vec<EntityRef>> {
        &self.representation_maps
    }
    fn tag(&self) -> &Option<IfcLabel> {
        &self.tag
    }
}
impl IIfcElementType for IfcAudioVisualApplianceType {
    fn element_type(&self) -> &Option<IfcLabel> {
        &self.element_type
    }
}
impl IIfcDistributionElementType for IfcAudioVisualApplianceType {}
impl IIfcDistributionFlowElementType for IfcAudioVisualApplianceType {}
impl IIfcFlowTerminalType for IfcAudioVisualApplianceType {}
impl IIfcAudioVisualApplianceType for IfcAudioVisualApplianceType {
    fn predefined_type(&self) -> &IfcAudioVisualApplianceTypeEnum {
        &self.predefined_type
    }
}
impl IfcAudioVisualApplianceType {
    pub fn from_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcAudioVisualApplianceType::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.global_id = parameter.into(),
                1usize => {
                    entity.owner_history = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => {
                    entity.applicable_occurrence = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                5usize => {
                    entity.has_property_sets = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                6usize => {
                    entity.representation_maps = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                7usize => {
                    entity.tag = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                8usize => {
                    entity.element_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                9usize => entity.predefined_type = parameter.into(),
                _ => {}
            }
        }
        entity
    }
    pub fn from_own_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcAudioVisualApplianceType::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.predefined_type = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcAxis1Placement: IIfcPlacement {
    fn axis(&self) -> &Option<EntityRef>;
}
#[derive(Default, Debug)]
pub struct IfcAxis1Placement {
    location: EntityRef,
    axis: Option<EntityRef>,
}
impl IIfcRepresentationItem for IfcAxis1Placement {}
impl IIfcGeometricRepresentationItem for IfcAxis1Placement {}
impl IIfcPlacement for IfcAxis1Placement {
    fn location(&self) -> &EntityRef {
        &self.location
    }
}
impl IIfcAxis1Placement for IfcAxis1Placement {
    fn axis(&self) -> &Option<EntityRef> {
        &self.axis
    }
}
impl IfcAxis1Placement {
    pub fn from_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcAxis1Placement::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.location = parameter.into(),
                1usize => {
                    entity.axis = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
    pub fn from_own_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcAxis1Placement::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => {
                    entity.axis = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcAxis2Placement2D: IIfcPlacement {
    fn ref_direction(&self) -> &Option<EntityRef>;
}
#[derive(Default, Debug)]
pub struct IfcAxis2Placement2D {
    location: EntityRef,
    ref_direction: Option<EntityRef>,
}
impl IIfcRepresentationItem for IfcAxis2Placement2D {}
impl IIfcGeometricRepresentationItem for IfcAxis2Placement2D {}
impl IIfcPlacement for IfcAxis2Placement2D {
    fn location(&self) -> &EntityRef {
        &self.location
    }
}
impl IIfcAxis2Placement2D for IfcAxis2Placement2D {
    fn ref_direction(&self) -> &Option<EntityRef> {
        &self.ref_direction
    }
}
impl IfcAxis2Placement2D {
    pub fn from_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcAxis2Placement2D::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.location = parameter.into(),
                1usize => {
                    entity.ref_direction = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
    pub fn from_own_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcAxis2Placement2D::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => {
                    entity.ref_direction = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcAxis2Placement3D: IIfcPlacement {
    fn axis(&self) -> &Option<EntityRef>;
    fn ref_direction(&self) -> &Option<EntityRef>;
}
#[derive(Default, Debug)]
pub struct IfcAxis2Placement3D {
    location: EntityRef,
    axis: Option<EntityRef>,
    ref_direction: Option<EntityRef>,
}
impl IIfcRepresentationItem for IfcAxis2Placement3D {}
impl IIfcGeometricRepresentationItem for IfcAxis2Placement3D {}
impl IIfcPlacement for IfcAxis2Placement3D {
    fn location(&self) -> &EntityRef {
        &self.location
    }
}
impl IIfcAxis2Placement3D for IfcAxis2Placement3D {
    fn axis(&self) -> &Option<EntityRef> {
        &self.axis
    }
    fn ref_direction(&self) -> &Option<EntityRef> {
        &self.ref_direction
    }
}
impl IfcAxis2Placement3D {
    pub fn from_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcAxis2Placement3D::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.location = parameter.into(),
                1usize => {
                    entity.axis = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => {
                    entity.ref_direction = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
    pub fn from_own_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcAxis2Placement3D::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => {
                    entity.axis = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                1usize => {
                    entity.ref_direction = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcBSplineCurve: IIfcBoundedCurve {
    fn degree(&self) -> &IfcInteger;
    fn control_points_list(&self) -> &Vec<EntityRef>;
    fn curve_form(&self) -> &IfcBSplineCurveForm;
    fn closed_curve(&self) -> &IfcLogical;
    fn self_intersect(&self) -> &IfcLogical;
}
pub trait IIfcBSplineCurveWithKnots: IIfcBSplineCurve {
    fn knot_multiplicities(&self) -> &Vec<IfcInteger>;
    fn knots(&self) -> &Vec<IfcParameterValue>;
    fn knot_spec(&self) -> &IfcKnotType;
}
#[derive(Default, Debug)]
pub struct IfcBSplineCurveWithKnots {
    degree: IfcInteger,
    control_points_list: Vec<EntityRef>,
    curve_form: IfcBSplineCurveForm,
    closed_curve: IfcLogical,
    self_intersect: IfcLogical,
    knot_multiplicities: Vec<IfcInteger>,
    knots: Vec<IfcParameterValue>,
    knot_spec: IfcKnotType,
}
impl IIfcRepresentationItem for IfcBSplineCurveWithKnots {}
impl IIfcGeometricRepresentationItem for IfcBSplineCurveWithKnots {}
impl IIfcCurve for IfcBSplineCurveWithKnots {}
impl IIfcBoundedCurve for IfcBSplineCurveWithKnots {}
impl IIfcBSplineCurve for IfcBSplineCurveWithKnots {
    fn degree(&self) -> &IfcInteger {
        &self.degree
    }
    fn control_points_list(&self) -> &Vec<EntityRef> {
        &self.control_points_list
    }
    fn curve_form(&self) -> &IfcBSplineCurveForm {
        &self.curve_form
    }
    fn closed_curve(&self) -> &IfcLogical {
        &self.closed_curve
    }
    fn self_intersect(&self) -> &IfcLogical {
        &self.self_intersect
    }
}
impl IIfcBSplineCurveWithKnots for IfcBSplineCurveWithKnots {
    fn knot_multiplicities(&self) -> &Vec<IfcInteger> {
        &self.knot_multiplicities
    }
    fn knots(&self) -> &Vec<IfcParameterValue> {
        &self.knots
    }
    fn knot_spec(&self) -> &IfcKnotType {
        &self.knot_spec
    }
}
impl IfcBSplineCurveWithKnots {
    pub fn from_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcBSplineCurveWithKnots::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.degree = parameter.into(),
                1usize => entity.control_points_list = parameter.into(),
                2usize => entity.curve_form = parameter.into(),
                3usize => entity.closed_curve = parameter.into(),
                4usize => entity.self_intersect = parameter.into(),
                5usize => entity.knot_multiplicities = parameter.into(),
                6usize => entity.knots = parameter.into(),
                7usize => entity.knot_spec = parameter.into(),
                _ => {}
            }
        }
        entity
    }
    pub fn from_own_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcBSplineCurveWithKnots::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.knot_multiplicities = parameter.into(),
                1usize => entity.knots = parameter.into(),
                2usize => entity.knot_spec = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcBSplineSurface: IIfcBoundedSurface {
    fn u_degree(&self) -> &IfcInteger;
    fn v_degree(&self) -> &IfcInteger;
    fn control_points_list(&self) -> &Vec<Vec<EntityRef>>;
    fn surface_form(&self) -> &IfcBSplineSurfaceForm;
    fn u_closed(&self) -> &IfcLogical;
    fn v_closed(&self) -> &IfcLogical;
    fn self_intersect(&self) -> &IfcLogical;
}
pub trait IIfcBSplineSurfaceWithKnots: IIfcBSplineSurface {
    fn u_multiplicities(&self) -> &Vec<IfcInteger>;
    fn v_multiplicities(&self) -> &Vec<IfcInteger>;
    fn u_knots(&self) -> &Vec<IfcParameterValue>;
    fn v_knots(&self) -> &Vec<IfcParameterValue>;
    fn knot_spec(&self) -> &IfcKnotType;
}
#[derive(Default, Debug)]
pub struct IfcBSplineSurfaceWithKnots {
    u_degree: IfcInteger,
    v_degree: IfcInteger,
    control_points_list: Vec<Vec<EntityRef>>,
    surface_form: IfcBSplineSurfaceForm,
    u_closed: IfcLogical,
    v_closed: IfcLogical,
    self_intersect: IfcLogical,
    u_multiplicities: Vec<IfcInteger>,
    v_multiplicities: Vec<IfcInteger>,
    u_knots: Vec<IfcParameterValue>,
    v_knots: Vec<IfcParameterValue>,
    knot_spec: IfcKnotType,
}
impl IIfcRepresentationItem for IfcBSplineSurfaceWithKnots {}
impl IIfcGeometricRepresentationItem for IfcBSplineSurfaceWithKnots {}
impl IIfcSurface for IfcBSplineSurfaceWithKnots {}
impl IIfcBoundedSurface for IfcBSplineSurfaceWithKnots {}
impl IIfcBSplineSurface for IfcBSplineSurfaceWithKnots {
    fn u_degree(&self) -> &IfcInteger {
        &self.u_degree
    }
    fn v_degree(&self) -> &IfcInteger {
        &self.v_degree
    }
    fn control_points_list(&self) -> &Vec<Vec<EntityRef>> {
        &self.control_points_list
    }
    fn surface_form(&self) -> &IfcBSplineSurfaceForm {
        &self.surface_form
    }
    fn u_closed(&self) -> &IfcLogical {
        &self.u_closed
    }
    fn v_closed(&self) -> &IfcLogical {
        &self.v_closed
    }
    fn self_intersect(&self) -> &IfcLogical {
        &self.self_intersect
    }
}
impl IIfcBSplineSurfaceWithKnots for IfcBSplineSurfaceWithKnots {
    fn u_multiplicities(&self) -> &Vec<IfcInteger> {
        &self.u_multiplicities
    }
    fn v_multiplicities(&self) -> &Vec<IfcInteger> {
        &self.v_multiplicities
    }
    fn u_knots(&self) -> &Vec<IfcParameterValue> {
        &self.u_knots
    }
    fn v_knots(&self) -> &Vec<IfcParameterValue> {
        &self.v_knots
    }
    fn knot_spec(&self) -> &IfcKnotType {
        &self.knot_spec
    }
}
impl IfcBSplineSurfaceWithKnots {
    pub fn from_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcBSplineSurfaceWithKnots::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.u_degree = parameter.into(),
                1usize => entity.v_degree = parameter.into(),
                2usize => entity.control_points_list = parameter.into(),
                3usize => entity.surface_form = parameter.into(),
                4usize => entity.u_closed = parameter.into(),
                5usize => entity.v_closed = parameter.into(),
                6usize => entity.self_intersect = parameter.into(),
                7usize => entity.u_multiplicities = parameter.into(),
                8usize => entity.v_multiplicities = parameter.into(),
                9usize => entity.u_knots = parameter.into(),
                10usize => entity.v_knots = parameter.into(),
                11usize => entity.knot_spec = parameter.into(),
                _ => {}
            }
        }
        entity
    }
    pub fn from_own_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcBSplineSurfaceWithKnots::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.u_multiplicities = parameter.into(),
                1usize => entity.v_multiplicities = parameter.into(),
                2usize => entity.u_knots = parameter.into(),
                3usize => entity.v_knots = parameter.into(),
                4usize => entity.knot_spec = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcBeam: IIfcBuildingElement {
    fn predefined_type(&self) -> &Option<IfcBeamTypeEnum>;
}
#[derive(Default, Debug)]
pub struct IfcBeam {
    global_id: IfcGloballyUniqueId,
    owner_history: Option<EntityRef>,
    name: Option<IfcLabel>,
    description: Option<IfcText>,
    object_type: Option<IfcLabel>,
    object_placement: Option<EntityRef>,
    representation: Option<EntityRef>,
    tag: Option<IfcIdentifier>,
    predefined_type: Option<IfcBeamTypeEnum>,
}
impl IIfcRoot for IfcBeam {
    fn global_id(&self) -> &IfcGloballyUniqueId {
        &self.global_id
    }
    fn owner_history(&self) -> &Option<EntityRef> {
        &self.owner_history
    }
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
}
impl IIfcObjectDefinition for IfcBeam {}
impl IIfcObject for IfcBeam {
    fn object_type(&self) -> &Option<IfcLabel> {
        &self.object_type
    }
}
impl IIfcProduct for IfcBeam {
    fn object_placement(&self) -> &Option<EntityRef> {
        &self.object_placement
    }
    fn representation(&self) -> &Option<EntityRef> {
        &self.representation
    }
}
impl IIfcElement for IfcBeam {
    fn tag(&self) -> &Option<IfcIdentifier> {
        &self.tag
    }
}
impl IIfcBuildingElement for IfcBeam {}
impl IIfcBeam for IfcBeam {
    fn predefined_type(&self) -> &Option<IfcBeamTypeEnum> {
        &self.predefined_type
    }
}
impl IfcBeam {
    pub fn from_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcBeam::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.global_id = parameter.into(),
                1usize => {
                    entity.owner_history = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => {
                    entity.object_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                5usize => {
                    entity.object_placement = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                6usize => {
                    entity.representation = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                7usize => {
                    entity.tag = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                8usize => {
                    entity.predefined_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
    pub fn from_own_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcBeam::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => {
                    entity.predefined_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcBeamStandardCase: IIfcBeam {}
#[derive(Default, Debug)]
pub struct IfcBeamStandardCase {
    global_id: IfcGloballyUniqueId,
    owner_history: Option<EntityRef>,
    name: Option<IfcLabel>,
    description: Option<IfcText>,
    object_type: Option<IfcLabel>,
    object_placement: Option<EntityRef>,
    representation: Option<EntityRef>,
    tag: Option<IfcIdentifier>,
    predefined_type: Option<IfcBeamTypeEnum>,
}
impl IIfcRoot for IfcBeamStandardCase {
    fn global_id(&self) -> &IfcGloballyUniqueId {
        &self.global_id
    }
    fn owner_history(&self) -> &Option<EntityRef> {
        &self.owner_history
    }
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
}
impl IIfcObjectDefinition for IfcBeamStandardCase {}
impl IIfcObject for IfcBeamStandardCase {
    fn object_type(&self) -> &Option<IfcLabel> {
        &self.object_type
    }
}
impl IIfcProduct for IfcBeamStandardCase {
    fn object_placement(&self) -> &Option<EntityRef> {
        &self.object_placement
    }
    fn representation(&self) -> &Option<EntityRef> {
        &self.representation
    }
}
impl IIfcElement for IfcBeamStandardCase {
    fn tag(&self) -> &Option<IfcIdentifier> {
        &self.tag
    }
}
impl IIfcBuildingElement for IfcBeamStandardCase {}
impl IIfcBeam for IfcBeamStandardCase {
    fn predefined_type(&self) -> &Option<IfcBeamTypeEnum> {
        &self.predefined_type
    }
}
impl IIfcBeamStandardCase for IfcBeamStandardCase {}
impl IfcBeamStandardCase {
    pub fn from_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcBeamStandardCase::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.global_id = parameter.into(),
                1usize => {
                    entity.owner_history = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => {
                    entity.object_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                5usize => {
                    entity.object_placement = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                6usize => {
                    entity.representation = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                7usize => {
                    entity.tag = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                8usize => {
                    entity.predefined_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcBeamType: IIfcBuildingElementType {
    fn predefined_type(&self) -> &IfcBeamTypeEnum;
}
#[derive(Default, Debug)]
pub struct IfcBeamType {
    global_id: IfcGloballyUniqueId,
    owner_history: Option<EntityRef>,
    name: Option<IfcLabel>,
    description: Option<IfcText>,
    applicable_occurrence: Option<IfcIdentifier>,
    has_property_sets: Option<HashSet<EntityRef>>,
    representation_maps: Option<Vec<EntityRef>>,
    tag: Option<IfcLabel>,
    element_type: Option<IfcLabel>,
    predefined_type: IfcBeamTypeEnum,
}
impl IIfcRoot for IfcBeamType {
    fn global_id(&self) -> &IfcGloballyUniqueId {
        &self.global_id
    }
    fn owner_history(&self) -> &Option<EntityRef> {
        &self.owner_history
    }
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
}
impl IIfcObjectDefinition for IfcBeamType {}
impl IIfcTypeObject for IfcBeamType {
    fn applicable_occurrence(&self) -> &Option<IfcIdentifier> {
        &self.applicable_occurrence
    }
    fn has_property_sets(&self) -> &Option<HashSet<EntityRef>> {
        &self.has_property_sets
    }
}
impl IIfcTypeProduct for IfcBeamType {
    fn representation_maps(&self) -> &Option<Vec<EntityRef>> {
        &self.representation_maps
    }
    fn tag(&self) -> &Option<IfcLabel> {
        &self.tag
    }
}
impl IIfcElementType for IfcBeamType {
    fn element_type(&self) -> &Option<IfcLabel> {
        &self.element_type
    }
}
impl IIfcBuildingElementType for IfcBeamType {}
impl IIfcBeamType for IfcBeamType {
    fn predefined_type(&self) -> &IfcBeamTypeEnum {
        &self.predefined_type
    }
}
impl IfcBeamType {
    pub fn from_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcBeamType::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.global_id = parameter.into(),
                1usize => {
                    entity.owner_history = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => {
                    entity.applicable_occurrence = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                5usize => {
                    entity.has_property_sets = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                6usize => {
                    entity.representation_maps = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                7usize => {
                    entity.tag = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                8usize => {
                    entity.element_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                9usize => entity.predefined_type = parameter.into(),
                _ => {}
            }
        }
        entity
    }
    pub fn from_own_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcBeamType::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.predefined_type = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcBlobTexture: IIfcSurfaceTexture {
    fn raster_format(&self) -> &IfcIdentifier;
    fn raster_code(&self) -> &IfcBinary;
}
#[derive(Default, Debug)]
pub struct IfcBlobTexture {
    repeat_s: IfcBoolean,
    repeat_t: IfcBoolean,
    mode: Option<IfcIdentifier>,
    texture_transform: Option<EntityRef>,
    parameter: Option<Vec<IfcIdentifier>>,
    raster_format: IfcIdentifier,
    raster_code: IfcBinary,
}
impl IIfcPresentationItem for IfcBlobTexture {}
impl IIfcSurfaceTexture for IfcBlobTexture {
    fn repeat_s(&self) -> &IfcBoolean {
        &self.repeat_s
    }
    fn repeat_t(&self) -> &IfcBoolean {
        &self.repeat_t
    }
    fn mode(&self) -> &Option<IfcIdentifier> {
        &self.mode
    }
    fn texture_transform(&self) -> &Option<EntityRef> {
        &self.texture_transform
    }
    fn parameter(&self) -> &Option<Vec<IfcIdentifier>> {
        &self.parameter
    }
}
impl IIfcBlobTexture for IfcBlobTexture {
    fn raster_format(&self) -> &IfcIdentifier {
        &self.raster_format
    }
    fn raster_code(&self) -> &IfcBinary {
        &self.raster_code
    }
}
impl IfcBlobTexture {
    pub fn from_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcBlobTexture::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.repeat_s = parameter.into(),
                1usize => entity.repeat_t = parameter.into(),
                2usize => {
                    entity.mode = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.texture_transform = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => {
                    entity.parameter = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                5usize => entity.raster_format = parameter.into(),
                6usize => entity.raster_code = parameter.into(),
                _ => {}
            }
        }
        entity
    }
    pub fn from_own_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcBlobTexture::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.raster_format = parameter.into(),
                1usize => entity.raster_code = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcBlock: IIfcCsgPrimitive3D {
    fn x_length(&self) -> &IfcPositiveLengthMeasure;
    fn y_length(&self) -> &IfcPositiveLengthMeasure;
    fn z_length(&self) -> &IfcPositiveLengthMeasure;
}
#[derive(Default, Debug)]
pub struct IfcBlock {
    position: EntityRef,
    x_length: IfcPositiveLengthMeasure,
    y_length: IfcPositiveLengthMeasure,
    z_length: IfcPositiveLengthMeasure,
}
impl IIfcRepresentationItem for IfcBlock {}
impl IIfcGeometricRepresentationItem for IfcBlock {}
impl IIfcCsgPrimitive3D for IfcBlock {
    fn position(&self) -> &EntityRef {
        &self.position
    }
}
impl IIfcBlock for IfcBlock {
    fn x_length(&self) -> &IfcPositiveLengthMeasure {
        &self.x_length
    }
    fn y_length(&self) -> &IfcPositiveLengthMeasure {
        &self.y_length
    }
    fn z_length(&self) -> &IfcPositiveLengthMeasure {
        &self.z_length
    }
}
impl IfcBlock {
    pub fn from_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcBlock::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.position = parameter.into(),
                1usize => entity.x_length = parameter.into(),
                2usize => entity.y_length = parameter.into(),
                3usize => entity.z_length = parameter.into(),
                _ => {}
            }
        }
        entity
    }
    pub fn from_own_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcBlock::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.x_length = parameter.into(),
                1usize => entity.y_length = parameter.into(),
                2usize => entity.z_length = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcBoiler: IIfcEnergyConversionDevice {
    fn predefined_type(&self) -> &Option<IfcBoilerTypeEnum>;
}
#[derive(Default, Debug)]
pub struct IfcBoiler {
    global_id: IfcGloballyUniqueId,
    owner_history: Option<EntityRef>,
    name: Option<IfcLabel>,
    description: Option<IfcText>,
    object_type: Option<IfcLabel>,
    object_placement: Option<EntityRef>,
    representation: Option<EntityRef>,
    tag: Option<IfcIdentifier>,
    predefined_type: Option<IfcBoilerTypeEnum>,
}
impl IIfcRoot for IfcBoiler {
    fn global_id(&self) -> &IfcGloballyUniqueId {
        &self.global_id
    }
    fn owner_history(&self) -> &Option<EntityRef> {
        &self.owner_history
    }
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
}
impl IIfcObjectDefinition for IfcBoiler {}
impl IIfcObject for IfcBoiler {
    fn object_type(&self) -> &Option<IfcLabel> {
        &self.object_type
    }
}
impl IIfcProduct for IfcBoiler {
    fn object_placement(&self) -> &Option<EntityRef> {
        &self.object_placement
    }
    fn representation(&self) -> &Option<EntityRef> {
        &self.representation
    }
}
impl IIfcElement for IfcBoiler {
    fn tag(&self) -> &Option<IfcIdentifier> {
        &self.tag
    }
}
impl IIfcDistributionElement for IfcBoiler {}
impl IIfcDistributionFlowElement for IfcBoiler {}
impl IIfcEnergyConversionDevice for IfcBoiler {}
impl IIfcBoiler for IfcBoiler {
    fn predefined_type(&self) -> &Option<IfcBoilerTypeEnum> {
        &self.predefined_type
    }
}
impl IfcBoiler {
    pub fn from_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcBoiler::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.global_id = parameter.into(),
                1usize => {
                    entity.owner_history = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => {
                    entity.object_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                5usize => {
                    entity.object_placement = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                6usize => {
                    entity.representation = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                7usize => {
                    entity.tag = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                8usize => {
                    entity.predefined_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
    pub fn from_own_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcBoiler::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => {
                    entity.predefined_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcBoilerType: IIfcEnergyConversionDeviceType {
    fn predefined_type(&self) -> &IfcBoilerTypeEnum;
}
#[derive(Default, Debug)]
pub struct IfcBoilerType {
    global_id: IfcGloballyUniqueId,
    owner_history: Option<EntityRef>,
    name: Option<IfcLabel>,
    description: Option<IfcText>,
    applicable_occurrence: Option<IfcIdentifier>,
    has_property_sets: Option<HashSet<EntityRef>>,
    representation_maps: Option<Vec<EntityRef>>,
    tag: Option<IfcLabel>,
    element_type: Option<IfcLabel>,
    predefined_type: IfcBoilerTypeEnum,
}
impl IIfcRoot for IfcBoilerType {
    fn global_id(&self) -> &IfcGloballyUniqueId {
        &self.global_id
    }
    fn owner_history(&self) -> &Option<EntityRef> {
        &self.owner_history
    }
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
}
impl IIfcObjectDefinition for IfcBoilerType {}
impl IIfcTypeObject for IfcBoilerType {
    fn applicable_occurrence(&self) -> &Option<IfcIdentifier> {
        &self.applicable_occurrence
    }
    fn has_property_sets(&self) -> &Option<HashSet<EntityRef>> {
        &self.has_property_sets
    }
}
impl IIfcTypeProduct for IfcBoilerType {
    fn representation_maps(&self) -> &Option<Vec<EntityRef>> {
        &self.representation_maps
    }
    fn tag(&self) -> &Option<IfcLabel> {
        &self.tag
    }
}
impl IIfcElementType for IfcBoilerType {
    fn element_type(&self) -> &Option<IfcLabel> {
        &self.element_type
    }
}
impl IIfcDistributionElementType for IfcBoilerType {}
impl IIfcDistributionFlowElementType for IfcBoilerType {}
impl IIfcEnergyConversionDeviceType for IfcBoilerType {}
impl IIfcBoilerType for IfcBoilerType {
    fn predefined_type(&self) -> &IfcBoilerTypeEnum {
        &self.predefined_type
    }
}
impl IfcBoilerType {
    pub fn from_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcBoilerType::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.global_id = parameter.into(),
                1usize => {
                    entity.owner_history = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => {
                    entity.applicable_occurrence = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                5usize => {
                    entity.has_property_sets = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                6usize => {
                    entity.representation_maps = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                7usize => {
                    entity.tag = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                8usize => {
                    entity.element_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                9usize => entity.predefined_type = parameter.into(),
                _ => {}
            }
        }
        entity
    }
    pub fn from_own_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcBoilerType::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.predefined_type = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcBooleanClippingResult: IIfcBooleanResult {}
#[derive(Default, Debug)]
pub struct IfcBooleanClippingResult {
    operator: IfcBooleanOperator,
    first_operand: EntityRef,
    second_operand: EntityRef,
}
impl IIfcRepresentationItem for IfcBooleanClippingResult {}
impl IIfcGeometricRepresentationItem for IfcBooleanClippingResult {}
impl IIfcBooleanResult for IfcBooleanClippingResult {
    fn operator(&self) -> &IfcBooleanOperator {
        &self.operator
    }
    fn first_operand(&self) -> &EntityRef {
        &self.first_operand
    }
    fn second_operand(&self) -> &EntityRef {
        &self.second_operand
    }
}
impl IIfcBooleanClippingResult for IfcBooleanClippingResult {}
impl IfcBooleanClippingResult {
    pub fn from_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcBooleanClippingResult::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.operator = parameter.into(),
                1usize => entity.first_operand = parameter.into(),
                2usize => entity.second_operand = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcBooleanResult: IIfcGeometricRepresentationItem {
    fn operator(&self) -> &IfcBooleanOperator;
    fn first_operand(&self) -> &EntityRef;
    fn second_operand(&self) -> &EntityRef;
}
#[derive(Default, Debug)]
pub struct IfcBooleanResult {
    operator: IfcBooleanOperator,
    first_operand: EntityRef,
    second_operand: EntityRef,
}
impl IIfcRepresentationItem for IfcBooleanResult {}
impl IIfcGeometricRepresentationItem for IfcBooleanResult {}
impl IIfcBooleanResult for IfcBooleanResult {
    fn operator(&self) -> &IfcBooleanOperator {
        &self.operator
    }
    fn first_operand(&self) -> &EntityRef {
        &self.first_operand
    }
    fn second_operand(&self) -> &EntityRef {
        &self.second_operand
    }
}
impl IfcBooleanResult {
    pub fn from_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcBooleanResult::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.operator = parameter.into(),
                1usize => entity.first_operand = parameter.into(),
                2usize => entity.second_operand = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcBoundaryCondition {
    fn name(&self) -> &Option<IfcLabel>;
}
pub trait IIfcBoundaryCurve: IIfcCompositeCurveOnSurface {}
#[derive(Default, Debug)]
pub struct IfcBoundaryCurve {
    segments: Vec<EntityRef>,
    self_intersect: IfcLogical,
}
impl IIfcRepresentationItem for IfcBoundaryCurve {}
impl IIfcGeometricRepresentationItem for IfcBoundaryCurve {}
impl IIfcCurve for IfcBoundaryCurve {}
impl IIfcBoundedCurve for IfcBoundaryCurve {}
impl IIfcCompositeCurve for IfcBoundaryCurve {
    fn segments(&self) -> &Vec<EntityRef> {
        &self.segments
    }
    fn self_intersect(&self) -> &IfcLogical {
        &self.self_intersect
    }
}
impl IIfcCompositeCurveOnSurface for IfcBoundaryCurve {}
impl IIfcBoundaryCurve for IfcBoundaryCurve {}
impl IfcBoundaryCurve {
    pub fn from_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcBoundaryCurve::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.segments = parameter.into(),
                1usize => entity.self_intersect = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcBoundaryEdgeCondition: IIfcBoundaryCondition {
    fn translational_stiffness_by_length_x(&self) -> &Option<IfcModulusOfTranslationalSubgradeReactionSelect>;
    fn translational_stiffness_by_length_y(&self) -> &Option<IfcModulusOfTranslationalSubgradeReactionSelect>;
    fn translational_stiffness_by_length_z(&self) -> &Option<IfcModulusOfTranslationalSubgradeReactionSelect>;
    fn rotational_stiffness_by_length_x(&self) -> &Option<IfcModulusOfRotationalSubgradeReactionSelect>;
    fn rotational_stiffness_by_length_y(&self) -> &Option<IfcModulusOfRotationalSubgradeReactionSelect>;
    fn rotational_stiffness_by_length_z(&self) -> &Option<IfcModulusOfRotationalSubgradeReactionSelect>;
}
#[derive(Default, Debug)]
pub struct IfcBoundaryEdgeCondition {
    name: Option<IfcLabel>,
    translational_stiffness_by_length_x: Option<IfcModulusOfTranslationalSubgradeReactionSelect>,
    translational_stiffness_by_length_y: Option<IfcModulusOfTranslationalSubgradeReactionSelect>,
    translational_stiffness_by_length_z: Option<IfcModulusOfTranslationalSubgradeReactionSelect>,
    rotational_stiffness_by_length_x: Option<IfcModulusOfRotationalSubgradeReactionSelect>,
    rotational_stiffness_by_length_y: Option<IfcModulusOfRotationalSubgradeReactionSelect>,
    rotational_stiffness_by_length_z: Option<IfcModulusOfRotationalSubgradeReactionSelect>,
}
impl IIfcBoundaryCondition for IfcBoundaryEdgeCondition {
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
}
impl IIfcBoundaryEdgeCondition for IfcBoundaryEdgeCondition {
    fn translational_stiffness_by_length_x(&self) -> &Option<IfcModulusOfTranslationalSubgradeReactionSelect> {
        &self.translational_stiffness_by_length_x
    }
    fn translational_stiffness_by_length_y(&self) -> &Option<IfcModulusOfTranslationalSubgradeReactionSelect> {
        &self.translational_stiffness_by_length_y
    }
    fn translational_stiffness_by_length_z(&self) -> &Option<IfcModulusOfTranslationalSubgradeReactionSelect> {
        &self.translational_stiffness_by_length_z
    }
    fn rotational_stiffness_by_length_x(&self) -> &Option<IfcModulusOfRotationalSubgradeReactionSelect> {
        &self.rotational_stiffness_by_length_x
    }
    fn rotational_stiffness_by_length_y(&self) -> &Option<IfcModulusOfRotationalSubgradeReactionSelect> {
        &self.rotational_stiffness_by_length_y
    }
    fn rotational_stiffness_by_length_z(&self) -> &Option<IfcModulusOfRotationalSubgradeReactionSelect> {
        &self.rotational_stiffness_by_length_z
    }
}
impl IfcBoundaryEdgeCondition {
    pub fn from_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcBoundaryEdgeCondition::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                1usize => {
                    entity.translational_stiffness_by_length_x = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => {
                    entity.translational_stiffness_by_length_y = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.translational_stiffness_by_length_z = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => {
                    entity.rotational_stiffness_by_length_x = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                5usize => {
                    entity.rotational_stiffness_by_length_y = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                6usize => {
                    entity.rotational_stiffness_by_length_z = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
    pub fn from_own_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcBoundaryEdgeCondition::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => {
                    entity.translational_stiffness_by_length_x = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                1usize => {
                    entity.translational_stiffness_by_length_y = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => {
                    entity.translational_stiffness_by_length_z = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.rotational_stiffness_by_length_x = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => {
                    entity.rotational_stiffness_by_length_y = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                5usize => {
                    entity.rotational_stiffness_by_length_z = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcBoundaryFaceCondition: IIfcBoundaryCondition {
    fn translational_stiffness_by_area_x(&self) -> &Option<IfcModulusOfSubgradeReactionSelect>;
    fn translational_stiffness_by_area_y(&self) -> &Option<IfcModulusOfSubgradeReactionSelect>;
    fn translational_stiffness_by_area_z(&self) -> &Option<IfcModulusOfSubgradeReactionSelect>;
}
#[derive(Default, Debug)]
pub struct IfcBoundaryFaceCondition {
    name: Option<IfcLabel>,
    translational_stiffness_by_area_x: Option<IfcModulusOfSubgradeReactionSelect>,
    translational_stiffness_by_area_y: Option<IfcModulusOfSubgradeReactionSelect>,
    translational_stiffness_by_area_z: Option<IfcModulusOfSubgradeReactionSelect>,
}
impl IIfcBoundaryCondition for IfcBoundaryFaceCondition {
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
}
impl IIfcBoundaryFaceCondition for IfcBoundaryFaceCondition {
    fn translational_stiffness_by_area_x(&self) -> &Option<IfcModulusOfSubgradeReactionSelect> {
        &self.translational_stiffness_by_area_x
    }
    fn translational_stiffness_by_area_y(&self) -> &Option<IfcModulusOfSubgradeReactionSelect> {
        &self.translational_stiffness_by_area_y
    }
    fn translational_stiffness_by_area_z(&self) -> &Option<IfcModulusOfSubgradeReactionSelect> {
        &self.translational_stiffness_by_area_z
    }
}
impl IfcBoundaryFaceCondition {
    pub fn from_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcBoundaryFaceCondition::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                1usize => {
                    entity.translational_stiffness_by_area_x = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => {
                    entity.translational_stiffness_by_area_y = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.translational_stiffness_by_area_z = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
    pub fn from_own_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcBoundaryFaceCondition::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => {
                    entity.translational_stiffness_by_area_x = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                1usize => {
                    entity.translational_stiffness_by_area_y = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => {
                    entity.translational_stiffness_by_area_z = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcBoundaryNodeCondition: IIfcBoundaryCondition {
    fn translational_stiffness_x(&self) -> &Option<IfcTranslationalStiffnessSelect>;
    fn translational_stiffness_y(&self) -> &Option<IfcTranslationalStiffnessSelect>;
    fn translational_stiffness_z(&self) -> &Option<IfcTranslationalStiffnessSelect>;
    fn rotational_stiffness_x(&self) -> &Option<IfcRotationalStiffnessSelect>;
    fn rotational_stiffness_y(&self) -> &Option<IfcRotationalStiffnessSelect>;
    fn rotational_stiffness_z(&self) -> &Option<IfcRotationalStiffnessSelect>;
}
#[derive(Default, Debug)]
pub struct IfcBoundaryNodeCondition {
    name: Option<IfcLabel>,
    translational_stiffness_x: Option<IfcTranslationalStiffnessSelect>,
    translational_stiffness_y: Option<IfcTranslationalStiffnessSelect>,
    translational_stiffness_z: Option<IfcTranslationalStiffnessSelect>,
    rotational_stiffness_x: Option<IfcRotationalStiffnessSelect>,
    rotational_stiffness_y: Option<IfcRotationalStiffnessSelect>,
    rotational_stiffness_z: Option<IfcRotationalStiffnessSelect>,
}
impl IIfcBoundaryCondition for IfcBoundaryNodeCondition {
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
}
impl IIfcBoundaryNodeCondition for IfcBoundaryNodeCondition {
    fn translational_stiffness_x(&self) -> &Option<IfcTranslationalStiffnessSelect> {
        &self.translational_stiffness_x
    }
    fn translational_stiffness_y(&self) -> &Option<IfcTranslationalStiffnessSelect> {
        &self.translational_stiffness_y
    }
    fn translational_stiffness_z(&self) -> &Option<IfcTranslationalStiffnessSelect> {
        &self.translational_stiffness_z
    }
    fn rotational_stiffness_x(&self) -> &Option<IfcRotationalStiffnessSelect> {
        &self.rotational_stiffness_x
    }
    fn rotational_stiffness_y(&self) -> &Option<IfcRotationalStiffnessSelect> {
        &self.rotational_stiffness_y
    }
    fn rotational_stiffness_z(&self) -> &Option<IfcRotationalStiffnessSelect> {
        &self.rotational_stiffness_z
    }
}
impl IfcBoundaryNodeCondition {
    pub fn from_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcBoundaryNodeCondition::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                1usize => {
                    entity.translational_stiffness_x = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => {
                    entity.translational_stiffness_y = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.translational_stiffness_z = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => {
                    entity.rotational_stiffness_x = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                5usize => {
                    entity.rotational_stiffness_y = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                6usize => {
                    entity.rotational_stiffness_z = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
    pub fn from_own_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcBoundaryNodeCondition::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => {
                    entity.translational_stiffness_x = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                1usize => {
                    entity.translational_stiffness_y = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => {
                    entity.translational_stiffness_z = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.rotational_stiffness_x = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => {
                    entity.rotational_stiffness_y = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                5usize => {
                    entity.rotational_stiffness_z = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcBoundaryNodeConditionWarping: IIfcBoundaryNodeCondition {
    fn warping_stiffness(&self) -> &Option<IfcWarpingStiffnessSelect>;
}
#[derive(Default, Debug)]
pub struct IfcBoundaryNodeConditionWarping {
    name: Option<IfcLabel>,
    translational_stiffness_x: Option<IfcTranslationalStiffnessSelect>,
    translational_stiffness_y: Option<IfcTranslationalStiffnessSelect>,
    translational_stiffness_z: Option<IfcTranslationalStiffnessSelect>,
    rotational_stiffness_x: Option<IfcRotationalStiffnessSelect>,
    rotational_stiffness_y: Option<IfcRotationalStiffnessSelect>,
    rotational_stiffness_z: Option<IfcRotationalStiffnessSelect>,
    warping_stiffness: Option<IfcWarpingStiffnessSelect>,
}
impl IIfcBoundaryCondition for IfcBoundaryNodeConditionWarping {
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
}
impl IIfcBoundaryNodeCondition for IfcBoundaryNodeConditionWarping {
    fn translational_stiffness_x(&self) -> &Option<IfcTranslationalStiffnessSelect> {
        &self.translational_stiffness_x
    }
    fn translational_stiffness_y(&self) -> &Option<IfcTranslationalStiffnessSelect> {
        &self.translational_stiffness_y
    }
    fn translational_stiffness_z(&self) -> &Option<IfcTranslationalStiffnessSelect> {
        &self.translational_stiffness_z
    }
    fn rotational_stiffness_x(&self) -> &Option<IfcRotationalStiffnessSelect> {
        &self.rotational_stiffness_x
    }
    fn rotational_stiffness_y(&self) -> &Option<IfcRotationalStiffnessSelect> {
        &self.rotational_stiffness_y
    }
    fn rotational_stiffness_z(&self) -> &Option<IfcRotationalStiffnessSelect> {
        &self.rotational_stiffness_z
    }
}
impl IIfcBoundaryNodeConditionWarping for IfcBoundaryNodeConditionWarping {
    fn warping_stiffness(&self) -> &Option<IfcWarpingStiffnessSelect> {
        &self.warping_stiffness
    }
}
impl IfcBoundaryNodeConditionWarping {
    pub fn from_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcBoundaryNodeConditionWarping::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                1usize => {
                    entity.translational_stiffness_x = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => {
                    entity.translational_stiffness_y = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.translational_stiffness_z = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => {
                    entity.rotational_stiffness_x = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                5usize => {
                    entity.rotational_stiffness_y = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                6usize => {
                    entity.rotational_stiffness_z = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                7usize => {
                    entity.warping_stiffness = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
    pub fn from_own_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcBoundaryNodeConditionWarping::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => {
                    entity.warping_stiffness = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcBoundedCurve: IIfcCurve {}
pub trait IIfcBoundedSurface: IIfcSurface {}
pub trait IIfcBoundingBox: IIfcGeometricRepresentationItem {
    fn corner(&self) -> &EntityRef;
    fn x_dim(&self) -> &IfcPositiveLengthMeasure;
    fn y_dim(&self) -> &IfcPositiveLengthMeasure;
    fn z_dim(&self) -> &IfcPositiveLengthMeasure;
}
#[derive(Default, Debug)]
pub struct IfcBoundingBox {
    corner: EntityRef,
    x_dim: IfcPositiveLengthMeasure,
    y_dim: IfcPositiveLengthMeasure,
    z_dim: IfcPositiveLengthMeasure,
}
impl IIfcRepresentationItem for IfcBoundingBox {}
impl IIfcGeometricRepresentationItem for IfcBoundingBox {}
impl IIfcBoundingBox for IfcBoundingBox {
    fn corner(&self) -> &EntityRef {
        &self.corner
    }
    fn x_dim(&self) -> &IfcPositiveLengthMeasure {
        &self.x_dim
    }
    fn y_dim(&self) -> &IfcPositiveLengthMeasure {
        &self.y_dim
    }
    fn z_dim(&self) -> &IfcPositiveLengthMeasure {
        &self.z_dim
    }
}
impl IfcBoundingBox {
    pub fn from_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcBoundingBox::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.corner = parameter.into(),
                1usize => entity.x_dim = parameter.into(),
                2usize => entity.y_dim = parameter.into(),
                3usize => entity.z_dim = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcBoxedHalfSpace: IIfcHalfSpaceSolid {
    fn enclosure(&self) -> &EntityRef;
}
#[derive(Default, Debug)]
pub struct IfcBoxedHalfSpace {
    base_surface: EntityRef,
    agreement_flag: IfcBoolean,
    enclosure: EntityRef,
}
impl IIfcRepresentationItem for IfcBoxedHalfSpace {}
impl IIfcGeometricRepresentationItem for IfcBoxedHalfSpace {}
impl IIfcHalfSpaceSolid for IfcBoxedHalfSpace {
    fn base_surface(&self) -> &EntityRef {
        &self.base_surface
    }
    fn agreement_flag(&self) -> &IfcBoolean {
        &self.agreement_flag
    }
}
impl IIfcBoxedHalfSpace for IfcBoxedHalfSpace {
    fn enclosure(&self) -> &EntityRef {
        &self.enclosure
    }
}
impl IfcBoxedHalfSpace {
    pub fn from_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcBoxedHalfSpace::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.base_surface = parameter.into(),
                1usize => entity.agreement_flag = parameter.into(),
                2usize => entity.enclosure = parameter.into(),
                _ => {}
            }
        }
        entity
    }
    pub fn from_own_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcBoxedHalfSpace::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.enclosure = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcBuilding: IIfcSpatialStructureElement {
    fn elevation_of_ref_height(&self) -> &Option<IfcLengthMeasure>;
    fn elevation_of_terrain(&self) -> &Option<IfcLengthMeasure>;
    fn building_address(&self) -> &Option<EntityRef>;
}
#[derive(Default, Debug)]
pub struct IfcBuilding {
    global_id: IfcGloballyUniqueId,
    owner_history: Option<EntityRef>,
    name: Option<IfcLabel>,
    description: Option<IfcText>,
    object_type: Option<IfcLabel>,
    object_placement: Option<EntityRef>,
    representation: Option<EntityRef>,
    long_name: Option<IfcLabel>,
    composition_type: Option<IfcElementCompositionEnum>,
    elevation_of_ref_height: Option<IfcLengthMeasure>,
    elevation_of_terrain: Option<IfcLengthMeasure>,
    building_address: Option<EntityRef>,
}
impl IIfcRoot for IfcBuilding {
    fn global_id(&self) -> &IfcGloballyUniqueId {
        &self.global_id
    }
    fn owner_history(&self) -> &Option<EntityRef> {
        &self.owner_history
    }
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
}
impl IIfcObjectDefinition for IfcBuilding {}
impl IIfcObject for IfcBuilding {
    fn object_type(&self) -> &Option<IfcLabel> {
        &self.object_type
    }
}
impl IIfcProduct for IfcBuilding {
    fn object_placement(&self) -> &Option<EntityRef> {
        &self.object_placement
    }
    fn representation(&self) -> &Option<EntityRef> {
        &self.representation
    }
}
impl IIfcSpatialElement for IfcBuilding {
    fn long_name(&self) -> &Option<IfcLabel> {
        &self.long_name
    }
}
impl IIfcSpatialStructureElement for IfcBuilding {
    fn composition_type(&self) -> &Option<IfcElementCompositionEnum> {
        &self.composition_type
    }
}
impl IIfcBuilding for IfcBuilding {
    fn elevation_of_ref_height(&self) -> &Option<IfcLengthMeasure> {
        &self.elevation_of_ref_height
    }
    fn elevation_of_terrain(&self) -> &Option<IfcLengthMeasure> {
        &self.elevation_of_terrain
    }
    fn building_address(&self) -> &Option<EntityRef> {
        &self.building_address
    }
}
impl IfcBuilding {
    pub fn from_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcBuilding::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.global_id = parameter.into(),
                1usize => {
                    entity.owner_history = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => {
                    entity.object_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                5usize => {
                    entity.object_placement = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                6usize => {
                    entity.representation = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                7usize => {
                    entity.long_name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                8usize => {
                    entity.composition_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                9usize => {
                    entity.elevation_of_ref_height = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                10usize => {
                    entity.elevation_of_terrain = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                11usize => {
                    entity.building_address = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
    pub fn from_own_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcBuilding::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => {
                    entity.elevation_of_ref_height = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                1usize => {
                    entity.elevation_of_terrain = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => {
                    entity.building_address = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcBuildingElement: IIfcElement {}
pub trait IIfcBuildingElementPart: IIfcElementComponent {
    fn predefined_type(&self) -> &Option<IfcBuildingElementPartTypeEnum>;
}
#[derive(Default, Debug)]
pub struct IfcBuildingElementPart {
    global_id: IfcGloballyUniqueId,
    owner_history: Option<EntityRef>,
    name: Option<IfcLabel>,
    description: Option<IfcText>,
    object_type: Option<IfcLabel>,
    object_placement: Option<EntityRef>,
    representation: Option<EntityRef>,
    tag: Option<IfcIdentifier>,
    predefined_type: Option<IfcBuildingElementPartTypeEnum>,
}
impl IIfcRoot for IfcBuildingElementPart {
    fn global_id(&self) -> &IfcGloballyUniqueId {
        &self.global_id
    }
    fn owner_history(&self) -> &Option<EntityRef> {
        &self.owner_history
    }
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
}
impl IIfcObjectDefinition for IfcBuildingElementPart {}
impl IIfcObject for IfcBuildingElementPart {
    fn object_type(&self) -> &Option<IfcLabel> {
        &self.object_type
    }
}
impl IIfcProduct for IfcBuildingElementPart {
    fn object_placement(&self) -> &Option<EntityRef> {
        &self.object_placement
    }
    fn representation(&self) -> &Option<EntityRef> {
        &self.representation
    }
}
impl IIfcElement for IfcBuildingElementPart {
    fn tag(&self) -> &Option<IfcIdentifier> {
        &self.tag
    }
}
impl IIfcElementComponent for IfcBuildingElementPart {}
impl IIfcBuildingElementPart for IfcBuildingElementPart {
    fn predefined_type(&self) -> &Option<IfcBuildingElementPartTypeEnum> {
        &self.predefined_type
    }
}
impl IfcBuildingElementPart {
    pub fn from_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcBuildingElementPart::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.global_id = parameter.into(),
                1usize => {
                    entity.owner_history = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => {
                    entity.object_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                5usize => {
                    entity.object_placement = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                6usize => {
                    entity.representation = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                7usize => {
                    entity.tag = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                8usize => {
                    entity.predefined_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
    pub fn from_own_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcBuildingElementPart::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => {
                    entity.predefined_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcBuildingElementPartType: IIfcElementComponentType {
    fn predefined_type(&self) -> &IfcBuildingElementPartTypeEnum;
}
#[derive(Default, Debug)]
pub struct IfcBuildingElementPartType {
    global_id: IfcGloballyUniqueId,
    owner_history: Option<EntityRef>,
    name: Option<IfcLabel>,
    description: Option<IfcText>,
    applicable_occurrence: Option<IfcIdentifier>,
    has_property_sets: Option<HashSet<EntityRef>>,
    representation_maps: Option<Vec<EntityRef>>,
    tag: Option<IfcLabel>,
    element_type: Option<IfcLabel>,
    predefined_type: IfcBuildingElementPartTypeEnum,
}
impl IIfcRoot for IfcBuildingElementPartType {
    fn global_id(&self) -> &IfcGloballyUniqueId {
        &self.global_id
    }
    fn owner_history(&self) -> &Option<EntityRef> {
        &self.owner_history
    }
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
}
impl IIfcObjectDefinition for IfcBuildingElementPartType {}
impl IIfcTypeObject for IfcBuildingElementPartType {
    fn applicable_occurrence(&self) -> &Option<IfcIdentifier> {
        &self.applicable_occurrence
    }
    fn has_property_sets(&self) -> &Option<HashSet<EntityRef>> {
        &self.has_property_sets
    }
}
impl IIfcTypeProduct for IfcBuildingElementPartType {
    fn representation_maps(&self) -> &Option<Vec<EntityRef>> {
        &self.representation_maps
    }
    fn tag(&self) -> &Option<IfcLabel> {
        &self.tag
    }
}
impl IIfcElementType for IfcBuildingElementPartType {
    fn element_type(&self) -> &Option<IfcLabel> {
        &self.element_type
    }
}
impl IIfcElementComponentType for IfcBuildingElementPartType {}
impl IIfcBuildingElementPartType for IfcBuildingElementPartType {
    fn predefined_type(&self) -> &IfcBuildingElementPartTypeEnum {
        &self.predefined_type
    }
}
impl IfcBuildingElementPartType {
    pub fn from_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcBuildingElementPartType::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.global_id = parameter.into(),
                1usize => {
                    entity.owner_history = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => {
                    entity.applicable_occurrence = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                5usize => {
                    entity.has_property_sets = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                6usize => {
                    entity.representation_maps = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                7usize => {
                    entity.tag = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                8usize => {
                    entity.element_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                9usize => entity.predefined_type = parameter.into(),
                _ => {}
            }
        }
        entity
    }
    pub fn from_own_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcBuildingElementPartType::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.predefined_type = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcBuildingElementProxy: IIfcBuildingElement {
    fn predefined_type(&self) -> &Option<IfcBuildingElementProxyTypeEnum>;
}
#[derive(Default, Debug)]
pub struct IfcBuildingElementProxy {
    global_id: IfcGloballyUniqueId,
    owner_history: Option<EntityRef>,
    name: Option<IfcLabel>,
    description: Option<IfcText>,
    object_type: Option<IfcLabel>,
    object_placement: Option<EntityRef>,
    representation: Option<EntityRef>,
    tag: Option<IfcIdentifier>,
    predefined_type: Option<IfcBuildingElementProxyTypeEnum>,
}
impl IIfcRoot for IfcBuildingElementProxy {
    fn global_id(&self) -> &IfcGloballyUniqueId {
        &self.global_id
    }
    fn owner_history(&self) -> &Option<EntityRef> {
        &self.owner_history
    }
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
}
impl IIfcObjectDefinition for IfcBuildingElementProxy {}
impl IIfcObject for IfcBuildingElementProxy {
    fn object_type(&self) -> &Option<IfcLabel> {
        &self.object_type
    }
}
impl IIfcProduct for IfcBuildingElementProxy {
    fn object_placement(&self) -> &Option<EntityRef> {
        &self.object_placement
    }
    fn representation(&self) -> &Option<EntityRef> {
        &self.representation
    }
}
impl IIfcElement for IfcBuildingElementProxy {
    fn tag(&self) -> &Option<IfcIdentifier> {
        &self.tag
    }
}
impl IIfcBuildingElement for IfcBuildingElementProxy {}
impl IIfcBuildingElementProxy for IfcBuildingElementProxy {
    fn predefined_type(&self) -> &Option<IfcBuildingElementProxyTypeEnum> {
        &self.predefined_type
    }
}
impl IfcBuildingElementProxy {
    pub fn from_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcBuildingElementProxy::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.global_id = parameter.into(),
                1usize => {
                    entity.owner_history = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => {
                    entity.object_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                5usize => {
                    entity.object_placement = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                6usize => {
                    entity.representation = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                7usize => {
                    entity.tag = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                8usize => {
                    entity.predefined_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
    pub fn from_own_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcBuildingElementProxy::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => {
                    entity.predefined_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcBuildingElementProxyType: IIfcBuildingElementType {
    fn predefined_type(&self) -> &IfcBuildingElementProxyTypeEnum;
}
#[derive(Default, Debug)]
pub struct IfcBuildingElementProxyType {
    global_id: IfcGloballyUniqueId,
    owner_history: Option<EntityRef>,
    name: Option<IfcLabel>,
    description: Option<IfcText>,
    applicable_occurrence: Option<IfcIdentifier>,
    has_property_sets: Option<HashSet<EntityRef>>,
    representation_maps: Option<Vec<EntityRef>>,
    tag: Option<IfcLabel>,
    element_type: Option<IfcLabel>,
    predefined_type: IfcBuildingElementProxyTypeEnum,
}
impl IIfcRoot for IfcBuildingElementProxyType {
    fn global_id(&self) -> &IfcGloballyUniqueId {
        &self.global_id
    }
    fn owner_history(&self) -> &Option<EntityRef> {
        &self.owner_history
    }
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
}
impl IIfcObjectDefinition for IfcBuildingElementProxyType {}
impl IIfcTypeObject for IfcBuildingElementProxyType {
    fn applicable_occurrence(&self) -> &Option<IfcIdentifier> {
        &self.applicable_occurrence
    }
    fn has_property_sets(&self) -> &Option<HashSet<EntityRef>> {
        &self.has_property_sets
    }
}
impl IIfcTypeProduct for IfcBuildingElementProxyType {
    fn representation_maps(&self) -> &Option<Vec<EntityRef>> {
        &self.representation_maps
    }
    fn tag(&self) -> &Option<IfcLabel> {
        &self.tag
    }
}
impl IIfcElementType for IfcBuildingElementProxyType {
    fn element_type(&self) -> &Option<IfcLabel> {
        &self.element_type
    }
}
impl IIfcBuildingElementType for IfcBuildingElementProxyType {}
impl IIfcBuildingElementProxyType for IfcBuildingElementProxyType {
    fn predefined_type(&self) -> &IfcBuildingElementProxyTypeEnum {
        &self.predefined_type
    }
}
impl IfcBuildingElementProxyType {
    pub fn from_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcBuildingElementProxyType::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.global_id = parameter.into(),
                1usize => {
                    entity.owner_history = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => {
                    entity.applicable_occurrence = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                5usize => {
                    entity.has_property_sets = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                6usize => {
                    entity.representation_maps = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                7usize => {
                    entity.tag = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                8usize => {
                    entity.element_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                9usize => entity.predefined_type = parameter.into(),
                _ => {}
            }
        }
        entity
    }
    pub fn from_own_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcBuildingElementProxyType::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.predefined_type = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcBuildingElementType: IIfcElementType {}
pub trait IIfcBuildingStorey: IIfcSpatialStructureElement {
    fn elevation(&self) -> &Option<IfcLengthMeasure>;
}
#[derive(Default, Debug)]
pub struct IfcBuildingStorey {
    global_id: IfcGloballyUniqueId,
    owner_history: Option<EntityRef>,
    name: Option<IfcLabel>,
    description: Option<IfcText>,
    object_type: Option<IfcLabel>,
    object_placement: Option<EntityRef>,
    representation: Option<EntityRef>,
    long_name: Option<IfcLabel>,
    composition_type: Option<IfcElementCompositionEnum>,
    elevation: Option<IfcLengthMeasure>,
}
impl IIfcRoot for IfcBuildingStorey {
    fn global_id(&self) -> &IfcGloballyUniqueId {
        &self.global_id
    }
    fn owner_history(&self) -> &Option<EntityRef> {
        &self.owner_history
    }
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
}
impl IIfcObjectDefinition for IfcBuildingStorey {}
impl IIfcObject for IfcBuildingStorey {
    fn object_type(&self) -> &Option<IfcLabel> {
        &self.object_type
    }
}
impl IIfcProduct for IfcBuildingStorey {
    fn object_placement(&self) -> &Option<EntityRef> {
        &self.object_placement
    }
    fn representation(&self) -> &Option<EntityRef> {
        &self.representation
    }
}
impl IIfcSpatialElement for IfcBuildingStorey {
    fn long_name(&self) -> &Option<IfcLabel> {
        &self.long_name
    }
}
impl IIfcSpatialStructureElement for IfcBuildingStorey {
    fn composition_type(&self) -> &Option<IfcElementCompositionEnum> {
        &self.composition_type
    }
}
impl IIfcBuildingStorey for IfcBuildingStorey {
    fn elevation(&self) -> &Option<IfcLengthMeasure> {
        &self.elevation
    }
}
impl IfcBuildingStorey {
    pub fn from_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcBuildingStorey::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.global_id = parameter.into(),
                1usize => {
                    entity.owner_history = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => {
                    entity.object_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                5usize => {
                    entity.object_placement = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                6usize => {
                    entity.representation = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                7usize => {
                    entity.long_name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                8usize => {
                    entity.composition_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                9usize => {
                    entity.elevation = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
    pub fn from_own_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcBuildingStorey::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => {
                    entity.elevation = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcBuildingSystem: IIfcSystem {
    fn predefined_type(&self) -> &Option<IfcBuildingSystemTypeEnum>;
    fn long_name(&self) -> &Option<IfcLabel>;
}
#[derive(Default, Debug)]
pub struct IfcBuildingSystem {
    global_id: IfcGloballyUniqueId,
    owner_history: Option<EntityRef>,
    name: Option<IfcLabel>,
    description: Option<IfcText>,
    object_type: Option<IfcLabel>,
    predefined_type: Option<IfcBuildingSystemTypeEnum>,
    long_name: Option<IfcLabel>,
}
impl IIfcRoot for IfcBuildingSystem {
    fn global_id(&self) -> &IfcGloballyUniqueId {
        &self.global_id
    }
    fn owner_history(&self) -> &Option<EntityRef> {
        &self.owner_history
    }
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
}
impl IIfcObjectDefinition for IfcBuildingSystem {}
impl IIfcObject for IfcBuildingSystem {
    fn object_type(&self) -> &Option<IfcLabel> {
        &self.object_type
    }
}
impl IIfcGroup for IfcBuildingSystem {}
impl IIfcSystem for IfcBuildingSystem {}
impl IIfcBuildingSystem for IfcBuildingSystem {
    fn predefined_type(&self) -> &Option<IfcBuildingSystemTypeEnum> {
        &self.predefined_type
    }
    fn long_name(&self) -> &Option<IfcLabel> {
        &self.long_name
    }
}
impl IfcBuildingSystem {
    pub fn from_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcBuildingSystem::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.global_id = parameter.into(),
                1usize => {
                    entity.owner_history = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => {
                    entity.object_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                5usize => {
                    entity.predefined_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                6usize => {
                    entity.long_name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
    pub fn from_own_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcBuildingSystem::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => {
                    entity.predefined_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                1usize => {
                    entity.long_name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcBurner: IIfcEnergyConversionDevice {
    fn predefined_type(&self) -> &Option<IfcBurnerTypeEnum>;
}
#[derive(Default, Debug)]
pub struct IfcBurner {
    global_id: IfcGloballyUniqueId,
    owner_history: Option<EntityRef>,
    name: Option<IfcLabel>,
    description: Option<IfcText>,
    object_type: Option<IfcLabel>,
    object_placement: Option<EntityRef>,
    representation: Option<EntityRef>,
    tag: Option<IfcIdentifier>,
    predefined_type: Option<IfcBurnerTypeEnum>,
}
impl IIfcRoot for IfcBurner {
    fn global_id(&self) -> &IfcGloballyUniqueId {
        &self.global_id
    }
    fn owner_history(&self) -> &Option<EntityRef> {
        &self.owner_history
    }
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
}
impl IIfcObjectDefinition for IfcBurner {}
impl IIfcObject for IfcBurner {
    fn object_type(&self) -> &Option<IfcLabel> {
        &self.object_type
    }
}
impl IIfcProduct for IfcBurner {
    fn object_placement(&self) -> &Option<EntityRef> {
        &self.object_placement
    }
    fn representation(&self) -> &Option<EntityRef> {
        &self.representation
    }
}
impl IIfcElement for IfcBurner {
    fn tag(&self) -> &Option<IfcIdentifier> {
        &self.tag
    }
}
impl IIfcDistributionElement for IfcBurner {}
impl IIfcDistributionFlowElement for IfcBurner {}
impl IIfcEnergyConversionDevice for IfcBurner {}
impl IIfcBurner for IfcBurner {
    fn predefined_type(&self) -> &Option<IfcBurnerTypeEnum> {
        &self.predefined_type
    }
}
impl IfcBurner {
    pub fn from_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcBurner::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.global_id = parameter.into(),
                1usize => {
                    entity.owner_history = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => {
                    entity.object_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                5usize => {
                    entity.object_placement = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                6usize => {
                    entity.representation = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                7usize => {
                    entity.tag = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                8usize => {
                    entity.predefined_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
    pub fn from_own_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcBurner::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => {
                    entity.predefined_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcBurnerType: IIfcEnergyConversionDeviceType {
    fn predefined_type(&self) -> &IfcBurnerTypeEnum;
}
#[derive(Default, Debug)]
pub struct IfcBurnerType {
    global_id: IfcGloballyUniqueId,
    owner_history: Option<EntityRef>,
    name: Option<IfcLabel>,
    description: Option<IfcText>,
    applicable_occurrence: Option<IfcIdentifier>,
    has_property_sets: Option<HashSet<EntityRef>>,
    representation_maps: Option<Vec<EntityRef>>,
    tag: Option<IfcLabel>,
    element_type: Option<IfcLabel>,
    predefined_type: IfcBurnerTypeEnum,
}
impl IIfcRoot for IfcBurnerType {
    fn global_id(&self) -> &IfcGloballyUniqueId {
        &self.global_id
    }
    fn owner_history(&self) -> &Option<EntityRef> {
        &self.owner_history
    }
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
}
impl IIfcObjectDefinition for IfcBurnerType {}
impl IIfcTypeObject for IfcBurnerType {
    fn applicable_occurrence(&self) -> &Option<IfcIdentifier> {
        &self.applicable_occurrence
    }
    fn has_property_sets(&self) -> &Option<HashSet<EntityRef>> {
        &self.has_property_sets
    }
}
impl IIfcTypeProduct for IfcBurnerType {
    fn representation_maps(&self) -> &Option<Vec<EntityRef>> {
        &self.representation_maps
    }
    fn tag(&self) -> &Option<IfcLabel> {
        &self.tag
    }
}
impl IIfcElementType for IfcBurnerType {
    fn element_type(&self) -> &Option<IfcLabel> {
        &self.element_type
    }
}
impl IIfcDistributionElementType for IfcBurnerType {}
impl IIfcDistributionFlowElementType for IfcBurnerType {}
impl IIfcEnergyConversionDeviceType for IfcBurnerType {}
impl IIfcBurnerType for IfcBurnerType {
    fn predefined_type(&self) -> &IfcBurnerTypeEnum {
        &self.predefined_type
    }
}
impl IfcBurnerType {
    pub fn from_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcBurnerType::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.global_id = parameter.into(),
                1usize => {
                    entity.owner_history = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => {
                    entity.applicable_occurrence = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                5usize => {
                    entity.has_property_sets = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                6usize => {
                    entity.representation_maps = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                7usize => {
                    entity.tag = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                8usize => {
                    entity.element_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                9usize => entity.predefined_type = parameter.into(),
                _ => {}
            }
        }
        entity
    }
    pub fn from_own_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcBurnerType::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.predefined_type = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcCShapeProfileDef: IIfcParameterizedProfileDef {
    fn depth(&self) -> &IfcPositiveLengthMeasure;
    fn width(&self) -> &IfcPositiveLengthMeasure;
    fn wall_thickness(&self) -> &IfcPositiveLengthMeasure;
    fn girth(&self) -> &IfcPositiveLengthMeasure;
    fn internal_fillet_radius(&self) -> &Option<IfcNonNegativeLengthMeasure>;
}
#[derive(Default, Debug)]
pub struct IfcCShapeProfileDef {
    profile_type: IfcProfileTypeEnum,
    profile_name: Option<IfcLabel>,
    position: Option<EntityRef>,
    depth: IfcPositiveLengthMeasure,
    width: IfcPositiveLengthMeasure,
    wall_thickness: IfcPositiveLengthMeasure,
    girth: IfcPositiveLengthMeasure,
    internal_fillet_radius: Option<IfcNonNegativeLengthMeasure>,
}
impl IIfcProfileDef for IfcCShapeProfileDef {
    fn profile_type(&self) -> &IfcProfileTypeEnum {
        &self.profile_type
    }
    fn profile_name(&self) -> &Option<IfcLabel> {
        &self.profile_name
    }
}
impl IIfcParameterizedProfileDef for IfcCShapeProfileDef {
    fn position(&self) -> &Option<EntityRef> {
        &self.position
    }
}
impl IIfcCShapeProfileDef for IfcCShapeProfileDef {
    fn depth(&self) -> &IfcPositiveLengthMeasure {
        &self.depth
    }
    fn width(&self) -> &IfcPositiveLengthMeasure {
        &self.width
    }
    fn wall_thickness(&self) -> &IfcPositiveLengthMeasure {
        &self.wall_thickness
    }
    fn girth(&self) -> &IfcPositiveLengthMeasure {
        &self.girth
    }
    fn internal_fillet_radius(&self) -> &Option<IfcNonNegativeLengthMeasure> {
        &self.internal_fillet_radius
    }
}
impl IfcCShapeProfileDef {
    pub fn from_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcCShapeProfileDef::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.profile_type = parameter.into(),
                1usize => {
                    entity.profile_name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => {
                    entity.position = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => entity.depth = parameter.into(),
                4usize => entity.width = parameter.into(),
                5usize => entity.wall_thickness = parameter.into(),
                6usize => entity.girth = parameter.into(),
                7usize => {
                    entity.internal_fillet_radius = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
    pub fn from_own_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcCShapeProfileDef::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.depth = parameter.into(),
                1usize => entity.width = parameter.into(),
                2usize => entity.wall_thickness = parameter.into(),
                3usize => entity.girth = parameter.into(),
                4usize => {
                    entity.internal_fillet_radius = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcCableCarrierFitting: IIfcFlowFitting {
    fn predefined_type(&self) -> &Option<IfcCableCarrierFittingTypeEnum>;
}
#[derive(Default, Debug)]
pub struct IfcCableCarrierFitting {
    global_id: IfcGloballyUniqueId,
    owner_history: Option<EntityRef>,
    name: Option<IfcLabel>,
    description: Option<IfcText>,
    object_type: Option<IfcLabel>,
    object_placement: Option<EntityRef>,
    representation: Option<EntityRef>,
    tag: Option<IfcIdentifier>,
    predefined_type: Option<IfcCableCarrierFittingTypeEnum>,
}
impl IIfcRoot for IfcCableCarrierFitting {
    fn global_id(&self) -> &IfcGloballyUniqueId {
        &self.global_id
    }
    fn owner_history(&self) -> &Option<EntityRef> {
        &self.owner_history
    }
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
}
impl IIfcObjectDefinition for IfcCableCarrierFitting {}
impl IIfcObject for IfcCableCarrierFitting {
    fn object_type(&self) -> &Option<IfcLabel> {
        &self.object_type
    }
}
impl IIfcProduct for IfcCableCarrierFitting {
    fn object_placement(&self) -> &Option<EntityRef> {
        &self.object_placement
    }
    fn representation(&self) -> &Option<EntityRef> {
        &self.representation
    }
}
impl IIfcElement for IfcCableCarrierFitting {
    fn tag(&self) -> &Option<IfcIdentifier> {
        &self.tag
    }
}
impl IIfcDistributionElement for IfcCableCarrierFitting {}
impl IIfcDistributionFlowElement for IfcCableCarrierFitting {}
impl IIfcFlowFitting for IfcCableCarrierFitting {}
impl IIfcCableCarrierFitting for IfcCableCarrierFitting {
    fn predefined_type(&self) -> &Option<IfcCableCarrierFittingTypeEnum> {
        &self.predefined_type
    }
}
impl IfcCableCarrierFitting {
    pub fn from_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcCableCarrierFitting::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.global_id = parameter.into(),
                1usize => {
                    entity.owner_history = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => {
                    entity.object_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                5usize => {
                    entity.object_placement = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                6usize => {
                    entity.representation = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                7usize => {
                    entity.tag = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                8usize => {
                    entity.predefined_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
    pub fn from_own_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcCableCarrierFitting::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => {
                    entity.predefined_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcCableCarrierFittingType: IIfcFlowFittingType {
    fn predefined_type(&self) -> &IfcCableCarrierFittingTypeEnum;
}
#[derive(Default, Debug)]
pub struct IfcCableCarrierFittingType {
    global_id: IfcGloballyUniqueId,
    owner_history: Option<EntityRef>,
    name: Option<IfcLabel>,
    description: Option<IfcText>,
    applicable_occurrence: Option<IfcIdentifier>,
    has_property_sets: Option<HashSet<EntityRef>>,
    representation_maps: Option<Vec<EntityRef>>,
    tag: Option<IfcLabel>,
    element_type: Option<IfcLabel>,
    predefined_type: IfcCableCarrierFittingTypeEnum,
}
impl IIfcRoot for IfcCableCarrierFittingType {
    fn global_id(&self) -> &IfcGloballyUniqueId {
        &self.global_id
    }
    fn owner_history(&self) -> &Option<EntityRef> {
        &self.owner_history
    }
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
}
impl IIfcObjectDefinition for IfcCableCarrierFittingType {}
impl IIfcTypeObject for IfcCableCarrierFittingType {
    fn applicable_occurrence(&self) -> &Option<IfcIdentifier> {
        &self.applicable_occurrence
    }
    fn has_property_sets(&self) -> &Option<HashSet<EntityRef>> {
        &self.has_property_sets
    }
}
impl IIfcTypeProduct for IfcCableCarrierFittingType {
    fn representation_maps(&self) -> &Option<Vec<EntityRef>> {
        &self.representation_maps
    }
    fn tag(&self) -> &Option<IfcLabel> {
        &self.tag
    }
}
impl IIfcElementType for IfcCableCarrierFittingType {
    fn element_type(&self) -> &Option<IfcLabel> {
        &self.element_type
    }
}
impl IIfcDistributionElementType for IfcCableCarrierFittingType {}
impl IIfcDistributionFlowElementType for IfcCableCarrierFittingType {}
impl IIfcFlowFittingType for IfcCableCarrierFittingType {}
impl IIfcCableCarrierFittingType for IfcCableCarrierFittingType {
    fn predefined_type(&self) -> &IfcCableCarrierFittingTypeEnum {
        &self.predefined_type
    }
}
impl IfcCableCarrierFittingType {
    pub fn from_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcCableCarrierFittingType::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.global_id = parameter.into(),
                1usize => {
                    entity.owner_history = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => {
                    entity.applicable_occurrence = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                5usize => {
                    entity.has_property_sets = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                6usize => {
                    entity.representation_maps = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                7usize => {
                    entity.tag = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                8usize => {
                    entity.element_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                9usize => entity.predefined_type = parameter.into(),
                _ => {}
            }
        }
        entity
    }
    pub fn from_own_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcCableCarrierFittingType::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.predefined_type = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcCableCarrierSegment: IIfcFlowSegment {
    fn predefined_type(&self) -> &Option<IfcCableCarrierSegmentTypeEnum>;
}
#[derive(Default, Debug)]
pub struct IfcCableCarrierSegment {
    global_id: IfcGloballyUniqueId,
    owner_history: Option<EntityRef>,
    name: Option<IfcLabel>,
    description: Option<IfcText>,
    object_type: Option<IfcLabel>,
    object_placement: Option<EntityRef>,
    representation: Option<EntityRef>,
    tag: Option<IfcIdentifier>,
    predefined_type: Option<IfcCableCarrierSegmentTypeEnum>,
}
impl IIfcRoot for IfcCableCarrierSegment {
    fn global_id(&self) -> &IfcGloballyUniqueId {
        &self.global_id
    }
    fn owner_history(&self) -> &Option<EntityRef> {
        &self.owner_history
    }
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
}
impl IIfcObjectDefinition for IfcCableCarrierSegment {}
impl IIfcObject for IfcCableCarrierSegment {
    fn object_type(&self) -> &Option<IfcLabel> {
        &self.object_type
    }
}
impl IIfcProduct for IfcCableCarrierSegment {
    fn object_placement(&self) -> &Option<EntityRef> {
        &self.object_placement
    }
    fn representation(&self) -> &Option<EntityRef> {
        &self.representation
    }
}
impl IIfcElement for IfcCableCarrierSegment {
    fn tag(&self) -> &Option<IfcIdentifier> {
        &self.tag
    }
}
impl IIfcDistributionElement for IfcCableCarrierSegment {}
impl IIfcDistributionFlowElement for IfcCableCarrierSegment {}
impl IIfcFlowSegment for IfcCableCarrierSegment {}
impl IIfcCableCarrierSegment for IfcCableCarrierSegment {
    fn predefined_type(&self) -> &Option<IfcCableCarrierSegmentTypeEnum> {
        &self.predefined_type
    }
}
impl IfcCableCarrierSegment {
    pub fn from_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcCableCarrierSegment::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.global_id = parameter.into(),
                1usize => {
                    entity.owner_history = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => {
                    entity.object_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                5usize => {
                    entity.object_placement = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                6usize => {
                    entity.representation = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                7usize => {
                    entity.tag = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                8usize => {
                    entity.predefined_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
    pub fn from_own_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcCableCarrierSegment::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => {
                    entity.predefined_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcCableCarrierSegmentType: IIfcFlowSegmentType {
    fn predefined_type(&self) -> &IfcCableCarrierSegmentTypeEnum;
}
#[derive(Default, Debug)]
pub struct IfcCableCarrierSegmentType {
    global_id: IfcGloballyUniqueId,
    owner_history: Option<EntityRef>,
    name: Option<IfcLabel>,
    description: Option<IfcText>,
    applicable_occurrence: Option<IfcIdentifier>,
    has_property_sets: Option<HashSet<EntityRef>>,
    representation_maps: Option<Vec<EntityRef>>,
    tag: Option<IfcLabel>,
    element_type: Option<IfcLabel>,
    predefined_type: IfcCableCarrierSegmentTypeEnum,
}
impl IIfcRoot for IfcCableCarrierSegmentType {
    fn global_id(&self) -> &IfcGloballyUniqueId {
        &self.global_id
    }
    fn owner_history(&self) -> &Option<EntityRef> {
        &self.owner_history
    }
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
}
impl IIfcObjectDefinition for IfcCableCarrierSegmentType {}
impl IIfcTypeObject for IfcCableCarrierSegmentType {
    fn applicable_occurrence(&self) -> &Option<IfcIdentifier> {
        &self.applicable_occurrence
    }
    fn has_property_sets(&self) -> &Option<HashSet<EntityRef>> {
        &self.has_property_sets
    }
}
impl IIfcTypeProduct for IfcCableCarrierSegmentType {
    fn representation_maps(&self) -> &Option<Vec<EntityRef>> {
        &self.representation_maps
    }
    fn tag(&self) -> &Option<IfcLabel> {
        &self.tag
    }
}
impl IIfcElementType for IfcCableCarrierSegmentType {
    fn element_type(&self) -> &Option<IfcLabel> {
        &self.element_type
    }
}
impl IIfcDistributionElementType for IfcCableCarrierSegmentType {}
impl IIfcDistributionFlowElementType for IfcCableCarrierSegmentType {}
impl IIfcFlowSegmentType for IfcCableCarrierSegmentType {}
impl IIfcCableCarrierSegmentType for IfcCableCarrierSegmentType {
    fn predefined_type(&self) -> &IfcCableCarrierSegmentTypeEnum {
        &self.predefined_type
    }
}
impl IfcCableCarrierSegmentType {
    pub fn from_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcCableCarrierSegmentType::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.global_id = parameter.into(),
                1usize => {
                    entity.owner_history = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => {
                    entity.applicable_occurrence = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                5usize => {
                    entity.has_property_sets = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                6usize => {
                    entity.representation_maps = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                7usize => {
                    entity.tag = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                8usize => {
                    entity.element_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                9usize => entity.predefined_type = parameter.into(),
                _ => {}
            }
        }
        entity
    }
    pub fn from_own_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcCableCarrierSegmentType::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.predefined_type = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcCableFitting: IIfcFlowFitting {
    fn predefined_type(&self) -> &Option<IfcCableFittingTypeEnum>;
}
#[derive(Default, Debug)]
pub struct IfcCableFitting {
    global_id: IfcGloballyUniqueId,
    owner_history: Option<EntityRef>,
    name: Option<IfcLabel>,
    description: Option<IfcText>,
    object_type: Option<IfcLabel>,
    object_placement: Option<EntityRef>,
    representation: Option<EntityRef>,
    tag: Option<IfcIdentifier>,
    predefined_type: Option<IfcCableFittingTypeEnum>,
}
impl IIfcRoot for IfcCableFitting {
    fn global_id(&self) -> &IfcGloballyUniqueId {
        &self.global_id
    }
    fn owner_history(&self) -> &Option<EntityRef> {
        &self.owner_history
    }
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
}
impl IIfcObjectDefinition for IfcCableFitting {}
impl IIfcObject for IfcCableFitting {
    fn object_type(&self) -> &Option<IfcLabel> {
        &self.object_type
    }
}
impl IIfcProduct for IfcCableFitting {
    fn object_placement(&self) -> &Option<EntityRef> {
        &self.object_placement
    }
    fn representation(&self) -> &Option<EntityRef> {
        &self.representation
    }
}
impl IIfcElement for IfcCableFitting {
    fn tag(&self) -> &Option<IfcIdentifier> {
        &self.tag
    }
}
impl IIfcDistributionElement for IfcCableFitting {}
impl IIfcDistributionFlowElement for IfcCableFitting {}
impl IIfcFlowFitting for IfcCableFitting {}
impl IIfcCableFitting for IfcCableFitting {
    fn predefined_type(&self) -> &Option<IfcCableFittingTypeEnum> {
        &self.predefined_type
    }
}
impl IfcCableFitting {
    pub fn from_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcCableFitting::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.global_id = parameter.into(),
                1usize => {
                    entity.owner_history = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => {
                    entity.object_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                5usize => {
                    entity.object_placement = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                6usize => {
                    entity.representation = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                7usize => {
                    entity.tag = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                8usize => {
                    entity.predefined_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
    pub fn from_own_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcCableFitting::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => {
                    entity.predefined_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcCableFittingType: IIfcFlowFittingType {
    fn predefined_type(&self) -> &IfcCableFittingTypeEnum;
}
#[derive(Default, Debug)]
pub struct IfcCableFittingType {
    global_id: IfcGloballyUniqueId,
    owner_history: Option<EntityRef>,
    name: Option<IfcLabel>,
    description: Option<IfcText>,
    applicable_occurrence: Option<IfcIdentifier>,
    has_property_sets: Option<HashSet<EntityRef>>,
    representation_maps: Option<Vec<EntityRef>>,
    tag: Option<IfcLabel>,
    element_type: Option<IfcLabel>,
    predefined_type: IfcCableFittingTypeEnum,
}
impl IIfcRoot for IfcCableFittingType {
    fn global_id(&self) -> &IfcGloballyUniqueId {
        &self.global_id
    }
    fn owner_history(&self) -> &Option<EntityRef> {
        &self.owner_history
    }
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
}
impl IIfcObjectDefinition for IfcCableFittingType {}
impl IIfcTypeObject for IfcCableFittingType {
    fn applicable_occurrence(&self) -> &Option<IfcIdentifier> {
        &self.applicable_occurrence
    }
    fn has_property_sets(&self) -> &Option<HashSet<EntityRef>> {
        &self.has_property_sets
    }
}
impl IIfcTypeProduct for IfcCableFittingType {
    fn representation_maps(&self) -> &Option<Vec<EntityRef>> {
        &self.representation_maps
    }
    fn tag(&self) -> &Option<IfcLabel> {
        &self.tag
    }
}
impl IIfcElementType for IfcCableFittingType {
    fn element_type(&self) -> &Option<IfcLabel> {
        &self.element_type
    }
}
impl IIfcDistributionElementType for IfcCableFittingType {}
impl IIfcDistributionFlowElementType for IfcCableFittingType {}
impl IIfcFlowFittingType for IfcCableFittingType {}
impl IIfcCableFittingType for IfcCableFittingType {
    fn predefined_type(&self) -> &IfcCableFittingTypeEnum {
        &self.predefined_type
    }
}
impl IfcCableFittingType {
    pub fn from_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcCableFittingType::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.global_id = parameter.into(),
                1usize => {
                    entity.owner_history = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => {
                    entity.applicable_occurrence = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                5usize => {
                    entity.has_property_sets = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                6usize => {
                    entity.representation_maps = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                7usize => {
                    entity.tag = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                8usize => {
                    entity.element_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                9usize => entity.predefined_type = parameter.into(),
                _ => {}
            }
        }
        entity
    }
    pub fn from_own_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcCableFittingType::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.predefined_type = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcCableSegment: IIfcFlowSegment {
    fn predefined_type(&self) -> &Option<IfcCableSegmentTypeEnum>;
}
#[derive(Default, Debug)]
pub struct IfcCableSegment {
    global_id: IfcGloballyUniqueId,
    owner_history: Option<EntityRef>,
    name: Option<IfcLabel>,
    description: Option<IfcText>,
    object_type: Option<IfcLabel>,
    object_placement: Option<EntityRef>,
    representation: Option<EntityRef>,
    tag: Option<IfcIdentifier>,
    predefined_type: Option<IfcCableSegmentTypeEnum>,
}
impl IIfcRoot for IfcCableSegment {
    fn global_id(&self) -> &IfcGloballyUniqueId {
        &self.global_id
    }
    fn owner_history(&self) -> &Option<EntityRef> {
        &self.owner_history
    }
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
}
impl IIfcObjectDefinition for IfcCableSegment {}
impl IIfcObject for IfcCableSegment {
    fn object_type(&self) -> &Option<IfcLabel> {
        &self.object_type
    }
}
impl IIfcProduct for IfcCableSegment {
    fn object_placement(&self) -> &Option<EntityRef> {
        &self.object_placement
    }
    fn representation(&self) -> &Option<EntityRef> {
        &self.representation
    }
}
impl IIfcElement for IfcCableSegment {
    fn tag(&self) -> &Option<IfcIdentifier> {
        &self.tag
    }
}
impl IIfcDistributionElement for IfcCableSegment {}
impl IIfcDistributionFlowElement for IfcCableSegment {}
impl IIfcFlowSegment for IfcCableSegment {}
impl IIfcCableSegment for IfcCableSegment {
    fn predefined_type(&self) -> &Option<IfcCableSegmentTypeEnum> {
        &self.predefined_type
    }
}
impl IfcCableSegment {
    pub fn from_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcCableSegment::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.global_id = parameter.into(),
                1usize => {
                    entity.owner_history = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => {
                    entity.object_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                5usize => {
                    entity.object_placement = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                6usize => {
                    entity.representation = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                7usize => {
                    entity.tag = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                8usize => {
                    entity.predefined_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
    pub fn from_own_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcCableSegment::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => {
                    entity.predefined_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcCableSegmentType: IIfcFlowSegmentType {
    fn predefined_type(&self) -> &IfcCableSegmentTypeEnum;
}
#[derive(Default, Debug)]
pub struct IfcCableSegmentType {
    global_id: IfcGloballyUniqueId,
    owner_history: Option<EntityRef>,
    name: Option<IfcLabel>,
    description: Option<IfcText>,
    applicable_occurrence: Option<IfcIdentifier>,
    has_property_sets: Option<HashSet<EntityRef>>,
    representation_maps: Option<Vec<EntityRef>>,
    tag: Option<IfcLabel>,
    element_type: Option<IfcLabel>,
    predefined_type: IfcCableSegmentTypeEnum,
}
impl IIfcRoot for IfcCableSegmentType {
    fn global_id(&self) -> &IfcGloballyUniqueId {
        &self.global_id
    }
    fn owner_history(&self) -> &Option<EntityRef> {
        &self.owner_history
    }
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
}
impl IIfcObjectDefinition for IfcCableSegmentType {}
impl IIfcTypeObject for IfcCableSegmentType {
    fn applicable_occurrence(&self) -> &Option<IfcIdentifier> {
        &self.applicable_occurrence
    }
    fn has_property_sets(&self) -> &Option<HashSet<EntityRef>> {
        &self.has_property_sets
    }
}
impl IIfcTypeProduct for IfcCableSegmentType {
    fn representation_maps(&self) -> &Option<Vec<EntityRef>> {
        &self.representation_maps
    }
    fn tag(&self) -> &Option<IfcLabel> {
        &self.tag
    }
}
impl IIfcElementType for IfcCableSegmentType {
    fn element_type(&self) -> &Option<IfcLabel> {
        &self.element_type
    }
}
impl IIfcDistributionElementType for IfcCableSegmentType {}
impl IIfcDistributionFlowElementType for IfcCableSegmentType {}
impl IIfcFlowSegmentType for IfcCableSegmentType {}
impl IIfcCableSegmentType for IfcCableSegmentType {
    fn predefined_type(&self) -> &IfcCableSegmentTypeEnum {
        &self.predefined_type
    }
}
impl IfcCableSegmentType {
    pub fn from_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcCableSegmentType::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.global_id = parameter.into(),
                1usize => {
                    entity.owner_history = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => {
                    entity.applicable_occurrence = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                5usize => {
                    entity.has_property_sets = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                6usize => {
                    entity.representation_maps = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                7usize => {
                    entity.tag = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                8usize => {
                    entity.element_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                9usize => entity.predefined_type = parameter.into(),
                _ => {}
            }
        }
        entity
    }
    pub fn from_own_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcCableSegmentType::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.predefined_type = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcCartesianPoint: IIfcPoint {
    fn coordinates(&self) -> &Vec<IfcLengthMeasure>;
}
#[derive(Default, Debug)]
pub struct IfcCartesianPoint {
    coordinates: Vec<IfcLengthMeasure>,
}
impl IIfcRepresentationItem for IfcCartesianPoint {}
impl IIfcGeometricRepresentationItem for IfcCartesianPoint {}
impl IIfcPoint for IfcCartesianPoint {}
impl IIfcCartesianPoint for IfcCartesianPoint {
    fn coordinates(&self) -> &Vec<IfcLengthMeasure> {
        &self.coordinates
    }
}
impl IfcCartesianPoint {
    pub fn from_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcCartesianPoint::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.coordinates = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcCartesianPointList: IIfcGeometricRepresentationItem {}
pub trait IIfcCartesianPointList2D: IIfcCartesianPointList {
    fn coord_list(&self) -> &Vec<Vec<IfcLengthMeasure>>;
}
#[derive(Default, Debug)]
pub struct IfcCartesianPointList2D {
    coord_list: Vec<Vec<IfcLengthMeasure>>,
}
impl IIfcRepresentationItem for IfcCartesianPointList2D {}
impl IIfcGeometricRepresentationItem for IfcCartesianPointList2D {}
impl IIfcCartesianPointList for IfcCartesianPointList2D {}
impl IIfcCartesianPointList2D for IfcCartesianPointList2D {
    fn coord_list(&self) -> &Vec<Vec<IfcLengthMeasure>> {
        &self.coord_list
    }
}
impl IfcCartesianPointList2D {
    pub fn from_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcCartesianPointList2D::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.coord_list = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcCartesianPointList3D: IIfcCartesianPointList {
    fn coord_list(&self) -> &Vec<Vec<IfcLengthMeasure>>;
}
#[derive(Default, Debug)]
pub struct IfcCartesianPointList3D {
    coord_list: Vec<Vec<IfcLengthMeasure>>,
}
impl IIfcRepresentationItem for IfcCartesianPointList3D {}
impl IIfcGeometricRepresentationItem for IfcCartesianPointList3D {}
impl IIfcCartesianPointList for IfcCartesianPointList3D {}
impl IIfcCartesianPointList3D for IfcCartesianPointList3D {
    fn coord_list(&self) -> &Vec<Vec<IfcLengthMeasure>> {
        &self.coord_list
    }
}
impl IfcCartesianPointList3D {
    pub fn from_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcCartesianPointList3D::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.coord_list = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcCartesianTransformationOperator: IIfcGeometricRepresentationItem {
    fn axis1(&self) -> &Option<EntityRef>;
    fn axis2(&self) -> &Option<EntityRef>;
    fn local_origin(&self) -> &EntityRef;
    fn scale(&self) -> &Option<IfcReal>;
}
pub trait IIfcCartesianTransformationOperator2D: IIfcCartesianTransformationOperator {}
#[derive(Default, Debug)]
pub struct IfcCartesianTransformationOperator2D {
    axis1: Option<EntityRef>,
    axis2: Option<EntityRef>,
    local_origin: EntityRef,
    scale: Option<IfcReal>,
}
impl IIfcRepresentationItem for IfcCartesianTransformationOperator2D {}
impl IIfcGeometricRepresentationItem for IfcCartesianTransformationOperator2D {}
impl IIfcCartesianTransformationOperator for IfcCartesianTransformationOperator2D {
    fn axis1(&self) -> &Option<EntityRef> {
        &self.axis1
    }
    fn axis2(&self) -> &Option<EntityRef> {
        &self.axis2
    }
    fn local_origin(&self) -> &EntityRef {
        &self.local_origin
    }
    fn scale(&self) -> &Option<IfcReal> {
        &self.scale
    }
}
impl IIfcCartesianTransformationOperator2D for IfcCartesianTransformationOperator2D {}
impl IfcCartesianTransformationOperator2D {
    pub fn from_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcCartesianTransformationOperator2D::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => {
                    entity.axis1 = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                1usize => {
                    entity.axis2 = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => entity.local_origin = parameter.into(),
                3usize => {
                    entity.scale = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcCartesianTransformationOperator2DnonUniform: IIfcCartesianTransformationOperator2D {
    fn scale2(&self) -> &Option<IfcReal>;
}
#[derive(Default, Debug)]
pub struct IfcCartesianTransformationOperator2DnonUniform {
    axis1: Option<EntityRef>,
    axis2: Option<EntityRef>,
    local_origin: EntityRef,
    scale: Option<IfcReal>,
    scale2: Option<IfcReal>,
}
impl IIfcRepresentationItem for IfcCartesianTransformationOperator2DnonUniform {}
impl IIfcGeometricRepresentationItem for IfcCartesianTransformationOperator2DnonUniform {}
impl IIfcCartesianTransformationOperator for IfcCartesianTransformationOperator2DnonUniform {
    fn axis1(&self) -> &Option<EntityRef> {
        &self.axis1
    }
    fn axis2(&self) -> &Option<EntityRef> {
        &self.axis2
    }
    fn local_origin(&self) -> &EntityRef {
        &self.local_origin
    }
    fn scale(&self) -> &Option<IfcReal> {
        &self.scale
    }
}
impl IIfcCartesianTransformationOperator2D for IfcCartesianTransformationOperator2DnonUniform {}
impl IIfcCartesianTransformationOperator2DnonUniform for IfcCartesianTransformationOperator2DnonUniform {
    fn scale2(&self) -> &Option<IfcReal> {
        &self.scale2
    }
}
impl IfcCartesianTransformationOperator2DnonUniform {
    pub fn from_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcCartesianTransformationOperator2DnonUniform::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => {
                    entity.axis1 = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                1usize => {
                    entity.axis2 = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => entity.local_origin = parameter.into(),
                3usize => {
                    entity.scale = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => {
                    entity.scale2 = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
    pub fn from_own_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcCartesianTransformationOperator2DnonUniform::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => {
                    entity.scale2 = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcCartesianTransformationOperator3D: IIfcCartesianTransformationOperator {
    fn axis3(&self) -> &Option<EntityRef>;
}
#[derive(Default, Debug)]
pub struct IfcCartesianTransformationOperator3D {
    axis1: Option<EntityRef>,
    axis2: Option<EntityRef>,
    local_origin: EntityRef,
    scale: Option<IfcReal>,
    axis3: Option<EntityRef>,
}
impl IIfcRepresentationItem for IfcCartesianTransformationOperator3D {}
impl IIfcGeometricRepresentationItem for IfcCartesianTransformationOperator3D {}
impl IIfcCartesianTransformationOperator for IfcCartesianTransformationOperator3D {
    fn axis1(&self) -> &Option<EntityRef> {
        &self.axis1
    }
    fn axis2(&self) -> &Option<EntityRef> {
        &self.axis2
    }
    fn local_origin(&self) -> &EntityRef {
        &self.local_origin
    }
    fn scale(&self) -> &Option<IfcReal> {
        &self.scale
    }
}
impl IIfcCartesianTransformationOperator3D for IfcCartesianTransformationOperator3D {
    fn axis3(&self) -> &Option<EntityRef> {
        &self.axis3
    }
}
impl IfcCartesianTransformationOperator3D {
    pub fn from_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcCartesianTransformationOperator3D::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => {
                    entity.axis1 = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                1usize => {
                    entity.axis2 = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => entity.local_origin = parameter.into(),
                3usize => {
                    entity.scale = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => {
                    entity.axis3 = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
    pub fn from_own_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcCartesianTransformationOperator3D::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => {
                    entity.axis3 = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcCartesianTransformationOperator3DnonUniform: IIfcCartesianTransformationOperator3D {
    fn scale2(&self) -> &Option<IfcReal>;
    fn scale3(&self) -> &Option<IfcReal>;
}
#[derive(Default, Debug)]
pub struct IfcCartesianTransformationOperator3DnonUniform {
    axis1: Option<EntityRef>,
    axis2: Option<EntityRef>,
    local_origin: EntityRef,
    scale: Option<IfcReal>,
    axis3: Option<EntityRef>,
    scale2: Option<IfcReal>,
    scale3: Option<IfcReal>,
}
impl IIfcRepresentationItem for IfcCartesianTransformationOperator3DnonUniform {}
impl IIfcGeometricRepresentationItem for IfcCartesianTransformationOperator3DnonUniform {}
impl IIfcCartesianTransformationOperator for IfcCartesianTransformationOperator3DnonUniform {
    fn axis1(&self) -> &Option<EntityRef> {
        &self.axis1
    }
    fn axis2(&self) -> &Option<EntityRef> {
        &self.axis2
    }
    fn local_origin(&self) -> &EntityRef {
        &self.local_origin
    }
    fn scale(&self) -> &Option<IfcReal> {
        &self.scale
    }
}
impl IIfcCartesianTransformationOperator3D for IfcCartesianTransformationOperator3DnonUniform {
    fn axis3(&self) -> &Option<EntityRef> {
        &self.axis3
    }
}
impl IIfcCartesianTransformationOperator3DnonUniform for IfcCartesianTransformationOperator3DnonUniform {
    fn scale2(&self) -> &Option<IfcReal> {
        &self.scale2
    }
    fn scale3(&self) -> &Option<IfcReal> {
        &self.scale3
    }
}
impl IfcCartesianTransformationOperator3DnonUniform {
    pub fn from_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcCartesianTransformationOperator3DnonUniform::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => {
                    entity.axis1 = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                1usize => {
                    entity.axis2 = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => entity.local_origin = parameter.into(),
                3usize => {
                    entity.scale = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => {
                    entity.axis3 = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                5usize => {
                    entity.scale2 = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                6usize => {
                    entity.scale3 = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
    pub fn from_own_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcCartesianTransformationOperator3DnonUniform::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => {
                    entity.scale2 = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                1usize => {
                    entity.scale3 = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcCenterLineProfileDef: IIfcArbitraryOpenProfileDef {
    fn thickness(&self) -> &IfcPositiveLengthMeasure;
}
#[derive(Default, Debug)]
pub struct IfcCenterLineProfileDef {
    profile_type: IfcProfileTypeEnum,
    profile_name: Option<IfcLabel>,
    curve: EntityRef,
    thickness: IfcPositiveLengthMeasure,
}
impl IIfcProfileDef for IfcCenterLineProfileDef {
    fn profile_type(&self) -> &IfcProfileTypeEnum {
        &self.profile_type
    }
    fn profile_name(&self) -> &Option<IfcLabel> {
        &self.profile_name
    }
}
impl IIfcArbitraryOpenProfileDef for IfcCenterLineProfileDef {
    fn curve(&self) -> &EntityRef {
        &self.curve
    }
}
impl IIfcCenterLineProfileDef for IfcCenterLineProfileDef {
    fn thickness(&self) -> &IfcPositiveLengthMeasure {
        &self.thickness
    }
}
impl IfcCenterLineProfileDef {
    pub fn from_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcCenterLineProfileDef::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.profile_type = parameter.into(),
                1usize => {
                    entity.profile_name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => entity.curve = parameter.into(),
                3usize => entity.thickness = parameter.into(),
                _ => {}
            }
        }
        entity
    }
    pub fn from_own_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcCenterLineProfileDef::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.thickness = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcChiller: IIfcEnergyConversionDevice {
    fn predefined_type(&self) -> &Option<IfcChillerTypeEnum>;
}
#[derive(Default, Debug)]
pub struct IfcChiller {
    global_id: IfcGloballyUniqueId,
    owner_history: Option<EntityRef>,
    name: Option<IfcLabel>,
    description: Option<IfcText>,
    object_type: Option<IfcLabel>,
    object_placement: Option<EntityRef>,
    representation: Option<EntityRef>,
    tag: Option<IfcIdentifier>,
    predefined_type: Option<IfcChillerTypeEnum>,
}
impl IIfcRoot for IfcChiller {
    fn global_id(&self) -> &IfcGloballyUniqueId {
        &self.global_id
    }
    fn owner_history(&self) -> &Option<EntityRef> {
        &self.owner_history
    }
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
}
impl IIfcObjectDefinition for IfcChiller {}
impl IIfcObject for IfcChiller {
    fn object_type(&self) -> &Option<IfcLabel> {
        &self.object_type
    }
}
impl IIfcProduct for IfcChiller {
    fn object_placement(&self) -> &Option<EntityRef> {
        &self.object_placement
    }
    fn representation(&self) -> &Option<EntityRef> {
        &self.representation
    }
}
impl IIfcElement for IfcChiller {
    fn tag(&self) -> &Option<IfcIdentifier> {
        &self.tag
    }
}
impl IIfcDistributionElement for IfcChiller {}
impl IIfcDistributionFlowElement for IfcChiller {}
impl IIfcEnergyConversionDevice for IfcChiller {}
impl IIfcChiller for IfcChiller {
    fn predefined_type(&self) -> &Option<IfcChillerTypeEnum> {
        &self.predefined_type
    }
}
impl IfcChiller {
    pub fn from_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcChiller::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.global_id = parameter.into(),
                1usize => {
                    entity.owner_history = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => {
                    entity.object_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                5usize => {
                    entity.object_placement = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                6usize => {
                    entity.representation = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                7usize => {
                    entity.tag = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                8usize => {
                    entity.predefined_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
    pub fn from_own_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcChiller::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => {
                    entity.predefined_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcChillerType: IIfcEnergyConversionDeviceType {
    fn predefined_type(&self) -> &IfcChillerTypeEnum;
}
#[derive(Default, Debug)]
pub struct IfcChillerType {
    global_id: IfcGloballyUniqueId,
    owner_history: Option<EntityRef>,
    name: Option<IfcLabel>,
    description: Option<IfcText>,
    applicable_occurrence: Option<IfcIdentifier>,
    has_property_sets: Option<HashSet<EntityRef>>,
    representation_maps: Option<Vec<EntityRef>>,
    tag: Option<IfcLabel>,
    element_type: Option<IfcLabel>,
    predefined_type: IfcChillerTypeEnum,
}
impl IIfcRoot for IfcChillerType {
    fn global_id(&self) -> &IfcGloballyUniqueId {
        &self.global_id
    }
    fn owner_history(&self) -> &Option<EntityRef> {
        &self.owner_history
    }
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
}
impl IIfcObjectDefinition for IfcChillerType {}
impl IIfcTypeObject for IfcChillerType {
    fn applicable_occurrence(&self) -> &Option<IfcIdentifier> {
        &self.applicable_occurrence
    }
    fn has_property_sets(&self) -> &Option<HashSet<EntityRef>> {
        &self.has_property_sets
    }
}
impl IIfcTypeProduct for IfcChillerType {
    fn representation_maps(&self) -> &Option<Vec<EntityRef>> {
        &self.representation_maps
    }
    fn tag(&self) -> &Option<IfcLabel> {
        &self.tag
    }
}
impl IIfcElementType for IfcChillerType {
    fn element_type(&self) -> &Option<IfcLabel> {
        &self.element_type
    }
}
impl IIfcDistributionElementType for IfcChillerType {}
impl IIfcDistributionFlowElementType for IfcChillerType {}
impl IIfcEnergyConversionDeviceType for IfcChillerType {}
impl IIfcChillerType for IfcChillerType {
    fn predefined_type(&self) -> &IfcChillerTypeEnum {
        &self.predefined_type
    }
}
impl IfcChillerType {
    pub fn from_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcChillerType::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.global_id = parameter.into(),
                1usize => {
                    entity.owner_history = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => {
                    entity.applicable_occurrence = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                5usize => {
                    entity.has_property_sets = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                6usize => {
                    entity.representation_maps = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                7usize => {
                    entity.tag = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                8usize => {
                    entity.element_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                9usize => entity.predefined_type = parameter.into(),
                _ => {}
            }
        }
        entity
    }
    pub fn from_own_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcChillerType::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.predefined_type = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcChimney: IIfcBuildingElement {
    fn predefined_type(&self) -> &Option<IfcChimneyTypeEnum>;
}
#[derive(Default, Debug)]
pub struct IfcChimney {
    global_id: IfcGloballyUniqueId,
    owner_history: Option<EntityRef>,
    name: Option<IfcLabel>,
    description: Option<IfcText>,
    object_type: Option<IfcLabel>,
    object_placement: Option<EntityRef>,
    representation: Option<EntityRef>,
    tag: Option<IfcIdentifier>,
    predefined_type: Option<IfcChimneyTypeEnum>,
}
impl IIfcRoot for IfcChimney {
    fn global_id(&self) -> &IfcGloballyUniqueId {
        &self.global_id
    }
    fn owner_history(&self) -> &Option<EntityRef> {
        &self.owner_history
    }
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
}
impl IIfcObjectDefinition for IfcChimney {}
impl IIfcObject for IfcChimney {
    fn object_type(&self) -> &Option<IfcLabel> {
        &self.object_type
    }
}
impl IIfcProduct for IfcChimney {
    fn object_placement(&self) -> &Option<EntityRef> {
        &self.object_placement
    }
    fn representation(&self) -> &Option<EntityRef> {
        &self.representation
    }
}
impl IIfcElement for IfcChimney {
    fn tag(&self) -> &Option<IfcIdentifier> {
        &self.tag
    }
}
impl IIfcBuildingElement for IfcChimney {}
impl IIfcChimney for IfcChimney {
    fn predefined_type(&self) -> &Option<IfcChimneyTypeEnum> {
        &self.predefined_type
    }
}
impl IfcChimney {
    pub fn from_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcChimney::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.global_id = parameter.into(),
                1usize => {
                    entity.owner_history = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => {
                    entity.object_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                5usize => {
                    entity.object_placement = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                6usize => {
                    entity.representation = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                7usize => {
                    entity.tag = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                8usize => {
                    entity.predefined_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
    pub fn from_own_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcChimney::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => {
                    entity.predefined_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcChimneyType: IIfcBuildingElementType {
    fn predefined_type(&self) -> &IfcChimneyTypeEnum;
}
#[derive(Default, Debug)]
pub struct IfcChimneyType {
    global_id: IfcGloballyUniqueId,
    owner_history: Option<EntityRef>,
    name: Option<IfcLabel>,
    description: Option<IfcText>,
    applicable_occurrence: Option<IfcIdentifier>,
    has_property_sets: Option<HashSet<EntityRef>>,
    representation_maps: Option<Vec<EntityRef>>,
    tag: Option<IfcLabel>,
    element_type: Option<IfcLabel>,
    predefined_type: IfcChimneyTypeEnum,
}
impl IIfcRoot for IfcChimneyType {
    fn global_id(&self) -> &IfcGloballyUniqueId {
        &self.global_id
    }
    fn owner_history(&self) -> &Option<EntityRef> {
        &self.owner_history
    }
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
}
impl IIfcObjectDefinition for IfcChimneyType {}
impl IIfcTypeObject for IfcChimneyType {
    fn applicable_occurrence(&self) -> &Option<IfcIdentifier> {
        &self.applicable_occurrence
    }
    fn has_property_sets(&self) -> &Option<HashSet<EntityRef>> {
        &self.has_property_sets
    }
}
impl IIfcTypeProduct for IfcChimneyType {
    fn representation_maps(&self) -> &Option<Vec<EntityRef>> {
        &self.representation_maps
    }
    fn tag(&self) -> &Option<IfcLabel> {
        &self.tag
    }
}
impl IIfcElementType for IfcChimneyType {
    fn element_type(&self) -> &Option<IfcLabel> {
        &self.element_type
    }
}
impl IIfcBuildingElementType for IfcChimneyType {}
impl IIfcChimneyType for IfcChimneyType {
    fn predefined_type(&self) -> &IfcChimneyTypeEnum {
        &self.predefined_type
    }
}
impl IfcChimneyType {
    pub fn from_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcChimneyType::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.global_id = parameter.into(),
                1usize => {
                    entity.owner_history = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => {
                    entity.applicable_occurrence = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                5usize => {
                    entity.has_property_sets = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                6usize => {
                    entity.representation_maps = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                7usize => {
                    entity.tag = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                8usize => {
                    entity.element_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                9usize => entity.predefined_type = parameter.into(),
                _ => {}
            }
        }
        entity
    }
    pub fn from_own_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcChimneyType::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.predefined_type = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcCircle: IIfcConic {
    fn radius(&self) -> &IfcPositiveLengthMeasure;
}
#[derive(Default, Debug)]
pub struct IfcCircle {
    position: EntityRef,
    radius: IfcPositiveLengthMeasure,
}
impl IIfcRepresentationItem for IfcCircle {}
impl IIfcGeometricRepresentationItem for IfcCircle {}
impl IIfcCurve for IfcCircle {}
impl IIfcConic for IfcCircle {
    fn position(&self) -> &EntityRef {
        &self.position
    }
}
impl IIfcCircle for IfcCircle {
    fn radius(&self) -> &IfcPositiveLengthMeasure {
        &self.radius
    }
}
impl IfcCircle {
    pub fn from_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcCircle::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.position = parameter.into(),
                1usize => entity.radius = parameter.into(),
                _ => {}
            }
        }
        entity
    }
    pub fn from_own_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcCircle::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.radius = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcCircleHollowProfileDef: IIfcCircleProfileDef {
    fn wall_thickness(&self) -> &IfcPositiveLengthMeasure;
}
#[derive(Default, Debug)]
pub struct IfcCircleHollowProfileDef {
    profile_type: IfcProfileTypeEnum,
    profile_name: Option<IfcLabel>,
    position: Option<EntityRef>,
    radius: IfcPositiveLengthMeasure,
    wall_thickness: IfcPositiveLengthMeasure,
}
impl IIfcProfileDef for IfcCircleHollowProfileDef {
    fn profile_type(&self) -> &IfcProfileTypeEnum {
        &self.profile_type
    }
    fn profile_name(&self) -> &Option<IfcLabel> {
        &self.profile_name
    }
}
impl IIfcParameterizedProfileDef for IfcCircleHollowProfileDef {
    fn position(&self) -> &Option<EntityRef> {
        &self.position
    }
}
impl IIfcCircleProfileDef for IfcCircleHollowProfileDef {
    fn radius(&self) -> &IfcPositiveLengthMeasure {
        &self.radius
    }
}
impl IIfcCircleHollowProfileDef for IfcCircleHollowProfileDef {
    fn wall_thickness(&self) -> &IfcPositiveLengthMeasure {
        &self.wall_thickness
    }
}
impl IfcCircleHollowProfileDef {
    pub fn from_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcCircleHollowProfileDef::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.profile_type = parameter.into(),
                1usize => {
                    entity.profile_name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => {
                    entity.position = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => entity.radius = parameter.into(),
                4usize => entity.wall_thickness = parameter.into(),
                _ => {}
            }
        }
        entity
    }
    pub fn from_own_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcCircleHollowProfileDef::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.wall_thickness = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcCircleProfileDef: IIfcParameterizedProfileDef {
    fn radius(&self) -> &IfcPositiveLengthMeasure;
}
#[derive(Default, Debug)]
pub struct IfcCircleProfileDef {
    profile_type: IfcProfileTypeEnum,
    profile_name: Option<IfcLabel>,
    position: Option<EntityRef>,
    radius: IfcPositiveLengthMeasure,
}
impl IIfcProfileDef for IfcCircleProfileDef {
    fn profile_type(&self) -> &IfcProfileTypeEnum {
        &self.profile_type
    }
    fn profile_name(&self) -> &Option<IfcLabel> {
        &self.profile_name
    }
}
impl IIfcParameterizedProfileDef for IfcCircleProfileDef {
    fn position(&self) -> &Option<EntityRef> {
        &self.position
    }
}
impl IIfcCircleProfileDef for IfcCircleProfileDef {
    fn radius(&self) -> &IfcPositiveLengthMeasure {
        &self.radius
    }
}
impl IfcCircleProfileDef {
    pub fn from_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcCircleProfileDef::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.profile_type = parameter.into(),
                1usize => {
                    entity.profile_name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => {
                    entity.position = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => entity.radius = parameter.into(),
                _ => {}
            }
        }
        entity
    }
    pub fn from_own_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcCircleProfileDef::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.radius = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcCivilElement: IIfcElement {}
#[derive(Default, Debug)]
pub struct IfcCivilElement {
    global_id: IfcGloballyUniqueId,
    owner_history: Option<EntityRef>,
    name: Option<IfcLabel>,
    description: Option<IfcText>,
    object_type: Option<IfcLabel>,
    object_placement: Option<EntityRef>,
    representation: Option<EntityRef>,
    tag: Option<IfcIdentifier>,
}
impl IIfcRoot for IfcCivilElement {
    fn global_id(&self) -> &IfcGloballyUniqueId {
        &self.global_id
    }
    fn owner_history(&self) -> &Option<EntityRef> {
        &self.owner_history
    }
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
}
impl IIfcObjectDefinition for IfcCivilElement {}
impl IIfcObject for IfcCivilElement {
    fn object_type(&self) -> &Option<IfcLabel> {
        &self.object_type
    }
}
impl IIfcProduct for IfcCivilElement {
    fn object_placement(&self) -> &Option<EntityRef> {
        &self.object_placement
    }
    fn representation(&self) -> &Option<EntityRef> {
        &self.representation
    }
}
impl IIfcElement for IfcCivilElement {
    fn tag(&self) -> &Option<IfcIdentifier> {
        &self.tag
    }
}
impl IIfcCivilElement for IfcCivilElement {}
impl IfcCivilElement {
    pub fn from_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcCivilElement::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.global_id = parameter.into(),
                1usize => {
                    entity.owner_history = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => {
                    entity.object_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                5usize => {
                    entity.object_placement = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                6usize => {
                    entity.representation = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                7usize => {
                    entity.tag = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcCivilElementType: IIfcElementType {}
#[derive(Default, Debug)]
pub struct IfcCivilElementType {
    global_id: IfcGloballyUniqueId,
    owner_history: Option<EntityRef>,
    name: Option<IfcLabel>,
    description: Option<IfcText>,
    applicable_occurrence: Option<IfcIdentifier>,
    has_property_sets: Option<HashSet<EntityRef>>,
    representation_maps: Option<Vec<EntityRef>>,
    tag: Option<IfcLabel>,
    element_type: Option<IfcLabel>,
}
impl IIfcRoot for IfcCivilElementType {
    fn global_id(&self) -> &IfcGloballyUniqueId {
        &self.global_id
    }
    fn owner_history(&self) -> &Option<EntityRef> {
        &self.owner_history
    }
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
}
impl IIfcObjectDefinition for IfcCivilElementType {}
impl IIfcTypeObject for IfcCivilElementType {
    fn applicable_occurrence(&self) -> &Option<IfcIdentifier> {
        &self.applicable_occurrence
    }
    fn has_property_sets(&self) -> &Option<HashSet<EntityRef>> {
        &self.has_property_sets
    }
}
impl IIfcTypeProduct for IfcCivilElementType {
    fn representation_maps(&self) -> &Option<Vec<EntityRef>> {
        &self.representation_maps
    }
    fn tag(&self) -> &Option<IfcLabel> {
        &self.tag
    }
}
impl IIfcElementType for IfcCivilElementType {
    fn element_type(&self) -> &Option<IfcLabel> {
        &self.element_type
    }
}
impl IIfcCivilElementType for IfcCivilElementType {}
impl IfcCivilElementType {
    pub fn from_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcCivilElementType::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.global_id = parameter.into(),
                1usize => {
                    entity.owner_history = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => {
                    entity.applicable_occurrence = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                5usize => {
                    entity.has_property_sets = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                6usize => {
                    entity.representation_maps = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                7usize => {
                    entity.tag = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                8usize => {
                    entity.element_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcClassification: IIfcExternalInformation {
    fn source(&self) -> &Option<IfcLabel>;
    fn edition(&self) -> &Option<IfcLabel>;
    fn edition_date(&self) -> &Option<IfcDate>;
    fn name(&self) -> &IfcLabel;
    fn description(&self) -> &Option<IfcText>;
    fn location(&self) -> &Option<IfcUriReference>;
    fn reference_tokens(&self) -> &Option<Vec<IfcIdentifier>>;
}
#[derive(Default, Debug)]
pub struct IfcClassification {
    source: Option<IfcLabel>,
    edition: Option<IfcLabel>,
    edition_date: Option<IfcDate>,
    name: IfcLabel,
    description: Option<IfcText>,
    location: Option<IfcUriReference>,
    reference_tokens: Option<Vec<IfcIdentifier>>,
}
impl IIfcExternalInformation for IfcClassification {}
impl IIfcClassification for IfcClassification {
    fn source(&self) -> &Option<IfcLabel> {
        &self.source
    }
    fn edition(&self) -> &Option<IfcLabel> {
        &self.edition
    }
    fn edition_date(&self) -> &Option<IfcDate> {
        &self.edition_date
    }
    fn name(&self) -> &IfcLabel {
        &self.name
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
    fn location(&self) -> &Option<IfcUriReference> {
        &self.location
    }
    fn reference_tokens(&self) -> &Option<Vec<IfcIdentifier>> {
        &self.reference_tokens
    }
}
impl IfcClassification {
    pub fn from_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcClassification::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => {
                    entity.source = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                1usize => {
                    entity.edition = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => {
                    entity.edition_date = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => entity.name = parameter.into(),
                4usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                5usize => {
                    entity.location = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                6usize => {
                    entity.reference_tokens = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcClassificationReference: IIfcExternalReference {
    fn referenced_source(&self) -> &Option<EntityRef>;
    fn description(&self) -> &Option<IfcText>;
    fn sort(&self) -> &Option<IfcIdentifier>;
}
#[derive(Default, Debug)]
pub struct IfcClassificationReference {
    location: Option<IfcUriReference>,
    identification: Option<IfcIdentifier>,
    name: Option<IfcLabel>,
    referenced_source: Option<EntityRef>,
    description: Option<IfcText>,
    sort: Option<IfcIdentifier>,
}
impl IIfcExternalReference for IfcClassificationReference {
    fn location(&self) -> &Option<IfcUriReference> {
        &self.location
    }
    fn identification(&self) -> &Option<IfcIdentifier> {
        &self.identification
    }
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
}
impl IIfcClassificationReference for IfcClassificationReference {
    fn referenced_source(&self) -> &Option<EntityRef> {
        &self.referenced_source
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
    fn sort(&self) -> &Option<IfcIdentifier> {
        &self.sort
    }
}
impl IfcClassificationReference {
    pub fn from_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcClassificationReference::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => {
                    entity.location = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                1usize => {
                    entity.identification = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.referenced_source = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                5usize => {
                    entity.sort = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
    pub fn from_own_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcClassificationReference::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => {
                    entity.referenced_source = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                1usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => {
                    entity.sort = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcClosedShell: IIfcConnectedFaceSet {}
#[derive(Default, Debug)]
pub struct IfcClosedShell {
    cfs_faces: HashSet<EntityRef>,
}
impl IIfcRepresentationItem for IfcClosedShell {}
impl IIfcTopologicalRepresentationItem for IfcClosedShell {}
impl IIfcConnectedFaceSet for IfcClosedShell {
    fn cfs_faces(&self) -> &HashSet<EntityRef> {
        &self.cfs_faces
    }
}
impl IIfcClosedShell for IfcClosedShell {}
impl IfcClosedShell {
    pub fn from_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcClosedShell::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.cfs_faces = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcCoil: IIfcEnergyConversionDevice {
    fn predefined_type(&self) -> &Option<IfcCoilTypeEnum>;
}
#[derive(Default, Debug)]
pub struct IfcCoil {
    global_id: IfcGloballyUniqueId,
    owner_history: Option<EntityRef>,
    name: Option<IfcLabel>,
    description: Option<IfcText>,
    object_type: Option<IfcLabel>,
    object_placement: Option<EntityRef>,
    representation: Option<EntityRef>,
    tag: Option<IfcIdentifier>,
    predefined_type: Option<IfcCoilTypeEnum>,
}
impl IIfcRoot for IfcCoil {
    fn global_id(&self) -> &IfcGloballyUniqueId {
        &self.global_id
    }
    fn owner_history(&self) -> &Option<EntityRef> {
        &self.owner_history
    }
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
}
impl IIfcObjectDefinition for IfcCoil {}
impl IIfcObject for IfcCoil {
    fn object_type(&self) -> &Option<IfcLabel> {
        &self.object_type
    }
}
impl IIfcProduct for IfcCoil {
    fn object_placement(&self) -> &Option<EntityRef> {
        &self.object_placement
    }
    fn representation(&self) -> &Option<EntityRef> {
        &self.representation
    }
}
impl IIfcElement for IfcCoil {
    fn tag(&self) -> &Option<IfcIdentifier> {
        &self.tag
    }
}
impl IIfcDistributionElement for IfcCoil {}
impl IIfcDistributionFlowElement for IfcCoil {}
impl IIfcEnergyConversionDevice for IfcCoil {}
impl IIfcCoil for IfcCoil {
    fn predefined_type(&self) -> &Option<IfcCoilTypeEnum> {
        &self.predefined_type
    }
}
impl IfcCoil {
    pub fn from_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcCoil::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.global_id = parameter.into(),
                1usize => {
                    entity.owner_history = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => {
                    entity.object_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                5usize => {
                    entity.object_placement = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                6usize => {
                    entity.representation = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                7usize => {
                    entity.tag = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                8usize => {
                    entity.predefined_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
    pub fn from_own_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcCoil::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => {
                    entity.predefined_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcCoilType: IIfcEnergyConversionDeviceType {
    fn predefined_type(&self) -> &IfcCoilTypeEnum;
}
#[derive(Default, Debug)]
pub struct IfcCoilType {
    global_id: IfcGloballyUniqueId,
    owner_history: Option<EntityRef>,
    name: Option<IfcLabel>,
    description: Option<IfcText>,
    applicable_occurrence: Option<IfcIdentifier>,
    has_property_sets: Option<HashSet<EntityRef>>,
    representation_maps: Option<Vec<EntityRef>>,
    tag: Option<IfcLabel>,
    element_type: Option<IfcLabel>,
    predefined_type: IfcCoilTypeEnum,
}
impl IIfcRoot for IfcCoilType {
    fn global_id(&self) -> &IfcGloballyUniqueId {
        &self.global_id
    }
    fn owner_history(&self) -> &Option<EntityRef> {
        &self.owner_history
    }
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
}
impl IIfcObjectDefinition for IfcCoilType {}
impl IIfcTypeObject for IfcCoilType {
    fn applicable_occurrence(&self) -> &Option<IfcIdentifier> {
        &self.applicable_occurrence
    }
    fn has_property_sets(&self) -> &Option<HashSet<EntityRef>> {
        &self.has_property_sets
    }
}
impl IIfcTypeProduct for IfcCoilType {
    fn representation_maps(&self) -> &Option<Vec<EntityRef>> {
        &self.representation_maps
    }
    fn tag(&self) -> &Option<IfcLabel> {
        &self.tag
    }
}
impl IIfcElementType for IfcCoilType {
    fn element_type(&self) -> &Option<IfcLabel> {
        &self.element_type
    }
}
impl IIfcDistributionElementType for IfcCoilType {}
impl IIfcDistributionFlowElementType for IfcCoilType {}
impl IIfcEnergyConversionDeviceType for IfcCoilType {}
impl IIfcCoilType for IfcCoilType {
    fn predefined_type(&self) -> &IfcCoilTypeEnum {
        &self.predefined_type
    }
}
impl IfcCoilType {
    pub fn from_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcCoilType::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.global_id = parameter.into(),
                1usize => {
                    entity.owner_history = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => {
                    entity.applicable_occurrence = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                5usize => {
                    entity.has_property_sets = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                6usize => {
                    entity.representation_maps = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                7usize => {
                    entity.tag = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                8usize => {
                    entity.element_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                9usize => entity.predefined_type = parameter.into(),
                _ => {}
            }
        }
        entity
    }
    pub fn from_own_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcCoilType::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.predefined_type = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcColourRgb: IIfcColourSpecification {
    fn red(&self) -> &IfcNormalisedRatioMeasure;
    fn green(&self) -> &IfcNormalisedRatioMeasure;
    fn blue(&self) -> &IfcNormalisedRatioMeasure;
}
#[derive(Default, Debug)]
pub struct IfcColourRgb {
    name: Option<IfcLabel>,
    red: IfcNormalisedRatioMeasure,
    green: IfcNormalisedRatioMeasure,
    blue: IfcNormalisedRatioMeasure,
}
impl IIfcPresentationItem for IfcColourRgb {}
impl IIfcColourSpecification for IfcColourRgb {
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
}
impl IIfcColourRgb for IfcColourRgb {
    fn red(&self) -> &IfcNormalisedRatioMeasure {
        &self.red
    }
    fn green(&self) -> &IfcNormalisedRatioMeasure {
        &self.green
    }
    fn blue(&self) -> &IfcNormalisedRatioMeasure {
        &self.blue
    }
}
impl IfcColourRgb {
    pub fn from_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcColourRgb::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                1usize => entity.red = parameter.into(),
                2usize => entity.green = parameter.into(),
                3usize => entity.blue = parameter.into(),
                _ => {}
            }
        }
        entity
    }
    pub fn from_own_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcColourRgb::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.red = parameter.into(),
                1usize => entity.green = parameter.into(),
                2usize => entity.blue = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcColourRgbList: IIfcPresentationItem {
    fn colour_list(&self) -> &Vec<Vec<IfcNormalisedRatioMeasure>>;
}
#[derive(Default, Debug)]
pub struct IfcColourRgbList {
    colour_list: Vec<Vec<IfcNormalisedRatioMeasure>>,
}
impl IIfcPresentationItem for IfcColourRgbList {}
impl IIfcColourRgbList for IfcColourRgbList {
    fn colour_list(&self) -> &Vec<Vec<IfcNormalisedRatioMeasure>> {
        &self.colour_list
    }
}
impl IfcColourRgbList {
    pub fn from_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcColourRgbList::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.colour_list = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcColourSpecification: IIfcPresentationItem {
    fn name(&self) -> &Option<IfcLabel>;
}
pub trait IIfcColumn: IIfcBuildingElement {
    fn predefined_type(&self) -> &Option<IfcColumnTypeEnum>;
}
#[derive(Default, Debug)]
pub struct IfcColumn {
    global_id: IfcGloballyUniqueId,
    owner_history: Option<EntityRef>,
    name: Option<IfcLabel>,
    description: Option<IfcText>,
    object_type: Option<IfcLabel>,
    object_placement: Option<EntityRef>,
    representation: Option<EntityRef>,
    tag: Option<IfcIdentifier>,
    predefined_type: Option<IfcColumnTypeEnum>,
}
impl IIfcRoot for IfcColumn {
    fn global_id(&self) -> &IfcGloballyUniqueId {
        &self.global_id
    }
    fn owner_history(&self) -> &Option<EntityRef> {
        &self.owner_history
    }
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
}
impl IIfcObjectDefinition for IfcColumn {}
impl IIfcObject for IfcColumn {
    fn object_type(&self) -> &Option<IfcLabel> {
        &self.object_type
    }
}
impl IIfcProduct for IfcColumn {
    fn object_placement(&self) -> &Option<EntityRef> {
        &self.object_placement
    }
    fn representation(&self) -> &Option<EntityRef> {
        &self.representation
    }
}
impl IIfcElement for IfcColumn {
    fn tag(&self) -> &Option<IfcIdentifier> {
        &self.tag
    }
}
impl IIfcBuildingElement for IfcColumn {}
impl IIfcColumn for IfcColumn {
    fn predefined_type(&self) -> &Option<IfcColumnTypeEnum> {
        &self.predefined_type
    }
}
impl IfcColumn {
    pub fn from_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcColumn::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.global_id = parameter.into(),
                1usize => {
                    entity.owner_history = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => {
                    entity.object_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                5usize => {
                    entity.object_placement = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                6usize => {
                    entity.representation = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                7usize => {
                    entity.tag = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                8usize => {
                    entity.predefined_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
    pub fn from_own_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcColumn::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => {
                    entity.predefined_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcColumnStandardCase: IIfcColumn {}
#[derive(Default, Debug)]
pub struct IfcColumnStandardCase {
    global_id: IfcGloballyUniqueId,
    owner_history: Option<EntityRef>,
    name: Option<IfcLabel>,
    description: Option<IfcText>,
    object_type: Option<IfcLabel>,
    object_placement: Option<EntityRef>,
    representation: Option<EntityRef>,
    tag: Option<IfcIdentifier>,
    predefined_type: Option<IfcColumnTypeEnum>,
}
impl IIfcRoot for IfcColumnStandardCase {
    fn global_id(&self) -> &IfcGloballyUniqueId {
        &self.global_id
    }
    fn owner_history(&self) -> &Option<EntityRef> {
        &self.owner_history
    }
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
}
impl IIfcObjectDefinition for IfcColumnStandardCase {}
impl IIfcObject for IfcColumnStandardCase {
    fn object_type(&self) -> &Option<IfcLabel> {
        &self.object_type
    }
}
impl IIfcProduct for IfcColumnStandardCase {
    fn object_placement(&self) -> &Option<EntityRef> {
        &self.object_placement
    }
    fn representation(&self) -> &Option<EntityRef> {
        &self.representation
    }
}
impl IIfcElement for IfcColumnStandardCase {
    fn tag(&self) -> &Option<IfcIdentifier> {
        &self.tag
    }
}
impl IIfcBuildingElement for IfcColumnStandardCase {}
impl IIfcColumn for IfcColumnStandardCase {
    fn predefined_type(&self) -> &Option<IfcColumnTypeEnum> {
        &self.predefined_type
    }
}
impl IIfcColumnStandardCase for IfcColumnStandardCase {}
impl IfcColumnStandardCase {
    pub fn from_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcColumnStandardCase::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.global_id = parameter.into(),
                1usize => {
                    entity.owner_history = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => {
                    entity.object_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                5usize => {
                    entity.object_placement = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                6usize => {
                    entity.representation = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                7usize => {
                    entity.tag = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                8usize => {
                    entity.predefined_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcColumnType: IIfcBuildingElementType {
    fn predefined_type(&self) -> &IfcColumnTypeEnum;
}
#[derive(Default, Debug)]
pub struct IfcColumnType {
    global_id: IfcGloballyUniqueId,
    owner_history: Option<EntityRef>,
    name: Option<IfcLabel>,
    description: Option<IfcText>,
    applicable_occurrence: Option<IfcIdentifier>,
    has_property_sets: Option<HashSet<EntityRef>>,
    representation_maps: Option<Vec<EntityRef>>,
    tag: Option<IfcLabel>,
    element_type: Option<IfcLabel>,
    predefined_type: IfcColumnTypeEnum,
}
impl IIfcRoot for IfcColumnType {
    fn global_id(&self) -> &IfcGloballyUniqueId {
        &self.global_id
    }
    fn owner_history(&self) -> &Option<EntityRef> {
        &self.owner_history
    }
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
}
impl IIfcObjectDefinition for IfcColumnType {}
impl IIfcTypeObject for IfcColumnType {
    fn applicable_occurrence(&self) -> &Option<IfcIdentifier> {
        &self.applicable_occurrence
    }
    fn has_property_sets(&self) -> &Option<HashSet<EntityRef>> {
        &self.has_property_sets
    }
}
impl IIfcTypeProduct for IfcColumnType {
    fn representation_maps(&self) -> &Option<Vec<EntityRef>> {
        &self.representation_maps
    }
    fn tag(&self) -> &Option<IfcLabel> {
        &self.tag
    }
}
impl IIfcElementType for IfcColumnType {
    fn element_type(&self) -> &Option<IfcLabel> {
        &self.element_type
    }
}
impl IIfcBuildingElementType for IfcColumnType {}
impl IIfcColumnType for IfcColumnType {
    fn predefined_type(&self) -> &IfcColumnTypeEnum {
        &self.predefined_type
    }
}
impl IfcColumnType {
    pub fn from_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcColumnType::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.global_id = parameter.into(),
                1usize => {
                    entity.owner_history = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => {
                    entity.applicable_occurrence = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                5usize => {
                    entity.has_property_sets = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                6usize => {
                    entity.representation_maps = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                7usize => {
                    entity.tag = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                8usize => {
                    entity.element_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                9usize => entity.predefined_type = parameter.into(),
                _ => {}
            }
        }
        entity
    }
    pub fn from_own_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcColumnType::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.predefined_type = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcCommunicationsAppliance: IIfcFlowTerminal {
    fn predefined_type(&self) -> &Option<IfcCommunicationsApplianceTypeEnum>;
}
#[derive(Default, Debug)]
pub struct IfcCommunicationsAppliance {
    global_id: IfcGloballyUniqueId,
    owner_history: Option<EntityRef>,
    name: Option<IfcLabel>,
    description: Option<IfcText>,
    object_type: Option<IfcLabel>,
    object_placement: Option<EntityRef>,
    representation: Option<EntityRef>,
    tag: Option<IfcIdentifier>,
    predefined_type: Option<IfcCommunicationsApplianceTypeEnum>,
}
impl IIfcRoot for IfcCommunicationsAppliance {
    fn global_id(&self) -> &IfcGloballyUniqueId {
        &self.global_id
    }
    fn owner_history(&self) -> &Option<EntityRef> {
        &self.owner_history
    }
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
}
impl IIfcObjectDefinition for IfcCommunicationsAppliance {}
impl IIfcObject for IfcCommunicationsAppliance {
    fn object_type(&self) -> &Option<IfcLabel> {
        &self.object_type
    }
}
impl IIfcProduct for IfcCommunicationsAppliance {
    fn object_placement(&self) -> &Option<EntityRef> {
        &self.object_placement
    }
    fn representation(&self) -> &Option<EntityRef> {
        &self.representation
    }
}
impl IIfcElement for IfcCommunicationsAppliance {
    fn tag(&self) -> &Option<IfcIdentifier> {
        &self.tag
    }
}
impl IIfcDistributionElement for IfcCommunicationsAppliance {}
impl IIfcDistributionFlowElement for IfcCommunicationsAppliance {}
impl IIfcFlowTerminal for IfcCommunicationsAppliance {}
impl IIfcCommunicationsAppliance for IfcCommunicationsAppliance {
    fn predefined_type(&self) -> &Option<IfcCommunicationsApplianceTypeEnum> {
        &self.predefined_type
    }
}
impl IfcCommunicationsAppliance {
    pub fn from_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcCommunicationsAppliance::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.global_id = parameter.into(),
                1usize => {
                    entity.owner_history = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => {
                    entity.object_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                5usize => {
                    entity.object_placement = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                6usize => {
                    entity.representation = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                7usize => {
                    entity.tag = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                8usize => {
                    entity.predefined_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
    pub fn from_own_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcCommunicationsAppliance::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => {
                    entity.predefined_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcCommunicationsApplianceType: IIfcFlowTerminalType {
    fn predefined_type(&self) -> &IfcCommunicationsApplianceTypeEnum;
}
#[derive(Default, Debug)]
pub struct IfcCommunicationsApplianceType {
    global_id: IfcGloballyUniqueId,
    owner_history: Option<EntityRef>,
    name: Option<IfcLabel>,
    description: Option<IfcText>,
    applicable_occurrence: Option<IfcIdentifier>,
    has_property_sets: Option<HashSet<EntityRef>>,
    representation_maps: Option<Vec<EntityRef>>,
    tag: Option<IfcLabel>,
    element_type: Option<IfcLabel>,
    predefined_type: IfcCommunicationsApplianceTypeEnum,
}
impl IIfcRoot for IfcCommunicationsApplianceType {
    fn global_id(&self) -> &IfcGloballyUniqueId {
        &self.global_id
    }
    fn owner_history(&self) -> &Option<EntityRef> {
        &self.owner_history
    }
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
}
impl IIfcObjectDefinition for IfcCommunicationsApplianceType {}
impl IIfcTypeObject for IfcCommunicationsApplianceType {
    fn applicable_occurrence(&self) -> &Option<IfcIdentifier> {
        &self.applicable_occurrence
    }
    fn has_property_sets(&self) -> &Option<HashSet<EntityRef>> {
        &self.has_property_sets
    }
}
impl IIfcTypeProduct for IfcCommunicationsApplianceType {
    fn representation_maps(&self) -> &Option<Vec<EntityRef>> {
        &self.representation_maps
    }
    fn tag(&self) -> &Option<IfcLabel> {
        &self.tag
    }
}
impl IIfcElementType for IfcCommunicationsApplianceType {
    fn element_type(&self) -> &Option<IfcLabel> {
        &self.element_type
    }
}
impl IIfcDistributionElementType for IfcCommunicationsApplianceType {}
impl IIfcDistributionFlowElementType for IfcCommunicationsApplianceType {}
impl IIfcFlowTerminalType for IfcCommunicationsApplianceType {}
impl IIfcCommunicationsApplianceType for IfcCommunicationsApplianceType {
    fn predefined_type(&self) -> &IfcCommunicationsApplianceTypeEnum {
        &self.predefined_type
    }
}
impl IfcCommunicationsApplianceType {
    pub fn from_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcCommunicationsApplianceType::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.global_id = parameter.into(),
                1usize => {
                    entity.owner_history = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => {
                    entity.applicable_occurrence = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                5usize => {
                    entity.has_property_sets = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                6usize => {
                    entity.representation_maps = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                7usize => {
                    entity.tag = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                8usize => {
                    entity.element_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                9usize => entity.predefined_type = parameter.into(),
                _ => {}
            }
        }
        entity
    }
    pub fn from_own_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcCommunicationsApplianceType::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.predefined_type = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcComplexProperty: IIfcProperty {
    fn usage_name(&self) -> &IfcIdentifier;
    fn has_properties(&self) -> &HashSet<EntityRef>;
}
#[derive(Default, Debug)]
pub struct IfcComplexProperty {
    name: IfcIdentifier,
    description: Option<IfcText>,
    usage_name: IfcIdentifier,
    has_properties: HashSet<EntityRef>,
}
impl IIfcPropertyAbstraction for IfcComplexProperty {}
impl IIfcProperty for IfcComplexProperty {
    fn name(&self) -> &IfcIdentifier {
        &self.name
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
}
impl IIfcComplexProperty for IfcComplexProperty {
    fn usage_name(&self) -> &IfcIdentifier {
        &self.usage_name
    }
    fn has_properties(&self) -> &HashSet<EntityRef> {
        &self.has_properties
    }
}
impl IfcComplexProperty {
    pub fn from_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcComplexProperty::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => entity.usage_name = parameter.into(),
                3usize => entity.has_properties = parameter.into(),
                _ => {}
            }
        }
        entity
    }
    pub fn from_own_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcComplexProperty::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.usage_name = parameter.into(),
                1usize => entity.has_properties = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcComplexPropertyTemplate: IIfcPropertyTemplate {
    fn usage_name(&self) -> &Option<IfcLabel>;
    fn template_type(&self) -> &Option<IfcComplexPropertyTemplateTypeEnum>;
    fn has_property_templates(&self) -> &Option<HashSet<EntityRef>>;
}
#[derive(Default, Debug)]
pub struct IfcComplexPropertyTemplate {
    global_id: IfcGloballyUniqueId,
    owner_history: Option<EntityRef>,
    name: Option<IfcLabel>,
    description: Option<IfcText>,
    usage_name: Option<IfcLabel>,
    template_type: Option<IfcComplexPropertyTemplateTypeEnum>,
    has_property_templates: Option<HashSet<EntityRef>>,
}
impl IIfcRoot for IfcComplexPropertyTemplate {
    fn global_id(&self) -> &IfcGloballyUniqueId {
        &self.global_id
    }
    fn owner_history(&self) -> &Option<EntityRef> {
        &self.owner_history
    }
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
}
impl IIfcPropertyDefinition for IfcComplexPropertyTemplate {}
impl IIfcPropertyTemplateDefinition for IfcComplexPropertyTemplate {}
impl IIfcPropertyTemplate for IfcComplexPropertyTemplate {}
impl IIfcComplexPropertyTemplate for IfcComplexPropertyTemplate {
    fn usage_name(&self) -> &Option<IfcLabel> {
        &self.usage_name
    }
    fn template_type(&self) -> &Option<IfcComplexPropertyTemplateTypeEnum> {
        &self.template_type
    }
    fn has_property_templates(&self) -> &Option<HashSet<EntityRef>> {
        &self.has_property_templates
    }
}
impl IfcComplexPropertyTemplate {
    pub fn from_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcComplexPropertyTemplate::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.global_id = parameter.into(),
                1usize => {
                    entity.owner_history = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => {
                    entity.usage_name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                5usize => {
                    entity.template_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                6usize => {
                    entity.has_property_templates = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
    pub fn from_own_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcComplexPropertyTemplate::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => {
                    entity.usage_name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                1usize => {
                    entity.template_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => {
                    entity.has_property_templates = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcCompositeCurve: IIfcBoundedCurve {
    fn segments(&self) -> &Vec<EntityRef>;
    fn self_intersect(&self) -> &IfcLogical;
}
#[derive(Default, Debug)]
pub struct IfcCompositeCurve {
    segments: Vec<EntityRef>,
    self_intersect: IfcLogical,
}
impl IIfcRepresentationItem for IfcCompositeCurve {}
impl IIfcGeometricRepresentationItem for IfcCompositeCurve {}
impl IIfcCurve for IfcCompositeCurve {}
impl IIfcBoundedCurve for IfcCompositeCurve {}
impl IIfcCompositeCurve for IfcCompositeCurve {
    fn segments(&self) -> &Vec<EntityRef> {
        &self.segments
    }
    fn self_intersect(&self) -> &IfcLogical {
        &self.self_intersect
    }
}
impl IfcCompositeCurve {
    pub fn from_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcCompositeCurve::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.segments = parameter.into(),
                1usize => entity.self_intersect = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcCompositeCurveOnSurface: IIfcCompositeCurve {}
#[derive(Default, Debug)]
pub struct IfcCompositeCurveOnSurface {
    segments: Vec<EntityRef>,
    self_intersect: IfcLogical,
}
impl IIfcRepresentationItem for IfcCompositeCurveOnSurface {}
impl IIfcGeometricRepresentationItem for IfcCompositeCurveOnSurface {}
impl IIfcCurve for IfcCompositeCurveOnSurface {}
impl IIfcBoundedCurve for IfcCompositeCurveOnSurface {}
impl IIfcCompositeCurve for IfcCompositeCurveOnSurface {
    fn segments(&self) -> &Vec<EntityRef> {
        &self.segments
    }
    fn self_intersect(&self) -> &IfcLogical {
        &self.self_intersect
    }
}
impl IIfcCompositeCurveOnSurface for IfcCompositeCurveOnSurface {}
impl IfcCompositeCurveOnSurface {
    pub fn from_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcCompositeCurveOnSurface::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.segments = parameter.into(),
                1usize => entity.self_intersect = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcCompositeCurveSegment: IIfcGeometricRepresentationItem {
    fn transition(&self) -> &IfcTransitionCode;
    fn same_sense(&self) -> &IfcBoolean;
    fn parent_curve(&self) -> &EntityRef;
}
#[derive(Default, Debug)]
pub struct IfcCompositeCurveSegment {
    transition: IfcTransitionCode,
    same_sense: IfcBoolean,
    parent_curve: EntityRef,
}
impl IIfcRepresentationItem for IfcCompositeCurveSegment {}
impl IIfcGeometricRepresentationItem for IfcCompositeCurveSegment {}
impl IIfcCompositeCurveSegment for IfcCompositeCurveSegment {
    fn transition(&self) -> &IfcTransitionCode {
        &self.transition
    }
    fn same_sense(&self) -> &IfcBoolean {
        &self.same_sense
    }
    fn parent_curve(&self) -> &EntityRef {
        &self.parent_curve
    }
}
impl IfcCompositeCurveSegment {
    pub fn from_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcCompositeCurveSegment::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.transition = parameter.into(),
                1usize => entity.same_sense = parameter.into(),
                2usize => entity.parent_curve = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcCompositeProfileDef: IIfcProfileDef {
    fn profiles(&self) -> &HashSet<EntityRef>;
    fn label(&self) -> &Option<IfcLabel>;
}
#[derive(Default, Debug)]
pub struct IfcCompositeProfileDef {
    profile_type: IfcProfileTypeEnum,
    profile_name: Option<IfcLabel>,
    profiles: HashSet<EntityRef>,
    label: Option<IfcLabel>,
}
impl IIfcProfileDef for IfcCompositeProfileDef {
    fn profile_type(&self) -> &IfcProfileTypeEnum {
        &self.profile_type
    }
    fn profile_name(&self) -> &Option<IfcLabel> {
        &self.profile_name
    }
}
impl IIfcCompositeProfileDef for IfcCompositeProfileDef {
    fn profiles(&self) -> &HashSet<EntityRef> {
        &self.profiles
    }
    fn label(&self) -> &Option<IfcLabel> {
        &self.label
    }
}
impl IfcCompositeProfileDef {
    pub fn from_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcCompositeProfileDef::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.profile_type = parameter.into(),
                1usize => {
                    entity.profile_name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => entity.profiles = parameter.into(),
                3usize => {
                    entity.label = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
    pub fn from_own_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcCompositeProfileDef::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.profiles = parameter.into(),
                1usize => {
                    entity.label = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcCompressor: IIfcFlowMovingDevice {
    fn predefined_type(&self) -> &Option<IfcCompressorTypeEnum>;
}
#[derive(Default, Debug)]
pub struct IfcCompressor {
    global_id: IfcGloballyUniqueId,
    owner_history: Option<EntityRef>,
    name: Option<IfcLabel>,
    description: Option<IfcText>,
    object_type: Option<IfcLabel>,
    object_placement: Option<EntityRef>,
    representation: Option<EntityRef>,
    tag: Option<IfcIdentifier>,
    predefined_type: Option<IfcCompressorTypeEnum>,
}
impl IIfcRoot for IfcCompressor {
    fn global_id(&self) -> &IfcGloballyUniqueId {
        &self.global_id
    }
    fn owner_history(&self) -> &Option<EntityRef> {
        &self.owner_history
    }
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
}
impl IIfcObjectDefinition for IfcCompressor {}
impl IIfcObject for IfcCompressor {
    fn object_type(&self) -> &Option<IfcLabel> {
        &self.object_type
    }
}
impl IIfcProduct for IfcCompressor {
    fn object_placement(&self) -> &Option<EntityRef> {
        &self.object_placement
    }
    fn representation(&self) -> &Option<EntityRef> {
        &self.representation
    }
}
impl IIfcElement for IfcCompressor {
    fn tag(&self) -> &Option<IfcIdentifier> {
        &self.tag
    }
}
impl IIfcDistributionElement for IfcCompressor {}
impl IIfcDistributionFlowElement for IfcCompressor {}
impl IIfcFlowMovingDevice for IfcCompressor {}
impl IIfcCompressor for IfcCompressor {
    fn predefined_type(&self) -> &Option<IfcCompressorTypeEnum> {
        &self.predefined_type
    }
}
impl IfcCompressor {
    pub fn from_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcCompressor::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.global_id = parameter.into(),
                1usize => {
                    entity.owner_history = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => {
                    entity.object_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                5usize => {
                    entity.object_placement = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                6usize => {
                    entity.representation = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                7usize => {
                    entity.tag = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                8usize => {
                    entity.predefined_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
    pub fn from_own_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcCompressor::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => {
                    entity.predefined_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcCompressorType: IIfcFlowMovingDeviceType {
    fn predefined_type(&self) -> &IfcCompressorTypeEnum;
}
#[derive(Default, Debug)]
pub struct IfcCompressorType {
    global_id: IfcGloballyUniqueId,
    owner_history: Option<EntityRef>,
    name: Option<IfcLabel>,
    description: Option<IfcText>,
    applicable_occurrence: Option<IfcIdentifier>,
    has_property_sets: Option<HashSet<EntityRef>>,
    representation_maps: Option<Vec<EntityRef>>,
    tag: Option<IfcLabel>,
    element_type: Option<IfcLabel>,
    predefined_type: IfcCompressorTypeEnum,
}
impl IIfcRoot for IfcCompressorType {
    fn global_id(&self) -> &IfcGloballyUniqueId {
        &self.global_id
    }
    fn owner_history(&self) -> &Option<EntityRef> {
        &self.owner_history
    }
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
}
impl IIfcObjectDefinition for IfcCompressorType {}
impl IIfcTypeObject for IfcCompressorType {
    fn applicable_occurrence(&self) -> &Option<IfcIdentifier> {
        &self.applicable_occurrence
    }
    fn has_property_sets(&self) -> &Option<HashSet<EntityRef>> {
        &self.has_property_sets
    }
}
impl IIfcTypeProduct for IfcCompressorType {
    fn representation_maps(&self) -> &Option<Vec<EntityRef>> {
        &self.representation_maps
    }
    fn tag(&self) -> &Option<IfcLabel> {
        &self.tag
    }
}
impl IIfcElementType for IfcCompressorType {
    fn element_type(&self) -> &Option<IfcLabel> {
        &self.element_type
    }
}
impl IIfcDistributionElementType for IfcCompressorType {}
impl IIfcDistributionFlowElementType for IfcCompressorType {}
impl IIfcFlowMovingDeviceType for IfcCompressorType {}
impl IIfcCompressorType for IfcCompressorType {
    fn predefined_type(&self) -> &IfcCompressorTypeEnum {
        &self.predefined_type
    }
}
impl IfcCompressorType {
    pub fn from_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcCompressorType::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.global_id = parameter.into(),
                1usize => {
                    entity.owner_history = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => {
                    entity.applicable_occurrence = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                5usize => {
                    entity.has_property_sets = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                6usize => {
                    entity.representation_maps = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                7usize => {
                    entity.tag = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                8usize => {
                    entity.element_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                9usize => entity.predefined_type = parameter.into(),
                _ => {}
            }
        }
        entity
    }
    pub fn from_own_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcCompressorType::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.predefined_type = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcCondenser: IIfcEnergyConversionDevice {
    fn predefined_type(&self) -> &Option<IfcCondenserTypeEnum>;
}
#[derive(Default, Debug)]
pub struct IfcCondenser {
    global_id: IfcGloballyUniqueId,
    owner_history: Option<EntityRef>,
    name: Option<IfcLabel>,
    description: Option<IfcText>,
    object_type: Option<IfcLabel>,
    object_placement: Option<EntityRef>,
    representation: Option<EntityRef>,
    tag: Option<IfcIdentifier>,
    predefined_type: Option<IfcCondenserTypeEnum>,
}
impl IIfcRoot for IfcCondenser {
    fn global_id(&self) -> &IfcGloballyUniqueId {
        &self.global_id
    }
    fn owner_history(&self) -> &Option<EntityRef> {
        &self.owner_history
    }
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
}
impl IIfcObjectDefinition for IfcCondenser {}
impl IIfcObject for IfcCondenser {
    fn object_type(&self) -> &Option<IfcLabel> {
        &self.object_type
    }
}
impl IIfcProduct for IfcCondenser {
    fn object_placement(&self) -> &Option<EntityRef> {
        &self.object_placement
    }
    fn representation(&self) -> &Option<EntityRef> {
        &self.representation
    }
}
impl IIfcElement for IfcCondenser {
    fn tag(&self) -> &Option<IfcIdentifier> {
        &self.tag
    }
}
impl IIfcDistributionElement for IfcCondenser {}
impl IIfcDistributionFlowElement for IfcCondenser {}
impl IIfcEnergyConversionDevice for IfcCondenser {}
impl IIfcCondenser for IfcCondenser {
    fn predefined_type(&self) -> &Option<IfcCondenserTypeEnum> {
        &self.predefined_type
    }
}
impl IfcCondenser {
    pub fn from_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcCondenser::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.global_id = parameter.into(),
                1usize => {
                    entity.owner_history = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => {
                    entity.object_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                5usize => {
                    entity.object_placement = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                6usize => {
                    entity.representation = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                7usize => {
                    entity.tag = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                8usize => {
                    entity.predefined_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
    pub fn from_own_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcCondenser::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => {
                    entity.predefined_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcCondenserType: IIfcEnergyConversionDeviceType {
    fn predefined_type(&self) -> &IfcCondenserTypeEnum;
}
#[derive(Default, Debug)]
pub struct IfcCondenserType {
    global_id: IfcGloballyUniqueId,
    owner_history: Option<EntityRef>,
    name: Option<IfcLabel>,
    description: Option<IfcText>,
    applicable_occurrence: Option<IfcIdentifier>,
    has_property_sets: Option<HashSet<EntityRef>>,
    representation_maps: Option<Vec<EntityRef>>,
    tag: Option<IfcLabel>,
    element_type: Option<IfcLabel>,
    predefined_type: IfcCondenserTypeEnum,
}
impl IIfcRoot for IfcCondenserType {
    fn global_id(&self) -> &IfcGloballyUniqueId {
        &self.global_id
    }
    fn owner_history(&self) -> &Option<EntityRef> {
        &self.owner_history
    }
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
}
impl IIfcObjectDefinition for IfcCondenserType {}
impl IIfcTypeObject for IfcCondenserType {
    fn applicable_occurrence(&self) -> &Option<IfcIdentifier> {
        &self.applicable_occurrence
    }
    fn has_property_sets(&self) -> &Option<HashSet<EntityRef>> {
        &self.has_property_sets
    }
}
impl IIfcTypeProduct for IfcCondenserType {
    fn representation_maps(&self) -> &Option<Vec<EntityRef>> {
        &self.representation_maps
    }
    fn tag(&self) -> &Option<IfcLabel> {
        &self.tag
    }
}
impl IIfcElementType for IfcCondenserType {
    fn element_type(&self) -> &Option<IfcLabel> {
        &self.element_type
    }
}
impl IIfcDistributionElementType for IfcCondenserType {}
impl IIfcDistributionFlowElementType for IfcCondenserType {}
impl IIfcEnergyConversionDeviceType for IfcCondenserType {}
impl IIfcCondenserType for IfcCondenserType {
    fn predefined_type(&self) -> &IfcCondenserTypeEnum {
        &self.predefined_type
    }
}
impl IfcCondenserType {
    pub fn from_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcCondenserType::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.global_id = parameter.into(),
                1usize => {
                    entity.owner_history = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => {
                    entity.applicable_occurrence = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                5usize => {
                    entity.has_property_sets = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                6usize => {
                    entity.representation_maps = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                7usize => {
                    entity.tag = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                8usize => {
                    entity.element_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                9usize => entity.predefined_type = parameter.into(),
                _ => {}
            }
        }
        entity
    }
    pub fn from_own_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcCondenserType::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.predefined_type = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcConic: IIfcCurve {
    fn position(&self) -> &EntityRef;
}
pub trait IIfcConnectedFaceSet: IIfcTopologicalRepresentationItem {
    fn cfs_faces(&self) -> &HashSet<EntityRef>;
}
#[derive(Default, Debug)]
pub struct IfcConnectedFaceSet {
    cfs_faces: HashSet<EntityRef>,
}
impl IIfcRepresentationItem for IfcConnectedFaceSet {}
impl IIfcTopologicalRepresentationItem for IfcConnectedFaceSet {}
impl IIfcConnectedFaceSet for IfcConnectedFaceSet {
    fn cfs_faces(&self) -> &HashSet<EntityRef> {
        &self.cfs_faces
    }
}
impl IfcConnectedFaceSet {
    pub fn from_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcConnectedFaceSet::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.cfs_faces = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcConnectionCurveGeometry: IIfcConnectionGeometry {
    fn curve_on_relating_element(&self) -> &EntityRef;
    fn curve_on_related_element(&self) -> &Option<EntityRef>;
}
#[derive(Default, Debug)]
pub struct IfcConnectionCurveGeometry {
    curve_on_relating_element: EntityRef,
    curve_on_related_element: Option<EntityRef>,
}
impl IIfcConnectionGeometry for IfcConnectionCurveGeometry {}
impl IIfcConnectionCurveGeometry for IfcConnectionCurveGeometry {
    fn curve_on_relating_element(&self) -> &EntityRef {
        &self.curve_on_relating_element
    }
    fn curve_on_related_element(&self) -> &Option<EntityRef> {
        &self.curve_on_related_element
    }
}
impl IfcConnectionCurveGeometry {
    pub fn from_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcConnectionCurveGeometry::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.curve_on_relating_element = parameter.into(),
                1usize => {
                    entity.curve_on_related_element = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcConnectionGeometry {}
pub trait IIfcConnectionPointEccentricity: IIfcConnectionPointGeometry {
    fn eccentricity_in_x(&self) -> &Option<IfcLengthMeasure>;
    fn eccentricity_in_y(&self) -> &Option<IfcLengthMeasure>;
    fn eccentricity_in_z(&self) -> &Option<IfcLengthMeasure>;
}
#[derive(Default, Debug)]
pub struct IfcConnectionPointEccentricity {
    point_on_relating_element: EntityRef,
    point_on_related_element: Option<EntityRef>,
    eccentricity_in_x: Option<IfcLengthMeasure>,
    eccentricity_in_y: Option<IfcLengthMeasure>,
    eccentricity_in_z: Option<IfcLengthMeasure>,
}
impl IIfcConnectionGeometry for IfcConnectionPointEccentricity {}
impl IIfcConnectionPointGeometry for IfcConnectionPointEccentricity {
    fn point_on_relating_element(&self) -> &EntityRef {
        &self.point_on_relating_element
    }
    fn point_on_related_element(&self) -> &Option<EntityRef> {
        &self.point_on_related_element
    }
}
impl IIfcConnectionPointEccentricity for IfcConnectionPointEccentricity {
    fn eccentricity_in_x(&self) -> &Option<IfcLengthMeasure> {
        &self.eccentricity_in_x
    }
    fn eccentricity_in_y(&self) -> &Option<IfcLengthMeasure> {
        &self.eccentricity_in_y
    }
    fn eccentricity_in_z(&self) -> &Option<IfcLengthMeasure> {
        &self.eccentricity_in_z
    }
}
impl IfcConnectionPointEccentricity {
    pub fn from_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcConnectionPointEccentricity::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.point_on_relating_element = parameter.into(),
                1usize => {
                    entity.point_on_related_element = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => {
                    entity.eccentricity_in_x = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.eccentricity_in_y = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => {
                    entity.eccentricity_in_z = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
    pub fn from_own_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcConnectionPointEccentricity::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => {
                    entity.eccentricity_in_x = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                1usize => {
                    entity.eccentricity_in_y = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => {
                    entity.eccentricity_in_z = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcConnectionPointGeometry: IIfcConnectionGeometry {
    fn point_on_relating_element(&self) -> &EntityRef;
    fn point_on_related_element(&self) -> &Option<EntityRef>;
}
#[derive(Default, Debug)]
pub struct IfcConnectionPointGeometry {
    point_on_relating_element: EntityRef,
    point_on_related_element: Option<EntityRef>,
}
impl IIfcConnectionGeometry for IfcConnectionPointGeometry {}
impl IIfcConnectionPointGeometry for IfcConnectionPointGeometry {
    fn point_on_relating_element(&self) -> &EntityRef {
        &self.point_on_relating_element
    }
    fn point_on_related_element(&self) -> &Option<EntityRef> {
        &self.point_on_related_element
    }
}
impl IfcConnectionPointGeometry {
    pub fn from_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcConnectionPointGeometry::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.point_on_relating_element = parameter.into(),
                1usize => {
                    entity.point_on_related_element = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcConnectionSurfaceGeometry: IIfcConnectionGeometry {
    fn surface_on_relating_element(&self) -> &EntityRef;
    fn surface_on_related_element(&self) -> &Option<EntityRef>;
}
#[derive(Default, Debug)]
pub struct IfcConnectionSurfaceGeometry {
    surface_on_relating_element: EntityRef,
    surface_on_related_element: Option<EntityRef>,
}
impl IIfcConnectionGeometry for IfcConnectionSurfaceGeometry {}
impl IIfcConnectionSurfaceGeometry for IfcConnectionSurfaceGeometry {
    fn surface_on_relating_element(&self) -> &EntityRef {
        &self.surface_on_relating_element
    }
    fn surface_on_related_element(&self) -> &Option<EntityRef> {
        &self.surface_on_related_element
    }
}
impl IfcConnectionSurfaceGeometry {
    pub fn from_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcConnectionSurfaceGeometry::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.surface_on_relating_element = parameter.into(),
                1usize => {
                    entity.surface_on_related_element = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcConnectionVolumeGeometry: IIfcConnectionGeometry {
    fn volume_on_relating_element(&self) -> &EntityRef;
    fn volume_on_related_element(&self) -> &Option<EntityRef>;
}
#[derive(Default, Debug)]
pub struct IfcConnectionVolumeGeometry {
    volume_on_relating_element: EntityRef,
    volume_on_related_element: Option<EntityRef>,
}
impl IIfcConnectionGeometry for IfcConnectionVolumeGeometry {}
impl IIfcConnectionVolumeGeometry for IfcConnectionVolumeGeometry {
    fn volume_on_relating_element(&self) -> &EntityRef {
        &self.volume_on_relating_element
    }
    fn volume_on_related_element(&self) -> &Option<EntityRef> {
        &self.volume_on_related_element
    }
}
impl IfcConnectionVolumeGeometry {
    pub fn from_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcConnectionVolumeGeometry::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.volume_on_relating_element = parameter.into(),
                1usize => {
                    entity.volume_on_related_element = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcConstraint {
    fn name(&self) -> &IfcLabel;
    fn description(&self) -> &Option<IfcText>;
    fn constraint_grade(&self) -> &IfcConstraintEnum;
    fn constraint_source(&self) -> &Option<IfcLabel>;
    fn creating_actor(&self) -> &Option<EntityRef>;
    fn creation_time(&self) -> &Option<IfcDateTime>;
    fn user_defined_grade(&self) -> &Option<IfcLabel>;
}
pub trait IIfcConstructionEquipmentResource: IIfcConstructionResource {
    fn predefined_type(&self) -> &Option<IfcConstructionEquipmentResourceTypeEnum>;
}
#[derive(Default, Debug)]
pub struct IfcConstructionEquipmentResource {
    global_id: IfcGloballyUniqueId,
    owner_history: Option<EntityRef>,
    name: Option<IfcLabel>,
    description: Option<IfcText>,
    object_type: Option<IfcLabel>,
    identification: Option<IfcIdentifier>,
    long_description: Option<IfcText>,
    usage: Option<EntityRef>,
    base_costs: Option<Vec<EntityRef>>,
    base_quantity: Option<EntityRef>,
    predefined_type: Option<IfcConstructionEquipmentResourceTypeEnum>,
}
impl IIfcRoot for IfcConstructionEquipmentResource {
    fn global_id(&self) -> &IfcGloballyUniqueId {
        &self.global_id
    }
    fn owner_history(&self) -> &Option<EntityRef> {
        &self.owner_history
    }
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
}
impl IIfcObjectDefinition for IfcConstructionEquipmentResource {}
impl IIfcObject for IfcConstructionEquipmentResource {
    fn object_type(&self) -> &Option<IfcLabel> {
        &self.object_type
    }
}
impl IIfcResource for IfcConstructionEquipmentResource {
    fn identification(&self) -> &Option<IfcIdentifier> {
        &self.identification
    }
    fn long_description(&self) -> &Option<IfcText> {
        &self.long_description
    }
}
impl IIfcConstructionResource for IfcConstructionEquipmentResource {
    fn usage(&self) -> &Option<EntityRef> {
        &self.usage
    }
    fn base_costs(&self) -> &Option<Vec<EntityRef>> {
        &self.base_costs
    }
    fn base_quantity(&self) -> &Option<EntityRef> {
        &self.base_quantity
    }
}
impl IIfcConstructionEquipmentResource for IfcConstructionEquipmentResource {
    fn predefined_type(&self) -> &Option<IfcConstructionEquipmentResourceTypeEnum> {
        &self.predefined_type
    }
}
impl IfcConstructionEquipmentResource {
    pub fn from_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcConstructionEquipmentResource::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.global_id = parameter.into(),
                1usize => {
                    entity.owner_history = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => {
                    entity.object_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                5usize => {
                    entity.identification = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                6usize => {
                    entity.long_description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                7usize => {
                    entity.usage = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                8usize => {
                    entity.base_costs = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                9usize => {
                    entity.base_quantity = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                10usize => {
                    entity.predefined_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
    pub fn from_own_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcConstructionEquipmentResource::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => {
                    entity.predefined_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcConstructionEquipmentResourceType: IIfcConstructionResourceType {
    fn predefined_type(&self) -> &IfcConstructionEquipmentResourceTypeEnum;
}
#[derive(Default, Debug)]
pub struct IfcConstructionEquipmentResourceType {
    global_id: IfcGloballyUniqueId,
    owner_history: Option<EntityRef>,
    name: Option<IfcLabel>,
    description: Option<IfcText>,
    applicable_occurrence: Option<IfcIdentifier>,
    has_property_sets: Option<HashSet<EntityRef>>,
    identification: Option<IfcIdentifier>,
    long_description: Option<IfcText>,
    resource_type: Option<IfcLabel>,
    base_costs: Option<Vec<EntityRef>>,
    base_quantity: Option<EntityRef>,
    predefined_type: IfcConstructionEquipmentResourceTypeEnum,
}
impl IIfcRoot for IfcConstructionEquipmentResourceType {
    fn global_id(&self) -> &IfcGloballyUniqueId {
        &self.global_id
    }
    fn owner_history(&self) -> &Option<EntityRef> {
        &self.owner_history
    }
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
}
impl IIfcObjectDefinition for IfcConstructionEquipmentResourceType {}
impl IIfcTypeObject for IfcConstructionEquipmentResourceType {
    fn applicable_occurrence(&self) -> &Option<IfcIdentifier> {
        &self.applicable_occurrence
    }
    fn has_property_sets(&self) -> &Option<HashSet<EntityRef>> {
        &self.has_property_sets
    }
}
impl IIfcTypeResource for IfcConstructionEquipmentResourceType {
    fn identification(&self) -> &Option<IfcIdentifier> {
        &self.identification
    }
    fn long_description(&self) -> &Option<IfcText> {
        &self.long_description
    }
    fn resource_type(&self) -> &Option<IfcLabel> {
        &self.resource_type
    }
}
impl IIfcConstructionResourceType for IfcConstructionEquipmentResourceType {
    fn base_costs(&self) -> &Option<Vec<EntityRef>> {
        &self.base_costs
    }
    fn base_quantity(&self) -> &Option<EntityRef> {
        &self.base_quantity
    }
}
impl IIfcConstructionEquipmentResourceType for IfcConstructionEquipmentResourceType {
    fn predefined_type(&self) -> &IfcConstructionEquipmentResourceTypeEnum {
        &self.predefined_type
    }
}
impl IfcConstructionEquipmentResourceType {
    pub fn from_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcConstructionEquipmentResourceType::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.global_id = parameter.into(),
                1usize => {
                    entity.owner_history = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => {
                    entity.applicable_occurrence = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                5usize => {
                    entity.has_property_sets = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                6usize => {
                    entity.identification = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                7usize => {
                    entity.long_description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                8usize => {
                    entity.resource_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                9usize => {
                    entity.base_costs = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                10usize => {
                    entity.base_quantity = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                11usize => entity.predefined_type = parameter.into(),
                _ => {}
            }
        }
        entity
    }
    pub fn from_own_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcConstructionEquipmentResourceType::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.predefined_type = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcConstructionMaterialResource: IIfcConstructionResource {
    fn predefined_type(&self) -> &Option<IfcConstructionMaterialResourceTypeEnum>;
}
#[derive(Default, Debug)]
pub struct IfcConstructionMaterialResource {
    global_id: IfcGloballyUniqueId,
    owner_history: Option<EntityRef>,
    name: Option<IfcLabel>,
    description: Option<IfcText>,
    object_type: Option<IfcLabel>,
    identification: Option<IfcIdentifier>,
    long_description: Option<IfcText>,
    usage: Option<EntityRef>,
    base_costs: Option<Vec<EntityRef>>,
    base_quantity: Option<EntityRef>,
    predefined_type: Option<IfcConstructionMaterialResourceTypeEnum>,
}
impl IIfcRoot for IfcConstructionMaterialResource {
    fn global_id(&self) -> &IfcGloballyUniqueId {
        &self.global_id
    }
    fn owner_history(&self) -> &Option<EntityRef> {
        &self.owner_history
    }
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
}
impl IIfcObjectDefinition for IfcConstructionMaterialResource {}
impl IIfcObject for IfcConstructionMaterialResource {
    fn object_type(&self) -> &Option<IfcLabel> {
        &self.object_type
    }
}
impl IIfcResource for IfcConstructionMaterialResource {
    fn identification(&self) -> &Option<IfcIdentifier> {
        &self.identification
    }
    fn long_description(&self) -> &Option<IfcText> {
        &self.long_description
    }
}
impl IIfcConstructionResource for IfcConstructionMaterialResource {
    fn usage(&self) -> &Option<EntityRef> {
        &self.usage
    }
    fn base_costs(&self) -> &Option<Vec<EntityRef>> {
        &self.base_costs
    }
    fn base_quantity(&self) -> &Option<EntityRef> {
        &self.base_quantity
    }
}
impl IIfcConstructionMaterialResource for IfcConstructionMaterialResource {
    fn predefined_type(&self) -> &Option<IfcConstructionMaterialResourceTypeEnum> {
        &self.predefined_type
    }
}
impl IfcConstructionMaterialResource {
    pub fn from_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcConstructionMaterialResource::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.global_id = parameter.into(),
                1usize => {
                    entity.owner_history = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => {
                    entity.object_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                5usize => {
                    entity.identification = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                6usize => {
                    entity.long_description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                7usize => {
                    entity.usage = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                8usize => {
                    entity.base_costs = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                9usize => {
                    entity.base_quantity = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                10usize => {
                    entity.predefined_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
    pub fn from_own_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcConstructionMaterialResource::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => {
                    entity.predefined_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcConstructionMaterialResourceType: IIfcConstructionResourceType {
    fn predefined_type(&self) -> &IfcConstructionMaterialResourceTypeEnum;
}
#[derive(Default, Debug)]
pub struct IfcConstructionMaterialResourceType {
    global_id: IfcGloballyUniqueId,
    owner_history: Option<EntityRef>,
    name: Option<IfcLabel>,
    description: Option<IfcText>,
    applicable_occurrence: Option<IfcIdentifier>,
    has_property_sets: Option<HashSet<EntityRef>>,
    identification: Option<IfcIdentifier>,
    long_description: Option<IfcText>,
    resource_type: Option<IfcLabel>,
    base_costs: Option<Vec<EntityRef>>,
    base_quantity: Option<EntityRef>,
    predefined_type: IfcConstructionMaterialResourceTypeEnum,
}
impl IIfcRoot for IfcConstructionMaterialResourceType {
    fn global_id(&self) -> &IfcGloballyUniqueId {
        &self.global_id
    }
    fn owner_history(&self) -> &Option<EntityRef> {
        &self.owner_history
    }
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
}
impl IIfcObjectDefinition for IfcConstructionMaterialResourceType {}
impl IIfcTypeObject for IfcConstructionMaterialResourceType {
    fn applicable_occurrence(&self) -> &Option<IfcIdentifier> {
        &self.applicable_occurrence
    }
    fn has_property_sets(&self) -> &Option<HashSet<EntityRef>> {
        &self.has_property_sets
    }
}
impl IIfcTypeResource for IfcConstructionMaterialResourceType {
    fn identification(&self) -> &Option<IfcIdentifier> {
        &self.identification
    }
    fn long_description(&self) -> &Option<IfcText> {
        &self.long_description
    }
    fn resource_type(&self) -> &Option<IfcLabel> {
        &self.resource_type
    }
}
impl IIfcConstructionResourceType for IfcConstructionMaterialResourceType {
    fn base_costs(&self) -> &Option<Vec<EntityRef>> {
        &self.base_costs
    }
    fn base_quantity(&self) -> &Option<EntityRef> {
        &self.base_quantity
    }
}
impl IIfcConstructionMaterialResourceType for IfcConstructionMaterialResourceType {
    fn predefined_type(&self) -> &IfcConstructionMaterialResourceTypeEnum {
        &self.predefined_type
    }
}
impl IfcConstructionMaterialResourceType {
    pub fn from_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcConstructionMaterialResourceType::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.global_id = parameter.into(),
                1usize => {
                    entity.owner_history = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => {
                    entity.applicable_occurrence = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                5usize => {
                    entity.has_property_sets = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                6usize => {
                    entity.identification = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                7usize => {
                    entity.long_description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                8usize => {
                    entity.resource_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                9usize => {
                    entity.base_costs = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                10usize => {
                    entity.base_quantity = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                11usize => entity.predefined_type = parameter.into(),
                _ => {}
            }
        }
        entity
    }
    pub fn from_own_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcConstructionMaterialResourceType::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.predefined_type = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcConstructionProductResource: IIfcConstructionResource {
    fn predefined_type(&self) -> &Option<IfcConstructionProductResourceTypeEnum>;
}
#[derive(Default, Debug)]
pub struct IfcConstructionProductResource {
    global_id: IfcGloballyUniqueId,
    owner_history: Option<EntityRef>,
    name: Option<IfcLabel>,
    description: Option<IfcText>,
    object_type: Option<IfcLabel>,
    identification: Option<IfcIdentifier>,
    long_description: Option<IfcText>,
    usage: Option<EntityRef>,
    base_costs: Option<Vec<EntityRef>>,
    base_quantity: Option<EntityRef>,
    predefined_type: Option<IfcConstructionProductResourceTypeEnum>,
}
impl IIfcRoot for IfcConstructionProductResource {
    fn global_id(&self) -> &IfcGloballyUniqueId {
        &self.global_id
    }
    fn owner_history(&self) -> &Option<EntityRef> {
        &self.owner_history
    }
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
}
impl IIfcObjectDefinition for IfcConstructionProductResource {}
impl IIfcObject for IfcConstructionProductResource {
    fn object_type(&self) -> &Option<IfcLabel> {
        &self.object_type
    }
}
impl IIfcResource for IfcConstructionProductResource {
    fn identification(&self) -> &Option<IfcIdentifier> {
        &self.identification
    }
    fn long_description(&self) -> &Option<IfcText> {
        &self.long_description
    }
}
impl IIfcConstructionResource for IfcConstructionProductResource {
    fn usage(&self) -> &Option<EntityRef> {
        &self.usage
    }
    fn base_costs(&self) -> &Option<Vec<EntityRef>> {
        &self.base_costs
    }
    fn base_quantity(&self) -> &Option<EntityRef> {
        &self.base_quantity
    }
}
impl IIfcConstructionProductResource for IfcConstructionProductResource {
    fn predefined_type(&self) -> &Option<IfcConstructionProductResourceTypeEnum> {
        &self.predefined_type
    }
}
impl IfcConstructionProductResource {
    pub fn from_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcConstructionProductResource::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.global_id = parameter.into(),
                1usize => {
                    entity.owner_history = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => {
                    entity.object_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                5usize => {
                    entity.identification = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                6usize => {
                    entity.long_description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                7usize => {
                    entity.usage = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                8usize => {
                    entity.base_costs = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                9usize => {
                    entity.base_quantity = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                10usize => {
                    entity.predefined_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
    pub fn from_own_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcConstructionProductResource::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => {
                    entity.predefined_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcConstructionProductResourceType: IIfcConstructionResourceType {
    fn predefined_type(&self) -> &IfcConstructionProductResourceTypeEnum;
}
#[derive(Default, Debug)]
pub struct IfcConstructionProductResourceType {
    global_id: IfcGloballyUniqueId,
    owner_history: Option<EntityRef>,
    name: Option<IfcLabel>,
    description: Option<IfcText>,
    applicable_occurrence: Option<IfcIdentifier>,
    has_property_sets: Option<HashSet<EntityRef>>,
    identification: Option<IfcIdentifier>,
    long_description: Option<IfcText>,
    resource_type: Option<IfcLabel>,
    base_costs: Option<Vec<EntityRef>>,
    base_quantity: Option<EntityRef>,
    predefined_type: IfcConstructionProductResourceTypeEnum,
}
impl IIfcRoot for IfcConstructionProductResourceType {
    fn global_id(&self) -> &IfcGloballyUniqueId {
        &self.global_id
    }
    fn owner_history(&self) -> &Option<EntityRef> {
        &self.owner_history
    }
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
}
impl IIfcObjectDefinition for IfcConstructionProductResourceType {}
impl IIfcTypeObject for IfcConstructionProductResourceType {
    fn applicable_occurrence(&self) -> &Option<IfcIdentifier> {
        &self.applicable_occurrence
    }
    fn has_property_sets(&self) -> &Option<HashSet<EntityRef>> {
        &self.has_property_sets
    }
}
impl IIfcTypeResource for IfcConstructionProductResourceType {
    fn identification(&self) -> &Option<IfcIdentifier> {
        &self.identification
    }
    fn long_description(&self) -> &Option<IfcText> {
        &self.long_description
    }
    fn resource_type(&self) -> &Option<IfcLabel> {
        &self.resource_type
    }
}
impl IIfcConstructionResourceType for IfcConstructionProductResourceType {
    fn base_costs(&self) -> &Option<Vec<EntityRef>> {
        &self.base_costs
    }
    fn base_quantity(&self) -> &Option<EntityRef> {
        &self.base_quantity
    }
}
impl IIfcConstructionProductResourceType for IfcConstructionProductResourceType {
    fn predefined_type(&self) -> &IfcConstructionProductResourceTypeEnum {
        &self.predefined_type
    }
}
impl IfcConstructionProductResourceType {
    pub fn from_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcConstructionProductResourceType::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.global_id = parameter.into(),
                1usize => {
                    entity.owner_history = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => {
                    entity.applicable_occurrence = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                5usize => {
                    entity.has_property_sets = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                6usize => {
                    entity.identification = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                7usize => {
                    entity.long_description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                8usize => {
                    entity.resource_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                9usize => {
                    entity.base_costs = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                10usize => {
                    entity.base_quantity = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                11usize => entity.predefined_type = parameter.into(),
                _ => {}
            }
        }
        entity
    }
    pub fn from_own_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcConstructionProductResourceType::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.predefined_type = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcConstructionResource: IIfcResource {
    fn usage(&self) -> &Option<EntityRef>;
    fn base_costs(&self) -> &Option<Vec<EntityRef>>;
    fn base_quantity(&self) -> &Option<EntityRef>;
}
pub trait IIfcConstructionResourceType: IIfcTypeResource {
    fn base_costs(&self) -> &Option<Vec<EntityRef>>;
    fn base_quantity(&self) -> &Option<EntityRef>;
}
pub trait IIfcContext: IIfcObjectDefinition {
    fn object_type(&self) -> &Option<IfcLabel>;
    fn long_name(&self) -> &Option<IfcLabel>;
    fn phase(&self) -> &Option<IfcLabel>;
    fn representation_contexts(&self) -> &Option<HashSet<EntityRef>>;
    fn units_in_context(&self) -> &Option<EntityRef>;
}
pub trait IIfcContextDependentUnit: IIfcNamedUnit {
    fn name(&self) -> &IfcLabel;
}
#[derive(Default, Debug)]
pub struct IfcContextDependentUnit {
    dimensions: EntityRef,
    unit_type: IfcUnitEnum,
    name: IfcLabel,
}
impl IIfcNamedUnit for IfcContextDependentUnit {
    fn dimensions(&self) -> &EntityRef {
        &self.dimensions
    }
    fn unit_type(&self) -> &IfcUnitEnum {
        &self.unit_type
    }
}
impl IIfcContextDependentUnit for IfcContextDependentUnit {
    fn name(&self) -> &IfcLabel {
        &self.name
    }
}
impl IfcContextDependentUnit {
    pub fn from_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcContextDependentUnit::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.dimensions = parameter.into(),
                1usize => entity.unit_type = parameter.into(),
                2usize => entity.name = parameter.into(),
                _ => {}
            }
        }
        entity
    }
    pub fn from_own_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcContextDependentUnit::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcControl: IIfcObject {
    fn identification(&self) -> &Option<IfcIdentifier>;
}
pub trait IIfcController: IIfcDistributionControlElement {
    fn predefined_type(&self) -> &Option<IfcControllerTypeEnum>;
}
#[derive(Default, Debug)]
pub struct IfcController {
    global_id: IfcGloballyUniqueId,
    owner_history: Option<EntityRef>,
    name: Option<IfcLabel>,
    description: Option<IfcText>,
    object_type: Option<IfcLabel>,
    object_placement: Option<EntityRef>,
    representation: Option<EntityRef>,
    tag: Option<IfcIdentifier>,
    predefined_type: Option<IfcControllerTypeEnum>,
}
impl IIfcRoot for IfcController {
    fn global_id(&self) -> &IfcGloballyUniqueId {
        &self.global_id
    }
    fn owner_history(&self) -> &Option<EntityRef> {
        &self.owner_history
    }
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
}
impl IIfcObjectDefinition for IfcController {}
impl IIfcObject for IfcController {
    fn object_type(&self) -> &Option<IfcLabel> {
        &self.object_type
    }
}
impl IIfcProduct for IfcController {
    fn object_placement(&self) -> &Option<EntityRef> {
        &self.object_placement
    }
    fn representation(&self) -> &Option<EntityRef> {
        &self.representation
    }
}
impl IIfcElement for IfcController {
    fn tag(&self) -> &Option<IfcIdentifier> {
        &self.tag
    }
}
impl IIfcDistributionElement for IfcController {}
impl IIfcDistributionControlElement for IfcController {}
impl IIfcController for IfcController {
    fn predefined_type(&self) -> &Option<IfcControllerTypeEnum> {
        &self.predefined_type
    }
}
impl IfcController {
    pub fn from_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcController::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.global_id = parameter.into(),
                1usize => {
                    entity.owner_history = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => {
                    entity.object_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                5usize => {
                    entity.object_placement = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                6usize => {
                    entity.representation = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                7usize => {
                    entity.tag = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                8usize => {
                    entity.predefined_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
    pub fn from_own_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcController::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => {
                    entity.predefined_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcControllerType: IIfcDistributionControlElementType {
    fn predefined_type(&self) -> &IfcControllerTypeEnum;
}
#[derive(Default, Debug)]
pub struct IfcControllerType {
    global_id: IfcGloballyUniqueId,
    owner_history: Option<EntityRef>,
    name: Option<IfcLabel>,
    description: Option<IfcText>,
    applicable_occurrence: Option<IfcIdentifier>,
    has_property_sets: Option<HashSet<EntityRef>>,
    representation_maps: Option<Vec<EntityRef>>,
    tag: Option<IfcLabel>,
    element_type: Option<IfcLabel>,
    predefined_type: IfcControllerTypeEnum,
}
impl IIfcRoot for IfcControllerType {
    fn global_id(&self) -> &IfcGloballyUniqueId {
        &self.global_id
    }
    fn owner_history(&self) -> &Option<EntityRef> {
        &self.owner_history
    }
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
}
impl IIfcObjectDefinition for IfcControllerType {}
impl IIfcTypeObject for IfcControllerType {
    fn applicable_occurrence(&self) -> &Option<IfcIdentifier> {
        &self.applicable_occurrence
    }
    fn has_property_sets(&self) -> &Option<HashSet<EntityRef>> {
        &self.has_property_sets
    }
}
impl IIfcTypeProduct for IfcControllerType {
    fn representation_maps(&self) -> &Option<Vec<EntityRef>> {
        &self.representation_maps
    }
    fn tag(&self) -> &Option<IfcLabel> {
        &self.tag
    }
}
impl IIfcElementType for IfcControllerType {
    fn element_type(&self) -> &Option<IfcLabel> {
        &self.element_type
    }
}
impl IIfcDistributionElementType for IfcControllerType {}
impl IIfcDistributionControlElementType for IfcControllerType {}
impl IIfcControllerType for IfcControllerType {
    fn predefined_type(&self) -> &IfcControllerTypeEnum {
        &self.predefined_type
    }
}
impl IfcControllerType {
    pub fn from_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcControllerType::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.global_id = parameter.into(),
                1usize => {
                    entity.owner_history = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => {
                    entity.applicable_occurrence = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                5usize => {
                    entity.has_property_sets = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                6usize => {
                    entity.representation_maps = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                7usize => {
                    entity.tag = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                8usize => {
                    entity.element_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                9usize => entity.predefined_type = parameter.into(),
                _ => {}
            }
        }
        entity
    }
    pub fn from_own_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcControllerType::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.predefined_type = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcConversionBasedUnit: IIfcNamedUnit {
    fn name(&self) -> &IfcLabel;
    fn conversion_factor(&self) -> &EntityRef;
}
#[derive(Default, Debug)]
pub struct IfcConversionBasedUnit {
    dimensions: EntityRef,
    unit_type: IfcUnitEnum,
    name: IfcLabel,
    conversion_factor: EntityRef,
}
impl IIfcNamedUnit for IfcConversionBasedUnit {
    fn dimensions(&self) -> &EntityRef {
        &self.dimensions
    }
    fn unit_type(&self) -> &IfcUnitEnum {
        &self.unit_type
    }
}
impl IIfcConversionBasedUnit for IfcConversionBasedUnit {
    fn name(&self) -> &IfcLabel {
        &self.name
    }
    fn conversion_factor(&self) -> &EntityRef {
        &self.conversion_factor
    }
}
impl IfcConversionBasedUnit {
    pub fn from_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcConversionBasedUnit::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.dimensions = parameter.into(),
                1usize => entity.unit_type = parameter.into(),
                2usize => entity.name = parameter.into(),
                3usize => entity.conversion_factor = parameter.into(),
                _ => {}
            }
        }
        entity
    }
    pub fn from_own_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcConversionBasedUnit::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => entity.conversion_factor = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcConversionBasedUnitWithOffset: IIfcConversionBasedUnit {
    fn conversion_offset(&self) -> &IfcReal;
}
#[derive(Default, Debug)]
pub struct IfcConversionBasedUnitWithOffset {
    dimensions: EntityRef,
    unit_type: IfcUnitEnum,
    name: IfcLabel,
    conversion_factor: EntityRef,
    conversion_offset: IfcReal,
}
impl IIfcNamedUnit for IfcConversionBasedUnitWithOffset {
    fn dimensions(&self) -> &EntityRef {
        &self.dimensions
    }
    fn unit_type(&self) -> &IfcUnitEnum {
        &self.unit_type
    }
}
impl IIfcConversionBasedUnit for IfcConversionBasedUnitWithOffset {
    fn name(&self) -> &IfcLabel {
        &self.name
    }
    fn conversion_factor(&self) -> &EntityRef {
        &self.conversion_factor
    }
}
impl IIfcConversionBasedUnitWithOffset for IfcConversionBasedUnitWithOffset {
    fn conversion_offset(&self) -> &IfcReal {
        &self.conversion_offset
    }
}
impl IfcConversionBasedUnitWithOffset {
    pub fn from_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcConversionBasedUnitWithOffset::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.dimensions = parameter.into(),
                1usize => entity.unit_type = parameter.into(),
                2usize => entity.name = parameter.into(),
                3usize => entity.conversion_factor = parameter.into(),
                4usize => entity.conversion_offset = parameter.into(),
                _ => {}
            }
        }
        entity
    }
    pub fn from_own_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcConversionBasedUnitWithOffset::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.conversion_offset = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcCooledBeam: IIfcEnergyConversionDevice {
    fn predefined_type(&self) -> &Option<IfcCooledBeamTypeEnum>;
}
#[derive(Default, Debug)]
pub struct IfcCooledBeam {
    global_id: IfcGloballyUniqueId,
    owner_history: Option<EntityRef>,
    name: Option<IfcLabel>,
    description: Option<IfcText>,
    object_type: Option<IfcLabel>,
    object_placement: Option<EntityRef>,
    representation: Option<EntityRef>,
    tag: Option<IfcIdentifier>,
    predefined_type: Option<IfcCooledBeamTypeEnum>,
}
impl IIfcRoot for IfcCooledBeam {
    fn global_id(&self) -> &IfcGloballyUniqueId {
        &self.global_id
    }
    fn owner_history(&self) -> &Option<EntityRef> {
        &self.owner_history
    }
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
}
impl IIfcObjectDefinition for IfcCooledBeam {}
impl IIfcObject for IfcCooledBeam {
    fn object_type(&self) -> &Option<IfcLabel> {
        &self.object_type
    }
}
impl IIfcProduct for IfcCooledBeam {
    fn object_placement(&self) -> &Option<EntityRef> {
        &self.object_placement
    }
    fn representation(&self) -> &Option<EntityRef> {
        &self.representation
    }
}
impl IIfcElement for IfcCooledBeam {
    fn tag(&self) -> &Option<IfcIdentifier> {
        &self.tag
    }
}
impl IIfcDistributionElement for IfcCooledBeam {}
impl IIfcDistributionFlowElement for IfcCooledBeam {}
impl IIfcEnergyConversionDevice for IfcCooledBeam {}
impl IIfcCooledBeam for IfcCooledBeam {
    fn predefined_type(&self) -> &Option<IfcCooledBeamTypeEnum> {
        &self.predefined_type
    }
}
impl IfcCooledBeam {
    pub fn from_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcCooledBeam::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.global_id = parameter.into(),
                1usize => {
                    entity.owner_history = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => {
                    entity.object_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                5usize => {
                    entity.object_placement = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                6usize => {
                    entity.representation = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                7usize => {
                    entity.tag = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                8usize => {
                    entity.predefined_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
    pub fn from_own_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcCooledBeam::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => {
                    entity.predefined_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcCooledBeamType: IIfcEnergyConversionDeviceType {
    fn predefined_type(&self) -> &IfcCooledBeamTypeEnum;
}
#[derive(Default, Debug)]
pub struct IfcCooledBeamType {
    global_id: IfcGloballyUniqueId,
    owner_history: Option<EntityRef>,
    name: Option<IfcLabel>,
    description: Option<IfcText>,
    applicable_occurrence: Option<IfcIdentifier>,
    has_property_sets: Option<HashSet<EntityRef>>,
    representation_maps: Option<Vec<EntityRef>>,
    tag: Option<IfcLabel>,
    element_type: Option<IfcLabel>,
    predefined_type: IfcCooledBeamTypeEnum,
}
impl IIfcRoot for IfcCooledBeamType {
    fn global_id(&self) -> &IfcGloballyUniqueId {
        &self.global_id
    }
    fn owner_history(&self) -> &Option<EntityRef> {
        &self.owner_history
    }
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
}
impl IIfcObjectDefinition for IfcCooledBeamType {}
impl IIfcTypeObject for IfcCooledBeamType {
    fn applicable_occurrence(&self) -> &Option<IfcIdentifier> {
        &self.applicable_occurrence
    }
    fn has_property_sets(&self) -> &Option<HashSet<EntityRef>> {
        &self.has_property_sets
    }
}
impl IIfcTypeProduct for IfcCooledBeamType {
    fn representation_maps(&self) -> &Option<Vec<EntityRef>> {
        &self.representation_maps
    }
    fn tag(&self) -> &Option<IfcLabel> {
        &self.tag
    }
}
impl IIfcElementType for IfcCooledBeamType {
    fn element_type(&self) -> &Option<IfcLabel> {
        &self.element_type
    }
}
impl IIfcDistributionElementType for IfcCooledBeamType {}
impl IIfcDistributionFlowElementType for IfcCooledBeamType {}
impl IIfcEnergyConversionDeviceType for IfcCooledBeamType {}
impl IIfcCooledBeamType for IfcCooledBeamType {
    fn predefined_type(&self) -> &IfcCooledBeamTypeEnum {
        &self.predefined_type
    }
}
impl IfcCooledBeamType {
    pub fn from_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcCooledBeamType::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.global_id = parameter.into(),
                1usize => {
                    entity.owner_history = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => {
                    entity.applicable_occurrence = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                5usize => {
                    entity.has_property_sets = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                6usize => {
                    entity.representation_maps = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                7usize => {
                    entity.tag = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                8usize => {
                    entity.element_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                9usize => entity.predefined_type = parameter.into(),
                _ => {}
            }
        }
        entity
    }
    pub fn from_own_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcCooledBeamType::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.predefined_type = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcCoolingTower: IIfcEnergyConversionDevice {
    fn predefined_type(&self) -> &Option<IfcCoolingTowerTypeEnum>;
}
#[derive(Default, Debug)]
pub struct IfcCoolingTower {
    global_id: IfcGloballyUniqueId,
    owner_history: Option<EntityRef>,
    name: Option<IfcLabel>,
    description: Option<IfcText>,
    object_type: Option<IfcLabel>,
    object_placement: Option<EntityRef>,
    representation: Option<EntityRef>,
    tag: Option<IfcIdentifier>,
    predefined_type: Option<IfcCoolingTowerTypeEnum>,
}
impl IIfcRoot for IfcCoolingTower {
    fn global_id(&self) -> &IfcGloballyUniqueId {
        &self.global_id
    }
    fn owner_history(&self) -> &Option<EntityRef> {
        &self.owner_history
    }
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
}
impl IIfcObjectDefinition for IfcCoolingTower {}
impl IIfcObject for IfcCoolingTower {
    fn object_type(&self) -> &Option<IfcLabel> {
        &self.object_type
    }
}
impl IIfcProduct for IfcCoolingTower {
    fn object_placement(&self) -> &Option<EntityRef> {
        &self.object_placement
    }
    fn representation(&self) -> &Option<EntityRef> {
        &self.representation
    }
}
impl IIfcElement for IfcCoolingTower {
    fn tag(&self) -> &Option<IfcIdentifier> {
        &self.tag
    }
}
impl IIfcDistributionElement for IfcCoolingTower {}
impl IIfcDistributionFlowElement for IfcCoolingTower {}
impl IIfcEnergyConversionDevice for IfcCoolingTower {}
impl IIfcCoolingTower for IfcCoolingTower {
    fn predefined_type(&self) -> &Option<IfcCoolingTowerTypeEnum> {
        &self.predefined_type
    }
}
impl IfcCoolingTower {
    pub fn from_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcCoolingTower::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.global_id = parameter.into(),
                1usize => {
                    entity.owner_history = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => {
                    entity.object_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                5usize => {
                    entity.object_placement = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                6usize => {
                    entity.representation = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                7usize => {
                    entity.tag = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                8usize => {
                    entity.predefined_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
    pub fn from_own_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcCoolingTower::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => {
                    entity.predefined_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcCoolingTowerType: IIfcEnergyConversionDeviceType {
    fn predefined_type(&self) -> &IfcCoolingTowerTypeEnum;
}
#[derive(Default, Debug)]
pub struct IfcCoolingTowerType {
    global_id: IfcGloballyUniqueId,
    owner_history: Option<EntityRef>,
    name: Option<IfcLabel>,
    description: Option<IfcText>,
    applicable_occurrence: Option<IfcIdentifier>,
    has_property_sets: Option<HashSet<EntityRef>>,
    representation_maps: Option<Vec<EntityRef>>,
    tag: Option<IfcLabel>,
    element_type: Option<IfcLabel>,
    predefined_type: IfcCoolingTowerTypeEnum,
}
impl IIfcRoot for IfcCoolingTowerType {
    fn global_id(&self) -> &IfcGloballyUniqueId {
        &self.global_id
    }
    fn owner_history(&self) -> &Option<EntityRef> {
        &self.owner_history
    }
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
}
impl IIfcObjectDefinition for IfcCoolingTowerType {}
impl IIfcTypeObject for IfcCoolingTowerType {
    fn applicable_occurrence(&self) -> &Option<IfcIdentifier> {
        &self.applicable_occurrence
    }
    fn has_property_sets(&self) -> &Option<HashSet<EntityRef>> {
        &self.has_property_sets
    }
}
impl IIfcTypeProduct for IfcCoolingTowerType {
    fn representation_maps(&self) -> &Option<Vec<EntityRef>> {
        &self.representation_maps
    }
    fn tag(&self) -> &Option<IfcLabel> {
        &self.tag
    }
}
impl IIfcElementType for IfcCoolingTowerType {
    fn element_type(&self) -> &Option<IfcLabel> {
        &self.element_type
    }
}
impl IIfcDistributionElementType for IfcCoolingTowerType {}
impl IIfcDistributionFlowElementType for IfcCoolingTowerType {}
impl IIfcEnergyConversionDeviceType for IfcCoolingTowerType {}
impl IIfcCoolingTowerType for IfcCoolingTowerType {
    fn predefined_type(&self) -> &IfcCoolingTowerTypeEnum {
        &self.predefined_type
    }
}
impl IfcCoolingTowerType {
    pub fn from_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcCoolingTowerType::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.global_id = parameter.into(),
                1usize => {
                    entity.owner_history = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => {
                    entity.applicable_occurrence = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                5usize => {
                    entity.has_property_sets = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                6usize => {
                    entity.representation_maps = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                7usize => {
                    entity.tag = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                8usize => {
                    entity.element_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                9usize => entity.predefined_type = parameter.into(),
                _ => {}
            }
        }
        entity
    }
    pub fn from_own_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcCoolingTowerType::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.predefined_type = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcCoordinateOperation {
    fn source_crs(&self) -> &EntityRef;
    fn target_crs(&self) -> &EntityRef;
}
pub trait IIfcCoordinateReferenceSystem {
    fn name(&self) -> &IfcLabel;
    fn description(&self) -> &Option<IfcText>;
    fn geodetic_datum(&self) -> &Option<IfcIdentifier>;
    fn vertical_datum(&self) -> &Option<IfcIdentifier>;
}
pub trait IIfcCostItem: IIfcControl {
    fn predefined_type(&self) -> &Option<IfcCostItemTypeEnum>;
    fn cost_values(&self) -> &Option<Vec<EntityRef>>;
    fn cost_quantities(&self) -> &Option<Vec<EntityRef>>;
}
#[derive(Default, Debug)]
pub struct IfcCostItem {
    global_id: IfcGloballyUniqueId,
    owner_history: Option<EntityRef>,
    name: Option<IfcLabel>,
    description: Option<IfcText>,
    object_type: Option<IfcLabel>,
    identification: Option<IfcIdentifier>,
    predefined_type: Option<IfcCostItemTypeEnum>,
    cost_values: Option<Vec<EntityRef>>,
    cost_quantities: Option<Vec<EntityRef>>,
}
impl IIfcRoot for IfcCostItem {
    fn global_id(&self) -> &IfcGloballyUniqueId {
        &self.global_id
    }
    fn owner_history(&self) -> &Option<EntityRef> {
        &self.owner_history
    }
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
}
impl IIfcObjectDefinition for IfcCostItem {}
impl IIfcObject for IfcCostItem {
    fn object_type(&self) -> &Option<IfcLabel> {
        &self.object_type
    }
}
impl IIfcControl for IfcCostItem {
    fn identification(&self) -> &Option<IfcIdentifier> {
        &self.identification
    }
}
impl IIfcCostItem for IfcCostItem {
    fn predefined_type(&self) -> &Option<IfcCostItemTypeEnum> {
        &self.predefined_type
    }
    fn cost_values(&self) -> &Option<Vec<EntityRef>> {
        &self.cost_values
    }
    fn cost_quantities(&self) -> &Option<Vec<EntityRef>> {
        &self.cost_quantities
    }
}
impl IfcCostItem {
    pub fn from_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcCostItem::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.global_id = parameter.into(),
                1usize => {
                    entity.owner_history = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => {
                    entity.object_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                5usize => {
                    entity.identification = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                6usize => {
                    entity.predefined_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                7usize => {
                    entity.cost_values = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                8usize => {
                    entity.cost_quantities = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
    pub fn from_own_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcCostItem::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => {
                    entity.predefined_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                1usize => {
                    entity.cost_values = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => {
                    entity.cost_quantities = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcCostSchedule: IIfcControl {
    fn predefined_type(&self) -> &Option<IfcCostScheduleTypeEnum>;
    fn status(&self) -> &Option<IfcLabel>;
    fn submitted_on(&self) -> &Option<IfcDateTime>;
    fn update_date(&self) -> &Option<IfcDateTime>;
}
#[derive(Default, Debug)]
pub struct IfcCostSchedule {
    global_id: IfcGloballyUniqueId,
    owner_history: Option<EntityRef>,
    name: Option<IfcLabel>,
    description: Option<IfcText>,
    object_type: Option<IfcLabel>,
    identification: Option<IfcIdentifier>,
    predefined_type: Option<IfcCostScheduleTypeEnum>,
    status: Option<IfcLabel>,
    submitted_on: Option<IfcDateTime>,
    update_date: Option<IfcDateTime>,
}
impl IIfcRoot for IfcCostSchedule {
    fn global_id(&self) -> &IfcGloballyUniqueId {
        &self.global_id
    }
    fn owner_history(&self) -> &Option<EntityRef> {
        &self.owner_history
    }
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
}
impl IIfcObjectDefinition for IfcCostSchedule {}
impl IIfcObject for IfcCostSchedule {
    fn object_type(&self) -> &Option<IfcLabel> {
        &self.object_type
    }
}
impl IIfcControl for IfcCostSchedule {
    fn identification(&self) -> &Option<IfcIdentifier> {
        &self.identification
    }
}
impl IIfcCostSchedule for IfcCostSchedule {
    fn predefined_type(&self) -> &Option<IfcCostScheduleTypeEnum> {
        &self.predefined_type
    }
    fn status(&self) -> &Option<IfcLabel> {
        &self.status
    }
    fn submitted_on(&self) -> &Option<IfcDateTime> {
        &self.submitted_on
    }
    fn update_date(&self) -> &Option<IfcDateTime> {
        &self.update_date
    }
}
impl IfcCostSchedule {
    pub fn from_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcCostSchedule::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.global_id = parameter.into(),
                1usize => {
                    entity.owner_history = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => {
                    entity.object_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                5usize => {
                    entity.identification = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                6usize => {
                    entity.predefined_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                7usize => {
                    entity.status = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                8usize => {
                    entity.submitted_on = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                9usize => {
                    entity.update_date = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
    pub fn from_own_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcCostSchedule::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => {
                    entity.predefined_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                1usize => {
                    entity.status = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => {
                    entity.submitted_on = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.update_date = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcCostValue: IIfcAppliedValue {}
#[derive(Default, Debug)]
pub struct IfcCostValue {
    name: Option<IfcLabel>,
    description: Option<IfcText>,
    applied_value: Option<IfcAppliedValueSelect>,
    unit_basis: Option<EntityRef>,
    applicable_date: Option<IfcDate>,
    fixed_until_date: Option<IfcDate>,
    category: Option<IfcLabel>,
    condition: Option<IfcLabel>,
    arithmetic_operator: Option<IfcArithmeticOperatorEnum>,
    components: Option<Vec<EntityRef>>,
}
impl IIfcAppliedValue for IfcCostValue {
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
    fn applied_value(&self) -> &Option<IfcAppliedValueSelect> {
        &self.applied_value
    }
    fn unit_basis(&self) -> &Option<EntityRef> {
        &self.unit_basis
    }
    fn applicable_date(&self) -> &Option<IfcDate> {
        &self.applicable_date
    }
    fn fixed_until_date(&self) -> &Option<IfcDate> {
        &self.fixed_until_date
    }
    fn category(&self) -> &Option<IfcLabel> {
        &self.category
    }
    fn condition(&self) -> &Option<IfcLabel> {
        &self.condition
    }
    fn arithmetic_operator(&self) -> &Option<IfcArithmeticOperatorEnum> {
        &self.arithmetic_operator
    }
    fn components(&self) -> &Option<Vec<EntityRef>> {
        &self.components
    }
}
impl IIfcCostValue for IfcCostValue {}
impl IfcCostValue {
    pub fn from_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcCostValue::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                1usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => {
                    entity.applied_value = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.unit_basis = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => {
                    entity.applicable_date = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                5usize => {
                    entity.fixed_until_date = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                6usize => {
                    entity.category = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                7usize => {
                    entity.condition = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                8usize => {
                    entity.arithmetic_operator = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                9usize => {
                    entity.components = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcCovering: IIfcBuildingElement {
    fn predefined_type(&self) -> &Option<IfcCoveringTypeEnum>;
}
#[derive(Default, Debug)]
pub struct IfcCovering {
    global_id: IfcGloballyUniqueId,
    owner_history: Option<EntityRef>,
    name: Option<IfcLabel>,
    description: Option<IfcText>,
    object_type: Option<IfcLabel>,
    object_placement: Option<EntityRef>,
    representation: Option<EntityRef>,
    tag: Option<IfcIdentifier>,
    predefined_type: Option<IfcCoveringTypeEnum>,
}
impl IIfcRoot for IfcCovering {
    fn global_id(&self) -> &IfcGloballyUniqueId {
        &self.global_id
    }
    fn owner_history(&self) -> &Option<EntityRef> {
        &self.owner_history
    }
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
}
impl IIfcObjectDefinition for IfcCovering {}
impl IIfcObject for IfcCovering {
    fn object_type(&self) -> &Option<IfcLabel> {
        &self.object_type
    }
}
impl IIfcProduct for IfcCovering {
    fn object_placement(&self) -> &Option<EntityRef> {
        &self.object_placement
    }
    fn representation(&self) -> &Option<EntityRef> {
        &self.representation
    }
}
impl IIfcElement for IfcCovering {
    fn tag(&self) -> &Option<IfcIdentifier> {
        &self.tag
    }
}
impl IIfcBuildingElement for IfcCovering {}
impl IIfcCovering for IfcCovering {
    fn predefined_type(&self) -> &Option<IfcCoveringTypeEnum> {
        &self.predefined_type
    }
}
impl IfcCovering {
    pub fn from_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcCovering::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.global_id = parameter.into(),
                1usize => {
                    entity.owner_history = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => {
                    entity.object_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                5usize => {
                    entity.object_placement = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                6usize => {
                    entity.representation = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                7usize => {
                    entity.tag = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                8usize => {
                    entity.predefined_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
    pub fn from_own_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcCovering::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => {
                    entity.predefined_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcCoveringType: IIfcBuildingElementType {
    fn predefined_type(&self) -> &IfcCoveringTypeEnum;
}
#[derive(Default, Debug)]
pub struct IfcCoveringType {
    global_id: IfcGloballyUniqueId,
    owner_history: Option<EntityRef>,
    name: Option<IfcLabel>,
    description: Option<IfcText>,
    applicable_occurrence: Option<IfcIdentifier>,
    has_property_sets: Option<HashSet<EntityRef>>,
    representation_maps: Option<Vec<EntityRef>>,
    tag: Option<IfcLabel>,
    element_type: Option<IfcLabel>,
    predefined_type: IfcCoveringTypeEnum,
}
impl IIfcRoot for IfcCoveringType {
    fn global_id(&self) -> &IfcGloballyUniqueId {
        &self.global_id
    }
    fn owner_history(&self) -> &Option<EntityRef> {
        &self.owner_history
    }
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
}
impl IIfcObjectDefinition for IfcCoveringType {}
impl IIfcTypeObject for IfcCoveringType {
    fn applicable_occurrence(&self) -> &Option<IfcIdentifier> {
        &self.applicable_occurrence
    }
    fn has_property_sets(&self) -> &Option<HashSet<EntityRef>> {
        &self.has_property_sets
    }
}
impl IIfcTypeProduct for IfcCoveringType {
    fn representation_maps(&self) -> &Option<Vec<EntityRef>> {
        &self.representation_maps
    }
    fn tag(&self) -> &Option<IfcLabel> {
        &self.tag
    }
}
impl IIfcElementType for IfcCoveringType {
    fn element_type(&self) -> &Option<IfcLabel> {
        &self.element_type
    }
}
impl IIfcBuildingElementType for IfcCoveringType {}
impl IIfcCoveringType for IfcCoveringType {
    fn predefined_type(&self) -> &IfcCoveringTypeEnum {
        &self.predefined_type
    }
}
impl IfcCoveringType {
    pub fn from_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcCoveringType::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.global_id = parameter.into(),
                1usize => {
                    entity.owner_history = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => {
                    entity.applicable_occurrence = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                5usize => {
                    entity.has_property_sets = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                6usize => {
                    entity.representation_maps = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                7usize => {
                    entity.tag = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                8usize => {
                    entity.element_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                9usize => entity.predefined_type = parameter.into(),
                _ => {}
            }
        }
        entity
    }
    pub fn from_own_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcCoveringType::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.predefined_type = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcCrewResource: IIfcConstructionResource {
    fn predefined_type(&self) -> &Option<IfcCrewResourceTypeEnum>;
}
#[derive(Default, Debug)]
pub struct IfcCrewResource {
    global_id: IfcGloballyUniqueId,
    owner_history: Option<EntityRef>,
    name: Option<IfcLabel>,
    description: Option<IfcText>,
    object_type: Option<IfcLabel>,
    identification: Option<IfcIdentifier>,
    long_description: Option<IfcText>,
    usage: Option<EntityRef>,
    base_costs: Option<Vec<EntityRef>>,
    base_quantity: Option<EntityRef>,
    predefined_type: Option<IfcCrewResourceTypeEnum>,
}
impl IIfcRoot for IfcCrewResource {
    fn global_id(&self) -> &IfcGloballyUniqueId {
        &self.global_id
    }
    fn owner_history(&self) -> &Option<EntityRef> {
        &self.owner_history
    }
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
}
impl IIfcObjectDefinition for IfcCrewResource {}
impl IIfcObject for IfcCrewResource {
    fn object_type(&self) -> &Option<IfcLabel> {
        &self.object_type
    }
}
impl IIfcResource for IfcCrewResource {
    fn identification(&self) -> &Option<IfcIdentifier> {
        &self.identification
    }
    fn long_description(&self) -> &Option<IfcText> {
        &self.long_description
    }
}
impl IIfcConstructionResource for IfcCrewResource {
    fn usage(&self) -> &Option<EntityRef> {
        &self.usage
    }
    fn base_costs(&self) -> &Option<Vec<EntityRef>> {
        &self.base_costs
    }
    fn base_quantity(&self) -> &Option<EntityRef> {
        &self.base_quantity
    }
}
impl IIfcCrewResource for IfcCrewResource {
    fn predefined_type(&self) -> &Option<IfcCrewResourceTypeEnum> {
        &self.predefined_type
    }
}
impl IfcCrewResource {
    pub fn from_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcCrewResource::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.global_id = parameter.into(),
                1usize => {
                    entity.owner_history = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => {
                    entity.object_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                5usize => {
                    entity.identification = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                6usize => {
                    entity.long_description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                7usize => {
                    entity.usage = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                8usize => {
                    entity.base_costs = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                9usize => {
                    entity.base_quantity = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                10usize => {
                    entity.predefined_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
    pub fn from_own_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcCrewResource::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => {
                    entity.predefined_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcCrewResourceType: IIfcConstructionResourceType {
    fn predefined_type(&self) -> &IfcCrewResourceTypeEnum;
}
#[derive(Default, Debug)]
pub struct IfcCrewResourceType {
    global_id: IfcGloballyUniqueId,
    owner_history: Option<EntityRef>,
    name: Option<IfcLabel>,
    description: Option<IfcText>,
    applicable_occurrence: Option<IfcIdentifier>,
    has_property_sets: Option<HashSet<EntityRef>>,
    identification: Option<IfcIdentifier>,
    long_description: Option<IfcText>,
    resource_type: Option<IfcLabel>,
    base_costs: Option<Vec<EntityRef>>,
    base_quantity: Option<EntityRef>,
    predefined_type: IfcCrewResourceTypeEnum,
}
impl IIfcRoot for IfcCrewResourceType {
    fn global_id(&self) -> &IfcGloballyUniqueId {
        &self.global_id
    }
    fn owner_history(&self) -> &Option<EntityRef> {
        &self.owner_history
    }
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
}
impl IIfcObjectDefinition for IfcCrewResourceType {}
impl IIfcTypeObject for IfcCrewResourceType {
    fn applicable_occurrence(&self) -> &Option<IfcIdentifier> {
        &self.applicable_occurrence
    }
    fn has_property_sets(&self) -> &Option<HashSet<EntityRef>> {
        &self.has_property_sets
    }
}
impl IIfcTypeResource for IfcCrewResourceType {
    fn identification(&self) -> &Option<IfcIdentifier> {
        &self.identification
    }
    fn long_description(&self) -> &Option<IfcText> {
        &self.long_description
    }
    fn resource_type(&self) -> &Option<IfcLabel> {
        &self.resource_type
    }
}
impl IIfcConstructionResourceType for IfcCrewResourceType {
    fn base_costs(&self) -> &Option<Vec<EntityRef>> {
        &self.base_costs
    }
    fn base_quantity(&self) -> &Option<EntityRef> {
        &self.base_quantity
    }
}
impl IIfcCrewResourceType for IfcCrewResourceType {
    fn predefined_type(&self) -> &IfcCrewResourceTypeEnum {
        &self.predefined_type
    }
}
impl IfcCrewResourceType {
    pub fn from_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcCrewResourceType::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.global_id = parameter.into(),
                1usize => {
                    entity.owner_history = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => {
                    entity.applicable_occurrence = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                5usize => {
                    entity.has_property_sets = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                6usize => {
                    entity.identification = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                7usize => {
                    entity.long_description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                8usize => {
                    entity.resource_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                9usize => {
                    entity.base_costs = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                10usize => {
                    entity.base_quantity = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                11usize => entity.predefined_type = parameter.into(),
                _ => {}
            }
        }
        entity
    }
    pub fn from_own_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcCrewResourceType::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.predefined_type = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcCsgPrimitive3D: IIfcGeometricRepresentationItem {
    fn position(&self) -> &EntityRef;
}
pub trait IIfcCsgSolid: IIfcSolidModel {
    fn tree_root_expression(&self) -> &EntityRef;
}
#[derive(Default, Debug)]
pub struct IfcCsgSolid {
    tree_root_expression: EntityRef,
}
impl IIfcRepresentationItem for IfcCsgSolid {}
impl IIfcGeometricRepresentationItem for IfcCsgSolid {}
impl IIfcSolidModel for IfcCsgSolid {}
impl IIfcCsgSolid for IfcCsgSolid {
    fn tree_root_expression(&self) -> &EntityRef {
        &self.tree_root_expression
    }
}
impl IfcCsgSolid {
    pub fn from_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcCsgSolid::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.tree_root_expression = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcCurrencyRelationship: IIfcResourceLevelRelationship {
    fn relating_monetary_unit(&self) -> &EntityRef;
    fn related_monetary_unit(&self) -> &EntityRef;
    fn exchange_rate(&self) -> &IfcPositiveRatioMeasure;
    fn rate_date_time(&self) -> &Option<IfcDateTime>;
    fn rate_source(&self) -> &Option<EntityRef>;
}
#[derive(Default, Debug)]
pub struct IfcCurrencyRelationship {
    name: Option<IfcLabel>,
    description: Option<IfcText>,
    relating_monetary_unit: EntityRef,
    related_monetary_unit: EntityRef,
    exchange_rate: IfcPositiveRatioMeasure,
    rate_date_time: Option<IfcDateTime>,
    rate_source: Option<EntityRef>,
}
impl IIfcResourceLevelRelationship for IfcCurrencyRelationship {
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
}
impl IIfcCurrencyRelationship for IfcCurrencyRelationship {
    fn relating_monetary_unit(&self) -> &EntityRef {
        &self.relating_monetary_unit
    }
    fn related_monetary_unit(&self) -> &EntityRef {
        &self.related_monetary_unit
    }
    fn exchange_rate(&self) -> &IfcPositiveRatioMeasure {
        &self.exchange_rate
    }
    fn rate_date_time(&self) -> &Option<IfcDateTime> {
        &self.rate_date_time
    }
    fn rate_source(&self) -> &Option<EntityRef> {
        &self.rate_source
    }
}
impl IfcCurrencyRelationship {
    pub fn from_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcCurrencyRelationship::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                1usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => entity.relating_monetary_unit = parameter.into(),
                3usize => entity.related_monetary_unit = parameter.into(),
                4usize => entity.exchange_rate = parameter.into(),
                5usize => {
                    entity.rate_date_time = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                6usize => {
                    entity.rate_source = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
    pub fn from_own_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcCurrencyRelationship::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.relating_monetary_unit = parameter.into(),
                1usize => entity.related_monetary_unit = parameter.into(),
                2usize => entity.exchange_rate = parameter.into(),
                3usize => {
                    entity.rate_date_time = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => {
                    entity.rate_source = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcCurtainWall: IIfcBuildingElement {
    fn predefined_type(&self) -> &Option<IfcCurtainWallTypeEnum>;
}
#[derive(Default, Debug)]
pub struct IfcCurtainWall {
    global_id: IfcGloballyUniqueId,
    owner_history: Option<EntityRef>,
    name: Option<IfcLabel>,
    description: Option<IfcText>,
    object_type: Option<IfcLabel>,
    object_placement: Option<EntityRef>,
    representation: Option<EntityRef>,
    tag: Option<IfcIdentifier>,
    predefined_type: Option<IfcCurtainWallTypeEnum>,
}
impl IIfcRoot for IfcCurtainWall {
    fn global_id(&self) -> &IfcGloballyUniqueId {
        &self.global_id
    }
    fn owner_history(&self) -> &Option<EntityRef> {
        &self.owner_history
    }
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
}
impl IIfcObjectDefinition for IfcCurtainWall {}
impl IIfcObject for IfcCurtainWall {
    fn object_type(&self) -> &Option<IfcLabel> {
        &self.object_type
    }
}
impl IIfcProduct for IfcCurtainWall {
    fn object_placement(&self) -> &Option<EntityRef> {
        &self.object_placement
    }
    fn representation(&self) -> &Option<EntityRef> {
        &self.representation
    }
}
impl IIfcElement for IfcCurtainWall {
    fn tag(&self) -> &Option<IfcIdentifier> {
        &self.tag
    }
}
impl IIfcBuildingElement for IfcCurtainWall {}
impl IIfcCurtainWall for IfcCurtainWall {
    fn predefined_type(&self) -> &Option<IfcCurtainWallTypeEnum> {
        &self.predefined_type
    }
}
impl IfcCurtainWall {
    pub fn from_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcCurtainWall::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.global_id = parameter.into(),
                1usize => {
                    entity.owner_history = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => {
                    entity.object_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                5usize => {
                    entity.object_placement = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                6usize => {
                    entity.representation = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                7usize => {
                    entity.tag = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                8usize => {
                    entity.predefined_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
    pub fn from_own_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcCurtainWall::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => {
                    entity.predefined_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcCurtainWallType: IIfcBuildingElementType {
    fn predefined_type(&self) -> &IfcCurtainWallTypeEnum;
}
#[derive(Default, Debug)]
pub struct IfcCurtainWallType {
    global_id: IfcGloballyUniqueId,
    owner_history: Option<EntityRef>,
    name: Option<IfcLabel>,
    description: Option<IfcText>,
    applicable_occurrence: Option<IfcIdentifier>,
    has_property_sets: Option<HashSet<EntityRef>>,
    representation_maps: Option<Vec<EntityRef>>,
    tag: Option<IfcLabel>,
    element_type: Option<IfcLabel>,
    predefined_type: IfcCurtainWallTypeEnum,
}
impl IIfcRoot for IfcCurtainWallType {
    fn global_id(&self) -> &IfcGloballyUniqueId {
        &self.global_id
    }
    fn owner_history(&self) -> &Option<EntityRef> {
        &self.owner_history
    }
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
}
impl IIfcObjectDefinition for IfcCurtainWallType {}
impl IIfcTypeObject for IfcCurtainWallType {
    fn applicable_occurrence(&self) -> &Option<IfcIdentifier> {
        &self.applicable_occurrence
    }
    fn has_property_sets(&self) -> &Option<HashSet<EntityRef>> {
        &self.has_property_sets
    }
}
impl IIfcTypeProduct for IfcCurtainWallType {
    fn representation_maps(&self) -> &Option<Vec<EntityRef>> {
        &self.representation_maps
    }
    fn tag(&self) -> &Option<IfcLabel> {
        &self.tag
    }
}
impl IIfcElementType for IfcCurtainWallType {
    fn element_type(&self) -> &Option<IfcLabel> {
        &self.element_type
    }
}
impl IIfcBuildingElementType for IfcCurtainWallType {}
impl IIfcCurtainWallType for IfcCurtainWallType {
    fn predefined_type(&self) -> &IfcCurtainWallTypeEnum {
        &self.predefined_type
    }
}
impl IfcCurtainWallType {
    pub fn from_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcCurtainWallType::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.global_id = parameter.into(),
                1usize => {
                    entity.owner_history = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => {
                    entity.applicable_occurrence = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                5usize => {
                    entity.has_property_sets = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                6usize => {
                    entity.representation_maps = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                7usize => {
                    entity.tag = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                8usize => {
                    entity.element_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                9usize => entity.predefined_type = parameter.into(),
                _ => {}
            }
        }
        entity
    }
    pub fn from_own_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcCurtainWallType::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.predefined_type = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcCurve: IIfcGeometricRepresentationItem {}
pub trait IIfcCurveBoundedPlane: IIfcBoundedSurface {
    fn basis_surface(&self) -> &EntityRef;
    fn outer_boundary(&self) -> &EntityRef;
    fn inner_boundaries(&self) -> &HashSet<EntityRef>;
}
#[derive(Default, Debug)]
pub struct IfcCurveBoundedPlane {
    basis_surface: EntityRef,
    outer_boundary: EntityRef,
    inner_boundaries: HashSet<EntityRef>,
}
impl IIfcRepresentationItem for IfcCurveBoundedPlane {}
impl IIfcGeometricRepresentationItem for IfcCurveBoundedPlane {}
impl IIfcSurface for IfcCurveBoundedPlane {}
impl IIfcBoundedSurface for IfcCurveBoundedPlane {}
impl IIfcCurveBoundedPlane for IfcCurveBoundedPlane {
    fn basis_surface(&self) -> &EntityRef {
        &self.basis_surface
    }
    fn outer_boundary(&self) -> &EntityRef {
        &self.outer_boundary
    }
    fn inner_boundaries(&self) -> &HashSet<EntityRef> {
        &self.inner_boundaries
    }
}
impl IfcCurveBoundedPlane {
    pub fn from_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcCurveBoundedPlane::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.basis_surface = parameter.into(),
                1usize => entity.outer_boundary = parameter.into(),
                2usize => entity.inner_boundaries = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcCurveBoundedSurface: IIfcBoundedSurface {
    fn basis_surface(&self) -> &EntityRef;
    fn boundaries(&self) -> &HashSet<EntityRef>;
    fn implicit_outer(&self) -> &IfcBoolean;
}
#[derive(Default, Debug)]
pub struct IfcCurveBoundedSurface {
    basis_surface: EntityRef,
    boundaries: HashSet<EntityRef>,
    implicit_outer: IfcBoolean,
}
impl IIfcRepresentationItem for IfcCurveBoundedSurface {}
impl IIfcGeometricRepresentationItem for IfcCurveBoundedSurface {}
impl IIfcSurface for IfcCurveBoundedSurface {}
impl IIfcBoundedSurface for IfcCurveBoundedSurface {}
impl IIfcCurveBoundedSurface for IfcCurveBoundedSurface {
    fn basis_surface(&self) -> &EntityRef {
        &self.basis_surface
    }
    fn boundaries(&self) -> &HashSet<EntityRef> {
        &self.boundaries
    }
    fn implicit_outer(&self) -> &IfcBoolean {
        &self.implicit_outer
    }
}
impl IfcCurveBoundedSurface {
    pub fn from_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcCurveBoundedSurface::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.basis_surface = parameter.into(),
                1usize => entity.boundaries = parameter.into(),
                2usize => entity.implicit_outer = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcCurveStyle: IIfcPresentationStyle {
    fn curve_font(&self) -> &Option<EntityRef>;
    fn curve_width(&self) -> &Option<IfcSizeSelect>;
    fn curve_colour(&self) -> &Option<EntityRef>;
    fn model_or_draughting(&self) -> &Option<IfcBoolean>;
}
#[derive(Default, Debug)]
pub struct IfcCurveStyle {
    name: Option<IfcLabel>,
    curve_font: Option<EntityRef>,
    curve_width: Option<IfcSizeSelect>,
    curve_colour: Option<EntityRef>,
    model_or_draughting: Option<IfcBoolean>,
}
impl IIfcPresentationStyle for IfcCurveStyle {
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
}
impl IIfcCurveStyle for IfcCurveStyle {
    fn curve_font(&self) -> &Option<EntityRef> {
        &self.curve_font
    }
    fn curve_width(&self) -> &Option<IfcSizeSelect> {
        &self.curve_width
    }
    fn curve_colour(&self) -> &Option<EntityRef> {
        &self.curve_colour
    }
    fn model_or_draughting(&self) -> &Option<IfcBoolean> {
        &self.model_or_draughting
    }
}
impl IfcCurveStyle {
    pub fn from_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcCurveStyle::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                1usize => {
                    entity.curve_font = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => {
                    entity.curve_width = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.curve_colour = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => {
                    entity.model_or_draughting = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
    pub fn from_own_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcCurveStyle::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => {
                    entity.curve_font = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                1usize => {
                    entity.curve_width = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => {
                    entity.curve_colour = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.model_or_draughting = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcCurveStyleFont: IIfcPresentationItem {
    fn name(&self) -> &Option<IfcLabel>;
    fn pattern_list(&self) -> &Vec<EntityRef>;
}
#[derive(Default, Debug)]
pub struct IfcCurveStyleFont {
    name: Option<IfcLabel>,
    pattern_list: Vec<EntityRef>,
}
impl IIfcPresentationItem for IfcCurveStyleFont {}
impl IIfcCurveStyleFont for IfcCurveStyleFont {
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
    fn pattern_list(&self) -> &Vec<EntityRef> {
        &self.pattern_list
    }
}
impl IfcCurveStyleFont {
    pub fn from_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcCurveStyleFont::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                1usize => entity.pattern_list = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcCurveStyleFontAndScaling: IIfcPresentationItem {
    fn name(&self) -> &Option<IfcLabel>;
    fn curve_font(&self) -> &EntityRef;
    fn curve_font_scaling(&self) -> &IfcPositiveRatioMeasure;
}
#[derive(Default, Debug)]
pub struct IfcCurveStyleFontAndScaling {
    name: Option<IfcLabel>,
    curve_font: EntityRef,
    curve_font_scaling: IfcPositiveRatioMeasure,
}
impl IIfcPresentationItem for IfcCurveStyleFontAndScaling {}
impl IIfcCurveStyleFontAndScaling for IfcCurveStyleFontAndScaling {
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
    fn curve_font(&self) -> &EntityRef {
        &self.curve_font
    }
    fn curve_font_scaling(&self) -> &IfcPositiveRatioMeasure {
        &self.curve_font_scaling
    }
}
impl IfcCurveStyleFontAndScaling {
    pub fn from_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcCurveStyleFontAndScaling::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                1usize => entity.curve_font = parameter.into(),
                2usize => entity.curve_font_scaling = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcCurveStyleFontPattern: IIfcPresentationItem {
    fn visible_segment_length(&self) -> &IfcLengthMeasure;
    fn invisible_segment_length(&self) -> &IfcPositiveLengthMeasure;
}
#[derive(Default, Debug)]
pub struct IfcCurveStyleFontPattern {
    visible_segment_length: IfcLengthMeasure,
    invisible_segment_length: IfcPositiveLengthMeasure,
}
impl IIfcPresentationItem for IfcCurveStyleFontPattern {}
impl IIfcCurveStyleFontPattern for IfcCurveStyleFontPattern {
    fn visible_segment_length(&self) -> &IfcLengthMeasure {
        &self.visible_segment_length
    }
    fn invisible_segment_length(&self) -> &IfcPositiveLengthMeasure {
        &self.invisible_segment_length
    }
}
impl IfcCurveStyleFontPattern {
    pub fn from_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcCurveStyleFontPattern::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.visible_segment_length = parameter.into(),
                1usize => entity.invisible_segment_length = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcCylindricalSurface: IIfcElementarySurface {
    fn radius(&self) -> &IfcPositiveLengthMeasure;
}
#[derive(Default, Debug)]
pub struct IfcCylindricalSurface {
    position: EntityRef,
    radius: IfcPositiveLengthMeasure,
}
impl IIfcRepresentationItem for IfcCylindricalSurface {}
impl IIfcGeometricRepresentationItem for IfcCylindricalSurface {}
impl IIfcSurface for IfcCylindricalSurface {}
impl IIfcElementarySurface for IfcCylindricalSurface {
    fn position(&self) -> &EntityRef {
        &self.position
    }
}
impl IIfcCylindricalSurface for IfcCylindricalSurface {
    fn radius(&self) -> &IfcPositiveLengthMeasure {
        &self.radius
    }
}
impl IfcCylindricalSurface {
    pub fn from_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcCylindricalSurface::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.position = parameter.into(),
                1usize => entity.radius = parameter.into(),
                _ => {}
            }
        }
        entity
    }
    pub fn from_own_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcCylindricalSurface::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.radius = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcDamper: IIfcFlowController {
    fn predefined_type(&self) -> &Option<IfcDamperTypeEnum>;
}
#[derive(Default, Debug)]
pub struct IfcDamper {
    global_id: IfcGloballyUniqueId,
    owner_history: Option<EntityRef>,
    name: Option<IfcLabel>,
    description: Option<IfcText>,
    object_type: Option<IfcLabel>,
    object_placement: Option<EntityRef>,
    representation: Option<EntityRef>,
    tag: Option<IfcIdentifier>,
    predefined_type: Option<IfcDamperTypeEnum>,
}
impl IIfcRoot for IfcDamper {
    fn global_id(&self) -> &IfcGloballyUniqueId {
        &self.global_id
    }
    fn owner_history(&self) -> &Option<EntityRef> {
        &self.owner_history
    }
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
}
impl IIfcObjectDefinition for IfcDamper {}
impl IIfcObject for IfcDamper {
    fn object_type(&self) -> &Option<IfcLabel> {
        &self.object_type
    }
}
impl IIfcProduct for IfcDamper {
    fn object_placement(&self) -> &Option<EntityRef> {
        &self.object_placement
    }
    fn representation(&self) -> &Option<EntityRef> {
        &self.representation
    }
}
impl IIfcElement for IfcDamper {
    fn tag(&self) -> &Option<IfcIdentifier> {
        &self.tag
    }
}
impl IIfcDistributionElement for IfcDamper {}
impl IIfcDistributionFlowElement for IfcDamper {}
impl IIfcFlowController for IfcDamper {}
impl IIfcDamper for IfcDamper {
    fn predefined_type(&self) -> &Option<IfcDamperTypeEnum> {
        &self.predefined_type
    }
}
impl IfcDamper {
    pub fn from_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcDamper::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.global_id = parameter.into(),
                1usize => {
                    entity.owner_history = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => {
                    entity.object_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                5usize => {
                    entity.object_placement = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                6usize => {
                    entity.representation = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                7usize => {
                    entity.tag = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                8usize => {
                    entity.predefined_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
    pub fn from_own_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcDamper::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => {
                    entity.predefined_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcDamperType: IIfcFlowControllerType {
    fn predefined_type(&self) -> &IfcDamperTypeEnum;
}
#[derive(Default, Debug)]
pub struct IfcDamperType {
    global_id: IfcGloballyUniqueId,
    owner_history: Option<EntityRef>,
    name: Option<IfcLabel>,
    description: Option<IfcText>,
    applicable_occurrence: Option<IfcIdentifier>,
    has_property_sets: Option<HashSet<EntityRef>>,
    representation_maps: Option<Vec<EntityRef>>,
    tag: Option<IfcLabel>,
    element_type: Option<IfcLabel>,
    predefined_type: IfcDamperTypeEnum,
}
impl IIfcRoot for IfcDamperType {
    fn global_id(&self) -> &IfcGloballyUniqueId {
        &self.global_id
    }
    fn owner_history(&self) -> &Option<EntityRef> {
        &self.owner_history
    }
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
}
impl IIfcObjectDefinition for IfcDamperType {}
impl IIfcTypeObject for IfcDamperType {
    fn applicable_occurrence(&self) -> &Option<IfcIdentifier> {
        &self.applicable_occurrence
    }
    fn has_property_sets(&self) -> &Option<HashSet<EntityRef>> {
        &self.has_property_sets
    }
}
impl IIfcTypeProduct for IfcDamperType {
    fn representation_maps(&self) -> &Option<Vec<EntityRef>> {
        &self.representation_maps
    }
    fn tag(&self) -> &Option<IfcLabel> {
        &self.tag
    }
}
impl IIfcElementType for IfcDamperType {
    fn element_type(&self) -> &Option<IfcLabel> {
        &self.element_type
    }
}
impl IIfcDistributionElementType for IfcDamperType {}
impl IIfcDistributionFlowElementType for IfcDamperType {}
impl IIfcFlowControllerType for IfcDamperType {}
impl IIfcDamperType for IfcDamperType {
    fn predefined_type(&self) -> &IfcDamperTypeEnum {
        &self.predefined_type
    }
}
impl IfcDamperType {
    pub fn from_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcDamperType::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.global_id = parameter.into(),
                1usize => {
                    entity.owner_history = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => {
                    entity.applicable_occurrence = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                5usize => {
                    entity.has_property_sets = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                6usize => {
                    entity.representation_maps = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                7usize => {
                    entity.tag = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                8usize => {
                    entity.element_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                9usize => entity.predefined_type = parameter.into(),
                _ => {}
            }
        }
        entity
    }
    pub fn from_own_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcDamperType::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.predefined_type = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcDerivedProfileDef: IIfcProfileDef {
    fn parent_profile(&self) -> &EntityRef;
    fn operator(&self) -> &EntityRef;
    fn label(&self) -> &Option<IfcLabel>;
}
#[derive(Default, Debug)]
pub struct IfcDerivedProfileDef {
    profile_type: IfcProfileTypeEnum,
    profile_name: Option<IfcLabel>,
    parent_profile: EntityRef,
    operator: EntityRef,
    label: Option<IfcLabel>,
}
impl IIfcProfileDef for IfcDerivedProfileDef {
    fn profile_type(&self) -> &IfcProfileTypeEnum {
        &self.profile_type
    }
    fn profile_name(&self) -> &Option<IfcLabel> {
        &self.profile_name
    }
}
impl IIfcDerivedProfileDef for IfcDerivedProfileDef {
    fn parent_profile(&self) -> &EntityRef {
        &self.parent_profile
    }
    fn operator(&self) -> &EntityRef {
        &self.operator
    }
    fn label(&self) -> &Option<IfcLabel> {
        &self.label
    }
}
impl IfcDerivedProfileDef {
    pub fn from_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcDerivedProfileDef::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.profile_type = parameter.into(),
                1usize => {
                    entity.profile_name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => entity.parent_profile = parameter.into(),
                3usize => entity.operator = parameter.into(),
                4usize => {
                    entity.label = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
    pub fn from_own_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcDerivedProfileDef::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.parent_profile = parameter.into(),
                1usize => entity.operator = parameter.into(),
                2usize => {
                    entity.label = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcDerivedUnit {
    fn elements(&self) -> &HashSet<EntityRef>;
    fn unit_type(&self) -> &IfcDerivedUnitEnum;
    fn user_defined_type(&self) -> &Option<IfcLabel>;
}
#[derive(Default, Debug)]
pub struct IfcDerivedUnit {
    elements: HashSet<EntityRef>,
    unit_type: IfcDerivedUnitEnum,
    user_defined_type: Option<IfcLabel>,
}
impl IIfcDerivedUnit for IfcDerivedUnit {
    fn elements(&self) -> &HashSet<EntityRef> {
        &self.elements
    }
    fn unit_type(&self) -> &IfcDerivedUnitEnum {
        &self.unit_type
    }
    fn user_defined_type(&self) -> &Option<IfcLabel> {
        &self.user_defined_type
    }
}
impl IfcDerivedUnit {
    pub fn from_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcDerivedUnit::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.elements = parameter.into(),
                1usize => entity.unit_type = parameter.into(),
                2usize => {
                    entity.user_defined_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcDerivedUnitElement {
    fn unit(&self) -> &EntityRef;
    fn exponent(&self) -> i64;
}
#[derive(Default, Debug)]
pub struct IfcDerivedUnitElement {
    unit: EntityRef,
    exponent: i64,
}
impl IIfcDerivedUnitElement for IfcDerivedUnitElement {
    fn unit(&self) -> &EntityRef {
        &self.unit
    }
    fn exponent(&self) -> i64 {
        self.exponent
    }
}
impl IfcDerivedUnitElement {
    pub fn from_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcDerivedUnitElement::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.unit = parameter.into(),
                1usize => entity.exponent = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcDimensionalExponents {
    fn length_exponent(&self) -> i64;
    fn mass_exponent(&self) -> i64;
    fn time_exponent(&self) -> i64;
    fn electric_current_exponent(&self) -> i64;
    fn thermodynamic_temperature_exponent(&self) -> i64;
    fn amount_of_substance_exponent(&self) -> i64;
    fn luminous_intensity_exponent(&self) -> i64;
}
#[derive(Default, Debug)]
pub struct IfcDimensionalExponents {
    length_exponent: i64,
    mass_exponent: i64,
    time_exponent: i64,
    electric_current_exponent: i64,
    thermodynamic_temperature_exponent: i64,
    amount_of_substance_exponent: i64,
    luminous_intensity_exponent: i64,
}
impl IIfcDimensionalExponents for IfcDimensionalExponents {
    fn length_exponent(&self) -> i64 {
        self.length_exponent
    }
    fn mass_exponent(&self) -> i64 {
        self.mass_exponent
    }
    fn time_exponent(&self) -> i64 {
        self.time_exponent
    }
    fn electric_current_exponent(&self) -> i64 {
        self.electric_current_exponent
    }
    fn thermodynamic_temperature_exponent(&self) -> i64 {
        self.thermodynamic_temperature_exponent
    }
    fn amount_of_substance_exponent(&self) -> i64 {
        self.amount_of_substance_exponent
    }
    fn luminous_intensity_exponent(&self) -> i64 {
        self.luminous_intensity_exponent
    }
}
impl IfcDimensionalExponents {
    pub fn from_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcDimensionalExponents::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.length_exponent = parameter.into(),
                1usize => entity.mass_exponent = parameter.into(),
                2usize => entity.time_exponent = parameter.into(),
                3usize => entity.electric_current_exponent = parameter.into(),
                4usize => entity.thermodynamic_temperature_exponent = parameter.into(),
                5usize => entity.amount_of_substance_exponent = parameter.into(),
                6usize => entity.luminous_intensity_exponent = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcDirection: IIfcGeometricRepresentationItem {
    fn direction_ratios(&self) -> &Vec<IfcReal>;
}
#[derive(Default, Debug)]
pub struct IfcDirection {
    direction_ratios: Vec<IfcReal>,
}
impl IIfcRepresentationItem for IfcDirection {}
impl IIfcGeometricRepresentationItem for IfcDirection {}
impl IIfcDirection for IfcDirection {
    fn direction_ratios(&self) -> &Vec<IfcReal> {
        &self.direction_ratios
    }
}
impl IfcDirection {
    pub fn from_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcDirection::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.direction_ratios = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcDiscreteAccessory: IIfcElementComponent {
    fn predefined_type(&self) -> &Option<IfcDiscreteAccessoryTypeEnum>;
}
#[derive(Default, Debug)]
pub struct IfcDiscreteAccessory {
    global_id: IfcGloballyUniqueId,
    owner_history: Option<EntityRef>,
    name: Option<IfcLabel>,
    description: Option<IfcText>,
    object_type: Option<IfcLabel>,
    object_placement: Option<EntityRef>,
    representation: Option<EntityRef>,
    tag: Option<IfcIdentifier>,
    predefined_type: Option<IfcDiscreteAccessoryTypeEnum>,
}
impl IIfcRoot for IfcDiscreteAccessory {
    fn global_id(&self) -> &IfcGloballyUniqueId {
        &self.global_id
    }
    fn owner_history(&self) -> &Option<EntityRef> {
        &self.owner_history
    }
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
}
impl IIfcObjectDefinition for IfcDiscreteAccessory {}
impl IIfcObject for IfcDiscreteAccessory {
    fn object_type(&self) -> &Option<IfcLabel> {
        &self.object_type
    }
}
impl IIfcProduct for IfcDiscreteAccessory {
    fn object_placement(&self) -> &Option<EntityRef> {
        &self.object_placement
    }
    fn representation(&self) -> &Option<EntityRef> {
        &self.representation
    }
}
impl IIfcElement for IfcDiscreteAccessory {
    fn tag(&self) -> &Option<IfcIdentifier> {
        &self.tag
    }
}
impl IIfcElementComponent for IfcDiscreteAccessory {}
impl IIfcDiscreteAccessory for IfcDiscreteAccessory {
    fn predefined_type(&self) -> &Option<IfcDiscreteAccessoryTypeEnum> {
        &self.predefined_type
    }
}
impl IfcDiscreteAccessory {
    pub fn from_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcDiscreteAccessory::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.global_id = parameter.into(),
                1usize => {
                    entity.owner_history = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => {
                    entity.object_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                5usize => {
                    entity.object_placement = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                6usize => {
                    entity.representation = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                7usize => {
                    entity.tag = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                8usize => {
                    entity.predefined_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
    pub fn from_own_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcDiscreteAccessory::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => {
                    entity.predefined_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcDiscreteAccessoryType: IIfcElementComponentType {
    fn predefined_type(&self) -> &IfcDiscreteAccessoryTypeEnum;
}
#[derive(Default, Debug)]
pub struct IfcDiscreteAccessoryType {
    global_id: IfcGloballyUniqueId,
    owner_history: Option<EntityRef>,
    name: Option<IfcLabel>,
    description: Option<IfcText>,
    applicable_occurrence: Option<IfcIdentifier>,
    has_property_sets: Option<HashSet<EntityRef>>,
    representation_maps: Option<Vec<EntityRef>>,
    tag: Option<IfcLabel>,
    element_type: Option<IfcLabel>,
    predefined_type: IfcDiscreteAccessoryTypeEnum,
}
impl IIfcRoot for IfcDiscreteAccessoryType {
    fn global_id(&self) -> &IfcGloballyUniqueId {
        &self.global_id
    }
    fn owner_history(&self) -> &Option<EntityRef> {
        &self.owner_history
    }
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
}
impl IIfcObjectDefinition for IfcDiscreteAccessoryType {}
impl IIfcTypeObject for IfcDiscreteAccessoryType {
    fn applicable_occurrence(&self) -> &Option<IfcIdentifier> {
        &self.applicable_occurrence
    }
    fn has_property_sets(&self) -> &Option<HashSet<EntityRef>> {
        &self.has_property_sets
    }
}
impl IIfcTypeProduct for IfcDiscreteAccessoryType {
    fn representation_maps(&self) -> &Option<Vec<EntityRef>> {
        &self.representation_maps
    }
    fn tag(&self) -> &Option<IfcLabel> {
        &self.tag
    }
}
impl IIfcElementType for IfcDiscreteAccessoryType {
    fn element_type(&self) -> &Option<IfcLabel> {
        &self.element_type
    }
}
impl IIfcElementComponentType for IfcDiscreteAccessoryType {}
impl IIfcDiscreteAccessoryType for IfcDiscreteAccessoryType {
    fn predefined_type(&self) -> &IfcDiscreteAccessoryTypeEnum {
        &self.predefined_type
    }
}
impl IfcDiscreteAccessoryType {
    pub fn from_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcDiscreteAccessoryType::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.global_id = parameter.into(),
                1usize => {
                    entity.owner_history = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => {
                    entity.applicable_occurrence = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                5usize => {
                    entity.has_property_sets = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                6usize => {
                    entity.representation_maps = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                7usize => {
                    entity.tag = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                8usize => {
                    entity.element_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                9usize => entity.predefined_type = parameter.into(),
                _ => {}
            }
        }
        entity
    }
    pub fn from_own_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcDiscreteAccessoryType::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.predefined_type = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcDistributionChamberElement: IIfcDistributionFlowElement {
    fn predefined_type(&self) -> &Option<IfcDistributionChamberElementTypeEnum>;
}
#[derive(Default, Debug)]
pub struct IfcDistributionChamberElement {
    global_id: IfcGloballyUniqueId,
    owner_history: Option<EntityRef>,
    name: Option<IfcLabel>,
    description: Option<IfcText>,
    object_type: Option<IfcLabel>,
    object_placement: Option<EntityRef>,
    representation: Option<EntityRef>,
    tag: Option<IfcIdentifier>,
    predefined_type: Option<IfcDistributionChamberElementTypeEnum>,
}
impl IIfcRoot for IfcDistributionChamberElement {
    fn global_id(&self) -> &IfcGloballyUniqueId {
        &self.global_id
    }
    fn owner_history(&self) -> &Option<EntityRef> {
        &self.owner_history
    }
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
}
impl IIfcObjectDefinition for IfcDistributionChamberElement {}
impl IIfcObject for IfcDistributionChamberElement {
    fn object_type(&self) -> &Option<IfcLabel> {
        &self.object_type
    }
}
impl IIfcProduct for IfcDistributionChamberElement {
    fn object_placement(&self) -> &Option<EntityRef> {
        &self.object_placement
    }
    fn representation(&self) -> &Option<EntityRef> {
        &self.representation
    }
}
impl IIfcElement for IfcDistributionChamberElement {
    fn tag(&self) -> &Option<IfcIdentifier> {
        &self.tag
    }
}
impl IIfcDistributionElement for IfcDistributionChamberElement {}
impl IIfcDistributionFlowElement for IfcDistributionChamberElement {}
impl IIfcDistributionChamberElement for IfcDistributionChamberElement {
    fn predefined_type(&self) -> &Option<IfcDistributionChamberElementTypeEnum> {
        &self.predefined_type
    }
}
impl IfcDistributionChamberElement {
    pub fn from_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcDistributionChamberElement::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.global_id = parameter.into(),
                1usize => {
                    entity.owner_history = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => {
                    entity.object_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                5usize => {
                    entity.object_placement = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                6usize => {
                    entity.representation = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                7usize => {
                    entity.tag = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                8usize => {
                    entity.predefined_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
    pub fn from_own_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcDistributionChamberElement::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => {
                    entity.predefined_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcDistributionChamberElementType: IIfcDistributionFlowElementType {
    fn predefined_type(&self) -> &IfcDistributionChamberElementTypeEnum;
}
#[derive(Default, Debug)]
pub struct IfcDistributionChamberElementType {
    global_id: IfcGloballyUniqueId,
    owner_history: Option<EntityRef>,
    name: Option<IfcLabel>,
    description: Option<IfcText>,
    applicable_occurrence: Option<IfcIdentifier>,
    has_property_sets: Option<HashSet<EntityRef>>,
    representation_maps: Option<Vec<EntityRef>>,
    tag: Option<IfcLabel>,
    element_type: Option<IfcLabel>,
    predefined_type: IfcDistributionChamberElementTypeEnum,
}
impl IIfcRoot for IfcDistributionChamberElementType {
    fn global_id(&self) -> &IfcGloballyUniqueId {
        &self.global_id
    }
    fn owner_history(&self) -> &Option<EntityRef> {
        &self.owner_history
    }
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
}
impl IIfcObjectDefinition for IfcDistributionChamberElementType {}
impl IIfcTypeObject for IfcDistributionChamberElementType {
    fn applicable_occurrence(&self) -> &Option<IfcIdentifier> {
        &self.applicable_occurrence
    }
    fn has_property_sets(&self) -> &Option<HashSet<EntityRef>> {
        &self.has_property_sets
    }
}
impl IIfcTypeProduct for IfcDistributionChamberElementType {
    fn representation_maps(&self) -> &Option<Vec<EntityRef>> {
        &self.representation_maps
    }
    fn tag(&self) -> &Option<IfcLabel> {
        &self.tag
    }
}
impl IIfcElementType for IfcDistributionChamberElementType {
    fn element_type(&self) -> &Option<IfcLabel> {
        &self.element_type
    }
}
impl IIfcDistributionElementType for IfcDistributionChamberElementType {}
impl IIfcDistributionFlowElementType for IfcDistributionChamberElementType {}
impl IIfcDistributionChamberElementType for IfcDistributionChamberElementType {
    fn predefined_type(&self) -> &IfcDistributionChamberElementTypeEnum {
        &self.predefined_type
    }
}
impl IfcDistributionChamberElementType {
    pub fn from_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcDistributionChamberElementType::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.global_id = parameter.into(),
                1usize => {
                    entity.owner_history = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => {
                    entity.applicable_occurrence = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                5usize => {
                    entity.has_property_sets = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                6usize => {
                    entity.representation_maps = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                7usize => {
                    entity.tag = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                8usize => {
                    entity.element_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                9usize => entity.predefined_type = parameter.into(),
                _ => {}
            }
        }
        entity
    }
    pub fn from_own_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcDistributionChamberElementType::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.predefined_type = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcDistributionCircuit: IIfcDistributionSystem {}
#[derive(Default, Debug)]
pub struct IfcDistributionCircuit {
    global_id: IfcGloballyUniqueId,
    owner_history: Option<EntityRef>,
    name: Option<IfcLabel>,
    description: Option<IfcText>,
    object_type: Option<IfcLabel>,
    long_name: Option<IfcLabel>,
    predefined_type: Option<IfcDistributionSystemEnum>,
}
impl IIfcRoot for IfcDistributionCircuit {
    fn global_id(&self) -> &IfcGloballyUniqueId {
        &self.global_id
    }
    fn owner_history(&self) -> &Option<EntityRef> {
        &self.owner_history
    }
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
}
impl IIfcObjectDefinition for IfcDistributionCircuit {}
impl IIfcObject for IfcDistributionCircuit {
    fn object_type(&self) -> &Option<IfcLabel> {
        &self.object_type
    }
}
impl IIfcGroup for IfcDistributionCircuit {}
impl IIfcSystem for IfcDistributionCircuit {}
impl IIfcDistributionSystem for IfcDistributionCircuit {
    fn long_name(&self) -> &Option<IfcLabel> {
        &self.long_name
    }
    fn predefined_type(&self) -> &Option<IfcDistributionSystemEnum> {
        &self.predefined_type
    }
}
impl IIfcDistributionCircuit for IfcDistributionCircuit {}
impl IfcDistributionCircuit {
    pub fn from_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcDistributionCircuit::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.global_id = parameter.into(),
                1usize => {
                    entity.owner_history = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => {
                    entity.object_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                5usize => {
                    entity.long_name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                6usize => {
                    entity.predefined_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcDistributionControlElement: IIfcDistributionElement {}
#[derive(Default, Debug)]
pub struct IfcDistributionControlElement {
    global_id: IfcGloballyUniqueId,
    owner_history: Option<EntityRef>,
    name: Option<IfcLabel>,
    description: Option<IfcText>,
    object_type: Option<IfcLabel>,
    object_placement: Option<EntityRef>,
    representation: Option<EntityRef>,
    tag: Option<IfcIdentifier>,
}
impl IIfcRoot for IfcDistributionControlElement {
    fn global_id(&self) -> &IfcGloballyUniqueId {
        &self.global_id
    }
    fn owner_history(&self) -> &Option<EntityRef> {
        &self.owner_history
    }
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
}
impl IIfcObjectDefinition for IfcDistributionControlElement {}
impl IIfcObject for IfcDistributionControlElement {
    fn object_type(&self) -> &Option<IfcLabel> {
        &self.object_type
    }
}
impl IIfcProduct for IfcDistributionControlElement {
    fn object_placement(&self) -> &Option<EntityRef> {
        &self.object_placement
    }
    fn representation(&self) -> &Option<EntityRef> {
        &self.representation
    }
}
impl IIfcElement for IfcDistributionControlElement {
    fn tag(&self) -> &Option<IfcIdentifier> {
        &self.tag
    }
}
impl IIfcDistributionElement for IfcDistributionControlElement {}
impl IIfcDistributionControlElement for IfcDistributionControlElement {}
impl IfcDistributionControlElement {
    pub fn from_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcDistributionControlElement::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.global_id = parameter.into(),
                1usize => {
                    entity.owner_history = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => {
                    entity.object_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                5usize => {
                    entity.object_placement = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                6usize => {
                    entity.representation = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                7usize => {
                    entity.tag = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcDistributionControlElementType: IIfcDistributionElementType {}
pub trait IIfcDistributionElement: IIfcElement {}
#[derive(Default, Debug)]
pub struct IfcDistributionElement {
    global_id: IfcGloballyUniqueId,
    owner_history: Option<EntityRef>,
    name: Option<IfcLabel>,
    description: Option<IfcText>,
    object_type: Option<IfcLabel>,
    object_placement: Option<EntityRef>,
    representation: Option<EntityRef>,
    tag: Option<IfcIdentifier>,
}
impl IIfcRoot for IfcDistributionElement {
    fn global_id(&self) -> &IfcGloballyUniqueId {
        &self.global_id
    }
    fn owner_history(&self) -> &Option<EntityRef> {
        &self.owner_history
    }
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
}
impl IIfcObjectDefinition for IfcDistributionElement {}
impl IIfcObject for IfcDistributionElement {
    fn object_type(&self) -> &Option<IfcLabel> {
        &self.object_type
    }
}
impl IIfcProduct for IfcDistributionElement {
    fn object_placement(&self) -> &Option<EntityRef> {
        &self.object_placement
    }
    fn representation(&self) -> &Option<EntityRef> {
        &self.representation
    }
}
impl IIfcElement for IfcDistributionElement {
    fn tag(&self) -> &Option<IfcIdentifier> {
        &self.tag
    }
}
impl IIfcDistributionElement for IfcDistributionElement {}
impl IfcDistributionElement {
    pub fn from_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcDistributionElement::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.global_id = parameter.into(),
                1usize => {
                    entity.owner_history = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => {
                    entity.object_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                5usize => {
                    entity.object_placement = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                6usize => {
                    entity.representation = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                7usize => {
                    entity.tag = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcDistributionElementType: IIfcElementType {}
#[derive(Default, Debug)]
pub struct IfcDistributionElementType {
    global_id: IfcGloballyUniqueId,
    owner_history: Option<EntityRef>,
    name: Option<IfcLabel>,
    description: Option<IfcText>,
    applicable_occurrence: Option<IfcIdentifier>,
    has_property_sets: Option<HashSet<EntityRef>>,
    representation_maps: Option<Vec<EntityRef>>,
    tag: Option<IfcLabel>,
    element_type: Option<IfcLabel>,
}
impl IIfcRoot for IfcDistributionElementType {
    fn global_id(&self) -> &IfcGloballyUniqueId {
        &self.global_id
    }
    fn owner_history(&self) -> &Option<EntityRef> {
        &self.owner_history
    }
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
}
impl IIfcObjectDefinition for IfcDistributionElementType {}
impl IIfcTypeObject for IfcDistributionElementType {
    fn applicable_occurrence(&self) -> &Option<IfcIdentifier> {
        &self.applicable_occurrence
    }
    fn has_property_sets(&self) -> &Option<HashSet<EntityRef>> {
        &self.has_property_sets
    }
}
impl IIfcTypeProduct for IfcDistributionElementType {
    fn representation_maps(&self) -> &Option<Vec<EntityRef>> {
        &self.representation_maps
    }
    fn tag(&self) -> &Option<IfcLabel> {
        &self.tag
    }
}
impl IIfcElementType for IfcDistributionElementType {
    fn element_type(&self) -> &Option<IfcLabel> {
        &self.element_type
    }
}
impl IIfcDistributionElementType for IfcDistributionElementType {}
impl IfcDistributionElementType {
    pub fn from_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcDistributionElementType::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.global_id = parameter.into(),
                1usize => {
                    entity.owner_history = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => {
                    entity.applicable_occurrence = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                5usize => {
                    entity.has_property_sets = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                6usize => {
                    entity.representation_maps = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                7usize => {
                    entity.tag = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                8usize => {
                    entity.element_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcDistributionFlowElement: IIfcDistributionElement {}
#[derive(Default, Debug)]
pub struct IfcDistributionFlowElement {
    global_id: IfcGloballyUniqueId,
    owner_history: Option<EntityRef>,
    name: Option<IfcLabel>,
    description: Option<IfcText>,
    object_type: Option<IfcLabel>,
    object_placement: Option<EntityRef>,
    representation: Option<EntityRef>,
    tag: Option<IfcIdentifier>,
}
impl IIfcRoot for IfcDistributionFlowElement {
    fn global_id(&self) -> &IfcGloballyUniqueId {
        &self.global_id
    }
    fn owner_history(&self) -> &Option<EntityRef> {
        &self.owner_history
    }
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
}
impl IIfcObjectDefinition for IfcDistributionFlowElement {}
impl IIfcObject for IfcDistributionFlowElement {
    fn object_type(&self) -> &Option<IfcLabel> {
        &self.object_type
    }
}
impl IIfcProduct for IfcDistributionFlowElement {
    fn object_placement(&self) -> &Option<EntityRef> {
        &self.object_placement
    }
    fn representation(&self) -> &Option<EntityRef> {
        &self.representation
    }
}
impl IIfcElement for IfcDistributionFlowElement {
    fn tag(&self) -> &Option<IfcIdentifier> {
        &self.tag
    }
}
impl IIfcDistributionElement for IfcDistributionFlowElement {}
impl IIfcDistributionFlowElement for IfcDistributionFlowElement {}
impl IfcDistributionFlowElement {
    pub fn from_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcDistributionFlowElement::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.global_id = parameter.into(),
                1usize => {
                    entity.owner_history = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => {
                    entity.object_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                5usize => {
                    entity.object_placement = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                6usize => {
                    entity.representation = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                7usize => {
                    entity.tag = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcDistributionFlowElementType: IIfcDistributionElementType {}
pub trait IIfcDistributionPort: IIfcPort {
    fn flow_direction(&self) -> &Option<IfcFlowDirectionEnum>;
    fn predefined_type(&self) -> &Option<IfcDistributionPortTypeEnum>;
    fn system_type(&self) -> &Option<IfcDistributionSystemEnum>;
}
#[derive(Default, Debug)]
pub struct IfcDistributionPort {
    global_id: IfcGloballyUniqueId,
    owner_history: Option<EntityRef>,
    name: Option<IfcLabel>,
    description: Option<IfcText>,
    object_type: Option<IfcLabel>,
    object_placement: Option<EntityRef>,
    representation: Option<EntityRef>,
    flow_direction: Option<IfcFlowDirectionEnum>,
    predefined_type: Option<IfcDistributionPortTypeEnum>,
    system_type: Option<IfcDistributionSystemEnum>,
}
impl IIfcRoot for IfcDistributionPort {
    fn global_id(&self) -> &IfcGloballyUniqueId {
        &self.global_id
    }
    fn owner_history(&self) -> &Option<EntityRef> {
        &self.owner_history
    }
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
}
impl IIfcObjectDefinition for IfcDistributionPort {}
impl IIfcObject for IfcDistributionPort {
    fn object_type(&self) -> &Option<IfcLabel> {
        &self.object_type
    }
}
impl IIfcProduct for IfcDistributionPort {
    fn object_placement(&self) -> &Option<EntityRef> {
        &self.object_placement
    }
    fn representation(&self) -> &Option<EntityRef> {
        &self.representation
    }
}
impl IIfcPort for IfcDistributionPort {}
impl IIfcDistributionPort for IfcDistributionPort {
    fn flow_direction(&self) -> &Option<IfcFlowDirectionEnum> {
        &self.flow_direction
    }
    fn predefined_type(&self) -> &Option<IfcDistributionPortTypeEnum> {
        &self.predefined_type
    }
    fn system_type(&self) -> &Option<IfcDistributionSystemEnum> {
        &self.system_type
    }
}
impl IfcDistributionPort {
    pub fn from_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcDistributionPort::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.global_id = parameter.into(),
                1usize => {
                    entity.owner_history = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => {
                    entity.object_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                5usize => {
                    entity.object_placement = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                6usize => {
                    entity.representation = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                7usize => {
                    entity.flow_direction = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                8usize => {
                    entity.predefined_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                9usize => {
                    entity.system_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
    pub fn from_own_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcDistributionPort::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => {
                    entity.flow_direction = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                1usize => {
                    entity.predefined_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => {
                    entity.system_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcDistributionSystem: IIfcSystem {
    fn long_name(&self) -> &Option<IfcLabel>;
    fn predefined_type(&self) -> &Option<IfcDistributionSystemEnum>;
}
#[derive(Default, Debug)]
pub struct IfcDistributionSystem {
    global_id: IfcGloballyUniqueId,
    owner_history: Option<EntityRef>,
    name: Option<IfcLabel>,
    description: Option<IfcText>,
    object_type: Option<IfcLabel>,
    long_name: Option<IfcLabel>,
    predefined_type: Option<IfcDistributionSystemEnum>,
}
impl IIfcRoot for IfcDistributionSystem {
    fn global_id(&self) -> &IfcGloballyUniqueId {
        &self.global_id
    }
    fn owner_history(&self) -> &Option<EntityRef> {
        &self.owner_history
    }
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
}
impl IIfcObjectDefinition for IfcDistributionSystem {}
impl IIfcObject for IfcDistributionSystem {
    fn object_type(&self) -> &Option<IfcLabel> {
        &self.object_type
    }
}
impl IIfcGroup for IfcDistributionSystem {}
impl IIfcSystem for IfcDistributionSystem {}
impl IIfcDistributionSystem for IfcDistributionSystem {
    fn long_name(&self) -> &Option<IfcLabel> {
        &self.long_name
    }
    fn predefined_type(&self) -> &Option<IfcDistributionSystemEnum> {
        &self.predefined_type
    }
}
impl IfcDistributionSystem {
    pub fn from_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcDistributionSystem::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.global_id = parameter.into(),
                1usize => {
                    entity.owner_history = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => {
                    entity.object_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                5usize => {
                    entity.long_name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                6usize => {
                    entity.predefined_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
    pub fn from_own_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcDistributionSystem::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => {
                    entity.long_name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                1usize => {
                    entity.predefined_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcDocumentInformation: IIfcExternalInformation {
    fn identification(&self) -> &IfcIdentifier;
    fn name(&self) -> &IfcLabel;
    fn description(&self) -> &Option<IfcText>;
    fn location(&self) -> &Option<IfcUriReference>;
    fn purpose(&self) -> &Option<IfcText>;
    fn intended_use(&self) -> &Option<IfcText>;
    fn scope(&self) -> &Option<IfcText>;
    fn revision(&self) -> &Option<IfcLabel>;
    fn document_owner(&self) -> &Option<EntityRef>;
    fn editors(&self) -> &Option<HashSet<EntityRef>>;
    fn creation_time(&self) -> &Option<IfcDateTime>;
    fn last_revision_time(&self) -> &Option<IfcDateTime>;
    fn electronic_format(&self) -> &Option<IfcIdentifier>;
    fn valid_from(&self) -> &Option<IfcDate>;
    fn valid_until(&self) -> &Option<IfcDate>;
    fn confidentiality(&self) -> &Option<IfcDocumentConfidentialityEnum>;
    fn status(&self) -> &Option<IfcDocumentStatusEnum>;
}
#[derive(Default, Debug)]
pub struct IfcDocumentInformation {
    identification: IfcIdentifier,
    name: IfcLabel,
    description: Option<IfcText>,
    location: Option<IfcUriReference>,
    purpose: Option<IfcText>,
    intended_use: Option<IfcText>,
    scope: Option<IfcText>,
    revision: Option<IfcLabel>,
    document_owner: Option<EntityRef>,
    editors: Option<HashSet<EntityRef>>,
    creation_time: Option<IfcDateTime>,
    last_revision_time: Option<IfcDateTime>,
    electronic_format: Option<IfcIdentifier>,
    valid_from: Option<IfcDate>,
    valid_until: Option<IfcDate>,
    confidentiality: Option<IfcDocumentConfidentialityEnum>,
    status: Option<IfcDocumentStatusEnum>,
}
impl IIfcExternalInformation for IfcDocumentInformation {}
impl IIfcDocumentInformation for IfcDocumentInformation {
    fn identification(&self) -> &IfcIdentifier {
        &self.identification
    }
    fn name(&self) -> &IfcLabel {
        &self.name
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
    fn location(&self) -> &Option<IfcUriReference> {
        &self.location
    }
    fn purpose(&self) -> &Option<IfcText> {
        &self.purpose
    }
    fn intended_use(&self) -> &Option<IfcText> {
        &self.intended_use
    }
    fn scope(&self) -> &Option<IfcText> {
        &self.scope
    }
    fn revision(&self) -> &Option<IfcLabel> {
        &self.revision
    }
    fn document_owner(&self) -> &Option<EntityRef> {
        &self.document_owner
    }
    fn editors(&self) -> &Option<HashSet<EntityRef>> {
        &self.editors
    }
    fn creation_time(&self) -> &Option<IfcDateTime> {
        &self.creation_time
    }
    fn last_revision_time(&self) -> &Option<IfcDateTime> {
        &self.last_revision_time
    }
    fn electronic_format(&self) -> &Option<IfcIdentifier> {
        &self.electronic_format
    }
    fn valid_from(&self) -> &Option<IfcDate> {
        &self.valid_from
    }
    fn valid_until(&self) -> &Option<IfcDate> {
        &self.valid_until
    }
    fn confidentiality(&self) -> &Option<IfcDocumentConfidentialityEnum> {
        &self.confidentiality
    }
    fn status(&self) -> &Option<IfcDocumentStatusEnum> {
        &self.status
    }
}
impl IfcDocumentInformation {
    pub fn from_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcDocumentInformation::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.identification = parameter.into(),
                1usize => entity.name = parameter.into(),
                2usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.location = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => {
                    entity.purpose = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                5usize => {
                    entity.intended_use = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                6usize => {
                    entity.scope = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                7usize => {
                    entity.revision = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                8usize => {
                    entity.document_owner = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                9usize => {
                    entity.editors = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                10usize => {
                    entity.creation_time = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                11usize => {
                    entity.last_revision_time = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                12usize => {
                    entity.electronic_format = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                13usize => {
                    entity.valid_from = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                14usize => {
                    entity.valid_until = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                15usize => {
                    entity.confidentiality = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                16usize => {
                    entity.status = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcDocumentInformationRelationship: IIfcResourceLevelRelationship {
    fn relating_document(&self) -> &EntityRef;
    fn related_documents(&self) -> &HashSet<EntityRef>;
    fn relationship_type(&self) -> &Option<IfcLabel>;
}
#[derive(Default, Debug)]
pub struct IfcDocumentInformationRelationship {
    name: Option<IfcLabel>,
    description: Option<IfcText>,
    relating_document: EntityRef,
    related_documents: HashSet<EntityRef>,
    relationship_type: Option<IfcLabel>,
}
impl IIfcResourceLevelRelationship for IfcDocumentInformationRelationship {
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
}
impl IIfcDocumentInformationRelationship for IfcDocumentInformationRelationship {
    fn relating_document(&self) -> &EntityRef {
        &self.relating_document
    }
    fn related_documents(&self) -> &HashSet<EntityRef> {
        &self.related_documents
    }
    fn relationship_type(&self) -> &Option<IfcLabel> {
        &self.relationship_type
    }
}
impl IfcDocumentInformationRelationship {
    pub fn from_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcDocumentInformationRelationship::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                1usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => entity.relating_document = parameter.into(),
                3usize => entity.related_documents = parameter.into(),
                4usize => {
                    entity.relationship_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
    pub fn from_own_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcDocumentInformationRelationship::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.relating_document = parameter.into(),
                1usize => entity.related_documents = parameter.into(),
                2usize => {
                    entity.relationship_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcDocumentReference: IIfcExternalReference {
    fn description(&self) -> &Option<IfcText>;
    fn referenced_document(&self) -> &Option<EntityRef>;
}
#[derive(Default, Debug)]
pub struct IfcDocumentReference {
    location: Option<IfcUriReference>,
    identification: Option<IfcIdentifier>,
    name: Option<IfcLabel>,
    description: Option<IfcText>,
    referenced_document: Option<EntityRef>,
}
impl IIfcExternalReference for IfcDocumentReference {
    fn location(&self) -> &Option<IfcUriReference> {
        &self.location
    }
    fn identification(&self) -> &Option<IfcIdentifier> {
        &self.identification
    }
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
}
impl IIfcDocumentReference for IfcDocumentReference {
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
    fn referenced_document(&self) -> &Option<EntityRef> {
        &self.referenced_document
    }
}
impl IfcDocumentReference {
    pub fn from_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcDocumentReference::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => {
                    entity.location = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                1usize => {
                    entity.identification = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => {
                    entity.referenced_document = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
    pub fn from_own_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcDocumentReference::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                1usize => {
                    entity.referenced_document = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcDoor: IIfcBuildingElement {
    fn overall_height(&self) -> &Option<IfcPositiveLengthMeasure>;
    fn overall_width(&self) -> &Option<IfcPositiveLengthMeasure>;
    fn predefined_type(&self) -> &Option<IfcDoorTypeEnum>;
    fn operation_type(&self) -> &Option<IfcDoorTypeOperationEnum>;
    fn user_defined_operation_type(&self) -> &Option<IfcLabel>;
}
#[derive(Default, Debug)]
pub struct IfcDoor {
    global_id: IfcGloballyUniqueId,
    owner_history: Option<EntityRef>,
    name: Option<IfcLabel>,
    description: Option<IfcText>,
    object_type: Option<IfcLabel>,
    object_placement: Option<EntityRef>,
    representation: Option<EntityRef>,
    tag: Option<IfcIdentifier>,
    overall_height: Option<IfcPositiveLengthMeasure>,
    overall_width: Option<IfcPositiveLengthMeasure>,
    predefined_type: Option<IfcDoorTypeEnum>,
    operation_type: Option<IfcDoorTypeOperationEnum>,
    user_defined_operation_type: Option<IfcLabel>,
}
impl IIfcRoot for IfcDoor {
    fn global_id(&self) -> &IfcGloballyUniqueId {
        &self.global_id
    }
    fn owner_history(&self) -> &Option<EntityRef> {
        &self.owner_history
    }
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
}
impl IIfcObjectDefinition for IfcDoor {}
impl IIfcObject for IfcDoor {
    fn object_type(&self) -> &Option<IfcLabel> {
        &self.object_type
    }
}
impl IIfcProduct for IfcDoor {
    fn object_placement(&self) -> &Option<EntityRef> {
        &self.object_placement
    }
    fn representation(&self) -> &Option<EntityRef> {
        &self.representation
    }
}
impl IIfcElement for IfcDoor {
    fn tag(&self) -> &Option<IfcIdentifier> {
        &self.tag
    }
}
impl IIfcBuildingElement for IfcDoor {}
impl IIfcDoor for IfcDoor {
    fn overall_height(&self) -> &Option<IfcPositiveLengthMeasure> {
        &self.overall_height
    }
    fn overall_width(&self) -> &Option<IfcPositiveLengthMeasure> {
        &self.overall_width
    }
    fn predefined_type(&self) -> &Option<IfcDoorTypeEnum> {
        &self.predefined_type
    }
    fn operation_type(&self) -> &Option<IfcDoorTypeOperationEnum> {
        &self.operation_type
    }
    fn user_defined_operation_type(&self) -> &Option<IfcLabel> {
        &self.user_defined_operation_type
    }
}
impl IfcDoor {
    pub fn from_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcDoor::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.global_id = parameter.into(),
                1usize => {
                    entity.owner_history = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => {
                    entity.object_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                5usize => {
                    entity.object_placement = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                6usize => {
                    entity.representation = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                7usize => {
                    entity.tag = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                8usize => {
                    entity.overall_height = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                9usize => {
                    entity.overall_width = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                10usize => {
                    entity.predefined_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                11usize => {
                    entity.operation_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                12usize => {
                    entity.user_defined_operation_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
    pub fn from_own_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcDoor::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => {
                    entity.overall_height = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                1usize => {
                    entity.overall_width = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => {
                    entity.predefined_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.operation_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => {
                    entity.user_defined_operation_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcDoorLiningProperties: IIfcPreDefinedPropertySet {
    fn lining_depth(&self) -> &Option<IfcPositiveLengthMeasure>;
    fn lining_thickness(&self) -> &Option<IfcNonNegativeLengthMeasure>;
    fn threshold_depth(&self) -> &Option<IfcPositiveLengthMeasure>;
    fn threshold_thickness(&self) -> &Option<IfcNonNegativeLengthMeasure>;
    fn transom_thickness(&self) -> &Option<IfcNonNegativeLengthMeasure>;
    fn transom_offset(&self) -> &Option<IfcLengthMeasure>;
    fn lining_offset(&self) -> &Option<IfcLengthMeasure>;
    fn threshold_offset(&self) -> &Option<IfcLengthMeasure>;
    fn casing_thickness(&self) -> &Option<IfcPositiveLengthMeasure>;
    fn casing_depth(&self) -> &Option<IfcPositiveLengthMeasure>;
    fn shape_aspect_style(&self) -> &Option<EntityRef>;
    fn lining_to_panel_offset_x(&self) -> &Option<IfcLengthMeasure>;
    fn lining_to_panel_offset_y(&self) -> &Option<IfcLengthMeasure>;
}
#[derive(Default, Debug)]
pub struct IfcDoorLiningProperties {
    global_id: IfcGloballyUniqueId,
    owner_history: Option<EntityRef>,
    name: Option<IfcLabel>,
    description: Option<IfcText>,
    lining_depth: Option<IfcPositiveLengthMeasure>,
    lining_thickness: Option<IfcNonNegativeLengthMeasure>,
    threshold_depth: Option<IfcPositiveLengthMeasure>,
    threshold_thickness: Option<IfcNonNegativeLengthMeasure>,
    transom_thickness: Option<IfcNonNegativeLengthMeasure>,
    transom_offset: Option<IfcLengthMeasure>,
    lining_offset: Option<IfcLengthMeasure>,
    threshold_offset: Option<IfcLengthMeasure>,
    casing_thickness: Option<IfcPositiveLengthMeasure>,
    casing_depth: Option<IfcPositiveLengthMeasure>,
    shape_aspect_style: Option<EntityRef>,
    lining_to_panel_offset_x: Option<IfcLengthMeasure>,
    lining_to_panel_offset_y: Option<IfcLengthMeasure>,
}
impl IIfcRoot for IfcDoorLiningProperties {
    fn global_id(&self) -> &IfcGloballyUniqueId {
        &self.global_id
    }
    fn owner_history(&self) -> &Option<EntityRef> {
        &self.owner_history
    }
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
}
impl IIfcPropertyDefinition for IfcDoorLiningProperties {}
impl IIfcPropertySetDefinition for IfcDoorLiningProperties {}
impl IIfcPreDefinedPropertySet for IfcDoorLiningProperties {}
impl IIfcDoorLiningProperties for IfcDoorLiningProperties {
    fn lining_depth(&self) -> &Option<IfcPositiveLengthMeasure> {
        &self.lining_depth
    }
    fn lining_thickness(&self) -> &Option<IfcNonNegativeLengthMeasure> {
        &self.lining_thickness
    }
    fn threshold_depth(&self) -> &Option<IfcPositiveLengthMeasure> {
        &self.threshold_depth
    }
    fn threshold_thickness(&self) -> &Option<IfcNonNegativeLengthMeasure> {
        &self.threshold_thickness
    }
    fn transom_thickness(&self) -> &Option<IfcNonNegativeLengthMeasure> {
        &self.transom_thickness
    }
    fn transom_offset(&self) -> &Option<IfcLengthMeasure> {
        &self.transom_offset
    }
    fn lining_offset(&self) -> &Option<IfcLengthMeasure> {
        &self.lining_offset
    }
    fn threshold_offset(&self) -> &Option<IfcLengthMeasure> {
        &self.threshold_offset
    }
    fn casing_thickness(&self) -> &Option<IfcPositiveLengthMeasure> {
        &self.casing_thickness
    }
    fn casing_depth(&self) -> &Option<IfcPositiveLengthMeasure> {
        &self.casing_depth
    }
    fn shape_aspect_style(&self) -> &Option<EntityRef> {
        &self.shape_aspect_style
    }
    fn lining_to_panel_offset_x(&self) -> &Option<IfcLengthMeasure> {
        &self.lining_to_panel_offset_x
    }
    fn lining_to_panel_offset_y(&self) -> &Option<IfcLengthMeasure> {
        &self.lining_to_panel_offset_y
    }
}
impl IfcDoorLiningProperties {
    pub fn from_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcDoorLiningProperties::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.global_id = parameter.into(),
                1usize => {
                    entity.owner_history = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => {
                    entity.lining_depth = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                5usize => {
                    entity.lining_thickness = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                6usize => {
                    entity.threshold_depth = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                7usize => {
                    entity.threshold_thickness = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                8usize => {
                    entity.transom_thickness = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                9usize => {
                    entity.transom_offset = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                10usize => {
                    entity.lining_offset = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                11usize => {
                    entity.threshold_offset = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                12usize => {
                    entity.casing_thickness = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                13usize => {
                    entity.casing_depth = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                14usize => {
                    entity.shape_aspect_style = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                15usize => {
                    entity.lining_to_panel_offset_x = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                16usize => {
                    entity.lining_to_panel_offset_y = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
    pub fn from_own_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcDoorLiningProperties::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => {
                    entity.lining_depth = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                1usize => {
                    entity.lining_thickness = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => {
                    entity.threshold_depth = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.threshold_thickness = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => {
                    entity.transom_thickness = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                5usize => {
                    entity.transom_offset = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                6usize => {
                    entity.lining_offset = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                7usize => {
                    entity.threshold_offset = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                8usize => {
                    entity.casing_thickness = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                9usize => {
                    entity.casing_depth = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                10usize => {
                    entity.shape_aspect_style = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                11usize => {
                    entity.lining_to_panel_offset_x = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                12usize => {
                    entity.lining_to_panel_offset_y = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcDoorPanelProperties: IIfcPreDefinedPropertySet {
    fn panel_depth(&self) -> &Option<IfcPositiveLengthMeasure>;
    fn panel_operation(&self) -> &IfcDoorPanelOperationEnum;
    fn panel_width(&self) -> &Option<IfcNormalisedRatioMeasure>;
    fn panel_position(&self) -> &IfcDoorPanelPositionEnum;
    fn shape_aspect_style(&self) -> &Option<EntityRef>;
}
#[derive(Default, Debug)]
pub struct IfcDoorPanelProperties {
    global_id: IfcGloballyUniqueId,
    owner_history: Option<EntityRef>,
    name: Option<IfcLabel>,
    description: Option<IfcText>,
    panel_depth: Option<IfcPositiveLengthMeasure>,
    panel_operation: IfcDoorPanelOperationEnum,
    panel_width: Option<IfcNormalisedRatioMeasure>,
    panel_position: IfcDoorPanelPositionEnum,
    shape_aspect_style: Option<EntityRef>,
}
impl IIfcRoot for IfcDoorPanelProperties {
    fn global_id(&self) -> &IfcGloballyUniqueId {
        &self.global_id
    }
    fn owner_history(&self) -> &Option<EntityRef> {
        &self.owner_history
    }
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
}
impl IIfcPropertyDefinition for IfcDoorPanelProperties {}
impl IIfcPropertySetDefinition for IfcDoorPanelProperties {}
impl IIfcPreDefinedPropertySet for IfcDoorPanelProperties {}
impl IIfcDoorPanelProperties for IfcDoorPanelProperties {
    fn panel_depth(&self) -> &Option<IfcPositiveLengthMeasure> {
        &self.panel_depth
    }
    fn panel_operation(&self) -> &IfcDoorPanelOperationEnum {
        &self.panel_operation
    }
    fn panel_width(&self) -> &Option<IfcNormalisedRatioMeasure> {
        &self.panel_width
    }
    fn panel_position(&self) -> &IfcDoorPanelPositionEnum {
        &self.panel_position
    }
    fn shape_aspect_style(&self) -> &Option<EntityRef> {
        &self.shape_aspect_style
    }
}
impl IfcDoorPanelProperties {
    pub fn from_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcDoorPanelProperties::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.global_id = parameter.into(),
                1usize => {
                    entity.owner_history = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => {
                    entity.panel_depth = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                5usize => entity.panel_operation = parameter.into(),
                6usize => {
                    entity.panel_width = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                7usize => entity.panel_position = parameter.into(),
                8usize => {
                    entity.shape_aspect_style = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
    pub fn from_own_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcDoorPanelProperties::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => {
                    entity.panel_depth = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                1usize => entity.panel_operation = parameter.into(),
                2usize => {
                    entity.panel_width = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => entity.panel_position = parameter.into(),
                4usize => {
                    entity.shape_aspect_style = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcDoorStandardCase: IIfcDoor {}
#[derive(Default, Debug)]
pub struct IfcDoorStandardCase {
    global_id: IfcGloballyUniqueId,
    owner_history: Option<EntityRef>,
    name: Option<IfcLabel>,
    description: Option<IfcText>,
    object_type: Option<IfcLabel>,
    object_placement: Option<EntityRef>,
    representation: Option<EntityRef>,
    tag: Option<IfcIdentifier>,
    overall_height: Option<IfcPositiveLengthMeasure>,
    overall_width: Option<IfcPositiveLengthMeasure>,
    predefined_type: Option<IfcDoorTypeEnum>,
    operation_type: Option<IfcDoorTypeOperationEnum>,
    user_defined_operation_type: Option<IfcLabel>,
}
impl IIfcRoot for IfcDoorStandardCase {
    fn global_id(&self) -> &IfcGloballyUniqueId {
        &self.global_id
    }
    fn owner_history(&self) -> &Option<EntityRef> {
        &self.owner_history
    }
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
}
impl IIfcObjectDefinition for IfcDoorStandardCase {}
impl IIfcObject for IfcDoorStandardCase {
    fn object_type(&self) -> &Option<IfcLabel> {
        &self.object_type
    }
}
impl IIfcProduct for IfcDoorStandardCase {
    fn object_placement(&self) -> &Option<EntityRef> {
        &self.object_placement
    }
    fn representation(&self) -> &Option<EntityRef> {
        &self.representation
    }
}
impl IIfcElement for IfcDoorStandardCase {
    fn tag(&self) -> &Option<IfcIdentifier> {
        &self.tag
    }
}
impl IIfcBuildingElement for IfcDoorStandardCase {}
impl IIfcDoor for IfcDoorStandardCase {
    fn overall_height(&self) -> &Option<IfcPositiveLengthMeasure> {
        &self.overall_height
    }
    fn overall_width(&self) -> &Option<IfcPositiveLengthMeasure> {
        &self.overall_width
    }
    fn predefined_type(&self) -> &Option<IfcDoorTypeEnum> {
        &self.predefined_type
    }
    fn operation_type(&self) -> &Option<IfcDoorTypeOperationEnum> {
        &self.operation_type
    }
    fn user_defined_operation_type(&self) -> &Option<IfcLabel> {
        &self.user_defined_operation_type
    }
}
impl IIfcDoorStandardCase for IfcDoorStandardCase {}
impl IfcDoorStandardCase {
    pub fn from_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcDoorStandardCase::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.global_id = parameter.into(),
                1usize => {
                    entity.owner_history = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => {
                    entity.object_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                5usize => {
                    entity.object_placement = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                6usize => {
                    entity.representation = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                7usize => {
                    entity.tag = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                8usize => {
                    entity.overall_height = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                9usize => {
                    entity.overall_width = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                10usize => {
                    entity.predefined_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                11usize => {
                    entity.operation_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                12usize => {
                    entity.user_defined_operation_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcDoorStyle: IIfcTypeProduct {
    fn operation_type(&self) -> &IfcDoorStyleOperationEnum;
    fn construction_type(&self) -> &IfcDoorStyleConstructionEnum;
    fn parameter_takes_precedence(&self) -> &IfcBoolean;
    fn sizeable(&self) -> &IfcBoolean;
}
#[derive(Default, Debug)]
pub struct IfcDoorStyle {
    global_id: IfcGloballyUniqueId,
    owner_history: Option<EntityRef>,
    name: Option<IfcLabel>,
    description: Option<IfcText>,
    applicable_occurrence: Option<IfcIdentifier>,
    has_property_sets: Option<HashSet<EntityRef>>,
    representation_maps: Option<Vec<EntityRef>>,
    tag: Option<IfcLabel>,
    operation_type: IfcDoorStyleOperationEnum,
    construction_type: IfcDoorStyleConstructionEnum,
    parameter_takes_precedence: IfcBoolean,
    sizeable: IfcBoolean,
}
impl IIfcRoot for IfcDoorStyle {
    fn global_id(&self) -> &IfcGloballyUniqueId {
        &self.global_id
    }
    fn owner_history(&self) -> &Option<EntityRef> {
        &self.owner_history
    }
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
}
impl IIfcObjectDefinition for IfcDoorStyle {}
impl IIfcTypeObject for IfcDoorStyle {
    fn applicable_occurrence(&self) -> &Option<IfcIdentifier> {
        &self.applicable_occurrence
    }
    fn has_property_sets(&self) -> &Option<HashSet<EntityRef>> {
        &self.has_property_sets
    }
}
impl IIfcTypeProduct for IfcDoorStyle {
    fn representation_maps(&self) -> &Option<Vec<EntityRef>> {
        &self.representation_maps
    }
    fn tag(&self) -> &Option<IfcLabel> {
        &self.tag
    }
}
impl IIfcDoorStyle for IfcDoorStyle {
    fn operation_type(&self) -> &IfcDoorStyleOperationEnum {
        &self.operation_type
    }
    fn construction_type(&self) -> &IfcDoorStyleConstructionEnum {
        &self.construction_type
    }
    fn parameter_takes_precedence(&self) -> &IfcBoolean {
        &self.parameter_takes_precedence
    }
    fn sizeable(&self) -> &IfcBoolean {
        &self.sizeable
    }
}
impl IfcDoorStyle {
    pub fn from_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcDoorStyle::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.global_id = parameter.into(),
                1usize => {
                    entity.owner_history = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => {
                    entity.applicable_occurrence = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                5usize => {
                    entity.has_property_sets = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                6usize => {
                    entity.representation_maps = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                7usize => {
                    entity.tag = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                8usize => entity.operation_type = parameter.into(),
                9usize => entity.construction_type = parameter.into(),
                10usize => entity.parameter_takes_precedence = parameter.into(),
                11usize => entity.sizeable = parameter.into(),
                _ => {}
            }
        }
        entity
    }
    pub fn from_own_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcDoorStyle::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.operation_type = parameter.into(),
                1usize => entity.construction_type = parameter.into(),
                2usize => entity.parameter_takes_precedence = parameter.into(),
                3usize => entity.sizeable = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcDoorType: IIfcBuildingElementType {
    fn predefined_type(&self) -> &IfcDoorTypeEnum;
    fn operation_type(&self) -> &IfcDoorTypeOperationEnum;
    fn parameter_takes_precedence(&self) -> &Option<IfcBoolean>;
    fn user_defined_operation_type(&self) -> &Option<IfcLabel>;
}
#[derive(Default, Debug)]
pub struct IfcDoorType {
    global_id: IfcGloballyUniqueId,
    owner_history: Option<EntityRef>,
    name: Option<IfcLabel>,
    description: Option<IfcText>,
    applicable_occurrence: Option<IfcIdentifier>,
    has_property_sets: Option<HashSet<EntityRef>>,
    representation_maps: Option<Vec<EntityRef>>,
    tag: Option<IfcLabel>,
    element_type: Option<IfcLabel>,
    predefined_type: IfcDoorTypeEnum,
    operation_type: IfcDoorTypeOperationEnum,
    parameter_takes_precedence: Option<IfcBoolean>,
    user_defined_operation_type: Option<IfcLabel>,
}
impl IIfcRoot for IfcDoorType {
    fn global_id(&self) -> &IfcGloballyUniqueId {
        &self.global_id
    }
    fn owner_history(&self) -> &Option<EntityRef> {
        &self.owner_history
    }
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
}
impl IIfcObjectDefinition for IfcDoorType {}
impl IIfcTypeObject for IfcDoorType {
    fn applicable_occurrence(&self) -> &Option<IfcIdentifier> {
        &self.applicable_occurrence
    }
    fn has_property_sets(&self) -> &Option<HashSet<EntityRef>> {
        &self.has_property_sets
    }
}
impl IIfcTypeProduct for IfcDoorType {
    fn representation_maps(&self) -> &Option<Vec<EntityRef>> {
        &self.representation_maps
    }
    fn tag(&self) -> &Option<IfcLabel> {
        &self.tag
    }
}
impl IIfcElementType for IfcDoorType {
    fn element_type(&self) -> &Option<IfcLabel> {
        &self.element_type
    }
}
impl IIfcBuildingElementType for IfcDoorType {}
impl IIfcDoorType for IfcDoorType {
    fn predefined_type(&self) -> &IfcDoorTypeEnum {
        &self.predefined_type
    }
    fn operation_type(&self) -> &IfcDoorTypeOperationEnum {
        &self.operation_type
    }
    fn parameter_takes_precedence(&self) -> &Option<IfcBoolean> {
        &self.parameter_takes_precedence
    }
    fn user_defined_operation_type(&self) -> &Option<IfcLabel> {
        &self.user_defined_operation_type
    }
}
impl IfcDoorType {
    pub fn from_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcDoorType::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.global_id = parameter.into(),
                1usize => {
                    entity.owner_history = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => {
                    entity.applicable_occurrence = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                5usize => {
                    entity.has_property_sets = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                6usize => {
                    entity.representation_maps = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                7usize => {
                    entity.tag = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                8usize => {
                    entity.element_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                9usize => entity.predefined_type = parameter.into(),
                10usize => entity.operation_type = parameter.into(),
                11usize => {
                    entity.parameter_takes_precedence = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                12usize => {
                    entity.user_defined_operation_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
    pub fn from_own_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcDoorType::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.predefined_type = parameter.into(),
                1usize => entity.operation_type = parameter.into(),
                2usize => {
                    entity.parameter_takes_precedence = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.user_defined_operation_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcDraughtingPreDefinedColour: IIfcPreDefinedColour {}
#[derive(Default, Debug)]
pub struct IfcDraughtingPreDefinedColour {
    name: IfcLabel,
}
impl IIfcPresentationItem for IfcDraughtingPreDefinedColour {}
impl IIfcPreDefinedItem for IfcDraughtingPreDefinedColour {
    fn name(&self) -> &IfcLabel {
        &self.name
    }
}
impl IIfcPreDefinedColour for IfcDraughtingPreDefinedColour {}
impl IIfcDraughtingPreDefinedColour for IfcDraughtingPreDefinedColour {}
impl IfcDraughtingPreDefinedColour {
    pub fn from_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcDraughtingPreDefinedColour::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcDraughtingPreDefinedCurveFont: IIfcPreDefinedCurveFont {}
#[derive(Default, Debug)]
pub struct IfcDraughtingPreDefinedCurveFont {
    name: IfcLabel,
}
impl IIfcPresentationItem for IfcDraughtingPreDefinedCurveFont {}
impl IIfcPreDefinedItem for IfcDraughtingPreDefinedCurveFont {
    fn name(&self) -> &IfcLabel {
        &self.name
    }
}
impl IIfcPreDefinedCurveFont for IfcDraughtingPreDefinedCurveFont {}
impl IIfcDraughtingPreDefinedCurveFont for IfcDraughtingPreDefinedCurveFont {}
impl IfcDraughtingPreDefinedCurveFont {
    pub fn from_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcDraughtingPreDefinedCurveFont::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcDuctFitting: IIfcFlowFitting {
    fn predefined_type(&self) -> &Option<IfcDuctFittingTypeEnum>;
}
#[derive(Default, Debug)]
pub struct IfcDuctFitting {
    global_id: IfcGloballyUniqueId,
    owner_history: Option<EntityRef>,
    name: Option<IfcLabel>,
    description: Option<IfcText>,
    object_type: Option<IfcLabel>,
    object_placement: Option<EntityRef>,
    representation: Option<EntityRef>,
    tag: Option<IfcIdentifier>,
    predefined_type: Option<IfcDuctFittingTypeEnum>,
}
impl IIfcRoot for IfcDuctFitting {
    fn global_id(&self) -> &IfcGloballyUniqueId {
        &self.global_id
    }
    fn owner_history(&self) -> &Option<EntityRef> {
        &self.owner_history
    }
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
}
impl IIfcObjectDefinition for IfcDuctFitting {}
impl IIfcObject for IfcDuctFitting {
    fn object_type(&self) -> &Option<IfcLabel> {
        &self.object_type
    }
}
impl IIfcProduct for IfcDuctFitting {
    fn object_placement(&self) -> &Option<EntityRef> {
        &self.object_placement
    }
    fn representation(&self) -> &Option<EntityRef> {
        &self.representation
    }
}
impl IIfcElement for IfcDuctFitting {
    fn tag(&self) -> &Option<IfcIdentifier> {
        &self.tag
    }
}
impl IIfcDistributionElement for IfcDuctFitting {}
impl IIfcDistributionFlowElement for IfcDuctFitting {}
impl IIfcFlowFitting for IfcDuctFitting {}
impl IIfcDuctFitting for IfcDuctFitting {
    fn predefined_type(&self) -> &Option<IfcDuctFittingTypeEnum> {
        &self.predefined_type
    }
}
impl IfcDuctFitting {
    pub fn from_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcDuctFitting::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.global_id = parameter.into(),
                1usize => {
                    entity.owner_history = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => {
                    entity.object_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                5usize => {
                    entity.object_placement = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                6usize => {
                    entity.representation = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                7usize => {
                    entity.tag = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                8usize => {
                    entity.predefined_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
    pub fn from_own_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcDuctFitting::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => {
                    entity.predefined_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcDuctFittingType: IIfcFlowFittingType {
    fn predefined_type(&self) -> &IfcDuctFittingTypeEnum;
}
#[derive(Default, Debug)]
pub struct IfcDuctFittingType {
    global_id: IfcGloballyUniqueId,
    owner_history: Option<EntityRef>,
    name: Option<IfcLabel>,
    description: Option<IfcText>,
    applicable_occurrence: Option<IfcIdentifier>,
    has_property_sets: Option<HashSet<EntityRef>>,
    representation_maps: Option<Vec<EntityRef>>,
    tag: Option<IfcLabel>,
    element_type: Option<IfcLabel>,
    predefined_type: IfcDuctFittingTypeEnum,
}
impl IIfcRoot for IfcDuctFittingType {
    fn global_id(&self) -> &IfcGloballyUniqueId {
        &self.global_id
    }
    fn owner_history(&self) -> &Option<EntityRef> {
        &self.owner_history
    }
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
}
impl IIfcObjectDefinition for IfcDuctFittingType {}
impl IIfcTypeObject for IfcDuctFittingType {
    fn applicable_occurrence(&self) -> &Option<IfcIdentifier> {
        &self.applicable_occurrence
    }
    fn has_property_sets(&self) -> &Option<HashSet<EntityRef>> {
        &self.has_property_sets
    }
}
impl IIfcTypeProduct for IfcDuctFittingType {
    fn representation_maps(&self) -> &Option<Vec<EntityRef>> {
        &self.representation_maps
    }
    fn tag(&self) -> &Option<IfcLabel> {
        &self.tag
    }
}
impl IIfcElementType for IfcDuctFittingType {
    fn element_type(&self) -> &Option<IfcLabel> {
        &self.element_type
    }
}
impl IIfcDistributionElementType for IfcDuctFittingType {}
impl IIfcDistributionFlowElementType for IfcDuctFittingType {}
impl IIfcFlowFittingType for IfcDuctFittingType {}
impl IIfcDuctFittingType for IfcDuctFittingType {
    fn predefined_type(&self) -> &IfcDuctFittingTypeEnum {
        &self.predefined_type
    }
}
impl IfcDuctFittingType {
    pub fn from_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcDuctFittingType::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.global_id = parameter.into(),
                1usize => {
                    entity.owner_history = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => {
                    entity.applicable_occurrence = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                5usize => {
                    entity.has_property_sets = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                6usize => {
                    entity.representation_maps = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                7usize => {
                    entity.tag = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                8usize => {
                    entity.element_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                9usize => entity.predefined_type = parameter.into(),
                _ => {}
            }
        }
        entity
    }
    pub fn from_own_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcDuctFittingType::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.predefined_type = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcDuctSegment: IIfcFlowSegment {
    fn predefined_type(&self) -> &Option<IfcDuctSegmentTypeEnum>;
}
#[derive(Default, Debug)]
pub struct IfcDuctSegment {
    global_id: IfcGloballyUniqueId,
    owner_history: Option<EntityRef>,
    name: Option<IfcLabel>,
    description: Option<IfcText>,
    object_type: Option<IfcLabel>,
    object_placement: Option<EntityRef>,
    representation: Option<EntityRef>,
    tag: Option<IfcIdentifier>,
    predefined_type: Option<IfcDuctSegmentTypeEnum>,
}
impl IIfcRoot for IfcDuctSegment {
    fn global_id(&self) -> &IfcGloballyUniqueId {
        &self.global_id
    }
    fn owner_history(&self) -> &Option<EntityRef> {
        &self.owner_history
    }
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
}
impl IIfcObjectDefinition for IfcDuctSegment {}
impl IIfcObject for IfcDuctSegment {
    fn object_type(&self) -> &Option<IfcLabel> {
        &self.object_type
    }
}
impl IIfcProduct for IfcDuctSegment {
    fn object_placement(&self) -> &Option<EntityRef> {
        &self.object_placement
    }
    fn representation(&self) -> &Option<EntityRef> {
        &self.representation
    }
}
impl IIfcElement for IfcDuctSegment {
    fn tag(&self) -> &Option<IfcIdentifier> {
        &self.tag
    }
}
impl IIfcDistributionElement for IfcDuctSegment {}
impl IIfcDistributionFlowElement for IfcDuctSegment {}
impl IIfcFlowSegment for IfcDuctSegment {}
impl IIfcDuctSegment for IfcDuctSegment {
    fn predefined_type(&self) -> &Option<IfcDuctSegmentTypeEnum> {
        &self.predefined_type
    }
}
impl IfcDuctSegment {
    pub fn from_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcDuctSegment::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.global_id = parameter.into(),
                1usize => {
                    entity.owner_history = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => {
                    entity.object_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                5usize => {
                    entity.object_placement = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                6usize => {
                    entity.representation = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                7usize => {
                    entity.tag = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                8usize => {
                    entity.predefined_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
    pub fn from_own_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcDuctSegment::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => {
                    entity.predefined_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcDuctSegmentType: IIfcFlowSegmentType {
    fn predefined_type(&self) -> &IfcDuctSegmentTypeEnum;
}
#[derive(Default, Debug)]
pub struct IfcDuctSegmentType {
    global_id: IfcGloballyUniqueId,
    owner_history: Option<EntityRef>,
    name: Option<IfcLabel>,
    description: Option<IfcText>,
    applicable_occurrence: Option<IfcIdentifier>,
    has_property_sets: Option<HashSet<EntityRef>>,
    representation_maps: Option<Vec<EntityRef>>,
    tag: Option<IfcLabel>,
    element_type: Option<IfcLabel>,
    predefined_type: IfcDuctSegmentTypeEnum,
}
impl IIfcRoot for IfcDuctSegmentType {
    fn global_id(&self) -> &IfcGloballyUniqueId {
        &self.global_id
    }
    fn owner_history(&self) -> &Option<EntityRef> {
        &self.owner_history
    }
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
}
impl IIfcObjectDefinition for IfcDuctSegmentType {}
impl IIfcTypeObject for IfcDuctSegmentType {
    fn applicable_occurrence(&self) -> &Option<IfcIdentifier> {
        &self.applicable_occurrence
    }
    fn has_property_sets(&self) -> &Option<HashSet<EntityRef>> {
        &self.has_property_sets
    }
}
impl IIfcTypeProduct for IfcDuctSegmentType {
    fn representation_maps(&self) -> &Option<Vec<EntityRef>> {
        &self.representation_maps
    }
    fn tag(&self) -> &Option<IfcLabel> {
        &self.tag
    }
}
impl IIfcElementType for IfcDuctSegmentType {
    fn element_type(&self) -> &Option<IfcLabel> {
        &self.element_type
    }
}
impl IIfcDistributionElementType for IfcDuctSegmentType {}
impl IIfcDistributionFlowElementType for IfcDuctSegmentType {}
impl IIfcFlowSegmentType for IfcDuctSegmentType {}
impl IIfcDuctSegmentType for IfcDuctSegmentType {
    fn predefined_type(&self) -> &IfcDuctSegmentTypeEnum {
        &self.predefined_type
    }
}
impl IfcDuctSegmentType {
    pub fn from_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcDuctSegmentType::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.global_id = parameter.into(),
                1usize => {
                    entity.owner_history = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => {
                    entity.applicable_occurrence = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                5usize => {
                    entity.has_property_sets = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                6usize => {
                    entity.representation_maps = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                7usize => {
                    entity.tag = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                8usize => {
                    entity.element_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                9usize => entity.predefined_type = parameter.into(),
                _ => {}
            }
        }
        entity
    }
    pub fn from_own_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcDuctSegmentType::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.predefined_type = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcDuctSilencer: IIfcFlowTreatmentDevice {
    fn predefined_type(&self) -> &Option<IfcDuctSilencerTypeEnum>;
}
#[derive(Default, Debug)]
pub struct IfcDuctSilencer {
    global_id: IfcGloballyUniqueId,
    owner_history: Option<EntityRef>,
    name: Option<IfcLabel>,
    description: Option<IfcText>,
    object_type: Option<IfcLabel>,
    object_placement: Option<EntityRef>,
    representation: Option<EntityRef>,
    tag: Option<IfcIdentifier>,
    predefined_type: Option<IfcDuctSilencerTypeEnum>,
}
impl IIfcRoot for IfcDuctSilencer {
    fn global_id(&self) -> &IfcGloballyUniqueId {
        &self.global_id
    }
    fn owner_history(&self) -> &Option<EntityRef> {
        &self.owner_history
    }
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
}
impl IIfcObjectDefinition for IfcDuctSilencer {}
impl IIfcObject for IfcDuctSilencer {
    fn object_type(&self) -> &Option<IfcLabel> {
        &self.object_type
    }
}
impl IIfcProduct for IfcDuctSilencer {
    fn object_placement(&self) -> &Option<EntityRef> {
        &self.object_placement
    }
    fn representation(&self) -> &Option<EntityRef> {
        &self.representation
    }
}
impl IIfcElement for IfcDuctSilencer {
    fn tag(&self) -> &Option<IfcIdentifier> {
        &self.tag
    }
}
impl IIfcDistributionElement for IfcDuctSilencer {}
impl IIfcDistributionFlowElement for IfcDuctSilencer {}
impl IIfcFlowTreatmentDevice for IfcDuctSilencer {}
impl IIfcDuctSilencer for IfcDuctSilencer {
    fn predefined_type(&self) -> &Option<IfcDuctSilencerTypeEnum> {
        &self.predefined_type
    }
}
impl IfcDuctSilencer {
    pub fn from_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcDuctSilencer::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.global_id = parameter.into(),
                1usize => {
                    entity.owner_history = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => {
                    entity.object_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                5usize => {
                    entity.object_placement = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                6usize => {
                    entity.representation = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                7usize => {
                    entity.tag = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                8usize => {
                    entity.predefined_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
    pub fn from_own_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcDuctSilencer::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => {
                    entity.predefined_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcDuctSilencerType: IIfcFlowTreatmentDeviceType {
    fn predefined_type(&self) -> &IfcDuctSilencerTypeEnum;
}
#[derive(Default, Debug)]
pub struct IfcDuctSilencerType {
    global_id: IfcGloballyUniqueId,
    owner_history: Option<EntityRef>,
    name: Option<IfcLabel>,
    description: Option<IfcText>,
    applicable_occurrence: Option<IfcIdentifier>,
    has_property_sets: Option<HashSet<EntityRef>>,
    representation_maps: Option<Vec<EntityRef>>,
    tag: Option<IfcLabel>,
    element_type: Option<IfcLabel>,
    predefined_type: IfcDuctSilencerTypeEnum,
}
impl IIfcRoot for IfcDuctSilencerType {
    fn global_id(&self) -> &IfcGloballyUniqueId {
        &self.global_id
    }
    fn owner_history(&self) -> &Option<EntityRef> {
        &self.owner_history
    }
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
}
impl IIfcObjectDefinition for IfcDuctSilencerType {}
impl IIfcTypeObject for IfcDuctSilencerType {
    fn applicable_occurrence(&self) -> &Option<IfcIdentifier> {
        &self.applicable_occurrence
    }
    fn has_property_sets(&self) -> &Option<HashSet<EntityRef>> {
        &self.has_property_sets
    }
}
impl IIfcTypeProduct for IfcDuctSilencerType {
    fn representation_maps(&self) -> &Option<Vec<EntityRef>> {
        &self.representation_maps
    }
    fn tag(&self) -> &Option<IfcLabel> {
        &self.tag
    }
}
impl IIfcElementType for IfcDuctSilencerType {
    fn element_type(&self) -> &Option<IfcLabel> {
        &self.element_type
    }
}
impl IIfcDistributionElementType for IfcDuctSilencerType {}
impl IIfcDistributionFlowElementType for IfcDuctSilencerType {}
impl IIfcFlowTreatmentDeviceType for IfcDuctSilencerType {}
impl IIfcDuctSilencerType for IfcDuctSilencerType {
    fn predefined_type(&self) -> &IfcDuctSilencerTypeEnum {
        &self.predefined_type
    }
}
impl IfcDuctSilencerType {
    pub fn from_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcDuctSilencerType::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.global_id = parameter.into(),
                1usize => {
                    entity.owner_history = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => {
                    entity.applicable_occurrence = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                5usize => {
                    entity.has_property_sets = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                6usize => {
                    entity.representation_maps = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                7usize => {
                    entity.tag = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                8usize => {
                    entity.element_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                9usize => entity.predefined_type = parameter.into(),
                _ => {}
            }
        }
        entity
    }
    pub fn from_own_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcDuctSilencerType::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.predefined_type = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcEdge: IIfcTopologicalRepresentationItem {
    fn edge_start(&self) -> &EntityRef;
    fn edge_end(&self) -> &EntityRef;
}
#[derive(Default, Debug)]
pub struct IfcEdge {
    edge_start: EntityRef,
    edge_end: EntityRef,
}
impl IIfcRepresentationItem for IfcEdge {}
impl IIfcTopologicalRepresentationItem for IfcEdge {}
impl IIfcEdge for IfcEdge {
    fn edge_start(&self) -> &EntityRef {
        &self.edge_start
    }
    fn edge_end(&self) -> &EntityRef {
        &self.edge_end
    }
}
impl IfcEdge {
    pub fn from_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcEdge::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.edge_start = parameter.into(),
                1usize => entity.edge_end = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcEdgeCurve: IIfcEdge {
    fn edge_geometry(&self) -> &EntityRef;
    fn same_sense(&self) -> &IfcBoolean;
}
#[derive(Default, Debug)]
pub struct IfcEdgeCurve {
    edge_start: EntityRef,
    edge_end: EntityRef,
    edge_geometry: EntityRef,
    same_sense: IfcBoolean,
}
impl IIfcRepresentationItem for IfcEdgeCurve {}
impl IIfcTopologicalRepresentationItem for IfcEdgeCurve {}
impl IIfcEdge for IfcEdgeCurve {
    fn edge_start(&self) -> &EntityRef {
        &self.edge_start
    }
    fn edge_end(&self) -> &EntityRef {
        &self.edge_end
    }
}
impl IIfcEdgeCurve for IfcEdgeCurve {
    fn edge_geometry(&self) -> &EntityRef {
        &self.edge_geometry
    }
    fn same_sense(&self) -> &IfcBoolean {
        &self.same_sense
    }
}
impl IfcEdgeCurve {
    pub fn from_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcEdgeCurve::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.edge_start = parameter.into(),
                1usize => entity.edge_end = parameter.into(),
                2usize => entity.edge_geometry = parameter.into(),
                3usize => entity.same_sense = parameter.into(),
                _ => {}
            }
        }
        entity
    }
    pub fn from_own_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcEdgeCurve::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.edge_geometry = parameter.into(),
                1usize => entity.same_sense = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcEdgeLoop: IIfcLoop {
    fn edge_list(&self) -> &Vec<EntityRef>;
}
#[derive(Default, Debug)]
pub struct IfcEdgeLoop {
    edge_list: Vec<EntityRef>,
}
impl IIfcRepresentationItem for IfcEdgeLoop {}
impl IIfcTopologicalRepresentationItem for IfcEdgeLoop {}
impl IIfcLoop for IfcEdgeLoop {}
impl IIfcEdgeLoop for IfcEdgeLoop {
    fn edge_list(&self) -> &Vec<EntityRef> {
        &self.edge_list
    }
}
impl IfcEdgeLoop {
    pub fn from_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcEdgeLoop::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.edge_list = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcElectricAppliance: IIfcFlowTerminal {
    fn predefined_type(&self) -> &Option<IfcElectricApplianceTypeEnum>;
}
#[derive(Default, Debug)]
pub struct IfcElectricAppliance {
    global_id: IfcGloballyUniqueId,
    owner_history: Option<EntityRef>,
    name: Option<IfcLabel>,
    description: Option<IfcText>,
    object_type: Option<IfcLabel>,
    object_placement: Option<EntityRef>,
    representation: Option<EntityRef>,
    tag: Option<IfcIdentifier>,
    predefined_type: Option<IfcElectricApplianceTypeEnum>,
}
impl IIfcRoot for IfcElectricAppliance {
    fn global_id(&self) -> &IfcGloballyUniqueId {
        &self.global_id
    }
    fn owner_history(&self) -> &Option<EntityRef> {
        &self.owner_history
    }
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
}
impl IIfcObjectDefinition for IfcElectricAppliance {}
impl IIfcObject for IfcElectricAppliance {
    fn object_type(&self) -> &Option<IfcLabel> {
        &self.object_type
    }
}
impl IIfcProduct for IfcElectricAppliance {
    fn object_placement(&self) -> &Option<EntityRef> {
        &self.object_placement
    }
    fn representation(&self) -> &Option<EntityRef> {
        &self.representation
    }
}
impl IIfcElement for IfcElectricAppliance {
    fn tag(&self) -> &Option<IfcIdentifier> {
        &self.tag
    }
}
impl IIfcDistributionElement for IfcElectricAppliance {}
impl IIfcDistributionFlowElement for IfcElectricAppliance {}
impl IIfcFlowTerminal for IfcElectricAppliance {}
impl IIfcElectricAppliance for IfcElectricAppliance {
    fn predefined_type(&self) -> &Option<IfcElectricApplianceTypeEnum> {
        &self.predefined_type
    }
}
impl IfcElectricAppliance {
    pub fn from_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcElectricAppliance::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.global_id = parameter.into(),
                1usize => {
                    entity.owner_history = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => {
                    entity.object_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                5usize => {
                    entity.object_placement = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                6usize => {
                    entity.representation = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                7usize => {
                    entity.tag = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                8usize => {
                    entity.predefined_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
    pub fn from_own_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcElectricAppliance::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => {
                    entity.predefined_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcElectricApplianceType: IIfcFlowTerminalType {
    fn predefined_type(&self) -> &IfcElectricApplianceTypeEnum;
}
#[derive(Default, Debug)]
pub struct IfcElectricApplianceType {
    global_id: IfcGloballyUniqueId,
    owner_history: Option<EntityRef>,
    name: Option<IfcLabel>,
    description: Option<IfcText>,
    applicable_occurrence: Option<IfcIdentifier>,
    has_property_sets: Option<HashSet<EntityRef>>,
    representation_maps: Option<Vec<EntityRef>>,
    tag: Option<IfcLabel>,
    element_type: Option<IfcLabel>,
    predefined_type: IfcElectricApplianceTypeEnum,
}
impl IIfcRoot for IfcElectricApplianceType {
    fn global_id(&self) -> &IfcGloballyUniqueId {
        &self.global_id
    }
    fn owner_history(&self) -> &Option<EntityRef> {
        &self.owner_history
    }
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
}
impl IIfcObjectDefinition for IfcElectricApplianceType {}
impl IIfcTypeObject for IfcElectricApplianceType {
    fn applicable_occurrence(&self) -> &Option<IfcIdentifier> {
        &self.applicable_occurrence
    }
    fn has_property_sets(&self) -> &Option<HashSet<EntityRef>> {
        &self.has_property_sets
    }
}
impl IIfcTypeProduct for IfcElectricApplianceType {
    fn representation_maps(&self) -> &Option<Vec<EntityRef>> {
        &self.representation_maps
    }
    fn tag(&self) -> &Option<IfcLabel> {
        &self.tag
    }
}
impl IIfcElementType for IfcElectricApplianceType {
    fn element_type(&self) -> &Option<IfcLabel> {
        &self.element_type
    }
}
impl IIfcDistributionElementType for IfcElectricApplianceType {}
impl IIfcDistributionFlowElementType for IfcElectricApplianceType {}
impl IIfcFlowTerminalType for IfcElectricApplianceType {}
impl IIfcElectricApplianceType for IfcElectricApplianceType {
    fn predefined_type(&self) -> &IfcElectricApplianceTypeEnum {
        &self.predefined_type
    }
}
impl IfcElectricApplianceType {
    pub fn from_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcElectricApplianceType::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.global_id = parameter.into(),
                1usize => {
                    entity.owner_history = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => {
                    entity.applicable_occurrence = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                5usize => {
                    entity.has_property_sets = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                6usize => {
                    entity.representation_maps = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                7usize => {
                    entity.tag = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                8usize => {
                    entity.element_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                9usize => entity.predefined_type = parameter.into(),
                _ => {}
            }
        }
        entity
    }
    pub fn from_own_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcElectricApplianceType::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.predefined_type = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcElectricDistributionBoard: IIfcFlowController {
    fn predefined_type(&self) -> &Option<IfcElectricDistributionBoardTypeEnum>;
}
#[derive(Default, Debug)]
pub struct IfcElectricDistributionBoard {
    global_id: IfcGloballyUniqueId,
    owner_history: Option<EntityRef>,
    name: Option<IfcLabel>,
    description: Option<IfcText>,
    object_type: Option<IfcLabel>,
    object_placement: Option<EntityRef>,
    representation: Option<EntityRef>,
    tag: Option<IfcIdentifier>,
    predefined_type: Option<IfcElectricDistributionBoardTypeEnum>,
}
impl IIfcRoot for IfcElectricDistributionBoard {
    fn global_id(&self) -> &IfcGloballyUniqueId {
        &self.global_id
    }
    fn owner_history(&self) -> &Option<EntityRef> {
        &self.owner_history
    }
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
}
impl IIfcObjectDefinition for IfcElectricDistributionBoard {}
impl IIfcObject for IfcElectricDistributionBoard {
    fn object_type(&self) -> &Option<IfcLabel> {
        &self.object_type
    }
}
impl IIfcProduct for IfcElectricDistributionBoard {
    fn object_placement(&self) -> &Option<EntityRef> {
        &self.object_placement
    }
    fn representation(&self) -> &Option<EntityRef> {
        &self.representation
    }
}
impl IIfcElement for IfcElectricDistributionBoard {
    fn tag(&self) -> &Option<IfcIdentifier> {
        &self.tag
    }
}
impl IIfcDistributionElement for IfcElectricDistributionBoard {}
impl IIfcDistributionFlowElement for IfcElectricDistributionBoard {}
impl IIfcFlowController for IfcElectricDistributionBoard {}
impl IIfcElectricDistributionBoard for IfcElectricDistributionBoard {
    fn predefined_type(&self) -> &Option<IfcElectricDistributionBoardTypeEnum> {
        &self.predefined_type
    }
}
impl IfcElectricDistributionBoard {
    pub fn from_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcElectricDistributionBoard::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.global_id = parameter.into(),
                1usize => {
                    entity.owner_history = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => {
                    entity.object_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                5usize => {
                    entity.object_placement = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                6usize => {
                    entity.representation = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                7usize => {
                    entity.tag = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                8usize => {
                    entity.predefined_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
    pub fn from_own_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcElectricDistributionBoard::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => {
                    entity.predefined_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcElectricDistributionBoardType: IIfcFlowControllerType {
    fn predefined_type(&self) -> &IfcElectricDistributionBoardTypeEnum;
}
#[derive(Default, Debug)]
pub struct IfcElectricDistributionBoardType {
    global_id: IfcGloballyUniqueId,
    owner_history: Option<EntityRef>,
    name: Option<IfcLabel>,
    description: Option<IfcText>,
    applicable_occurrence: Option<IfcIdentifier>,
    has_property_sets: Option<HashSet<EntityRef>>,
    representation_maps: Option<Vec<EntityRef>>,
    tag: Option<IfcLabel>,
    element_type: Option<IfcLabel>,
    predefined_type: IfcElectricDistributionBoardTypeEnum,
}
impl IIfcRoot for IfcElectricDistributionBoardType {
    fn global_id(&self) -> &IfcGloballyUniqueId {
        &self.global_id
    }
    fn owner_history(&self) -> &Option<EntityRef> {
        &self.owner_history
    }
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
}
impl IIfcObjectDefinition for IfcElectricDistributionBoardType {}
impl IIfcTypeObject for IfcElectricDistributionBoardType {
    fn applicable_occurrence(&self) -> &Option<IfcIdentifier> {
        &self.applicable_occurrence
    }
    fn has_property_sets(&self) -> &Option<HashSet<EntityRef>> {
        &self.has_property_sets
    }
}
impl IIfcTypeProduct for IfcElectricDistributionBoardType {
    fn representation_maps(&self) -> &Option<Vec<EntityRef>> {
        &self.representation_maps
    }
    fn tag(&self) -> &Option<IfcLabel> {
        &self.tag
    }
}
impl IIfcElementType for IfcElectricDistributionBoardType {
    fn element_type(&self) -> &Option<IfcLabel> {
        &self.element_type
    }
}
impl IIfcDistributionElementType for IfcElectricDistributionBoardType {}
impl IIfcDistributionFlowElementType for IfcElectricDistributionBoardType {}
impl IIfcFlowControllerType for IfcElectricDistributionBoardType {}
impl IIfcElectricDistributionBoardType for IfcElectricDistributionBoardType {
    fn predefined_type(&self) -> &IfcElectricDistributionBoardTypeEnum {
        &self.predefined_type
    }
}
impl IfcElectricDistributionBoardType {
    pub fn from_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcElectricDistributionBoardType::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.global_id = parameter.into(),
                1usize => {
                    entity.owner_history = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => {
                    entity.applicable_occurrence = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                5usize => {
                    entity.has_property_sets = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                6usize => {
                    entity.representation_maps = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                7usize => {
                    entity.tag = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                8usize => {
                    entity.element_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                9usize => entity.predefined_type = parameter.into(),
                _ => {}
            }
        }
        entity
    }
    pub fn from_own_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcElectricDistributionBoardType::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.predefined_type = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcElectricFlowStorageDevice: IIfcFlowStorageDevice {
    fn predefined_type(&self) -> &Option<IfcElectricFlowStorageDeviceTypeEnum>;
}
#[derive(Default, Debug)]
pub struct IfcElectricFlowStorageDevice {
    global_id: IfcGloballyUniqueId,
    owner_history: Option<EntityRef>,
    name: Option<IfcLabel>,
    description: Option<IfcText>,
    object_type: Option<IfcLabel>,
    object_placement: Option<EntityRef>,
    representation: Option<EntityRef>,
    tag: Option<IfcIdentifier>,
    predefined_type: Option<IfcElectricFlowStorageDeviceTypeEnum>,
}
impl IIfcRoot for IfcElectricFlowStorageDevice {
    fn global_id(&self) -> &IfcGloballyUniqueId {
        &self.global_id
    }
    fn owner_history(&self) -> &Option<EntityRef> {
        &self.owner_history
    }
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
}
impl IIfcObjectDefinition for IfcElectricFlowStorageDevice {}
impl IIfcObject for IfcElectricFlowStorageDevice {
    fn object_type(&self) -> &Option<IfcLabel> {
        &self.object_type
    }
}
impl IIfcProduct for IfcElectricFlowStorageDevice {
    fn object_placement(&self) -> &Option<EntityRef> {
        &self.object_placement
    }
    fn representation(&self) -> &Option<EntityRef> {
        &self.representation
    }
}
impl IIfcElement for IfcElectricFlowStorageDevice {
    fn tag(&self) -> &Option<IfcIdentifier> {
        &self.tag
    }
}
impl IIfcDistributionElement for IfcElectricFlowStorageDevice {}
impl IIfcDistributionFlowElement for IfcElectricFlowStorageDevice {}
impl IIfcFlowStorageDevice for IfcElectricFlowStorageDevice {}
impl IIfcElectricFlowStorageDevice for IfcElectricFlowStorageDevice {
    fn predefined_type(&self) -> &Option<IfcElectricFlowStorageDeviceTypeEnum> {
        &self.predefined_type
    }
}
impl IfcElectricFlowStorageDevice {
    pub fn from_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcElectricFlowStorageDevice::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.global_id = parameter.into(),
                1usize => {
                    entity.owner_history = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => {
                    entity.object_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                5usize => {
                    entity.object_placement = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                6usize => {
                    entity.representation = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                7usize => {
                    entity.tag = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                8usize => {
                    entity.predefined_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
    pub fn from_own_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcElectricFlowStorageDevice::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => {
                    entity.predefined_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcElectricFlowStorageDeviceType: IIfcFlowStorageDeviceType {
    fn predefined_type(&self) -> &IfcElectricFlowStorageDeviceTypeEnum;
}
#[derive(Default, Debug)]
pub struct IfcElectricFlowStorageDeviceType {
    global_id: IfcGloballyUniqueId,
    owner_history: Option<EntityRef>,
    name: Option<IfcLabel>,
    description: Option<IfcText>,
    applicable_occurrence: Option<IfcIdentifier>,
    has_property_sets: Option<HashSet<EntityRef>>,
    representation_maps: Option<Vec<EntityRef>>,
    tag: Option<IfcLabel>,
    element_type: Option<IfcLabel>,
    predefined_type: IfcElectricFlowStorageDeviceTypeEnum,
}
impl IIfcRoot for IfcElectricFlowStorageDeviceType {
    fn global_id(&self) -> &IfcGloballyUniqueId {
        &self.global_id
    }
    fn owner_history(&self) -> &Option<EntityRef> {
        &self.owner_history
    }
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
}
impl IIfcObjectDefinition for IfcElectricFlowStorageDeviceType {}
impl IIfcTypeObject for IfcElectricFlowStorageDeviceType {
    fn applicable_occurrence(&self) -> &Option<IfcIdentifier> {
        &self.applicable_occurrence
    }
    fn has_property_sets(&self) -> &Option<HashSet<EntityRef>> {
        &self.has_property_sets
    }
}
impl IIfcTypeProduct for IfcElectricFlowStorageDeviceType {
    fn representation_maps(&self) -> &Option<Vec<EntityRef>> {
        &self.representation_maps
    }
    fn tag(&self) -> &Option<IfcLabel> {
        &self.tag
    }
}
impl IIfcElementType for IfcElectricFlowStorageDeviceType {
    fn element_type(&self) -> &Option<IfcLabel> {
        &self.element_type
    }
}
impl IIfcDistributionElementType for IfcElectricFlowStorageDeviceType {}
impl IIfcDistributionFlowElementType for IfcElectricFlowStorageDeviceType {}
impl IIfcFlowStorageDeviceType for IfcElectricFlowStorageDeviceType {}
impl IIfcElectricFlowStorageDeviceType for IfcElectricFlowStorageDeviceType {
    fn predefined_type(&self) -> &IfcElectricFlowStorageDeviceTypeEnum {
        &self.predefined_type
    }
}
impl IfcElectricFlowStorageDeviceType {
    pub fn from_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcElectricFlowStorageDeviceType::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.global_id = parameter.into(),
                1usize => {
                    entity.owner_history = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => {
                    entity.applicable_occurrence = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                5usize => {
                    entity.has_property_sets = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                6usize => {
                    entity.representation_maps = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                7usize => {
                    entity.tag = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                8usize => {
                    entity.element_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                9usize => entity.predefined_type = parameter.into(),
                _ => {}
            }
        }
        entity
    }
    pub fn from_own_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcElectricFlowStorageDeviceType::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.predefined_type = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcElectricGenerator: IIfcEnergyConversionDevice {
    fn predefined_type(&self) -> &Option<IfcElectricGeneratorTypeEnum>;
}
#[derive(Default, Debug)]
pub struct IfcElectricGenerator {
    global_id: IfcGloballyUniqueId,
    owner_history: Option<EntityRef>,
    name: Option<IfcLabel>,
    description: Option<IfcText>,
    object_type: Option<IfcLabel>,
    object_placement: Option<EntityRef>,
    representation: Option<EntityRef>,
    tag: Option<IfcIdentifier>,
    predefined_type: Option<IfcElectricGeneratorTypeEnum>,
}
impl IIfcRoot for IfcElectricGenerator {
    fn global_id(&self) -> &IfcGloballyUniqueId {
        &self.global_id
    }
    fn owner_history(&self) -> &Option<EntityRef> {
        &self.owner_history
    }
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
}
impl IIfcObjectDefinition for IfcElectricGenerator {}
impl IIfcObject for IfcElectricGenerator {
    fn object_type(&self) -> &Option<IfcLabel> {
        &self.object_type
    }
}
impl IIfcProduct for IfcElectricGenerator {
    fn object_placement(&self) -> &Option<EntityRef> {
        &self.object_placement
    }
    fn representation(&self) -> &Option<EntityRef> {
        &self.representation
    }
}
impl IIfcElement for IfcElectricGenerator {
    fn tag(&self) -> &Option<IfcIdentifier> {
        &self.tag
    }
}
impl IIfcDistributionElement for IfcElectricGenerator {}
impl IIfcDistributionFlowElement for IfcElectricGenerator {}
impl IIfcEnergyConversionDevice for IfcElectricGenerator {}
impl IIfcElectricGenerator for IfcElectricGenerator {
    fn predefined_type(&self) -> &Option<IfcElectricGeneratorTypeEnum> {
        &self.predefined_type
    }
}
impl IfcElectricGenerator {
    pub fn from_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcElectricGenerator::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.global_id = parameter.into(),
                1usize => {
                    entity.owner_history = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => {
                    entity.object_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                5usize => {
                    entity.object_placement = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                6usize => {
                    entity.representation = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                7usize => {
                    entity.tag = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                8usize => {
                    entity.predefined_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
    pub fn from_own_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcElectricGenerator::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => {
                    entity.predefined_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcElectricGeneratorType: IIfcEnergyConversionDeviceType {
    fn predefined_type(&self) -> &IfcElectricGeneratorTypeEnum;
}
#[derive(Default, Debug)]
pub struct IfcElectricGeneratorType {
    global_id: IfcGloballyUniqueId,
    owner_history: Option<EntityRef>,
    name: Option<IfcLabel>,
    description: Option<IfcText>,
    applicable_occurrence: Option<IfcIdentifier>,
    has_property_sets: Option<HashSet<EntityRef>>,
    representation_maps: Option<Vec<EntityRef>>,
    tag: Option<IfcLabel>,
    element_type: Option<IfcLabel>,
    predefined_type: IfcElectricGeneratorTypeEnum,
}
impl IIfcRoot for IfcElectricGeneratorType {
    fn global_id(&self) -> &IfcGloballyUniqueId {
        &self.global_id
    }
    fn owner_history(&self) -> &Option<EntityRef> {
        &self.owner_history
    }
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
}
impl IIfcObjectDefinition for IfcElectricGeneratorType {}
impl IIfcTypeObject for IfcElectricGeneratorType {
    fn applicable_occurrence(&self) -> &Option<IfcIdentifier> {
        &self.applicable_occurrence
    }
    fn has_property_sets(&self) -> &Option<HashSet<EntityRef>> {
        &self.has_property_sets
    }
}
impl IIfcTypeProduct for IfcElectricGeneratorType {
    fn representation_maps(&self) -> &Option<Vec<EntityRef>> {
        &self.representation_maps
    }
    fn tag(&self) -> &Option<IfcLabel> {
        &self.tag
    }
}
impl IIfcElementType for IfcElectricGeneratorType {
    fn element_type(&self) -> &Option<IfcLabel> {
        &self.element_type
    }
}
impl IIfcDistributionElementType for IfcElectricGeneratorType {}
impl IIfcDistributionFlowElementType for IfcElectricGeneratorType {}
impl IIfcEnergyConversionDeviceType for IfcElectricGeneratorType {}
impl IIfcElectricGeneratorType for IfcElectricGeneratorType {
    fn predefined_type(&self) -> &IfcElectricGeneratorTypeEnum {
        &self.predefined_type
    }
}
impl IfcElectricGeneratorType {
    pub fn from_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcElectricGeneratorType::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.global_id = parameter.into(),
                1usize => {
                    entity.owner_history = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => {
                    entity.applicable_occurrence = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                5usize => {
                    entity.has_property_sets = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                6usize => {
                    entity.representation_maps = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                7usize => {
                    entity.tag = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                8usize => {
                    entity.element_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                9usize => entity.predefined_type = parameter.into(),
                _ => {}
            }
        }
        entity
    }
    pub fn from_own_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcElectricGeneratorType::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.predefined_type = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcElectricMotor: IIfcEnergyConversionDevice {
    fn predefined_type(&self) -> &Option<IfcElectricMotorTypeEnum>;
}
#[derive(Default, Debug)]
pub struct IfcElectricMotor {
    global_id: IfcGloballyUniqueId,
    owner_history: Option<EntityRef>,
    name: Option<IfcLabel>,
    description: Option<IfcText>,
    object_type: Option<IfcLabel>,
    object_placement: Option<EntityRef>,
    representation: Option<EntityRef>,
    tag: Option<IfcIdentifier>,
    predefined_type: Option<IfcElectricMotorTypeEnum>,
}
impl IIfcRoot for IfcElectricMotor {
    fn global_id(&self) -> &IfcGloballyUniqueId {
        &self.global_id
    }
    fn owner_history(&self) -> &Option<EntityRef> {
        &self.owner_history
    }
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
}
impl IIfcObjectDefinition for IfcElectricMotor {}
impl IIfcObject for IfcElectricMotor {
    fn object_type(&self) -> &Option<IfcLabel> {
        &self.object_type
    }
}
impl IIfcProduct for IfcElectricMotor {
    fn object_placement(&self) -> &Option<EntityRef> {
        &self.object_placement
    }
    fn representation(&self) -> &Option<EntityRef> {
        &self.representation
    }
}
impl IIfcElement for IfcElectricMotor {
    fn tag(&self) -> &Option<IfcIdentifier> {
        &self.tag
    }
}
impl IIfcDistributionElement for IfcElectricMotor {}
impl IIfcDistributionFlowElement for IfcElectricMotor {}
impl IIfcEnergyConversionDevice for IfcElectricMotor {}
impl IIfcElectricMotor for IfcElectricMotor {
    fn predefined_type(&self) -> &Option<IfcElectricMotorTypeEnum> {
        &self.predefined_type
    }
}
impl IfcElectricMotor {
    pub fn from_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcElectricMotor::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.global_id = parameter.into(),
                1usize => {
                    entity.owner_history = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => {
                    entity.object_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                5usize => {
                    entity.object_placement = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                6usize => {
                    entity.representation = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                7usize => {
                    entity.tag = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                8usize => {
                    entity.predefined_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
    pub fn from_own_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcElectricMotor::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => {
                    entity.predefined_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcElectricMotorType: IIfcEnergyConversionDeviceType {
    fn predefined_type(&self) -> &IfcElectricMotorTypeEnum;
}
#[derive(Default, Debug)]
pub struct IfcElectricMotorType {
    global_id: IfcGloballyUniqueId,
    owner_history: Option<EntityRef>,
    name: Option<IfcLabel>,
    description: Option<IfcText>,
    applicable_occurrence: Option<IfcIdentifier>,
    has_property_sets: Option<HashSet<EntityRef>>,
    representation_maps: Option<Vec<EntityRef>>,
    tag: Option<IfcLabel>,
    element_type: Option<IfcLabel>,
    predefined_type: IfcElectricMotorTypeEnum,
}
impl IIfcRoot for IfcElectricMotorType {
    fn global_id(&self) -> &IfcGloballyUniqueId {
        &self.global_id
    }
    fn owner_history(&self) -> &Option<EntityRef> {
        &self.owner_history
    }
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
}
impl IIfcObjectDefinition for IfcElectricMotorType {}
impl IIfcTypeObject for IfcElectricMotorType {
    fn applicable_occurrence(&self) -> &Option<IfcIdentifier> {
        &self.applicable_occurrence
    }
    fn has_property_sets(&self) -> &Option<HashSet<EntityRef>> {
        &self.has_property_sets
    }
}
impl IIfcTypeProduct for IfcElectricMotorType {
    fn representation_maps(&self) -> &Option<Vec<EntityRef>> {
        &self.representation_maps
    }
    fn tag(&self) -> &Option<IfcLabel> {
        &self.tag
    }
}
impl IIfcElementType for IfcElectricMotorType {
    fn element_type(&self) -> &Option<IfcLabel> {
        &self.element_type
    }
}
impl IIfcDistributionElementType for IfcElectricMotorType {}
impl IIfcDistributionFlowElementType for IfcElectricMotorType {}
impl IIfcEnergyConversionDeviceType for IfcElectricMotorType {}
impl IIfcElectricMotorType for IfcElectricMotorType {
    fn predefined_type(&self) -> &IfcElectricMotorTypeEnum {
        &self.predefined_type
    }
}
impl IfcElectricMotorType {
    pub fn from_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcElectricMotorType::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.global_id = parameter.into(),
                1usize => {
                    entity.owner_history = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => {
                    entity.applicable_occurrence = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                5usize => {
                    entity.has_property_sets = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                6usize => {
                    entity.representation_maps = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                7usize => {
                    entity.tag = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                8usize => {
                    entity.element_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                9usize => entity.predefined_type = parameter.into(),
                _ => {}
            }
        }
        entity
    }
    pub fn from_own_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcElectricMotorType::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.predefined_type = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcElectricTimeControl: IIfcFlowController {
    fn predefined_type(&self) -> &Option<IfcElectricTimeControlTypeEnum>;
}
#[derive(Default, Debug)]
pub struct IfcElectricTimeControl {
    global_id: IfcGloballyUniqueId,
    owner_history: Option<EntityRef>,
    name: Option<IfcLabel>,
    description: Option<IfcText>,
    object_type: Option<IfcLabel>,
    object_placement: Option<EntityRef>,
    representation: Option<EntityRef>,
    tag: Option<IfcIdentifier>,
    predefined_type: Option<IfcElectricTimeControlTypeEnum>,
}
impl IIfcRoot for IfcElectricTimeControl {
    fn global_id(&self) -> &IfcGloballyUniqueId {
        &self.global_id
    }
    fn owner_history(&self) -> &Option<EntityRef> {
        &self.owner_history
    }
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
}
impl IIfcObjectDefinition for IfcElectricTimeControl {}
impl IIfcObject for IfcElectricTimeControl {
    fn object_type(&self) -> &Option<IfcLabel> {
        &self.object_type
    }
}
impl IIfcProduct for IfcElectricTimeControl {
    fn object_placement(&self) -> &Option<EntityRef> {
        &self.object_placement
    }
    fn representation(&self) -> &Option<EntityRef> {
        &self.representation
    }
}
impl IIfcElement for IfcElectricTimeControl {
    fn tag(&self) -> &Option<IfcIdentifier> {
        &self.tag
    }
}
impl IIfcDistributionElement for IfcElectricTimeControl {}
impl IIfcDistributionFlowElement for IfcElectricTimeControl {}
impl IIfcFlowController for IfcElectricTimeControl {}
impl IIfcElectricTimeControl for IfcElectricTimeControl {
    fn predefined_type(&self) -> &Option<IfcElectricTimeControlTypeEnum> {
        &self.predefined_type
    }
}
impl IfcElectricTimeControl {
    pub fn from_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcElectricTimeControl::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.global_id = parameter.into(),
                1usize => {
                    entity.owner_history = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => {
                    entity.object_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                5usize => {
                    entity.object_placement = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                6usize => {
                    entity.representation = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                7usize => {
                    entity.tag = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                8usize => {
                    entity.predefined_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
    pub fn from_own_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcElectricTimeControl::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => {
                    entity.predefined_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcElectricTimeControlType: IIfcFlowControllerType {
    fn predefined_type(&self) -> &IfcElectricTimeControlTypeEnum;
}
#[derive(Default, Debug)]
pub struct IfcElectricTimeControlType {
    global_id: IfcGloballyUniqueId,
    owner_history: Option<EntityRef>,
    name: Option<IfcLabel>,
    description: Option<IfcText>,
    applicable_occurrence: Option<IfcIdentifier>,
    has_property_sets: Option<HashSet<EntityRef>>,
    representation_maps: Option<Vec<EntityRef>>,
    tag: Option<IfcLabel>,
    element_type: Option<IfcLabel>,
    predefined_type: IfcElectricTimeControlTypeEnum,
}
impl IIfcRoot for IfcElectricTimeControlType {
    fn global_id(&self) -> &IfcGloballyUniqueId {
        &self.global_id
    }
    fn owner_history(&self) -> &Option<EntityRef> {
        &self.owner_history
    }
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
}
impl IIfcObjectDefinition for IfcElectricTimeControlType {}
impl IIfcTypeObject for IfcElectricTimeControlType {
    fn applicable_occurrence(&self) -> &Option<IfcIdentifier> {
        &self.applicable_occurrence
    }
    fn has_property_sets(&self) -> &Option<HashSet<EntityRef>> {
        &self.has_property_sets
    }
}
impl IIfcTypeProduct for IfcElectricTimeControlType {
    fn representation_maps(&self) -> &Option<Vec<EntityRef>> {
        &self.representation_maps
    }
    fn tag(&self) -> &Option<IfcLabel> {
        &self.tag
    }
}
impl IIfcElementType for IfcElectricTimeControlType {
    fn element_type(&self) -> &Option<IfcLabel> {
        &self.element_type
    }
}
impl IIfcDistributionElementType for IfcElectricTimeControlType {}
impl IIfcDistributionFlowElementType for IfcElectricTimeControlType {}
impl IIfcFlowControllerType for IfcElectricTimeControlType {}
impl IIfcElectricTimeControlType for IfcElectricTimeControlType {
    fn predefined_type(&self) -> &IfcElectricTimeControlTypeEnum {
        &self.predefined_type
    }
}
impl IfcElectricTimeControlType {
    pub fn from_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcElectricTimeControlType::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.global_id = parameter.into(),
                1usize => {
                    entity.owner_history = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => {
                    entity.applicable_occurrence = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                5usize => {
                    entity.has_property_sets = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                6usize => {
                    entity.representation_maps = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                7usize => {
                    entity.tag = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                8usize => {
                    entity.element_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                9usize => entity.predefined_type = parameter.into(),
                _ => {}
            }
        }
        entity
    }
    pub fn from_own_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcElectricTimeControlType::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.predefined_type = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcElement: IIfcProduct {
    fn tag(&self) -> &Option<IfcIdentifier>;
}
pub trait IIfcElementAssembly: IIfcElement {
    fn assembly_place(&self) -> &Option<IfcAssemblyPlaceEnum>;
    fn predefined_type(&self) -> &Option<IfcElementAssemblyTypeEnum>;
}
#[derive(Default, Debug)]
pub struct IfcElementAssembly {
    global_id: IfcGloballyUniqueId,
    owner_history: Option<EntityRef>,
    name: Option<IfcLabel>,
    description: Option<IfcText>,
    object_type: Option<IfcLabel>,
    object_placement: Option<EntityRef>,
    representation: Option<EntityRef>,
    tag: Option<IfcIdentifier>,
    assembly_place: Option<IfcAssemblyPlaceEnum>,
    predefined_type: Option<IfcElementAssemblyTypeEnum>,
}
impl IIfcRoot for IfcElementAssembly {
    fn global_id(&self) -> &IfcGloballyUniqueId {
        &self.global_id
    }
    fn owner_history(&self) -> &Option<EntityRef> {
        &self.owner_history
    }
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
}
impl IIfcObjectDefinition for IfcElementAssembly {}
impl IIfcObject for IfcElementAssembly {
    fn object_type(&self) -> &Option<IfcLabel> {
        &self.object_type
    }
}
impl IIfcProduct for IfcElementAssembly {
    fn object_placement(&self) -> &Option<EntityRef> {
        &self.object_placement
    }
    fn representation(&self) -> &Option<EntityRef> {
        &self.representation
    }
}
impl IIfcElement for IfcElementAssembly {
    fn tag(&self) -> &Option<IfcIdentifier> {
        &self.tag
    }
}
impl IIfcElementAssembly for IfcElementAssembly {
    fn assembly_place(&self) -> &Option<IfcAssemblyPlaceEnum> {
        &self.assembly_place
    }
    fn predefined_type(&self) -> &Option<IfcElementAssemblyTypeEnum> {
        &self.predefined_type
    }
}
impl IfcElementAssembly {
    pub fn from_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcElementAssembly::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.global_id = parameter.into(),
                1usize => {
                    entity.owner_history = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => {
                    entity.object_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                5usize => {
                    entity.object_placement = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                6usize => {
                    entity.representation = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                7usize => {
                    entity.tag = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                8usize => {
                    entity.assembly_place = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                9usize => {
                    entity.predefined_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
    pub fn from_own_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcElementAssembly::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => {
                    entity.assembly_place = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                1usize => {
                    entity.predefined_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcElementAssemblyType: IIfcElementType {
    fn predefined_type(&self) -> &IfcElementAssemblyTypeEnum;
}
#[derive(Default, Debug)]
pub struct IfcElementAssemblyType {
    global_id: IfcGloballyUniqueId,
    owner_history: Option<EntityRef>,
    name: Option<IfcLabel>,
    description: Option<IfcText>,
    applicable_occurrence: Option<IfcIdentifier>,
    has_property_sets: Option<HashSet<EntityRef>>,
    representation_maps: Option<Vec<EntityRef>>,
    tag: Option<IfcLabel>,
    element_type: Option<IfcLabel>,
    predefined_type: IfcElementAssemblyTypeEnum,
}
impl IIfcRoot for IfcElementAssemblyType {
    fn global_id(&self) -> &IfcGloballyUniqueId {
        &self.global_id
    }
    fn owner_history(&self) -> &Option<EntityRef> {
        &self.owner_history
    }
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
}
impl IIfcObjectDefinition for IfcElementAssemblyType {}
impl IIfcTypeObject for IfcElementAssemblyType {
    fn applicable_occurrence(&self) -> &Option<IfcIdentifier> {
        &self.applicable_occurrence
    }
    fn has_property_sets(&self) -> &Option<HashSet<EntityRef>> {
        &self.has_property_sets
    }
}
impl IIfcTypeProduct for IfcElementAssemblyType {
    fn representation_maps(&self) -> &Option<Vec<EntityRef>> {
        &self.representation_maps
    }
    fn tag(&self) -> &Option<IfcLabel> {
        &self.tag
    }
}
impl IIfcElementType for IfcElementAssemblyType {
    fn element_type(&self) -> &Option<IfcLabel> {
        &self.element_type
    }
}
impl IIfcElementAssemblyType for IfcElementAssemblyType {
    fn predefined_type(&self) -> &IfcElementAssemblyTypeEnum {
        &self.predefined_type
    }
}
impl IfcElementAssemblyType {
    pub fn from_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcElementAssemblyType::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.global_id = parameter.into(),
                1usize => {
                    entity.owner_history = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => {
                    entity.applicable_occurrence = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                5usize => {
                    entity.has_property_sets = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                6usize => {
                    entity.representation_maps = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                7usize => {
                    entity.tag = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                8usize => {
                    entity.element_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                9usize => entity.predefined_type = parameter.into(),
                _ => {}
            }
        }
        entity
    }
    pub fn from_own_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcElementAssemblyType::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.predefined_type = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcElementComponent: IIfcElement {}
pub trait IIfcElementComponentType: IIfcElementType {}
pub trait IIfcElementQuantity: IIfcQuantitySet {
    fn method_of_measurement(&self) -> &Option<IfcLabel>;
    fn quantities(&self) -> &HashSet<EntityRef>;
}
#[derive(Default, Debug)]
pub struct IfcElementQuantity {
    global_id: IfcGloballyUniqueId,
    owner_history: Option<EntityRef>,
    name: Option<IfcLabel>,
    description: Option<IfcText>,
    method_of_measurement: Option<IfcLabel>,
    quantities: HashSet<EntityRef>,
}
impl IIfcRoot for IfcElementQuantity {
    fn global_id(&self) -> &IfcGloballyUniqueId {
        &self.global_id
    }
    fn owner_history(&self) -> &Option<EntityRef> {
        &self.owner_history
    }
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
}
impl IIfcPropertyDefinition for IfcElementQuantity {}
impl IIfcPropertySetDefinition for IfcElementQuantity {}
impl IIfcQuantitySet for IfcElementQuantity {}
impl IIfcElementQuantity for IfcElementQuantity {
    fn method_of_measurement(&self) -> &Option<IfcLabel> {
        &self.method_of_measurement
    }
    fn quantities(&self) -> &HashSet<EntityRef> {
        &self.quantities
    }
}
impl IfcElementQuantity {
    pub fn from_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcElementQuantity::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.global_id = parameter.into(),
                1usize => {
                    entity.owner_history = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => {
                    entity.method_of_measurement = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                5usize => entity.quantities = parameter.into(),
                _ => {}
            }
        }
        entity
    }
    pub fn from_own_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcElementQuantity::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => {
                    entity.method_of_measurement = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                1usize => entity.quantities = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcElementType: IIfcTypeProduct {
    fn element_type(&self) -> &Option<IfcLabel>;
}
pub trait IIfcElementarySurface: IIfcSurface {
    fn position(&self) -> &EntityRef;
}
pub trait IIfcEllipse: IIfcConic {
    fn semi_axis1(&self) -> &IfcPositiveLengthMeasure;
    fn semi_axis2(&self) -> &IfcPositiveLengthMeasure;
}
#[derive(Default, Debug)]
pub struct IfcEllipse {
    position: EntityRef,
    semi_axis1: IfcPositiveLengthMeasure,
    semi_axis2: IfcPositiveLengthMeasure,
}
impl IIfcRepresentationItem for IfcEllipse {}
impl IIfcGeometricRepresentationItem for IfcEllipse {}
impl IIfcCurve for IfcEllipse {}
impl IIfcConic for IfcEllipse {
    fn position(&self) -> &EntityRef {
        &self.position
    }
}
impl IIfcEllipse for IfcEllipse {
    fn semi_axis1(&self) -> &IfcPositiveLengthMeasure {
        &self.semi_axis1
    }
    fn semi_axis2(&self) -> &IfcPositiveLengthMeasure {
        &self.semi_axis2
    }
}
impl IfcEllipse {
    pub fn from_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcEllipse::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.position = parameter.into(),
                1usize => entity.semi_axis1 = parameter.into(),
                2usize => entity.semi_axis2 = parameter.into(),
                _ => {}
            }
        }
        entity
    }
    pub fn from_own_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcEllipse::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.semi_axis1 = parameter.into(),
                1usize => entity.semi_axis2 = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcEllipseProfileDef: IIfcParameterizedProfileDef {
    fn semi_axis1(&self) -> &IfcPositiveLengthMeasure;
    fn semi_axis2(&self) -> &IfcPositiveLengthMeasure;
}
#[derive(Default, Debug)]
pub struct IfcEllipseProfileDef {
    profile_type: IfcProfileTypeEnum,
    profile_name: Option<IfcLabel>,
    position: Option<EntityRef>,
    semi_axis1: IfcPositiveLengthMeasure,
    semi_axis2: IfcPositiveLengthMeasure,
}
impl IIfcProfileDef for IfcEllipseProfileDef {
    fn profile_type(&self) -> &IfcProfileTypeEnum {
        &self.profile_type
    }
    fn profile_name(&self) -> &Option<IfcLabel> {
        &self.profile_name
    }
}
impl IIfcParameterizedProfileDef for IfcEllipseProfileDef {
    fn position(&self) -> &Option<EntityRef> {
        &self.position
    }
}
impl IIfcEllipseProfileDef for IfcEllipseProfileDef {
    fn semi_axis1(&self) -> &IfcPositiveLengthMeasure {
        &self.semi_axis1
    }
    fn semi_axis2(&self) -> &IfcPositiveLengthMeasure {
        &self.semi_axis2
    }
}
impl IfcEllipseProfileDef {
    pub fn from_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcEllipseProfileDef::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.profile_type = parameter.into(),
                1usize => {
                    entity.profile_name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => {
                    entity.position = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => entity.semi_axis1 = parameter.into(),
                4usize => entity.semi_axis2 = parameter.into(),
                _ => {}
            }
        }
        entity
    }
    pub fn from_own_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcEllipseProfileDef::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.semi_axis1 = parameter.into(),
                1usize => entity.semi_axis2 = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcEnergyConversionDevice: IIfcDistributionFlowElement {}
#[derive(Default, Debug)]
pub struct IfcEnergyConversionDevice {
    global_id: IfcGloballyUniqueId,
    owner_history: Option<EntityRef>,
    name: Option<IfcLabel>,
    description: Option<IfcText>,
    object_type: Option<IfcLabel>,
    object_placement: Option<EntityRef>,
    representation: Option<EntityRef>,
    tag: Option<IfcIdentifier>,
}
impl IIfcRoot for IfcEnergyConversionDevice {
    fn global_id(&self) -> &IfcGloballyUniqueId {
        &self.global_id
    }
    fn owner_history(&self) -> &Option<EntityRef> {
        &self.owner_history
    }
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
}
impl IIfcObjectDefinition for IfcEnergyConversionDevice {}
impl IIfcObject for IfcEnergyConversionDevice {
    fn object_type(&self) -> &Option<IfcLabel> {
        &self.object_type
    }
}
impl IIfcProduct for IfcEnergyConversionDevice {
    fn object_placement(&self) -> &Option<EntityRef> {
        &self.object_placement
    }
    fn representation(&self) -> &Option<EntityRef> {
        &self.representation
    }
}
impl IIfcElement for IfcEnergyConversionDevice {
    fn tag(&self) -> &Option<IfcIdentifier> {
        &self.tag
    }
}
impl IIfcDistributionElement for IfcEnergyConversionDevice {}
impl IIfcDistributionFlowElement for IfcEnergyConversionDevice {}
impl IIfcEnergyConversionDevice for IfcEnergyConversionDevice {}
impl IfcEnergyConversionDevice {
    pub fn from_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcEnergyConversionDevice::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.global_id = parameter.into(),
                1usize => {
                    entity.owner_history = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => {
                    entity.object_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                5usize => {
                    entity.object_placement = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                6usize => {
                    entity.representation = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                7usize => {
                    entity.tag = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcEnergyConversionDeviceType: IIfcDistributionFlowElementType {}
pub trait IIfcEngine: IIfcEnergyConversionDevice {
    fn predefined_type(&self) -> &Option<IfcEngineTypeEnum>;
}
#[derive(Default, Debug)]
pub struct IfcEngine {
    global_id: IfcGloballyUniqueId,
    owner_history: Option<EntityRef>,
    name: Option<IfcLabel>,
    description: Option<IfcText>,
    object_type: Option<IfcLabel>,
    object_placement: Option<EntityRef>,
    representation: Option<EntityRef>,
    tag: Option<IfcIdentifier>,
    predefined_type: Option<IfcEngineTypeEnum>,
}
impl IIfcRoot for IfcEngine {
    fn global_id(&self) -> &IfcGloballyUniqueId {
        &self.global_id
    }
    fn owner_history(&self) -> &Option<EntityRef> {
        &self.owner_history
    }
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
}
impl IIfcObjectDefinition for IfcEngine {}
impl IIfcObject for IfcEngine {
    fn object_type(&self) -> &Option<IfcLabel> {
        &self.object_type
    }
}
impl IIfcProduct for IfcEngine {
    fn object_placement(&self) -> &Option<EntityRef> {
        &self.object_placement
    }
    fn representation(&self) -> &Option<EntityRef> {
        &self.representation
    }
}
impl IIfcElement for IfcEngine {
    fn tag(&self) -> &Option<IfcIdentifier> {
        &self.tag
    }
}
impl IIfcDistributionElement for IfcEngine {}
impl IIfcDistributionFlowElement for IfcEngine {}
impl IIfcEnergyConversionDevice for IfcEngine {}
impl IIfcEngine for IfcEngine {
    fn predefined_type(&self) -> &Option<IfcEngineTypeEnum> {
        &self.predefined_type
    }
}
impl IfcEngine {
    pub fn from_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcEngine::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.global_id = parameter.into(),
                1usize => {
                    entity.owner_history = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => {
                    entity.object_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                5usize => {
                    entity.object_placement = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                6usize => {
                    entity.representation = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                7usize => {
                    entity.tag = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                8usize => {
                    entity.predefined_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
    pub fn from_own_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcEngine::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => {
                    entity.predefined_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcEngineType: IIfcEnergyConversionDeviceType {
    fn predefined_type(&self) -> &IfcEngineTypeEnum;
}
#[derive(Default, Debug)]
pub struct IfcEngineType {
    global_id: IfcGloballyUniqueId,
    owner_history: Option<EntityRef>,
    name: Option<IfcLabel>,
    description: Option<IfcText>,
    applicable_occurrence: Option<IfcIdentifier>,
    has_property_sets: Option<HashSet<EntityRef>>,
    representation_maps: Option<Vec<EntityRef>>,
    tag: Option<IfcLabel>,
    element_type: Option<IfcLabel>,
    predefined_type: IfcEngineTypeEnum,
}
impl IIfcRoot for IfcEngineType {
    fn global_id(&self) -> &IfcGloballyUniqueId {
        &self.global_id
    }
    fn owner_history(&self) -> &Option<EntityRef> {
        &self.owner_history
    }
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
}
impl IIfcObjectDefinition for IfcEngineType {}
impl IIfcTypeObject for IfcEngineType {
    fn applicable_occurrence(&self) -> &Option<IfcIdentifier> {
        &self.applicable_occurrence
    }
    fn has_property_sets(&self) -> &Option<HashSet<EntityRef>> {
        &self.has_property_sets
    }
}
impl IIfcTypeProduct for IfcEngineType {
    fn representation_maps(&self) -> &Option<Vec<EntityRef>> {
        &self.representation_maps
    }
    fn tag(&self) -> &Option<IfcLabel> {
        &self.tag
    }
}
impl IIfcElementType for IfcEngineType {
    fn element_type(&self) -> &Option<IfcLabel> {
        &self.element_type
    }
}
impl IIfcDistributionElementType for IfcEngineType {}
impl IIfcDistributionFlowElementType for IfcEngineType {}
impl IIfcEnergyConversionDeviceType for IfcEngineType {}
impl IIfcEngineType for IfcEngineType {
    fn predefined_type(&self) -> &IfcEngineTypeEnum {
        &self.predefined_type
    }
}
impl IfcEngineType {
    pub fn from_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcEngineType::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.global_id = parameter.into(),
                1usize => {
                    entity.owner_history = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => {
                    entity.applicable_occurrence = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                5usize => {
                    entity.has_property_sets = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                6usize => {
                    entity.representation_maps = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                7usize => {
                    entity.tag = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                8usize => {
                    entity.element_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                9usize => entity.predefined_type = parameter.into(),
                _ => {}
            }
        }
        entity
    }
    pub fn from_own_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcEngineType::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.predefined_type = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcEvaporativeCooler: IIfcEnergyConversionDevice {
    fn predefined_type(&self) -> &Option<IfcEvaporativeCoolerTypeEnum>;
}
#[derive(Default, Debug)]
pub struct IfcEvaporativeCooler {
    global_id: IfcGloballyUniqueId,
    owner_history: Option<EntityRef>,
    name: Option<IfcLabel>,
    description: Option<IfcText>,
    object_type: Option<IfcLabel>,
    object_placement: Option<EntityRef>,
    representation: Option<EntityRef>,
    tag: Option<IfcIdentifier>,
    predefined_type: Option<IfcEvaporativeCoolerTypeEnum>,
}
impl IIfcRoot for IfcEvaporativeCooler {
    fn global_id(&self) -> &IfcGloballyUniqueId {
        &self.global_id
    }
    fn owner_history(&self) -> &Option<EntityRef> {
        &self.owner_history
    }
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
}
impl IIfcObjectDefinition for IfcEvaporativeCooler {}
impl IIfcObject for IfcEvaporativeCooler {
    fn object_type(&self) -> &Option<IfcLabel> {
        &self.object_type
    }
}
impl IIfcProduct for IfcEvaporativeCooler {
    fn object_placement(&self) -> &Option<EntityRef> {
        &self.object_placement
    }
    fn representation(&self) -> &Option<EntityRef> {
        &self.representation
    }
}
impl IIfcElement for IfcEvaporativeCooler {
    fn tag(&self) -> &Option<IfcIdentifier> {
        &self.tag
    }
}
impl IIfcDistributionElement for IfcEvaporativeCooler {}
impl IIfcDistributionFlowElement for IfcEvaporativeCooler {}
impl IIfcEnergyConversionDevice for IfcEvaporativeCooler {}
impl IIfcEvaporativeCooler for IfcEvaporativeCooler {
    fn predefined_type(&self) -> &Option<IfcEvaporativeCoolerTypeEnum> {
        &self.predefined_type
    }
}
impl IfcEvaporativeCooler {
    pub fn from_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcEvaporativeCooler::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.global_id = parameter.into(),
                1usize => {
                    entity.owner_history = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => {
                    entity.object_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                5usize => {
                    entity.object_placement = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                6usize => {
                    entity.representation = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                7usize => {
                    entity.tag = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                8usize => {
                    entity.predefined_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
    pub fn from_own_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcEvaporativeCooler::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => {
                    entity.predefined_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcEvaporativeCoolerType: IIfcEnergyConversionDeviceType {
    fn predefined_type(&self) -> &IfcEvaporativeCoolerTypeEnum;
}
#[derive(Default, Debug)]
pub struct IfcEvaporativeCoolerType {
    global_id: IfcGloballyUniqueId,
    owner_history: Option<EntityRef>,
    name: Option<IfcLabel>,
    description: Option<IfcText>,
    applicable_occurrence: Option<IfcIdentifier>,
    has_property_sets: Option<HashSet<EntityRef>>,
    representation_maps: Option<Vec<EntityRef>>,
    tag: Option<IfcLabel>,
    element_type: Option<IfcLabel>,
    predefined_type: IfcEvaporativeCoolerTypeEnum,
}
impl IIfcRoot for IfcEvaporativeCoolerType {
    fn global_id(&self) -> &IfcGloballyUniqueId {
        &self.global_id
    }
    fn owner_history(&self) -> &Option<EntityRef> {
        &self.owner_history
    }
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
}
impl IIfcObjectDefinition for IfcEvaporativeCoolerType {}
impl IIfcTypeObject for IfcEvaporativeCoolerType {
    fn applicable_occurrence(&self) -> &Option<IfcIdentifier> {
        &self.applicable_occurrence
    }
    fn has_property_sets(&self) -> &Option<HashSet<EntityRef>> {
        &self.has_property_sets
    }
}
impl IIfcTypeProduct for IfcEvaporativeCoolerType {
    fn representation_maps(&self) -> &Option<Vec<EntityRef>> {
        &self.representation_maps
    }
    fn tag(&self) -> &Option<IfcLabel> {
        &self.tag
    }
}
impl IIfcElementType for IfcEvaporativeCoolerType {
    fn element_type(&self) -> &Option<IfcLabel> {
        &self.element_type
    }
}
impl IIfcDistributionElementType for IfcEvaporativeCoolerType {}
impl IIfcDistributionFlowElementType for IfcEvaporativeCoolerType {}
impl IIfcEnergyConversionDeviceType for IfcEvaporativeCoolerType {}
impl IIfcEvaporativeCoolerType for IfcEvaporativeCoolerType {
    fn predefined_type(&self) -> &IfcEvaporativeCoolerTypeEnum {
        &self.predefined_type
    }
}
impl IfcEvaporativeCoolerType {
    pub fn from_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcEvaporativeCoolerType::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.global_id = parameter.into(),
                1usize => {
                    entity.owner_history = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => {
                    entity.applicable_occurrence = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                5usize => {
                    entity.has_property_sets = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                6usize => {
                    entity.representation_maps = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                7usize => {
                    entity.tag = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                8usize => {
                    entity.element_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                9usize => entity.predefined_type = parameter.into(),
                _ => {}
            }
        }
        entity
    }
    pub fn from_own_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcEvaporativeCoolerType::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.predefined_type = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcEvaporator: IIfcEnergyConversionDevice {
    fn predefined_type(&self) -> &Option<IfcEvaporatorTypeEnum>;
}
#[derive(Default, Debug)]
pub struct IfcEvaporator {
    global_id: IfcGloballyUniqueId,
    owner_history: Option<EntityRef>,
    name: Option<IfcLabel>,
    description: Option<IfcText>,
    object_type: Option<IfcLabel>,
    object_placement: Option<EntityRef>,
    representation: Option<EntityRef>,
    tag: Option<IfcIdentifier>,
    predefined_type: Option<IfcEvaporatorTypeEnum>,
}
impl IIfcRoot for IfcEvaporator {
    fn global_id(&self) -> &IfcGloballyUniqueId {
        &self.global_id
    }
    fn owner_history(&self) -> &Option<EntityRef> {
        &self.owner_history
    }
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
}
impl IIfcObjectDefinition for IfcEvaporator {}
impl IIfcObject for IfcEvaporator {
    fn object_type(&self) -> &Option<IfcLabel> {
        &self.object_type
    }
}
impl IIfcProduct for IfcEvaporator {
    fn object_placement(&self) -> &Option<EntityRef> {
        &self.object_placement
    }
    fn representation(&self) -> &Option<EntityRef> {
        &self.representation
    }
}
impl IIfcElement for IfcEvaporator {
    fn tag(&self) -> &Option<IfcIdentifier> {
        &self.tag
    }
}
impl IIfcDistributionElement for IfcEvaporator {}
impl IIfcDistributionFlowElement for IfcEvaporator {}
impl IIfcEnergyConversionDevice for IfcEvaporator {}
impl IIfcEvaporator for IfcEvaporator {
    fn predefined_type(&self) -> &Option<IfcEvaporatorTypeEnum> {
        &self.predefined_type
    }
}
impl IfcEvaporator {
    pub fn from_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcEvaporator::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.global_id = parameter.into(),
                1usize => {
                    entity.owner_history = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => {
                    entity.object_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                5usize => {
                    entity.object_placement = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                6usize => {
                    entity.representation = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                7usize => {
                    entity.tag = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                8usize => {
                    entity.predefined_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
    pub fn from_own_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcEvaporator::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => {
                    entity.predefined_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcEvaporatorType: IIfcEnergyConversionDeviceType {
    fn predefined_type(&self) -> &IfcEvaporatorTypeEnum;
}
#[derive(Default, Debug)]
pub struct IfcEvaporatorType {
    global_id: IfcGloballyUniqueId,
    owner_history: Option<EntityRef>,
    name: Option<IfcLabel>,
    description: Option<IfcText>,
    applicable_occurrence: Option<IfcIdentifier>,
    has_property_sets: Option<HashSet<EntityRef>>,
    representation_maps: Option<Vec<EntityRef>>,
    tag: Option<IfcLabel>,
    element_type: Option<IfcLabel>,
    predefined_type: IfcEvaporatorTypeEnum,
}
impl IIfcRoot for IfcEvaporatorType {
    fn global_id(&self) -> &IfcGloballyUniqueId {
        &self.global_id
    }
    fn owner_history(&self) -> &Option<EntityRef> {
        &self.owner_history
    }
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
}
impl IIfcObjectDefinition for IfcEvaporatorType {}
impl IIfcTypeObject for IfcEvaporatorType {
    fn applicable_occurrence(&self) -> &Option<IfcIdentifier> {
        &self.applicable_occurrence
    }
    fn has_property_sets(&self) -> &Option<HashSet<EntityRef>> {
        &self.has_property_sets
    }
}
impl IIfcTypeProduct for IfcEvaporatorType {
    fn representation_maps(&self) -> &Option<Vec<EntityRef>> {
        &self.representation_maps
    }
    fn tag(&self) -> &Option<IfcLabel> {
        &self.tag
    }
}
impl IIfcElementType for IfcEvaporatorType {
    fn element_type(&self) -> &Option<IfcLabel> {
        &self.element_type
    }
}
impl IIfcDistributionElementType for IfcEvaporatorType {}
impl IIfcDistributionFlowElementType for IfcEvaporatorType {}
impl IIfcEnergyConversionDeviceType for IfcEvaporatorType {}
impl IIfcEvaporatorType for IfcEvaporatorType {
    fn predefined_type(&self) -> &IfcEvaporatorTypeEnum {
        &self.predefined_type
    }
}
impl IfcEvaporatorType {
    pub fn from_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcEvaporatorType::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.global_id = parameter.into(),
                1usize => {
                    entity.owner_history = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => {
                    entity.applicable_occurrence = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                5usize => {
                    entity.has_property_sets = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                6usize => {
                    entity.representation_maps = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                7usize => {
                    entity.tag = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                8usize => {
                    entity.element_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                9usize => entity.predefined_type = parameter.into(),
                _ => {}
            }
        }
        entity
    }
    pub fn from_own_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcEvaporatorType::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.predefined_type = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcEvent: IIfcProcess {
    fn predefined_type(&self) -> &Option<IfcEventTypeEnum>;
    fn event_trigger_type(&self) -> &Option<IfcEventTriggerTypeEnum>;
    fn user_defined_event_trigger_type(&self) -> &Option<IfcLabel>;
    fn event_occurence_time(&self) -> &Option<EntityRef>;
}
#[derive(Default, Debug)]
pub struct IfcEvent {
    global_id: IfcGloballyUniqueId,
    owner_history: Option<EntityRef>,
    name: Option<IfcLabel>,
    description: Option<IfcText>,
    object_type: Option<IfcLabel>,
    identification: Option<IfcIdentifier>,
    long_description: Option<IfcText>,
    predefined_type: Option<IfcEventTypeEnum>,
    event_trigger_type: Option<IfcEventTriggerTypeEnum>,
    user_defined_event_trigger_type: Option<IfcLabel>,
    event_occurence_time: Option<EntityRef>,
}
impl IIfcRoot for IfcEvent {
    fn global_id(&self) -> &IfcGloballyUniqueId {
        &self.global_id
    }
    fn owner_history(&self) -> &Option<EntityRef> {
        &self.owner_history
    }
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
}
impl IIfcObjectDefinition for IfcEvent {}
impl IIfcObject for IfcEvent {
    fn object_type(&self) -> &Option<IfcLabel> {
        &self.object_type
    }
}
impl IIfcProcess for IfcEvent {
    fn identification(&self) -> &Option<IfcIdentifier> {
        &self.identification
    }
    fn long_description(&self) -> &Option<IfcText> {
        &self.long_description
    }
}
impl IIfcEvent for IfcEvent {
    fn predefined_type(&self) -> &Option<IfcEventTypeEnum> {
        &self.predefined_type
    }
    fn event_trigger_type(&self) -> &Option<IfcEventTriggerTypeEnum> {
        &self.event_trigger_type
    }
    fn user_defined_event_trigger_type(&self) -> &Option<IfcLabel> {
        &self.user_defined_event_trigger_type
    }
    fn event_occurence_time(&self) -> &Option<EntityRef> {
        &self.event_occurence_time
    }
}
impl IfcEvent {
    pub fn from_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcEvent::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.global_id = parameter.into(),
                1usize => {
                    entity.owner_history = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => {
                    entity.object_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                5usize => {
                    entity.identification = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                6usize => {
                    entity.long_description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                7usize => {
                    entity.predefined_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                8usize => {
                    entity.event_trigger_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                9usize => {
                    entity.user_defined_event_trigger_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                10usize => {
                    entity.event_occurence_time = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
    pub fn from_own_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcEvent::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => {
                    entity.predefined_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                1usize => {
                    entity.event_trigger_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => {
                    entity.user_defined_event_trigger_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.event_occurence_time = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcEventTime: IIfcSchedulingTime {
    fn actual_date(&self) -> &Option<IfcDateTime>;
    fn early_date(&self) -> &Option<IfcDateTime>;
    fn late_date(&self) -> &Option<IfcDateTime>;
    fn schedule_date(&self) -> &Option<IfcDateTime>;
}
#[derive(Default, Debug)]
pub struct IfcEventTime {
    name: Option<IfcLabel>,
    data_origin: Option<IfcDataOriginEnum>,
    user_defined_data_origin: Option<IfcLabel>,
    actual_date: Option<IfcDateTime>,
    early_date: Option<IfcDateTime>,
    late_date: Option<IfcDateTime>,
    schedule_date: Option<IfcDateTime>,
}
impl IIfcSchedulingTime for IfcEventTime {
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
    fn data_origin(&self) -> &Option<IfcDataOriginEnum> {
        &self.data_origin
    }
    fn user_defined_data_origin(&self) -> &Option<IfcLabel> {
        &self.user_defined_data_origin
    }
}
impl IIfcEventTime for IfcEventTime {
    fn actual_date(&self) -> &Option<IfcDateTime> {
        &self.actual_date
    }
    fn early_date(&self) -> &Option<IfcDateTime> {
        &self.early_date
    }
    fn late_date(&self) -> &Option<IfcDateTime> {
        &self.late_date
    }
    fn schedule_date(&self) -> &Option<IfcDateTime> {
        &self.schedule_date
    }
}
impl IfcEventTime {
    pub fn from_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcEventTime::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                1usize => {
                    entity.data_origin = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => {
                    entity.user_defined_data_origin = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.actual_date = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => {
                    entity.early_date = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                5usize => {
                    entity.late_date = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                6usize => {
                    entity.schedule_date = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
    pub fn from_own_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcEventTime::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => {
                    entity.actual_date = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                1usize => {
                    entity.early_date = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => {
                    entity.late_date = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.schedule_date = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcEventType: IIfcTypeProcess {
    fn predefined_type(&self) -> &IfcEventTypeEnum;
    fn event_trigger_type(&self) -> &IfcEventTriggerTypeEnum;
    fn user_defined_event_trigger_type(&self) -> &Option<IfcLabel>;
}
#[derive(Default, Debug)]
pub struct IfcEventType {
    global_id: IfcGloballyUniqueId,
    owner_history: Option<EntityRef>,
    name: Option<IfcLabel>,
    description: Option<IfcText>,
    applicable_occurrence: Option<IfcIdentifier>,
    has_property_sets: Option<HashSet<EntityRef>>,
    identification: Option<IfcIdentifier>,
    long_description: Option<IfcText>,
    process_type: Option<IfcLabel>,
    predefined_type: IfcEventTypeEnum,
    event_trigger_type: IfcEventTriggerTypeEnum,
    user_defined_event_trigger_type: Option<IfcLabel>,
}
impl IIfcRoot for IfcEventType {
    fn global_id(&self) -> &IfcGloballyUniqueId {
        &self.global_id
    }
    fn owner_history(&self) -> &Option<EntityRef> {
        &self.owner_history
    }
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
}
impl IIfcObjectDefinition for IfcEventType {}
impl IIfcTypeObject for IfcEventType {
    fn applicable_occurrence(&self) -> &Option<IfcIdentifier> {
        &self.applicable_occurrence
    }
    fn has_property_sets(&self) -> &Option<HashSet<EntityRef>> {
        &self.has_property_sets
    }
}
impl IIfcTypeProcess for IfcEventType {
    fn identification(&self) -> &Option<IfcIdentifier> {
        &self.identification
    }
    fn long_description(&self) -> &Option<IfcText> {
        &self.long_description
    }
    fn process_type(&self) -> &Option<IfcLabel> {
        &self.process_type
    }
}
impl IIfcEventType for IfcEventType {
    fn predefined_type(&self) -> &IfcEventTypeEnum {
        &self.predefined_type
    }
    fn event_trigger_type(&self) -> &IfcEventTriggerTypeEnum {
        &self.event_trigger_type
    }
    fn user_defined_event_trigger_type(&self) -> &Option<IfcLabel> {
        &self.user_defined_event_trigger_type
    }
}
impl IfcEventType {
    pub fn from_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcEventType::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.global_id = parameter.into(),
                1usize => {
                    entity.owner_history = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => {
                    entity.applicable_occurrence = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                5usize => {
                    entity.has_property_sets = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                6usize => {
                    entity.identification = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                7usize => {
                    entity.long_description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                8usize => {
                    entity.process_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                9usize => entity.predefined_type = parameter.into(),
                10usize => entity.event_trigger_type = parameter.into(),
                11usize => {
                    entity.user_defined_event_trigger_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
    pub fn from_own_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcEventType::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.predefined_type = parameter.into(),
                1usize => entity.event_trigger_type = parameter.into(),
                2usize => {
                    entity.user_defined_event_trigger_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcExtendedProperties: IIfcPropertyAbstraction {
    fn name(&self) -> &Option<IfcIdentifier>;
    fn description(&self) -> &Option<IfcText>;
    fn properties(&self) -> &HashSet<EntityRef>;
}
pub trait IIfcExternalInformation {}
pub trait IIfcExternalReference {
    fn location(&self) -> &Option<IfcUriReference>;
    fn identification(&self) -> &Option<IfcIdentifier>;
    fn name(&self) -> &Option<IfcLabel>;
}
pub trait IIfcExternalReferenceRelationship: IIfcResourceLevelRelationship {
    fn relating_reference(&self) -> &EntityRef;
    fn related_resource_objects(&self) -> &HashSet<EntityRef>;
}
#[derive(Default, Debug)]
pub struct IfcExternalReferenceRelationship {
    name: Option<IfcLabel>,
    description: Option<IfcText>,
    relating_reference: EntityRef,
    related_resource_objects: HashSet<EntityRef>,
}
impl IIfcResourceLevelRelationship for IfcExternalReferenceRelationship {
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
}
impl IIfcExternalReferenceRelationship for IfcExternalReferenceRelationship {
    fn relating_reference(&self) -> &EntityRef {
        &self.relating_reference
    }
    fn related_resource_objects(&self) -> &HashSet<EntityRef> {
        &self.related_resource_objects
    }
}
impl IfcExternalReferenceRelationship {
    pub fn from_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcExternalReferenceRelationship::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                1usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => entity.relating_reference = parameter.into(),
                3usize => entity.related_resource_objects = parameter.into(),
                _ => {}
            }
        }
        entity
    }
    pub fn from_own_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcExternalReferenceRelationship::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.relating_reference = parameter.into(),
                1usize => entity.related_resource_objects = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcExternalSpatialElement: IIfcExternalSpatialStructureElement {
    fn predefined_type(&self) -> &Option<IfcExternalSpatialElementTypeEnum>;
}
#[derive(Default, Debug)]
pub struct IfcExternalSpatialElement {
    global_id: IfcGloballyUniqueId,
    owner_history: Option<EntityRef>,
    name: Option<IfcLabel>,
    description: Option<IfcText>,
    object_type: Option<IfcLabel>,
    object_placement: Option<EntityRef>,
    representation: Option<EntityRef>,
    long_name: Option<IfcLabel>,
    predefined_type: Option<IfcExternalSpatialElementTypeEnum>,
}
impl IIfcRoot for IfcExternalSpatialElement {
    fn global_id(&self) -> &IfcGloballyUniqueId {
        &self.global_id
    }
    fn owner_history(&self) -> &Option<EntityRef> {
        &self.owner_history
    }
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
}
impl IIfcObjectDefinition for IfcExternalSpatialElement {}
impl IIfcObject for IfcExternalSpatialElement {
    fn object_type(&self) -> &Option<IfcLabel> {
        &self.object_type
    }
}
impl IIfcProduct for IfcExternalSpatialElement {
    fn object_placement(&self) -> &Option<EntityRef> {
        &self.object_placement
    }
    fn representation(&self) -> &Option<EntityRef> {
        &self.representation
    }
}
impl IIfcSpatialElement for IfcExternalSpatialElement {
    fn long_name(&self) -> &Option<IfcLabel> {
        &self.long_name
    }
}
impl IIfcExternalSpatialStructureElement for IfcExternalSpatialElement {}
impl IIfcExternalSpatialElement for IfcExternalSpatialElement {
    fn predefined_type(&self) -> &Option<IfcExternalSpatialElementTypeEnum> {
        &self.predefined_type
    }
}
impl IfcExternalSpatialElement {
    pub fn from_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcExternalSpatialElement::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.global_id = parameter.into(),
                1usize => {
                    entity.owner_history = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => {
                    entity.object_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                5usize => {
                    entity.object_placement = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                6usize => {
                    entity.representation = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                7usize => {
                    entity.long_name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                8usize => {
                    entity.predefined_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
    pub fn from_own_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcExternalSpatialElement::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => {
                    entity.predefined_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcExternalSpatialStructureElement: IIfcSpatialElement {}
pub trait IIfcExternallyDefinedHatchStyle: IIfcExternalReference {}
#[derive(Default, Debug)]
pub struct IfcExternallyDefinedHatchStyle {
    location: Option<IfcUriReference>,
    identification: Option<IfcIdentifier>,
    name: Option<IfcLabel>,
}
impl IIfcExternalReference for IfcExternallyDefinedHatchStyle {
    fn location(&self) -> &Option<IfcUriReference> {
        &self.location
    }
    fn identification(&self) -> &Option<IfcIdentifier> {
        &self.identification
    }
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
}
impl IIfcExternallyDefinedHatchStyle for IfcExternallyDefinedHatchStyle {}
impl IfcExternallyDefinedHatchStyle {
    pub fn from_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcExternallyDefinedHatchStyle::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => {
                    entity.location = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                1usize => {
                    entity.identification = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcExternallyDefinedSurfaceStyle: IIfcExternalReference {}
#[derive(Default, Debug)]
pub struct IfcExternallyDefinedSurfaceStyle {
    location: Option<IfcUriReference>,
    identification: Option<IfcIdentifier>,
    name: Option<IfcLabel>,
}
impl IIfcExternalReference for IfcExternallyDefinedSurfaceStyle {
    fn location(&self) -> &Option<IfcUriReference> {
        &self.location
    }
    fn identification(&self) -> &Option<IfcIdentifier> {
        &self.identification
    }
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
}
impl IIfcExternallyDefinedSurfaceStyle for IfcExternallyDefinedSurfaceStyle {}
impl IfcExternallyDefinedSurfaceStyle {
    pub fn from_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcExternallyDefinedSurfaceStyle::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => {
                    entity.location = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                1usize => {
                    entity.identification = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcExternallyDefinedTextFont: IIfcExternalReference {}
#[derive(Default, Debug)]
pub struct IfcExternallyDefinedTextFont {
    location: Option<IfcUriReference>,
    identification: Option<IfcIdentifier>,
    name: Option<IfcLabel>,
}
impl IIfcExternalReference for IfcExternallyDefinedTextFont {
    fn location(&self) -> &Option<IfcUriReference> {
        &self.location
    }
    fn identification(&self) -> &Option<IfcIdentifier> {
        &self.identification
    }
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
}
impl IIfcExternallyDefinedTextFont for IfcExternallyDefinedTextFont {}
impl IfcExternallyDefinedTextFont {
    pub fn from_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcExternallyDefinedTextFont::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => {
                    entity.location = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                1usize => {
                    entity.identification = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcExtrudedAreaSolid: IIfcSweptAreaSolid {
    fn extruded_direction(&self) -> &EntityRef;
    fn depth(&self) -> &IfcPositiveLengthMeasure;
}
#[derive(Default, Debug)]
pub struct IfcExtrudedAreaSolid {
    swept_area: EntityRef,
    position: Option<EntityRef>,
    extruded_direction: EntityRef,
    depth: IfcPositiveLengthMeasure,
}
impl IIfcRepresentationItem for IfcExtrudedAreaSolid {}
impl IIfcGeometricRepresentationItem for IfcExtrudedAreaSolid {}
impl IIfcSolidModel for IfcExtrudedAreaSolid {}
impl IIfcSweptAreaSolid for IfcExtrudedAreaSolid {
    fn swept_area(&self) -> &EntityRef {
        &self.swept_area
    }
    fn position(&self) -> &Option<EntityRef> {
        &self.position
    }
}
impl IIfcExtrudedAreaSolid for IfcExtrudedAreaSolid {
    fn extruded_direction(&self) -> &EntityRef {
        &self.extruded_direction
    }
    fn depth(&self) -> &IfcPositiveLengthMeasure {
        &self.depth
    }
}
impl IfcExtrudedAreaSolid {
    pub fn from_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcExtrudedAreaSolid::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.swept_area = parameter.into(),
                1usize => {
                    entity.position = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => entity.extruded_direction = parameter.into(),
                3usize => entity.depth = parameter.into(),
                _ => {}
            }
        }
        entity
    }
    pub fn from_own_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcExtrudedAreaSolid::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.extruded_direction = parameter.into(),
                1usize => entity.depth = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcExtrudedAreaSolidTapered: IIfcExtrudedAreaSolid {
    fn end_swept_area(&self) -> &EntityRef;
}
#[derive(Default, Debug)]
pub struct IfcExtrudedAreaSolidTapered {
    swept_area: EntityRef,
    position: Option<EntityRef>,
    extruded_direction: EntityRef,
    depth: IfcPositiveLengthMeasure,
    end_swept_area: EntityRef,
}
impl IIfcRepresentationItem for IfcExtrudedAreaSolidTapered {}
impl IIfcGeometricRepresentationItem for IfcExtrudedAreaSolidTapered {}
impl IIfcSolidModel for IfcExtrudedAreaSolidTapered {}
impl IIfcSweptAreaSolid for IfcExtrudedAreaSolidTapered {
    fn swept_area(&self) -> &EntityRef {
        &self.swept_area
    }
    fn position(&self) -> &Option<EntityRef> {
        &self.position
    }
}
impl IIfcExtrudedAreaSolid for IfcExtrudedAreaSolidTapered {
    fn extruded_direction(&self) -> &EntityRef {
        &self.extruded_direction
    }
    fn depth(&self) -> &IfcPositiveLengthMeasure {
        &self.depth
    }
}
impl IIfcExtrudedAreaSolidTapered for IfcExtrudedAreaSolidTapered {
    fn end_swept_area(&self) -> &EntityRef {
        &self.end_swept_area
    }
}
impl IfcExtrudedAreaSolidTapered {
    pub fn from_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcExtrudedAreaSolidTapered::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.swept_area = parameter.into(),
                1usize => {
                    entity.position = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => entity.extruded_direction = parameter.into(),
                3usize => entity.depth = parameter.into(),
                4usize => entity.end_swept_area = parameter.into(),
                _ => {}
            }
        }
        entity
    }
    pub fn from_own_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcExtrudedAreaSolidTapered::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.end_swept_area = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcFace: IIfcTopologicalRepresentationItem {
    fn bounds(&self) -> &HashSet<EntityRef>;
}
#[derive(Default, Debug)]
pub struct IfcFace {
    bounds: HashSet<EntityRef>,
}
impl IIfcRepresentationItem for IfcFace {}
impl IIfcTopologicalRepresentationItem for IfcFace {}
impl IIfcFace for IfcFace {
    fn bounds(&self) -> &HashSet<EntityRef> {
        &self.bounds
    }
}
impl IfcFace {
    pub fn from_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcFace::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.bounds = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcFaceBasedSurfaceModel: IIfcGeometricRepresentationItem {
    fn fbsm_faces(&self) -> &HashSet<EntityRef>;
}
#[derive(Default, Debug)]
pub struct IfcFaceBasedSurfaceModel {
    fbsm_faces: HashSet<EntityRef>,
}
impl IIfcRepresentationItem for IfcFaceBasedSurfaceModel {}
impl IIfcGeometricRepresentationItem for IfcFaceBasedSurfaceModel {}
impl IIfcFaceBasedSurfaceModel for IfcFaceBasedSurfaceModel {
    fn fbsm_faces(&self) -> &HashSet<EntityRef> {
        &self.fbsm_faces
    }
}
impl IfcFaceBasedSurfaceModel {
    pub fn from_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcFaceBasedSurfaceModel::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.fbsm_faces = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcFaceBound: IIfcTopologicalRepresentationItem {
    fn bound(&self) -> &EntityRef;
    fn orientation(&self) -> &IfcBoolean;
}
#[derive(Default, Debug)]
pub struct IfcFaceBound {
    bound: EntityRef,
    orientation: IfcBoolean,
}
impl IIfcRepresentationItem for IfcFaceBound {}
impl IIfcTopologicalRepresentationItem for IfcFaceBound {}
impl IIfcFaceBound for IfcFaceBound {
    fn bound(&self) -> &EntityRef {
        &self.bound
    }
    fn orientation(&self) -> &IfcBoolean {
        &self.orientation
    }
}
impl IfcFaceBound {
    pub fn from_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcFaceBound::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.bound = parameter.into(),
                1usize => entity.orientation = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcFaceOuterBound: IIfcFaceBound {}
#[derive(Default, Debug)]
pub struct IfcFaceOuterBound {
    bound: EntityRef,
    orientation: IfcBoolean,
}
impl IIfcRepresentationItem for IfcFaceOuterBound {}
impl IIfcTopologicalRepresentationItem for IfcFaceOuterBound {}
impl IIfcFaceBound for IfcFaceOuterBound {
    fn bound(&self) -> &EntityRef {
        &self.bound
    }
    fn orientation(&self) -> &IfcBoolean {
        &self.orientation
    }
}
impl IIfcFaceOuterBound for IfcFaceOuterBound {}
impl IfcFaceOuterBound {
    pub fn from_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcFaceOuterBound::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.bound = parameter.into(),
                1usize => entity.orientation = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcFaceSurface: IIfcFace {
    fn face_surface(&self) -> &EntityRef;
    fn same_sense(&self) -> &IfcBoolean;
}
#[derive(Default, Debug)]
pub struct IfcFaceSurface {
    bounds: HashSet<EntityRef>,
    face_surface: EntityRef,
    same_sense: IfcBoolean,
}
impl IIfcRepresentationItem for IfcFaceSurface {}
impl IIfcTopologicalRepresentationItem for IfcFaceSurface {}
impl IIfcFace for IfcFaceSurface {
    fn bounds(&self) -> &HashSet<EntityRef> {
        &self.bounds
    }
}
impl IIfcFaceSurface for IfcFaceSurface {
    fn face_surface(&self) -> &EntityRef {
        &self.face_surface
    }
    fn same_sense(&self) -> &IfcBoolean {
        &self.same_sense
    }
}
impl IfcFaceSurface {
    pub fn from_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcFaceSurface::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.bounds = parameter.into(),
                1usize => entity.face_surface = parameter.into(),
                2usize => entity.same_sense = parameter.into(),
                _ => {}
            }
        }
        entity
    }
    pub fn from_own_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcFaceSurface::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.face_surface = parameter.into(),
                1usize => entity.same_sense = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcFacetedBrep: IIfcManifoldSolidBrep {}
#[derive(Default, Debug)]
pub struct IfcFacetedBrep {
    outer: EntityRef,
}
impl IIfcRepresentationItem for IfcFacetedBrep {}
impl IIfcGeometricRepresentationItem for IfcFacetedBrep {}
impl IIfcSolidModel for IfcFacetedBrep {}
impl IIfcManifoldSolidBrep for IfcFacetedBrep {
    fn outer(&self) -> &EntityRef {
        &self.outer
    }
}
impl IIfcFacetedBrep for IfcFacetedBrep {}
impl IfcFacetedBrep {
    pub fn from_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcFacetedBrep::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.outer = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcFacetedBrepWithVoids: IIfcFacetedBrep {
    fn voids(&self) -> &HashSet<EntityRef>;
}
#[derive(Default, Debug)]
pub struct IfcFacetedBrepWithVoids {
    outer: EntityRef,
    voids: HashSet<EntityRef>,
}
impl IIfcRepresentationItem for IfcFacetedBrepWithVoids {}
impl IIfcGeometricRepresentationItem for IfcFacetedBrepWithVoids {}
impl IIfcSolidModel for IfcFacetedBrepWithVoids {}
impl IIfcManifoldSolidBrep for IfcFacetedBrepWithVoids {
    fn outer(&self) -> &EntityRef {
        &self.outer
    }
}
impl IIfcFacetedBrep for IfcFacetedBrepWithVoids {}
impl IIfcFacetedBrepWithVoids for IfcFacetedBrepWithVoids {
    fn voids(&self) -> &HashSet<EntityRef> {
        &self.voids
    }
}
impl IfcFacetedBrepWithVoids {
    pub fn from_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcFacetedBrepWithVoids::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.outer = parameter.into(),
                1usize => entity.voids = parameter.into(),
                _ => {}
            }
        }
        entity
    }
    pub fn from_own_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcFacetedBrepWithVoids::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.voids = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcFailureConnectionCondition: IIfcStructuralConnectionCondition {
    fn tension_failure_x(&self) -> &Option<IfcForceMeasure>;
    fn tension_failure_y(&self) -> &Option<IfcForceMeasure>;
    fn tension_failure_z(&self) -> &Option<IfcForceMeasure>;
    fn compression_failure_x(&self) -> &Option<IfcForceMeasure>;
    fn compression_failure_y(&self) -> &Option<IfcForceMeasure>;
    fn compression_failure_z(&self) -> &Option<IfcForceMeasure>;
}
#[derive(Default, Debug)]
pub struct IfcFailureConnectionCondition {
    name: Option<IfcLabel>,
    tension_failure_x: Option<IfcForceMeasure>,
    tension_failure_y: Option<IfcForceMeasure>,
    tension_failure_z: Option<IfcForceMeasure>,
    compression_failure_x: Option<IfcForceMeasure>,
    compression_failure_y: Option<IfcForceMeasure>,
    compression_failure_z: Option<IfcForceMeasure>,
}
impl IIfcStructuralConnectionCondition for IfcFailureConnectionCondition {
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
}
impl IIfcFailureConnectionCondition for IfcFailureConnectionCondition {
    fn tension_failure_x(&self) -> &Option<IfcForceMeasure> {
        &self.tension_failure_x
    }
    fn tension_failure_y(&self) -> &Option<IfcForceMeasure> {
        &self.tension_failure_y
    }
    fn tension_failure_z(&self) -> &Option<IfcForceMeasure> {
        &self.tension_failure_z
    }
    fn compression_failure_x(&self) -> &Option<IfcForceMeasure> {
        &self.compression_failure_x
    }
    fn compression_failure_y(&self) -> &Option<IfcForceMeasure> {
        &self.compression_failure_y
    }
    fn compression_failure_z(&self) -> &Option<IfcForceMeasure> {
        &self.compression_failure_z
    }
}
impl IfcFailureConnectionCondition {
    pub fn from_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcFailureConnectionCondition::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                1usize => {
                    entity.tension_failure_x = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => {
                    entity.tension_failure_y = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.tension_failure_z = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => {
                    entity.compression_failure_x = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                5usize => {
                    entity.compression_failure_y = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                6usize => {
                    entity.compression_failure_z = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
    pub fn from_own_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcFailureConnectionCondition::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => {
                    entity.tension_failure_x = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                1usize => {
                    entity.tension_failure_y = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => {
                    entity.tension_failure_z = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.compression_failure_x = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => {
                    entity.compression_failure_y = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                5usize => {
                    entity.compression_failure_z = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcFan: IIfcFlowMovingDevice {
    fn predefined_type(&self) -> &Option<IfcFanTypeEnum>;
}
#[derive(Default, Debug)]
pub struct IfcFan {
    global_id: IfcGloballyUniqueId,
    owner_history: Option<EntityRef>,
    name: Option<IfcLabel>,
    description: Option<IfcText>,
    object_type: Option<IfcLabel>,
    object_placement: Option<EntityRef>,
    representation: Option<EntityRef>,
    tag: Option<IfcIdentifier>,
    predefined_type: Option<IfcFanTypeEnum>,
}
impl IIfcRoot for IfcFan {
    fn global_id(&self) -> &IfcGloballyUniqueId {
        &self.global_id
    }
    fn owner_history(&self) -> &Option<EntityRef> {
        &self.owner_history
    }
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
}
impl IIfcObjectDefinition for IfcFan {}
impl IIfcObject for IfcFan {
    fn object_type(&self) -> &Option<IfcLabel> {
        &self.object_type
    }
}
impl IIfcProduct for IfcFan {
    fn object_placement(&self) -> &Option<EntityRef> {
        &self.object_placement
    }
    fn representation(&self) -> &Option<EntityRef> {
        &self.representation
    }
}
impl IIfcElement for IfcFan {
    fn tag(&self) -> &Option<IfcIdentifier> {
        &self.tag
    }
}
impl IIfcDistributionElement for IfcFan {}
impl IIfcDistributionFlowElement for IfcFan {}
impl IIfcFlowMovingDevice for IfcFan {}
impl IIfcFan for IfcFan {
    fn predefined_type(&self) -> &Option<IfcFanTypeEnum> {
        &self.predefined_type
    }
}
impl IfcFan {
    pub fn from_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcFan::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.global_id = parameter.into(),
                1usize => {
                    entity.owner_history = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => {
                    entity.object_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                5usize => {
                    entity.object_placement = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                6usize => {
                    entity.representation = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                7usize => {
                    entity.tag = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                8usize => {
                    entity.predefined_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
    pub fn from_own_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcFan::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => {
                    entity.predefined_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcFanType: IIfcFlowMovingDeviceType {
    fn predefined_type(&self) -> &IfcFanTypeEnum;
}
#[derive(Default, Debug)]
pub struct IfcFanType {
    global_id: IfcGloballyUniqueId,
    owner_history: Option<EntityRef>,
    name: Option<IfcLabel>,
    description: Option<IfcText>,
    applicable_occurrence: Option<IfcIdentifier>,
    has_property_sets: Option<HashSet<EntityRef>>,
    representation_maps: Option<Vec<EntityRef>>,
    tag: Option<IfcLabel>,
    element_type: Option<IfcLabel>,
    predefined_type: IfcFanTypeEnum,
}
impl IIfcRoot for IfcFanType {
    fn global_id(&self) -> &IfcGloballyUniqueId {
        &self.global_id
    }
    fn owner_history(&self) -> &Option<EntityRef> {
        &self.owner_history
    }
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
}
impl IIfcObjectDefinition for IfcFanType {}
impl IIfcTypeObject for IfcFanType {
    fn applicable_occurrence(&self) -> &Option<IfcIdentifier> {
        &self.applicable_occurrence
    }
    fn has_property_sets(&self) -> &Option<HashSet<EntityRef>> {
        &self.has_property_sets
    }
}
impl IIfcTypeProduct for IfcFanType {
    fn representation_maps(&self) -> &Option<Vec<EntityRef>> {
        &self.representation_maps
    }
    fn tag(&self) -> &Option<IfcLabel> {
        &self.tag
    }
}
impl IIfcElementType for IfcFanType {
    fn element_type(&self) -> &Option<IfcLabel> {
        &self.element_type
    }
}
impl IIfcDistributionElementType for IfcFanType {}
impl IIfcDistributionFlowElementType for IfcFanType {}
impl IIfcFlowMovingDeviceType for IfcFanType {}
impl IIfcFanType for IfcFanType {
    fn predefined_type(&self) -> &IfcFanTypeEnum {
        &self.predefined_type
    }
}
impl IfcFanType {
    pub fn from_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcFanType::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.global_id = parameter.into(),
                1usize => {
                    entity.owner_history = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => {
                    entity.applicable_occurrence = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                5usize => {
                    entity.has_property_sets = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                6usize => {
                    entity.representation_maps = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                7usize => {
                    entity.tag = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                8usize => {
                    entity.element_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                9usize => entity.predefined_type = parameter.into(),
                _ => {}
            }
        }
        entity
    }
    pub fn from_own_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcFanType::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.predefined_type = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcFastener: IIfcElementComponent {
    fn predefined_type(&self) -> &Option<IfcFastenerTypeEnum>;
}
#[derive(Default, Debug)]
pub struct IfcFastener {
    global_id: IfcGloballyUniqueId,
    owner_history: Option<EntityRef>,
    name: Option<IfcLabel>,
    description: Option<IfcText>,
    object_type: Option<IfcLabel>,
    object_placement: Option<EntityRef>,
    representation: Option<EntityRef>,
    tag: Option<IfcIdentifier>,
    predefined_type: Option<IfcFastenerTypeEnum>,
}
impl IIfcRoot for IfcFastener {
    fn global_id(&self) -> &IfcGloballyUniqueId {
        &self.global_id
    }
    fn owner_history(&self) -> &Option<EntityRef> {
        &self.owner_history
    }
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
}
impl IIfcObjectDefinition for IfcFastener {}
impl IIfcObject for IfcFastener {
    fn object_type(&self) -> &Option<IfcLabel> {
        &self.object_type
    }
}
impl IIfcProduct for IfcFastener {
    fn object_placement(&self) -> &Option<EntityRef> {
        &self.object_placement
    }
    fn representation(&self) -> &Option<EntityRef> {
        &self.representation
    }
}
impl IIfcElement for IfcFastener {
    fn tag(&self) -> &Option<IfcIdentifier> {
        &self.tag
    }
}
impl IIfcElementComponent for IfcFastener {}
impl IIfcFastener for IfcFastener {
    fn predefined_type(&self) -> &Option<IfcFastenerTypeEnum> {
        &self.predefined_type
    }
}
impl IfcFastener {
    pub fn from_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcFastener::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.global_id = parameter.into(),
                1usize => {
                    entity.owner_history = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => {
                    entity.object_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                5usize => {
                    entity.object_placement = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                6usize => {
                    entity.representation = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                7usize => {
                    entity.tag = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                8usize => {
                    entity.predefined_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
    pub fn from_own_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcFastener::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => {
                    entity.predefined_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcFastenerType: IIfcElementComponentType {
    fn predefined_type(&self) -> &IfcFastenerTypeEnum;
}
#[derive(Default, Debug)]
pub struct IfcFastenerType {
    global_id: IfcGloballyUniqueId,
    owner_history: Option<EntityRef>,
    name: Option<IfcLabel>,
    description: Option<IfcText>,
    applicable_occurrence: Option<IfcIdentifier>,
    has_property_sets: Option<HashSet<EntityRef>>,
    representation_maps: Option<Vec<EntityRef>>,
    tag: Option<IfcLabel>,
    element_type: Option<IfcLabel>,
    predefined_type: IfcFastenerTypeEnum,
}
impl IIfcRoot for IfcFastenerType {
    fn global_id(&self) -> &IfcGloballyUniqueId {
        &self.global_id
    }
    fn owner_history(&self) -> &Option<EntityRef> {
        &self.owner_history
    }
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
}
impl IIfcObjectDefinition for IfcFastenerType {}
impl IIfcTypeObject for IfcFastenerType {
    fn applicable_occurrence(&self) -> &Option<IfcIdentifier> {
        &self.applicable_occurrence
    }
    fn has_property_sets(&self) -> &Option<HashSet<EntityRef>> {
        &self.has_property_sets
    }
}
impl IIfcTypeProduct for IfcFastenerType {
    fn representation_maps(&self) -> &Option<Vec<EntityRef>> {
        &self.representation_maps
    }
    fn tag(&self) -> &Option<IfcLabel> {
        &self.tag
    }
}
impl IIfcElementType for IfcFastenerType {
    fn element_type(&self) -> &Option<IfcLabel> {
        &self.element_type
    }
}
impl IIfcElementComponentType for IfcFastenerType {}
impl IIfcFastenerType for IfcFastenerType {
    fn predefined_type(&self) -> &IfcFastenerTypeEnum {
        &self.predefined_type
    }
}
impl IfcFastenerType {
    pub fn from_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcFastenerType::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.global_id = parameter.into(),
                1usize => {
                    entity.owner_history = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => {
                    entity.applicable_occurrence = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                5usize => {
                    entity.has_property_sets = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                6usize => {
                    entity.representation_maps = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                7usize => {
                    entity.tag = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                8usize => {
                    entity.element_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                9usize => entity.predefined_type = parameter.into(),
                _ => {}
            }
        }
        entity
    }
    pub fn from_own_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcFastenerType::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.predefined_type = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcFeatureElement: IIfcElement {}
pub trait IIfcFeatureElementAddition: IIfcFeatureElement {}
pub trait IIfcFeatureElementSubtraction: IIfcFeatureElement {}
pub trait IIfcFillAreaStyle: IIfcPresentationStyle {
    fn fill_styles(&self) -> &HashSet<EntityRef>;
    fn modelor_draughting(&self) -> &Option<IfcBoolean>;
}
#[derive(Default, Debug)]
pub struct IfcFillAreaStyle {
    name: Option<IfcLabel>,
    fill_styles: HashSet<EntityRef>,
    modelor_draughting: Option<IfcBoolean>,
}
impl IIfcPresentationStyle for IfcFillAreaStyle {
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
}
impl IIfcFillAreaStyle for IfcFillAreaStyle {
    fn fill_styles(&self) -> &HashSet<EntityRef> {
        &self.fill_styles
    }
    fn modelor_draughting(&self) -> &Option<IfcBoolean> {
        &self.modelor_draughting
    }
}
impl IfcFillAreaStyle {
    pub fn from_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcFillAreaStyle::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                1usize => entity.fill_styles = parameter.into(),
                2usize => {
                    entity.modelor_draughting = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
    pub fn from_own_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcFillAreaStyle::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.fill_styles = parameter.into(),
                1usize => {
                    entity.modelor_draughting = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcFillAreaStyleHatching: IIfcGeometricRepresentationItem {
    fn hatch_line_appearance(&self) -> &EntityRef;
    fn start_of_next_hatch_line(&self) -> &IfcHatchLineDistanceSelect;
    fn point_of_reference_hatch_line(&self) -> &Option<EntityRef>;
    fn pattern_start(&self) -> &Option<EntityRef>;
    fn hatch_line_angle(&self) -> &IfcPlaneAngleMeasure;
}
#[derive(Default, Debug)]
pub struct IfcFillAreaStyleHatching {
    hatch_line_appearance: EntityRef,
    start_of_next_hatch_line: IfcHatchLineDistanceSelect,
    point_of_reference_hatch_line: Option<EntityRef>,
    pattern_start: Option<EntityRef>,
    hatch_line_angle: IfcPlaneAngleMeasure,
}
impl IIfcRepresentationItem for IfcFillAreaStyleHatching {}
impl IIfcGeometricRepresentationItem for IfcFillAreaStyleHatching {}
impl IIfcFillAreaStyleHatching for IfcFillAreaStyleHatching {
    fn hatch_line_appearance(&self) -> &EntityRef {
        &self.hatch_line_appearance
    }
    fn start_of_next_hatch_line(&self) -> &IfcHatchLineDistanceSelect {
        &self.start_of_next_hatch_line
    }
    fn point_of_reference_hatch_line(&self) -> &Option<EntityRef> {
        &self.point_of_reference_hatch_line
    }
    fn pattern_start(&self) -> &Option<EntityRef> {
        &self.pattern_start
    }
    fn hatch_line_angle(&self) -> &IfcPlaneAngleMeasure {
        &self.hatch_line_angle
    }
}
impl IfcFillAreaStyleHatching {
    pub fn from_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcFillAreaStyleHatching::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.hatch_line_appearance = parameter.into(),
                1usize => entity.start_of_next_hatch_line = parameter.into(),
                2usize => {
                    entity.point_of_reference_hatch_line = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.pattern_start = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => entity.hatch_line_angle = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcFillAreaStyleTiles: IIfcGeometricRepresentationItem {
    fn tiling_pattern(&self) -> &Vec<EntityRef>;
    fn tiles(&self) -> &HashSet<EntityRef>;
    fn tiling_scale(&self) -> &IfcPositiveRatioMeasure;
}
#[derive(Default, Debug)]
pub struct IfcFillAreaStyleTiles {
    tiling_pattern: Vec<EntityRef>,
    tiles: HashSet<EntityRef>,
    tiling_scale: IfcPositiveRatioMeasure,
}
impl IIfcRepresentationItem for IfcFillAreaStyleTiles {}
impl IIfcGeometricRepresentationItem for IfcFillAreaStyleTiles {}
impl IIfcFillAreaStyleTiles for IfcFillAreaStyleTiles {
    fn tiling_pattern(&self) -> &Vec<EntityRef> {
        &self.tiling_pattern
    }
    fn tiles(&self) -> &HashSet<EntityRef> {
        &self.tiles
    }
    fn tiling_scale(&self) -> &IfcPositiveRatioMeasure {
        &self.tiling_scale
    }
}
impl IfcFillAreaStyleTiles {
    pub fn from_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcFillAreaStyleTiles::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.tiling_pattern = parameter.into(),
                1usize => entity.tiles = parameter.into(),
                2usize => entity.tiling_scale = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcFilter: IIfcFlowTreatmentDevice {
    fn predefined_type(&self) -> &Option<IfcFilterTypeEnum>;
}
#[derive(Default, Debug)]
pub struct IfcFilter {
    global_id: IfcGloballyUniqueId,
    owner_history: Option<EntityRef>,
    name: Option<IfcLabel>,
    description: Option<IfcText>,
    object_type: Option<IfcLabel>,
    object_placement: Option<EntityRef>,
    representation: Option<EntityRef>,
    tag: Option<IfcIdentifier>,
    predefined_type: Option<IfcFilterTypeEnum>,
}
impl IIfcRoot for IfcFilter {
    fn global_id(&self) -> &IfcGloballyUniqueId {
        &self.global_id
    }
    fn owner_history(&self) -> &Option<EntityRef> {
        &self.owner_history
    }
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
}
impl IIfcObjectDefinition for IfcFilter {}
impl IIfcObject for IfcFilter {
    fn object_type(&self) -> &Option<IfcLabel> {
        &self.object_type
    }
}
impl IIfcProduct for IfcFilter {
    fn object_placement(&self) -> &Option<EntityRef> {
        &self.object_placement
    }
    fn representation(&self) -> &Option<EntityRef> {
        &self.representation
    }
}
impl IIfcElement for IfcFilter {
    fn tag(&self) -> &Option<IfcIdentifier> {
        &self.tag
    }
}
impl IIfcDistributionElement for IfcFilter {}
impl IIfcDistributionFlowElement for IfcFilter {}
impl IIfcFlowTreatmentDevice for IfcFilter {}
impl IIfcFilter for IfcFilter {
    fn predefined_type(&self) -> &Option<IfcFilterTypeEnum> {
        &self.predefined_type
    }
}
impl IfcFilter {
    pub fn from_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcFilter::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.global_id = parameter.into(),
                1usize => {
                    entity.owner_history = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => {
                    entity.object_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                5usize => {
                    entity.object_placement = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                6usize => {
                    entity.representation = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                7usize => {
                    entity.tag = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                8usize => {
                    entity.predefined_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
    pub fn from_own_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcFilter::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => {
                    entity.predefined_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcFilterType: IIfcFlowTreatmentDeviceType {
    fn predefined_type(&self) -> &IfcFilterTypeEnum;
}
#[derive(Default, Debug)]
pub struct IfcFilterType {
    global_id: IfcGloballyUniqueId,
    owner_history: Option<EntityRef>,
    name: Option<IfcLabel>,
    description: Option<IfcText>,
    applicable_occurrence: Option<IfcIdentifier>,
    has_property_sets: Option<HashSet<EntityRef>>,
    representation_maps: Option<Vec<EntityRef>>,
    tag: Option<IfcLabel>,
    element_type: Option<IfcLabel>,
    predefined_type: IfcFilterTypeEnum,
}
impl IIfcRoot for IfcFilterType {
    fn global_id(&self) -> &IfcGloballyUniqueId {
        &self.global_id
    }
    fn owner_history(&self) -> &Option<EntityRef> {
        &self.owner_history
    }
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
}
impl IIfcObjectDefinition for IfcFilterType {}
impl IIfcTypeObject for IfcFilterType {
    fn applicable_occurrence(&self) -> &Option<IfcIdentifier> {
        &self.applicable_occurrence
    }
    fn has_property_sets(&self) -> &Option<HashSet<EntityRef>> {
        &self.has_property_sets
    }
}
impl IIfcTypeProduct for IfcFilterType {
    fn representation_maps(&self) -> &Option<Vec<EntityRef>> {
        &self.representation_maps
    }
    fn tag(&self) -> &Option<IfcLabel> {
        &self.tag
    }
}
impl IIfcElementType for IfcFilterType {
    fn element_type(&self) -> &Option<IfcLabel> {
        &self.element_type
    }
}
impl IIfcDistributionElementType for IfcFilterType {}
impl IIfcDistributionFlowElementType for IfcFilterType {}
impl IIfcFlowTreatmentDeviceType for IfcFilterType {}
impl IIfcFilterType for IfcFilterType {
    fn predefined_type(&self) -> &IfcFilterTypeEnum {
        &self.predefined_type
    }
}
impl IfcFilterType {
    pub fn from_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcFilterType::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.global_id = parameter.into(),
                1usize => {
                    entity.owner_history = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => {
                    entity.applicable_occurrence = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                5usize => {
                    entity.has_property_sets = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                6usize => {
                    entity.representation_maps = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                7usize => {
                    entity.tag = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                8usize => {
                    entity.element_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                9usize => entity.predefined_type = parameter.into(),
                _ => {}
            }
        }
        entity
    }
    pub fn from_own_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcFilterType::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.predefined_type = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcFireSuppressionTerminal: IIfcFlowTerminal {
    fn predefined_type(&self) -> &Option<IfcFireSuppressionTerminalTypeEnum>;
}
#[derive(Default, Debug)]
pub struct IfcFireSuppressionTerminal {
    global_id: IfcGloballyUniqueId,
    owner_history: Option<EntityRef>,
    name: Option<IfcLabel>,
    description: Option<IfcText>,
    object_type: Option<IfcLabel>,
    object_placement: Option<EntityRef>,
    representation: Option<EntityRef>,
    tag: Option<IfcIdentifier>,
    predefined_type: Option<IfcFireSuppressionTerminalTypeEnum>,
}
impl IIfcRoot for IfcFireSuppressionTerminal {
    fn global_id(&self) -> &IfcGloballyUniqueId {
        &self.global_id
    }
    fn owner_history(&self) -> &Option<EntityRef> {
        &self.owner_history
    }
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
}
impl IIfcObjectDefinition for IfcFireSuppressionTerminal {}
impl IIfcObject for IfcFireSuppressionTerminal {
    fn object_type(&self) -> &Option<IfcLabel> {
        &self.object_type
    }
}
impl IIfcProduct for IfcFireSuppressionTerminal {
    fn object_placement(&self) -> &Option<EntityRef> {
        &self.object_placement
    }
    fn representation(&self) -> &Option<EntityRef> {
        &self.representation
    }
}
impl IIfcElement for IfcFireSuppressionTerminal {
    fn tag(&self) -> &Option<IfcIdentifier> {
        &self.tag
    }
}
impl IIfcDistributionElement for IfcFireSuppressionTerminal {}
impl IIfcDistributionFlowElement for IfcFireSuppressionTerminal {}
impl IIfcFlowTerminal for IfcFireSuppressionTerminal {}
impl IIfcFireSuppressionTerminal for IfcFireSuppressionTerminal {
    fn predefined_type(&self) -> &Option<IfcFireSuppressionTerminalTypeEnum> {
        &self.predefined_type
    }
}
impl IfcFireSuppressionTerminal {
    pub fn from_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcFireSuppressionTerminal::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.global_id = parameter.into(),
                1usize => {
                    entity.owner_history = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => {
                    entity.object_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                5usize => {
                    entity.object_placement = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                6usize => {
                    entity.representation = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                7usize => {
                    entity.tag = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                8usize => {
                    entity.predefined_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
    pub fn from_own_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcFireSuppressionTerminal::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => {
                    entity.predefined_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcFireSuppressionTerminalType: IIfcFlowTerminalType {
    fn predefined_type(&self) -> &IfcFireSuppressionTerminalTypeEnum;
}
#[derive(Default, Debug)]
pub struct IfcFireSuppressionTerminalType {
    global_id: IfcGloballyUniqueId,
    owner_history: Option<EntityRef>,
    name: Option<IfcLabel>,
    description: Option<IfcText>,
    applicable_occurrence: Option<IfcIdentifier>,
    has_property_sets: Option<HashSet<EntityRef>>,
    representation_maps: Option<Vec<EntityRef>>,
    tag: Option<IfcLabel>,
    element_type: Option<IfcLabel>,
    predefined_type: IfcFireSuppressionTerminalTypeEnum,
}
impl IIfcRoot for IfcFireSuppressionTerminalType {
    fn global_id(&self) -> &IfcGloballyUniqueId {
        &self.global_id
    }
    fn owner_history(&self) -> &Option<EntityRef> {
        &self.owner_history
    }
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
}
impl IIfcObjectDefinition for IfcFireSuppressionTerminalType {}
impl IIfcTypeObject for IfcFireSuppressionTerminalType {
    fn applicable_occurrence(&self) -> &Option<IfcIdentifier> {
        &self.applicable_occurrence
    }
    fn has_property_sets(&self) -> &Option<HashSet<EntityRef>> {
        &self.has_property_sets
    }
}
impl IIfcTypeProduct for IfcFireSuppressionTerminalType {
    fn representation_maps(&self) -> &Option<Vec<EntityRef>> {
        &self.representation_maps
    }
    fn tag(&self) -> &Option<IfcLabel> {
        &self.tag
    }
}
impl IIfcElementType for IfcFireSuppressionTerminalType {
    fn element_type(&self) -> &Option<IfcLabel> {
        &self.element_type
    }
}
impl IIfcDistributionElementType for IfcFireSuppressionTerminalType {}
impl IIfcDistributionFlowElementType for IfcFireSuppressionTerminalType {}
impl IIfcFlowTerminalType for IfcFireSuppressionTerminalType {}
impl IIfcFireSuppressionTerminalType for IfcFireSuppressionTerminalType {
    fn predefined_type(&self) -> &IfcFireSuppressionTerminalTypeEnum {
        &self.predefined_type
    }
}
impl IfcFireSuppressionTerminalType {
    pub fn from_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcFireSuppressionTerminalType::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.global_id = parameter.into(),
                1usize => {
                    entity.owner_history = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => {
                    entity.applicable_occurrence = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                5usize => {
                    entity.has_property_sets = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                6usize => {
                    entity.representation_maps = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                7usize => {
                    entity.tag = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                8usize => {
                    entity.element_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                9usize => entity.predefined_type = parameter.into(),
                _ => {}
            }
        }
        entity
    }
    pub fn from_own_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcFireSuppressionTerminalType::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.predefined_type = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcFixedReferenceSweptAreaSolid: IIfcSweptAreaSolid {
    fn directrix(&self) -> &EntityRef;
    fn start_param(&self) -> &Option<IfcParameterValue>;
    fn end_param(&self) -> &Option<IfcParameterValue>;
    fn fixed_reference(&self) -> &EntityRef;
}
#[derive(Default, Debug)]
pub struct IfcFixedReferenceSweptAreaSolid {
    swept_area: EntityRef,
    position: Option<EntityRef>,
    directrix: EntityRef,
    start_param: Option<IfcParameterValue>,
    end_param: Option<IfcParameterValue>,
    fixed_reference: EntityRef,
}
impl IIfcRepresentationItem for IfcFixedReferenceSweptAreaSolid {}
impl IIfcGeometricRepresentationItem for IfcFixedReferenceSweptAreaSolid {}
impl IIfcSolidModel for IfcFixedReferenceSweptAreaSolid {}
impl IIfcSweptAreaSolid for IfcFixedReferenceSweptAreaSolid {
    fn swept_area(&self) -> &EntityRef {
        &self.swept_area
    }
    fn position(&self) -> &Option<EntityRef> {
        &self.position
    }
}
impl IIfcFixedReferenceSweptAreaSolid for IfcFixedReferenceSweptAreaSolid {
    fn directrix(&self) -> &EntityRef {
        &self.directrix
    }
    fn start_param(&self) -> &Option<IfcParameterValue> {
        &self.start_param
    }
    fn end_param(&self) -> &Option<IfcParameterValue> {
        &self.end_param
    }
    fn fixed_reference(&self) -> &EntityRef {
        &self.fixed_reference
    }
}
impl IfcFixedReferenceSweptAreaSolid {
    pub fn from_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcFixedReferenceSweptAreaSolid::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.swept_area = parameter.into(),
                1usize => {
                    entity.position = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => entity.directrix = parameter.into(),
                3usize => {
                    entity.start_param = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => {
                    entity.end_param = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                5usize => entity.fixed_reference = parameter.into(),
                _ => {}
            }
        }
        entity
    }
    pub fn from_own_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcFixedReferenceSweptAreaSolid::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.directrix = parameter.into(),
                1usize => {
                    entity.start_param = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => {
                    entity.end_param = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => entity.fixed_reference = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcFlowController: IIfcDistributionFlowElement {}
#[derive(Default, Debug)]
pub struct IfcFlowController {
    global_id: IfcGloballyUniqueId,
    owner_history: Option<EntityRef>,
    name: Option<IfcLabel>,
    description: Option<IfcText>,
    object_type: Option<IfcLabel>,
    object_placement: Option<EntityRef>,
    representation: Option<EntityRef>,
    tag: Option<IfcIdentifier>,
}
impl IIfcRoot for IfcFlowController {
    fn global_id(&self) -> &IfcGloballyUniqueId {
        &self.global_id
    }
    fn owner_history(&self) -> &Option<EntityRef> {
        &self.owner_history
    }
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
}
impl IIfcObjectDefinition for IfcFlowController {}
impl IIfcObject for IfcFlowController {
    fn object_type(&self) -> &Option<IfcLabel> {
        &self.object_type
    }
}
impl IIfcProduct for IfcFlowController {
    fn object_placement(&self) -> &Option<EntityRef> {
        &self.object_placement
    }
    fn representation(&self) -> &Option<EntityRef> {
        &self.representation
    }
}
impl IIfcElement for IfcFlowController {
    fn tag(&self) -> &Option<IfcIdentifier> {
        &self.tag
    }
}
impl IIfcDistributionElement for IfcFlowController {}
impl IIfcDistributionFlowElement for IfcFlowController {}
impl IIfcFlowController for IfcFlowController {}
impl IfcFlowController {
    pub fn from_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcFlowController::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.global_id = parameter.into(),
                1usize => {
                    entity.owner_history = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => {
                    entity.object_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                5usize => {
                    entity.object_placement = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                6usize => {
                    entity.representation = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                7usize => {
                    entity.tag = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcFlowControllerType: IIfcDistributionFlowElementType {}
pub trait IIfcFlowFitting: IIfcDistributionFlowElement {}
#[derive(Default, Debug)]
pub struct IfcFlowFitting {
    global_id: IfcGloballyUniqueId,
    owner_history: Option<EntityRef>,
    name: Option<IfcLabel>,
    description: Option<IfcText>,
    object_type: Option<IfcLabel>,
    object_placement: Option<EntityRef>,
    representation: Option<EntityRef>,
    tag: Option<IfcIdentifier>,
}
impl IIfcRoot for IfcFlowFitting {
    fn global_id(&self) -> &IfcGloballyUniqueId {
        &self.global_id
    }
    fn owner_history(&self) -> &Option<EntityRef> {
        &self.owner_history
    }
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
}
impl IIfcObjectDefinition for IfcFlowFitting {}
impl IIfcObject for IfcFlowFitting {
    fn object_type(&self) -> &Option<IfcLabel> {
        &self.object_type
    }
}
impl IIfcProduct for IfcFlowFitting {
    fn object_placement(&self) -> &Option<EntityRef> {
        &self.object_placement
    }
    fn representation(&self) -> &Option<EntityRef> {
        &self.representation
    }
}
impl IIfcElement for IfcFlowFitting {
    fn tag(&self) -> &Option<IfcIdentifier> {
        &self.tag
    }
}
impl IIfcDistributionElement for IfcFlowFitting {}
impl IIfcDistributionFlowElement for IfcFlowFitting {}
impl IIfcFlowFitting for IfcFlowFitting {}
impl IfcFlowFitting {
    pub fn from_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcFlowFitting::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.global_id = parameter.into(),
                1usize => {
                    entity.owner_history = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => {
                    entity.object_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                5usize => {
                    entity.object_placement = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                6usize => {
                    entity.representation = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                7usize => {
                    entity.tag = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcFlowFittingType: IIfcDistributionFlowElementType {}
pub trait IIfcFlowInstrument: IIfcDistributionControlElement {
    fn predefined_type(&self) -> &Option<IfcFlowInstrumentTypeEnum>;
}
#[derive(Default, Debug)]
pub struct IfcFlowInstrument {
    global_id: IfcGloballyUniqueId,
    owner_history: Option<EntityRef>,
    name: Option<IfcLabel>,
    description: Option<IfcText>,
    object_type: Option<IfcLabel>,
    object_placement: Option<EntityRef>,
    representation: Option<EntityRef>,
    tag: Option<IfcIdentifier>,
    predefined_type: Option<IfcFlowInstrumentTypeEnum>,
}
impl IIfcRoot for IfcFlowInstrument {
    fn global_id(&self) -> &IfcGloballyUniqueId {
        &self.global_id
    }
    fn owner_history(&self) -> &Option<EntityRef> {
        &self.owner_history
    }
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
}
impl IIfcObjectDefinition for IfcFlowInstrument {}
impl IIfcObject for IfcFlowInstrument {
    fn object_type(&self) -> &Option<IfcLabel> {
        &self.object_type
    }
}
impl IIfcProduct for IfcFlowInstrument {
    fn object_placement(&self) -> &Option<EntityRef> {
        &self.object_placement
    }
    fn representation(&self) -> &Option<EntityRef> {
        &self.representation
    }
}
impl IIfcElement for IfcFlowInstrument {
    fn tag(&self) -> &Option<IfcIdentifier> {
        &self.tag
    }
}
impl IIfcDistributionElement for IfcFlowInstrument {}
impl IIfcDistributionControlElement for IfcFlowInstrument {}
impl IIfcFlowInstrument for IfcFlowInstrument {
    fn predefined_type(&self) -> &Option<IfcFlowInstrumentTypeEnum> {
        &self.predefined_type
    }
}
impl IfcFlowInstrument {
    pub fn from_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcFlowInstrument::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.global_id = parameter.into(),
                1usize => {
                    entity.owner_history = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => {
                    entity.object_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                5usize => {
                    entity.object_placement = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                6usize => {
                    entity.representation = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                7usize => {
                    entity.tag = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                8usize => {
                    entity.predefined_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
    pub fn from_own_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcFlowInstrument::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => {
                    entity.predefined_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcFlowInstrumentType: IIfcDistributionControlElementType {
    fn predefined_type(&self) -> &IfcFlowInstrumentTypeEnum;
}
#[derive(Default, Debug)]
pub struct IfcFlowInstrumentType {
    global_id: IfcGloballyUniqueId,
    owner_history: Option<EntityRef>,
    name: Option<IfcLabel>,
    description: Option<IfcText>,
    applicable_occurrence: Option<IfcIdentifier>,
    has_property_sets: Option<HashSet<EntityRef>>,
    representation_maps: Option<Vec<EntityRef>>,
    tag: Option<IfcLabel>,
    element_type: Option<IfcLabel>,
    predefined_type: IfcFlowInstrumentTypeEnum,
}
impl IIfcRoot for IfcFlowInstrumentType {
    fn global_id(&self) -> &IfcGloballyUniqueId {
        &self.global_id
    }
    fn owner_history(&self) -> &Option<EntityRef> {
        &self.owner_history
    }
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
}
impl IIfcObjectDefinition for IfcFlowInstrumentType {}
impl IIfcTypeObject for IfcFlowInstrumentType {
    fn applicable_occurrence(&self) -> &Option<IfcIdentifier> {
        &self.applicable_occurrence
    }
    fn has_property_sets(&self) -> &Option<HashSet<EntityRef>> {
        &self.has_property_sets
    }
}
impl IIfcTypeProduct for IfcFlowInstrumentType {
    fn representation_maps(&self) -> &Option<Vec<EntityRef>> {
        &self.representation_maps
    }
    fn tag(&self) -> &Option<IfcLabel> {
        &self.tag
    }
}
impl IIfcElementType for IfcFlowInstrumentType {
    fn element_type(&self) -> &Option<IfcLabel> {
        &self.element_type
    }
}
impl IIfcDistributionElementType for IfcFlowInstrumentType {}
impl IIfcDistributionControlElementType for IfcFlowInstrumentType {}
impl IIfcFlowInstrumentType for IfcFlowInstrumentType {
    fn predefined_type(&self) -> &IfcFlowInstrumentTypeEnum {
        &self.predefined_type
    }
}
impl IfcFlowInstrumentType {
    pub fn from_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcFlowInstrumentType::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.global_id = parameter.into(),
                1usize => {
                    entity.owner_history = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => {
                    entity.applicable_occurrence = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                5usize => {
                    entity.has_property_sets = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                6usize => {
                    entity.representation_maps = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                7usize => {
                    entity.tag = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                8usize => {
                    entity.element_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                9usize => entity.predefined_type = parameter.into(),
                _ => {}
            }
        }
        entity
    }
    pub fn from_own_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcFlowInstrumentType::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.predefined_type = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcFlowMeter: IIfcFlowController {
    fn predefined_type(&self) -> &Option<IfcFlowMeterTypeEnum>;
}
#[derive(Default, Debug)]
pub struct IfcFlowMeter {
    global_id: IfcGloballyUniqueId,
    owner_history: Option<EntityRef>,
    name: Option<IfcLabel>,
    description: Option<IfcText>,
    object_type: Option<IfcLabel>,
    object_placement: Option<EntityRef>,
    representation: Option<EntityRef>,
    tag: Option<IfcIdentifier>,
    predefined_type: Option<IfcFlowMeterTypeEnum>,
}
impl IIfcRoot for IfcFlowMeter {
    fn global_id(&self) -> &IfcGloballyUniqueId {
        &self.global_id
    }
    fn owner_history(&self) -> &Option<EntityRef> {
        &self.owner_history
    }
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
}
impl IIfcObjectDefinition for IfcFlowMeter {}
impl IIfcObject for IfcFlowMeter {
    fn object_type(&self) -> &Option<IfcLabel> {
        &self.object_type
    }
}
impl IIfcProduct for IfcFlowMeter {
    fn object_placement(&self) -> &Option<EntityRef> {
        &self.object_placement
    }
    fn representation(&self) -> &Option<EntityRef> {
        &self.representation
    }
}
impl IIfcElement for IfcFlowMeter {
    fn tag(&self) -> &Option<IfcIdentifier> {
        &self.tag
    }
}
impl IIfcDistributionElement for IfcFlowMeter {}
impl IIfcDistributionFlowElement for IfcFlowMeter {}
impl IIfcFlowController for IfcFlowMeter {}
impl IIfcFlowMeter for IfcFlowMeter {
    fn predefined_type(&self) -> &Option<IfcFlowMeterTypeEnum> {
        &self.predefined_type
    }
}
impl IfcFlowMeter {
    pub fn from_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcFlowMeter::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.global_id = parameter.into(),
                1usize => {
                    entity.owner_history = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => {
                    entity.object_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                5usize => {
                    entity.object_placement = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                6usize => {
                    entity.representation = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                7usize => {
                    entity.tag = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                8usize => {
                    entity.predefined_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
    pub fn from_own_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcFlowMeter::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => {
                    entity.predefined_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcFlowMeterType: IIfcFlowControllerType {
    fn predefined_type(&self) -> &IfcFlowMeterTypeEnum;
}
#[derive(Default, Debug)]
pub struct IfcFlowMeterType {
    global_id: IfcGloballyUniqueId,
    owner_history: Option<EntityRef>,
    name: Option<IfcLabel>,
    description: Option<IfcText>,
    applicable_occurrence: Option<IfcIdentifier>,
    has_property_sets: Option<HashSet<EntityRef>>,
    representation_maps: Option<Vec<EntityRef>>,
    tag: Option<IfcLabel>,
    element_type: Option<IfcLabel>,
    predefined_type: IfcFlowMeterTypeEnum,
}
impl IIfcRoot for IfcFlowMeterType {
    fn global_id(&self) -> &IfcGloballyUniqueId {
        &self.global_id
    }
    fn owner_history(&self) -> &Option<EntityRef> {
        &self.owner_history
    }
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
}
impl IIfcObjectDefinition for IfcFlowMeterType {}
impl IIfcTypeObject for IfcFlowMeterType {
    fn applicable_occurrence(&self) -> &Option<IfcIdentifier> {
        &self.applicable_occurrence
    }
    fn has_property_sets(&self) -> &Option<HashSet<EntityRef>> {
        &self.has_property_sets
    }
}
impl IIfcTypeProduct for IfcFlowMeterType {
    fn representation_maps(&self) -> &Option<Vec<EntityRef>> {
        &self.representation_maps
    }
    fn tag(&self) -> &Option<IfcLabel> {
        &self.tag
    }
}
impl IIfcElementType for IfcFlowMeterType {
    fn element_type(&self) -> &Option<IfcLabel> {
        &self.element_type
    }
}
impl IIfcDistributionElementType for IfcFlowMeterType {}
impl IIfcDistributionFlowElementType for IfcFlowMeterType {}
impl IIfcFlowControllerType for IfcFlowMeterType {}
impl IIfcFlowMeterType for IfcFlowMeterType {
    fn predefined_type(&self) -> &IfcFlowMeterTypeEnum {
        &self.predefined_type
    }
}
impl IfcFlowMeterType {
    pub fn from_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcFlowMeterType::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.global_id = parameter.into(),
                1usize => {
                    entity.owner_history = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => {
                    entity.applicable_occurrence = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                5usize => {
                    entity.has_property_sets = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                6usize => {
                    entity.representation_maps = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                7usize => {
                    entity.tag = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                8usize => {
                    entity.element_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                9usize => entity.predefined_type = parameter.into(),
                _ => {}
            }
        }
        entity
    }
    pub fn from_own_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcFlowMeterType::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.predefined_type = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcFlowMovingDevice: IIfcDistributionFlowElement {}
#[derive(Default, Debug)]
pub struct IfcFlowMovingDevice {
    global_id: IfcGloballyUniqueId,
    owner_history: Option<EntityRef>,
    name: Option<IfcLabel>,
    description: Option<IfcText>,
    object_type: Option<IfcLabel>,
    object_placement: Option<EntityRef>,
    representation: Option<EntityRef>,
    tag: Option<IfcIdentifier>,
}
impl IIfcRoot for IfcFlowMovingDevice {
    fn global_id(&self) -> &IfcGloballyUniqueId {
        &self.global_id
    }
    fn owner_history(&self) -> &Option<EntityRef> {
        &self.owner_history
    }
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
}
impl IIfcObjectDefinition for IfcFlowMovingDevice {}
impl IIfcObject for IfcFlowMovingDevice {
    fn object_type(&self) -> &Option<IfcLabel> {
        &self.object_type
    }
}
impl IIfcProduct for IfcFlowMovingDevice {
    fn object_placement(&self) -> &Option<EntityRef> {
        &self.object_placement
    }
    fn representation(&self) -> &Option<EntityRef> {
        &self.representation
    }
}
impl IIfcElement for IfcFlowMovingDevice {
    fn tag(&self) -> &Option<IfcIdentifier> {
        &self.tag
    }
}
impl IIfcDistributionElement for IfcFlowMovingDevice {}
impl IIfcDistributionFlowElement for IfcFlowMovingDevice {}
impl IIfcFlowMovingDevice for IfcFlowMovingDevice {}
impl IfcFlowMovingDevice {
    pub fn from_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcFlowMovingDevice::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.global_id = parameter.into(),
                1usize => {
                    entity.owner_history = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => {
                    entity.object_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                5usize => {
                    entity.object_placement = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                6usize => {
                    entity.representation = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                7usize => {
                    entity.tag = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcFlowMovingDeviceType: IIfcDistributionFlowElementType {}
pub trait IIfcFlowSegment: IIfcDistributionFlowElement {}
#[derive(Default, Debug)]
pub struct IfcFlowSegment {
    global_id: IfcGloballyUniqueId,
    owner_history: Option<EntityRef>,
    name: Option<IfcLabel>,
    description: Option<IfcText>,
    object_type: Option<IfcLabel>,
    object_placement: Option<EntityRef>,
    representation: Option<EntityRef>,
    tag: Option<IfcIdentifier>,
}
impl IIfcRoot for IfcFlowSegment {
    fn global_id(&self) -> &IfcGloballyUniqueId {
        &self.global_id
    }
    fn owner_history(&self) -> &Option<EntityRef> {
        &self.owner_history
    }
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
}
impl IIfcObjectDefinition for IfcFlowSegment {}
impl IIfcObject for IfcFlowSegment {
    fn object_type(&self) -> &Option<IfcLabel> {
        &self.object_type
    }
}
impl IIfcProduct for IfcFlowSegment {
    fn object_placement(&self) -> &Option<EntityRef> {
        &self.object_placement
    }
    fn representation(&self) -> &Option<EntityRef> {
        &self.representation
    }
}
impl IIfcElement for IfcFlowSegment {
    fn tag(&self) -> &Option<IfcIdentifier> {
        &self.tag
    }
}
impl IIfcDistributionElement for IfcFlowSegment {}
impl IIfcDistributionFlowElement for IfcFlowSegment {}
impl IIfcFlowSegment for IfcFlowSegment {}
impl IfcFlowSegment {
    pub fn from_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcFlowSegment::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.global_id = parameter.into(),
                1usize => {
                    entity.owner_history = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => {
                    entity.object_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                5usize => {
                    entity.object_placement = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                6usize => {
                    entity.representation = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                7usize => {
                    entity.tag = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcFlowSegmentType: IIfcDistributionFlowElementType {}
pub trait IIfcFlowStorageDevice: IIfcDistributionFlowElement {}
#[derive(Default, Debug)]
pub struct IfcFlowStorageDevice {
    global_id: IfcGloballyUniqueId,
    owner_history: Option<EntityRef>,
    name: Option<IfcLabel>,
    description: Option<IfcText>,
    object_type: Option<IfcLabel>,
    object_placement: Option<EntityRef>,
    representation: Option<EntityRef>,
    tag: Option<IfcIdentifier>,
}
impl IIfcRoot for IfcFlowStorageDevice {
    fn global_id(&self) -> &IfcGloballyUniqueId {
        &self.global_id
    }
    fn owner_history(&self) -> &Option<EntityRef> {
        &self.owner_history
    }
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
}
impl IIfcObjectDefinition for IfcFlowStorageDevice {}
impl IIfcObject for IfcFlowStorageDevice {
    fn object_type(&self) -> &Option<IfcLabel> {
        &self.object_type
    }
}
impl IIfcProduct for IfcFlowStorageDevice {
    fn object_placement(&self) -> &Option<EntityRef> {
        &self.object_placement
    }
    fn representation(&self) -> &Option<EntityRef> {
        &self.representation
    }
}
impl IIfcElement for IfcFlowStorageDevice {
    fn tag(&self) -> &Option<IfcIdentifier> {
        &self.tag
    }
}
impl IIfcDistributionElement for IfcFlowStorageDevice {}
impl IIfcDistributionFlowElement for IfcFlowStorageDevice {}
impl IIfcFlowStorageDevice for IfcFlowStorageDevice {}
impl IfcFlowStorageDevice {
    pub fn from_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcFlowStorageDevice::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.global_id = parameter.into(),
                1usize => {
                    entity.owner_history = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => {
                    entity.object_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                5usize => {
                    entity.object_placement = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                6usize => {
                    entity.representation = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                7usize => {
                    entity.tag = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcFlowStorageDeviceType: IIfcDistributionFlowElementType {}
pub trait IIfcFlowTerminal: IIfcDistributionFlowElement {}
#[derive(Default, Debug)]
pub struct IfcFlowTerminal {
    global_id: IfcGloballyUniqueId,
    owner_history: Option<EntityRef>,
    name: Option<IfcLabel>,
    description: Option<IfcText>,
    object_type: Option<IfcLabel>,
    object_placement: Option<EntityRef>,
    representation: Option<EntityRef>,
    tag: Option<IfcIdentifier>,
}
impl IIfcRoot for IfcFlowTerminal {
    fn global_id(&self) -> &IfcGloballyUniqueId {
        &self.global_id
    }
    fn owner_history(&self) -> &Option<EntityRef> {
        &self.owner_history
    }
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
}
impl IIfcObjectDefinition for IfcFlowTerminal {}
impl IIfcObject for IfcFlowTerminal {
    fn object_type(&self) -> &Option<IfcLabel> {
        &self.object_type
    }
}
impl IIfcProduct for IfcFlowTerminal {
    fn object_placement(&self) -> &Option<EntityRef> {
        &self.object_placement
    }
    fn representation(&self) -> &Option<EntityRef> {
        &self.representation
    }
}
impl IIfcElement for IfcFlowTerminal {
    fn tag(&self) -> &Option<IfcIdentifier> {
        &self.tag
    }
}
impl IIfcDistributionElement for IfcFlowTerminal {}
impl IIfcDistributionFlowElement for IfcFlowTerminal {}
impl IIfcFlowTerminal for IfcFlowTerminal {}
impl IfcFlowTerminal {
    pub fn from_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcFlowTerminal::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.global_id = parameter.into(),
                1usize => {
                    entity.owner_history = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => {
                    entity.object_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                5usize => {
                    entity.object_placement = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                6usize => {
                    entity.representation = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                7usize => {
                    entity.tag = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcFlowTerminalType: IIfcDistributionFlowElementType {}
pub trait IIfcFlowTreatmentDevice: IIfcDistributionFlowElement {}
#[derive(Default, Debug)]
pub struct IfcFlowTreatmentDevice {
    global_id: IfcGloballyUniqueId,
    owner_history: Option<EntityRef>,
    name: Option<IfcLabel>,
    description: Option<IfcText>,
    object_type: Option<IfcLabel>,
    object_placement: Option<EntityRef>,
    representation: Option<EntityRef>,
    tag: Option<IfcIdentifier>,
}
impl IIfcRoot for IfcFlowTreatmentDevice {
    fn global_id(&self) -> &IfcGloballyUniqueId {
        &self.global_id
    }
    fn owner_history(&self) -> &Option<EntityRef> {
        &self.owner_history
    }
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
}
impl IIfcObjectDefinition for IfcFlowTreatmentDevice {}
impl IIfcObject for IfcFlowTreatmentDevice {
    fn object_type(&self) -> &Option<IfcLabel> {
        &self.object_type
    }
}
impl IIfcProduct for IfcFlowTreatmentDevice {
    fn object_placement(&self) -> &Option<EntityRef> {
        &self.object_placement
    }
    fn representation(&self) -> &Option<EntityRef> {
        &self.representation
    }
}
impl IIfcElement for IfcFlowTreatmentDevice {
    fn tag(&self) -> &Option<IfcIdentifier> {
        &self.tag
    }
}
impl IIfcDistributionElement for IfcFlowTreatmentDevice {}
impl IIfcDistributionFlowElement for IfcFlowTreatmentDevice {}
impl IIfcFlowTreatmentDevice for IfcFlowTreatmentDevice {}
impl IfcFlowTreatmentDevice {
    pub fn from_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcFlowTreatmentDevice::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.global_id = parameter.into(),
                1usize => {
                    entity.owner_history = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => {
                    entity.object_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                5usize => {
                    entity.object_placement = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                6usize => {
                    entity.representation = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                7usize => {
                    entity.tag = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcFlowTreatmentDeviceType: IIfcDistributionFlowElementType {}
pub trait IIfcFooting: IIfcBuildingElement {
    fn predefined_type(&self) -> &Option<IfcFootingTypeEnum>;
}
#[derive(Default, Debug)]
pub struct IfcFooting {
    global_id: IfcGloballyUniqueId,
    owner_history: Option<EntityRef>,
    name: Option<IfcLabel>,
    description: Option<IfcText>,
    object_type: Option<IfcLabel>,
    object_placement: Option<EntityRef>,
    representation: Option<EntityRef>,
    tag: Option<IfcIdentifier>,
    predefined_type: Option<IfcFootingTypeEnum>,
}
impl IIfcRoot for IfcFooting {
    fn global_id(&self) -> &IfcGloballyUniqueId {
        &self.global_id
    }
    fn owner_history(&self) -> &Option<EntityRef> {
        &self.owner_history
    }
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
}
impl IIfcObjectDefinition for IfcFooting {}
impl IIfcObject for IfcFooting {
    fn object_type(&self) -> &Option<IfcLabel> {
        &self.object_type
    }
}
impl IIfcProduct for IfcFooting {
    fn object_placement(&self) -> &Option<EntityRef> {
        &self.object_placement
    }
    fn representation(&self) -> &Option<EntityRef> {
        &self.representation
    }
}
impl IIfcElement for IfcFooting {
    fn tag(&self) -> &Option<IfcIdentifier> {
        &self.tag
    }
}
impl IIfcBuildingElement for IfcFooting {}
impl IIfcFooting for IfcFooting {
    fn predefined_type(&self) -> &Option<IfcFootingTypeEnum> {
        &self.predefined_type
    }
}
impl IfcFooting {
    pub fn from_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcFooting::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.global_id = parameter.into(),
                1usize => {
                    entity.owner_history = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => {
                    entity.object_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                5usize => {
                    entity.object_placement = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                6usize => {
                    entity.representation = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                7usize => {
                    entity.tag = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                8usize => {
                    entity.predefined_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
    pub fn from_own_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcFooting::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => {
                    entity.predefined_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcFootingType: IIfcBuildingElementType {
    fn predefined_type(&self) -> &IfcFootingTypeEnum;
}
#[derive(Default, Debug)]
pub struct IfcFootingType {
    global_id: IfcGloballyUniqueId,
    owner_history: Option<EntityRef>,
    name: Option<IfcLabel>,
    description: Option<IfcText>,
    applicable_occurrence: Option<IfcIdentifier>,
    has_property_sets: Option<HashSet<EntityRef>>,
    representation_maps: Option<Vec<EntityRef>>,
    tag: Option<IfcLabel>,
    element_type: Option<IfcLabel>,
    predefined_type: IfcFootingTypeEnum,
}
impl IIfcRoot for IfcFootingType {
    fn global_id(&self) -> &IfcGloballyUniqueId {
        &self.global_id
    }
    fn owner_history(&self) -> &Option<EntityRef> {
        &self.owner_history
    }
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
}
impl IIfcObjectDefinition for IfcFootingType {}
impl IIfcTypeObject for IfcFootingType {
    fn applicable_occurrence(&self) -> &Option<IfcIdentifier> {
        &self.applicable_occurrence
    }
    fn has_property_sets(&self) -> &Option<HashSet<EntityRef>> {
        &self.has_property_sets
    }
}
impl IIfcTypeProduct for IfcFootingType {
    fn representation_maps(&self) -> &Option<Vec<EntityRef>> {
        &self.representation_maps
    }
    fn tag(&self) -> &Option<IfcLabel> {
        &self.tag
    }
}
impl IIfcElementType for IfcFootingType {
    fn element_type(&self) -> &Option<IfcLabel> {
        &self.element_type
    }
}
impl IIfcBuildingElementType for IfcFootingType {}
impl IIfcFootingType for IfcFootingType {
    fn predefined_type(&self) -> &IfcFootingTypeEnum {
        &self.predefined_type
    }
}
impl IfcFootingType {
    pub fn from_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcFootingType::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.global_id = parameter.into(),
                1usize => {
                    entity.owner_history = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => {
                    entity.applicable_occurrence = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                5usize => {
                    entity.has_property_sets = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                6usize => {
                    entity.representation_maps = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                7usize => {
                    entity.tag = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                8usize => {
                    entity.element_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                9usize => entity.predefined_type = parameter.into(),
                _ => {}
            }
        }
        entity
    }
    pub fn from_own_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcFootingType::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.predefined_type = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcFurnishingElement: IIfcElement {}
#[derive(Default, Debug)]
pub struct IfcFurnishingElement {
    global_id: IfcGloballyUniqueId,
    owner_history: Option<EntityRef>,
    name: Option<IfcLabel>,
    description: Option<IfcText>,
    object_type: Option<IfcLabel>,
    object_placement: Option<EntityRef>,
    representation: Option<EntityRef>,
    tag: Option<IfcIdentifier>,
}
impl IIfcRoot for IfcFurnishingElement {
    fn global_id(&self) -> &IfcGloballyUniqueId {
        &self.global_id
    }
    fn owner_history(&self) -> &Option<EntityRef> {
        &self.owner_history
    }
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
}
impl IIfcObjectDefinition for IfcFurnishingElement {}
impl IIfcObject for IfcFurnishingElement {
    fn object_type(&self) -> &Option<IfcLabel> {
        &self.object_type
    }
}
impl IIfcProduct for IfcFurnishingElement {
    fn object_placement(&self) -> &Option<EntityRef> {
        &self.object_placement
    }
    fn representation(&self) -> &Option<EntityRef> {
        &self.representation
    }
}
impl IIfcElement for IfcFurnishingElement {
    fn tag(&self) -> &Option<IfcIdentifier> {
        &self.tag
    }
}
impl IIfcFurnishingElement for IfcFurnishingElement {}
impl IfcFurnishingElement {
    pub fn from_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcFurnishingElement::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.global_id = parameter.into(),
                1usize => {
                    entity.owner_history = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => {
                    entity.object_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                5usize => {
                    entity.object_placement = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                6usize => {
                    entity.representation = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                7usize => {
                    entity.tag = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcFurnishingElementType: IIfcElementType {}
#[derive(Default, Debug)]
pub struct IfcFurnishingElementType {
    global_id: IfcGloballyUniqueId,
    owner_history: Option<EntityRef>,
    name: Option<IfcLabel>,
    description: Option<IfcText>,
    applicable_occurrence: Option<IfcIdentifier>,
    has_property_sets: Option<HashSet<EntityRef>>,
    representation_maps: Option<Vec<EntityRef>>,
    tag: Option<IfcLabel>,
    element_type: Option<IfcLabel>,
}
impl IIfcRoot for IfcFurnishingElementType {
    fn global_id(&self) -> &IfcGloballyUniqueId {
        &self.global_id
    }
    fn owner_history(&self) -> &Option<EntityRef> {
        &self.owner_history
    }
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
}
impl IIfcObjectDefinition for IfcFurnishingElementType {}
impl IIfcTypeObject for IfcFurnishingElementType {
    fn applicable_occurrence(&self) -> &Option<IfcIdentifier> {
        &self.applicable_occurrence
    }
    fn has_property_sets(&self) -> &Option<HashSet<EntityRef>> {
        &self.has_property_sets
    }
}
impl IIfcTypeProduct for IfcFurnishingElementType {
    fn representation_maps(&self) -> &Option<Vec<EntityRef>> {
        &self.representation_maps
    }
    fn tag(&self) -> &Option<IfcLabel> {
        &self.tag
    }
}
impl IIfcElementType for IfcFurnishingElementType {
    fn element_type(&self) -> &Option<IfcLabel> {
        &self.element_type
    }
}
impl IIfcFurnishingElementType for IfcFurnishingElementType {}
impl IfcFurnishingElementType {
    pub fn from_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcFurnishingElementType::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.global_id = parameter.into(),
                1usize => {
                    entity.owner_history = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => {
                    entity.applicable_occurrence = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                5usize => {
                    entity.has_property_sets = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                6usize => {
                    entity.representation_maps = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                7usize => {
                    entity.tag = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                8usize => {
                    entity.element_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcFurniture: IIfcFurnishingElement {
    fn predefined_type(&self) -> &Option<IfcFurnitureTypeEnum>;
}
#[derive(Default, Debug)]
pub struct IfcFurniture {
    global_id: IfcGloballyUniqueId,
    owner_history: Option<EntityRef>,
    name: Option<IfcLabel>,
    description: Option<IfcText>,
    object_type: Option<IfcLabel>,
    object_placement: Option<EntityRef>,
    representation: Option<EntityRef>,
    tag: Option<IfcIdentifier>,
    predefined_type: Option<IfcFurnitureTypeEnum>,
}
impl IIfcRoot for IfcFurniture {
    fn global_id(&self) -> &IfcGloballyUniqueId {
        &self.global_id
    }
    fn owner_history(&self) -> &Option<EntityRef> {
        &self.owner_history
    }
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
}
impl IIfcObjectDefinition for IfcFurniture {}
impl IIfcObject for IfcFurniture {
    fn object_type(&self) -> &Option<IfcLabel> {
        &self.object_type
    }
}
impl IIfcProduct for IfcFurniture {
    fn object_placement(&self) -> &Option<EntityRef> {
        &self.object_placement
    }
    fn representation(&self) -> &Option<EntityRef> {
        &self.representation
    }
}
impl IIfcElement for IfcFurniture {
    fn tag(&self) -> &Option<IfcIdentifier> {
        &self.tag
    }
}
impl IIfcFurnishingElement for IfcFurniture {}
impl IIfcFurniture for IfcFurniture {
    fn predefined_type(&self) -> &Option<IfcFurnitureTypeEnum> {
        &self.predefined_type
    }
}
impl IfcFurniture {
    pub fn from_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcFurniture::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.global_id = parameter.into(),
                1usize => {
                    entity.owner_history = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => {
                    entity.object_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                5usize => {
                    entity.object_placement = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                6usize => {
                    entity.representation = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                7usize => {
                    entity.tag = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                8usize => {
                    entity.predefined_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
    pub fn from_own_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcFurniture::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => {
                    entity.predefined_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcFurnitureType: IIfcFurnishingElementType {
    fn assembly_place(&self) -> &IfcAssemblyPlaceEnum;
    fn predefined_type(&self) -> &Option<IfcFurnitureTypeEnum>;
}
#[derive(Default, Debug)]
pub struct IfcFurnitureType {
    global_id: IfcGloballyUniqueId,
    owner_history: Option<EntityRef>,
    name: Option<IfcLabel>,
    description: Option<IfcText>,
    applicable_occurrence: Option<IfcIdentifier>,
    has_property_sets: Option<HashSet<EntityRef>>,
    representation_maps: Option<Vec<EntityRef>>,
    tag: Option<IfcLabel>,
    element_type: Option<IfcLabel>,
    assembly_place: IfcAssemblyPlaceEnum,
    predefined_type: Option<IfcFurnitureTypeEnum>,
}
impl IIfcRoot for IfcFurnitureType {
    fn global_id(&self) -> &IfcGloballyUniqueId {
        &self.global_id
    }
    fn owner_history(&self) -> &Option<EntityRef> {
        &self.owner_history
    }
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
}
impl IIfcObjectDefinition for IfcFurnitureType {}
impl IIfcTypeObject for IfcFurnitureType {
    fn applicable_occurrence(&self) -> &Option<IfcIdentifier> {
        &self.applicable_occurrence
    }
    fn has_property_sets(&self) -> &Option<HashSet<EntityRef>> {
        &self.has_property_sets
    }
}
impl IIfcTypeProduct for IfcFurnitureType {
    fn representation_maps(&self) -> &Option<Vec<EntityRef>> {
        &self.representation_maps
    }
    fn tag(&self) -> &Option<IfcLabel> {
        &self.tag
    }
}
impl IIfcElementType for IfcFurnitureType {
    fn element_type(&self) -> &Option<IfcLabel> {
        &self.element_type
    }
}
impl IIfcFurnishingElementType for IfcFurnitureType {}
impl IIfcFurnitureType for IfcFurnitureType {
    fn assembly_place(&self) -> &IfcAssemblyPlaceEnum {
        &self.assembly_place
    }
    fn predefined_type(&self) -> &Option<IfcFurnitureTypeEnum> {
        &self.predefined_type
    }
}
impl IfcFurnitureType {
    pub fn from_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcFurnitureType::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.global_id = parameter.into(),
                1usize => {
                    entity.owner_history = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => {
                    entity.applicable_occurrence = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                5usize => {
                    entity.has_property_sets = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                6usize => {
                    entity.representation_maps = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                7usize => {
                    entity.tag = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                8usize => {
                    entity.element_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                9usize => entity.assembly_place = parameter.into(),
                10usize => {
                    entity.predefined_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
    pub fn from_own_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcFurnitureType::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.assembly_place = parameter.into(),
                1usize => {
                    entity.predefined_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcGeographicElement: IIfcElement {
    fn predefined_type(&self) -> &Option<IfcGeographicElementTypeEnum>;
}
#[derive(Default, Debug)]
pub struct IfcGeographicElement {
    global_id: IfcGloballyUniqueId,
    owner_history: Option<EntityRef>,
    name: Option<IfcLabel>,
    description: Option<IfcText>,
    object_type: Option<IfcLabel>,
    object_placement: Option<EntityRef>,
    representation: Option<EntityRef>,
    tag: Option<IfcIdentifier>,
    predefined_type: Option<IfcGeographicElementTypeEnum>,
}
impl IIfcRoot for IfcGeographicElement {
    fn global_id(&self) -> &IfcGloballyUniqueId {
        &self.global_id
    }
    fn owner_history(&self) -> &Option<EntityRef> {
        &self.owner_history
    }
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
}
impl IIfcObjectDefinition for IfcGeographicElement {}
impl IIfcObject for IfcGeographicElement {
    fn object_type(&self) -> &Option<IfcLabel> {
        &self.object_type
    }
}
impl IIfcProduct for IfcGeographicElement {
    fn object_placement(&self) -> &Option<EntityRef> {
        &self.object_placement
    }
    fn representation(&self) -> &Option<EntityRef> {
        &self.representation
    }
}
impl IIfcElement for IfcGeographicElement {
    fn tag(&self) -> &Option<IfcIdentifier> {
        &self.tag
    }
}
impl IIfcGeographicElement for IfcGeographicElement {
    fn predefined_type(&self) -> &Option<IfcGeographicElementTypeEnum> {
        &self.predefined_type
    }
}
impl IfcGeographicElement {
    pub fn from_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcGeographicElement::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.global_id = parameter.into(),
                1usize => {
                    entity.owner_history = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => {
                    entity.object_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                5usize => {
                    entity.object_placement = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                6usize => {
                    entity.representation = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                7usize => {
                    entity.tag = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                8usize => {
                    entity.predefined_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
    pub fn from_own_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcGeographicElement::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => {
                    entity.predefined_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcGeographicElementType: IIfcElementType {
    fn predefined_type(&self) -> &IfcGeographicElementTypeEnum;
}
#[derive(Default, Debug)]
pub struct IfcGeographicElementType {
    global_id: IfcGloballyUniqueId,
    owner_history: Option<EntityRef>,
    name: Option<IfcLabel>,
    description: Option<IfcText>,
    applicable_occurrence: Option<IfcIdentifier>,
    has_property_sets: Option<HashSet<EntityRef>>,
    representation_maps: Option<Vec<EntityRef>>,
    tag: Option<IfcLabel>,
    element_type: Option<IfcLabel>,
    predefined_type: IfcGeographicElementTypeEnum,
}
impl IIfcRoot for IfcGeographicElementType {
    fn global_id(&self) -> &IfcGloballyUniqueId {
        &self.global_id
    }
    fn owner_history(&self) -> &Option<EntityRef> {
        &self.owner_history
    }
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
}
impl IIfcObjectDefinition for IfcGeographicElementType {}
impl IIfcTypeObject for IfcGeographicElementType {
    fn applicable_occurrence(&self) -> &Option<IfcIdentifier> {
        &self.applicable_occurrence
    }
    fn has_property_sets(&self) -> &Option<HashSet<EntityRef>> {
        &self.has_property_sets
    }
}
impl IIfcTypeProduct for IfcGeographicElementType {
    fn representation_maps(&self) -> &Option<Vec<EntityRef>> {
        &self.representation_maps
    }
    fn tag(&self) -> &Option<IfcLabel> {
        &self.tag
    }
}
impl IIfcElementType for IfcGeographicElementType {
    fn element_type(&self) -> &Option<IfcLabel> {
        &self.element_type
    }
}
impl IIfcGeographicElementType for IfcGeographicElementType {
    fn predefined_type(&self) -> &IfcGeographicElementTypeEnum {
        &self.predefined_type
    }
}
impl IfcGeographicElementType {
    pub fn from_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcGeographicElementType::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.global_id = parameter.into(),
                1usize => {
                    entity.owner_history = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => {
                    entity.applicable_occurrence = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                5usize => {
                    entity.has_property_sets = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                6usize => {
                    entity.representation_maps = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                7usize => {
                    entity.tag = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                8usize => {
                    entity.element_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                9usize => entity.predefined_type = parameter.into(),
                _ => {}
            }
        }
        entity
    }
    pub fn from_own_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcGeographicElementType::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.predefined_type = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcGeometricCurveSet: IIfcGeometricSet {}
#[derive(Default, Debug)]
pub struct IfcGeometricCurveSet {
    elements: HashSet<EntityRef>,
}
impl IIfcRepresentationItem for IfcGeometricCurveSet {}
impl IIfcGeometricRepresentationItem for IfcGeometricCurveSet {}
impl IIfcGeometricSet for IfcGeometricCurveSet {
    fn elements(&self) -> &HashSet<EntityRef> {
        &self.elements
    }
}
impl IIfcGeometricCurveSet for IfcGeometricCurveSet {}
impl IfcGeometricCurveSet {
    pub fn from_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcGeometricCurveSet::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.elements = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcGeometricRepresentationContext: IIfcRepresentationContext {
    fn coordinate_space_dimension(&self) -> &IfcDimensionCount;
    fn precision(&self) -> &Option<IfcReal>;
    fn world_coordinate_system(&self) -> &EntityRef;
    fn true_north(&self) -> &Option<EntityRef>;
}
#[derive(Default, Debug)]
pub struct IfcGeometricRepresentationContext {
    context_identifier: Option<IfcLabel>,
    context_type: Option<IfcLabel>,
    coordinate_space_dimension: IfcDimensionCount,
    precision: Option<IfcReal>,
    world_coordinate_system: EntityRef,
    true_north: Option<EntityRef>,
}
impl IIfcRepresentationContext for IfcGeometricRepresentationContext {
    fn context_identifier(&self) -> &Option<IfcLabel> {
        &self.context_identifier
    }
    fn context_type(&self) -> &Option<IfcLabel> {
        &self.context_type
    }
}
impl IIfcGeometricRepresentationContext for IfcGeometricRepresentationContext {
    fn coordinate_space_dimension(&self) -> &IfcDimensionCount {
        &self.coordinate_space_dimension
    }
    fn precision(&self) -> &Option<IfcReal> {
        &self.precision
    }
    fn world_coordinate_system(&self) -> &EntityRef {
        &self.world_coordinate_system
    }
    fn true_north(&self) -> &Option<EntityRef> {
        &self.true_north
    }
}
impl IfcGeometricRepresentationContext {
    pub fn from_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcGeometricRepresentationContext::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => {
                    entity.context_identifier = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                1usize => {
                    entity.context_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => entity.coordinate_space_dimension = parameter.into(),
                3usize => {
                    entity.precision = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => entity.world_coordinate_system = parameter.into(),
                5usize => {
                    entity.true_north = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
    pub fn from_own_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcGeometricRepresentationContext::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.coordinate_space_dimension = parameter.into(),
                1usize => {
                    entity.precision = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => entity.world_coordinate_system = parameter.into(),
                3usize => {
                    entity.true_north = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcGeometricRepresentationItem: IIfcRepresentationItem {}
pub trait IIfcGeometricRepresentationSubContext: IIfcGeometricRepresentationContext {
    fn parent_context(&self) -> &EntityRef;
    fn target_scale(&self) -> &Option<IfcPositiveRatioMeasure>;
    fn target_view(&self) -> &IfcGeometricProjectionEnum;
    fn user_defined_target_view(&self) -> &Option<IfcLabel>;
}
#[derive(Default, Debug)]
pub struct IfcGeometricRepresentationSubContext {
    context_identifier: Option<IfcLabel>,
    context_type: Option<IfcLabel>,
    coordinate_space_dimension: IfcDimensionCount,
    precision: Option<IfcReal>,
    world_coordinate_system: EntityRef,
    true_north: Option<EntityRef>,
    parent_context: EntityRef,
    target_scale: Option<IfcPositiveRatioMeasure>,
    target_view: IfcGeometricProjectionEnum,
    user_defined_target_view: Option<IfcLabel>,
}
impl IIfcRepresentationContext for IfcGeometricRepresentationSubContext {
    fn context_identifier(&self) -> &Option<IfcLabel> {
        &self.context_identifier
    }
    fn context_type(&self) -> &Option<IfcLabel> {
        &self.context_type
    }
}
impl IIfcGeometricRepresentationContext for IfcGeometricRepresentationSubContext {
    fn coordinate_space_dimension(&self) -> &IfcDimensionCount {
        &self.coordinate_space_dimension
    }
    fn precision(&self) -> &Option<IfcReal> {
        &self.precision
    }
    fn world_coordinate_system(&self) -> &EntityRef {
        &self.world_coordinate_system
    }
    fn true_north(&self) -> &Option<EntityRef> {
        &self.true_north
    }
}
impl IIfcGeometricRepresentationSubContext for IfcGeometricRepresentationSubContext {
    fn parent_context(&self) -> &EntityRef {
        &self.parent_context
    }
    fn target_scale(&self) -> &Option<IfcPositiveRatioMeasure> {
        &self.target_scale
    }
    fn target_view(&self) -> &IfcGeometricProjectionEnum {
        &self.target_view
    }
    fn user_defined_target_view(&self) -> &Option<IfcLabel> {
        &self.user_defined_target_view
    }
}
impl IfcGeometricRepresentationSubContext {
    pub fn from_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcGeometricRepresentationSubContext::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => {
                    entity.context_identifier = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                1usize => {
                    entity.context_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => entity.coordinate_space_dimension = parameter.into(),
                3usize => {
                    entity.precision = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => entity.world_coordinate_system = parameter.into(),
                5usize => {
                    entity.true_north = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                6usize => entity.parent_context = parameter.into(),
                7usize => {
                    entity.target_scale = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                8usize => entity.target_view = parameter.into(),
                9usize => {
                    entity.user_defined_target_view = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
    pub fn from_own_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcGeometricRepresentationSubContext::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.parent_context = parameter.into(),
                1usize => {
                    entity.target_scale = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => entity.target_view = parameter.into(),
                3usize => {
                    entity.user_defined_target_view = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcGeometricSet: IIfcGeometricRepresentationItem {
    fn elements(&self) -> &HashSet<EntityRef>;
}
#[derive(Default, Debug)]
pub struct IfcGeometricSet {
    elements: HashSet<EntityRef>,
}
impl IIfcRepresentationItem for IfcGeometricSet {}
impl IIfcGeometricRepresentationItem for IfcGeometricSet {}
impl IIfcGeometricSet for IfcGeometricSet {
    fn elements(&self) -> &HashSet<EntityRef> {
        &self.elements
    }
}
impl IfcGeometricSet {
    pub fn from_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcGeometricSet::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.elements = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcGrid: IIfcProduct {
    fn u_axes(&self) -> &Vec<EntityRef>;
    fn v_axes(&self) -> &Vec<EntityRef>;
    fn w_axes(&self) -> &Option<Vec<EntityRef>>;
    fn predefined_type(&self) -> &Option<IfcGridTypeEnum>;
}
#[derive(Default, Debug)]
pub struct IfcGrid {
    global_id: IfcGloballyUniqueId,
    owner_history: Option<EntityRef>,
    name: Option<IfcLabel>,
    description: Option<IfcText>,
    object_type: Option<IfcLabel>,
    object_placement: Option<EntityRef>,
    representation: Option<EntityRef>,
    u_axes: Vec<EntityRef>,
    v_axes: Vec<EntityRef>,
    w_axes: Option<Vec<EntityRef>>,
    predefined_type: Option<IfcGridTypeEnum>,
}
impl IIfcRoot for IfcGrid {
    fn global_id(&self) -> &IfcGloballyUniqueId {
        &self.global_id
    }
    fn owner_history(&self) -> &Option<EntityRef> {
        &self.owner_history
    }
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
}
impl IIfcObjectDefinition for IfcGrid {}
impl IIfcObject for IfcGrid {
    fn object_type(&self) -> &Option<IfcLabel> {
        &self.object_type
    }
}
impl IIfcProduct for IfcGrid {
    fn object_placement(&self) -> &Option<EntityRef> {
        &self.object_placement
    }
    fn representation(&self) -> &Option<EntityRef> {
        &self.representation
    }
}
impl IIfcGrid for IfcGrid {
    fn u_axes(&self) -> &Vec<EntityRef> {
        &self.u_axes
    }
    fn v_axes(&self) -> &Vec<EntityRef> {
        &self.v_axes
    }
    fn w_axes(&self) -> &Option<Vec<EntityRef>> {
        &self.w_axes
    }
    fn predefined_type(&self) -> &Option<IfcGridTypeEnum> {
        &self.predefined_type
    }
}
impl IfcGrid {
    pub fn from_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcGrid::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.global_id = parameter.into(),
                1usize => {
                    entity.owner_history = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => {
                    entity.object_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                5usize => {
                    entity.object_placement = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                6usize => {
                    entity.representation = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                7usize => entity.u_axes = parameter.into(),
                8usize => entity.v_axes = parameter.into(),
                9usize => {
                    entity.w_axes = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                10usize => {
                    entity.predefined_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
    pub fn from_own_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcGrid::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.u_axes = parameter.into(),
                1usize => entity.v_axes = parameter.into(),
                2usize => {
                    entity.w_axes = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.predefined_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcGridAxis {
    fn axis_tag(&self) -> &Option<IfcLabel>;
    fn axis_curve(&self) -> &EntityRef;
    fn same_sense(&self) -> &IfcBoolean;
}
#[derive(Default, Debug)]
pub struct IfcGridAxis {
    axis_tag: Option<IfcLabel>,
    axis_curve: EntityRef,
    same_sense: IfcBoolean,
}
impl IIfcGridAxis for IfcGridAxis {
    fn axis_tag(&self) -> &Option<IfcLabel> {
        &self.axis_tag
    }
    fn axis_curve(&self) -> &EntityRef {
        &self.axis_curve
    }
    fn same_sense(&self) -> &IfcBoolean {
        &self.same_sense
    }
}
impl IfcGridAxis {
    pub fn from_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcGridAxis::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => {
                    entity.axis_tag = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                1usize => entity.axis_curve = parameter.into(),
                2usize => entity.same_sense = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcGridPlacement: IIfcObjectPlacement {
    fn placement_location(&self) -> &EntityRef;
    fn placement_ref_direction(&self) -> &Option<EntityRef>;
}
#[derive(Default, Debug)]
pub struct IfcGridPlacement {
    placement_location: EntityRef,
    placement_ref_direction: Option<EntityRef>,
}
impl IIfcObjectPlacement for IfcGridPlacement {}
impl IIfcGridPlacement for IfcGridPlacement {
    fn placement_location(&self) -> &EntityRef {
        &self.placement_location
    }
    fn placement_ref_direction(&self) -> &Option<EntityRef> {
        &self.placement_ref_direction
    }
}
impl IfcGridPlacement {
    pub fn from_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcGridPlacement::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.placement_location = parameter.into(),
                1usize => {
                    entity.placement_ref_direction = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcGroup: IIfcObject {}
#[derive(Default, Debug)]
pub struct IfcGroup {
    global_id: IfcGloballyUniqueId,
    owner_history: Option<EntityRef>,
    name: Option<IfcLabel>,
    description: Option<IfcText>,
    object_type: Option<IfcLabel>,
}
impl IIfcRoot for IfcGroup {
    fn global_id(&self) -> &IfcGloballyUniqueId {
        &self.global_id
    }
    fn owner_history(&self) -> &Option<EntityRef> {
        &self.owner_history
    }
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
}
impl IIfcObjectDefinition for IfcGroup {}
impl IIfcObject for IfcGroup {
    fn object_type(&self) -> &Option<IfcLabel> {
        &self.object_type
    }
}
impl IIfcGroup for IfcGroup {}
impl IfcGroup {
    pub fn from_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcGroup::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.global_id = parameter.into(),
                1usize => {
                    entity.owner_history = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => {
                    entity.object_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcHalfSpaceSolid: IIfcGeometricRepresentationItem {
    fn base_surface(&self) -> &EntityRef;
    fn agreement_flag(&self) -> &IfcBoolean;
}
#[derive(Default, Debug)]
pub struct IfcHalfSpaceSolid {
    base_surface: EntityRef,
    agreement_flag: IfcBoolean,
}
impl IIfcRepresentationItem for IfcHalfSpaceSolid {}
impl IIfcGeometricRepresentationItem for IfcHalfSpaceSolid {}
impl IIfcHalfSpaceSolid for IfcHalfSpaceSolid {
    fn base_surface(&self) -> &EntityRef {
        &self.base_surface
    }
    fn agreement_flag(&self) -> &IfcBoolean {
        &self.agreement_flag
    }
}
impl IfcHalfSpaceSolid {
    pub fn from_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcHalfSpaceSolid::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.base_surface = parameter.into(),
                1usize => entity.agreement_flag = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcHeatExchanger: IIfcEnergyConversionDevice {
    fn predefined_type(&self) -> &Option<IfcHeatExchangerTypeEnum>;
}
#[derive(Default, Debug)]
pub struct IfcHeatExchanger {
    global_id: IfcGloballyUniqueId,
    owner_history: Option<EntityRef>,
    name: Option<IfcLabel>,
    description: Option<IfcText>,
    object_type: Option<IfcLabel>,
    object_placement: Option<EntityRef>,
    representation: Option<EntityRef>,
    tag: Option<IfcIdentifier>,
    predefined_type: Option<IfcHeatExchangerTypeEnum>,
}
impl IIfcRoot for IfcHeatExchanger {
    fn global_id(&self) -> &IfcGloballyUniqueId {
        &self.global_id
    }
    fn owner_history(&self) -> &Option<EntityRef> {
        &self.owner_history
    }
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
}
impl IIfcObjectDefinition for IfcHeatExchanger {}
impl IIfcObject for IfcHeatExchanger {
    fn object_type(&self) -> &Option<IfcLabel> {
        &self.object_type
    }
}
impl IIfcProduct for IfcHeatExchanger {
    fn object_placement(&self) -> &Option<EntityRef> {
        &self.object_placement
    }
    fn representation(&self) -> &Option<EntityRef> {
        &self.representation
    }
}
impl IIfcElement for IfcHeatExchanger {
    fn tag(&self) -> &Option<IfcIdentifier> {
        &self.tag
    }
}
impl IIfcDistributionElement for IfcHeatExchanger {}
impl IIfcDistributionFlowElement for IfcHeatExchanger {}
impl IIfcEnergyConversionDevice for IfcHeatExchanger {}
impl IIfcHeatExchanger for IfcHeatExchanger {
    fn predefined_type(&self) -> &Option<IfcHeatExchangerTypeEnum> {
        &self.predefined_type
    }
}
impl IfcHeatExchanger {
    pub fn from_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcHeatExchanger::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.global_id = parameter.into(),
                1usize => {
                    entity.owner_history = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => {
                    entity.object_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                5usize => {
                    entity.object_placement = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                6usize => {
                    entity.representation = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                7usize => {
                    entity.tag = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                8usize => {
                    entity.predefined_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
    pub fn from_own_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcHeatExchanger::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => {
                    entity.predefined_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcHeatExchangerType: IIfcEnergyConversionDeviceType {
    fn predefined_type(&self) -> &IfcHeatExchangerTypeEnum;
}
#[derive(Default, Debug)]
pub struct IfcHeatExchangerType {
    global_id: IfcGloballyUniqueId,
    owner_history: Option<EntityRef>,
    name: Option<IfcLabel>,
    description: Option<IfcText>,
    applicable_occurrence: Option<IfcIdentifier>,
    has_property_sets: Option<HashSet<EntityRef>>,
    representation_maps: Option<Vec<EntityRef>>,
    tag: Option<IfcLabel>,
    element_type: Option<IfcLabel>,
    predefined_type: IfcHeatExchangerTypeEnum,
}
impl IIfcRoot for IfcHeatExchangerType {
    fn global_id(&self) -> &IfcGloballyUniqueId {
        &self.global_id
    }
    fn owner_history(&self) -> &Option<EntityRef> {
        &self.owner_history
    }
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
}
impl IIfcObjectDefinition for IfcHeatExchangerType {}
impl IIfcTypeObject for IfcHeatExchangerType {
    fn applicable_occurrence(&self) -> &Option<IfcIdentifier> {
        &self.applicable_occurrence
    }
    fn has_property_sets(&self) -> &Option<HashSet<EntityRef>> {
        &self.has_property_sets
    }
}
impl IIfcTypeProduct for IfcHeatExchangerType {
    fn representation_maps(&self) -> &Option<Vec<EntityRef>> {
        &self.representation_maps
    }
    fn tag(&self) -> &Option<IfcLabel> {
        &self.tag
    }
}
impl IIfcElementType for IfcHeatExchangerType {
    fn element_type(&self) -> &Option<IfcLabel> {
        &self.element_type
    }
}
impl IIfcDistributionElementType for IfcHeatExchangerType {}
impl IIfcDistributionFlowElementType for IfcHeatExchangerType {}
impl IIfcEnergyConversionDeviceType for IfcHeatExchangerType {}
impl IIfcHeatExchangerType for IfcHeatExchangerType {
    fn predefined_type(&self) -> &IfcHeatExchangerTypeEnum {
        &self.predefined_type
    }
}
impl IfcHeatExchangerType {
    pub fn from_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcHeatExchangerType::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.global_id = parameter.into(),
                1usize => {
                    entity.owner_history = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => {
                    entity.applicable_occurrence = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                5usize => {
                    entity.has_property_sets = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                6usize => {
                    entity.representation_maps = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                7usize => {
                    entity.tag = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                8usize => {
                    entity.element_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                9usize => entity.predefined_type = parameter.into(),
                _ => {}
            }
        }
        entity
    }
    pub fn from_own_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcHeatExchangerType::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.predefined_type = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcHumidifier: IIfcEnergyConversionDevice {
    fn predefined_type(&self) -> &Option<IfcHumidifierTypeEnum>;
}
#[derive(Default, Debug)]
pub struct IfcHumidifier {
    global_id: IfcGloballyUniqueId,
    owner_history: Option<EntityRef>,
    name: Option<IfcLabel>,
    description: Option<IfcText>,
    object_type: Option<IfcLabel>,
    object_placement: Option<EntityRef>,
    representation: Option<EntityRef>,
    tag: Option<IfcIdentifier>,
    predefined_type: Option<IfcHumidifierTypeEnum>,
}
impl IIfcRoot for IfcHumidifier {
    fn global_id(&self) -> &IfcGloballyUniqueId {
        &self.global_id
    }
    fn owner_history(&self) -> &Option<EntityRef> {
        &self.owner_history
    }
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
}
impl IIfcObjectDefinition for IfcHumidifier {}
impl IIfcObject for IfcHumidifier {
    fn object_type(&self) -> &Option<IfcLabel> {
        &self.object_type
    }
}
impl IIfcProduct for IfcHumidifier {
    fn object_placement(&self) -> &Option<EntityRef> {
        &self.object_placement
    }
    fn representation(&self) -> &Option<EntityRef> {
        &self.representation
    }
}
impl IIfcElement for IfcHumidifier {
    fn tag(&self) -> &Option<IfcIdentifier> {
        &self.tag
    }
}
impl IIfcDistributionElement for IfcHumidifier {}
impl IIfcDistributionFlowElement for IfcHumidifier {}
impl IIfcEnergyConversionDevice for IfcHumidifier {}
impl IIfcHumidifier for IfcHumidifier {
    fn predefined_type(&self) -> &Option<IfcHumidifierTypeEnum> {
        &self.predefined_type
    }
}
impl IfcHumidifier {
    pub fn from_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcHumidifier::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.global_id = parameter.into(),
                1usize => {
                    entity.owner_history = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => {
                    entity.object_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                5usize => {
                    entity.object_placement = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                6usize => {
                    entity.representation = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                7usize => {
                    entity.tag = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                8usize => {
                    entity.predefined_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
    pub fn from_own_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcHumidifier::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => {
                    entity.predefined_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcHumidifierType: IIfcEnergyConversionDeviceType {
    fn predefined_type(&self) -> &IfcHumidifierTypeEnum;
}
#[derive(Default, Debug)]
pub struct IfcHumidifierType {
    global_id: IfcGloballyUniqueId,
    owner_history: Option<EntityRef>,
    name: Option<IfcLabel>,
    description: Option<IfcText>,
    applicable_occurrence: Option<IfcIdentifier>,
    has_property_sets: Option<HashSet<EntityRef>>,
    representation_maps: Option<Vec<EntityRef>>,
    tag: Option<IfcLabel>,
    element_type: Option<IfcLabel>,
    predefined_type: IfcHumidifierTypeEnum,
}
impl IIfcRoot for IfcHumidifierType {
    fn global_id(&self) -> &IfcGloballyUniqueId {
        &self.global_id
    }
    fn owner_history(&self) -> &Option<EntityRef> {
        &self.owner_history
    }
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
}
impl IIfcObjectDefinition for IfcHumidifierType {}
impl IIfcTypeObject for IfcHumidifierType {
    fn applicable_occurrence(&self) -> &Option<IfcIdentifier> {
        &self.applicable_occurrence
    }
    fn has_property_sets(&self) -> &Option<HashSet<EntityRef>> {
        &self.has_property_sets
    }
}
impl IIfcTypeProduct for IfcHumidifierType {
    fn representation_maps(&self) -> &Option<Vec<EntityRef>> {
        &self.representation_maps
    }
    fn tag(&self) -> &Option<IfcLabel> {
        &self.tag
    }
}
impl IIfcElementType for IfcHumidifierType {
    fn element_type(&self) -> &Option<IfcLabel> {
        &self.element_type
    }
}
impl IIfcDistributionElementType for IfcHumidifierType {}
impl IIfcDistributionFlowElementType for IfcHumidifierType {}
impl IIfcEnergyConversionDeviceType for IfcHumidifierType {}
impl IIfcHumidifierType for IfcHumidifierType {
    fn predefined_type(&self) -> &IfcHumidifierTypeEnum {
        &self.predefined_type
    }
}
impl IfcHumidifierType {
    pub fn from_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcHumidifierType::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.global_id = parameter.into(),
                1usize => {
                    entity.owner_history = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => {
                    entity.applicable_occurrence = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                5usize => {
                    entity.has_property_sets = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                6usize => {
                    entity.representation_maps = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                7usize => {
                    entity.tag = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                8usize => {
                    entity.element_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                9usize => entity.predefined_type = parameter.into(),
                _ => {}
            }
        }
        entity
    }
    pub fn from_own_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcHumidifierType::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.predefined_type = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcIShapeProfileDef: IIfcParameterizedProfileDef {
    fn overall_width(&self) -> &IfcPositiveLengthMeasure;
    fn overall_depth(&self) -> &IfcPositiveLengthMeasure;
    fn web_thickness(&self) -> &IfcPositiveLengthMeasure;
    fn flange_thickness(&self) -> &IfcPositiveLengthMeasure;
    fn fillet_radius(&self) -> &Option<IfcNonNegativeLengthMeasure>;
    fn flange_edge_radius(&self) -> &Option<IfcNonNegativeLengthMeasure>;
    fn flange_slope(&self) -> &Option<IfcPlaneAngleMeasure>;
}
#[derive(Default, Debug)]
pub struct IfcIShapeProfileDef {
    profile_type: IfcProfileTypeEnum,
    profile_name: Option<IfcLabel>,
    position: Option<EntityRef>,
    overall_width: IfcPositiveLengthMeasure,
    overall_depth: IfcPositiveLengthMeasure,
    web_thickness: IfcPositiveLengthMeasure,
    flange_thickness: IfcPositiveLengthMeasure,
    fillet_radius: Option<IfcNonNegativeLengthMeasure>,
    flange_edge_radius: Option<IfcNonNegativeLengthMeasure>,
    flange_slope: Option<IfcPlaneAngleMeasure>,
}
impl IIfcProfileDef for IfcIShapeProfileDef {
    fn profile_type(&self) -> &IfcProfileTypeEnum {
        &self.profile_type
    }
    fn profile_name(&self) -> &Option<IfcLabel> {
        &self.profile_name
    }
}
impl IIfcParameterizedProfileDef for IfcIShapeProfileDef {
    fn position(&self) -> &Option<EntityRef> {
        &self.position
    }
}
impl IIfcIShapeProfileDef for IfcIShapeProfileDef {
    fn overall_width(&self) -> &IfcPositiveLengthMeasure {
        &self.overall_width
    }
    fn overall_depth(&self) -> &IfcPositiveLengthMeasure {
        &self.overall_depth
    }
    fn web_thickness(&self) -> &IfcPositiveLengthMeasure {
        &self.web_thickness
    }
    fn flange_thickness(&self) -> &IfcPositiveLengthMeasure {
        &self.flange_thickness
    }
    fn fillet_radius(&self) -> &Option<IfcNonNegativeLengthMeasure> {
        &self.fillet_radius
    }
    fn flange_edge_radius(&self) -> &Option<IfcNonNegativeLengthMeasure> {
        &self.flange_edge_radius
    }
    fn flange_slope(&self) -> &Option<IfcPlaneAngleMeasure> {
        &self.flange_slope
    }
}
impl IfcIShapeProfileDef {
    pub fn from_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcIShapeProfileDef::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.profile_type = parameter.into(),
                1usize => {
                    entity.profile_name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => {
                    entity.position = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => entity.overall_width = parameter.into(),
                4usize => entity.overall_depth = parameter.into(),
                5usize => entity.web_thickness = parameter.into(),
                6usize => entity.flange_thickness = parameter.into(),
                7usize => {
                    entity.fillet_radius = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                8usize => {
                    entity.flange_edge_radius = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                9usize => {
                    entity.flange_slope = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
    pub fn from_own_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcIShapeProfileDef::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.overall_width = parameter.into(),
                1usize => entity.overall_depth = parameter.into(),
                2usize => entity.web_thickness = parameter.into(),
                3usize => entity.flange_thickness = parameter.into(),
                4usize => {
                    entity.fillet_radius = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                5usize => {
                    entity.flange_edge_radius = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                6usize => {
                    entity.flange_slope = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcImageTexture: IIfcSurfaceTexture {
    fn url_reference(&self) -> &IfcUriReference;
}
#[derive(Default, Debug)]
pub struct IfcImageTexture {
    repeat_s: IfcBoolean,
    repeat_t: IfcBoolean,
    mode: Option<IfcIdentifier>,
    texture_transform: Option<EntityRef>,
    parameter: Option<Vec<IfcIdentifier>>,
    url_reference: IfcUriReference,
}
impl IIfcPresentationItem for IfcImageTexture {}
impl IIfcSurfaceTexture for IfcImageTexture {
    fn repeat_s(&self) -> &IfcBoolean {
        &self.repeat_s
    }
    fn repeat_t(&self) -> &IfcBoolean {
        &self.repeat_t
    }
    fn mode(&self) -> &Option<IfcIdentifier> {
        &self.mode
    }
    fn texture_transform(&self) -> &Option<EntityRef> {
        &self.texture_transform
    }
    fn parameter(&self) -> &Option<Vec<IfcIdentifier>> {
        &self.parameter
    }
}
impl IIfcImageTexture for IfcImageTexture {
    fn url_reference(&self) -> &IfcUriReference {
        &self.url_reference
    }
}
impl IfcImageTexture {
    pub fn from_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcImageTexture::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.repeat_s = parameter.into(),
                1usize => entity.repeat_t = parameter.into(),
                2usize => {
                    entity.mode = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.texture_transform = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => {
                    entity.parameter = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                5usize => entity.url_reference = parameter.into(),
                _ => {}
            }
        }
        entity
    }
    pub fn from_own_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcImageTexture::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.url_reference = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcIndexedColourMap: IIfcPresentationItem {
    fn mapped_to(&self) -> &EntityRef;
    fn opacity(&self) -> &Option<IfcNormalisedRatioMeasure>;
    fn colours(&self) -> &EntityRef;
    fn colour_index(&self) -> &Vec<IfcPositiveInteger>;
}
#[derive(Default, Debug)]
pub struct IfcIndexedColourMap {
    mapped_to: EntityRef,
    opacity: Option<IfcNormalisedRatioMeasure>,
    colours: EntityRef,
    colour_index: Vec<IfcPositiveInteger>,
}
impl IIfcPresentationItem for IfcIndexedColourMap {}
impl IIfcIndexedColourMap for IfcIndexedColourMap {
    fn mapped_to(&self) -> &EntityRef {
        &self.mapped_to
    }
    fn opacity(&self) -> &Option<IfcNormalisedRatioMeasure> {
        &self.opacity
    }
    fn colours(&self) -> &EntityRef {
        &self.colours
    }
    fn colour_index(&self) -> &Vec<IfcPositiveInteger> {
        &self.colour_index
    }
}
impl IfcIndexedColourMap {
    pub fn from_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcIndexedColourMap::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.mapped_to = parameter.into(),
                1usize => {
                    entity.opacity = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => entity.colours = parameter.into(),
                3usize => entity.colour_index = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcIndexedPolyCurve: IIfcBoundedCurve {
    fn points(&self) -> &EntityRef;
    fn segments(&self) -> &Option<Vec<IfcSegmentIndexSelect>>;
    fn self_intersect(&self) -> &Option<IfcBoolean>;
}
#[derive(Default, Debug)]
pub struct IfcIndexedPolyCurve {
    points: EntityRef,
    segments: Option<Vec<IfcSegmentIndexSelect>>,
    self_intersect: Option<IfcBoolean>,
}
impl IIfcRepresentationItem for IfcIndexedPolyCurve {}
impl IIfcGeometricRepresentationItem for IfcIndexedPolyCurve {}
impl IIfcCurve for IfcIndexedPolyCurve {}
impl IIfcBoundedCurve for IfcIndexedPolyCurve {}
impl IIfcIndexedPolyCurve for IfcIndexedPolyCurve {
    fn points(&self) -> &EntityRef {
        &self.points
    }
    fn segments(&self) -> &Option<Vec<IfcSegmentIndexSelect>> {
        &self.segments
    }
    fn self_intersect(&self) -> &Option<IfcBoolean> {
        &self.self_intersect
    }
}
impl IfcIndexedPolyCurve {
    pub fn from_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcIndexedPolyCurve::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.points = parameter.into(),
                1usize => {
                    entity.segments = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => {
                    entity.self_intersect = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcIndexedPolygonalFace: IIfcTessellatedItem {
    fn coord_index(&self) -> &Vec<IfcPositiveInteger>;
}
#[derive(Default, Debug)]
pub struct IfcIndexedPolygonalFace {
    coord_index: Vec<IfcPositiveInteger>,
}
impl IIfcRepresentationItem for IfcIndexedPolygonalFace {}
impl IIfcGeometricRepresentationItem for IfcIndexedPolygonalFace {}
impl IIfcTessellatedItem for IfcIndexedPolygonalFace {}
impl IIfcIndexedPolygonalFace for IfcIndexedPolygonalFace {
    fn coord_index(&self) -> &Vec<IfcPositiveInteger> {
        &self.coord_index
    }
}
impl IfcIndexedPolygonalFace {
    pub fn from_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcIndexedPolygonalFace::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.coord_index = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcIndexedPolygonalFaceWithVoids: IIfcIndexedPolygonalFace {
    fn inner_coord_indices(&self) -> &Vec<Vec<IfcPositiveInteger>>;
}
#[derive(Default, Debug)]
pub struct IfcIndexedPolygonalFaceWithVoids {
    coord_index: Vec<IfcPositiveInteger>,
    inner_coord_indices: Vec<Vec<IfcPositiveInteger>>,
}
impl IIfcRepresentationItem for IfcIndexedPolygonalFaceWithVoids {}
impl IIfcGeometricRepresentationItem for IfcIndexedPolygonalFaceWithVoids {}
impl IIfcTessellatedItem for IfcIndexedPolygonalFaceWithVoids {}
impl IIfcIndexedPolygonalFace for IfcIndexedPolygonalFaceWithVoids {
    fn coord_index(&self) -> &Vec<IfcPositiveInteger> {
        &self.coord_index
    }
}
impl IIfcIndexedPolygonalFaceWithVoids for IfcIndexedPolygonalFaceWithVoids {
    fn inner_coord_indices(&self) -> &Vec<Vec<IfcPositiveInteger>> {
        &self.inner_coord_indices
    }
}
impl IfcIndexedPolygonalFaceWithVoids {
    pub fn from_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcIndexedPolygonalFaceWithVoids::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.coord_index = parameter.into(),
                1usize => entity.inner_coord_indices = parameter.into(),
                _ => {}
            }
        }
        entity
    }
    pub fn from_own_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcIndexedPolygonalFaceWithVoids::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.inner_coord_indices = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcIndexedTextureMap: IIfcTextureCoordinate {
    fn mapped_to(&self) -> &EntityRef;
    fn tex_coords(&self) -> &EntityRef;
}
pub trait IIfcIndexedTriangleTextureMap: IIfcIndexedTextureMap {
    fn tex_coord_index(&self) -> &Option<Vec<Vec<IfcPositiveInteger>>>;
}
#[derive(Default, Debug)]
pub struct IfcIndexedTriangleTextureMap {
    maps: Vec<EntityRef>,
    mapped_to: EntityRef,
    tex_coords: EntityRef,
    tex_coord_index: Option<Vec<Vec<IfcPositiveInteger>>>,
}
impl IIfcPresentationItem for IfcIndexedTriangleTextureMap {}
impl IIfcTextureCoordinate for IfcIndexedTriangleTextureMap {
    fn maps(&self) -> &Vec<EntityRef> {
        &self.maps
    }
}
impl IIfcIndexedTextureMap for IfcIndexedTriangleTextureMap {
    fn mapped_to(&self) -> &EntityRef {
        &self.mapped_to
    }
    fn tex_coords(&self) -> &EntityRef {
        &self.tex_coords
    }
}
impl IIfcIndexedTriangleTextureMap for IfcIndexedTriangleTextureMap {
    fn tex_coord_index(&self) -> &Option<Vec<Vec<IfcPositiveInteger>>> {
        &self.tex_coord_index
    }
}
impl IfcIndexedTriangleTextureMap {
    pub fn from_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcIndexedTriangleTextureMap::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.maps = parameter.into(),
                1usize => entity.mapped_to = parameter.into(),
                2usize => entity.tex_coords = parameter.into(),
                3usize => {
                    entity.tex_coord_index = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
    pub fn from_own_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcIndexedTriangleTextureMap::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => {
                    entity.tex_coord_index = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcInterceptor: IIfcFlowTreatmentDevice {
    fn predefined_type(&self) -> &Option<IfcInterceptorTypeEnum>;
}
#[derive(Default, Debug)]
pub struct IfcInterceptor {
    global_id: IfcGloballyUniqueId,
    owner_history: Option<EntityRef>,
    name: Option<IfcLabel>,
    description: Option<IfcText>,
    object_type: Option<IfcLabel>,
    object_placement: Option<EntityRef>,
    representation: Option<EntityRef>,
    tag: Option<IfcIdentifier>,
    predefined_type: Option<IfcInterceptorTypeEnum>,
}
impl IIfcRoot for IfcInterceptor {
    fn global_id(&self) -> &IfcGloballyUniqueId {
        &self.global_id
    }
    fn owner_history(&self) -> &Option<EntityRef> {
        &self.owner_history
    }
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
}
impl IIfcObjectDefinition for IfcInterceptor {}
impl IIfcObject for IfcInterceptor {
    fn object_type(&self) -> &Option<IfcLabel> {
        &self.object_type
    }
}
impl IIfcProduct for IfcInterceptor {
    fn object_placement(&self) -> &Option<EntityRef> {
        &self.object_placement
    }
    fn representation(&self) -> &Option<EntityRef> {
        &self.representation
    }
}
impl IIfcElement for IfcInterceptor {
    fn tag(&self) -> &Option<IfcIdentifier> {
        &self.tag
    }
}
impl IIfcDistributionElement for IfcInterceptor {}
impl IIfcDistributionFlowElement for IfcInterceptor {}
impl IIfcFlowTreatmentDevice for IfcInterceptor {}
impl IIfcInterceptor for IfcInterceptor {
    fn predefined_type(&self) -> &Option<IfcInterceptorTypeEnum> {
        &self.predefined_type
    }
}
impl IfcInterceptor {
    pub fn from_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcInterceptor::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.global_id = parameter.into(),
                1usize => {
                    entity.owner_history = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => {
                    entity.object_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                5usize => {
                    entity.object_placement = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                6usize => {
                    entity.representation = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                7usize => {
                    entity.tag = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                8usize => {
                    entity.predefined_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
    pub fn from_own_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcInterceptor::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => {
                    entity.predefined_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcInterceptorType: IIfcFlowTreatmentDeviceType {
    fn predefined_type(&self) -> &IfcInterceptorTypeEnum;
}
#[derive(Default, Debug)]
pub struct IfcInterceptorType {
    global_id: IfcGloballyUniqueId,
    owner_history: Option<EntityRef>,
    name: Option<IfcLabel>,
    description: Option<IfcText>,
    applicable_occurrence: Option<IfcIdentifier>,
    has_property_sets: Option<HashSet<EntityRef>>,
    representation_maps: Option<Vec<EntityRef>>,
    tag: Option<IfcLabel>,
    element_type: Option<IfcLabel>,
    predefined_type: IfcInterceptorTypeEnum,
}
impl IIfcRoot for IfcInterceptorType {
    fn global_id(&self) -> &IfcGloballyUniqueId {
        &self.global_id
    }
    fn owner_history(&self) -> &Option<EntityRef> {
        &self.owner_history
    }
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
}
impl IIfcObjectDefinition for IfcInterceptorType {}
impl IIfcTypeObject for IfcInterceptorType {
    fn applicable_occurrence(&self) -> &Option<IfcIdentifier> {
        &self.applicable_occurrence
    }
    fn has_property_sets(&self) -> &Option<HashSet<EntityRef>> {
        &self.has_property_sets
    }
}
impl IIfcTypeProduct for IfcInterceptorType {
    fn representation_maps(&self) -> &Option<Vec<EntityRef>> {
        &self.representation_maps
    }
    fn tag(&self) -> &Option<IfcLabel> {
        &self.tag
    }
}
impl IIfcElementType for IfcInterceptorType {
    fn element_type(&self) -> &Option<IfcLabel> {
        &self.element_type
    }
}
impl IIfcDistributionElementType for IfcInterceptorType {}
impl IIfcDistributionFlowElementType for IfcInterceptorType {}
impl IIfcFlowTreatmentDeviceType for IfcInterceptorType {}
impl IIfcInterceptorType for IfcInterceptorType {
    fn predefined_type(&self) -> &IfcInterceptorTypeEnum {
        &self.predefined_type
    }
}
impl IfcInterceptorType {
    pub fn from_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcInterceptorType::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.global_id = parameter.into(),
                1usize => {
                    entity.owner_history = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => {
                    entity.applicable_occurrence = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                5usize => {
                    entity.has_property_sets = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                6usize => {
                    entity.representation_maps = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                7usize => {
                    entity.tag = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                8usize => {
                    entity.element_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                9usize => entity.predefined_type = parameter.into(),
                _ => {}
            }
        }
        entity
    }
    pub fn from_own_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcInterceptorType::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.predefined_type = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcIntersectionCurve: IIfcSurfaceCurve {}
#[derive(Default, Debug)]
pub struct IfcIntersectionCurve {
    curve3_d: EntityRef,
    associated_geometry: Vec<EntityRef>,
    master_representation: IfcPreferredSurfaceCurveRepresentation,
}
impl IIfcRepresentationItem for IfcIntersectionCurve {}
impl IIfcGeometricRepresentationItem for IfcIntersectionCurve {}
impl IIfcCurve for IfcIntersectionCurve {}
impl IIfcSurfaceCurve for IfcIntersectionCurve {
    fn curve3_d(&self) -> &EntityRef {
        &self.curve3_d
    }
    fn associated_geometry(&self) -> &Vec<EntityRef> {
        &self.associated_geometry
    }
    fn master_representation(&self) -> &IfcPreferredSurfaceCurveRepresentation {
        &self.master_representation
    }
}
impl IIfcIntersectionCurve for IfcIntersectionCurve {}
impl IfcIntersectionCurve {
    pub fn from_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcIntersectionCurve::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.curve3_d = parameter.into(),
                1usize => entity.associated_geometry = parameter.into(),
                2usize => entity.master_representation = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcInventory: IIfcGroup {
    fn predefined_type(&self) -> &Option<IfcInventoryTypeEnum>;
    fn jurisdiction(&self) -> &Option<EntityRef>;
    fn responsible_persons(&self) -> &Option<HashSet<EntityRef>>;
    fn last_update_date(&self) -> &Option<IfcDate>;
    fn current_value(&self) -> &Option<EntityRef>;
    fn original_value(&self) -> &Option<EntityRef>;
}
#[derive(Default, Debug)]
pub struct IfcInventory {
    global_id: IfcGloballyUniqueId,
    owner_history: Option<EntityRef>,
    name: Option<IfcLabel>,
    description: Option<IfcText>,
    object_type: Option<IfcLabel>,
    predefined_type: Option<IfcInventoryTypeEnum>,
    jurisdiction: Option<EntityRef>,
    responsible_persons: Option<HashSet<EntityRef>>,
    last_update_date: Option<IfcDate>,
    current_value: Option<EntityRef>,
    original_value: Option<EntityRef>,
}
impl IIfcRoot for IfcInventory {
    fn global_id(&self) -> &IfcGloballyUniqueId {
        &self.global_id
    }
    fn owner_history(&self) -> &Option<EntityRef> {
        &self.owner_history
    }
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
}
impl IIfcObjectDefinition for IfcInventory {}
impl IIfcObject for IfcInventory {
    fn object_type(&self) -> &Option<IfcLabel> {
        &self.object_type
    }
}
impl IIfcGroup for IfcInventory {}
impl IIfcInventory for IfcInventory {
    fn predefined_type(&self) -> &Option<IfcInventoryTypeEnum> {
        &self.predefined_type
    }
    fn jurisdiction(&self) -> &Option<EntityRef> {
        &self.jurisdiction
    }
    fn responsible_persons(&self) -> &Option<HashSet<EntityRef>> {
        &self.responsible_persons
    }
    fn last_update_date(&self) -> &Option<IfcDate> {
        &self.last_update_date
    }
    fn current_value(&self) -> &Option<EntityRef> {
        &self.current_value
    }
    fn original_value(&self) -> &Option<EntityRef> {
        &self.original_value
    }
}
impl IfcInventory {
    pub fn from_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcInventory::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.global_id = parameter.into(),
                1usize => {
                    entity.owner_history = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => {
                    entity.object_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                5usize => {
                    entity.predefined_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                6usize => {
                    entity.jurisdiction = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                7usize => {
                    entity.responsible_persons = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                8usize => {
                    entity.last_update_date = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                9usize => {
                    entity.current_value = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                10usize => {
                    entity.original_value = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
    pub fn from_own_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcInventory::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => {
                    entity.predefined_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                1usize => {
                    entity.jurisdiction = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => {
                    entity.responsible_persons = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.last_update_date = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => {
                    entity.current_value = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                5usize => {
                    entity.original_value = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcIrregularTimeSeries: IIfcTimeSeries {
    fn values(&self) -> &Vec<EntityRef>;
}
#[derive(Default, Debug)]
pub struct IfcIrregularTimeSeries {
    name: IfcLabel,
    description: Option<IfcText>,
    start_time: IfcDateTime,
    end_time: IfcDateTime,
    time_series_data_type: IfcTimeSeriesDataTypeEnum,
    data_origin: IfcDataOriginEnum,
    user_defined_data_origin: Option<IfcLabel>,
    unit: Option<EntityRef>,
    values: Vec<EntityRef>,
}
impl IIfcTimeSeries for IfcIrregularTimeSeries {
    fn name(&self) -> &IfcLabel {
        &self.name
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
    fn start_time(&self) -> &IfcDateTime {
        &self.start_time
    }
    fn end_time(&self) -> &IfcDateTime {
        &self.end_time
    }
    fn time_series_data_type(&self) -> &IfcTimeSeriesDataTypeEnum {
        &self.time_series_data_type
    }
    fn data_origin(&self) -> &IfcDataOriginEnum {
        &self.data_origin
    }
    fn user_defined_data_origin(&self) -> &Option<IfcLabel> {
        &self.user_defined_data_origin
    }
    fn unit(&self) -> &Option<EntityRef> {
        &self.unit
    }
}
impl IIfcIrregularTimeSeries for IfcIrregularTimeSeries {
    fn values(&self) -> &Vec<EntityRef> {
        &self.values
    }
}
impl IfcIrregularTimeSeries {
    pub fn from_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcIrregularTimeSeries::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => entity.start_time = parameter.into(),
                3usize => entity.end_time = parameter.into(),
                4usize => entity.time_series_data_type = parameter.into(),
                5usize => entity.data_origin = parameter.into(),
                6usize => {
                    entity.user_defined_data_origin = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                7usize => {
                    entity.unit = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                8usize => entity.values = parameter.into(),
                _ => {}
            }
        }
        entity
    }
    pub fn from_own_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcIrregularTimeSeries::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.values = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcIrregularTimeSeriesValue {
    fn time_stamp(&self) -> &IfcDateTime;
    fn list_values(&self) -> &Vec<IfcValue>;
}
#[derive(Default, Debug)]
pub struct IfcIrregularTimeSeriesValue {
    time_stamp: IfcDateTime,
    list_values: Vec<IfcValue>,
}
impl IIfcIrregularTimeSeriesValue for IfcIrregularTimeSeriesValue {
    fn time_stamp(&self) -> &IfcDateTime {
        &self.time_stamp
    }
    fn list_values(&self) -> &Vec<IfcValue> {
        &self.list_values
    }
}
impl IfcIrregularTimeSeriesValue {
    pub fn from_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcIrregularTimeSeriesValue::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.time_stamp = parameter.into(),
                1usize => entity.list_values = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcJunctionBox: IIfcFlowFitting {
    fn predefined_type(&self) -> &Option<IfcJunctionBoxTypeEnum>;
}
#[derive(Default, Debug)]
pub struct IfcJunctionBox {
    global_id: IfcGloballyUniqueId,
    owner_history: Option<EntityRef>,
    name: Option<IfcLabel>,
    description: Option<IfcText>,
    object_type: Option<IfcLabel>,
    object_placement: Option<EntityRef>,
    representation: Option<EntityRef>,
    tag: Option<IfcIdentifier>,
    predefined_type: Option<IfcJunctionBoxTypeEnum>,
}
impl IIfcRoot for IfcJunctionBox {
    fn global_id(&self) -> &IfcGloballyUniqueId {
        &self.global_id
    }
    fn owner_history(&self) -> &Option<EntityRef> {
        &self.owner_history
    }
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
}
impl IIfcObjectDefinition for IfcJunctionBox {}
impl IIfcObject for IfcJunctionBox {
    fn object_type(&self) -> &Option<IfcLabel> {
        &self.object_type
    }
}
impl IIfcProduct for IfcJunctionBox {
    fn object_placement(&self) -> &Option<EntityRef> {
        &self.object_placement
    }
    fn representation(&self) -> &Option<EntityRef> {
        &self.representation
    }
}
impl IIfcElement for IfcJunctionBox {
    fn tag(&self) -> &Option<IfcIdentifier> {
        &self.tag
    }
}
impl IIfcDistributionElement for IfcJunctionBox {}
impl IIfcDistributionFlowElement for IfcJunctionBox {}
impl IIfcFlowFitting for IfcJunctionBox {}
impl IIfcJunctionBox for IfcJunctionBox {
    fn predefined_type(&self) -> &Option<IfcJunctionBoxTypeEnum> {
        &self.predefined_type
    }
}
impl IfcJunctionBox {
    pub fn from_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcJunctionBox::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.global_id = parameter.into(),
                1usize => {
                    entity.owner_history = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => {
                    entity.object_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                5usize => {
                    entity.object_placement = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                6usize => {
                    entity.representation = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                7usize => {
                    entity.tag = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                8usize => {
                    entity.predefined_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
    pub fn from_own_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcJunctionBox::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => {
                    entity.predefined_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcJunctionBoxType: IIfcFlowFittingType {
    fn predefined_type(&self) -> &IfcJunctionBoxTypeEnum;
}
#[derive(Default, Debug)]
pub struct IfcJunctionBoxType {
    global_id: IfcGloballyUniqueId,
    owner_history: Option<EntityRef>,
    name: Option<IfcLabel>,
    description: Option<IfcText>,
    applicable_occurrence: Option<IfcIdentifier>,
    has_property_sets: Option<HashSet<EntityRef>>,
    representation_maps: Option<Vec<EntityRef>>,
    tag: Option<IfcLabel>,
    element_type: Option<IfcLabel>,
    predefined_type: IfcJunctionBoxTypeEnum,
}
impl IIfcRoot for IfcJunctionBoxType {
    fn global_id(&self) -> &IfcGloballyUniqueId {
        &self.global_id
    }
    fn owner_history(&self) -> &Option<EntityRef> {
        &self.owner_history
    }
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
}
impl IIfcObjectDefinition for IfcJunctionBoxType {}
impl IIfcTypeObject for IfcJunctionBoxType {
    fn applicable_occurrence(&self) -> &Option<IfcIdentifier> {
        &self.applicable_occurrence
    }
    fn has_property_sets(&self) -> &Option<HashSet<EntityRef>> {
        &self.has_property_sets
    }
}
impl IIfcTypeProduct for IfcJunctionBoxType {
    fn representation_maps(&self) -> &Option<Vec<EntityRef>> {
        &self.representation_maps
    }
    fn tag(&self) -> &Option<IfcLabel> {
        &self.tag
    }
}
impl IIfcElementType for IfcJunctionBoxType {
    fn element_type(&self) -> &Option<IfcLabel> {
        &self.element_type
    }
}
impl IIfcDistributionElementType for IfcJunctionBoxType {}
impl IIfcDistributionFlowElementType for IfcJunctionBoxType {}
impl IIfcFlowFittingType for IfcJunctionBoxType {}
impl IIfcJunctionBoxType for IfcJunctionBoxType {
    fn predefined_type(&self) -> &IfcJunctionBoxTypeEnum {
        &self.predefined_type
    }
}
impl IfcJunctionBoxType {
    pub fn from_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcJunctionBoxType::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.global_id = parameter.into(),
                1usize => {
                    entity.owner_history = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => {
                    entity.applicable_occurrence = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                5usize => {
                    entity.has_property_sets = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                6usize => {
                    entity.representation_maps = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                7usize => {
                    entity.tag = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                8usize => {
                    entity.element_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                9usize => entity.predefined_type = parameter.into(),
                _ => {}
            }
        }
        entity
    }
    pub fn from_own_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcJunctionBoxType::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.predefined_type = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcLShapeProfileDef: IIfcParameterizedProfileDef {
    fn depth(&self) -> &IfcPositiveLengthMeasure;
    fn width(&self) -> &Option<IfcPositiveLengthMeasure>;
    fn thickness(&self) -> &IfcPositiveLengthMeasure;
    fn fillet_radius(&self) -> &Option<IfcNonNegativeLengthMeasure>;
    fn edge_radius(&self) -> &Option<IfcNonNegativeLengthMeasure>;
    fn leg_slope(&self) -> &Option<IfcPlaneAngleMeasure>;
}
#[derive(Default, Debug)]
pub struct IfcLShapeProfileDef {
    profile_type: IfcProfileTypeEnum,
    profile_name: Option<IfcLabel>,
    position: Option<EntityRef>,
    depth: IfcPositiveLengthMeasure,
    width: Option<IfcPositiveLengthMeasure>,
    thickness: IfcPositiveLengthMeasure,
    fillet_radius: Option<IfcNonNegativeLengthMeasure>,
    edge_radius: Option<IfcNonNegativeLengthMeasure>,
    leg_slope: Option<IfcPlaneAngleMeasure>,
}
impl IIfcProfileDef for IfcLShapeProfileDef {
    fn profile_type(&self) -> &IfcProfileTypeEnum {
        &self.profile_type
    }
    fn profile_name(&self) -> &Option<IfcLabel> {
        &self.profile_name
    }
}
impl IIfcParameterizedProfileDef for IfcLShapeProfileDef {
    fn position(&self) -> &Option<EntityRef> {
        &self.position
    }
}
impl IIfcLShapeProfileDef for IfcLShapeProfileDef {
    fn depth(&self) -> &IfcPositiveLengthMeasure {
        &self.depth
    }
    fn width(&self) -> &Option<IfcPositiveLengthMeasure> {
        &self.width
    }
    fn thickness(&self) -> &IfcPositiveLengthMeasure {
        &self.thickness
    }
    fn fillet_radius(&self) -> &Option<IfcNonNegativeLengthMeasure> {
        &self.fillet_radius
    }
    fn edge_radius(&self) -> &Option<IfcNonNegativeLengthMeasure> {
        &self.edge_radius
    }
    fn leg_slope(&self) -> &Option<IfcPlaneAngleMeasure> {
        &self.leg_slope
    }
}
impl IfcLShapeProfileDef {
    pub fn from_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcLShapeProfileDef::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.profile_type = parameter.into(),
                1usize => {
                    entity.profile_name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => {
                    entity.position = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => entity.depth = parameter.into(),
                4usize => {
                    entity.width = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                5usize => entity.thickness = parameter.into(),
                6usize => {
                    entity.fillet_radius = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                7usize => {
                    entity.edge_radius = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                8usize => {
                    entity.leg_slope = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
    pub fn from_own_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcLShapeProfileDef::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.depth = parameter.into(),
                1usize => {
                    entity.width = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => entity.thickness = parameter.into(),
                3usize => {
                    entity.fillet_radius = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => {
                    entity.edge_radius = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                5usize => {
                    entity.leg_slope = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcLaborResource: IIfcConstructionResource {
    fn predefined_type(&self) -> &Option<IfcLaborResourceTypeEnum>;
}
#[derive(Default, Debug)]
pub struct IfcLaborResource {
    global_id: IfcGloballyUniqueId,
    owner_history: Option<EntityRef>,
    name: Option<IfcLabel>,
    description: Option<IfcText>,
    object_type: Option<IfcLabel>,
    identification: Option<IfcIdentifier>,
    long_description: Option<IfcText>,
    usage: Option<EntityRef>,
    base_costs: Option<Vec<EntityRef>>,
    base_quantity: Option<EntityRef>,
    predefined_type: Option<IfcLaborResourceTypeEnum>,
}
impl IIfcRoot for IfcLaborResource {
    fn global_id(&self) -> &IfcGloballyUniqueId {
        &self.global_id
    }
    fn owner_history(&self) -> &Option<EntityRef> {
        &self.owner_history
    }
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
}
impl IIfcObjectDefinition for IfcLaborResource {}
impl IIfcObject for IfcLaborResource {
    fn object_type(&self) -> &Option<IfcLabel> {
        &self.object_type
    }
}
impl IIfcResource for IfcLaborResource {
    fn identification(&self) -> &Option<IfcIdentifier> {
        &self.identification
    }
    fn long_description(&self) -> &Option<IfcText> {
        &self.long_description
    }
}
impl IIfcConstructionResource for IfcLaborResource {
    fn usage(&self) -> &Option<EntityRef> {
        &self.usage
    }
    fn base_costs(&self) -> &Option<Vec<EntityRef>> {
        &self.base_costs
    }
    fn base_quantity(&self) -> &Option<EntityRef> {
        &self.base_quantity
    }
}
impl IIfcLaborResource for IfcLaborResource {
    fn predefined_type(&self) -> &Option<IfcLaborResourceTypeEnum> {
        &self.predefined_type
    }
}
impl IfcLaborResource {
    pub fn from_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcLaborResource::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.global_id = parameter.into(),
                1usize => {
                    entity.owner_history = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => {
                    entity.object_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                5usize => {
                    entity.identification = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                6usize => {
                    entity.long_description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                7usize => {
                    entity.usage = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                8usize => {
                    entity.base_costs = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                9usize => {
                    entity.base_quantity = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                10usize => {
                    entity.predefined_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
    pub fn from_own_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcLaborResource::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => {
                    entity.predefined_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcLaborResourceType: IIfcConstructionResourceType {
    fn predefined_type(&self) -> &IfcLaborResourceTypeEnum;
}
#[derive(Default, Debug)]
pub struct IfcLaborResourceType {
    global_id: IfcGloballyUniqueId,
    owner_history: Option<EntityRef>,
    name: Option<IfcLabel>,
    description: Option<IfcText>,
    applicable_occurrence: Option<IfcIdentifier>,
    has_property_sets: Option<HashSet<EntityRef>>,
    identification: Option<IfcIdentifier>,
    long_description: Option<IfcText>,
    resource_type: Option<IfcLabel>,
    base_costs: Option<Vec<EntityRef>>,
    base_quantity: Option<EntityRef>,
    predefined_type: IfcLaborResourceTypeEnum,
}
impl IIfcRoot for IfcLaborResourceType {
    fn global_id(&self) -> &IfcGloballyUniqueId {
        &self.global_id
    }
    fn owner_history(&self) -> &Option<EntityRef> {
        &self.owner_history
    }
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
}
impl IIfcObjectDefinition for IfcLaborResourceType {}
impl IIfcTypeObject for IfcLaborResourceType {
    fn applicable_occurrence(&self) -> &Option<IfcIdentifier> {
        &self.applicable_occurrence
    }
    fn has_property_sets(&self) -> &Option<HashSet<EntityRef>> {
        &self.has_property_sets
    }
}
impl IIfcTypeResource for IfcLaborResourceType {
    fn identification(&self) -> &Option<IfcIdentifier> {
        &self.identification
    }
    fn long_description(&self) -> &Option<IfcText> {
        &self.long_description
    }
    fn resource_type(&self) -> &Option<IfcLabel> {
        &self.resource_type
    }
}
impl IIfcConstructionResourceType for IfcLaborResourceType {
    fn base_costs(&self) -> &Option<Vec<EntityRef>> {
        &self.base_costs
    }
    fn base_quantity(&self) -> &Option<EntityRef> {
        &self.base_quantity
    }
}
impl IIfcLaborResourceType for IfcLaborResourceType {
    fn predefined_type(&self) -> &IfcLaborResourceTypeEnum {
        &self.predefined_type
    }
}
impl IfcLaborResourceType {
    pub fn from_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcLaborResourceType::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.global_id = parameter.into(),
                1usize => {
                    entity.owner_history = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => {
                    entity.applicable_occurrence = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                5usize => {
                    entity.has_property_sets = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                6usize => {
                    entity.identification = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                7usize => {
                    entity.long_description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                8usize => {
                    entity.resource_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                9usize => {
                    entity.base_costs = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                10usize => {
                    entity.base_quantity = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                11usize => entity.predefined_type = parameter.into(),
                _ => {}
            }
        }
        entity
    }
    pub fn from_own_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcLaborResourceType::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.predefined_type = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcLagTime: IIfcSchedulingTime {
    fn lag_value(&self) -> &IfcTimeOrRatioSelect;
    fn duration_type(&self) -> &IfcTaskDurationEnum;
}
#[derive(Default, Debug)]
pub struct IfcLagTime {
    name: Option<IfcLabel>,
    data_origin: Option<IfcDataOriginEnum>,
    user_defined_data_origin: Option<IfcLabel>,
    lag_value: IfcTimeOrRatioSelect,
    duration_type: IfcTaskDurationEnum,
}
impl IIfcSchedulingTime for IfcLagTime {
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
    fn data_origin(&self) -> &Option<IfcDataOriginEnum> {
        &self.data_origin
    }
    fn user_defined_data_origin(&self) -> &Option<IfcLabel> {
        &self.user_defined_data_origin
    }
}
impl IIfcLagTime for IfcLagTime {
    fn lag_value(&self) -> &IfcTimeOrRatioSelect {
        &self.lag_value
    }
    fn duration_type(&self) -> &IfcTaskDurationEnum {
        &self.duration_type
    }
}
impl IfcLagTime {
    pub fn from_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcLagTime::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                1usize => {
                    entity.data_origin = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => {
                    entity.user_defined_data_origin = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => entity.lag_value = parameter.into(),
                4usize => entity.duration_type = parameter.into(),
                _ => {}
            }
        }
        entity
    }
    pub fn from_own_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcLagTime::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.lag_value = parameter.into(),
                1usize => entity.duration_type = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcLamp: IIfcFlowTerminal {
    fn predefined_type(&self) -> &Option<IfcLampTypeEnum>;
}
#[derive(Default, Debug)]
pub struct IfcLamp {
    global_id: IfcGloballyUniqueId,
    owner_history: Option<EntityRef>,
    name: Option<IfcLabel>,
    description: Option<IfcText>,
    object_type: Option<IfcLabel>,
    object_placement: Option<EntityRef>,
    representation: Option<EntityRef>,
    tag: Option<IfcIdentifier>,
    predefined_type: Option<IfcLampTypeEnum>,
}
impl IIfcRoot for IfcLamp {
    fn global_id(&self) -> &IfcGloballyUniqueId {
        &self.global_id
    }
    fn owner_history(&self) -> &Option<EntityRef> {
        &self.owner_history
    }
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
}
impl IIfcObjectDefinition for IfcLamp {}
impl IIfcObject for IfcLamp {
    fn object_type(&self) -> &Option<IfcLabel> {
        &self.object_type
    }
}
impl IIfcProduct for IfcLamp {
    fn object_placement(&self) -> &Option<EntityRef> {
        &self.object_placement
    }
    fn representation(&self) -> &Option<EntityRef> {
        &self.representation
    }
}
impl IIfcElement for IfcLamp {
    fn tag(&self) -> &Option<IfcIdentifier> {
        &self.tag
    }
}
impl IIfcDistributionElement for IfcLamp {}
impl IIfcDistributionFlowElement for IfcLamp {}
impl IIfcFlowTerminal for IfcLamp {}
impl IIfcLamp for IfcLamp {
    fn predefined_type(&self) -> &Option<IfcLampTypeEnum> {
        &self.predefined_type
    }
}
impl IfcLamp {
    pub fn from_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcLamp::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.global_id = parameter.into(),
                1usize => {
                    entity.owner_history = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => {
                    entity.object_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                5usize => {
                    entity.object_placement = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                6usize => {
                    entity.representation = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                7usize => {
                    entity.tag = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                8usize => {
                    entity.predefined_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
    pub fn from_own_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcLamp::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => {
                    entity.predefined_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcLampType: IIfcFlowTerminalType {
    fn predefined_type(&self) -> &IfcLampTypeEnum;
}
#[derive(Default, Debug)]
pub struct IfcLampType {
    global_id: IfcGloballyUniqueId,
    owner_history: Option<EntityRef>,
    name: Option<IfcLabel>,
    description: Option<IfcText>,
    applicable_occurrence: Option<IfcIdentifier>,
    has_property_sets: Option<HashSet<EntityRef>>,
    representation_maps: Option<Vec<EntityRef>>,
    tag: Option<IfcLabel>,
    element_type: Option<IfcLabel>,
    predefined_type: IfcLampTypeEnum,
}
impl IIfcRoot for IfcLampType {
    fn global_id(&self) -> &IfcGloballyUniqueId {
        &self.global_id
    }
    fn owner_history(&self) -> &Option<EntityRef> {
        &self.owner_history
    }
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
}
impl IIfcObjectDefinition for IfcLampType {}
impl IIfcTypeObject for IfcLampType {
    fn applicable_occurrence(&self) -> &Option<IfcIdentifier> {
        &self.applicable_occurrence
    }
    fn has_property_sets(&self) -> &Option<HashSet<EntityRef>> {
        &self.has_property_sets
    }
}
impl IIfcTypeProduct for IfcLampType {
    fn representation_maps(&self) -> &Option<Vec<EntityRef>> {
        &self.representation_maps
    }
    fn tag(&self) -> &Option<IfcLabel> {
        &self.tag
    }
}
impl IIfcElementType for IfcLampType {
    fn element_type(&self) -> &Option<IfcLabel> {
        &self.element_type
    }
}
impl IIfcDistributionElementType for IfcLampType {}
impl IIfcDistributionFlowElementType for IfcLampType {}
impl IIfcFlowTerminalType for IfcLampType {}
impl IIfcLampType for IfcLampType {
    fn predefined_type(&self) -> &IfcLampTypeEnum {
        &self.predefined_type
    }
}
impl IfcLampType {
    pub fn from_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcLampType::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.global_id = parameter.into(),
                1usize => {
                    entity.owner_history = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => {
                    entity.applicable_occurrence = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                5usize => {
                    entity.has_property_sets = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                6usize => {
                    entity.representation_maps = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                7usize => {
                    entity.tag = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                8usize => {
                    entity.element_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                9usize => entity.predefined_type = parameter.into(),
                _ => {}
            }
        }
        entity
    }
    pub fn from_own_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcLampType::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.predefined_type = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcLibraryInformation: IIfcExternalInformation {
    fn name(&self) -> &IfcLabel;
    fn version(&self) -> &Option<IfcLabel>;
    fn publisher(&self) -> &Option<EntityRef>;
    fn version_date(&self) -> &Option<IfcDateTime>;
    fn location(&self) -> &Option<IfcUriReference>;
    fn description(&self) -> &Option<IfcText>;
}
#[derive(Default, Debug)]
pub struct IfcLibraryInformation {
    name: IfcLabel,
    version: Option<IfcLabel>,
    publisher: Option<EntityRef>,
    version_date: Option<IfcDateTime>,
    location: Option<IfcUriReference>,
    description: Option<IfcText>,
}
impl IIfcExternalInformation for IfcLibraryInformation {}
impl IIfcLibraryInformation for IfcLibraryInformation {
    fn name(&self) -> &IfcLabel {
        &self.name
    }
    fn version(&self) -> &Option<IfcLabel> {
        &self.version
    }
    fn publisher(&self) -> &Option<EntityRef> {
        &self.publisher
    }
    fn version_date(&self) -> &Option<IfcDateTime> {
        &self.version_date
    }
    fn location(&self) -> &Option<IfcUriReference> {
        &self.location
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
}
impl IfcLibraryInformation {
    pub fn from_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcLibraryInformation::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => {
                    entity.version = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => {
                    entity.publisher = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.version_date = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => {
                    entity.location = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                5usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcLibraryReference: IIfcExternalReference {
    fn description(&self) -> &Option<IfcText>;
    fn language(&self) -> &Option<IfcLanguageId>;
    fn referenced_library(&self) -> &Option<EntityRef>;
}
#[derive(Default, Debug)]
pub struct IfcLibraryReference {
    location: Option<IfcUriReference>,
    identification: Option<IfcIdentifier>,
    name: Option<IfcLabel>,
    description: Option<IfcText>,
    language: Option<IfcLanguageId>,
    referenced_library: Option<EntityRef>,
}
impl IIfcExternalReference for IfcLibraryReference {
    fn location(&self) -> &Option<IfcUriReference> {
        &self.location
    }
    fn identification(&self) -> &Option<IfcIdentifier> {
        &self.identification
    }
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
}
impl IIfcLibraryReference for IfcLibraryReference {
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
    fn language(&self) -> &Option<IfcLanguageId> {
        &self.language
    }
    fn referenced_library(&self) -> &Option<EntityRef> {
        &self.referenced_library
    }
}
impl IfcLibraryReference {
    pub fn from_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcLibraryReference::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => {
                    entity.location = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                1usize => {
                    entity.identification = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => {
                    entity.language = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                5usize => {
                    entity.referenced_library = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
    pub fn from_own_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcLibraryReference::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                1usize => {
                    entity.language = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => {
                    entity.referenced_library = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcLightDistributionData {
    fn main_plane_angle(&self) -> &IfcPlaneAngleMeasure;
    fn secondary_plane_angle(&self) -> &Vec<IfcPlaneAngleMeasure>;
    fn luminous_intensity(&self) -> &Vec<IfcLuminousIntensityDistributionMeasure>;
}
#[derive(Default, Debug)]
pub struct IfcLightDistributionData {
    main_plane_angle: IfcPlaneAngleMeasure,
    secondary_plane_angle: Vec<IfcPlaneAngleMeasure>,
    luminous_intensity: Vec<IfcLuminousIntensityDistributionMeasure>,
}
impl IIfcLightDistributionData for IfcLightDistributionData {
    fn main_plane_angle(&self) -> &IfcPlaneAngleMeasure {
        &self.main_plane_angle
    }
    fn secondary_plane_angle(&self) -> &Vec<IfcPlaneAngleMeasure> {
        &self.secondary_plane_angle
    }
    fn luminous_intensity(&self) -> &Vec<IfcLuminousIntensityDistributionMeasure> {
        &self.luminous_intensity
    }
}
impl IfcLightDistributionData {
    pub fn from_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcLightDistributionData::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.main_plane_angle = parameter.into(),
                1usize => entity.secondary_plane_angle = parameter.into(),
                2usize => entity.luminous_intensity = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcLightFixture: IIfcFlowTerminal {
    fn predefined_type(&self) -> &Option<IfcLightFixtureTypeEnum>;
}
#[derive(Default, Debug)]
pub struct IfcLightFixture {
    global_id: IfcGloballyUniqueId,
    owner_history: Option<EntityRef>,
    name: Option<IfcLabel>,
    description: Option<IfcText>,
    object_type: Option<IfcLabel>,
    object_placement: Option<EntityRef>,
    representation: Option<EntityRef>,
    tag: Option<IfcIdentifier>,
    predefined_type: Option<IfcLightFixtureTypeEnum>,
}
impl IIfcRoot for IfcLightFixture {
    fn global_id(&self) -> &IfcGloballyUniqueId {
        &self.global_id
    }
    fn owner_history(&self) -> &Option<EntityRef> {
        &self.owner_history
    }
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
}
impl IIfcObjectDefinition for IfcLightFixture {}
impl IIfcObject for IfcLightFixture {
    fn object_type(&self) -> &Option<IfcLabel> {
        &self.object_type
    }
}
impl IIfcProduct for IfcLightFixture {
    fn object_placement(&self) -> &Option<EntityRef> {
        &self.object_placement
    }
    fn representation(&self) -> &Option<EntityRef> {
        &self.representation
    }
}
impl IIfcElement for IfcLightFixture {
    fn tag(&self) -> &Option<IfcIdentifier> {
        &self.tag
    }
}
impl IIfcDistributionElement for IfcLightFixture {}
impl IIfcDistributionFlowElement for IfcLightFixture {}
impl IIfcFlowTerminal for IfcLightFixture {}
impl IIfcLightFixture for IfcLightFixture {
    fn predefined_type(&self) -> &Option<IfcLightFixtureTypeEnum> {
        &self.predefined_type
    }
}
impl IfcLightFixture {
    pub fn from_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcLightFixture::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.global_id = parameter.into(),
                1usize => {
                    entity.owner_history = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => {
                    entity.object_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                5usize => {
                    entity.object_placement = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                6usize => {
                    entity.representation = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                7usize => {
                    entity.tag = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                8usize => {
                    entity.predefined_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
    pub fn from_own_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcLightFixture::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => {
                    entity.predefined_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcLightFixtureType: IIfcFlowTerminalType {
    fn predefined_type(&self) -> &IfcLightFixtureTypeEnum;
}
#[derive(Default, Debug)]
pub struct IfcLightFixtureType {
    global_id: IfcGloballyUniqueId,
    owner_history: Option<EntityRef>,
    name: Option<IfcLabel>,
    description: Option<IfcText>,
    applicable_occurrence: Option<IfcIdentifier>,
    has_property_sets: Option<HashSet<EntityRef>>,
    representation_maps: Option<Vec<EntityRef>>,
    tag: Option<IfcLabel>,
    element_type: Option<IfcLabel>,
    predefined_type: IfcLightFixtureTypeEnum,
}
impl IIfcRoot for IfcLightFixtureType {
    fn global_id(&self) -> &IfcGloballyUniqueId {
        &self.global_id
    }
    fn owner_history(&self) -> &Option<EntityRef> {
        &self.owner_history
    }
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
}
impl IIfcObjectDefinition for IfcLightFixtureType {}
impl IIfcTypeObject for IfcLightFixtureType {
    fn applicable_occurrence(&self) -> &Option<IfcIdentifier> {
        &self.applicable_occurrence
    }
    fn has_property_sets(&self) -> &Option<HashSet<EntityRef>> {
        &self.has_property_sets
    }
}
impl IIfcTypeProduct for IfcLightFixtureType {
    fn representation_maps(&self) -> &Option<Vec<EntityRef>> {
        &self.representation_maps
    }
    fn tag(&self) -> &Option<IfcLabel> {
        &self.tag
    }
}
impl IIfcElementType for IfcLightFixtureType {
    fn element_type(&self) -> &Option<IfcLabel> {
        &self.element_type
    }
}
impl IIfcDistributionElementType for IfcLightFixtureType {}
impl IIfcDistributionFlowElementType for IfcLightFixtureType {}
impl IIfcFlowTerminalType for IfcLightFixtureType {}
impl IIfcLightFixtureType for IfcLightFixtureType {
    fn predefined_type(&self) -> &IfcLightFixtureTypeEnum {
        &self.predefined_type
    }
}
impl IfcLightFixtureType {
    pub fn from_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcLightFixtureType::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.global_id = parameter.into(),
                1usize => {
                    entity.owner_history = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => {
                    entity.applicable_occurrence = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                5usize => {
                    entity.has_property_sets = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                6usize => {
                    entity.representation_maps = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                7usize => {
                    entity.tag = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                8usize => {
                    entity.element_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                9usize => entity.predefined_type = parameter.into(),
                _ => {}
            }
        }
        entity
    }
    pub fn from_own_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcLightFixtureType::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.predefined_type = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcLightIntensityDistribution {
    fn light_distribution_curve(&self) -> &IfcLightDistributionCurveEnum;
    fn distribution_data(&self) -> &Vec<EntityRef>;
}
#[derive(Default, Debug)]
pub struct IfcLightIntensityDistribution {
    light_distribution_curve: IfcLightDistributionCurveEnum,
    distribution_data: Vec<EntityRef>,
}
impl IIfcLightIntensityDistribution for IfcLightIntensityDistribution {
    fn light_distribution_curve(&self) -> &IfcLightDistributionCurveEnum {
        &self.light_distribution_curve
    }
    fn distribution_data(&self) -> &Vec<EntityRef> {
        &self.distribution_data
    }
}
impl IfcLightIntensityDistribution {
    pub fn from_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcLightIntensityDistribution::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.light_distribution_curve = parameter.into(),
                1usize => entity.distribution_data = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcLightSource: IIfcGeometricRepresentationItem {
    fn name(&self) -> &Option<IfcLabel>;
    fn light_colour(&self) -> &EntityRef;
    fn ambient_intensity(&self) -> &Option<IfcNormalisedRatioMeasure>;
    fn intensity(&self) -> &Option<IfcNormalisedRatioMeasure>;
}
pub trait IIfcLightSourceAmbient: IIfcLightSource {}
#[derive(Default, Debug)]
pub struct IfcLightSourceAmbient {
    name: Option<IfcLabel>,
    light_colour: EntityRef,
    ambient_intensity: Option<IfcNormalisedRatioMeasure>,
    intensity: Option<IfcNormalisedRatioMeasure>,
}
impl IIfcRepresentationItem for IfcLightSourceAmbient {}
impl IIfcGeometricRepresentationItem for IfcLightSourceAmbient {}
impl IIfcLightSource for IfcLightSourceAmbient {
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
    fn light_colour(&self) -> &EntityRef {
        &self.light_colour
    }
    fn ambient_intensity(&self) -> &Option<IfcNormalisedRatioMeasure> {
        &self.ambient_intensity
    }
    fn intensity(&self) -> &Option<IfcNormalisedRatioMeasure> {
        &self.intensity
    }
}
impl IIfcLightSourceAmbient for IfcLightSourceAmbient {}
impl IfcLightSourceAmbient {
    pub fn from_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcLightSourceAmbient::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                1usize => entity.light_colour = parameter.into(),
                2usize => {
                    entity.ambient_intensity = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.intensity = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcLightSourceDirectional: IIfcLightSource {
    fn orientation(&self) -> &EntityRef;
}
#[derive(Default, Debug)]
pub struct IfcLightSourceDirectional {
    name: Option<IfcLabel>,
    light_colour: EntityRef,
    ambient_intensity: Option<IfcNormalisedRatioMeasure>,
    intensity: Option<IfcNormalisedRatioMeasure>,
    orientation: EntityRef,
}
impl IIfcRepresentationItem for IfcLightSourceDirectional {}
impl IIfcGeometricRepresentationItem for IfcLightSourceDirectional {}
impl IIfcLightSource for IfcLightSourceDirectional {
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
    fn light_colour(&self) -> &EntityRef {
        &self.light_colour
    }
    fn ambient_intensity(&self) -> &Option<IfcNormalisedRatioMeasure> {
        &self.ambient_intensity
    }
    fn intensity(&self) -> &Option<IfcNormalisedRatioMeasure> {
        &self.intensity
    }
}
impl IIfcLightSourceDirectional for IfcLightSourceDirectional {
    fn orientation(&self) -> &EntityRef {
        &self.orientation
    }
}
impl IfcLightSourceDirectional {
    pub fn from_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcLightSourceDirectional::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                1usize => entity.light_colour = parameter.into(),
                2usize => {
                    entity.ambient_intensity = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.intensity = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => entity.orientation = parameter.into(),
                _ => {}
            }
        }
        entity
    }
    pub fn from_own_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcLightSourceDirectional::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.orientation = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcLightSourceGoniometric: IIfcLightSource {
    fn position(&self) -> &EntityRef;
    fn colour_appearance(&self) -> &Option<EntityRef>;
    fn colour_temperature(&self) -> &IfcThermodynamicTemperatureMeasure;
    fn luminous_flux(&self) -> &IfcLuminousFluxMeasure;
    fn light_emission_source(&self) -> &IfcLightEmissionSourceEnum;
    fn light_distribution_data_source(&self) -> &EntityRef;
}
#[derive(Default, Debug)]
pub struct IfcLightSourceGoniometric {
    name: Option<IfcLabel>,
    light_colour: EntityRef,
    ambient_intensity: Option<IfcNormalisedRatioMeasure>,
    intensity: Option<IfcNormalisedRatioMeasure>,
    position: EntityRef,
    colour_appearance: Option<EntityRef>,
    colour_temperature: IfcThermodynamicTemperatureMeasure,
    luminous_flux: IfcLuminousFluxMeasure,
    light_emission_source: IfcLightEmissionSourceEnum,
    light_distribution_data_source: EntityRef,
}
impl IIfcRepresentationItem for IfcLightSourceGoniometric {}
impl IIfcGeometricRepresentationItem for IfcLightSourceGoniometric {}
impl IIfcLightSource for IfcLightSourceGoniometric {
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
    fn light_colour(&self) -> &EntityRef {
        &self.light_colour
    }
    fn ambient_intensity(&self) -> &Option<IfcNormalisedRatioMeasure> {
        &self.ambient_intensity
    }
    fn intensity(&self) -> &Option<IfcNormalisedRatioMeasure> {
        &self.intensity
    }
}
impl IIfcLightSourceGoniometric for IfcLightSourceGoniometric {
    fn position(&self) -> &EntityRef {
        &self.position
    }
    fn colour_appearance(&self) -> &Option<EntityRef> {
        &self.colour_appearance
    }
    fn colour_temperature(&self) -> &IfcThermodynamicTemperatureMeasure {
        &self.colour_temperature
    }
    fn luminous_flux(&self) -> &IfcLuminousFluxMeasure {
        &self.luminous_flux
    }
    fn light_emission_source(&self) -> &IfcLightEmissionSourceEnum {
        &self.light_emission_source
    }
    fn light_distribution_data_source(&self) -> &EntityRef {
        &self.light_distribution_data_source
    }
}
impl IfcLightSourceGoniometric {
    pub fn from_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcLightSourceGoniometric::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                1usize => entity.light_colour = parameter.into(),
                2usize => {
                    entity.ambient_intensity = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.intensity = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => entity.position = parameter.into(),
                5usize => {
                    entity.colour_appearance = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                6usize => entity.colour_temperature = parameter.into(),
                7usize => entity.luminous_flux = parameter.into(),
                8usize => entity.light_emission_source = parameter.into(),
                9usize => entity.light_distribution_data_source = parameter.into(),
                _ => {}
            }
        }
        entity
    }
    pub fn from_own_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcLightSourceGoniometric::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.position = parameter.into(),
                1usize => {
                    entity.colour_appearance = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => entity.colour_temperature = parameter.into(),
                3usize => entity.luminous_flux = parameter.into(),
                4usize => entity.light_emission_source = parameter.into(),
                5usize => entity.light_distribution_data_source = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcLightSourcePositional: IIfcLightSource {
    fn position(&self) -> &EntityRef;
    fn radius(&self) -> &IfcPositiveLengthMeasure;
    fn constant_attenuation(&self) -> &IfcReal;
    fn distance_attenuation(&self) -> &IfcReal;
    fn quadric_attenuation(&self) -> &IfcReal;
}
#[derive(Default, Debug)]
pub struct IfcLightSourcePositional {
    name: Option<IfcLabel>,
    light_colour: EntityRef,
    ambient_intensity: Option<IfcNormalisedRatioMeasure>,
    intensity: Option<IfcNormalisedRatioMeasure>,
    position: EntityRef,
    radius: IfcPositiveLengthMeasure,
    constant_attenuation: IfcReal,
    distance_attenuation: IfcReal,
    quadric_attenuation: IfcReal,
}
impl IIfcRepresentationItem for IfcLightSourcePositional {}
impl IIfcGeometricRepresentationItem for IfcLightSourcePositional {}
impl IIfcLightSource for IfcLightSourcePositional {
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
    fn light_colour(&self) -> &EntityRef {
        &self.light_colour
    }
    fn ambient_intensity(&self) -> &Option<IfcNormalisedRatioMeasure> {
        &self.ambient_intensity
    }
    fn intensity(&self) -> &Option<IfcNormalisedRatioMeasure> {
        &self.intensity
    }
}
impl IIfcLightSourcePositional for IfcLightSourcePositional {
    fn position(&self) -> &EntityRef {
        &self.position
    }
    fn radius(&self) -> &IfcPositiveLengthMeasure {
        &self.radius
    }
    fn constant_attenuation(&self) -> &IfcReal {
        &self.constant_attenuation
    }
    fn distance_attenuation(&self) -> &IfcReal {
        &self.distance_attenuation
    }
    fn quadric_attenuation(&self) -> &IfcReal {
        &self.quadric_attenuation
    }
}
impl IfcLightSourcePositional {
    pub fn from_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcLightSourcePositional::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                1usize => entity.light_colour = parameter.into(),
                2usize => {
                    entity.ambient_intensity = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.intensity = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => entity.position = parameter.into(),
                5usize => entity.radius = parameter.into(),
                6usize => entity.constant_attenuation = parameter.into(),
                7usize => entity.distance_attenuation = parameter.into(),
                8usize => entity.quadric_attenuation = parameter.into(),
                _ => {}
            }
        }
        entity
    }
    pub fn from_own_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcLightSourcePositional::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.position = parameter.into(),
                1usize => entity.radius = parameter.into(),
                2usize => entity.constant_attenuation = parameter.into(),
                3usize => entity.distance_attenuation = parameter.into(),
                4usize => entity.quadric_attenuation = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcLightSourceSpot: IIfcLightSourcePositional {
    fn orientation(&self) -> &EntityRef;
    fn concentration_exponent(&self) -> &Option<IfcReal>;
    fn spread_angle(&self) -> &IfcPositivePlaneAngleMeasure;
    fn beam_width_angle(&self) -> &IfcPositivePlaneAngleMeasure;
}
#[derive(Default, Debug)]
pub struct IfcLightSourceSpot {
    name: Option<IfcLabel>,
    light_colour: EntityRef,
    ambient_intensity: Option<IfcNormalisedRatioMeasure>,
    intensity: Option<IfcNormalisedRatioMeasure>,
    position: EntityRef,
    radius: IfcPositiveLengthMeasure,
    constant_attenuation: IfcReal,
    distance_attenuation: IfcReal,
    quadric_attenuation: IfcReal,
    orientation: EntityRef,
    concentration_exponent: Option<IfcReal>,
    spread_angle: IfcPositivePlaneAngleMeasure,
    beam_width_angle: IfcPositivePlaneAngleMeasure,
}
impl IIfcRepresentationItem for IfcLightSourceSpot {}
impl IIfcGeometricRepresentationItem for IfcLightSourceSpot {}
impl IIfcLightSource for IfcLightSourceSpot {
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
    fn light_colour(&self) -> &EntityRef {
        &self.light_colour
    }
    fn ambient_intensity(&self) -> &Option<IfcNormalisedRatioMeasure> {
        &self.ambient_intensity
    }
    fn intensity(&self) -> &Option<IfcNormalisedRatioMeasure> {
        &self.intensity
    }
}
impl IIfcLightSourcePositional for IfcLightSourceSpot {
    fn position(&self) -> &EntityRef {
        &self.position
    }
    fn radius(&self) -> &IfcPositiveLengthMeasure {
        &self.radius
    }
    fn constant_attenuation(&self) -> &IfcReal {
        &self.constant_attenuation
    }
    fn distance_attenuation(&self) -> &IfcReal {
        &self.distance_attenuation
    }
    fn quadric_attenuation(&self) -> &IfcReal {
        &self.quadric_attenuation
    }
}
impl IIfcLightSourceSpot for IfcLightSourceSpot {
    fn orientation(&self) -> &EntityRef {
        &self.orientation
    }
    fn concentration_exponent(&self) -> &Option<IfcReal> {
        &self.concentration_exponent
    }
    fn spread_angle(&self) -> &IfcPositivePlaneAngleMeasure {
        &self.spread_angle
    }
    fn beam_width_angle(&self) -> &IfcPositivePlaneAngleMeasure {
        &self.beam_width_angle
    }
}
impl IfcLightSourceSpot {
    pub fn from_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcLightSourceSpot::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                1usize => entity.light_colour = parameter.into(),
                2usize => {
                    entity.ambient_intensity = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.intensity = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => entity.position = parameter.into(),
                5usize => entity.radius = parameter.into(),
                6usize => entity.constant_attenuation = parameter.into(),
                7usize => entity.distance_attenuation = parameter.into(),
                8usize => entity.quadric_attenuation = parameter.into(),
                9usize => entity.orientation = parameter.into(),
                10usize => {
                    entity.concentration_exponent = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                11usize => entity.spread_angle = parameter.into(),
                12usize => entity.beam_width_angle = parameter.into(),
                _ => {}
            }
        }
        entity
    }
    pub fn from_own_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcLightSourceSpot::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.orientation = parameter.into(),
                1usize => {
                    entity.concentration_exponent = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => entity.spread_angle = parameter.into(),
                3usize => entity.beam_width_angle = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcLine: IIfcCurve {
    fn pnt(&self) -> &EntityRef;
    fn dir(&self) -> &EntityRef;
}
#[derive(Default, Debug)]
pub struct IfcLine {
    pnt: EntityRef,
    dir: EntityRef,
}
impl IIfcRepresentationItem for IfcLine {}
impl IIfcGeometricRepresentationItem for IfcLine {}
impl IIfcCurve for IfcLine {}
impl IIfcLine for IfcLine {
    fn pnt(&self) -> &EntityRef {
        &self.pnt
    }
    fn dir(&self) -> &EntityRef {
        &self.dir
    }
}
impl IfcLine {
    pub fn from_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcLine::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.pnt = parameter.into(),
                1usize => entity.dir = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcLocalPlacement: IIfcObjectPlacement {
    fn placement_rel_to(&self) -> &Option<EntityRef>;
    fn relative_placement(&self) -> &EntityRef;
}
#[derive(Default, Debug)]
pub struct IfcLocalPlacement {
    placement_rel_to: Option<EntityRef>,
    relative_placement: EntityRef,
}
impl IIfcObjectPlacement for IfcLocalPlacement {}
impl IIfcLocalPlacement for IfcLocalPlacement {
    fn placement_rel_to(&self) -> &Option<EntityRef> {
        &self.placement_rel_to
    }
    fn relative_placement(&self) -> &EntityRef {
        &self.relative_placement
    }
}
impl IfcLocalPlacement {
    pub fn from_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcLocalPlacement::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => {
                    entity.placement_rel_to = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                1usize => entity.relative_placement = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcLoop: IIfcTopologicalRepresentationItem {}
#[derive(Default, Debug)]
pub struct IfcLoop {}
impl IIfcRepresentationItem for IfcLoop {}
impl IIfcTopologicalRepresentationItem for IfcLoop {}
impl IIfcLoop for IfcLoop {}
impl IfcLoop {
    pub fn from_parameters(_parameters: Vec<Parameter>) -> Self {
        IfcLoop::default()
    }
}
pub trait IIfcManifoldSolidBrep: IIfcSolidModel {
    fn outer(&self) -> &EntityRef;
}
pub trait IIfcMapConversion: IIfcCoordinateOperation {
    fn eastings(&self) -> &IfcLengthMeasure;
    fn northings(&self) -> &IfcLengthMeasure;
    fn orthogonal_height(&self) -> &IfcLengthMeasure;
    fn x_axis_abscissa(&self) -> &Option<IfcReal>;
    fn x_axis_ordinate(&self) -> &Option<IfcReal>;
    fn scale(&self) -> &Option<IfcReal>;
}
#[derive(Default, Debug)]
pub struct IfcMapConversion {
    source_crs: EntityRef,
    target_crs: EntityRef,
    eastings: IfcLengthMeasure,
    northings: IfcLengthMeasure,
    orthogonal_height: IfcLengthMeasure,
    x_axis_abscissa: Option<IfcReal>,
    x_axis_ordinate: Option<IfcReal>,
    scale: Option<IfcReal>,
}
impl IIfcCoordinateOperation for IfcMapConversion {
    fn source_crs(&self) -> &EntityRef {
        &self.source_crs
    }
    fn target_crs(&self) -> &EntityRef {
        &self.target_crs
    }
}
impl IIfcMapConversion for IfcMapConversion {
    fn eastings(&self) -> &IfcLengthMeasure {
        &self.eastings
    }
    fn northings(&self) -> &IfcLengthMeasure {
        &self.northings
    }
    fn orthogonal_height(&self) -> &IfcLengthMeasure {
        &self.orthogonal_height
    }
    fn x_axis_abscissa(&self) -> &Option<IfcReal> {
        &self.x_axis_abscissa
    }
    fn x_axis_ordinate(&self) -> &Option<IfcReal> {
        &self.x_axis_ordinate
    }
    fn scale(&self) -> &Option<IfcReal> {
        &self.scale
    }
}
impl IfcMapConversion {
    pub fn from_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcMapConversion::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.source_crs = parameter.into(),
                1usize => entity.target_crs = parameter.into(),
                2usize => entity.eastings = parameter.into(),
                3usize => entity.northings = parameter.into(),
                4usize => entity.orthogonal_height = parameter.into(),
                5usize => {
                    entity.x_axis_abscissa = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                6usize => {
                    entity.x_axis_ordinate = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                7usize => {
                    entity.scale = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
    pub fn from_own_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcMapConversion::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.eastings = parameter.into(),
                1usize => entity.northings = parameter.into(),
                2usize => entity.orthogonal_height = parameter.into(),
                3usize => {
                    entity.x_axis_abscissa = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => {
                    entity.x_axis_ordinate = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                5usize => {
                    entity.scale = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcMappedItem: IIfcRepresentationItem {
    fn mapping_source(&self) -> &EntityRef;
    fn mapping_target(&self) -> &EntityRef;
}
#[derive(Default, Debug)]
pub struct IfcMappedItem {
    mapping_source: EntityRef,
    mapping_target: EntityRef,
}
impl IIfcRepresentationItem for IfcMappedItem {}
impl IIfcMappedItem for IfcMappedItem {
    fn mapping_source(&self) -> &EntityRef {
        &self.mapping_source
    }
    fn mapping_target(&self) -> &EntityRef {
        &self.mapping_target
    }
}
impl IfcMappedItem {
    pub fn from_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcMappedItem::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.mapping_source = parameter.into(),
                1usize => entity.mapping_target = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcMaterial: IIfcMaterialDefinition {
    fn name(&self) -> &IfcLabel;
    fn description(&self) -> &Option<IfcText>;
    fn category(&self) -> &Option<IfcLabel>;
}
#[derive(Default, Debug)]
pub struct IfcMaterial {
    name: IfcLabel,
    description: Option<IfcText>,
    category: Option<IfcLabel>,
}
impl IIfcMaterialDefinition for IfcMaterial {}
impl IIfcMaterial for IfcMaterial {
    fn name(&self) -> &IfcLabel {
        &self.name
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
    fn category(&self) -> &Option<IfcLabel> {
        &self.category
    }
}
impl IfcMaterial {
    pub fn from_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcMaterial::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => {
                    entity.category = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcMaterialClassificationRelationship {
    fn material_classifications(&self) -> &HashSet<EntityRef>;
    fn classified_material(&self) -> &EntityRef;
}
#[derive(Default, Debug)]
pub struct IfcMaterialClassificationRelationship {
    material_classifications: HashSet<EntityRef>,
    classified_material: EntityRef,
}
impl IIfcMaterialClassificationRelationship for IfcMaterialClassificationRelationship {
    fn material_classifications(&self) -> &HashSet<EntityRef> {
        &self.material_classifications
    }
    fn classified_material(&self) -> &EntityRef {
        &self.classified_material
    }
}
impl IfcMaterialClassificationRelationship {
    pub fn from_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcMaterialClassificationRelationship::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.material_classifications = parameter.into(),
                1usize => entity.classified_material = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcMaterialConstituent: IIfcMaterialDefinition {
    fn name(&self) -> &Option<IfcLabel>;
    fn description(&self) -> &Option<IfcText>;
    fn material(&self) -> &EntityRef;
    fn fraction(&self) -> &Option<IfcNormalisedRatioMeasure>;
    fn category(&self) -> &Option<IfcLabel>;
}
#[derive(Default, Debug)]
pub struct IfcMaterialConstituent {
    name: Option<IfcLabel>,
    description: Option<IfcText>,
    material: EntityRef,
    fraction: Option<IfcNormalisedRatioMeasure>,
    category: Option<IfcLabel>,
}
impl IIfcMaterialDefinition for IfcMaterialConstituent {}
impl IIfcMaterialConstituent for IfcMaterialConstituent {
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
    fn material(&self) -> &EntityRef {
        &self.material
    }
    fn fraction(&self) -> &Option<IfcNormalisedRatioMeasure> {
        &self.fraction
    }
    fn category(&self) -> &Option<IfcLabel> {
        &self.category
    }
}
impl IfcMaterialConstituent {
    pub fn from_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcMaterialConstituent::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                1usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => entity.material = parameter.into(),
                3usize => {
                    entity.fraction = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => {
                    entity.category = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcMaterialConstituentSet: IIfcMaterialDefinition {
    fn name(&self) -> &Option<IfcLabel>;
    fn description(&self) -> &Option<IfcText>;
    fn material_constituents(&self) -> &Option<HashSet<EntityRef>>;
}
#[derive(Default, Debug)]
pub struct IfcMaterialConstituentSet {
    name: Option<IfcLabel>,
    description: Option<IfcText>,
    material_constituents: Option<HashSet<EntityRef>>,
}
impl IIfcMaterialDefinition for IfcMaterialConstituentSet {}
impl IIfcMaterialConstituentSet for IfcMaterialConstituentSet {
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
    fn material_constituents(&self) -> &Option<HashSet<EntityRef>> {
        &self.material_constituents
    }
}
impl IfcMaterialConstituentSet {
    pub fn from_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcMaterialConstituentSet::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                1usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => {
                    entity.material_constituents = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcMaterialDefinition {}
pub trait IIfcMaterialDefinitionRepresentation: IIfcProductRepresentation {
    fn represented_material(&self) -> &EntityRef;
}
#[derive(Default, Debug)]
pub struct IfcMaterialDefinitionRepresentation {
    name: Option<IfcLabel>,
    description: Option<IfcText>,
    representations: Vec<EntityRef>,
    represented_material: EntityRef,
}
impl IIfcProductRepresentation for IfcMaterialDefinitionRepresentation {
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
    fn representations(&self) -> &Vec<EntityRef> {
        &self.representations
    }
}
impl IIfcMaterialDefinitionRepresentation for IfcMaterialDefinitionRepresentation {
    fn represented_material(&self) -> &EntityRef {
        &self.represented_material
    }
}
impl IfcMaterialDefinitionRepresentation {
    pub fn from_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcMaterialDefinitionRepresentation::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                1usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => entity.representations = parameter.into(),
                3usize => entity.represented_material = parameter.into(),
                _ => {}
            }
        }
        entity
    }
    pub fn from_own_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcMaterialDefinitionRepresentation::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.represented_material = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcMaterialLayer: IIfcMaterialDefinition {
    fn material(&self) -> &Option<EntityRef>;
    fn layer_thickness(&self) -> &IfcNonNegativeLengthMeasure;
    fn is_ventilated(&self) -> &Option<IfcLogical>;
    fn name(&self) -> &Option<IfcLabel>;
    fn description(&self) -> &Option<IfcText>;
    fn category(&self) -> &Option<IfcLabel>;
    fn priority(&self) -> &Option<IfcInteger>;
}
#[derive(Default, Debug)]
pub struct IfcMaterialLayer {
    material: Option<EntityRef>,
    layer_thickness: IfcNonNegativeLengthMeasure,
    is_ventilated: Option<IfcLogical>,
    name: Option<IfcLabel>,
    description: Option<IfcText>,
    category: Option<IfcLabel>,
    priority: Option<IfcInteger>,
}
impl IIfcMaterialDefinition for IfcMaterialLayer {}
impl IIfcMaterialLayer for IfcMaterialLayer {
    fn material(&self) -> &Option<EntityRef> {
        &self.material
    }
    fn layer_thickness(&self) -> &IfcNonNegativeLengthMeasure {
        &self.layer_thickness
    }
    fn is_ventilated(&self) -> &Option<IfcLogical> {
        &self.is_ventilated
    }
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
    fn category(&self) -> &Option<IfcLabel> {
        &self.category
    }
    fn priority(&self) -> &Option<IfcInteger> {
        &self.priority
    }
}
impl IfcMaterialLayer {
    pub fn from_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcMaterialLayer::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => {
                    entity.material = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                1usize => entity.layer_thickness = parameter.into(),
                2usize => {
                    entity.is_ventilated = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                5usize => {
                    entity.category = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                6usize => {
                    entity.priority = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcMaterialLayerSet: IIfcMaterialDefinition {
    fn material_layers(&self) -> &Vec<EntityRef>;
    fn layer_set_name(&self) -> &Option<IfcLabel>;
    fn description(&self) -> &Option<IfcText>;
}
#[derive(Default, Debug)]
pub struct IfcMaterialLayerSet {
    material_layers: Vec<EntityRef>,
    layer_set_name: Option<IfcLabel>,
    description: Option<IfcText>,
}
impl IIfcMaterialDefinition for IfcMaterialLayerSet {}
impl IIfcMaterialLayerSet for IfcMaterialLayerSet {
    fn material_layers(&self) -> &Vec<EntityRef> {
        &self.material_layers
    }
    fn layer_set_name(&self) -> &Option<IfcLabel> {
        &self.layer_set_name
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
}
impl IfcMaterialLayerSet {
    pub fn from_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcMaterialLayerSet::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.material_layers = parameter.into(),
                1usize => {
                    entity.layer_set_name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcMaterialLayerSetUsage: IIfcMaterialUsageDefinition {
    fn for_layer_set(&self) -> &EntityRef;
    fn layer_set_direction(&self) -> &IfcLayerSetDirectionEnum;
    fn direction_sense(&self) -> &IfcDirectionSenseEnum;
    fn offset_from_reference_line(&self) -> &IfcLengthMeasure;
    fn reference_extent(&self) -> &Option<IfcPositiveLengthMeasure>;
}
#[derive(Default, Debug)]
pub struct IfcMaterialLayerSetUsage {
    for_layer_set: EntityRef,
    layer_set_direction: IfcLayerSetDirectionEnum,
    direction_sense: IfcDirectionSenseEnum,
    offset_from_reference_line: IfcLengthMeasure,
    reference_extent: Option<IfcPositiveLengthMeasure>,
}
impl IIfcMaterialUsageDefinition for IfcMaterialLayerSetUsage {}
impl IIfcMaterialLayerSetUsage for IfcMaterialLayerSetUsage {
    fn for_layer_set(&self) -> &EntityRef {
        &self.for_layer_set
    }
    fn layer_set_direction(&self) -> &IfcLayerSetDirectionEnum {
        &self.layer_set_direction
    }
    fn direction_sense(&self) -> &IfcDirectionSenseEnum {
        &self.direction_sense
    }
    fn offset_from_reference_line(&self) -> &IfcLengthMeasure {
        &self.offset_from_reference_line
    }
    fn reference_extent(&self) -> &Option<IfcPositiveLengthMeasure> {
        &self.reference_extent
    }
}
impl IfcMaterialLayerSetUsage {
    pub fn from_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcMaterialLayerSetUsage::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.for_layer_set = parameter.into(),
                1usize => entity.layer_set_direction = parameter.into(),
                2usize => entity.direction_sense = parameter.into(),
                3usize => entity.offset_from_reference_line = parameter.into(),
                4usize => {
                    entity.reference_extent = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcMaterialLayerWithOffsets: IIfcMaterialLayer {
    fn offset_direction(&self) -> &IfcLayerSetDirectionEnum;
    fn offset_values(&self) -> &Vec<IfcLengthMeasure>;
}
#[derive(Default, Debug)]
pub struct IfcMaterialLayerWithOffsets {
    material: Option<EntityRef>,
    layer_thickness: IfcNonNegativeLengthMeasure,
    is_ventilated: Option<IfcLogical>,
    name: Option<IfcLabel>,
    description: Option<IfcText>,
    category: Option<IfcLabel>,
    priority: Option<IfcInteger>,
    offset_direction: IfcLayerSetDirectionEnum,
    offset_values: Vec<IfcLengthMeasure>,
}
impl IIfcMaterialDefinition for IfcMaterialLayerWithOffsets {}
impl IIfcMaterialLayer for IfcMaterialLayerWithOffsets {
    fn material(&self) -> &Option<EntityRef> {
        &self.material
    }
    fn layer_thickness(&self) -> &IfcNonNegativeLengthMeasure {
        &self.layer_thickness
    }
    fn is_ventilated(&self) -> &Option<IfcLogical> {
        &self.is_ventilated
    }
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
    fn category(&self) -> &Option<IfcLabel> {
        &self.category
    }
    fn priority(&self) -> &Option<IfcInteger> {
        &self.priority
    }
}
impl IIfcMaterialLayerWithOffsets for IfcMaterialLayerWithOffsets {
    fn offset_direction(&self) -> &IfcLayerSetDirectionEnum {
        &self.offset_direction
    }
    fn offset_values(&self) -> &Vec<IfcLengthMeasure> {
        &self.offset_values
    }
}
impl IfcMaterialLayerWithOffsets {
    pub fn from_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcMaterialLayerWithOffsets::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => {
                    entity.material = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                1usize => entity.layer_thickness = parameter.into(),
                2usize => {
                    entity.is_ventilated = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                5usize => {
                    entity.category = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                6usize => {
                    entity.priority = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                7usize => entity.offset_direction = parameter.into(),
                8usize => entity.offset_values = parameter.into(),
                _ => {}
            }
        }
        entity
    }
    pub fn from_own_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcMaterialLayerWithOffsets::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.offset_direction = parameter.into(),
                1usize => entity.offset_values = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcMaterialList {
    fn materials(&self) -> &Vec<EntityRef>;
}
#[derive(Default, Debug)]
pub struct IfcMaterialList {
    materials: Vec<EntityRef>,
}
impl IIfcMaterialList for IfcMaterialList {
    fn materials(&self) -> &Vec<EntityRef> {
        &self.materials
    }
}
impl IfcMaterialList {
    pub fn from_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcMaterialList::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.materials = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcMaterialProfile: IIfcMaterialDefinition {
    fn name(&self) -> &Option<IfcLabel>;
    fn description(&self) -> &Option<IfcText>;
    fn material(&self) -> &Option<EntityRef>;
    fn profile(&self) -> &EntityRef;
    fn priority(&self) -> &Option<IfcInteger>;
    fn category(&self) -> &Option<IfcLabel>;
}
#[derive(Default, Debug)]
pub struct IfcMaterialProfile {
    name: Option<IfcLabel>,
    description: Option<IfcText>,
    material: Option<EntityRef>,
    profile: EntityRef,
    priority: Option<IfcInteger>,
    category: Option<IfcLabel>,
}
impl IIfcMaterialDefinition for IfcMaterialProfile {}
impl IIfcMaterialProfile for IfcMaterialProfile {
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
    fn material(&self) -> &Option<EntityRef> {
        &self.material
    }
    fn profile(&self) -> &EntityRef {
        &self.profile
    }
    fn priority(&self) -> &Option<IfcInteger> {
        &self.priority
    }
    fn category(&self) -> &Option<IfcLabel> {
        &self.category
    }
}
impl IfcMaterialProfile {
    pub fn from_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcMaterialProfile::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                1usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => {
                    entity.material = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => entity.profile = parameter.into(),
                4usize => {
                    entity.priority = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                5usize => {
                    entity.category = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcMaterialProfileSet: IIfcMaterialDefinition {
    fn name(&self) -> &Option<IfcLabel>;
    fn description(&self) -> &Option<IfcText>;
    fn material_profiles(&self) -> &Vec<EntityRef>;
    fn composite_profile(&self) -> &Option<EntityRef>;
}
#[derive(Default, Debug)]
pub struct IfcMaterialProfileSet {
    name: Option<IfcLabel>,
    description: Option<IfcText>,
    material_profiles: Vec<EntityRef>,
    composite_profile: Option<EntityRef>,
}
impl IIfcMaterialDefinition for IfcMaterialProfileSet {}
impl IIfcMaterialProfileSet for IfcMaterialProfileSet {
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
    fn material_profiles(&self) -> &Vec<EntityRef> {
        &self.material_profiles
    }
    fn composite_profile(&self) -> &Option<EntityRef> {
        &self.composite_profile
    }
}
impl IfcMaterialProfileSet {
    pub fn from_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcMaterialProfileSet::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                1usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => entity.material_profiles = parameter.into(),
                3usize => {
                    entity.composite_profile = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcMaterialProfileSetUsage: IIfcMaterialUsageDefinition {
    fn for_profile_set(&self) -> &EntityRef;
    fn cardinal_point(&self) -> &Option<IfcCardinalPointReference>;
    fn reference_extent(&self) -> &Option<IfcPositiveLengthMeasure>;
}
#[derive(Default, Debug)]
pub struct IfcMaterialProfileSetUsage {
    for_profile_set: EntityRef,
    cardinal_point: Option<IfcCardinalPointReference>,
    reference_extent: Option<IfcPositiveLengthMeasure>,
}
impl IIfcMaterialUsageDefinition for IfcMaterialProfileSetUsage {}
impl IIfcMaterialProfileSetUsage for IfcMaterialProfileSetUsage {
    fn for_profile_set(&self) -> &EntityRef {
        &self.for_profile_set
    }
    fn cardinal_point(&self) -> &Option<IfcCardinalPointReference> {
        &self.cardinal_point
    }
    fn reference_extent(&self) -> &Option<IfcPositiveLengthMeasure> {
        &self.reference_extent
    }
}
impl IfcMaterialProfileSetUsage {
    pub fn from_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcMaterialProfileSetUsage::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.for_profile_set = parameter.into(),
                1usize => {
                    entity.cardinal_point = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => {
                    entity.reference_extent = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcMaterialProfileSetUsageTapering: IIfcMaterialProfileSetUsage {
    fn for_profile_end_set(&self) -> &EntityRef;
    fn cardinal_end_point(&self) -> &Option<IfcCardinalPointReference>;
}
#[derive(Default, Debug)]
pub struct IfcMaterialProfileSetUsageTapering {
    for_profile_set: EntityRef,
    cardinal_point: Option<IfcCardinalPointReference>,
    reference_extent: Option<IfcPositiveLengthMeasure>,
    for_profile_end_set: EntityRef,
    cardinal_end_point: Option<IfcCardinalPointReference>,
}
impl IIfcMaterialUsageDefinition for IfcMaterialProfileSetUsageTapering {}
impl IIfcMaterialProfileSetUsage for IfcMaterialProfileSetUsageTapering {
    fn for_profile_set(&self) -> &EntityRef {
        &self.for_profile_set
    }
    fn cardinal_point(&self) -> &Option<IfcCardinalPointReference> {
        &self.cardinal_point
    }
    fn reference_extent(&self) -> &Option<IfcPositiveLengthMeasure> {
        &self.reference_extent
    }
}
impl IIfcMaterialProfileSetUsageTapering for IfcMaterialProfileSetUsageTapering {
    fn for_profile_end_set(&self) -> &EntityRef {
        &self.for_profile_end_set
    }
    fn cardinal_end_point(&self) -> &Option<IfcCardinalPointReference> {
        &self.cardinal_end_point
    }
}
impl IfcMaterialProfileSetUsageTapering {
    pub fn from_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcMaterialProfileSetUsageTapering::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.for_profile_set = parameter.into(),
                1usize => {
                    entity.cardinal_point = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => {
                    entity.reference_extent = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => entity.for_profile_end_set = parameter.into(),
                4usize => {
                    entity.cardinal_end_point = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
    pub fn from_own_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcMaterialProfileSetUsageTapering::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.for_profile_end_set = parameter.into(),
                1usize => {
                    entity.cardinal_end_point = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcMaterialProfileWithOffsets: IIfcMaterialProfile {
    fn offset_values(&self) -> &Vec<IfcLengthMeasure>;
}
#[derive(Default, Debug)]
pub struct IfcMaterialProfileWithOffsets {
    name: Option<IfcLabel>,
    description: Option<IfcText>,
    material: Option<EntityRef>,
    profile: EntityRef,
    priority: Option<IfcInteger>,
    category: Option<IfcLabel>,
    offset_values: Vec<IfcLengthMeasure>,
}
impl IIfcMaterialDefinition for IfcMaterialProfileWithOffsets {}
impl IIfcMaterialProfile for IfcMaterialProfileWithOffsets {
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
    fn material(&self) -> &Option<EntityRef> {
        &self.material
    }
    fn profile(&self) -> &EntityRef {
        &self.profile
    }
    fn priority(&self) -> &Option<IfcInteger> {
        &self.priority
    }
    fn category(&self) -> &Option<IfcLabel> {
        &self.category
    }
}
impl IIfcMaterialProfileWithOffsets for IfcMaterialProfileWithOffsets {
    fn offset_values(&self) -> &Vec<IfcLengthMeasure> {
        &self.offset_values
    }
}
impl IfcMaterialProfileWithOffsets {
    pub fn from_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcMaterialProfileWithOffsets::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                1usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => {
                    entity.material = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => entity.profile = parameter.into(),
                4usize => {
                    entity.priority = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                5usize => {
                    entity.category = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                6usize => entity.offset_values = parameter.into(),
                _ => {}
            }
        }
        entity
    }
    pub fn from_own_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcMaterialProfileWithOffsets::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.offset_values = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcMaterialProperties: IIfcExtendedProperties {
    fn material(&self) -> &EntityRef;
}
#[derive(Default, Debug)]
pub struct IfcMaterialProperties {
    name: Option<IfcIdentifier>,
    description: Option<IfcText>,
    properties: HashSet<EntityRef>,
    material: EntityRef,
}
impl IIfcPropertyAbstraction for IfcMaterialProperties {}
impl IIfcExtendedProperties for IfcMaterialProperties {
    fn name(&self) -> &Option<IfcIdentifier> {
        &self.name
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
    fn properties(&self) -> &HashSet<EntityRef> {
        &self.properties
    }
}
impl IIfcMaterialProperties for IfcMaterialProperties {
    fn material(&self) -> &EntityRef {
        &self.material
    }
}
impl IfcMaterialProperties {
    pub fn from_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcMaterialProperties::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                1usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => entity.properties = parameter.into(),
                3usize => entity.material = parameter.into(),
                _ => {}
            }
        }
        entity
    }
    pub fn from_own_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcMaterialProperties::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.material = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcMaterialRelationship: IIfcResourceLevelRelationship {
    fn relating_material(&self) -> &EntityRef;
    fn related_materials(&self) -> &HashSet<EntityRef>;
    fn expression(&self) -> &Option<IfcLabel>;
}
#[derive(Default, Debug)]
pub struct IfcMaterialRelationship {
    name: Option<IfcLabel>,
    description: Option<IfcText>,
    relating_material: EntityRef,
    related_materials: HashSet<EntityRef>,
    expression: Option<IfcLabel>,
}
impl IIfcResourceLevelRelationship for IfcMaterialRelationship {
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
}
impl IIfcMaterialRelationship for IfcMaterialRelationship {
    fn relating_material(&self) -> &EntityRef {
        &self.relating_material
    }
    fn related_materials(&self) -> &HashSet<EntityRef> {
        &self.related_materials
    }
    fn expression(&self) -> &Option<IfcLabel> {
        &self.expression
    }
}
impl IfcMaterialRelationship {
    pub fn from_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcMaterialRelationship::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                1usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => entity.relating_material = parameter.into(),
                3usize => entity.related_materials = parameter.into(),
                4usize => {
                    entity.expression = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
    pub fn from_own_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcMaterialRelationship::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.relating_material = parameter.into(),
                1usize => entity.related_materials = parameter.into(),
                2usize => {
                    entity.expression = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcMaterialUsageDefinition {}
pub trait IIfcMeasureWithUnit {
    fn value_component(&self) -> &IfcValue;
    fn unit_component(&self) -> &EntityRef;
}
#[derive(Default, Debug)]
pub struct IfcMeasureWithUnit {
    value_component: IfcValue,
    unit_component: EntityRef,
}
impl IIfcMeasureWithUnit for IfcMeasureWithUnit {
    fn value_component(&self) -> &IfcValue {
        &self.value_component
    }
    fn unit_component(&self) -> &EntityRef {
        &self.unit_component
    }
}
impl IfcMeasureWithUnit {
    pub fn from_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcMeasureWithUnit::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.value_component = parameter.into(),
                1usize => entity.unit_component = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcMechanicalFastener: IIfcElementComponent {
    fn nominal_diameter(&self) -> &Option<IfcPositiveLengthMeasure>;
    fn nominal_length(&self) -> &Option<IfcPositiveLengthMeasure>;
    fn predefined_type(&self) -> &Option<IfcMechanicalFastenerTypeEnum>;
}
#[derive(Default, Debug)]
pub struct IfcMechanicalFastener {
    global_id: IfcGloballyUniqueId,
    owner_history: Option<EntityRef>,
    name: Option<IfcLabel>,
    description: Option<IfcText>,
    object_type: Option<IfcLabel>,
    object_placement: Option<EntityRef>,
    representation: Option<EntityRef>,
    tag: Option<IfcIdentifier>,
    nominal_diameter: Option<IfcPositiveLengthMeasure>,
    nominal_length: Option<IfcPositiveLengthMeasure>,
    predefined_type: Option<IfcMechanicalFastenerTypeEnum>,
}
impl IIfcRoot for IfcMechanicalFastener {
    fn global_id(&self) -> &IfcGloballyUniqueId {
        &self.global_id
    }
    fn owner_history(&self) -> &Option<EntityRef> {
        &self.owner_history
    }
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
}
impl IIfcObjectDefinition for IfcMechanicalFastener {}
impl IIfcObject for IfcMechanicalFastener {
    fn object_type(&self) -> &Option<IfcLabel> {
        &self.object_type
    }
}
impl IIfcProduct for IfcMechanicalFastener {
    fn object_placement(&self) -> &Option<EntityRef> {
        &self.object_placement
    }
    fn representation(&self) -> &Option<EntityRef> {
        &self.representation
    }
}
impl IIfcElement for IfcMechanicalFastener {
    fn tag(&self) -> &Option<IfcIdentifier> {
        &self.tag
    }
}
impl IIfcElementComponent for IfcMechanicalFastener {}
impl IIfcMechanicalFastener for IfcMechanicalFastener {
    fn nominal_diameter(&self) -> &Option<IfcPositiveLengthMeasure> {
        &self.nominal_diameter
    }
    fn nominal_length(&self) -> &Option<IfcPositiveLengthMeasure> {
        &self.nominal_length
    }
    fn predefined_type(&self) -> &Option<IfcMechanicalFastenerTypeEnum> {
        &self.predefined_type
    }
}
impl IfcMechanicalFastener {
    pub fn from_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcMechanicalFastener::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.global_id = parameter.into(),
                1usize => {
                    entity.owner_history = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => {
                    entity.object_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                5usize => {
                    entity.object_placement = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                6usize => {
                    entity.representation = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                7usize => {
                    entity.tag = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                8usize => {
                    entity.nominal_diameter = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                9usize => {
                    entity.nominal_length = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                10usize => {
                    entity.predefined_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
    pub fn from_own_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcMechanicalFastener::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => {
                    entity.nominal_diameter = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                1usize => {
                    entity.nominal_length = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => {
                    entity.predefined_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcMechanicalFastenerType: IIfcElementComponentType {
    fn predefined_type(&self) -> &IfcMechanicalFastenerTypeEnum;
    fn nominal_diameter(&self) -> &Option<IfcPositiveLengthMeasure>;
    fn nominal_length(&self) -> &Option<IfcPositiveLengthMeasure>;
}
#[derive(Default, Debug)]
pub struct IfcMechanicalFastenerType {
    global_id: IfcGloballyUniqueId,
    owner_history: Option<EntityRef>,
    name: Option<IfcLabel>,
    description: Option<IfcText>,
    applicable_occurrence: Option<IfcIdentifier>,
    has_property_sets: Option<HashSet<EntityRef>>,
    representation_maps: Option<Vec<EntityRef>>,
    tag: Option<IfcLabel>,
    element_type: Option<IfcLabel>,
    predefined_type: IfcMechanicalFastenerTypeEnum,
    nominal_diameter: Option<IfcPositiveLengthMeasure>,
    nominal_length: Option<IfcPositiveLengthMeasure>,
}
impl IIfcRoot for IfcMechanicalFastenerType {
    fn global_id(&self) -> &IfcGloballyUniqueId {
        &self.global_id
    }
    fn owner_history(&self) -> &Option<EntityRef> {
        &self.owner_history
    }
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
}
impl IIfcObjectDefinition for IfcMechanicalFastenerType {}
impl IIfcTypeObject for IfcMechanicalFastenerType {
    fn applicable_occurrence(&self) -> &Option<IfcIdentifier> {
        &self.applicable_occurrence
    }
    fn has_property_sets(&self) -> &Option<HashSet<EntityRef>> {
        &self.has_property_sets
    }
}
impl IIfcTypeProduct for IfcMechanicalFastenerType {
    fn representation_maps(&self) -> &Option<Vec<EntityRef>> {
        &self.representation_maps
    }
    fn tag(&self) -> &Option<IfcLabel> {
        &self.tag
    }
}
impl IIfcElementType for IfcMechanicalFastenerType {
    fn element_type(&self) -> &Option<IfcLabel> {
        &self.element_type
    }
}
impl IIfcElementComponentType for IfcMechanicalFastenerType {}
impl IIfcMechanicalFastenerType for IfcMechanicalFastenerType {
    fn predefined_type(&self) -> &IfcMechanicalFastenerTypeEnum {
        &self.predefined_type
    }
    fn nominal_diameter(&self) -> &Option<IfcPositiveLengthMeasure> {
        &self.nominal_diameter
    }
    fn nominal_length(&self) -> &Option<IfcPositiveLengthMeasure> {
        &self.nominal_length
    }
}
impl IfcMechanicalFastenerType {
    pub fn from_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcMechanicalFastenerType::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.global_id = parameter.into(),
                1usize => {
                    entity.owner_history = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => {
                    entity.applicable_occurrence = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                5usize => {
                    entity.has_property_sets = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                6usize => {
                    entity.representation_maps = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                7usize => {
                    entity.tag = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                8usize => {
                    entity.element_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                9usize => entity.predefined_type = parameter.into(),
                10usize => {
                    entity.nominal_diameter = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                11usize => {
                    entity.nominal_length = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
    pub fn from_own_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcMechanicalFastenerType::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.predefined_type = parameter.into(),
                1usize => {
                    entity.nominal_diameter = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => {
                    entity.nominal_length = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcMedicalDevice: IIfcFlowTerminal {
    fn predefined_type(&self) -> &Option<IfcMedicalDeviceTypeEnum>;
}
#[derive(Default, Debug)]
pub struct IfcMedicalDevice {
    global_id: IfcGloballyUniqueId,
    owner_history: Option<EntityRef>,
    name: Option<IfcLabel>,
    description: Option<IfcText>,
    object_type: Option<IfcLabel>,
    object_placement: Option<EntityRef>,
    representation: Option<EntityRef>,
    tag: Option<IfcIdentifier>,
    predefined_type: Option<IfcMedicalDeviceTypeEnum>,
}
impl IIfcRoot for IfcMedicalDevice {
    fn global_id(&self) -> &IfcGloballyUniqueId {
        &self.global_id
    }
    fn owner_history(&self) -> &Option<EntityRef> {
        &self.owner_history
    }
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
}
impl IIfcObjectDefinition for IfcMedicalDevice {}
impl IIfcObject for IfcMedicalDevice {
    fn object_type(&self) -> &Option<IfcLabel> {
        &self.object_type
    }
}
impl IIfcProduct for IfcMedicalDevice {
    fn object_placement(&self) -> &Option<EntityRef> {
        &self.object_placement
    }
    fn representation(&self) -> &Option<EntityRef> {
        &self.representation
    }
}
impl IIfcElement for IfcMedicalDevice {
    fn tag(&self) -> &Option<IfcIdentifier> {
        &self.tag
    }
}
impl IIfcDistributionElement for IfcMedicalDevice {}
impl IIfcDistributionFlowElement for IfcMedicalDevice {}
impl IIfcFlowTerminal for IfcMedicalDevice {}
impl IIfcMedicalDevice for IfcMedicalDevice {
    fn predefined_type(&self) -> &Option<IfcMedicalDeviceTypeEnum> {
        &self.predefined_type
    }
}
impl IfcMedicalDevice {
    pub fn from_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcMedicalDevice::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.global_id = parameter.into(),
                1usize => {
                    entity.owner_history = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => {
                    entity.object_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                5usize => {
                    entity.object_placement = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                6usize => {
                    entity.representation = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                7usize => {
                    entity.tag = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                8usize => {
                    entity.predefined_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
    pub fn from_own_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcMedicalDevice::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => {
                    entity.predefined_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcMedicalDeviceType: IIfcFlowTerminalType {
    fn predefined_type(&self) -> &IfcMedicalDeviceTypeEnum;
}
#[derive(Default, Debug)]
pub struct IfcMedicalDeviceType {
    global_id: IfcGloballyUniqueId,
    owner_history: Option<EntityRef>,
    name: Option<IfcLabel>,
    description: Option<IfcText>,
    applicable_occurrence: Option<IfcIdentifier>,
    has_property_sets: Option<HashSet<EntityRef>>,
    representation_maps: Option<Vec<EntityRef>>,
    tag: Option<IfcLabel>,
    element_type: Option<IfcLabel>,
    predefined_type: IfcMedicalDeviceTypeEnum,
}
impl IIfcRoot for IfcMedicalDeviceType {
    fn global_id(&self) -> &IfcGloballyUniqueId {
        &self.global_id
    }
    fn owner_history(&self) -> &Option<EntityRef> {
        &self.owner_history
    }
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
}
impl IIfcObjectDefinition for IfcMedicalDeviceType {}
impl IIfcTypeObject for IfcMedicalDeviceType {
    fn applicable_occurrence(&self) -> &Option<IfcIdentifier> {
        &self.applicable_occurrence
    }
    fn has_property_sets(&self) -> &Option<HashSet<EntityRef>> {
        &self.has_property_sets
    }
}
impl IIfcTypeProduct for IfcMedicalDeviceType {
    fn representation_maps(&self) -> &Option<Vec<EntityRef>> {
        &self.representation_maps
    }
    fn tag(&self) -> &Option<IfcLabel> {
        &self.tag
    }
}
impl IIfcElementType for IfcMedicalDeviceType {
    fn element_type(&self) -> &Option<IfcLabel> {
        &self.element_type
    }
}
impl IIfcDistributionElementType for IfcMedicalDeviceType {}
impl IIfcDistributionFlowElementType for IfcMedicalDeviceType {}
impl IIfcFlowTerminalType for IfcMedicalDeviceType {}
impl IIfcMedicalDeviceType for IfcMedicalDeviceType {
    fn predefined_type(&self) -> &IfcMedicalDeviceTypeEnum {
        &self.predefined_type
    }
}
impl IfcMedicalDeviceType {
    pub fn from_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcMedicalDeviceType::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.global_id = parameter.into(),
                1usize => {
                    entity.owner_history = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => {
                    entity.applicable_occurrence = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                5usize => {
                    entity.has_property_sets = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                6usize => {
                    entity.representation_maps = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                7usize => {
                    entity.tag = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                8usize => {
                    entity.element_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                9usize => entity.predefined_type = parameter.into(),
                _ => {}
            }
        }
        entity
    }
    pub fn from_own_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcMedicalDeviceType::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.predefined_type = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcMember: IIfcBuildingElement {
    fn predefined_type(&self) -> &Option<IfcMemberTypeEnum>;
}
#[derive(Default, Debug)]
pub struct IfcMember {
    global_id: IfcGloballyUniqueId,
    owner_history: Option<EntityRef>,
    name: Option<IfcLabel>,
    description: Option<IfcText>,
    object_type: Option<IfcLabel>,
    object_placement: Option<EntityRef>,
    representation: Option<EntityRef>,
    tag: Option<IfcIdentifier>,
    predefined_type: Option<IfcMemberTypeEnum>,
}
impl IIfcRoot for IfcMember {
    fn global_id(&self) -> &IfcGloballyUniqueId {
        &self.global_id
    }
    fn owner_history(&self) -> &Option<EntityRef> {
        &self.owner_history
    }
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
}
impl IIfcObjectDefinition for IfcMember {}
impl IIfcObject for IfcMember {
    fn object_type(&self) -> &Option<IfcLabel> {
        &self.object_type
    }
}
impl IIfcProduct for IfcMember {
    fn object_placement(&self) -> &Option<EntityRef> {
        &self.object_placement
    }
    fn representation(&self) -> &Option<EntityRef> {
        &self.representation
    }
}
impl IIfcElement for IfcMember {
    fn tag(&self) -> &Option<IfcIdentifier> {
        &self.tag
    }
}
impl IIfcBuildingElement for IfcMember {}
impl IIfcMember for IfcMember {
    fn predefined_type(&self) -> &Option<IfcMemberTypeEnum> {
        &self.predefined_type
    }
}
impl IfcMember {
    pub fn from_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcMember::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.global_id = parameter.into(),
                1usize => {
                    entity.owner_history = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => {
                    entity.object_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                5usize => {
                    entity.object_placement = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                6usize => {
                    entity.representation = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                7usize => {
                    entity.tag = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                8usize => {
                    entity.predefined_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
    pub fn from_own_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcMember::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => {
                    entity.predefined_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcMemberStandardCase: IIfcMember {}
#[derive(Default, Debug)]
pub struct IfcMemberStandardCase {
    global_id: IfcGloballyUniqueId,
    owner_history: Option<EntityRef>,
    name: Option<IfcLabel>,
    description: Option<IfcText>,
    object_type: Option<IfcLabel>,
    object_placement: Option<EntityRef>,
    representation: Option<EntityRef>,
    tag: Option<IfcIdentifier>,
    predefined_type: Option<IfcMemberTypeEnum>,
}
impl IIfcRoot for IfcMemberStandardCase {
    fn global_id(&self) -> &IfcGloballyUniqueId {
        &self.global_id
    }
    fn owner_history(&self) -> &Option<EntityRef> {
        &self.owner_history
    }
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
}
impl IIfcObjectDefinition for IfcMemberStandardCase {}
impl IIfcObject for IfcMemberStandardCase {
    fn object_type(&self) -> &Option<IfcLabel> {
        &self.object_type
    }
}
impl IIfcProduct for IfcMemberStandardCase {
    fn object_placement(&self) -> &Option<EntityRef> {
        &self.object_placement
    }
    fn representation(&self) -> &Option<EntityRef> {
        &self.representation
    }
}
impl IIfcElement for IfcMemberStandardCase {
    fn tag(&self) -> &Option<IfcIdentifier> {
        &self.tag
    }
}
impl IIfcBuildingElement for IfcMemberStandardCase {}
impl IIfcMember for IfcMemberStandardCase {
    fn predefined_type(&self) -> &Option<IfcMemberTypeEnum> {
        &self.predefined_type
    }
}
impl IIfcMemberStandardCase for IfcMemberStandardCase {}
impl IfcMemberStandardCase {
    pub fn from_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcMemberStandardCase::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.global_id = parameter.into(),
                1usize => {
                    entity.owner_history = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => {
                    entity.object_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                5usize => {
                    entity.object_placement = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                6usize => {
                    entity.representation = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                7usize => {
                    entity.tag = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                8usize => {
                    entity.predefined_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcMemberType: IIfcBuildingElementType {
    fn predefined_type(&self) -> &IfcMemberTypeEnum;
}
#[derive(Default, Debug)]
pub struct IfcMemberType {
    global_id: IfcGloballyUniqueId,
    owner_history: Option<EntityRef>,
    name: Option<IfcLabel>,
    description: Option<IfcText>,
    applicable_occurrence: Option<IfcIdentifier>,
    has_property_sets: Option<HashSet<EntityRef>>,
    representation_maps: Option<Vec<EntityRef>>,
    tag: Option<IfcLabel>,
    element_type: Option<IfcLabel>,
    predefined_type: IfcMemberTypeEnum,
}
impl IIfcRoot for IfcMemberType {
    fn global_id(&self) -> &IfcGloballyUniqueId {
        &self.global_id
    }
    fn owner_history(&self) -> &Option<EntityRef> {
        &self.owner_history
    }
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
}
impl IIfcObjectDefinition for IfcMemberType {}
impl IIfcTypeObject for IfcMemberType {
    fn applicable_occurrence(&self) -> &Option<IfcIdentifier> {
        &self.applicable_occurrence
    }
    fn has_property_sets(&self) -> &Option<HashSet<EntityRef>> {
        &self.has_property_sets
    }
}
impl IIfcTypeProduct for IfcMemberType {
    fn representation_maps(&self) -> &Option<Vec<EntityRef>> {
        &self.representation_maps
    }
    fn tag(&self) -> &Option<IfcLabel> {
        &self.tag
    }
}
impl IIfcElementType for IfcMemberType {
    fn element_type(&self) -> &Option<IfcLabel> {
        &self.element_type
    }
}
impl IIfcBuildingElementType for IfcMemberType {}
impl IIfcMemberType for IfcMemberType {
    fn predefined_type(&self) -> &IfcMemberTypeEnum {
        &self.predefined_type
    }
}
impl IfcMemberType {
    pub fn from_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcMemberType::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.global_id = parameter.into(),
                1usize => {
                    entity.owner_history = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => {
                    entity.applicable_occurrence = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                5usize => {
                    entity.has_property_sets = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                6usize => {
                    entity.representation_maps = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                7usize => {
                    entity.tag = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                8usize => {
                    entity.element_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                9usize => entity.predefined_type = parameter.into(),
                _ => {}
            }
        }
        entity
    }
    pub fn from_own_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcMemberType::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.predefined_type = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcMetric: IIfcConstraint {
    fn benchmark(&self) -> &IfcBenchmarkEnum;
    fn value_source(&self) -> &Option<IfcLabel>;
    fn data_value(&self) -> &Option<IfcMetricValueSelect>;
    fn reference_path(&self) -> &Option<EntityRef>;
}
#[derive(Default, Debug)]
pub struct IfcMetric {
    name: IfcLabel,
    description: Option<IfcText>,
    constraint_grade: IfcConstraintEnum,
    constraint_source: Option<IfcLabel>,
    creating_actor: Option<EntityRef>,
    creation_time: Option<IfcDateTime>,
    user_defined_grade: Option<IfcLabel>,
    benchmark: IfcBenchmarkEnum,
    value_source: Option<IfcLabel>,
    data_value: Option<IfcMetricValueSelect>,
    reference_path: Option<EntityRef>,
}
impl IIfcConstraint for IfcMetric {
    fn name(&self) -> &IfcLabel {
        &self.name
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
    fn constraint_grade(&self) -> &IfcConstraintEnum {
        &self.constraint_grade
    }
    fn constraint_source(&self) -> &Option<IfcLabel> {
        &self.constraint_source
    }
    fn creating_actor(&self) -> &Option<EntityRef> {
        &self.creating_actor
    }
    fn creation_time(&self) -> &Option<IfcDateTime> {
        &self.creation_time
    }
    fn user_defined_grade(&self) -> &Option<IfcLabel> {
        &self.user_defined_grade
    }
}
impl IIfcMetric for IfcMetric {
    fn benchmark(&self) -> &IfcBenchmarkEnum {
        &self.benchmark
    }
    fn value_source(&self) -> &Option<IfcLabel> {
        &self.value_source
    }
    fn data_value(&self) -> &Option<IfcMetricValueSelect> {
        &self.data_value
    }
    fn reference_path(&self) -> &Option<EntityRef> {
        &self.reference_path
    }
}
impl IfcMetric {
    pub fn from_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcMetric::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => entity.constraint_grade = parameter.into(),
                3usize => {
                    entity.constraint_source = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => {
                    entity.creating_actor = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                5usize => {
                    entity.creation_time = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                6usize => {
                    entity.user_defined_grade = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                7usize => entity.benchmark = parameter.into(),
                8usize => {
                    entity.value_source = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                9usize => {
                    entity.data_value = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                10usize => {
                    entity.reference_path = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
    pub fn from_own_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcMetric::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.benchmark = parameter.into(),
                1usize => {
                    entity.value_source = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => {
                    entity.data_value = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.reference_path = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcMirroredProfileDef: IIfcDerivedProfileDef {}
#[derive(Default, Debug)]
pub struct IfcMirroredProfileDef {
    profile_type: IfcProfileTypeEnum,
    profile_name: Option<IfcLabel>,
    parent_profile: EntityRef,
    operator: EntityRef,
    label: Option<IfcLabel>,
}
impl IIfcProfileDef for IfcMirroredProfileDef {
    fn profile_type(&self) -> &IfcProfileTypeEnum {
        &self.profile_type
    }
    fn profile_name(&self) -> &Option<IfcLabel> {
        &self.profile_name
    }
}
impl IIfcDerivedProfileDef for IfcMirroredProfileDef {
    fn parent_profile(&self) -> &EntityRef {
        &self.parent_profile
    }
    fn operator(&self) -> &EntityRef {
        &self.operator
    }
    fn label(&self) -> &Option<IfcLabel> {
        &self.label
    }
}
impl IIfcMirroredProfileDef for IfcMirroredProfileDef {}
impl IfcMirroredProfileDef {
    pub fn from_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcMirroredProfileDef::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.profile_type = parameter.into(),
                1usize => {
                    entity.profile_name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => entity.parent_profile = parameter.into(),
                3usize => entity.operator = parameter.into(),
                4usize => {
                    entity.label = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcMonetaryUnit {
    fn currency(&self) -> &IfcLabel;
}
#[derive(Default, Debug)]
pub struct IfcMonetaryUnit {
    currency: IfcLabel,
}
impl IIfcMonetaryUnit for IfcMonetaryUnit {
    fn currency(&self) -> &IfcLabel {
        &self.currency
    }
}
impl IfcMonetaryUnit {
    pub fn from_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcMonetaryUnit::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.currency = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcMotorConnection: IIfcEnergyConversionDevice {
    fn predefined_type(&self) -> &Option<IfcMotorConnectionTypeEnum>;
}
#[derive(Default, Debug)]
pub struct IfcMotorConnection {
    global_id: IfcGloballyUniqueId,
    owner_history: Option<EntityRef>,
    name: Option<IfcLabel>,
    description: Option<IfcText>,
    object_type: Option<IfcLabel>,
    object_placement: Option<EntityRef>,
    representation: Option<EntityRef>,
    tag: Option<IfcIdentifier>,
    predefined_type: Option<IfcMotorConnectionTypeEnum>,
}
impl IIfcRoot for IfcMotorConnection {
    fn global_id(&self) -> &IfcGloballyUniqueId {
        &self.global_id
    }
    fn owner_history(&self) -> &Option<EntityRef> {
        &self.owner_history
    }
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
}
impl IIfcObjectDefinition for IfcMotorConnection {}
impl IIfcObject for IfcMotorConnection {
    fn object_type(&self) -> &Option<IfcLabel> {
        &self.object_type
    }
}
impl IIfcProduct for IfcMotorConnection {
    fn object_placement(&self) -> &Option<EntityRef> {
        &self.object_placement
    }
    fn representation(&self) -> &Option<EntityRef> {
        &self.representation
    }
}
impl IIfcElement for IfcMotorConnection {
    fn tag(&self) -> &Option<IfcIdentifier> {
        &self.tag
    }
}
impl IIfcDistributionElement for IfcMotorConnection {}
impl IIfcDistributionFlowElement for IfcMotorConnection {}
impl IIfcEnergyConversionDevice for IfcMotorConnection {}
impl IIfcMotorConnection for IfcMotorConnection {
    fn predefined_type(&self) -> &Option<IfcMotorConnectionTypeEnum> {
        &self.predefined_type
    }
}
impl IfcMotorConnection {
    pub fn from_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcMotorConnection::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.global_id = parameter.into(),
                1usize => {
                    entity.owner_history = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => {
                    entity.object_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                5usize => {
                    entity.object_placement = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                6usize => {
                    entity.representation = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                7usize => {
                    entity.tag = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                8usize => {
                    entity.predefined_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
    pub fn from_own_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcMotorConnection::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => {
                    entity.predefined_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcMotorConnectionType: IIfcEnergyConversionDeviceType {
    fn predefined_type(&self) -> &IfcMotorConnectionTypeEnum;
}
#[derive(Default, Debug)]
pub struct IfcMotorConnectionType {
    global_id: IfcGloballyUniqueId,
    owner_history: Option<EntityRef>,
    name: Option<IfcLabel>,
    description: Option<IfcText>,
    applicable_occurrence: Option<IfcIdentifier>,
    has_property_sets: Option<HashSet<EntityRef>>,
    representation_maps: Option<Vec<EntityRef>>,
    tag: Option<IfcLabel>,
    element_type: Option<IfcLabel>,
    predefined_type: IfcMotorConnectionTypeEnum,
}
impl IIfcRoot for IfcMotorConnectionType {
    fn global_id(&self) -> &IfcGloballyUniqueId {
        &self.global_id
    }
    fn owner_history(&self) -> &Option<EntityRef> {
        &self.owner_history
    }
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
}
impl IIfcObjectDefinition for IfcMotorConnectionType {}
impl IIfcTypeObject for IfcMotorConnectionType {
    fn applicable_occurrence(&self) -> &Option<IfcIdentifier> {
        &self.applicable_occurrence
    }
    fn has_property_sets(&self) -> &Option<HashSet<EntityRef>> {
        &self.has_property_sets
    }
}
impl IIfcTypeProduct for IfcMotorConnectionType {
    fn representation_maps(&self) -> &Option<Vec<EntityRef>> {
        &self.representation_maps
    }
    fn tag(&self) -> &Option<IfcLabel> {
        &self.tag
    }
}
impl IIfcElementType for IfcMotorConnectionType {
    fn element_type(&self) -> &Option<IfcLabel> {
        &self.element_type
    }
}
impl IIfcDistributionElementType for IfcMotorConnectionType {}
impl IIfcDistributionFlowElementType for IfcMotorConnectionType {}
impl IIfcEnergyConversionDeviceType for IfcMotorConnectionType {}
impl IIfcMotorConnectionType for IfcMotorConnectionType {
    fn predefined_type(&self) -> &IfcMotorConnectionTypeEnum {
        &self.predefined_type
    }
}
impl IfcMotorConnectionType {
    pub fn from_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcMotorConnectionType::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.global_id = parameter.into(),
                1usize => {
                    entity.owner_history = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => {
                    entity.applicable_occurrence = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                5usize => {
                    entity.has_property_sets = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                6usize => {
                    entity.representation_maps = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                7usize => {
                    entity.tag = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                8usize => {
                    entity.element_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                9usize => entity.predefined_type = parameter.into(),
                _ => {}
            }
        }
        entity
    }
    pub fn from_own_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcMotorConnectionType::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.predefined_type = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcNamedUnit {
    fn dimensions(&self) -> &EntityRef;
    fn unit_type(&self) -> &IfcUnitEnum;
}
pub trait IIfcObject: IIfcObjectDefinition {
    fn object_type(&self) -> &Option<IfcLabel>;
}
pub trait IIfcObjectDefinition: IIfcRoot {}
pub trait IIfcObjectPlacement {}
pub trait IIfcObjective: IIfcConstraint {
    fn benchmark_values(&self) -> &Option<Vec<EntityRef>>;
    fn logical_aggregator(&self) -> &Option<IfcLogicalOperatorEnum>;
    fn objective_qualifier(&self) -> &IfcObjectiveEnum;
    fn user_defined_qualifier(&self) -> &Option<IfcLabel>;
}
#[derive(Default, Debug)]
pub struct IfcObjective {
    name: IfcLabel,
    description: Option<IfcText>,
    constraint_grade: IfcConstraintEnum,
    constraint_source: Option<IfcLabel>,
    creating_actor: Option<EntityRef>,
    creation_time: Option<IfcDateTime>,
    user_defined_grade: Option<IfcLabel>,
    benchmark_values: Option<Vec<EntityRef>>,
    logical_aggregator: Option<IfcLogicalOperatorEnum>,
    objective_qualifier: IfcObjectiveEnum,
    user_defined_qualifier: Option<IfcLabel>,
}
impl IIfcConstraint for IfcObjective {
    fn name(&self) -> &IfcLabel {
        &self.name
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
    fn constraint_grade(&self) -> &IfcConstraintEnum {
        &self.constraint_grade
    }
    fn constraint_source(&self) -> &Option<IfcLabel> {
        &self.constraint_source
    }
    fn creating_actor(&self) -> &Option<EntityRef> {
        &self.creating_actor
    }
    fn creation_time(&self) -> &Option<IfcDateTime> {
        &self.creation_time
    }
    fn user_defined_grade(&self) -> &Option<IfcLabel> {
        &self.user_defined_grade
    }
}
impl IIfcObjective for IfcObjective {
    fn benchmark_values(&self) -> &Option<Vec<EntityRef>> {
        &self.benchmark_values
    }
    fn logical_aggregator(&self) -> &Option<IfcLogicalOperatorEnum> {
        &self.logical_aggregator
    }
    fn objective_qualifier(&self) -> &IfcObjectiveEnum {
        &self.objective_qualifier
    }
    fn user_defined_qualifier(&self) -> &Option<IfcLabel> {
        &self.user_defined_qualifier
    }
}
impl IfcObjective {
    pub fn from_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcObjective::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => entity.constraint_grade = parameter.into(),
                3usize => {
                    entity.constraint_source = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => {
                    entity.creating_actor = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                5usize => {
                    entity.creation_time = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                6usize => {
                    entity.user_defined_grade = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                7usize => {
                    entity.benchmark_values = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                8usize => {
                    entity.logical_aggregator = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                9usize => entity.objective_qualifier = parameter.into(),
                10usize => {
                    entity.user_defined_qualifier = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
    pub fn from_own_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcObjective::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => {
                    entity.benchmark_values = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                1usize => {
                    entity.logical_aggregator = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => entity.objective_qualifier = parameter.into(),
                3usize => {
                    entity.user_defined_qualifier = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcOccupant: IIfcActor {
    fn predefined_type(&self) -> &Option<IfcOccupantTypeEnum>;
}
#[derive(Default, Debug)]
pub struct IfcOccupant {
    global_id: IfcGloballyUniqueId,
    owner_history: Option<EntityRef>,
    name: Option<IfcLabel>,
    description: Option<IfcText>,
    object_type: Option<IfcLabel>,
    the_actor: EntityRef,
    predefined_type: Option<IfcOccupantTypeEnum>,
}
impl IIfcRoot for IfcOccupant {
    fn global_id(&self) -> &IfcGloballyUniqueId {
        &self.global_id
    }
    fn owner_history(&self) -> &Option<EntityRef> {
        &self.owner_history
    }
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
}
impl IIfcObjectDefinition for IfcOccupant {}
impl IIfcObject for IfcOccupant {
    fn object_type(&self) -> &Option<IfcLabel> {
        &self.object_type
    }
}
impl IIfcActor for IfcOccupant {
    fn the_actor(&self) -> &EntityRef {
        &self.the_actor
    }
}
impl IIfcOccupant for IfcOccupant {
    fn predefined_type(&self) -> &Option<IfcOccupantTypeEnum> {
        &self.predefined_type
    }
}
impl IfcOccupant {
    pub fn from_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcOccupant::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.global_id = parameter.into(),
                1usize => {
                    entity.owner_history = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => {
                    entity.object_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                5usize => entity.the_actor = parameter.into(),
                6usize => {
                    entity.predefined_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
    pub fn from_own_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcOccupant::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => {
                    entity.predefined_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcOffsetCurve2D: IIfcCurve {
    fn basis_curve(&self) -> &EntityRef;
    fn distance(&self) -> &IfcLengthMeasure;
    fn self_intersect(&self) -> &IfcLogical;
}
#[derive(Default, Debug)]
pub struct IfcOffsetCurve2D {
    basis_curve: EntityRef,
    distance: IfcLengthMeasure,
    self_intersect: IfcLogical,
}
impl IIfcRepresentationItem for IfcOffsetCurve2D {}
impl IIfcGeometricRepresentationItem for IfcOffsetCurve2D {}
impl IIfcCurve for IfcOffsetCurve2D {}
impl IIfcOffsetCurve2D for IfcOffsetCurve2D {
    fn basis_curve(&self) -> &EntityRef {
        &self.basis_curve
    }
    fn distance(&self) -> &IfcLengthMeasure {
        &self.distance
    }
    fn self_intersect(&self) -> &IfcLogical {
        &self.self_intersect
    }
}
impl IfcOffsetCurve2D {
    pub fn from_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcOffsetCurve2D::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.basis_curve = parameter.into(),
                1usize => entity.distance = parameter.into(),
                2usize => entity.self_intersect = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcOffsetCurve3D: IIfcCurve {
    fn basis_curve(&self) -> &EntityRef;
    fn distance(&self) -> &IfcLengthMeasure;
    fn self_intersect(&self) -> &IfcLogical;
    fn ref_direction(&self) -> &EntityRef;
}
#[derive(Default, Debug)]
pub struct IfcOffsetCurve3D {
    basis_curve: EntityRef,
    distance: IfcLengthMeasure,
    self_intersect: IfcLogical,
    ref_direction: EntityRef,
}
impl IIfcRepresentationItem for IfcOffsetCurve3D {}
impl IIfcGeometricRepresentationItem for IfcOffsetCurve3D {}
impl IIfcCurve for IfcOffsetCurve3D {}
impl IIfcOffsetCurve3D for IfcOffsetCurve3D {
    fn basis_curve(&self) -> &EntityRef {
        &self.basis_curve
    }
    fn distance(&self) -> &IfcLengthMeasure {
        &self.distance
    }
    fn self_intersect(&self) -> &IfcLogical {
        &self.self_intersect
    }
    fn ref_direction(&self) -> &EntityRef {
        &self.ref_direction
    }
}
impl IfcOffsetCurve3D {
    pub fn from_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcOffsetCurve3D::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.basis_curve = parameter.into(),
                1usize => entity.distance = parameter.into(),
                2usize => entity.self_intersect = parameter.into(),
                3usize => entity.ref_direction = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcOpenShell: IIfcConnectedFaceSet {}
#[derive(Default, Debug)]
pub struct IfcOpenShell {
    cfs_faces: HashSet<EntityRef>,
}
impl IIfcRepresentationItem for IfcOpenShell {}
impl IIfcTopologicalRepresentationItem for IfcOpenShell {}
impl IIfcConnectedFaceSet for IfcOpenShell {
    fn cfs_faces(&self) -> &HashSet<EntityRef> {
        &self.cfs_faces
    }
}
impl IIfcOpenShell for IfcOpenShell {}
impl IfcOpenShell {
    pub fn from_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcOpenShell::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.cfs_faces = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcOpeningElement: IIfcFeatureElementSubtraction {
    fn predefined_type(&self) -> &Option<IfcOpeningElementTypeEnum>;
}
#[derive(Default, Debug)]
pub struct IfcOpeningElement {
    global_id: IfcGloballyUniqueId,
    owner_history: Option<EntityRef>,
    name: Option<IfcLabel>,
    description: Option<IfcText>,
    object_type: Option<IfcLabel>,
    object_placement: Option<EntityRef>,
    representation: Option<EntityRef>,
    tag: Option<IfcIdentifier>,
    predefined_type: Option<IfcOpeningElementTypeEnum>,
}
impl IIfcRoot for IfcOpeningElement {
    fn global_id(&self) -> &IfcGloballyUniqueId {
        &self.global_id
    }
    fn owner_history(&self) -> &Option<EntityRef> {
        &self.owner_history
    }
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
}
impl IIfcObjectDefinition for IfcOpeningElement {}
impl IIfcObject for IfcOpeningElement {
    fn object_type(&self) -> &Option<IfcLabel> {
        &self.object_type
    }
}
impl IIfcProduct for IfcOpeningElement {
    fn object_placement(&self) -> &Option<EntityRef> {
        &self.object_placement
    }
    fn representation(&self) -> &Option<EntityRef> {
        &self.representation
    }
}
impl IIfcElement for IfcOpeningElement {
    fn tag(&self) -> &Option<IfcIdentifier> {
        &self.tag
    }
}
impl IIfcFeatureElement for IfcOpeningElement {}
impl IIfcFeatureElementSubtraction for IfcOpeningElement {}
impl IIfcOpeningElement for IfcOpeningElement {
    fn predefined_type(&self) -> &Option<IfcOpeningElementTypeEnum> {
        &self.predefined_type
    }
}
impl IfcOpeningElement {
    pub fn from_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcOpeningElement::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.global_id = parameter.into(),
                1usize => {
                    entity.owner_history = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => {
                    entity.object_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                5usize => {
                    entity.object_placement = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                6usize => {
                    entity.representation = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                7usize => {
                    entity.tag = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                8usize => {
                    entity.predefined_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
    pub fn from_own_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcOpeningElement::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => {
                    entity.predefined_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcOpeningStandardCase: IIfcOpeningElement {}
#[derive(Default, Debug)]
pub struct IfcOpeningStandardCase {
    global_id: IfcGloballyUniqueId,
    owner_history: Option<EntityRef>,
    name: Option<IfcLabel>,
    description: Option<IfcText>,
    object_type: Option<IfcLabel>,
    object_placement: Option<EntityRef>,
    representation: Option<EntityRef>,
    tag: Option<IfcIdentifier>,
    predefined_type: Option<IfcOpeningElementTypeEnum>,
}
impl IIfcRoot for IfcOpeningStandardCase {
    fn global_id(&self) -> &IfcGloballyUniqueId {
        &self.global_id
    }
    fn owner_history(&self) -> &Option<EntityRef> {
        &self.owner_history
    }
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
}
impl IIfcObjectDefinition for IfcOpeningStandardCase {}
impl IIfcObject for IfcOpeningStandardCase {
    fn object_type(&self) -> &Option<IfcLabel> {
        &self.object_type
    }
}
impl IIfcProduct for IfcOpeningStandardCase {
    fn object_placement(&self) -> &Option<EntityRef> {
        &self.object_placement
    }
    fn representation(&self) -> &Option<EntityRef> {
        &self.representation
    }
}
impl IIfcElement for IfcOpeningStandardCase {
    fn tag(&self) -> &Option<IfcIdentifier> {
        &self.tag
    }
}
impl IIfcFeatureElement for IfcOpeningStandardCase {}
impl IIfcFeatureElementSubtraction for IfcOpeningStandardCase {}
impl IIfcOpeningElement for IfcOpeningStandardCase {
    fn predefined_type(&self) -> &Option<IfcOpeningElementTypeEnum> {
        &self.predefined_type
    }
}
impl IIfcOpeningStandardCase for IfcOpeningStandardCase {}
impl IfcOpeningStandardCase {
    pub fn from_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcOpeningStandardCase::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.global_id = parameter.into(),
                1usize => {
                    entity.owner_history = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => {
                    entity.object_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                5usize => {
                    entity.object_placement = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                6usize => {
                    entity.representation = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                7usize => {
                    entity.tag = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                8usize => {
                    entity.predefined_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcOrganization {
    fn identification(&self) -> &Option<IfcIdentifier>;
    fn name(&self) -> &IfcLabel;
    fn description(&self) -> &Option<IfcText>;
    fn roles(&self) -> &Option<Vec<EntityRef>>;
    fn addresses(&self) -> &Option<Vec<EntityRef>>;
}
#[derive(Default, Debug)]
pub struct IfcOrganization {
    identification: Option<IfcIdentifier>,
    name: IfcLabel,
    description: Option<IfcText>,
    roles: Option<Vec<EntityRef>>,
    addresses: Option<Vec<EntityRef>>,
}
impl IIfcOrganization for IfcOrganization {
    fn identification(&self) -> &Option<IfcIdentifier> {
        &self.identification
    }
    fn name(&self) -> &IfcLabel {
        &self.name
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
    fn roles(&self) -> &Option<Vec<EntityRef>> {
        &self.roles
    }
    fn addresses(&self) -> &Option<Vec<EntityRef>> {
        &self.addresses
    }
}
impl IfcOrganization {
    pub fn from_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcOrganization::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => {
                    entity.identification = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                1usize => entity.name = parameter.into(),
                2usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.roles = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => {
                    entity.addresses = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcOrganizationRelationship: IIfcResourceLevelRelationship {
    fn relating_organization(&self) -> &EntityRef;
    fn related_organizations(&self) -> &HashSet<EntityRef>;
}
#[derive(Default, Debug)]
pub struct IfcOrganizationRelationship {
    name: Option<IfcLabel>,
    description: Option<IfcText>,
    relating_organization: EntityRef,
    related_organizations: HashSet<EntityRef>,
}
impl IIfcResourceLevelRelationship for IfcOrganizationRelationship {
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
}
impl IIfcOrganizationRelationship for IfcOrganizationRelationship {
    fn relating_organization(&self) -> &EntityRef {
        &self.relating_organization
    }
    fn related_organizations(&self) -> &HashSet<EntityRef> {
        &self.related_organizations
    }
}
impl IfcOrganizationRelationship {
    pub fn from_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcOrganizationRelationship::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                1usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => entity.relating_organization = parameter.into(),
                3usize => entity.related_organizations = parameter.into(),
                _ => {}
            }
        }
        entity
    }
    pub fn from_own_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcOrganizationRelationship::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.relating_organization = parameter.into(),
                1usize => entity.related_organizations = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcOrientedEdge: IIfcEdge {
    fn edge_element(&self) -> &EntityRef;
    fn orientation(&self) -> &IfcBoolean;
}
#[derive(Default, Debug)]
pub struct IfcOrientedEdge {
    edge_start: EntityRef,
    edge_end: EntityRef,
    edge_element: EntityRef,
    orientation: IfcBoolean,
}
impl IIfcRepresentationItem for IfcOrientedEdge {}
impl IIfcTopologicalRepresentationItem for IfcOrientedEdge {}
impl IIfcEdge for IfcOrientedEdge {
    fn edge_start(&self) -> &EntityRef {
        &self.edge_start
    }
    fn edge_end(&self) -> &EntityRef {
        &self.edge_end
    }
}
impl IIfcOrientedEdge for IfcOrientedEdge {
    fn edge_element(&self) -> &EntityRef {
        &self.edge_element
    }
    fn orientation(&self) -> &IfcBoolean {
        &self.orientation
    }
}
impl IfcOrientedEdge {
    pub fn from_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcOrientedEdge::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.edge_start = parameter.into(),
                1usize => entity.edge_end = parameter.into(),
                2usize => entity.edge_element = parameter.into(),
                3usize => entity.orientation = parameter.into(),
                _ => {}
            }
        }
        entity
    }
    pub fn from_own_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcOrientedEdge::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.edge_element = parameter.into(),
                1usize => entity.orientation = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcOuterBoundaryCurve: IIfcBoundaryCurve {}
#[derive(Default, Debug)]
pub struct IfcOuterBoundaryCurve {
    segments: Vec<EntityRef>,
    self_intersect: IfcLogical,
}
impl IIfcRepresentationItem for IfcOuterBoundaryCurve {}
impl IIfcGeometricRepresentationItem for IfcOuterBoundaryCurve {}
impl IIfcCurve for IfcOuterBoundaryCurve {}
impl IIfcBoundedCurve for IfcOuterBoundaryCurve {}
impl IIfcCompositeCurve for IfcOuterBoundaryCurve {
    fn segments(&self) -> &Vec<EntityRef> {
        &self.segments
    }
    fn self_intersect(&self) -> &IfcLogical {
        &self.self_intersect
    }
}
impl IIfcCompositeCurveOnSurface for IfcOuterBoundaryCurve {}
impl IIfcBoundaryCurve for IfcOuterBoundaryCurve {}
impl IIfcOuterBoundaryCurve for IfcOuterBoundaryCurve {}
impl IfcOuterBoundaryCurve {
    pub fn from_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcOuterBoundaryCurve::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.segments = parameter.into(),
                1usize => entity.self_intersect = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcOutlet: IIfcFlowTerminal {
    fn predefined_type(&self) -> &Option<IfcOutletTypeEnum>;
}
#[derive(Default, Debug)]
pub struct IfcOutlet {
    global_id: IfcGloballyUniqueId,
    owner_history: Option<EntityRef>,
    name: Option<IfcLabel>,
    description: Option<IfcText>,
    object_type: Option<IfcLabel>,
    object_placement: Option<EntityRef>,
    representation: Option<EntityRef>,
    tag: Option<IfcIdentifier>,
    predefined_type: Option<IfcOutletTypeEnum>,
}
impl IIfcRoot for IfcOutlet {
    fn global_id(&self) -> &IfcGloballyUniqueId {
        &self.global_id
    }
    fn owner_history(&self) -> &Option<EntityRef> {
        &self.owner_history
    }
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
}
impl IIfcObjectDefinition for IfcOutlet {}
impl IIfcObject for IfcOutlet {
    fn object_type(&self) -> &Option<IfcLabel> {
        &self.object_type
    }
}
impl IIfcProduct for IfcOutlet {
    fn object_placement(&self) -> &Option<EntityRef> {
        &self.object_placement
    }
    fn representation(&self) -> &Option<EntityRef> {
        &self.representation
    }
}
impl IIfcElement for IfcOutlet {
    fn tag(&self) -> &Option<IfcIdentifier> {
        &self.tag
    }
}
impl IIfcDistributionElement for IfcOutlet {}
impl IIfcDistributionFlowElement for IfcOutlet {}
impl IIfcFlowTerminal for IfcOutlet {}
impl IIfcOutlet for IfcOutlet {
    fn predefined_type(&self) -> &Option<IfcOutletTypeEnum> {
        &self.predefined_type
    }
}
impl IfcOutlet {
    pub fn from_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcOutlet::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.global_id = parameter.into(),
                1usize => {
                    entity.owner_history = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => {
                    entity.object_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                5usize => {
                    entity.object_placement = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                6usize => {
                    entity.representation = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                7usize => {
                    entity.tag = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                8usize => {
                    entity.predefined_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
    pub fn from_own_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcOutlet::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => {
                    entity.predefined_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcOutletType: IIfcFlowTerminalType {
    fn predefined_type(&self) -> &IfcOutletTypeEnum;
}
#[derive(Default, Debug)]
pub struct IfcOutletType {
    global_id: IfcGloballyUniqueId,
    owner_history: Option<EntityRef>,
    name: Option<IfcLabel>,
    description: Option<IfcText>,
    applicable_occurrence: Option<IfcIdentifier>,
    has_property_sets: Option<HashSet<EntityRef>>,
    representation_maps: Option<Vec<EntityRef>>,
    tag: Option<IfcLabel>,
    element_type: Option<IfcLabel>,
    predefined_type: IfcOutletTypeEnum,
}
impl IIfcRoot for IfcOutletType {
    fn global_id(&self) -> &IfcGloballyUniqueId {
        &self.global_id
    }
    fn owner_history(&self) -> &Option<EntityRef> {
        &self.owner_history
    }
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
}
impl IIfcObjectDefinition for IfcOutletType {}
impl IIfcTypeObject for IfcOutletType {
    fn applicable_occurrence(&self) -> &Option<IfcIdentifier> {
        &self.applicable_occurrence
    }
    fn has_property_sets(&self) -> &Option<HashSet<EntityRef>> {
        &self.has_property_sets
    }
}
impl IIfcTypeProduct for IfcOutletType {
    fn representation_maps(&self) -> &Option<Vec<EntityRef>> {
        &self.representation_maps
    }
    fn tag(&self) -> &Option<IfcLabel> {
        &self.tag
    }
}
impl IIfcElementType for IfcOutletType {
    fn element_type(&self) -> &Option<IfcLabel> {
        &self.element_type
    }
}
impl IIfcDistributionElementType for IfcOutletType {}
impl IIfcDistributionFlowElementType for IfcOutletType {}
impl IIfcFlowTerminalType for IfcOutletType {}
impl IIfcOutletType for IfcOutletType {
    fn predefined_type(&self) -> &IfcOutletTypeEnum {
        &self.predefined_type
    }
}
impl IfcOutletType {
    pub fn from_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcOutletType::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.global_id = parameter.into(),
                1usize => {
                    entity.owner_history = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => {
                    entity.applicable_occurrence = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                5usize => {
                    entity.has_property_sets = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                6usize => {
                    entity.representation_maps = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                7usize => {
                    entity.tag = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                8usize => {
                    entity.element_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                9usize => entity.predefined_type = parameter.into(),
                _ => {}
            }
        }
        entity
    }
    pub fn from_own_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcOutletType::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.predefined_type = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcOwnerHistory {
    fn owning_user(&self) -> &EntityRef;
    fn owning_application(&self) -> &EntityRef;
    fn state(&self) -> &Option<IfcStateEnum>;
    fn change_action(&self) -> &Option<IfcChangeActionEnum>;
    fn last_modified_date(&self) -> &Option<IfcTimeStamp>;
    fn last_modifying_user(&self) -> &Option<EntityRef>;
    fn last_modifying_application(&self) -> &Option<EntityRef>;
    fn creation_date(&self) -> &IfcTimeStamp;
}
#[derive(Default, Debug)]
pub struct IfcOwnerHistory {
    owning_user: EntityRef,
    owning_application: EntityRef,
    state: Option<IfcStateEnum>,
    change_action: Option<IfcChangeActionEnum>,
    last_modified_date: Option<IfcTimeStamp>,
    last_modifying_user: Option<EntityRef>,
    last_modifying_application: Option<EntityRef>,
    creation_date: IfcTimeStamp,
}
impl IIfcOwnerHistory for IfcOwnerHistory {
    fn owning_user(&self) -> &EntityRef {
        &self.owning_user
    }
    fn owning_application(&self) -> &EntityRef {
        &self.owning_application
    }
    fn state(&self) -> &Option<IfcStateEnum> {
        &self.state
    }
    fn change_action(&self) -> &Option<IfcChangeActionEnum> {
        &self.change_action
    }
    fn last_modified_date(&self) -> &Option<IfcTimeStamp> {
        &self.last_modified_date
    }
    fn last_modifying_user(&self) -> &Option<EntityRef> {
        &self.last_modifying_user
    }
    fn last_modifying_application(&self) -> &Option<EntityRef> {
        &self.last_modifying_application
    }
    fn creation_date(&self) -> &IfcTimeStamp {
        &self.creation_date
    }
}
impl IfcOwnerHistory {
    pub fn from_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcOwnerHistory::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.owning_user = parameter.into(),
                1usize => entity.owning_application = parameter.into(),
                2usize => {
                    entity.state = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.change_action = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => {
                    entity.last_modified_date = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                5usize => {
                    entity.last_modifying_user = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                6usize => {
                    entity.last_modifying_application = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                7usize => entity.creation_date = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcParameterizedProfileDef: IIfcProfileDef {
    fn position(&self) -> &Option<EntityRef>;
}
pub trait IIfcPath: IIfcTopologicalRepresentationItem {
    fn edge_list(&self) -> &Vec<EntityRef>;
}
#[derive(Default, Debug)]
pub struct IfcPath {
    edge_list: Vec<EntityRef>,
}
impl IIfcRepresentationItem for IfcPath {}
impl IIfcTopologicalRepresentationItem for IfcPath {}
impl IIfcPath for IfcPath {
    fn edge_list(&self) -> &Vec<EntityRef> {
        &self.edge_list
    }
}
impl IfcPath {
    pub fn from_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcPath::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.edge_list = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcPcurve: IIfcCurve {
    fn basis_surface(&self) -> &EntityRef;
    fn reference_curve(&self) -> &EntityRef;
}
#[derive(Default, Debug)]
pub struct IfcPcurve {
    basis_surface: EntityRef,
    reference_curve: EntityRef,
}
impl IIfcRepresentationItem for IfcPcurve {}
impl IIfcGeometricRepresentationItem for IfcPcurve {}
impl IIfcCurve for IfcPcurve {}
impl IIfcPcurve for IfcPcurve {
    fn basis_surface(&self) -> &EntityRef {
        &self.basis_surface
    }
    fn reference_curve(&self) -> &EntityRef {
        &self.reference_curve
    }
}
impl IfcPcurve {
    pub fn from_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcPcurve::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.basis_surface = parameter.into(),
                1usize => entity.reference_curve = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcPerformanceHistory: IIfcControl {
    fn life_cycle_phase(&self) -> &IfcLabel;
    fn predefined_type(&self) -> &Option<IfcPerformanceHistoryTypeEnum>;
}
#[derive(Default, Debug)]
pub struct IfcPerformanceHistory {
    global_id: IfcGloballyUniqueId,
    owner_history: Option<EntityRef>,
    name: Option<IfcLabel>,
    description: Option<IfcText>,
    object_type: Option<IfcLabel>,
    identification: Option<IfcIdentifier>,
    life_cycle_phase: IfcLabel,
    predefined_type: Option<IfcPerformanceHistoryTypeEnum>,
}
impl IIfcRoot for IfcPerformanceHistory {
    fn global_id(&self) -> &IfcGloballyUniqueId {
        &self.global_id
    }
    fn owner_history(&self) -> &Option<EntityRef> {
        &self.owner_history
    }
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
}
impl IIfcObjectDefinition for IfcPerformanceHistory {}
impl IIfcObject for IfcPerformanceHistory {
    fn object_type(&self) -> &Option<IfcLabel> {
        &self.object_type
    }
}
impl IIfcControl for IfcPerformanceHistory {
    fn identification(&self) -> &Option<IfcIdentifier> {
        &self.identification
    }
}
impl IIfcPerformanceHistory for IfcPerformanceHistory {
    fn life_cycle_phase(&self) -> &IfcLabel {
        &self.life_cycle_phase
    }
    fn predefined_type(&self) -> &Option<IfcPerformanceHistoryTypeEnum> {
        &self.predefined_type
    }
}
impl IfcPerformanceHistory {
    pub fn from_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcPerformanceHistory::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.global_id = parameter.into(),
                1usize => {
                    entity.owner_history = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => {
                    entity.object_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                5usize => {
                    entity.identification = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                6usize => entity.life_cycle_phase = parameter.into(),
                7usize => {
                    entity.predefined_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
    pub fn from_own_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcPerformanceHistory::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.life_cycle_phase = parameter.into(),
                1usize => {
                    entity.predefined_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcPermeableCoveringProperties: IIfcPreDefinedPropertySet {
    fn operation_type(&self) -> &IfcPermeableCoveringOperationEnum;
    fn panel_position(&self) -> &IfcWindowPanelPositionEnum;
    fn frame_depth(&self) -> &Option<IfcPositiveLengthMeasure>;
    fn frame_thickness(&self) -> &Option<IfcPositiveLengthMeasure>;
    fn shape_aspect_style(&self) -> &Option<EntityRef>;
}
#[derive(Default, Debug)]
pub struct IfcPermeableCoveringProperties {
    global_id: IfcGloballyUniqueId,
    owner_history: Option<EntityRef>,
    name: Option<IfcLabel>,
    description: Option<IfcText>,
    operation_type: IfcPermeableCoveringOperationEnum,
    panel_position: IfcWindowPanelPositionEnum,
    frame_depth: Option<IfcPositiveLengthMeasure>,
    frame_thickness: Option<IfcPositiveLengthMeasure>,
    shape_aspect_style: Option<EntityRef>,
}
impl IIfcRoot for IfcPermeableCoveringProperties {
    fn global_id(&self) -> &IfcGloballyUniqueId {
        &self.global_id
    }
    fn owner_history(&self) -> &Option<EntityRef> {
        &self.owner_history
    }
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
}
impl IIfcPropertyDefinition for IfcPermeableCoveringProperties {}
impl IIfcPropertySetDefinition for IfcPermeableCoveringProperties {}
impl IIfcPreDefinedPropertySet for IfcPermeableCoveringProperties {}
impl IIfcPermeableCoveringProperties for IfcPermeableCoveringProperties {
    fn operation_type(&self) -> &IfcPermeableCoveringOperationEnum {
        &self.operation_type
    }
    fn panel_position(&self) -> &IfcWindowPanelPositionEnum {
        &self.panel_position
    }
    fn frame_depth(&self) -> &Option<IfcPositiveLengthMeasure> {
        &self.frame_depth
    }
    fn frame_thickness(&self) -> &Option<IfcPositiveLengthMeasure> {
        &self.frame_thickness
    }
    fn shape_aspect_style(&self) -> &Option<EntityRef> {
        &self.shape_aspect_style
    }
}
impl IfcPermeableCoveringProperties {
    pub fn from_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcPermeableCoveringProperties::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.global_id = parameter.into(),
                1usize => {
                    entity.owner_history = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => entity.operation_type = parameter.into(),
                5usize => entity.panel_position = parameter.into(),
                6usize => {
                    entity.frame_depth = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                7usize => {
                    entity.frame_thickness = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                8usize => {
                    entity.shape_aspect_style = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
    pub fn from_own_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcPermeableCoveringProperties::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.operation_type = parameter.into(),
                1usize => entity.panel_position = parameter.into(),
                2usize => {
                    entity.frame_depth = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.frame_thickness = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => {
                    entity.shape_aspect_style = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcPermit: IIfcControl {
    fn predefined_type(&self) -> &Option<IfcPermitTypeEnum>;
    fn status(&self) -> &Option<IfcLabel>;
    fn long_description(&self) -> &Option<IfcText>;
}
#[derive(Default, Debug)]
pub struct IfcPermit {
    global_id: IfcGloballyUniqueId,
    owner_history: Option<EntityRef>,
    name: Option<IfcLabel>,
    description: Option<IfcText>,
    object_type: Option<IfcLabel>,
    identification: Option<IfcIdentifier>,
    predefined_type: Option<IfcPermitTypeEnum>,
    status: Option<IfcLabel>,
    long_description: Option<IfcText>,
}
impl IIfcRoot for IfcPermit {
    fn global_id(&self) -> &IfcGloballyUniqueId {
        &self.global_id
    }
    fn owner_history(&self) -> &Option<EntityRef> {
        &self.owner_history
    }
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
}
impl IIfcObjectDefinition for IfcPermit {}
impl IIfcObject for IfcPermit {
    fn object_type(&self) -> &Option<IfcLabel> {
        &self.object_type
    }
}
impl IIfcControl for IfcPermit {
    fn identification(&self) -> &Option<IfcIdentifier> {
        &self.identification
    }
}
impl IIfcPermit for IfcPermit {
    fn predefined_type(&self) -> &Option<IfcPermitTypeEnum> {
        &self.predefined_type
    }
    fn status(&self) -> &Option<IfcLabel> {
        &self.status
    }
    fn long_description(&self) -> &Option<IfcText> {
        &self.long_description
    }
}
impl IfcPermit {
    pub fn from_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcPermit::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.global_id = parameter.into(),
                1usize => {
                    entity.owner_history = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => {
                    entity.object_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                5usize => {
                    entity.identification = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                6usize => {
                    entity.predefined_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                7usize => {
                    entity.status = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                8usize => {
                    entity.long_description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
    pub fn from_own_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcPermit::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => {
                    entity.predefined_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                1usize => {
                    entity.status = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => {
                    entity.long_description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcPerson {
    fn identification(&self) -> &Option<IfcIdentifier>;
    fn family_name(&self) -> &Option<IfcLabel>;
    fn given_name(&self) -> &Option<IfcLabel>;
    fn middle_names(&self) -> &Option<Vec<IfcLabel>>;
    fn prefix_titles(&self) -> &Option<Vec<IfcLabel>>;
    fn suffix_titles(&self) -> &Option<Vec<IfcLabel>>;
    fn roles(&self) -> &Option<Vec<EntityRef>>;
    fn addresses(&self) -> &Option<Vec<EntityRef>>;
}
#[derive(Default, Debug)]
pub struct IfcPerson {
    identification: Option<IfcIdentifier>,
    family_name: Option<IfcLabel>,
    given_name: Option<IfcLabel>,
    middle_names: Option<Vec<IfcLabel>>,
    prefix_titles: Option<Vec<IfcLabel>>,
    suffix_titles: Option<Vec<IfcLabel>>,
    roles: Option<Vec<EntityRef>>,
    addresses: Option<Vec<EntityRef>>,
}
impl IIfcPerson for IfcPerson {
    fn identification(&self) -> &Option<IfcIdentifier> {
        &self.identification
    }
    fn family_name(&self) -> &Option<IfcLabel> {
        &self.family_name
    }
    fn given_name(&self) -> &Option<IfcLabel> {
        &self.given_name
    }
    fn middle_names(&self) -> &Option<Vec<IfcLabel>> {
        &self.middle_names
    }
    fn prefix_titles(&self) -> &Option<Vec<IfcLabel>> {
        &self.prefix_titles
    }
    fn suffix_titles(&self) -> &Option<Vec<IfcLabel>> {
        &self.suffix_titles
    }
    fn roles(&self) -> &Option<Vec<EntityRef>> {
        &self.roles
    }
    fn addresses(&self) -> &Option<Vec<EntityRef>> {
        &self.addresses
    }
}
impl IfcPerson {
    pub fn from_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcPerson::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => {
                    entity.identification = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                1usize => {
                    entity.family_name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => {
                    entity.given_name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.middle_names = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => {
                    entity.prefix_titles = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                5usize => {
                    entity.suffix_titles = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                6usize => {
                    entity.roles = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                7usize => {
                    entity.addresses = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcPersonAndOrganization {
    fn the_person(&self) -> &EntityRef;
    fn the_organization(&self) -> &EntityRef;
    fn roles(&self) -> &Option<Vec<EntityRef>>;
}
#[derive(Default, Debug)]
pub struct IfcPersonAndOrganization {
    the_person: EntityRef,
    the_organization: EntityRef,
    roles: Option<Vec<EntityRef>>,
}
impl IIfcPersonAndOrganization for IfcPersonAndOrganization {
    fn the_person(&self) -> &EntityRef {
        &self.the_person
    }
    fn the_organization(&self) -> &EntityRef {
        &self.the_organization
    }
    fn roles(&self) -> &Option<Vec<EntityRef>> {
        &self.roles
    }
}
impl IfcPersonAndOrganization {
    pub fn from_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcPersonAndOrganization::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.the_person = parameter.into(),
                1usize => entity.the_organization = parameter.into(),
                2usize => {
                    entity.roles = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcPhysicalComplexQuantity: IIfcPhysicalQuantity {
    fn has_quantities(&self) -> &HashSet<EntityRef>;
    fn discrimination(&self) -> &IfcLabel;
    fn quality(&self) -> &Option<IfcLabel>;
    fn usage(&self) -> &Option<IfcLabel>;
}
#[derive(Default, Debug)]
pub struct IfcPhysicalComplexQuantity {
    name: IfcLabel,
    description: Option<IfcText>,
    has_quantities: HashSet<EntityRef>,
    discrimination: IfcLabel,
    quality: Option<IfcLabel>,
    usage: Option<IfcLabel>,
}
impl IIfcPhysicalQuantity for IfcPhysicalComplexQuantity {
    fn name(&self) -> &IfcLabel {
        &self.name
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
}
impl IIfcPhysicalComplexQuantity for IfcPhysicalComplexQuantity {
    fn has_quantities(&self) -> &HashSet<EntityRef> {
        &self.has_quantities
    }
    fn discrimination(&self) -> &IfcLabel {
        &self.discrimination
    }
    fn quality(&self) -> &Option<IfcLabel> {
        &self.quality
    }
    fn usage(&self) -> &Option<IfcLabel> {
        &self.usage
    }
}
impl IfcPhysicalComplexQuantity {
    pub fn from_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcPhysicalComplexQuantity::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => entity.has_quantities = parameter.into(),
                3usize => entity.discrimination = parameter.into(),
                4usize => {
                    entity.quality = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                5usize => {
                    entity.usage = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
    pub fn from_own_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcPhysicalComplexQuantity::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.has_quantities = parameter.into(),
                1usize => entity.discrimination = parameter.into(),
                2usize => {
                    entity.quality = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.usage = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcPhysicalQuantity {
    fn name(&self) -> &IfcLabel;
    fn description(&self) -> &Option<IfcText>;
}
pub trait IIfcPhysicalSimpleQuantity: IIfcPhysicalQuantity {
    fn unit(&self) -> &Option<EntityRef>;
}
pub trait IIfcPile: IIfcBuildingElement {
    fn predefined_type(&self) -> &Option<IfcPileTypeEnum>;
    fn construction_type(&self) -> &Option<IfcPileConstructionEnum>;
}
#[derive(Default, Debug)]
pub struct IfcPile {
    global_id: IfcGloballyUniqueId,
    owner_history: Option<EntityRef>,
    name: Option<IfcLabel>,
    description: Option<IfcText>,
    object_type: Option<IfcLabel>,
    object_placement: Option<EntityRef>,
    representation: Option<EntityRef>,
    tag: Option<IfcIdentifier>,
    predefined_type: Option<IfcPileTypeEnum>,
    construction_type: Option<IfcPileConstructionEnum>,
}
impl IIfcRoot for IfcPile {
    fn global_id(&self) -> &IfcGloballyUniqueId {
        &self.global_id
    }
    fn owner_history(&self) -> &Option<EntityRef> {
        &self.owner_history
    }
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
}
impl IIfcObjectDefinition for IfcPile {}
impl IIfcObject for IfcPile {
    fn object_type(&self) -> &Option<IfcLabel> {
        &self.object_type
    }
}
impl IIfcProduct for IfcPile {
    fn object_placement(&self) -> &Option<EntityRef> {
        &self.object_placement
    }
    fn representation(&self) -> &Option<EntityRef> {
        &self.representation
    }
}
impl IIfcElement for IfcPile {
    fn tag(&self) -> &Option<IfcIdentifier> {
        &self.tag
    }
}
impl IIfcBuildingElement for IfcPile {}
impl IIfcPile for IfcPile {
    fn predefined_type(&self) -> &Option<IfcPileTypeEnum> {
        &self.predefined_type
    }
    fn construction_type(&self) -> &Option<IfcPileConstructionEnum> {
        &self.construction_type
    }
}
impl IfcPile {
    pub fn from_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcPile::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.global_id = parameter.into(),
                1usize => {
                    entity.owner_history = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => {
                    entity.object_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                5usize => {
                    entity.object_placement = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                6usize => {
                    entity.representation = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                7usize => {
                    entity.tag = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                8usize => {
                    entity.predefined_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                9usize => {
                    entity.construction_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
    pub fn from_own_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcPile::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => {
                    entity.predefined_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                1usize => {
                    entity.construction_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcPileType: IIfcBuildingElementType {
    fn predefined_type(&self) -> &IfcPileTypeEnum;
}
#[derive(Default, Debug)]
pub struct IfcPileType {
    global_id: IfcGloballyUniqueId,
    owner_history: Option<EntityRef>,
    name: Option<IfcLabel>,
    description: Option<IfcText>,
    applicable_occurrence: Option<IfcIdentifier>,
    has_property_sets: Option<HashSet<EntityRef>>,
    representation_maps: Option<Vec<EntityRef>>,
    tag: Option<IfcLabel>,
    element_type: Option<IfcLabel>,
    predefined_type: IfcPileTypeEnum,
}
impl IIfcRoot for IfcPileType {
    fn global_id(&self) -> &IfcGloballyUniqueId {
        &self.global_id
    }
    fn owner_history(&self) -> &Option<EntityRef> {
        &self.owner_history
    }
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
}
impl IIfcObjectDefinition for IfcPileType {}
impl IIfcTypeObject for IfcPileType {
    fn applicable_occurrence(&self) -> &Option<IfcIdentifier> {
        &self.applicable_occurrence
    }
    fn has_property_sets(&self) -> &Option<HashSet<EntityRef>> {
        &self.has_property_sets
    }
}
impl IIfcTypeProduct for IfcPileType {
    fn representation_maps(&self) -> &Option<Vec<EntityRef>> {
        &self.representation_maps
    }
    fn tag(&self) -> &Option<IfcLabel> {
        &self.tag
    }
}
impl IIfcElementType for IfcPileType {
    fn element_type(&self) -> &Option<IfcLabel> {
        &self.element_type
    }
}
impl IIfcBuildingElementType for IfcPileType {}
impl IIfcPileType for IfcPileType {
    fn predefined_type(&self) -> &IfcPileTypeEnum {
        &self.predefined_type
    }
}
impl IfcPileType {
    pub fn from_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcPileType::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.global_id = parameter.into(),
                1usize => {
                    entity.owner_history = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => {
                    entity.applicable_occurrence = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                5usize => {
                    entity.has_property_sets = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                6usize => {
                    entity.representation_maps = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                7usize => {
                    entity.tag = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                8usize => {
                    entity.element_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                9usize => entity.predefined_type = parameter.into(),
                _ => {}
            }
        }
        entity
    }
    pub fn from_own_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcPileType::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.predefined_type = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcPipeFitting: IIfcFlowFitting {
    fn predefined_type(&self) -> &Option<IfcPipeFittingTypeEnum>;
}
#[derive(Default, Debug)]
pub struct IfcPipeFitting {
    global_id: IfcGloballyUniqueId,
    owner_history: Option<EntityRef>,
    name: Option<IfcLabel>,
    description: Option<IfcText>,
    object_type: Option<IfcLabel>,
    object_placement: Option<EntityRef>,
    representation: Option<EntityRef>,
    tag: Option<IfcIdentifier>,
    predefined_type: Option<IfcPipeFittingTypeEnum>,
}
impl IIfcRoot for IfcPipeFitting {
    fn global_id(&self) -> &IfcGloballyUniqueId {
        &self.global_id
    }
    fn owner_history(&self) -> &Option<EntityRef> {
        &self.owner_history
    }
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
}
impl IIfcObjectDefinition for IfcPipeFitting {}
impl IIfcObject for IfcPipeFitting {
    fn object_type(&self) -> &Option<IfcLabel> {
        &self.object_type
    }
}
impl IIfcProduct for IfcPipeFitting {
    fn object_placement(&self) -> &Option<EntityRef> {
        &self.object_placement
    }
    fn representation(&self) -> &Option<EntityRef> {
        &self.representation
    }
}
impl IIfcElement for IfcPipeFitting {
    fn tag(&self) -> &Option<IfcIdentifier> {
        &self.tag
    }
}
impl IIfcDistributionElement for IfcPipeFitting {}
impl IIfcDistributionFlowElement for IfcPipeFitting {}
impl IIfcFlowFitting for IfcPipeFitting {}
impl IIfcPipeFitting for IfcPipeFitting {
    fn predefined_type(&self) -> &Option<IfcPipeFittingTypeEnum> {
        &self.predefined_type
    }
}
impl IfcPipeFitting {
    pub fn from_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcPipeFitting::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.global_id = parameter.into(),
                1usize => {
                    entity.owner_history = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => {
                    entity.object_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                5usize => {
                    entity.object_placement = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                6usize => {
                    entity.representation = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                7usize => {
                    entity.tag = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                8usize => {
                    entity.predefined_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
    pub fn from_own_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcPipeFitting::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => {
                    entity.predefined_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcPipeFittingType: IIfcFlowFittingType {
    fn predefined_type(&self) -> &IfcPipeFittingTypeEnum;
}
#[derive(Default, Debug)]
pub struct IfcPipeFittingType {
    global_id: IfcGloballyUniqueId,
    owner_history: Option<EntityRef>,
    name: Option<IfcLabel>,
    description: Option<IfcText>,
    applicable_occurrence: Option<IfcIdentifier>,
    has_property_sets: Option<HashSet<EntityRef>>,
    representation_maps: Option<Vec<EntityRef>>,
    tag: Option<IfcLabel>,
    element_type: Option<IfcLabel>,
    predefined_type: IfcPipeFittingTypeEnum,
}
impl IIfcRoot for IfcPipeFittingType {
    fn global_id(&self) -> &IfcGloballyUniqueId {
        &self.global_id
    }
    fn owner_history(&self) -> &Option<EntityRef> {
        &self.owner_history
    }
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
}
impl IIfcObjectDefinition for IfcPipeFittingType {}
impl IIfcTypeObject for IfcPipeFittingType {
    fn applicable_occurrence(&self) -> &Option<IfcIdentifier> {
        &self.applicable_occurrence
    }
    fn has_property_sets(&self) -> &Option<HashSet<EntityRef>> {
        &self.has_property_sets
    }
}
impl IIfcTypeProduct for IfcPipeFittingType {
    fn representation_maps(&self) -> &Option<Vec<EntityRef>> {
        &self.representation_maps
    }
    fn tag(&self) -> &Option<IfcLabel> {
        &self.tag
    }
}
impl IIfcElementType for IfcPipeFittingType {
    fn element_type(&self) -> &Option<IfcLabel> {
        &self.element_type
    }
}
impl IIfcDistributionElementType for IfcPipeFittingType {}
impl IIfcDistributionFlowElementType for IfcPipeFittingType {}
impl IIfcFlowFittingType for IfcPipeFittingType {}
impl IIfcPipeFittingType for IfcPipeFittingType {
    fn predefined_type(&self) -> &IfcPipeFittingTypeEnum {
        &self.predefined_type
    }
}
impl IfcPipeFittingType {
    pub fn from_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcPipeFittingType::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.global_id = parameter.into(),
                1usize => {
                    entity.owner_history = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => {
                    entity.applicable_occurrence = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                5usize => {
                    entity.has_property_sets = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                6usize => {
                    entity.representation_maps = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                7usize => {
                    entity.tag = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                8usize => {
                    entity.element_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                9usize => entity.predefined_type = parameter.into(),
                _ => {}
            }
        }
        entity
    }
    pub fn from_own_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcPipeFittingType::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.predefined_type = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcPipeSegment: IIfcFlowSegment {
    fn predefined_type(&self) -> &Option<IfcPipeSegmentTypeEnum>;
}
#[derive(Default, Debug)]
pub struct IfcPipeSegment {
    global_id: IfcGloballyUniqueId,
    owner_history: Option<EntityRef>,
    name: Option<IfcLabel>,
    description: Option<IfcText>,
    object_type: Option<IfcLabel>,
    object_placement: Option<EntityRef>,
    representation: Option<EntityRef>,
    tag: Option<IfcIdentifier>,
    predefined_type: Option<IfcPipeSegmentTypeEnum>,
}
impl IIfcRoot for IfcPipeSegment {
    fn global_id(&self) -> &IfcGloballyUniqueId {
        &self.global_id
    }
    fn owner_history(&self) -> &Option<EntityRef> {
        &self.owner_history
    }
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
}
impl IIfcObjectDefinition for IfcPipeSegment {}
impl IIfcObject for IfcPipeSegment {
    fn object_type(&self) -> &Option<IfcLabel> {
        &self.object_type
    }
}
impl IIfcProduct for IfcPipeSegment {
    fn object_placement(&self) -> &Option<EntityRef> {
        &self.object_placement
    }
    fn representation(&self) -> &Option<EntityRef> {
        &self.representation
    }
}
impl IIfcElement for IfcPipeSegment {
    fn tag(&self) -> &Option<IfcIdentifier> {
        &self.tag
    }
}
impl IIfcDistributionElement for IfcPipeSegment {}
impl IIfcDistributionFlowElement for IfcPipeSegment {}
impl IIfcFlowSegment for IfcPipeSegment {}
impl IIfcPipeSegment for IfcPipeSegment {
    fn predefined_type(&self) -> &Option<IfcPipeSegmentTypeEnum> {
        &self.predefined_type
    }
}
impl IfcPipeSegment {
    pub fn from_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcPipeSegment::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.global_id = parameter.into(),
                1usize => {
                    entity.owner_history = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => {
                    entity.object_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                5usize => {
                    entity.object_placement = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                6usize => {
                    entity.representation = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                7usize => {
                    entity.tag = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                8usize => {
                    entity.predefined_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
    pub fn from_own_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcPipeSegment::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => {
                    entity.predefined_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcPipeSegmentType: IIfcFlowSegmentType {
    fn predefined_type(&self) -> &IfcPipeSegmentTypeEnum;
}
#[derive(Default, Debug)]
pub struct IfcPipeSegmentType {
    global_id: IfcGloballyUniqueId,
    owner_history: Option<EntityRef>,
    name: Option<IfcLabel>,
    description: Option<IfcText>,
    applicable_occurrence: Option<IfcIdentifier>,
    has_property_sets: Option<HashSet<EntityRef>>,
    representation_maps: Option<Vec<EntityRef>>,
    tag: Option<IfcLabel>,
    element_type: Option<IfcLabel>,
    predefined_type: IfcPipeSegmentTypeEnum,
}
impl IIfcRoot for IfcPipeSegmentType {
    fn global_id(&self) -> &IfcGloballyUniqueId {
        &self.global_id
    }
    fn owner_history(&self) -> &Option<EntityRef> {
        &self.owner_history
    }
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
}
impl IIfcObjectDefinition for IfcPipeSegmentType {}
impl IIfcTypeObject for IfcPipeSegmentType {
    fn applicable_occurrence(&self) -> &Option<IfcIdentifier> {
        &self.applicable_occurrence
    }
    fn has_property_sets(&self) -> &Option<HashSet<EntityRef>> {
        &self.has_property_sets
    }
}
impl IIfcTypeProduct for IfcPipeSegmentType {
    fn representation_maps(&self) -> &Option<Vec<EntityRef>> {
        &self.representation_maps
    }
    fn tag(&self) -> &Option<IfcLabel> {
        &self.tag
    }
}
impl IIfcElementType for IfcPipeSegmentType {
    fn element_type(&self) -> &Option<IfcLabel> {
        &self.element_type
    }
}
impl IIfcDistributionElementType for IfcPipeSegmentType {}
impl IIfcDistributionFlowElementType for IfcPipeSegmentType {}
impl IIfcFlowSegmentType for IfcPipeSegmentType {}
impl IIfcPipeSegmentType for IfcPipeSegmentType {
    fn predefined_type(&self) -> &IfcPipeSegmentTypeEnum {
        &self.predefined_type
    }
}
impl IfcPipeSegmentType {
    pub fn from_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcPipeSegmentType::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.global_id = parameter.into(),
                1usize => {
                    entity.owner_history = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => {
                    entity.applicable_occurrence = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                5usize => {
                    entity.has_property_sets = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                6usize => {
                    entity.representation_maps = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                7usize => {
                    entity.tag = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                8usize => {
                    entity.element_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                9usize => entity.predefined_type = parameter.into(),
                _ => {}
            }
        }
        entity
    }
    pub fn from_own_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcPipeSegmentType::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.predefined_type = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcPixelTexture: IIfcSurfaceTexture {
    fn width(&self) -> &IfcInteger;
    fn height(&self) -> &IfcInteger;
    fn colour_components(&self) -> &IfcInteger;
    fn pixel(&self) -> &Vec<IfcBinary>;
}
#[derive(Default, Debug)]
pub struct IfcPixelTexture {
    repeat_s: IfcBoolean,
    repeat_t: IfcBoolean,
    mode: Option<IfcIdentifier>,
    texture_transform: Option<EntityRef>,
    parameter: Option<Vec<IfcIdentifier>>,
    width: IfcInteger,
    height: IfcInteger,
    colour_components: IfcInteger,
    pixel: Vec<IfcBinary>,
}
impl IIfcPresentationItem for IfcPixelTexture {}
impl IIfcSurfaceTexture for IfcPixelTexture {
    fn repeat_s(&self) -> &IfcBoolean {
        &self.repeat_s
    }
    fn repeat_t(&self) -> &IfcBoolean {
        &self.repeat_t
    }
    fn mode(&self) -> &Option<IfcIdentifier> {
        &self.mode
    }
    fn texture_transform(&self) -> &Option<EntityRef> {
        &self.texture_transform
    }
    fn parameter(&self) -> &Option<Vec<IfcIdentifier>> {
        &self.parameter
    }
}
impl IIfcPixelTexture for IfcPixelTexture {
    fn width(&self) -> &IfcInteger {
        &self.width
    }
    fn height(&self) -> &IfcInteger {
        &self.height
    }
    fn colour_components(&self) -> &IfcInteger {
        &self.colour_components
    }
    fn pixel(&self) -> &Vec<IfcBinary> {
        &self.pixel
    }
}
impl IfcPixelTexture {
    pub fn from_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcPixelTexture::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.repeat_s = parameter.into(),
                1usize => entity.repeat_t = parameter.into(),
                2usize => {
                    entity.mode = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.texture_transform = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => {
                    entity.parameter = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                5usize => entity.width = parameter.into(),
                6usize => entity.height = parameter.into(),
                7usize => entity.colour_components = parameter.into(),
                8usize => entity.pixel = parameter.into(),
                _ => {}
            }
        }
        entity
    }
    pub fn from_own_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcPixelTexture::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.width = parameter.into(),
                1usize => entity.height = parameter.into(),
                2usize => entity.colour_components = parameter.into(),
                3usize => entity.pixel = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcPlacement: IIfcGeometricRepresentationItem {
    fn location(&self) -> &EntityRef;
}
pub trait IIfcPlanarBox: IIfcPlanarExtent {
    fn placement(&self) -> &EntityRef;
}
#[derive(Default, Debug)]
pub struct IfcPlanarBox {
    size_in_x: IfcLengthMeasure,
    size_in_y: IfcLengthMeasure,
    placement: EntityRef,
}
impl IIfcRepresentationItem for IfcPlanarBox {}
impl IIfcGeometricRepresentationItem for IfcPlanarBox {}
impl IIfcPlanarExtent for IfcPlanarBox {
    fn size_in_x(&self) -> &IfcLengthMeasure {
        &self.size_in_x
    }
    fn size_in_y(&self) -> &IfcLengthMeasure {
        &self.size_in_y
    }
}
impl IIfcPlanarBox for IfcPlanarBox {
    fn placement(&self) -> &EntityRef {
        &self.placement
    }
}
impl IfcPlanarBox {
    pub fn from_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcPlanarBox::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.size_in_x = parameter.into(),
                1usize => entity.size_in_y = parameter.into(),
                2usize => entity.placement = parameter.into(),
                _ => {}
            }
        }
        entity
    }
    pub fn from_own_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcPlanarBox::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.placement = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcPlanarExtent: IIfcGeometricRepresentationItem {
    fn size_in_x(&self) -> &IfcLengthMeasure;
    fn size_in_y(&self) -> &IfcLengthMeasure;
}
#[derive(Default, Debug)]
pub struct IfcPlanarExtent {
    size_in_x: IfcLengthMeasure,
    size_in_y: IfcLengthMeasure,
}
impl IIfcRepresentationItem for IfcPlanarExtent {}
impl IIfcGeometricRepresentationItem for IfcPlanarExtent {}
impl IIfcPlanarExtent for IfcPlanarExtent {
    fn size_in_x(&self) -> &IfcLengthMeasure {
        &self.size_in_x
    }
    fn size_in_y(&self) -> &IfcLengthMeasure {
        &self.size_in_y
    }
}
impl IfcPlanarExtent {
    pub fn from_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcPlanarExtent::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.size_in_x = parameter.into(),
                1usize => entity.size_in_y = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcPlane: IIfcElementarySurface {}
#[derive(Default, Debug)]
pub struct IfcPlane {
    position: EntityRef,
}
impl IIfcRepresentationItem for IfcPlane {}
impl IIfcGeometricRepresentationItem for IfcPlane {}
impl IIfcSurface for IfcPlane {}
impl IIfcElementarySurface for IfcPlane {
    fn position(&self) -> &EntityRef {
        &self.position
    }
}
impl IIfcPlane for IfcPlane {}
impl IfcPlane {
    pub fn from_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcPlane::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.position = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcPlate: IIfcBuildingElement {
    fn predefined_type(&self) -> &Option<IfcPlateTypeEnum>;
}
#[derive(Default, Debug)]
pub struct IfcPlate {
    global_id: IfcGloballyUniqueId,
    owner_history: Option<EntityRef>,
    name: Option<IfcLabel>,
    description: Option<IfcText>,
    object_type: Option<IfcLabel>,
    object_placement: Option<EntityRef>,
    representation: Option<EntityRef>,
    tag: Option<IfcIdentifier>,
    predefined_type: Option<IfcPlateTypeEnum>,
}
impl IIfcRoot for IfcPlate {
    fn global_id(&self) -> &IfcGloballyUniqueId {
        &self.global_id
    }
    fn owner_history(&self) -> &Option<EntityRef> {
        &self.owner_history
    }
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
}
impl IIfcObjectDefinition for IfcPlate {}
impl IIfcObject for IfcPlate {
    fn object_type(&self) -> &Option<IfcLabel> {
        &self.object_type
    }
}
impl IIfcProduct for IfcPlate {
    fn object_placement(&self) -> &Option<EntityRef> {
        &self.object_placement
    }
    fn representation(&self) -> &Option<EntityRef> {
        &self.representation
    }
}
impl IIfcElement for IfcPlate {
    fn tag(&self) -> &Option<IfcIdentifier> {
        &self.tag
    }
}
impl IIfcBuildingElement for IfcPlate {}
impl IIfcPlate for IfcPlate {
    fn predefined_type(&self) -> &Option<IfcPlateTypeEnum> {
        &self.predefined_type
    }
}
impl IfcPlate {
    pub fn from_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcPlate::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.global_id = parameter.into(),
                1usize => {
                    entity.owner_history = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => {
                    entity.object_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                5usize => {
                    entity.object_placement = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                6usize => {
                    entity.representation = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                7usize => {
                    entity.tag = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                8usize => {
                    entity.predefined_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
    pub fn from_own_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcPlate::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => {
                    entity.predefined_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcPlateStandardCase: IIfcPlate {}
#[derive(Default, Debug)]
pub struct IfcPlateStandardCase {
    global_id: IfcGloballyUniqueId,
    owner_history: Option<EntityRef>,
    name: Option<IfcLabel>,
    description: Option<IfcText>,
    object_type: Option<IfcLabel>,
    object_placement: Option<EntityRef>,
    representation: Option<EntityRef>,
    tag: Option<IfcIdentifier>,
    predefined_type: Option<IfcPlateTypeEnum>,
}
impl IIfcRoot for IfcPlateStandardCase {
    fn global_id(&self) -> &IfcGloballyUniqueId {
        &self.global_id
    }
    fn owner_history(&self) -> &Option<EntityRef> {
        &self.owner_history
    }
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
}
impl IIfcObjectDefinition for IfcPlateStandardCase {}
impl IIfcObject for IfcPlateStandardCase {
    fn object_type(&self) -> &Option<IfcLabel> {
        &self.object_type
    }
}
impl IIfcProduct for IfcPlateStandardCase {
    fn object_placement(&self) -> &Option<EntityRef> {
        &self.object_placement
    }
    fn representation(&self) -> &Option<EntityRef> {
        &self.representation
    }
}
impl IIfcElement for IfcPlateStandardCase {
    fn tag(&self) -> &Option<IfcIdentifier> {
        &self.tag
    }
}
impl IIfcBuildingElement for IfcPlateStandardCase {}
impl IIfcPlate for IfcPlateStandardCase {
    fn predefined_type(&self) -> &Option<IfcPlateTypeEnum> {
        &self.predefined_type
    }
}
impl IIfcPlateStandardCase for IfcPlateStandardCase {}
impl IfcPlateStandardCase {
    pub fn from_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcPlateStandardCase::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.global_id = parameter.into(),
                1usize => {
                    entity.owner_history = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => {
                    entity.object_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                5usize => {
                    entity.object_placement = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                6usize => {
                    entity.representation = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                7usize => {
                    entity.tag = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                8usize => {
                    entity.predefined_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcPlateType: IIfcBuildingElementType {
    fn predefined_type(&self) -> &IfcPlateTypeEnum;
}
#[derive(Default, Debug)]
pub struct IfcPlateType {
    global_id: IfcGloballyUniqueId,
    owner_history: Option<EntityRef>,
    name: Option<IfcLabel>,
    description: Option<IfcText>,
    applicable_occurrence: Option<IfcIdentifier>,
    has_property_sets: Option<HashSet<EntityRef>>,
    representation_maps: Option<Vec<EntityRef>>,
    tag: Option<IfcLabel>,
    element_type: Option<IfcLabel>,
    predefined_type: IfcPlateTypeEnum,
}
impl IIfcRoot for IfcPlateType {
    fn global_id(&self) -> &IfcGloballyUniqueId {
        &self.global_id
    }
    fn owner_history(&self) -> &Option<EntityRef> {
        &self.owner_history
    }
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
}
impl IIfcObjectDefinition for IfcPlateType {}
impl IIfcTypeObject for IfcPlateType {
    fn applicable_occurrence(&self) -> &Option<IfcIdentifier> {
        &self.applicable_occurrence
    }
    fn has_property_sets(&self) -> &Option<HashSet<EntityRef>> {
        &self.has_property_sets
    }
}
impl IIfcTypeProduct for IfcPlateType {
    fn representation_maps(&self) -> &Option<Vec<EntityRef>> {
        &self.representation_maps
    }
    fn tag(&self) -> &Option<IfcLabel> {
        &self.tag
    }
}
impl IIfcElementType for IfcPlateType {
    fn element_type(&self) -> &Option<IfcLabel> {
        &self.element_type
    }
}
impl IIfcBuildingElementType for IfcPlateType {}
impl IIfcPlateType for IfcPlateType {
    fn predefined_type(&self) -> &IfcPlateTypeEnum {
        &self.predefined_type
    }
}
impl IfcPlateType {
    pub fn from_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcPlateType::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.global_id = parameter.into(),
                1usize => {
                    entity.owner_history = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => {
                    entity.applicable_occurrence = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                5usize => {
                    entity.has_property_sets = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                6usize => {
                    entity.representation_maps = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                7usize => {
                    entity.tag = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                8usize => {
                    entity.element_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                9usize => entity.predefined_type = parameter.into(),
                _ => {}
            }
        }
        entity
    }
    pub fn from_own_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcPlateType::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.predefined_type = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcPoint: IIfcGeometricRepresentationItem {}
pub trait IIfcPointOnCurve: IIfcPoint {
    fn basis_curve(&self) -> &EntityRef;
    fn point_parameter(&self) -> &IfcParameterValue;
}
#[derive(Default, Debug)]
pub struct IfcPointOnCurve {
    basis_curve: EntityRef,
    point_parameter: IfcParameterValue,
}
impl IIfcRepresentationItem for IfcPointOnCurve {}
impl IIfcGeometricRepresentationItem for IfcPointOnCurve {}
impl IIfcPoint for IfcPointOnCurve {}
impl IIfcPointOnCurve for IfcPointOnCurve {
    fn basis_curve(&self) -> &EntityRef {
        &self.basis_curve
    }
    fn point_parameter(&self) -> &IfcParameterValue {
        &self.point_parameter
    }
}
impl IfcPointOnCurve {
    pub fn from_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcPointOnCurve::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.basis_curve = parameter.into(),
                1usize => entity.point_parameter = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcPointOnSurface: IIfcPoint {
    fn basis_surface(&self) -> &EntityRef;
    fn point_parameter_u(&self) -> &IfcParameterValue;
    fn point_parameter_v(&self) -> &IfcParameterValue;
}
#[derive(Default, Debug)]
pub struct IfcPointOnSurface {
    basis_surface: EntityRef,
    point_parameter_u: IfcParameterValue,
    point_parameter_v: IfcParameterValue,
}
impl IIfcRepresentationItem for IfcPointOnSurface {}
impl IIfcGeometricRepresentationItem for IfcPointOnSurface {}
impl IIfcPoint for IfcPointOnSurface {}
impl IIfcPointOnSurface for IfcPointOnSurface {
    fn basis_surface(&self) -> &EntityRef {
        &self.basis_surface
    }
    fn point_parameter_u(&self) -> &IfcParameterValue {
        &self.point_parameter_u
    }
    fn point_parameter_v(&self) -> &IfcParameterValue {
        &self.point_parameter_v
    }
}
impl IfcPointOnSurface {
    pub fn from_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcPointOnSurface::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.basis_surface = parameter.into(),
                1usize => entity.point_parameter_u = parameter.into(),
                2usize => entity.point_parameter_v = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcPolyLoop: IIfcLoop {
    fn polygon(&self) -> &Vec<EntityRef>;
}
#[derive(Default, Debug)]
pub struct IfcPolyLoop {
    polygon: Vec<EntityRef>,
}
impl IIfcRepresentationItem for IfcPolyLoop {}
impl IIfcTopologicalRepresentationItem for IfcPolyLoop {}
impl IIfcLoop for IfcPolyLoop {}
impl IIfcPolyLoop for IfcPolyLoop {
    fn polygon(&self) -> &Vec<EntityRef> {
        &self.polygon
    }
}
impl IfcPolyLoop {
    pub fn from_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcPolyLoop::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.polygon = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcPolygonalBoundedHalfSpace: IIfcHalfSpaceSolid {
    fn position(&self) -> &EntityRef;
    fn polygonal_boundary(&self) -> &EntityRef;
}
#[derive(Default, Debug)]
pub struct IfcPolygonalBoundedHalfSpace {
    base_surface: EntityRef,
    agreement_flag: IfcBoolean,
    position: EntityRef,
    polygonal_boundary: EntityRef,
}
impl IIfcRepresentationItem for IfcPolygonalBoundedHalfSpace {}
impl IIfcGeometricRepresentationItem for IfcPolygonalBoundedHalfSpace {}
impl IIfcHalfSpaceSolid for IfcPolygonalBoundedHalfSpace {
    fn base_surface(&self) -> &EntityRef {
        &self.base_surface
    }
    fn agreement_flag(&self) -> &IfcBoolean {
        &self.agreement_flag
    }
}
impl IIfcPolygonalBoundedHalfSpace for IfcPolygonalBoundedHalfSpace {
    fn position(&self) -> &EntityRef {
        &self.position
    }
    fn polygonal_boundary(&self) -> &EntityRef {
        &self.polygonal_boundary
    }
}
impl IfcPolygonalBoundedHalfSpace {
    pub fn from_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcPolygonalBoundedHalfSpace::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.base_surface = parameter.into(),
                1usize => entity.agreement_flag = parameter.into(),
                2usize => entity.position = parameter.into(),
                3usize => entity.polygonal_boundary = parameter.into(),
                _ => {}
            }
        }
        entity
    }
    pub fn from_own_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcPolygonalBoundedHalfSpace::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.position = parameter.into(),
                1usize => entity.polygonal_boundary = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcPolygonalFaceSet: IIfcTessellatedFaceSet {
    fn closed(&self) -> &Option<IfcBoolean>;
    fn faces(&self) -> &Vec<EntityRef>;
    fn pn_index(&self) -> &Option<Vec<IfcPositiveInteger>>;
}
#[derive(Default, Debug)]
pub struct IfcPolygonalFaceSet {
    coordinates: EntityRef,
    closed: Option<IfcBoolean>,
    faces: Vec<EntityRef>,
    pn_index: Option<Vec<IfcPositiveInteger>>,
}
impl IIfcRepresentationItem for IfcPolygonalFaceSet {}
impl IIfcGeometricRepresentationItem for IfcPolygonalFaceSet {}
impl IIfcTessellatedItem for IfcPolygonalFaceSet {}
impl IIfcTessellatedFaceSet for IfcPolygonalFaceSet {
    fn coordinates(&self) -> &EntityRef {
        &self.coordinates
    }
}
impl IIfcPolygonalFaceSet for IfcPolygonalFaceSet {
    fn closed(&self) -> &Option<IfcBoolean> {
        &self.closed
    }
    fn faces(&self) -> &Vec<EntityRef> {
        &self.faces
    }
    fn pn_index(&self) -> &Option<Vec<IfcPositiveInteger>> {
        &self.pn_index
    }
}
impl IfcPolygonalFaceSet {
    pub fn from_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcPolygonalFaceSet::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.coordinates = parameter.into(),
                1usize => {
                    entity.closed = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => entity.faces = parameter.into(),
                3usize => {
                    entity.pn_index = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
    pub fn from_own_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcPolygonalFaceSet::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => {
                    entity.closed = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                1usize => entity.faces = parameter.into(),
                2usize => {
                    entity.pn_index = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcPolyline: IIfcBoundedCurve {
    fn points(&self) -> &Vec<EntityRef>;
}
#[derive(Default, Debug)]
pub struct IfcPolyline {
    points: Vec<EntityRef>,
}
impl IIfcRepresentationItem for IfcPolyline {}
impl IIfcGeometricRepresentationItem for IfcPolyline {}
impl IIfcCurve for IfcPolyline {}
impl IIfcBoundedCurve for IfcPolyline {}
impl IIfcPolyline for IfcPolyline {
    fn points(&self) -> &Vec<EntityRef> {
        &self.points
    }
}
impl IfcPolyline {
    pub fn from_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcPolyline::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.points = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcPort: IIfcProduct {}
pub trait IIfcPostalAddress: IIfcAddress {
    fn internal_location(&self) -> &Option<IfcLabel>;
    fn address_lines(&self) -> &Option<Vec<IfcLabel>>;
    fn postal_box(&self) -> &Option<IfcLabel>;
    fn town(&self) -> &Option<IfcLabel>;
    fn region(&self) -> &Option<IfcLabel>;
    fn postal_code(&self) -> &Option<IfcLabel>;
    fn country(&self) -> &Option<IfcLabel>;
}
#[derive(Default, Debug)]
pub struct IfcPostalAddress {
    purpose: Option<IfcAddressTypeEnum>,
    description: Option<IfcText>,
    user_defined_purpose: Option<IfcLabel>,
    internal_location: Option<IfcLabel>,
    address_lines: Option<Vec<IfcLabel>>,
    postal_box: Option<IfcLabel>,
    town: Option<IfcLabel>,
    region: Option<IfcLabel>,
    postal_code: Option<IfcLabel>,
    country: Option<IfcLabel>,
}
impl IIfcAddress for IfcPostalAddress {
    fn purpose(&self) -> &Option<IfcAddressTypeEnum> {
        &self.purpose
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
    fn user_defined_purpose(&self) -> &Option<IfcLabel> {
        &self.user_defined_purpose
    }
}
impl IIfcPostalAddress for IfcPostalAddress {
    fn internal_location(&self) -> &Option<IfcLabel> {
        &self.internal_location
    }
    fn address_lines(&self) -> &Option<Vec<IfcLabel>> {
        &self.address_lines
    }
    fn postal_box(&self) -> &Option<IfcLabel> {
        &self.postal_box
    }
    fn town(&self) -> &Option<IfcLabel> {
        &self.town
    }
    fn region(&self) -> &Option<IfcLabel> {
        &self.region
    }
    fn postal_code(&self) -> &Option<IfcLabel> {
        &self.postal_code
    }
    fn country(&self) -> &Option<IfcLabel> {
        &self.country
    }
}
impl IfcPostalAddress {
    pub fn from_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcPostalAddress::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => {
                    entity.purpose = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                1usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => {
                    entity.user_defined_purpose = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.internal_location = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => {
                    entity.address_lines = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                5usize => {
                    entity.postal_box = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                6usize => {
                    entity.town = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                7usize => {
                    entity.region = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                8usize => {
                    entity.postal_code = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                9usize => {
                    entity.country = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
    pub fn from_own_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcPostalAddress::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => {
                    entity.internal_location = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                1usize => {
                    entity.address_lines = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => {
                    entity.postal_box = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.town = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => {
                    entity.region = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                5usize => {
                    entity.postal_code = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                6usize => {
                    entity.country = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcPreDefinedColour: IIfcPreDefinedItem {}
pub trait IIfcPreDefinedCurveFont: IIfcPreDefinedItem {}
pub trait IIfcPreDefinedItem: IIfcPresentationItem {
    fn name(&self) -> &IfcLabel;
}
pub trait IIfcPreDefinedProperties: IIfcPropertyAbstraction {}
pub trait IIfcPreDefinedPropertySet: IIfcPropertySetDefinition {}
pub trait IIfcPreDefinedTextFont: IIfcPreDefinedItem {}
pub trait IIfcPresentationItem {}
pub trait IIfcPresentationLayerAssignment {
    fn name(&self) -> &IfcLabel;
    fn description(&self) -> &Option<IfcText>;
    fn assigned_items(&self) -> &HashSet<EntityRef>;
    fn identifier(&self) -> &Option<IfcIdentifier>;
}
#[derive(Default, Debug)]
pub struct IfcPresentationLayerAssignment {
    name: IfcLabel,
    description: Option<IfcText>,
    assigned_items: HashSet<EntityRef>,
    identifier: Option<IfcIdentifier>,
}
impl IIfcPresentationLayerAssignment for IfcPresentationLayerAssignment {
    fn name(&self) -> &IfcLabel {
        &self.name
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
    fn assigned_items(&self) -> &HashSet<EntityRef> {
        &self.assigned_items
    }
    fn identifier(&self) -> &Option<IfcIdentifier> {
        &self.identifier
    }
}
impl IfcPresentationLayerAssignment {
    pub fn from_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcPresentationLayerAssignment::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => entity.assigned_items = parameter.into(),
                3usize => {
                    entity.identifier = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcPresentationLayerWithStyle: IIfcPresentationLayerAssignment {
    fn layer_on(&self) -> &IfcLogical;
    fn layer_frozen(&self) -> &IfcLogical;
    fn layer_blocked(&self) -> &IfcLogical;
    fn layer_styles(&self) -> &HashSet<EntityRef>;
}
#[derive(Default, Debug)]
pub struct IfcPresentationLayerWithStyle {
    name: IfcLabel,
    description: Option<IfcText>,
    assigned_items: HashSet<EntityRef>,
    identifier: Option<IfcIdentifier>,
    layer_on: IfcLogical,
    layer_frozen: IfcLogical,
    layer_blocked: IfcLogical,
    layer_styles: HashSet<EntityRef>,
}
impl IIfcPresentationLayerAssignment for IfcPresentationLayerWithStyle {
    fn name(&self) -> &IfcLabel {
        &self.name
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
    fn assigned_items(&self) -> &HashSet<EntityRef> {
        &self.assigned_items
    }
    fn identifier(&self) -> &Option<IfcIdentifier> {
        &self.identifier
    }
}
impl IIfcPresentationLayerWithStyle for IfcPresentationLayerWithStyle {
    fn layer_on(&self) -> &IfcLogical {
        &self.layer_on
    }
    fn layer_frozen(&self) -> &IfcLogical {
        &self.layer_frozen
    }
    fn layer_blocked(&self) -> &IfcLogical {
        &self.layer_blocked
    }
    fn layer_styles(&self) -> &HashSet<EntityRef> {
        &self.layer_styles
    }
}
impl IfcPresentationLayerWithStyle {
    pub fn from_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcPresentationLayerWithStyle::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => entity.assigned_items = parameter.into(),
                3usize => {
                    entity.identifier = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => entity.layer_on = parameter.into(),
                5usize => entity.layer_frozen = parameter.into(),
                6usize => entity.layer_blocked = parameter.into(),
                7usize => entity.layer_styles = parameter.into(),
                _ => {}
            }
        }
        entity
    }
    pub fn from_own_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcPresentationLayerWithStyle::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.layer_on = parameter.into(),
                1usize => entity.layer_frozen = parameter.into(),
                2usize => entity.layer_blocked = parameter.into(),
                3usize => entity.layer_styles = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcPresentationStyle {
    fn name(&self) -> &Option<IfcLabel>;
}
pub trait IIfcPresentationStyleAssignment {
    fn styles(&self) -> &HashSet<IfcPresentationStyleSelect>;
}
#[derive(Default, Debug)]
pub struct IfcPresentationStyleAssignment {
    styles: HashSet<IfcPresentationStyleSelect>,
}
impl IIfcPresentationStyleAssignment for IfcPresentationStyleAssignment {
    fn styles(&self) -> &HashSet<IfcPresentationStyleSelect> {
        &self.styles
    }
}
impl IfcPresentationStyleAssignment {
    pub fn from_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcPresentationStyleAssignment::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.styles = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcProcedure: IIfcProcess {
    fn predefined_type(&self) -> &Option<IfcProcedureTypeEnum>;
}
#[derive(Default, Debug)]
pub struct IfcProcedure {
    global_id: IfcGloballyUniqueId,
    owner_history: Option<EntityRef>,
    name: Option<IfcLabel>,
    description: Option<IfcText>,
    object_type: Option<IfcLabel>,
    identification: Option<IfcIdentifier>,
    long_description: Option<IfcText>,
    predefined_type: Option<IfcProcedureTypeEnum>,
}
impl IIfcRoot for IfcProcedure {
    fn global_id(&self) -> &IfcGloballyUniqueId {
        &self.global_id
    }
    fn owner_history(&self) -> &Option<EntityRef> {
        &self.owner_history
    }
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
}
impl IIfcObjectDefinition for IfcProcedure {}
impl IIfcObject for IfcProcedure {
    fn object_type(&self) -> &Option<IfcLabel> {
        &self.object_type
    }
}
impl IIfcProcess for IfcProcedure {
    fn identification(&self) -> &Option<IfcIdentifier> {
        &self.identification
    }
    fn long_description(&self) -> &Option<IfcText> {
        &self.long_description
    }
}
impl IIfcProcedure for IfcProcedure {
    fn predefined_type(&self) -> &Option<IfcProcedureTypeEnum> {
        &self.predefined_type
    }
}
impl IfcProcedure {
    pub fn from_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcProcedure::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.global_id = parameter.into(),
                1usize => {
                    entity.owner_history = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => {
                    entity.object_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                5usize => {
                    entity.identification = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                6usize => {
                    entity.long_description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                7usize => {
                    entity.predefined_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
    pub fn from_own_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcProcedure::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => {
                    entity.predefined_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcProcedureType: IIfcTypeProcess {
    fn predefined_type(&self) -> &IfcProcedureTypeEnum;
}
#[derive(Default, Debug)]
pub struct IfcProcedureType {
    global_id: IfcGloballyUniqueId,
    owner_history: Option<EntityRef>,
    name: Option<IfcLabel>,
    description: Option<IfcText>,
    applicable_occurrence: Option<IfcIdentifier>,
    has_property_sets: Option<HashSet<EntityRef>>,
    identification: Option<IfcIdentifier>,
    long_description: Option<IfcText>,
    process_type: Option<IfcLabel>,
    predefined_type: IfcProcedureTypeEnum,
}
impl IIfcRoot for IfcProcedureType {
    fn global_id(&self) -> &IfcGloballyUniqueId {
        &self.global_id
    }
    fn owner_history(&self) -> &Option<EntityRef> {
        &self.owner_history
    }
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
}
impl IIfcObjectDefinition for IfcProcedureType {}
impl IIfcTypeObject for IfcProcedureType {
    fn applicable_occurrence(&self) -> &Option<IfcIdentifier> {
        &self.applicable_occurrence
    }
    fn has_property_sets(&self) -> &Option<HashSet<EntityRef>> {
        &self.has_property_sets
    }
}
impl IIfcTypeProcess for IfcProcedureType {
    fn identification(&self) -> &Option<IfcIdentifier> {
        &self.identification
    }
    fn long_description(&self) -> &Option<IfcText> {
        &self.long_description
    }
    fn process_type(&self) -> &Option<IfcLabel> {
        &self.process_type
    }
}
impl IIfcProcedureType for IfcProcedureType {
    fn predefined_type(&self) -> &IfcProcedureTypeEnum {
        &self.predefined_type
    }
}
impl IfcProcedureType {
    pub fn from_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcProcedureType::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.global_id = parameter.into(),
                1usize => {
                    entity.owner_history = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => {
                    entity.applicable_occurrence = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                5usize => {
                    entity.has_property_sets = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                6usize => {
                    entity.identification = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                7usize => {
                    entity.long_description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                8usize => {
                    entity.process_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                9usize => entity.predefined_type = parameter.into(),
                _ => {}
            }
        }
        entity
    }
    pub fn from_own_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcProcedureType::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.predefined_type = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcProcess: IIfcObject {
    fn identification(&self) -> &Option<IfcIdentifier>;
    fn long_description(&self) -> &Option<IfcText>;
}
pub trait IIfcProduct: IIfcObject {
    fn object_placement(&self) -> &Option<EntityRef>;
    fn representation(&self) -> &Option<EntityRef>;
}
pub trait IIfcProductDefinitionShape: IIfcProductRepresentation {}
#[derive(Default, Debug)]
pub struct IfcProductDefinitionShape {
    name: Option<IfcLabel>,
    description: Option<IfcText>,
    representations: Vec<EntityRef>,
}
impl IIfcProductRepresentation for IfcProductDefinitionShape {
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
    fn representations(&self) -> &Vec<EntityRef> {
        &self.representations
    }
}
impl IIfcProductDefinitionShape for IfcProductDefinitionShape {}
impl IfcProductDefinitionShape {
    pub fn from_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcProductDefinitionShape::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                1usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => entity.representations = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcProductRepresentation {
    fn name(&self) -> &Option<IfcLabel>;
    fn description(&self) -> &Option<IfcText>;
    fn representations(&self) -> &Vec<EntityRef>;
}
pub trait IIfcProfileDef {
    fn profile_type(&self) -> &IfcProfileTypeEnum;
    fn profile_name(&self) -> &Option<IfcLabel>;
}
#[derive(Default, Debug)]
pub struct IfcProfileDef {
    profile_type: IfcProfileTypeEnum,
    profile_name: Option<IfcLabel>,
}
impl IIfcProfileDef for IfcProfileDef {
    fn profile_type(&self) -> &IfcProfileTypeEnum {
        &self.profile_type
    }
    fn profile_name(&self) -> &Option<IfcLabel> {
        &self.profile_name
    }
}
impl IfcProfileDef {
    pub fn from_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcProfileDef::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.profile_type = parameter.into(),
                1usize => {
                    entity.profile_name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcProfileProperties: IIfcExtendedProperties {
    fn profile_definition(&self) -> &EntityRef;
}
#[derive(Default, Debug)]
pub struct IfcProfileProperties {
    name: Option<IfcIdentifier>,
    description: Option<IfcText>,
    properties: HashSet<EntityRef>,
    profile_definition: EntityRef,
}
impl IIfcPropertyAbstraction for IfcProfileProperties {}
impl IIfcExtendedProperties for IfcProfileProperties {
    fn name(&self) -> &Option<IfcIdentifier> {
        &self.name
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
    fn properties(&self) -> &HashSet<EntityRef> {
        &self.properties
    }
}
impl IIfcProfileProperties for IfcProfileProperties {
    fn profile_definition(&self) -> &EntityRef {
        &self.profile_definition
    }
}
impl IfcProfileProperties {
    pub fn from_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcProfileProperties::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                1usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => entity.properties = parameter.into(),
                3usize => entity.profile_definition = parameter.into(),
                _ => {}
            }
        }
        entity
    }
    pub fn from_own_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcProfileProperties::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.profile_definition = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcProject: IIfcContext {}
#[derive(Default, Debug)]
pub struct IfcProject {
    global_id: IfcGloballyUniqueId,
    owner_history: Option<EntityRef>,
    name: Option<IfcLabel>,
    description: Option<IfcText>,
    object_type: Option<IfcLabel>,
    long_name: Option<IfcLabel>,
    phase: Option<IfcLabel>,
    representation_contexts: Option<HashSet<EntityRef>>,
    units_in_context: Option<EntityRef>,
}
impl IIfcRoot for IfcProject {
    fn global_id(&self) -> &IfcGloballyUniqueId {
        &self.global_id
    }
    fn owner_history(&self) -> &Option<EntityRef> {
        &self.owner_history
    }
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
}
impl IIfcObjectDefinition for IfcProject {}
impl IIfcContext for IfcProject {
    fn object_type(&self) -> &Option<IfcLabel> {
        &self.object_type
    }
    fn long_name(&self) -> &Option<IfcLabel> {
        &self.long_name
    }
    fn phase(&self) -> &Option<IfcLabel> {
        &self.phase
    }
    fn representation_contexts(&self) -> &Option<HashSet<EntityRef>> {
        &self.representation_contexts
    }
    fn units_in_context(&self) -> &Option<EntityRef> {
        &self.units_in_context
    }
}
impl IIfcProject for IfcProject {}
impl IfcProject {
    pub fn from_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcProject::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.global_id = parameter.into(),
                1usize => {
                    entity.owner_history = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => {
                    entity.object_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                5usize => {
                    entity.long_name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                6usize => {
                    entity.phase = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                7usize => {
                    entity.representation_contexts = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                8usize => {
                    entity.units_in_context = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcProjectLibrary: IIfcContext {}
#[derive(Default, Debug)]
pub struct IfcProjectLibrary {
    global_id: IfcGloballyUniqueId,
    owner_history: Option<EntityRef>,
    name: Option<IfcLabel>,
    description: Option<IfcText>,
    object_type: Option<IfcLabel>,
    long_name: Option<IfcLabel>,
    phase: Option<IfcLabel>,
    representation_contexts: Option<HashSet<EntityRef>>,
    units_in_context: Option<EntityRef>,
}
impl IIfcRoot for IfcProjectLibrary {
    fn global_id(&self) -> &IfcGloballyUniqueId {
        &self.global_id
    }
    fn owner_history(&self) -> &Option<EntityRef> {
        &self.owner_history
    }
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
}
impl IIfcObjectDefinition for IfcProjectLibrary {}
impl IIfcContext for IfcProjectLibrary {
    fn object_type(&self) -> &Option<IfcLabel> {
        &self.object_type
    }
    fn long_name(&self) -> &Option<IfcLabel> {
        &self.long_name
    }
    fn phase(&self) -> &Option<IfcLabel> {
        &self.phase
    }
    fn representation_contexts(&self) -> &Option<HashSet<EntityRef>> {
        &self.representation_contexts
    }
    fn units_in_context(&self) -> &Option<EntityRef> {
        &self.units_in_context
    }
}
impl IIfcProjectLibrary for IfcProjectLibrary {}
impl IfcProjectLibrary {
    pub fn from_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcProjectLibrary::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.global_id = parameter.into(),
                1usize => {
                    entity.owner_history = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => {
                    entity.object_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                5usize => {
                    entity.long_name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                6usize => {
                    entity.phase = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                7usize => {
                    entity.representation_contexts = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                8usize => {
                    entity.units_in_context = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcProjectOrder: IIfcControl {
    fn predefined_type(&self) -> &Option<IfcProjectOrderTypeEnum>;
    fn status(&self) -> &Option<IfcLabel>;
    fn long_description(&self) -> &Option<IfcText>;
}
#[derive(Default, Debug)]
pub struct IfcProjectOrder {
    global_id: IfcGloballyUniqueId,
    owner_history: Option<EntityRef>,
    name: Option<IfcLabel>,
    description: Option<IfcText>,
    object_type: Option<IfcLabel>,
    identification: Option<IfcIdentifier>,
    predefined_type: Option<IfcProjectOrderTypeEnum>,
    status: Option<IfcLabel>,
    long_description: Option<IfcText>,
}
impl IIfcRoot for IfcProjectOrder {
    fn global_id(&self) -> &IfcGloballyUniqueId {
        &self.global_id
    }
    fn owner_history(&self) -> &Option<EntityRef> {
        &self.owner_history
    }
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
}
impl IIfcObjectDefinition for IfcProjectOrder {}
impl IIfcObject for IfcProjectOrder {
    fn object_type(&self) -> &Option<IfcLabel> {
        &self.object_type
    }
}
impl IIfcControl for IfcProjectOrder {
    fn identification(&self) -> &Option<IfcIdentifier> {
        &self.identification
    }
}
impl IIfcProjectOrder for IfcProjectOrder {
    fn predefined_type(&self) -> &Option<IfcProjectOrderTypeEnum> {
        &self.predefined_type
    }
    fn status(&self) -> &Option<IfcLabel> {
        &self.status
    }
    fn long_description(&self) -> &Option<IfcText> {
        &self.long_description
    }
}
impl IfcProjectOrder {
    pub fn from_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcProjectOrder::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.global_id = parameter.into(),
                1usize => {
                    entity.owner_history = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => {
                    entity.object_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                5usize => {
                    entity.identification = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                6usize => {
                    entity.predefined_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                7usize => {
                    entity.status = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                8usize => {
                    entity.long_description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
    pub fn from_own_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcProjectOrder::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => {
                    entity.predefined_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                1usize => {
                    entity.status = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => {
                    entity.long_description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcProjectedCrs: IIfcCoordinateReferenceSystem {
    fn map_projection(&self) -> &Option<IfcIdentifier>;
    fn map_zone(&self) -> &Option<IfcIdentifier>;
    fn map_unit(&self) -> &Option<EntityRef>;
}
#[derive(Default, Debug)]
pub struct IfcProjectedCrs {
    name: IfcLabel,
    description: Option<IfcText>,
    geodetic_datum: Option<IfcIdentifier>,
    vertical_datum: Option<IfcIdentifier>,
    map_projection: Option<IfcIdentifier>,
    map_zone: Option<IfcIdentifier>,
    map_unit: Option<EntityRef>,
}
impl IIfcCoordinateReferenceSystem for IfcProjectedCrs {
    fn name(&self) -> &IfcLabel {
        &self.name
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
    fn geodetic_datum(&self) -> &Option<IfcIdentifier> {
        &self.geodetic_datum
    }
    fn vertical_datum(&self) -> &Option<IfcIdentifier> {
        &self.vertical_datum
    }
}
impl IIfcProjectedCrs for IfcProjectedCrs {
    fn map_projection(&self) -> &Option<IfcIdentifier> {
        &self.map_projection
    }
    fn map_zone(&self) -> &Option<IfcIdentifier> {
        &self.map_zone
    }
    fn map_unit(&self) -> &Option<EntityRef> {
        &self.map_unit
    }
}
impl IfcProjectedCrs {
    pub fn from_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcProjectedCrs::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => {
                    entity.geodetic_datum = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.vertical_datum = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => {
                    entity.map_projection = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                5usize => {
                    entity.map_zone = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                6usize => {
                    entity.map_unit = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
    pub fn from_own_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcProjectedCrs::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => {
                    entity.map_projection = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                1usize => {
                    entity.map_zone = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => {
                    entity.map_unit = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcProjectionElement: IIfcFeatureElementAddition {
    fn predefined_type(&self) -> &Option<IfcProjectionElementTypeEnum>;
}
#[derive(Default, Debug)]
pub struct IfcProjectionElement {
    global_id: IfcGloballyUniqueId,
    owner_history: Option<EntityRef>,
    name: Option<IfcLabel>,
    description: Option<IfcText>,
    object_type: Option<IfcLabel>,
    object_placement: Option<EntityRef>,
    representation: Option<EntityRef>,
    tag: Option<IfcIdentifier>,
    predefined_type: Option<IfcProjectionElementTypeEnum>,
}
impl IIfcRoot for IfcProjectionElement {
    fn global_id(&self) -> &IfcGloballyUniqueId {
        &self.global_id
    }
    fn owner_history(&self) -> &Option<EntityRef> {
        &self.owner_history
    }
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
}
impl IIfcObjectDefinition for IfcProjectionElement {}
impl IIfcObject for IfcProjectionElement {
    fn object_type(&self) -> &Option<IfcLabel> {
        &self.object_type
    }
}
impl IIfcProduct for IfcProjectionElement {
    fn object_placement(&self) -> &Option<EntityRef> {
        &self.object_placement
    }
    fn representation(&self) -> &Option<EntityRef> {
        &self.representation
    }
}
impl IIfcElement for IfcProjectionElement {
    fn tag(&self) -> &Option<IfcIdentifier> {
        &self.tag
    }
}
impl IIfcFeatureElement for IfcProjectionElement {}
impl IIfcFeatureElementAddition for IfcProjectionElement {}
impl IIfcProjectionElement for IfcProjectionElement {
    fn predefined_type(&self) -> &Option<IfcProjectionElementTypeEnum> {
        &self.predefined_type
    }
}
impl IfcProjectionElement {
    pub fn from_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcProjectionElement::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.global_id = parameter.into(),
                1usize => {
                    entity.owner_history = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => {
                    entity.object_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                5usize => {
                    entity.object_placement = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                6usize => {
                    entity.representation = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                7usize => {
                    entity.tag = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                8usize => {
                    entity.predefined_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
    pub fn from_own_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcProjectionElement::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => {
                    entity.predefined_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcProperty: IIfcPropertyAbstraction {
    fn name(&self) -> &IfcIdentifier;
    fn description(&self) -> &Option<IfcText>;
}
pub trait IIfcPropertyAbstraction {}
pub trait IIfcPropertyBoundedValue: IIfcSimpleProperty {
    fn upper_bound_value(&self) -> &Option<IfcValue>;
    fn lower_bound_value(&self) -> &Option<IfcValue>;
    fn unit(&self) -> &Option<EntityRef>;
    fn set_point_value(&self) -> &Option<IfcValue>;
}
#[derive(Default, Debug)]
pub struct IfcPropertyBoundedValue {
    name: IfcIdentifier,
    description: Option<IfcText>,
    upper_bound_value: Option<IfcValue>,
    lower_bound_value: Option<IfcValue>,
    unit: Option<EntityRef>,
    set_point_value: Option<IfcValue>,
}
impl IIfcPropertyAbstraction for IfcPropertyBoundedValue {}
impl IIfcProperty for IfcPropertyBoundedValue {
    fn name(&self) -> &IfcIdentifier {
        &self.name
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
}
impl IIfcSimpleProperty for IfcPropertyBoundedValue {}
impl IIfcPropertyBoundedValue for IfcPropertyBoundedValue {
    fn upper_bound_value(&self) -> &Option<IfcValue> {
        &self.upper_bound_value
    }
    fn lower_bound_value(&self) -> &Option<IfcValue> {
        &self.lower_bound_value
    }
    fn unit(&self) -> &Option<EntityRef> {
        &self.unit
    }
    fn set_point_value(&self) -> &Option<IfcValue> {
        &self.set_point_value
    }
}
impl IfcPropertyBoundedValue {
    pub fn from_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcPropertyBoundedValue::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => {
                    entity.upper_bound_value = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.lower_bound_value = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => {
                    entity.unit = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                5usize => {
                    entity.set_point_value = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
    pub fn from_own_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcPropertyBoundedValue::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => {
                    entity.upper_bound_value = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                1usize => {
                    entity.lower_bound_value = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => {
                    entity.unit = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.set_point_value = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcPropertyDefinition: IIfcRoot {}
pub trait IIfcPropertyDependencyRelationship: IIfcResourceLevelRelationship {
    fn depending_property(&self) -> &EntityRef;
    fn dependant_property(&self) -> &EntityRef;
    fn expression(&self) -> &Option<IfcText>;
}
#[derive(Default, Debug)]
pub struct IfcPropertyDependencyRelationship {
    name: Option<IfcLabel>,
    description: Option<IfcText>,
    depending_property: EntityRef,
    dependant_property: EntityRef,
    expression: Option<IfcText>,
}
impl IIfcResourceLevelRelationship for IfcPropertyDependencyRelationship {
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
}
impl IIfcPropertyDependencyRelationship for IfcPropertyDependencyRelationship {
    fn depending_property(&self) -> &EntityRef {
        &self.depending_property
    }
    fn dependant_property(&self) -> &EntityRef {
        &self.dependant_property
    }
    fn expression(&self) -> &Option<IfcText> {
        &self.expression
    }
}
impl IfcPropertyDependencyRelationship {
    pub fn from_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcPropertyDependencyRelationship::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                1usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => entity.depending_property = parameter.into(),
                3usize => entity.dependant_property = parameter.into(),
                4usize => {
                    entity.expression = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
    pub fn from_own_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcPropertyDependencyRelationship::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.depending_property = parameter.into(),
                1usize => entity.dependant_property = parameter.into(),
                2usize => {
                    entity.expression = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcPropertyEnumeratedValue: IIfcSimpleProperty {
    fn enumeration_values(&self) -> &Option<Vec<IfcValue>>;
    fn enumeration_reference(&self) -> &Option<EntityRef>;
}
#[derive(Default, Debug)]
pub struct IfcPropertyEnumeratedValue {
    name: IfcIdentifier,
    description: Option<IfcText>,
    enumeration_values: Option<Vec<IfcValue>>,
    enumeration_reference: Option<EntityRef>,
}
impl IIfcPropertyAbstraction for IfcPropertyEnumeratedValue {}
impl IIfcProperty for IfcPropertyEnumeratedValue {
    fn name(&self) -> &IfcIdentifier {
        &self.name
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
}
impl IIfcSimpleProperty for IfcPropertyEnumeratedValue {}
impl IIfcPropertyEnumeratedValue for IfcPropertyEnumeratedValue {
    fn enumeration_values(&self) -> &Option<Vec<IfcValue>> {
        &self.enumeration_values
    }
    fn enumeration_reference(&self) -> &Option<EntityRef> {
        &self.enumeration_reference
    }
}
impl IfcPropertyEnumeratedValue {
    pub fn from_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcPropertyEnumeratedValue::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => {
                    entity.enumeration_values = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.enumeration_reference = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
    pub fn from_own_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcPropertyEnumeratedValue::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => {
                    entity.enumeration_values = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                1usize => {
                    entity.enumeration_reference = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcPropertyEnumeration: IIfcPropertyAbstraction {
    fn name(&self) -> &IfcLabel;
    fn enumeration_values(&self) -> &Vec<IfcValue>;
    fn unit(&self) -> &Option<EntityRef>;
}
#[derive(Default, Debug)]
pub struct IfcPropertyEnumeration {
    name: IfcLabel,
    enumeration_values: Vec<IfcValue>,
    unit: Option<EntityRef>,
}
impl IIfcPropertyAbstraction for IfcPropertyEnumeration {}
impl IIfcPropertyEnumeration for IfcPropertyEnumeration {
    fn name(&self) -> &IfcLabel {
        &self.name
    }
    fn enumeration_values(&self) -> &Vec<IfcValue> {
        &self.enumeration_values
    }
    fn unit(&self) -> &Option<EntityRef> {
        &self.unit
    }
}
impl IfcPropertyEnumeration {
    pub fn from_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcPropertyEnumeration::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => entity.enumeration_values = parameter.into(),
                2usize => {
                    entity.unit = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcPropertyListValue: IIfcSimpleProperty {
    fn list_values(&self) -> &Option<Vec<IfcValue>>;
    fn unit(&self) -> &Option<EntityRef>;
}
#[derive(Default, Debug)]
pub struct IfcPropertyListValue {
    name: IfcIdentifier,
    description: Option<IfcText>,
    list_values: Option<Vec<IfcValue>>,
    unit: Option<EntityRef>,
}
impl IIfcPropertyAbstraction for IfcPropertyListValue {}
impl IIfcProperty for IfcPropertyListValue {
    fn name(&self) -> &IfcIdentifier {
        &self.name
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
}
impl IIfcSimpleProperty for IfcPropertyListValue {}
impl IIfcPropertyListValue for IfcPropertyListValue {
    fn list_values(&self) -> &Option<Vec<IfcValue>> {
        &self.list_values
    }
    fn unit(&self) -> &Option<EntityRef> {
        &self.unit
    }
}
impl IfcPropertyListValue {
    pub fn from_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcPropertyListValue::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => {
                    entity.list_values = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.unit = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
    pub fn from_own_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcPropertyListValue::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => {
                    entity.list_values = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                1usize => {
                    entity.unit = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcPropertyReferenceValue: IIfcSimpleProperty {
    fn usage_name(&self) -> &Option<IfcText>;
    fn property_reference(&self) -> &Option<EntityRef>;
}
#[derive(Default, Debug)]
pub struct IfcPropertyReferenceValue {
    name: IfcIdentifier,
    description: Option<IfcText>,
    usage_name: Option<IfcText>,
    property_reference: Option<EntityRef>,
}
impl IIfcPropertyAbstraction for IfcPropertyReferenceValue {}
impl IIfcProperty for IfcPropertyReferenceValue {
    fn name(&self) -> &IfcIdentifier {
        &self.name
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
}
impl IIfcSimpleProperty for IfcPropertyReferenceValue {}
impl IIfcPropertyReferenceValue for IfcPropertyReferenceValue {
    fn usage_name(&self) -> &Option<IfcText> {
        &self.usage_name
    }
    fn property_reference(&self) -> &Option<EntityRef> {
        &self.property_reference
    }
}
impl IfcPropertyReferenceValue {
    pub fn from_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcPropertyReferenceValue::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => {
                    entity.usage_name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.property_reference = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
    pub fn from_own_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcPropertyReferenceValue::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => {
                    entity.usage_name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                1usize => {
                    entity.property_reference = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcPropertySet: IIfcPropertySetDefinition {
    fn has_properties(&self) -> &HashSet<EntityRef>;
}
#[derive(Default, Debug)]
pub struct IfcPropertySet {
    global_id: IfcGloballyUniqueId,
    owner_history: Option<EntityRef>,
    name: Option<IfcLabel>,
    description: Option<IfcText>,
    has_properties: HashSet<EntityRef>,
}
impl IIfcRoot for IfcPropertySet {
    fn global_id(&self) -> &IfcGloballyUniqueId {
        &self.global_id
    }
    fn owner_history(&self) -> &Option<EntityRef> {
        &self.owner_history
    }
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
}
impl IIfcPropertyDefinition for IfcPropertySet {}
impl IIfcPropertySetDefinition for IfcPropertySet {}
impl IIfcPropertySet for IfcPropertySet {
    fn has_properties(&self) -> &HashSet<EntityRef> {
        &self.has_properties
    }
}
impl IfcPropertySet {
    pub fn from_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcPropertySet::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.global_id = parameter.into(),
                1usize => {
                    entity.owner_history = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => entity.has_properties = parameter.into(),
                _ => {}
            }
        }
        entity
    }
    pub fn from_own_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcPropertySet::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.has_properties = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcPropertySetDefinition: IIfcPropertyDefinition {}
pub trait IIfcPropertySetTemplate: IIfcPropertyTemplateDefinition {
    fn template_type(&self) -> &Option<IfcPropertySetTemplateTypeEnum>;
    fn applicable_entity(&self) -> &Option<IfcIdentifier>;
    fn has_property_templates(&self) -> &HashSet<EntityRef>;
}
#[derive(Default, Debug)]
pub struct IfcPropertySetTemplate {
    global_id: IfcGloballyUniqueId,
    owner_history: Option<EntityRef>,
    name: Option<IfcLabel>,
    description: Option<IfcText>,
    template_type: Option<IfcPropertySetTemplateTypeEnum>,
    applicable_entity: Option<IfcIdentifier>,
    has_property_templates: HashSet<EntityRef>,
}
impl IIfcRoot for IfcPropertySetTemplate {
    fn global_id(&self) -> &IfcGloballyUniqueId {
        &self.global_id
    }
    fn owner_history(&self) -> &Option<EntityRef> {
        &self.owner_history
    }
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
}
impl IIfcPropertyDefinition for IfcPropertySetTemplate {}
impl IIfcPropertyTemplateDefinition for IfcPropertySetTemplate {}
impl IIfcPropertySetTemplate for IfcPropertySetTemplate {
    fn template_type(&self) -> &Option<IfcPropertySetTemplateTypeEnum> {
        &self.template_type
    }
    fn applicable_entity(&self) -> &Option<IfcIdentifier> {
        &self.applicable_entity
    }
    fn has_property_templates(&self) -> &HashSet<EntityRef> {
        &self.has_property_templates
    }
}
impl IfcPropertySetTemplate {
    pub fn from_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcPropertySetTemplate::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.global_id = parameter.into(),
                1usize => {
                    entity.owner_history = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => {
                    entity.template_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                5usize => {
                    entity.applicable_entity = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                6usize => entity.has_property_templates = parameter.into(),
                _ => {}
            }
        }
        entity
    }
    pub fn from_own_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcPropertySetTemplate::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => {
                    entity.template_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                1usize => {
                    entity.applicable_entity = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => entity.has_property_templates = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcPropertySingleValue: IIfcSimpleProperty {
    fn nominal_value(&self) -> &Option<IfcValue>;
    fn unit(&self) -> &Option<EntityRef>;
}
#[derive(Default, Debug)]
pub struct IfcPropertySingleValue {
    name: IfcIdentifier,
    description: Option<IfcText>,
    nominal_value: Option<IfcValue>,
    unit: Option<EntityRef>,
}
impl IIfcPropertyAbstraction for IfcPropertySingleValue {}
impl IIfcProperty for IfcPropertySingleValue {
    fn name(&self) -> &IfcIdentifier {
        &self.name
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
}
impl IIfcSimpleProperty for IfcPropertySingleValue {}
impl IIfcPropertySingleValue for IfcPropertySingleValue {
    fn nominal_value(&self) -> &Option<IfcValue> {
        &self.nominal_value
    }
    fn unit(&self) -> &Option<EntityRef> {
        &self.unit
    }
}
impl IfcPropertySingleValue {
    pub fn from_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcPropertySingleValue::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => {
                    entity.nominal_value = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.unit = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
    pub fn from_own_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcPropertySingleValue::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => {
                    entity.nominal_value = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                1usize => {
                    entity.unit = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcPropertyTableValue: IIfcSimpleProperty {
    fn defining_values(&self) -> &Option<Vec<IfcValue>>;
    fn defined_values(&self) -> &Option<Vec<IfcValue>>;
    fn expression(&self) -> &Option<IfcText>;
    fn defining_unit(&self) -> &Option<EntityRef>;
    fn defined_unit(&self) -> &Option<EntityRef>;
    fn curve_interpolation(&self) -> &Option<IfcCurveInterpolationEnum>;
}
#[derive(Default, Debug)]
pub struct IfcPropertyTableValue {
    name: IfcIdentifier,
    description: Option<IfcText>,
    defining_values: Option<Vec<IfcValue>>,
    defined_values: Option<Vec<IfcValue>>,
    expression: Option<IfcText>,
    defining_unit: Option<EntityRef>,
    defined_unit: Option<EntityRef>,
    curve_interpolation: Option<IfcCurveInterpolationEnum>,
}
impl IIfcPropertyAbstraction for IfcPropertyTableValue {}
impl IIfcProperty for IfcPropertyTableValue {
    fn name(&self) -> &IfcIdentifier {
        &self.name
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
}
impl IIfcSimpleProperty for IfcPropertyTableValue {}
impl IIfcPropertyTableValue for IfcPropertyTableValue {
    fn defining_values(&self) -> &Option<Vec<IfcValue>> {
        &self.defining_values
    }
    fn defined_values(&self) -> &Option<Vec<IfcValue>> {
        &self.defined_values
    }
    fn expression(&self) -> &Option<IfcText> {
        &self.expression
    }
    fn defining_unit(&self) -> &Option<EntityRef> {
        &self.defining_unit
    }
    fn defined_unit(&self) -> &Option<EntityRef> {
        &self.defined_unit
    }
    fn curve_interpolation(&self) -> &Option<IfcCurveInterpolationEnum> {
        &self.curve_interpolation
    }
}
impl IfcPropertyTableValue {
    pub fn from_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcPropertyTableValue::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => {
                    entity.defining_values = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.defined_values = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => {
                    entity.expression = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                5usize => {
                    entity.defining_unit = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                6usize => {
                    entity.defined_unit = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                7usize => {
                    entity.curve_interpolation = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
    pub fn from_own_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcPropertyTableValue::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => {
                    entity.defining_values = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                1usize => {
                    entity.defined_values = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => {
                    entity.expression = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.defining_unit = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => {
                    entity.defined_unit = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                5usize => {
                    entity.curve_interpolation = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcPropertyTemplate: IIfcPropertyTemplateDefinition {}
pub trait IIfcPropertyTemplateDefinition: IIfcPropertyDefinition {}
pub trait IIfcProtectiveDevice: IIfcFlowController {
    fn predefined_type(&self) -> &Option<IfcProtectiveDeviceTypeEnum>;
}
#[derive(Default, Debug)]
pub struct IfcProtectiveDevice {
    global_id: IfcGloballyUniqueId,
    owner_history: Option<EntityRef>,
    name: Option<IfcLabel>,
    description: Option<IfcText>,
    object_type: Option<IfcLabel>,
    object_placement: Option<EntityRef>,
    representation: Option<EntityRef>,
    tag: Option<IfcIdentifier>,
    predefined_type: Option<IfcProtectiveDeviceTypeEnum>,
}
impl IIfcRoot for IfcProtectiveDevice {
    fn global_id(&self) -> &IfcGloballyUniqueId {
        &self.global_id
    }
    fn owner_history(&self) -> &Option<EntityRef> {
        &self.owner_history
    }
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
}
impl IIfcObjectDefinition for IfcProtectiveDevice {}
impl IIfcObject for IfcProtectiveDevice {
    fn object_type(&self) -> &Option<IfcLabel> {
        &self.object_type
    }
}
impl IIfcProduct for IfcProtectiveDevice {
    fn object_placement(&self) -> &Option<EntityRef> {
        &self.object_placement
    }
    fn representation(&self) -> &Option<EntityRef> {
        &self.representation
    }
}
impl IIfcElement for IfcProtectiveDevice {
    fn tag(&self) -> &Option<IfcIdentifier> {
        &self.tag
    }
}
impl IIfcDistributionElement for IfcProtectiveDevice {}
impl IIfcDistributionFlowElement for IfcProtectiveDevice {}
impl IIfcFlowController for IfcProtectiveDevice {}
impl IIfcProtectiveDevice for IfcProtectiveDevice {
    fn predefined_type(&self) -> &Option<IfcProtectiveDeviceTypeEnum> {
        &self.predefined_type
    }
}
impl IfcProtectiveDevice {
    pub fn from_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcProtectiveDevice::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.global_id = parameter.into(),
                1usize => {
                    entity.owner_history = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => {
                    entity.object_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                5usize => {
                    entity.object_placement = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                6usize => {
                    entity.representation = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                7usize => {
                    entity.tag = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                8usize => {
                    entity.predefined_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
    pub fn from_own_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcProtectiveDevice::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => {
                    entity.predefined_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcProtectiveDeviceTrippingUnit: IIfcDistributionControlElement {
    fn predefined_type(&self) -> &Option<IfcProtectiveDeviceTrippingUnitTypeEnum>;
}
#[derive(Default, Debug)]
pub struct IfcProtectiveDeviceTrippingUnit {
    global_id: IfcGloballyUniqueId,
    owner_history: Option<EntityRef>,
    name: Option<IfcLabel>,
    description: Option<IfcText>,
    object_type: Option<IfcLabel>,
    object_placement: Option<EntityRef>,
    representation: Option<EntityRef>,
    tag: Option<IfcIdentifier>,
    predefined_type: Option<IfcProtectiveDeviceTrippingUnitTypeEnum>,
}
impl IIfcRoot for IfcProtectiveDeviceTrippingUnit {
    fn global_id(&self) -> &IfcGloballyUniqueId {
        &self.global_id
    }
    fn owner_history(&self) -> &Option<EntityRef> {
        &self.owner_history
    }
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
}
impl IIfcObjectDefinition for IfcProtectiveDeviceTrippingUnit {}
impl IIfcObject for IfcProtectiveDeviceTrippingUnit {
    fn object_type(&self) -> &Option<IfcLabel> {
        &self.object_type
    }
}
impl IIfcProduct for IfcProtectiveDeviceTrippingUnit {
    fn object_placement(&self) -> &Option<EntityRef> {
        &self.object_placement
    }
    fn representation(&self) -> &Option<EntityRef> {
        &self.representation
    }
}
impl IIfcElement for IfcProtectiveDeviceTrippingUnit {
    fn tag(&self) -> &Option<IfcIdentifier> {
        &self.tag
    }
}
impl IIfcDistributionElement for IfcProtectiveDeviceTrippingUnit {}
impl IIfcDistributionControlElement for IfcProtectiveDeviceTrippingUnit {}
impl IIfcProtectiveDeviceTrippingUnit for IfcProtectiveDeviceTrippingUnit {
    fn predefined_type(&self) -> &Option<IfcProtectiveDeviceTrippingUnitTypeEnum> {
        &self.predefined_type
    }
}
impl IfcProtectiveDeviceTrippingUnit {
    pub fn from_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcProtectiveDeviceTrippingUnit::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.global_id = parameter.into(),
                1usize => {
                    entity.owner_history = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => {
                    entity.object_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                5usize => {
                    entity.object_placement = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                6usize => {
                    entity.representation = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                7usize => {
                    entity.tag = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                8usize => {
                    entity.predefined_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
    pub fn from_own_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcProtectiveDeviceTrippingUnit::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => {
                    entity.predefined_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcProtectiveDeviceTrippingUnitType: IIfcDistributionControlElementType {
    fn predefined_type(&self) -> &IfcProtectiveDeviceTrippingUnitTypeEnum;
}
#[derive(Default, Debug)]
pub struct IfcProtectiveDeviceTrippingUnitType {
    global_id: IfcGloballyUniqueId,
    owner_history: Option<EntityRef>,
    name: Option<IfcLabel>,
    description: Option<IfcText>,
    applicable_occurrence: Option<IfcIdentifier>,
    has_property_sets: Option<HashSet<EntityRef>>,
    representation_maps: Option<Vec<EntityRef>>,
    tag: Option<IfcLabel>,
    element_type: Option<IfcLabel>,
    predefined_type: IfcProtectiveDeviceTrippingUnitTypeEnum,
}
impl IIfcRoot for IfcProtectiveDeviceTrippingUnitType {
    fn global_id(&self) -> &IfcGloballyUniqueId {
        &self.global_id
    }
    fn owner_history(&self) -> &Option<EntityRef> {
        &self.owner_history
    }
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
}
impl IIfcObjectDefinition for IfcProtectiveDeviceTrippingUnitType {}
impl IIfcTypeObject for IfcProtectiveDeviceTrippingUnitType {
    fn applicable_occurrence(&self) -> &Option<IfcIdentifier> {
        &self.applicable_occurrence
    }
    fn has_property_sets(&self) -> &Option<HashSet<EntityRef>> {
        &self.has_property_sets
    }
}
impl IIfcTypeProduct for IfcProtectiveDeviceTrippingUnitType {
    fn representation_maps(&self) -> &Option<Vec<EntityRef>> {
        &self.representation_maps
    }
    fn tag(&self) -> &Option<IfcLabel> {
        &self.tag
    }
}
impl IIfcElementType for IfcProtectiveDeviceTrippingUnitType {
    fn element_type(&self) -> &Option<IfcLabel> {
        &self.element_type
    }
}
impl IIfcDistributionElementType for IfcProtectiveDeviceTrippingUnitType {}
impl IIfcDistributionControlElementType for IfcProtectiveDeviceTrippingUnitType {}
impl IIfcProtectiveDeviceTrippingUnitType for IfcProtectiveDeviceTrippingUnitType {
    fn predefined_type(&self) -> &IfcProtectiveDeviceTrippingUnitTypeEnum {
        &self.predefined_type
    }
}
impl IfcProtectiveDeviceTrippingUnitType {
    pub fn from_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcProtectiveDeviceTrippingUnitType::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.global_id = parameter.into(),
                1usize => {
                    entity.owner_history = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => {
                    entity.applicable_occurrence = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                5usize => {
                    entity.has_property_sets = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                6usize => {
                    entity.representation_maps = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                7usize => {
                    entity.tag = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                8usize => {
                    entity.element_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                9usize => entity.predefined_type = parameter.into(),
                _ => {}
            }
        }
        entity
    }
    pub fn from_own_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcProtectiveDeviceTrippingUnitType::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.predefined_type = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcProtectiveDeviceType: IIfcFlowControllerType {
    fn predefined_type(&self) -> &IfcProtectiveDeviceTypeEnum;
}
#[derive(Default, Debug)]
pub struct IfcProtectiveDeviceType {
    global_id: IfcGloballyUniqueId,
    owner_history: Option<EntityRef>,
    name: Option<IfcLabel>,
    description: Option<IfcText>,
    applicable_occurrence: Option<IfcIdentifier>,
    has_property_sets: Option<HashSet<EntityRef>>,
    representation_maps: Option<Vec<EntityRef>>,
    tag: Option<IfcLabel>,
    element_type: Option<IfcLabel>,
    predefined_type: IfcProtectiveDeviceTypeEnum,
}
impl IIfcRoot for IfcProtectiveDeviceType {
    fn global_id(&self) -> &IfcGloballyUniqueId {
        &self.global_id
    }
    fn owner_history(&self) -> &Option<EntityRef> {
        &self.owner_history
    }
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
}
impl IIfcObjectDefinition for IfcProtectiveDeviceType {}
impl IIfcTypeObject for IfcProtectiveDeviceType {
    fn applicable_occurrence(&self) -> &Option<IfcIdentifier> {
        &self.applicable_occurrence
    }
    fn has_property_sets(&self) -> &Option<HashSet<EntityRef>> {
        &self.has_property_sets
    }
}
impl IIfcTypeProduct for IfcProtectiveDeviceType {
    fn representation_maps(&self) -> &Option<Vec<EntityRef>> {
        &self.representation_maps
    }
    fn tag(&self) -> &Option<IfcLabel> {
        &self.tag
    }
}
impl IIfcElementType for IfcProtectiveDeviceType {
    fn element_type(&self) -> &Option<IfcLabel> {
        &self.element_type
    }
}
impl IIfcDistributionElementType for IfcProtectiveDeviceType {}
impl IIfcDistributionFlowElementType for IfcProtectiveDeviceType {}
impl IIfcFlowControllerType for IfcProtectiveDeviceType {}
impl IIfcProtectiveDeviceType for IfcProtectiveDeviceType {
    fn predefined_type(&self) -> &IfcProtectiveDeviceTypeEnum {
        &self.predefined_type
    }
}
impl IfcProtectiveDeviceType {
    pub fn from_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcProtectiveDeviceType::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.global_id = parameter.into(),
                1usize => {
                    entity.owner_history = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => {
                    entity.applicable_occurrence = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                5usize => {
                    entity.has_property_sets = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                6usize => {
                    entity.representation_maps = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                7usize => {
                    entity.tag = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                8usize => {
                    entity.element_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                9usize => entity.predefined_type = parameter.into(),
                _ => {}
            }
        }
        entity
    }
    pub fn from_own_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcProtectiveDeviceType::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.predefined_type = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcProxy: IIfcProduct {
    fn proxy_type(&self) -> &IfcObjectTypeEnum;
    fn tag(&self) -> &Option<IfcLabel>;
}
#[derive(Default, Debug)]
pub struct IfcProxy {
    global_id: IfcGloballyUniqueId,
    owner_history: Option<EntityRef>,
    name: Option<IfcLabel>,
    description: Option<IfcText>,
    object_type: Option<IfcLabel>,
    object_placement: Option<EntityRef>,
    representation: Option<EntityRef>,
    proxy_type: IfcObjectTypeEnum,
    tag: Option<IfcLabel>,
}
impl IIfcRoot for IfcProxy {
    fn global_id(&self) -> &IfcGloballyUniqueId {
        &self.global_id
    }
    fn owner_history(&self) -> &Option<EntityRef> {
        &self.owner_history
    }
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
}
impl IIfcObjectDefinition for IfcProxy {}
impl IIfcObject for IfcProxy {
    fn object_type(&self) -> &Option<IfcLabel> {
        &self.object_type
    }
}
impl IIfcProduct for IfcProxy {
    fn object_placement(&self) -> &Option<EntityRef> {
        &self.object_placement
    }
    fn representation(&self) -> &Option<EntityRef> {
        &self.representation
    }
}
impl IIfcProxy for IfcProxy {
    fn proxy_type(&self) -> &IfcObjectTypeEnum {
        &self.proxy_type
    }
    fn tag(&self) -> &Option<IfcLabel> {
        &self.tag
    }
}
impl IfcProxy {
    pub fn from_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcProxy::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.global_id = parameter.into(),
                1usize => {
                    entity.owner_history = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => {
                    entity.object_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                5usize => {
                    entity.object_placement = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                6usize => {
                    entity.representation = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                7usize => entity.proxy_type = parameter.into(),
                8usize => {
                    entity.tag = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
    pub fn from_own_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcProxy::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.proxy_type = parameter.into(),
                1usize => {
                    entity.tag = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcPump: IIfcFlowMovingDevice {
    fn predefined_type(&self) -> &Option<IfcPumpTypeEnum>;
}
#[derive(Default, Debug)]
pub struct IfcPump {
    global_id: IfcGloballyUniqueId,
    owner_history: Option<EntityRef>,
    name: Option<IfcLabel>,
    description: Option<IfcText>,
    object_type: Option<IfcLabel>,
    object_placement: Option<EntityRef>,
    representation: Option<EntityRef>,
    tag: Option<IfcIdentifier>,
    predefined_type: Option<IfcPumpTypeEnum>,
}
impl IIfcRoot for IfcPump {
    fn global_id(&self) -> &IfcGloballyUniqueId {
        &self.global_id
    }
    fn owner_history(&self) -> &Option<EntityRef> {
        &self.owner_history
    }
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
}
impl IIfcObjectDefinition for IfcPump {}
impl IIfcObject for IfcPump {
    fn object_type(&self) -> &Option<IfcLabel> {
        &self.object_type
    }
}
impl IIfcProduct for IfcPump {
    fn object_placement(&self) -> &Option<EntityRef> {
        &self.object_placement
    }
    fn representation(&self) -> &Option<EntityRef> {
        &self.representation
    }
}
impl IIfcElement for IfcPump {
    fn tag(&self) -> &Option<IfcIdentifier> {
        &self.tag
    }
}
impl IIfcDistributionElement for IfcPump {}
impl IIfcDistributionFlowElement for IfcPump {}
impl IIfcFlowMovingDevice for IfcPump {}
impl IIfcPump for IfcPump {
    fn predefined_type(&self) -> &Option<IfcPumpTypeEnum> {
        &self.predefined_type
    }
}
impl IfcPump {
    pub fn from_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcPump::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.global_id = parameter.into(),
                1usize => {
                    entity.owner_history = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => {
                    entity.object_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                5usize => {
                    entity.object_placement = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                6usize => {
                    entity.representation = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                7usize => {
                    entity.tag = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                8usize => {
                    entity.predefined_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
    pub fn from_own_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcPump::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => {
                    entity.predefined_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcPumpType: IIfcFlowMovingDeviceType {
    fn predefined_type(&self) -> &IfcPumpTypeEnum;
}
#[derive(Default, Debug)]
pub struct IfcPumpType {
    global_id: IfcGloballyUniqueId,
    owner_history: Option<EntityRef>,
    name: Option<IfcLabel>,
    description: Option<IfcText>,
    applicable_occurrence: Option<IfcIdentifier>,
    has_property_sets: Option<HashSet<EntityRef>>,
    representation_maps: Option<Vec<EntityRef>>,
    tag: Option<IfcLabel>,
    element_type: Option<IfcLabel>,
    predefined_type: IfcPumpTypeEnum,
}
impl IIfcRoot for IfcPumpType {
    fn global_id(&self) -> &IfcGloballyUniqueId {
        &self.global_id
    }
    fn owner_history(&self) -> &Option<EntityRef> {
        &self.owner_history
    }
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
}
impl IIfcObjectDefinition for IfcPumpType {}
impl IIfcTypeObject for IfcPumpType {
    fn applicable_occurrence(&self) -> &Option<IfcIdentifier> {
        &self.applicable_occurrence
    }
    fn has_property_sets(&self) -> &Option<HashSet<EntityRef>> {
        &self.has_property_sets
    }
}
impl IIfcTypeProduct for IfcPumpType {
    fn representation_maps(&self) -> &Option<Vec<EntityRef>> {
        &self.representation_maps
    }
    fn tag(&self) -> &Option<IfcLabel> {
        &self.tag
    }
}
impl IIfcElementType for IfcPumpType {
    fn element_type(&self) -> &Option<IfcLabel> {
        &self.element_type
    }
}
impl IIfcDistributionElementType for IfcPumpType {}
impl IIfcDistributionFlowElementType for IfcPumpType {}
impl IIfcFlowMovingDeviceType for IfcPumpType {}
impl IIfcPumpType for IfcPumpType {
    fn predefined_type(&self) -> &IfcPumpTypeEnum {
        &self.predefined_type
    }
}
impl IfcPumpType {
    pub fn from_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcPumpType::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.global_id = parameter.into(),
                1usize => {
                    entity.owner_history = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => {
                    entity.applicable_occurrence = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                5usize => {
                    entity.has_property_sets = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                6usize => {
                    entity.representation_maps = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                7usize => {
                    entity.tag = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                8usize => {
                    entity.element_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                9usize => entity.predefined_type = parameter.into(),
                _ => {}
            }
        }
        entity
    }
    pub fn from_own_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcPumpType::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.predefined_type = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcQuantityArea: IIfcPhysicalSimpleQuantity {
    fn area_value(&self) -> &IfcAreaMeasure;
    fn formula(&self) -> &Option<IfcLabel>;
}
#[derive(Default, Debug)]
pub struct IfcQuantityArea {
    name: IfcLabel,
    description: Option<IfcText>,
    unit: Option<EntityRef>,
    area_value: IfcAreaMeasure,
    formula: Option<IfcLabel>,
}
impl IIfcPhysicalQuantity for IfcQuantityArea {
    fn name(&self) -> &IfcLabel {
        &self.name
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
}
impl IIfcPhysicalSimpleQuantity for IfcQuantityArea {
    fn unit(&self) -> &Option<EntityRef> {
        &self.unit
    }
}
impl IIfcQuantityArea for IfcQuantityArea {
    fn area_value(&self) -> &IfcAreaMeasure {
        &self.area_value
    }
    fn formula(&self) -> &Option<IfcLabel> {
        &self.formula
    }
}
impl IfcQuantityArea {
    pub fn from_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcQuantityArea::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => {
                    entity.unit = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => entity.area_value = parameter.into(),
                4usize => {
                    entity.formula = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
    pub fn from_own_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcQuantityArea::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.area_value = parameter.into(),
                1usize => {
                    entity.formula = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcQuantityCount: IIfcPhysicalSimpleQuantity {
    fn count_value(&self) -> &IfcCountMeasure;
    fn formula(&self) -> &Option<IfcLabel>;
}
#[derive(Default, Debug)]
pub struct IfcQuantityCount {
    name: IfcLabel,
    description: Option<IfcText>,
    unit: Option<EntityRef>,
    count_value: IfcCountMeasure,
    formula: Option<IfcLabel>,
}
impl IIfcPhysicalQuantity for IfcQuantityCount {
    fn name(&self) -> &IfcLabel {
        &self.name
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
}
impl IIfcPhysicalSimpleQuantity for IfcQuantityCount {
    fn unit(&self) -> &Option<EntityRef> {
        &self.unit
    }
}
impl IIfcQuantityCount for IfcQuantityCount {
    fn count_value(&self) -> &IfcCountMeasure {
        &self.count_value
    }
    fn formula(&self) -> &Option<IfcLabel> {
        &self.formula
    }
}
impl IfcQuantityCount {
    pub fn from_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcQuantityCount::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => {
                    entity.unit = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => entity.count_value = parameter.into(),
                4usize => {
                    entity.formula = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
    pub fn from_own_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcQuantityCount::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.count_value = parameter.into(),
                1usize => {
                    entity.formula = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcQuantityLength: IIfcPhysicalSimpleQuantity {
    fn length_value(&self) -> &IfcLengthMeasure;
    fn formula(&self) -> &Option<IfcLabel>;
}
#[derive(Default, Debug)]
pub struct IfcQuantityLength {
    name: IfcLabel,
    description: Option<IfcText>,
    unit: Option<EntityRef>,
    length_value: IfcLengthMeasure,
    formula: Option<IfcLabel>,
}
impl IIfcPhysicalQuantity for IfcQuantityLength {
    fn name(&self) -> &IfcLabel {
        &self.name
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
}
impl IIfcPhysicalSimpleQuantity for IfcQuantityLength {
    fn unit(&self) -> &Option<EntityRef> {
        &self.unit
    }
}
impl IIfcQuantityLength for IfcQuantityLength {
    fn length_value(&self) -> &IfcLengthMeasure {
        &self.length_value
    }
    fn formula(&self) -> &Option<IfcLabel> {
        &self.formula
    }
}
impl IfcQuantityLength {
    pub fn from_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcQuantityLength::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => {
                    entity.unit = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => entity.length_value = parameter.into(),
                4usize => {
                    entity.formula = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
    pub fn from_own_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcQuantityLength::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.length_value = parameter.into(),
                1usize => {
                    entity.formula = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcQuantitySet: IIfcPropertySetDefinition {}
pub trait IIfcQuantityTime: IIfcPhysicalSimpleQuantity {
    fn time_value(&self) -> &IfcTimeMeasure;
    fn formula(&self) -> &Option<IfcLabel>;
}
#[derive(Default, Debug)]
pub struct IfcQuantityTime {
    name: IfcLabel,
    description: Option<IfcText>,
    unit: Option<EntityRef>,
    time_value: IfcTimeMeasure,
    formula: Option<IfcLabel>,
}
impl IIfcPhysicalQuantity for IfcQuantityTime {
    fn name(&self) -> &IfcLabel {
        &self.name
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
}
impl IIfcPhysicalSimpleQuantity for IfcQuantityTime {
    fn unit(&self) -> &Option<EntityRef> {
        &self.unit
    }
}
impl IIfcQuantityTime for IfcQuantityTime {
    fn time_value(&self) -> &IfcTimeMeasure {
        &self.time_value
    }
    fn formula(&self) -> &Option<IfcLabel> {
        &self.formula
    }
}
impl IfcQuantityTime {
    pub fn from_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcQuantityTime::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => {
                    entity.unit = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => entity.time_value = parameter.into(),
                4usize => {
                    entity.formula = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
    pub fn from_own_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcQuantityTime::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.time_value = parameter.into(),
                1usize => {
                    entity.formula = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcQuantityVolume: IIfcPhysicalSimpleQuantity {
    fn volume_value(&self) -> &IfcVolumeMeasure;
    fn formula(&self) -> &Option<IfcLabel>;
}
#[derive(Default, Debug)]
pub struct IfcQuantityVolume {
    name: IfcLabel,
    description: Option<IfcText>,
    unit: Option<EntityRef>,
    volume_value: IfcVolumeMeasure,
    formula: Option<IfcLabel>,
}
impl IIfcPhysicalQuantity for IfcQuantityVolume {
    fn name(&self) -> &IfcLabel {
        &self.name
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
}
impl IIfcPhysicalSimpleQuantity for IfcQuantityVolume {
    fn unit(&self) -> &Option<EntityRef> {
        &self.unit
    }
}
impl IIfcQuantityVolume for IfcQuantityVolume {
    fn volume_value(&self) -> &IfcVolumeMeasure {
        &self.volume_value
    }
    fn formula(&self) -> &Option<IfcLabel> {
        &self.formula
    }
}
impl IfcQuantityVolume {
    pub fn from_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcQuantityVolume::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => {
                    entity.unit = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => entity.volume_value = parameter.into(),
                4usize => {
                    entity.formula = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
    pub fn from_own_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcQuantityVolume::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.volume_value = parameter.into(),
                1usize => {
                    entity.formula = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcQuantityWeight: IIfcPhysicalSimpleQuantity {
    fn weight_value(&self) -> &IfcMassMeasure;
    fn formula(&self) -> &Option<IfcLabel>;
}
#[derive(Default, Debug)]
pub struct IfcQuantityWeight {
    name: IfcLabel,
    description: Option<IfcText>,
    unit: Option<EntityRef>,
    weight_value: IfcMassMeasure,
    formula: Option<IfcLabel>,
}
impl IIfcPhysicalQuantity for IfcQuantityWeight {
    fn name(&self) -> &IfcLabel {
        &self.name
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
}
impl IIfcPhysicalSimpleQuantity for IfcQuantityWeight {
    fn unit(&self) -> &Option<EntityRef> {
        &self.unit
    }
}
impl IIfcQuantityWeight for IfcQuantityWeight {
    fn weight_value(&self) -> &IfcMassMeasure {
        &self.weight_value
    }
    fn formula(&self) -> &Option<IfcLabel> {
        &self.formula
    }
}
impl IfcQuantityWeight {
    pub fn from_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcQuantityWeight::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => {
                    entity.unit = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => entity.weight_value = parameter.into(),
                4usize => {
                    entity.formula = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
    pub fn from_own_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcQuantityWeight::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.weight_value = parameter.into(),
                1usize => {
                    entity.formula = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcRailing: IIfcBuildingElement {
    fn predefined_type(&self) -> &Option<IfcRailingTypeEnum>;
}
#[derive(Default, Debug)]
pub struct IfcRailing {
    global_id: IfcGloballyUniqueId,
    owner_history: Option<EntityRef>,
    name: Option<IfcLabel>,
    description: Option<IfcText>,
    object_type: Option<IfcLabel>,
    object_placement: Option<EntityRef>,
    representation: Option<EntityRef>,
    tag: Option<IfcIdentifier>,
    predefined_type: Option<IfcRailingTypeEnum>,
}
impl IIfcRoot for IfcRailing {
    fn global_id(&self) -> &IfcGloballyUniqueId {
        &self.global_id
    }
    fn owner_history(&self) -> &Option<EntityRef> {
        &self.owner_history
    }
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
}
impl IIfcObjectDefinition for IfcRailing {}
impl IIfcObject for IfcRailing {
    fn object_type(&self) -> &Option<IfcLabel> {
        &self.object_type
    }
}
impl IIfcProduct for IfcRailing {
    fn object_placement(&self) -> &Option<EntityRef> {
        &self.object_placement
    }
    fn representation(&self) -> &Option<EntityRef> {
        &self.representation
    }
}
impl IIfcElement for IfcRailing {
    fn tag(&self) -> &Option<IfcIdentifier> {
        &self.tag
    }
}
impl IIfcBuildingElement for IfcRailing {}
impl IIfcRailing for IfcRailing {
    fn predefined_type(&self) -> &Option<IfcRailingTypeEnum> {
        &self.predefined_type
    }
}
impl IfcRailing {
    pub fn from_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcRailing::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.global_id = parameter.into(),
                1usize => {
                    entity.owner_history = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => {
                    entity.object_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                5usize => {
                    entity.object_placement = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                6usize => {
                    entity.representation = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                7usize => {
                    entity.tag = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                8usize => {
                    entity.predefined_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
    pub fn from_own_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcRailing::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => {
                    entity.predefined_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcRailingType: IIfcBuildingElementType {
    fn predefined_type(&self) -> &IfcRailingTypeEnum;
}
#[derive(Default, Debug)]
pub struct IfcRailingType {
    global_id: IfcGloballyUniqueId,
    owner_history: Option<EntityRef>,
    name: Option<IfcLabel>,
    description: Option<IfcText>,
    applicable_occurrence: Option<IfcIdentifier>,
    has_property_sets: Option<HashSet<EntityRef>>,
    representation_maps: Option<Vec<EntityRef>>,
    tag: Option<IfcLabel>,
    element_type: Option<IfcLabel>,
    predefined_type: IfcRailingTypeEnum,
}
impl IIfcRoot for IfcRailingType {
    fn global_id(&self) -> &IfcGloballyUniqueId {
        &self.global_id
    }
    fn owner_history(&self) -> &Option<EntityRef> {
        &self.owner_history
    }
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
}
impl IIfcObjectDefinition for IfcRailingType {}
impl IIfcTypeObject for IfcRailingType {
    fn applicable_occurrence(&self) -> &Option<IfcIdentifier> {
        &self.applicable_occurrence
    }
    fn has_property_sets(&self) -> &Option<HashSet<EntityRef>> {
        &self.has_property_sets
    }
}
impl IIfcTypeProduct for IfcRailingType {
    fn representation_maps(&self) -> &Option<Vec<EntityRef>> {
        &self.representation_maps
    }
    fn tag(&self) -> &Option<IfcLabel> {
        &self.tag
    }
}
impl IIfcElementType for IfcRailingType {
    fn element_type(&self) -> &Option<IfcLabel> {
        &self.element_type
    }
}
impl IIfcBuildingElementType for IfcRailingType {}
impl IIfcRailingType for IfcRailingType {
    fn predefined_type(&self) -> &IfcRailingTypeEnum {
        &self.predefined_type
    }
}
impl IfcRailingType {
    pub fn from_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcRailingType::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.global_id = parameter.into(),
                1usize => {
                    entity.owner_history = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => {
                    entity.applicable_occurrence = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                5usize => {
                    entity.has_property_sets = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                6usize => {
                    entity.representation_maps = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                7usize => {
                    entity.tag = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                8usize => {
                    entity.element_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                9usize => entity.predefined_type = parameter.into(),
                _ => {}
            }
        }
        entity
    }
    pub fn from_own_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcRailingType::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.predefined_type = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcRamp: IIfcBuildingElement {
    fn predefined_type(&self) -> &Option<IfcRampTypeEnum>;
}
#[derive(Default, Debug)]
pub struct IfcRamp {
    global_id: IfcGloballyUniqueId,
    owner_history: Option<EntityRef>,
    name: Option<IfcLabel>,
    description: Option<IfcText>,
    object_type: Option<IfcLabel>,
    object_placement: Option<EntityRef>,
    representation: Option<EntityRef>,
    tag: Option<IfcIdentifier>,
    predefined_type: Option<IfcRampTypeEnum>,
}
impl IIfcRoot for IfcRamp {
    fn global_id(&self) -> &IfcGloballyUniqueId {
        &self.global_id
    }
    fn owner_history(&self) -> &Option<EntityRef> {
        &self.owner_history
    }
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
}
impl IIfcObjectDefinition for IfcRamp {}
impl IIfcObject for IfcRamp {
    fn object_type(&self) -> &Option<IfcLabel> {
        &self.object_type
    }
}
impl IIfcProduct for IfcRamp {
    fn object_placement(&self) -> &Option<EntityRef> {
        &self.object_placement
    }
    fn representation(&self) -> &Option<EntityRef> {
        &self.representation
    }
}
impl IIfcElement for IfcRamp {
    fn tag(&self) -> &Option<IfcIdentifier> {
        &self.tag
    }
}
impl IIfcBuildingElement for IfcRamp {}
impl IIfcRamp for IfcRamp {
    fn predefined_type(&self) -> &Option<IfcRampTypeEnum> {
        &self.predefined_type
    }
}
impl IfcRamp {
    pub fn from_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcRamp::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.global_id = parameter.into(),
                1usize => {
                    entity.owner_history = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => {
                    entity.object_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                5usize => {
                    entity.object_placement = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                6usize => {
                    entity.representation = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                7usize => {
                    entity.tag = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                8usize => {
                    entity.predefined_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
    pub fn from_own_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcRamp::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => {
                    entity.predefined_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcRampFlight: IIfcBuildingElement {
    fn predefined_type(&self) -> &Option<IfcRampFlightTypeEnum>;
}
#[derive(Default, Debug)]
pub struct IfcRampFlight {
    global_id: IfcGloballyUniqueId,
    owner_history: Option<EntityRef>,
    name: Option<IfcLabel>,
    description: Option<IfcText>,
    object_type: Option<IfcLabel>,
    object_placement: Option<EntityRef>,
    representation: Option<EntityRef>,
    tag: Option<IfcIdentifier>,
    predefined_type: Option<IfcRampFlightTypeEnum>,
}
impl IIfcRoot for IfcRampFlight {
    fn global_id(&self) -> &IfcGloballyUniqueId {
        &self.global_id
    }
    fn owner_history(&self) -> &Option<EntityRef> {
        &self.owner_history
    }
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
}
impl IIfcObjectDefinition for IfcRampFlight {}
impl IIfcObject for IfcRampFlight {
    fn object_type(&self) -> &Option<IfcLabel> {
        &self.object_type
    }
}
impl IIfcProduct for IfcRampFlight {
    fn object_placement(&self) -> &Option<EntityRef> {
        &self.object_placement
    }
    fn representation(&self) -> &Option<EntityRef> {
        &self.representation
    }
}
impl IIfcElement for IfcRampFlight {
    fn tag(&self) -> &Option<IfcIdentifier> {
        &self.tag
    }
}
impl IIfcBuildingElement for IfcRampFlight {}
impl IIfcRampFlight for IfcRampFlight {
    fn predefined_type(&self) -> &Option<IfcRampFlightTypeEnum> {
        &self.predefined_type
    }
}
impl IfcRampFlight {
    pub fn from_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcRampFlight::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.global_id = parameter.into(),
                1usize => {
                    entity.owner_history = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => {
                    entity.object_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                5usize => {
                    entity.object_placement = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                6usize => {
                    entity.representation = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                7usize => {
                    entity.tag = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                8usize => {
                    entity.predefined_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
    pub fn from_own_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcRampFlight::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => {
                    entity.predefined_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcRampFlightType: IIfcBuildingElementType {
    fn predefined_type(&self) -> &IfcRampFlightTypeEnum;
}
#[derive(Default, Debug)]
pub struct IfcRampFlightType {
    global_id: IfcGloballyUniqueId,
    owner_history: Option<EntityRef>,
    name: Option<IfcLabel>,
    description: Option<IfcText>,
    applicable_occurrence: Option<IfcIdentifier>,
    has_property_sets: Option<HashSet<EntityRef>>,
    representation_maps: Option<Vec<EntityRef>>,
    tag: Option<IfcLabel>,
    element_type: Option<IfcLabel>,
    predefined_type: IfcRampFlightTypeEnum,
}
impl IIfcRoot for IfcRampFlightType {
    fn global_id(&self) -> &IfcGloballyUniqueId {
        &self.global_id
    }
    fn owner_history(&self) -> &Option<EntityRef> {
        &self.owner_history
    }
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
}
impl IIfcObjectDefinition for IfcRampFlightType {}
impl IIfcTypeObject for IfcRampFlightType {
    fn applicable_occurrence(&self) -> &Option<IfcIdentifier> {
        &self.applicable_occurrence
    }
    fn has_property_sets(&self) -> &Option<HashSet<EntityRef>> {
        &self.has_property_sets
    }
}
impl IIfcTypeProduct for IfcRampFlightType {
    fn representation_maps(&self) -> &Option<Vec<EntityRef>> {
        &self.representation_maps
    }
    fn tag(&self) -> &Option<IfcLabel> {
        &self.tag
    }
}
impl IIfcElementType for IfcRampFlightType {
    fn element_type(&self) -> &Option<IfcLabel> {
        &self.element_type
    }
}
impl IIfcBuildingElementType for IfcRampFlightType {}
impl IIfcRampFlightType for IfcRampFlightType {
    fn predefined_type(&self) -> &IfcRampFlightTypeEnum {
        &self.predefined_type
    }
}
impl IfcRampFlightType {
    pub fn from_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcRampFlightType::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.global_id = parameter.into(),
                1usize => {
                    entity.owner_history = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => {
                    entity.applicable_occurrence = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                5usize => {
                    entity.has_property_sets = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                6usize => {
                    entity.representation_maps = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                7usize => {
                    entity.tag = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                8usize => {
                    entity.element_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                9usize => entity.predefined_type = parameter.into(),
                _ => {}
            }
        }
        entity
    }
    pub fn from_own_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcRampFlightType::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.predefined_type = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcRampType: IIfcBuildingElementType {
    fn predefined_type(&self) -> &IfcRampTypeEnum;
}
#[derive(Default, Debug)]
pub struct IfcRampType {
    global_id: IfcGloballyUniqueId,
    owner_history: Option<EntityRef>,
    name: Option<IfcLabel>,
    description: Option<IfcText>,
    applicable_occurrence: Option<IfcIdentifier>,
    has_property_sets: Option<HashSet<EntityRef>>,
    representation_maps: Option<Vec<EntityRef>>,
    tag: Option<IfcLabel>,
    element_type: Option<IfcLabel>,
    predefined_type: IfcRampTypeEnum,
}
impl IIfcRoot for IfcRampType {
    fn global_id(&self) -> &IfcGloballyUniqueId {
        &self.global_id
    }
    fn owner_history(&self) -> &Option<EntityRef> {
        &self.owner_history
    }
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
}
impl IIfcObjectDefinition for IfcRampType {}
impl IIfcTypeObject for IfcRampType {
    fn applicable_occurrence(&self) -> &Option<IfcIdentifier> {
        &self.applicable_occurrence
    }
    fn has_property_sets(&self) -> &Option<HashSet<EntityRef>> {
        &self.has_property_sets
    }
}
impl IIfcTypeProduct for IfcRampType {
    fn representation_maps(&self) -> &Option<Vec<EntityRef>> {
        &self.representation_maps
    }
    fn tag(&self) -> &Option<IfcLabel> {
        &self.tag
    }
}
impl IIfcElementType for IfcRampType {
    fn element_type(&self) -> &Option<IfcLabel> {
        &self.element_type
    }
}
impl IIfcBuildingElementType for IfcRampType {}
impl IIfcRampType for IfcRampType {
    fn predefined_type(&self) -> &IfcRampTypeEnum {
        &self.predefined_type
    }
}
impl IfcRampType {
    pub fn from_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcRampType::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.global_id = parameter.into(),
                1usize => {
                    entity.owner_history = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => {
                    entity.applicable_occurrence = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                5usize => {
                    entity.has_property_sets = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                6usize => {
                    entity.representation_maps = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                7usize => {
                    entity.tag = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                8usize => {
                    entity.element_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                9usize => entity.predefined_type = parameter.into(),
                _ => {}
            }
        }
        entity
    }
    pub fn from_own_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcRampType::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.predefined_type = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcRationalBSplineCurveWithKnots: IIfcBSplineCurveWithKnots {
    fn weights_data(&self) -> &Vec<IfcReal>;
}
#[derive(Default, Debug)]
pub struct IfcRationalBSplineCurveWithKnots {
    degree: IfcInteger,
    control_points_list: Vec<EntityRef>,
    curve_form: IfcBSplineCurveForm,
    closed_curve: IfcLogical,
    self_intersect: IfcLogical,
    knot_multiplicities: Vec<IfcInteger>,
    knots: Vec<IfcParameterValue>,
    knot_spec: IfcKnotType,
    weights_data: Vec<IfcReal>,
}
impl IIfcRepresentationItem for IfcRationalBSplineCurveWithKnots {}
impl IIfcGeometricRepresentationItem for IfcRationalBSplineCurveWithKnots {}
impl IIfcCurve for IfcRationalBSplineCurveWithKnots {}
impl IIfcBoundedCurve for IfcRationalBSplineCurveWithKnots {}
impl IIfcBSplineCurve for IfcRationalBSplineCurveWithKnots {
    fn degree(&self) -> &IfcInteger {
        &self.degree
    }
    fn control_points_list(&self) -> &Vec<EntityRef> {
        &self.control_points_list
    }
    fn curve_form(&self) -> &IfcBSplineCurveForm {
        &self.curve_form
    }
    fn closed_curve(&self) -> &IfcLogical {
        &self.closed_curve
    }
    fn self_intersect(&self) -> &IfcLogical {
        &self.self_intersect
    }
}
impl IIfcBSplineCurveWithKnots for IfcRationalBSplineCurveWithKnots {
    fn knot_multiplicities(&self) -> &Vec<IfcInteger> {
        &self.knot_multiplicities
    }
    fn knots(&self) -> &Vec<IfcParameterValue> {
        &self.knots
    }
    fn knot_spec(&self) -> &IfcKnotType {
        &self.knot_spec
    }
}
impl IIfcRationalBSplineCurveWithKnots for IfcRationalBSplineCurveWithKnots {
    fn weights_data(&self) -> &Vec<IfcReal> {
        &self.weights_data
    }
}
impl IfcRationalBSplineCurveWithKnots {
    pub fn from_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcRationalBSplineCurveWithKnots::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.degree = parameter.into(),
                1usize => entity.control_points_list = parameter.into(),
                2usize => entity.curve_form = parameter.into(),
                3usize => entity.closed_curve = parameter.into(),
                4usize => entity.self_intersect = parameter.into(),
                5usize => entity.knot_multiplicities = parameter.into(),
                6usize => entity.knots = parameter.into(),
                7usize => entity.knot_spec = parameter.into(),
                8usize => entity.weights_data = parameter.into(),
                _ => {}
            }
        }
        entity
    }
    pub fn from_own_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcRationalBSplineCurveWithKnots::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.weights_data = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcRationalBSplineSurfaceWithKnots: IIfcBSplineSurfaceWithKnots {
    fn weights_data(&self) -> &Vec<Vec<IfcReal>>;
}
#[derive(Default, Debug)]
pub struct IfcRationalBSplineSurfaceWithKnots {
    u_degree: IfcInteger,
    v_degree: IfcInteger,
    control_points_list: Vec<Vec<EntityRef>>,
    surface_form: IfcBSplineSurfaceForm,
    u_closed: IfcLogical,
    v_closed: IfcLogical,
    self_intersect: IfcLogical,
    u_multiplicities: Vec<IfcInteger>,
    v_multiplicities: Vec<IfcInteger>,
    u_knots: Vec<IfcParameterValue>,
    v_knots: Vec<IfcParameterValue>,
    knot_spec: IfcKnotType,
    weights_data: Vec<Vec<IfcReal>>,
}
impl IIfcRepresentationItem for IfcRationalBSplineSurfaceWithKnots {}
impl IIfcGeometricRepresentationItem for IfcRationalBSplineSurfaceWithKnots {}
impl IIfcSurface for IfcRationalBSplineSurfaceWithKnots {}
impl IIfcBoundedSurface for IfcRationalBSplineSurfaceWithKnots {}
impl IIfcBSplineSurface for IfcRationalBSplineSurfaceWithKnots {
    fn u_degree(&self) -> &IfcInteger {
        &self.u_degree
    }
    fn v_degree(&self) -> &IfcInteger {
        &self.v_degree
    }
    fn control_points_list(&self) -> &Vec<Vec<EntityRef>> {
        &self.control_points_list
    }
    fn surface_form(&self) -> &IfcBSplineSurfaceForm {
        &self.surface_form
    }
    fn u_closed(&self) -> &IfcLogical {
        &self.u_closed
    }
    fn v_closed(&self) -> &IfcLogical {
        &self.v_closed
    }
    fn self_intersect(&self) -> &IfcLogical {
        &self.self_intersect
    }
}
impl IIfcBSplineSurfaceWithKnots for IfcRationalBSplineSurfaceWithKnots {
    fn u_multiplicities(&self) -> &Vec<IfcInteger> {
        &self.u_multiplicities
    }
    fn v_multiplicities(&self) -> &Vec<IfcInteger> {
        &self.v_multiplicities
    }
    fn u_knots(&self) -> &Vec<IfcParameterValue> {
        &self.u_knots
    }
    fn v_knots(&self) -> &Vec<IfcParameterValue> {
        &self.v_knots
    }
    fn knot_spec(&self) -> &IfcKnotType {
        &self.knot_spec
    }
}
impl IIfcRationalBSplineSurfaceWithKnots for IfcRationalBSplineSurfaceWithKnots {
    fn weights_data(&self) -> &Vec<Vec<IfcReal>> {
        &self.weights_data
    }
}
impl IfcRationalBSplineSurfaceWithKnots {
    pub fn from_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcRationalBSplineSurfaceWithKnots::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.u_degree = parameter.into(),
                1usize => entity.v_degree = parameter.into(),
                2usize => entity.control_points_list = parameter.into(),
                3usize => entity.surface_form = parameter.into(),
                4usize => entity.u_closed = parameter.into(),
                5usize => entity.v_closed = parameter.into(),
                6usize => entity.self_intersect = parameter.into(),
                7usize => entity.u_multiplicities = parameter.into(),
                8usize => entity.v_multiplicities = parameter.into(),
                9usize => entity.u_knots = parameter.into(),
                10usize => entity.v_knots = parameter.into(),
                11usize => entity.knot_spec = parameter.into(),
                12usize => entity.weights_data = parameter.into(),
                _ => {}
            }
        }
        entity
    }
    pub fn from_own_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcRationalBSplineSurfaceWithKnots::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.weights_data = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcRectangleHollowProfileDef: IIfcRectangleProfileDef {
    fn wall_thickness(&self) -> &IfcPositiveLengthMeasure;
    fn inner_fillet_radius(&self) -> &Option<IfcNonNegativeLengthMeasure>;
    fn outer_fillet_radius(&self) -> &Option<IfcNonNegativeLengthMeasure>;
}
#[derive(Default, Debug)]
pub struct IfcRectangleHollowProfileDef {
    profile_type: IfcProfileTypeEnum,
    profile_name: Option<IfcLabel>,
    position: Option<EntityRef>,
    x_dim: IfcPositiveLengthMeasure,
    y_dim: IfcPositiveLengthMeasure,
    wall_thickness: IfcPositiveLengthMeasure,
    inner_fillet_radius: Option<IfcNonNegativeLengthMeasure>,
    outer_fillet_radius: Option<IfcNonNegativeLengthMeasure>,
}
impl IIfcProfileDef for IfcRectangleHollowProfileDef {
    fn profile_type(&self) -> &IfcProfileTypeEnum {
        &self.profile_type
    }
    fn profile_name(&self) -> &Option<IfcLabel> {
        &self.profile_name
    }
}
impl IIfcParameterizedProfileDef for IfcRectangleHollowProfileDef {
    fn position(&self) -> &Option<EntityRef> {
        &self.position
    }
}
impl IIfcRectangleProfileDef for IfcRectangleHollowProfileDef {
    fn x_dim(&self) -> &IfcPositiveLengthMeasure {
        &self.x_dim
    }
    fn y_dim(&self) -> &IfcPositiveLengthMeasure {
        &self.y_dim
    }
}
impl IIfcRectangleHollowProfileDef for IfcRectangleHollowProfileDef {
    fn wall_thickness(&self) -> &IfcPositiveLengthMeasure {
        &self.wall_thickness
    }
    fn inner_fillet_radius(&self) -> &Option<IfcNonNegativeLengthMeasure> {
        &self.inner_fillet_radius
    }
    fn outer_fillet_radius(&self) -> &Option<IfcNonNegativeLengthMeasure> {
        &self.outer_fillet_radius
    }
}
impl IfcRectangleHollowProfileDef {
    pub fn from_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcRectangleHollowProfileDef::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.profile_type = parameter.into(),
                1usize => {
                    entity.profile_name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => {
                    entity.position = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => entity.x_dim = parameter.into(),
                4usize => entity.y_dim = parameter.into(),
                5usize => entity.wall_thickness = parameter.into(),
                6usize => {
                    entity.inner_fillet_radius = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                7usize => {
                    entity.outer_fillet_radius = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
    pub fn from_own_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcRectangleHollowProfileDef::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.wall_thickness = parameter.into(),
                1usize => {
                    entity.inner_fillet_radius = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => {
                    entity.outer_fillet_radius = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcRectangleProfileDef: IIfcParameterizedProfileDef {
    fn x_dim(&self) -> &IfcPositiveLengthMeasure;
    fn y_dim(&self) -> &IfcPositiveLengthMeasure;
}
#[derive(Default, Debug)]
pub struct IfcRectangleProfileDef {
    profile_type: IfcProfileTypeEnum,
    profile_name: Option<IfcLabel>,
    position: Option<EntityRef>,
    x_dim: IfcPositiveLengthMeasure,
    y_dim: IfcPositiveLengthMeasure,
}
impl IIfcProfileDef for IfcRectangleProfileDef {
    fn profile_type(&self) -> &IfcProfileTypeEnum {
        &self.profile_type
    }
    fn profile_name(&self) -> &Option<IfcLabel> {
        &self.profile_name
    }
}
impl IIfcParameterizedProfileDef for IfcRectangleProfileDef {
    fn position(&self) -> &Option<EntityRef> {
        &self.position
    }
}
impl IIfcRectangleProfileDef for IfcRectangleProfileDef {
    fn x_dim(&self) -> &IfcPositiveLengthMeasure {
        &self.x_dim
    }
    fn y_dim(&self) -> &IfcPositiveLengthMeasure {
        &self.y_dim
    }
}
impl IfcRectangleProfileDef {
    pub fn from_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcRectangleProfileDef::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.profile_type = parameter.into(),
                1usize => {
                    entity.profile_name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => {
                    entity.position = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => entity.x_dim = parameter.into(),
                4usize => entity.y_dim = parameter.into(),
                _ => {}
            }
        }
        entity
    }
    pub fn from_own_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcRectangleProfileDef::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.x_dim = parameter.into(),
                1usize => entity.y_dim = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcRectangularPyramid: IIfcCsgPrimitive3D {
    fn x_length(&self) -> &IfcPositiveLengthMeasure;
    fn y_length(&self) -> &IfcPositiveLengthMeasure;
    fn height(&self) -> &IfcPositiveLengthMeasure;
}
#[derive(Default, Debug)]
pub struct IfcRectangularPyramid {
    position: EntityRef,
    x_length: IfcPositiveLengthMeasure,
    y_length: IfcPositiveLengthMeasure,
    height: IfcPositiveLengthMeasure,
}
impl IIfcRepresentationItem for IfcRectangularPyramid {}
impl IIfcGeometricRepresentationItem for IfcRectangularPyramid {}
impl IIfcCsgPrimitive3D for IfcRectangularPyramid {
    fn position(&self) -> &EntityRef {
        &self.position
    }
}
impl IIfcRectangularPyramid for IfcRectangularPyramid {
    fn x_length(&self) -> &IfcPositiveLengthMeasure {
        &self.x_length
    }
    fn y_length(&self) -> &IfcPositiveLengthMeasure {
        &self.y_length
    }
    fn height(&self) -> &IfcPositiveLengthMeasure {
        &self.height
    }
}
impl IfcRectangularPyramid {
    pub fn from_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcRectangularPyramid::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.position = parameter.into(),
                1usize => entity.x_length = parameter.into(),
                2usize => entity.y_length = parameter.into(),
                3usize => entity.height = parameter.into(),
                _ => {}
            }
        }
        entity
    }
    pub fn from_own_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcRectangularPyramid::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.x_length = parameter.into(),
                1usize => entity.y_length = parameter.into(),
                2usize => entity.height = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcRectangularTrimmedSurface: IIfcBoundedSurface {
    fn basis_surface(&self) -> &EntityRef;
    fn u1(&self) -> &IfcParameterValue;
    fn v1(&self) -> &IfcParameterValue;
    fn u2(&self) -> &IfcParameterValue;
    fn v2(&self) -> &IfcParameterValue;
    fn usense(&self) -> &IfcBoolean;
    fn vsense(&self) -> &IfcBoolean;
}
#[derive(Default, Debug)]
pub struct IfcRectangularTrimmedSurface {
    basis_surface: EntityRef,
    u1: IfcParameterValue,
    v1: IfcParameterValue,
    u2: IfcParameterValue,
    v2: IfcParameterValue,
    usense: IfcBoolean,
    vsense: IfcBoolean,
}
impl IIfcRepresentationItem for IfcRectangularTrimmedSurface {}
impl IIfcGeometricRepresentationItem for IfcRectangularTrimmedSurface {}
impl IIfcSurface for IfcRectangularTrimmedSurface {}
impl IIfcBoundedSurface for IfcRectangularTrimmedSurface {}
impl IIfcRectangularTrimmedSurface for IfcRectangularTrimmedSurface {
    fn basis_surface(&self) -> &EntityRef {
        &self.basis_surface
    }
    fn u1(&self) -> &IfcParameterValue {
        &self.u1
    }
    fn v1(&self) -> &IfcParameterValue {
        &self.v1
    }
    fn u2(&self) -> &IfcParameterValue {
        &self.u2
    }
    fn v2(&self) -> &IfcParameterValue {
        &self.v2
    }
    fn usense(&self) -> &IfcBoolean {
        &self.usense
    }
    fn vsense(&self) -> &IfcBoolean {
        &self.vsense
    }
}
impl IfcRectangularTrimmedSurface {
    pub fn from_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcRectangularTrimmedSurface::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.basis_surface = parameter.into(),
                1usize => entity.u1 = parameter.into(),
                2usize => entity.v1 = parameter.into(),
                3usize => entity.u2 = parameter.into(),
                4usize => entity.v2 = parameter.into(),
                5usize => entity.usense = parameter.into(),
                6usize => entity.vsense = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcRecurrencePattern {
    fn recurrence_type(&self) -> &IfcRecurrenceTypeEnum;
    fn day_component(&self) -> &Option<HashSet<IfcDayInMonthNumber>>;
    fn weekday_component(&self) -> &Option<HashSet<IfcDayInWeekNumber>>;
    fn month_component(&self) -> &Option<HashSet<IfcMonthInYearNumber>>;
    fn position(&self) -> &Option<IfcInteger>;
    fn interval(&self) -> &Option<IfcInteger>;
    fn occurrences(&self) -> &Option<IfcInteger>;
    fn time_periods(&self) -> &Option<Vec<EntityRef>>;
}
#[derive(Default, Debug)]
pub struct IfcRecurrencePattern {
    recurrence_type: IfcRecurrenceTypeEnum,
    day_component: Option<HashSet<IfcDayInMonthNumber>>,
    weekday_component: Option<HashSet<IfcDayInWeekNumber>>,
    month_component: Option<HashSet<IfcMonthInYearNumber>>,
    position: Option<IfcInteger>,
    interval: Option<IfcInteger>,
    occurrences: Option<IfcInteger>,
    time_periods: Option<Vec<EntityRef>>,
}
impl IIfcRecurrencePattern for IfcRecurrencePattern {
    fn recurrence_type(&self) -> &IfcRecurrenceTypeEnum {
        &self.recurrence_type
    }
    fn day_component(&self) -> &Option<HashSet<IfcDayInMonthNumber>> {
        &self.day_component
    }
    fn weekday_component(&self) -> &Option<HashSet<IfcDayInWeekNumber>> {
        &self.weekday_component
    }
    fn month_component(&self) -> &Option<HashSet<IfcMonthInYearNumber>> {
        &self.month_component
    }
    fn position(&self) -> &Option<IfcInteger> {
        &self.position
    }
    fn interval(&self) -> &Option<IfcInteger> {
        &self.interval
    }
    fn occurrences(&self) -> &Option<IfcInteger> {
        &self.occurrences
    }
    fn time_periods(&self) -> &Option<Vec<EntityRef>> {
        &self.time_periods
    }
}
impl IfcRecurrencePattern {
    pub fn from_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcRecurrencePattern::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.recurrence_type = parameter.into(),
                1usize => {
                    entity.day_component = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => {
                    entity.weekday_component = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.month_component = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => {
                    entity.position = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                5usize => {
                    entity.interval = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                6usize => {
                    entity.occurrences = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                7usize => {
                    entity.time_periods = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcReference {
    fn type_identifier(&self) -> &Option<IfcIdentifier>;
    fn attribute_identifier(&self) -> &Option<IfcIdentifier>;
    fn instance_name(&self) -> &Option<IfcLabel>;
    fn list_positions(&self) -> &Option<Vec<IfcInteger>>;
    fn inner_reference(&self) -> &Option<EntityRef>;
}
#[derive(Default, Debug)]
pub struct IfcReference {
    type_identifier: Option<IfcIdentifier>,
    attribute_identifier: Option<IfcIdentifier>,
    instance_name: Option<IfcLabel>,
    list_positions: Option<Vec<IfcInteger>>,
    inner_reference: Option<EntityRef>,
}
impl IIfcReference for IfcReference {
    fn type_identifier(&self) -> &Option<IfcIdentifier> {
        &self.type_identifier
    }
    fn attribute_identifier(&self) -> &Option<IfcIdentifier> {
        &self.attribute_identifier
    }
    fn instance_name(&self) -> &Option<IfcLabel> {
        &self.instance_name
    }
    fn list_positions(&self) -> &Option<Vec<IfcInteger>> {
        &self.list_positions
    }
    fn inner_reference(&self) -> &Option<EntityRef> {
        &self.inner_reference
    }
}
impl IfcReference {
    pub fn from_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcReference::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => {
                    entity.type_identifier = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                1usize => {
                    entity.attribute_identifier = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => {
                    entity.instance_name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.list_positions = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => {
                    entity.inner_reference = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcRegularTimeSeries: IIfcTimeSeries {
    fn time_step(&self) -> &IfcTimeMeasure;
    fn values(&self) -> &Vec<EntityRef>;
}
#[derive(Default, Debug)]
pub struct IfcRegularTimeSeries {
    name: IfcLabel,
    description: Option<IfcText>,
    start_time: IfcDateTime,
    end_time: IfcDateTime,
    time_series_data_type: IfcTimeSeriesDataTypeEnum,
    data_origin: IfcDataOriginEnum,
    user_defined_data_origin: Option<IfcLabel>,
    unit: Option<EntityRef>,
    time_step: IfcTimeMeasure,
    values: Vec<EntityRef>,
}
impl IIfcTimeSeries for IfcRegularTimeSeries {
    fn name(&self) -> &IfcLabel {
        &self.name
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
    fn start_time(&self) -> &IfcDateTime {
        &self.start_time
    }
    fn end_time(&self) -> &IfcDateTime {
        &self.end_time
    }
    fn time_series_data_type(&self) -> &IfcTimeSeriesDataTypeEnum {
        &self.time_series_data_type
    }
    fn data_origin(&self) -> &IfcDataOriginEnum {
        &self.data_origin
    }
    fn user_defined_data_origin(&self) -> &Option<IfcLabel> {
        &self.user_defined_data_origin
    }
    fn unit(&self) -> &Option<EntityRef> {
        &self.unit
    }
}
impl IIfcRegularTimeSeries for IfcRegularTimeSeries {
    fn time_step(&self) -> &IfcTimeMeasure {
        &self.time_step
    }
    fn values(&self) -> &Vec<EntityRef> {
        &self.values
    }
}
impl IfcRegularTimeSeries {
    pub fn from_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcRegularTimeSeries::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => entity.start_time = parameter.into(),
                3usize => entity.end_time = parameter.into(),
                4usize => entity.time_series_data_type = parameter.into(),
                5usize => entity.data_origin = parameter.into(),
                6usize => {
                    entity.user_defined_data_origin = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                7usize => {
                    entity.unit = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                8usize => entity.time_step = parameter.into(),
                9usize => entity.values = parameter.into(),
                _ => {}
            }
        }
        entity
    }
    pub fn from_own_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcRegularTimeSeries::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.time_step = parameter.into(),
                1usize => entity.values = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcReinforcementBarProperties: IIfcPreDefinedProperties {
    fn total_cross_section_area(&self) -> &IfcAreaMeasure;
    fn steel_grade(&self) -> &IfcLabel;
    fn bar_surface(&self) -> &Option<IfcReinforcingBarSurfaceEnum>;
    fn effective_depth(&self) -> &Option<IfcLengthMeasure>;
    fn nominal_bar_diameter(&self) -> &Option<IfcPositiveLengthMeasure>;
    fn bar_count(&self) -> &Option<IfcCountMeasure>;
}
#[derive(Default, Debug)]
pub struct IfcReinforcementBarProperties {
    total_cross_section_area: IfcAreaMeasure,
    steel_grade: IfcLabel,
    bar_surface: Option<IfcReinforcingBarSurfaceEnum>,
    effective_depth: Option<IfcLengthMeasure>,
    nominal_bar_diameter: Option<IfcPositiveLengthMeasure>,
    bar_count: Option<IfcCountMeasure>,
}
impl IIfcPropertyAbstraction for IfcReinforcementBarProperties {}
impl IIfcPreDefinedProperties for IfcReinforcementBarProperties {}
impl IIfcReinforcementBarProperties for IfcReinforcementBarProperties {
    fn total_cross_section_area(&self) -> &IfcAreaMeasure {
        &self.total_cross_section_area
    }
    fn steel_grade(&self) -> &IfcLabel {
        &self.steel_grade
    }
    fn bar_surface(&self) -> &Option<IfcReinforcingBarSurfaceEnum> {
        &self.bar_surface
    }
    fn effective_depth(&self) -> &Option<IfcLengthMeasure> {
        &self.effective_depth
    }
    fn nominal_bar_diameter(&self) -> &Option<IfcPositiveLengthMeasure> {
        &self.nominal_bar_diameter
    }
    fn bar_count(&self) -> &Option<IfcCountMeasure> {
        &self.bar_count
    }
}
impl IfcReinforcementBarProperties {
    pub fn from_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcReinforcementBarProperties::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.total_cross_section_area = parameter.into(),
                1usize => entity.steel_grade = parameter.into(),
                2usize => {
                    entity.bar_surface = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.effective_depth = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => {
                    entity.nominal_bar_diameter = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                5usize => {
                    entity.bar_count = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcReinforcementDefinitionProperties: IIfcPreDefinedPropertySet {
    fn definition_type(&self) -> &Option<IfcLabel>;
    fn reinforcement_section_definitions(&self) -> &Vec<EntityRef>;
}
#[derive(Default, Debug)]
pub struct IfcReinforcementDefinitionProperties {
    global_id: IfcGloballyUniqueId,
    owner_history: Option<EntityRef>,
    name: Option<IfcLabel>,
    description: Option<IfcText>,
    definition_type: Option<IfcLabel>,
    reinforcement_section_definitions: Vec<EntityRef>,
}
impl IIfcRoot for IfcReinforcementDefinitionProperties {
    fn global_id(&self) -> &IfcGloballyUniqueId {
        &self.global_id
    }
    fn owner_history(&self) -> &Option<EntityRef> {
        &self.owner_history
    }
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
}
impl IIfcPropertyDefinition for IfcReinforcementDefinitionProperties {}
impl IIfcPropertySetDefinition for IfcReinforcementDefinitionProperties {}
impl IIfcPreDefinedPropertySet for IfcReinforcementDefinitionProperties {}
impl IIfcReinforcementDefinitionProperties for IfcReinforcementDefinitionProperties {
    fn definition_type(&self) -> &Option<IfcLabel> {
        &self.definition_type
    }
    fn reinforcement_section_definitions(&self) -> &Vec<EntityRef> {
        &self.reinforcement_section_definitions
    }
}
impl IfcReinforcementDefinitionProperties {
    pub fn from_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcReinforcementDefinitionProperties::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.global_id = parameter.into(),
                1usize => {
                    entity.owner_history = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => {
                    entity.definition_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                5usize => entity.reinforcement_section_definitions = parameter.into(),
                _ => {}
            }
        }
        entity
    }
    pub fn from_own_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcReinforcementDefinitionProperties::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => {
                    entity.definition_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                1usize => entity.reinforcement_section_definitions = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcReinforcingBar: IIfcReinforcingElement {
    fn nominal_diameter(&self) -> &Option<IfcPositiveLengthMeasure>;
    fn cross_section_area(&self) -> &Option<IfcAreaMeasure>;
    fn bar_length(&self) -> &Option<IfcPositiveLengthMeasure>;
    fn predefined_type(&self) -> &Option<IfcReinforcingBarTypeEnum>;
    fn bar_surface(&self) -> &Option<IfcReinforcingBarSurfaceEnum>;
}
#[derive(Default, Debug)]
pub struct IfcReinforcingBar {
    global_id: IfcGloballyUniqueId,
    owner_history: Option<EntityRef>,
    name: Option<IfcLabel>,
    description: Option<IfcText>,
    object_type: Option<IfcLabel>,
    object_placement: Option<EntityRef>,
    representation: Option<EntityRef>,
    tag: Option<IfcIdentifier>,
    steel_grade: Option<IfcLabel>,
    nominal_diameter: Option<IfcPositiveLengthMeasure>,
    cross_section_area: Option<IfcAreaMeasure>,
    bar_length: Option<IfcPositiveLengthMeasure>,
    predefined_type: Option<IfcReinforcingBarTypeEnum>,
    bar_surface: Option<IfcReinforcingBarSurfaceEnum>,
}
impl IIfcRoot for IfcReinforcingBar {
    fn global_id(&self) -> &IfcGloballyUniqueId {
        &self.global_id
    }
    fn owner_history(&self) -> &Option<EntityRef> {
        &self.owner_history
    }
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
}
impl IIfcObjectDefinition for IfcReinforcingBar {}
impl IIfcObject for IfcReinforcingBar {
    fn object_type(&self) -> &Option<IfcLabel> {
        &self.object_type
    }
}
impl IIfcProduct for IfcReinforcingBar {
    fn object_placement(&self) -> &Option<EntityRef> {
        &self.object_placement
    }
    fn representation(&self) -> &Option<EntityRef> {
        &self.representation
    }
}
impl IIfcElement for IfcReinforcingBar {
    fn tag(&self) -> &Option<IfcIdentifier> {
        &self.tag
    }
}
impl IIfcElementComponent for IfcReinforcingBar {}
impl IIfcReinforcingElement for IfcReinforcingBar {
    fn steel_grade(&self) -> &Option<IfcLabel> {
        &self.steel_grade
    }
}
impl IIfcReinforcingBar for IfcReinforcingBar {
    fn nominal_diameter(&self) -> &Option<IfcPositiveLengthMeasure> {
        &self.nominal_diameter
    }
    fn cross_section_area(&self) -> &Option<IfcAreaMeasure> {
        &self.cross_section_area
    }
    fn bar_length(&self) -> &Option<IfcPositiveLengthMeasure> {
        &self.bar_length
    }
    fn predefined_type(&self) -> &Option<IfcReinforcingBarTypeEnum> {
        &self.predefined_type
    }
    fn bar_surface(&self) -> &Option<IfcReinforcingBarSurfaceEnum> {
        &self.bar_surface
    }
}
impl IfcReinforcingBar {
    pub fn from_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcReinforcingBar::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.global_id = parameter.into(),
                1usize => {
                    entity.owner_history = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => {
                    entity.object_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                5usize => {
                    entity.object_placement = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                6usize => {
                    entity.representation = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                7usize => {
                    entity.tag = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                8usize => {
                    entity.steel_grade = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                9usize => {
                    entity.nominal_diameter = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                10usize => {
                    entity.cross_section_area = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                11usize => {
                    entity.bar_length = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                12usize => {
                    entity.predefined_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                13usize => {
                    entity.bar_surface = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
    pub fn from_own_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcReinforcingBar::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => {
                    entity.nominal_diameter = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                1usize => {
                    entity.cross_section_area = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => {
                    entity.bar_length = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.predefined_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => {
                    entity.bar_surface = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcReinforcingBarType: IIfcReinforcingElementType {
    fn predefined_type(&self) -> &IfcReinforcingBarTypeEnum;
    fn nominal_diameter(&self) -> &Option<IfcPositiveLengthMeasure>;
    fn cross_section_area(&self) -> &Option<IfcAreaMeasure>;
    fn bar_length(&self) -> &Option<IfcPositiveLengthMeasure>;
    fn bar_surface(&self) -> &Option<IfcReinforcingBarSurfaceEnum>;
    fn bending_shape_code(&self) -> &Option<IfcLabel>;
    fn bending_parameters(&self) -> &Option<Vec<IfcBendingParameterSelect>>;
}
#[derive(Default, Debug)]
pub struct IfcReinforcingBarType {
    global_id: IfcGloballyUniqueId,
    owner_history: Option<EntityRef>,
    name: Option<IfcLabel>,
    description: Option<IfcText>,
    applicable_occurrence: Option<IfcIdentifier>,
    has_property_sets: Option<HashSet<EntityRef>>,
    representation_maps: Option<Vec<EntityRef>>,
    tag: Option<IfcLabel>,
    element_type: Option<IfcLabel>,
    predefined_type: IfcReinforcingBarTypeEnum,
    nominal_diameter: Option<IfcPositiveLengthMeasure>,
    cross_section_area: Option<IfcAreaMeasure>,
    bar_length: Option<IfcPositiveLengthMeasure>,
    bar_surface: Option<IfcReinforcingBarSurfaceEnum>,
    bending_shape_code: Option<IfcLabel>,
    bending_parameters: Option<Vec<IfcBendingParameterSelect>>,
}
impl IIfcRoot for IfcReinforcingBarType {
    fn global_id(&self) -> &IfcGloballyUniqueId {
        &self.global_id
    }
    fn owner_history(&self) -> &Option<EntityRef> {
        &self.owner_history
    }
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
}
impl IIfcObjectDefinition for IfcReinforcingBarType {}
impl IIfcTypeObject for IfcReinforcingBarType {
    fn applicable_occurrence(&self) -> &Option<IfcIdentifier> {
        &self.applicable_occurrence
    }
    fn has_property_sets(&self) -> &Option<HashSet<EntityRef>> {
        &self.has_property_sets
    }
}
impl IIfcTypeProduct for IfcReinforcingBarType {
    fn representation_maps(&self) -> &Option<Vec<EntityRef>> {
        &self.representation_maps
    }
    fn tag(&self) -> &Option<IfcLabel> {
        &self.tag
    }
}
impl IIfcElementType for IfcReinforcingBarType {
    fn element_type(&self) -> &Option<IfcLabel> {
        &self.element_type
    }
}
impl IIfcElementComponentType for IfcReinforcingBarType {}
impl IIfcReinforcingElementType for IfcReinforcingBarType {}
impl IIfcReinforcingBarType for IfcReinforcingBarType {
    fn predefined_type(&self) -> &IfcReinforcingBarTypeEnum {
        &self.predefined_type
    }
    fn nominal_diameter(&self) -> &Option<IfcPositiveLengthMeasure> {
        &self.nominal_diameter
    }
    fn cross_section_area(&self) -> &Option<IfcAreaMeasure> {
        &self.cross_section_area
    }
    fn bar_length(&self) -> &Option<IfcPositiveLengthMeasure> {
        &self.bar_length
    }
    fn bar_surface(&self) -> &Option<IfcReinforcingBarSurfaceEnum> {
        &self.bar_surface
    }
    fn bending_shape_code(&self) -> &Option<IfcLabel> {
        &self.bending_shape_code
    }
    fn bending_parameters(&self) -> &Option<Vec<IfcBendingParameterSelect>> {
        &self.bending_parameters
    }
}
impl IfcReinforcingBarType {
    pub fn from_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcReinforcingBarType::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.global_id = parameter.into(),
                1usize => {
                    entity.owner_history = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => {
                    entity.applicable_occurrence = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                5usize => {
                    entity.has_property_sets = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                6usize => {
                    entity.representation_maps = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                7usize => {
                    entity.tag = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                8usize => {
                    entity.element_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                9usize => entity.predefined_type = parameter.into(),
                10usize => {
                    entity.nominal_diameter = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                11usize => {
                    entity.cross_section_area = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                12usize => {
                    entity.bar_length = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                13usize => {
                    entity.bar_surface = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                14usize => {
                    entity.bending_shape_code = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                15usize => {
                    entity.bending_parameters = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
    pub fn from_own_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcReinforcingBarType::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.predefined_type = parameter.into(),
                1usize => {
                    entity.nominal_diameter = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => {
                    entity.cross_section_area = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.bar_length = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => {
                    entity.bar_surface = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                5usize => {
                    entity.bending_shape_code = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                6usize => {
                    entity.bending_parameters = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcReinforcingElement: IIfcElementComponent {
    fn steel_grade(&self) -> &Option<IfcLabel>;
}
pub trait IIfcReinforcingElementType: IIfcElementComponentType {}
pub trait IIfcReinforcingMesh: IIfcReinforcingElement {
    fn mesh_length(&self) -> &Option<IfcPositiveLengthMeasure>;
    fn mesh_width(&self) -> &Option<IfcPositiveLengthMeasure>;
    fn longitudinal_bar_nominal_diameter(&self) -> &Option<IfcPositiveLengthMeasure>;
    fn transverse_bar_nominal_diameter(&self) -> &Option<IfcPositiveLengthMeasure>;
    fn longitudinal_bar_cross_section_area(&self) -> &Option<IfcAreaMeasure>;
    fn transverse_bar_cross_section_area(&self) -> &Option<IfcAreaMeasure>;
    fn longitudinal_bar_spacing(&self) -> &Option<IfcPositiveLengthMeasure>;
    fn transverse_bar_spacing(&self) -> &Option<IfcPositiveLengthMeasure>;
    fn predefined_type(&self) -> &Option<IfcReinforcingMeshTypeEnum>;
}
#[derive(Default, Debug)]
pub struct IfcReinforcingMesh {
    global_id: IfcGloballyUniqueId,
    owner_history: Option<EntityRef>,
    name: Option<IfcLabel>,
    description: Option<IfcText>,
    object_type: Option<IfcLabel>,
    object_placement: Option<EntityRef>,
    representation: Option<EntityRef>,
    tag: Option<IfcIdentifier>,
    steel_grade: Option<IfcLabel>,
    mesh_length: Option<IfcPositiveLengthMeasure>,
    mesh_width: Option<IfcPositiveLengthMeasure>,
    longitudinal_bar_nominal_diameter: Option<IfcPositiveLengthMeasure>,
    transverse_bar_nominal_diameter: Option<IfcPositiveLengthMeasure>,
    longitudinal_bar_cross_section_area: Option<IfcAreaMeasure>,
    transverse_bar_cross_section_area: Option<IfcAreaMeasure>,
    longitudinal_bar_spacing: Option<IfcPositiveLengthMeasure>,
    transverse_bar_spacing: Option<IfcPositiveLengthMeasure>,
    predefined_type: Option<IfcReinforcingMeshTypeEnum>,
}
impl IIfcRoot for IfcReinforcingMesh {
    fn global_id(&self) -> &IfcGloballyUniqueId {
        &self.global_id
    }
    fn owner_history(&self) -> &Option<EntityRef> {
        &self.owner_history
    }
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
}
impl IIfcObjectDefinition for IfcReinforcingMesh {}
impl IIfcObject for IfcReinforcingMesh {
    fn object_type(&self) -> &Option<IfcLabel> {
        &self.object_type
    }
}
impl IIfcProduct for IfcReinforcingMesh {
    fn object_placement(&self) -> &Option<EntityRef> {
        &self.object_placement
    }
    fn representation(&self) -> &Option<EntityRef> {
        &self.representation
    }
}
impl IIfcElement for IfcReinforcingMesh {
    fn tag(&self) -> &Option<IfcIdentifier> {
        &self.tag
    }
}
impl IIfcElementComponent for IfcReinforcingMesh {}
impl IIfcReinforcingElement for IfcReinforcingMesh {
    fn steel_grade(&self) -> &Option<IfcLabel> {
        &self.steel_grade
    }
}
impl IIfcReinforcingMesh for IfcReinforcingMesh {
    fn mesh_length(&self) -> &Option<IfcPositiveLengthMeasure> {
        &self.mesh_length
    }
    fn mesh_width(&self) -> &Option<IfcPositiveLengthMeasure> {
        &self.mesh_width
    }
    fn longitudinal_bar_nominal_diameter(&self) -> &Option<IfcPositiveLengthMeasure> {
        &self.longitudinal_bar_nominal_diameter
    }
    fn transverse_bar_nominal_diameter(&self) -> &Option<IfcPositiveLengthMeasure> {
        &self.transverse_bar_nominal_diameter
    }
    fn longitudinal_bar_cross_section_area(&self) -> &Option<IfcAreaMeasure> {
        &self.longitudinal_bar_cross_section_area
    }
    fn transverse_bar_cross_section_area(&self) -> &Option<IfcAreaMeasure> {
        &self.transverse_bar_cross_section_area
    }
    fn longitudinal_bar_spacing(&self) -> &Option<IfcPositiveLengthMeasure> {
        &self.longitudinal_bar_spacing
    }
    fn transverse_bar_spacing(&self) -> &Option<IfcPositiveLengthMeasure> {
        &self.transverse_bar_spacing
    }
    fn predefined_type(&self) -> &Option<IfcReinforcingMeshTypeEnum> {
        &self.predefined_type
    }
}
impl IfcReinforcingMesh {
    pub fn from_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcReinforcingMesh::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.global_id = parameter.into(),
                1usize => {
                    entity.owner_history = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => {
                    entity.object_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                5usize => {
                    entity.object_placement = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                6usize => {
                    entity.representation = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                7usize => {
                    entity.tag = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                8usize => {
                    entity.steel_grade = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                9usize => {
                    entity.mesh_length = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                10usize => {
                    entity.mesh_width = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                11usize => {
                    entity.longitudinal_bar_nominal_diameter = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                12usize => {
                    entity.transverse_bar_nominal_diameter = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                13usize => {
                    entity.longitudinal_bar_cross_section_area = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                14usize => {
                    entity.transverse_bar_cross_section_area = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                15usize => {
                    entity.longitudinal_bar_spacing = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                16usize => {
                    entity.transverse_bar_spacing = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                17usize => {
                    entity.predefined_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
    pub fn from_own_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcReinforcingMesh::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => {
                    entity.mesh_length = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                1usize => {
                    entity.mesh_width = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => {
                    entity.longitudinal_bar_nominal_diameter = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.transverse_bar_nominal_diameter = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => {
                    entity.longitudinal_bar_cross_section_area = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                5usize => {
                    entity.transverse_bar_cross_section_area = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                6usize => {
                    entity.longitudinal_bar_spacing = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                7usize => {
                    entity.transverse_bar_spacing = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                8usize => {
                    entity.predefined_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcReinforcingMeshType: IIfcReinforcingElementType {
    fn predefined_type(&self) -> &IfcReinforcingMeshTypeEnum;
    fn mesh_length(&self) -> &Option<IfcPositiveLengthMeasure>;
    fn mesh_width(&self) -> &Option<IfcPositiveLengthMeasure>;
    fn longitudinal_bar_nominal_diameter(&self) -> &Option<IfcPositiveLengthMeasure>;
    fn transverse_bar_nominal_diameter(&self) -> &Option<IfcPositiveLengthMeasure>;
    fn longitudinal_bar_cross_section_area(&self) -> &Option<IfcAreaMeasure>;
    fn transverse_bar_cross_section_area(&self) -> &Option<IfcAreaMeasure>;
    fn longitudinal_bar_spacing(&self) -> &Option<IfcPositiveLengthMeasure>;
    fn transverse_bar_spacing(&self) -> &Option<IfcPositiveLengthMeasure>;
    fn bending_shape_code(&self) -> &Option<IfcLabel>;
    fn bending_parameters(&self) -> &Option<Vec<IfcBendingParameterSelect>>;
}
#[derive(Default, Debug)]
pub struct IfcReinforcingMeshType {
    global_id: IfcGloballyUniqueId,
    owner_history: Option<EntityRef>,
    name: Option<IfcLabel>,
    description: Option<IfcText>,
    applicable_occurrence: Option<IfcIdentifier>,
    has_property_sets: Option<HashSet<EntityRef>>,
    representation_maps: Option<Vec<EntityRef>>,
    tag: Option<IfcLabel>,
    element_type: Option<IfcLabel>,
    predefined_type: IfcReinforcingMeshTypeEnum,
    mesh_length: Option<IfcPositiveLengthMeasure>,
    mesh_width: Option<IfcPositiveLengthMeasure>,
    longitudinal_bar_nominal_diameter: Option<IfcPositiveLengthMeasure>,
    transverse_bar_nominal_diameter: Option<IfcPositiveLengthMeasure>,
    longitudinal_bar_cross_section_area: Option<IfcAreaMeasure>,
    transverse_bar_cross_section_area: Option<IfcAreaMeasure>,
    longitudinal_bar_spacing: Option<IfcPositiveLengthMeasure>,
    transverse_bar_spacing: Option<IfcPositiveLengthMeasure>,
    bending_shape_code: Option<IfcLabel>,
    bending_parameters: Option<Vec<IfcBendingParameterSelect>>,
}
impl IIfcRoot for IfcReinforcingMeshType {
    fn global_id(&self) -> &IfcGloballyUniqueId {
        &self.global_id
    }
    fn owner_history(&self) -> &Option<EntityRef> {
        &self.owner_history
    }
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
}
impl IIfcObjectDefinition for IfcReinforcingMeshType {}
impl IIfcTypeObject for IfcReinforcingMeshType {
    fn applicable_occurrence(&self) -> &Option<IfcIdentifier> {
        &self.applicable_occurrence
    }
    fn has_property_sets(&self) -> &Option<HashSet<EntityRef>> {
        &self.has_property_sets
    }
}
impl IIfcTypeProduct for IfcReinforcingMeshType {
    fn representation_maps(&self) -> &Option<Vec<EntityRef>> {
        &self.representation_maps
    }
    fn tag(&self) -> &Option<IfcLabel> {
        &self.tag
    }
}
impl IIfcElementType for IfcReinforcingMeshType {
    fn element_type(&self) -> &Option<IfcLabel> {
        &self.element_type
    }
}
impl IIfcElementComponentType for IfcReinforcingMeshType {}
impl IIfcReinforcingElementType for IfcReinforcingMeshType {}
impl IIfcReinforcingMeshType for IfcReinforcingMeshType {
    fn predefined_type(&self) -> &IfcReinforcingMeshTypeEnum {
        &self.predefined_type
    }
    fn mesh_length(&self) -> &Option<IfcPositiveLengthMeasure> {
        &self.mesh_length
    }
    fn mesh_width(&self) -> &Option<IfcPositiveLengthMeasure> {
        &self.mesh_width
    }
    fn longitudinal_bar_nominal_diameter(&self) -> &Option<IfcPositiveLengthMeasure> {
        &self.longitudinal_bar_nominal_diameter
    }
    fn transverse_bar_nominal_diameter(&self) -> &Option<IfcPositiveLengthMeasure> {
        &self.transverse_bar_nominal_diameter
    }
    fn longitudinal_bar_cross_section_area(&self) -> &Option<IfcAreaMeasure> {
        &self.longitudinal_bar_cross_section_area
    }
    fn transverse_bar_cross_section_area(&self) -> &Option<IfcAreaMeasure> {
        &self.transverse_bar_cross_section_area
    }
    fn longitudinal_bar_spacing(&self) -> &Option<IfcPositiveLengthMeasure> {
        &self.longitudinal_bar_spacing
    }
    fn transverse_bar_spacing(&self) -> &Option<IfcPositiveLengthMeasure> {
        &self.transverse_bar_spacing
    }
    fn bending_shape_code(&self) -> &Option<IfcLabel> {
        &self.bending_shape_code
    }
    fn bending_parameters(&self) -> &Option<Vec<IfcBendingParameterSelect>> {
        &self.bending_parameters
    }
}
impl IfcReinforcingMeshType {
    pub fn from_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcReinforcingMeshType::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.global_id = parameter.into(),
                1usize => {
                    entity.owner_history = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => {
                    entity.applicable_occurrence = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                5usize => {
                    entity.has_property_sets = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                6usize => {
                    entity.representation_maps = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                7usize => {
                    entity.tag = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                8usize => {
                    entity.element_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                9usize => entity.predefined_type = parameter.into(),
                10usize => {
                    entity.mesh_length = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                11usize => {
                    entity.mesh_width = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                12usize => {
                    entity.longitudinal_bar_nominal_diameter = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                13usize => {
                    entity.transverse_bar_nominal_diameter = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                14usize => {
                    entity.longitudinal_bar_cross_section_area = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                15usize => {
                    entity.transverse_bar_cross_section_area = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                16usize => {
                    entity.longitudinal_bar_spacing = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                17usize => {
                    entity.transverse_bar_spacing = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                18usize => {
                    entity.bending_shape_code = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                19usize => {
                    entity.bending_parameters = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
    pub fn from_own_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcReinforcingMeshType::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.predefined_type = parameter.into(),
                1usize => {
                    entity.mesh_length = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => {
                    entity.mesh_width = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.longitudinal_bar_nominal_diameter = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => {
                    entity.transverse_bar_nominal_diameter = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                5usize => {
                    entity.longitudinal_bar_cross_section_area = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                6usize => {
                    entity.transverse_bar_cross_section_area = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                7usize => {
                    entity.longitudinal_bar_spacing = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                8usize => {
                    entity.transverse_bar_spacing = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                9usize => {
                    entity.bending_shape_code = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                10usize => {
                    entity.bending_parameters = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcRelAggregates: IIfcRelDecomposes {
    fn relating_object(&self) -> &EntityRef;
    fn related_objects(&self) -> &HashSet<EntityRef>;
}
#[derive(Default, Debug)]
pub struct IfcRelAggregates {
    global_id: IfcGloballyUniqueId,
    owner_history: Option<EntityRef>,
    name: Option<IfcLabel>,
    description: Option<IfcText>,
    relating_object: EntityRef,
    related_objects: HashSet<EntityRef>,
}
impl IIfcRoot for IfcRelAggregates {
    fn global_id(&self) -> &IfcGloballyUniqueId {
        &self.global_id
    }
    fn owner_history(&self) -> &Option<EntityRef> {
        &self.owner_history
    }
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
}
impl IIfcRelationship for IfcRelAggregates {}
impl IIfcRelDecomposes for IfcRelAggregates {}
impl IIfcRelAggregates for IfcRelAggregates {
    fn relating_object(&self) -> &EntityRef {
        &self.relating_object
    }
    fn related_objects(&self) -> &HashSet<EntityRef> {
        &self.related_objects
    }
}
impl IfcRelAggregates {
    pub fn from_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcRelAggregates::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.global_id = parameter.into(),
                1usize => {
                    entity.owner_history = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => entity.relating_object = parameter.into(),
                5usize => entity.related_objects = parameter.into(),
                _ => {}
            }
        }
        entity
    }
    pub fn from_own_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcRelAggregates::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.relating_object = parameter.into(),
                1usize => entity.related_objects = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcRelAssigns: IIfcRelationship {
    fn related_objects(&self) -> &HashSet<EntityRef>;
    fn related_objects_type(&self) -> &Option<IfcObjectTypeEnum>;
}
pub trait IIfcRelAssignsToActor: IIfcRelAssigns {
    fn relating_actor(&self) -> &EntityRef;
    fn acting_role(&self) -> &Option<EntityRef>;
}
#[derive(Default, Debug)]
pub struct IfcRelAssignsToActor {
    global_id: IfcGloballyUniqueId,
    owner_history: Option<EntityRef>,
    name: Option<IfcLabel>,
    description: Option<IfcText>,
    related_objects: HashSet<EntityRef>,
    related_objects_type: Option<IfcObjectTypeEnum>,
    relating_actor: EntityRef,
    acting_role: Option<EntityRef>,
}
impl IIfcRoot for IfcRelAssignsToActor {
    fn global_id(&self) -> &IfcGloballyUniqueId {
        &self.global_id
    }
    fn owner_history(&self) -> &Option<EntityRef> {
        &self.owner_history
    }
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
}
impl IIfcRelationship for IfcRelAssignsToActor {}
impl IIfcRelAssigns for IfcRelAssignsToActor {
    fn related_objects(&self) -> &HashSet<EntityRef> {
        &self.related_objects
    }
    fn related_objects_type(&self) -> &Option<IfcObjectTypeEnum> {
        &self.related_objects_type
    }
}
impl IIfcRelAssignsToActor for IfcRelAssignsToActor {
    fn relating_actor(&self) -> &EntityRef {
        &self.relating_actor
    }
    fn acting_role(&self) -> &Option<EntityRef> {
        &self.acting_role
    }
}
impl IfcRelAssignsToActor {
    pub fn from_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcRelAssignsToActor::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.global_id = parameter.into(),
                1usize => {
                    entity.owner_history = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => entity.related_objects = parameter.into(),
                5usize => {
                    entity.related_objects_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                6usize => entity.relating_actor = parameter.into(),
                7usize => {
                    entity.acting_role = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
    pub fn from_own_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcRelAssignsToActor::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.relating_actor = parameter.into(),
                1usize => {
                    entity.acting_role = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcRelAssignsToControl: IIfcRelAssigns {
    fn relating_control(&self) -> &EntityRef;
}
#[derive(Default, Debug)]
pub struct IfcRelAssignsToControl {
    global_id: IfcGloballyUniqueId,
    owner_history: Option<EntityRef>,
    name: Option<IfcLabel>,
    description: Option<IfcText>,
    related_objects: HashSet<EntityRef>,
    related_objects_type: Option<IfcObjectTypeEnum>,
    relating_control: EntityRef,
}
impl IIfcRoot for IfcRelAssignsToControl {
    fn global_id(&self) -> &IfcGloballyUniqueId {
        &self.global_id
    }
    fn owner_history(&self) -> &Option<EntityRef> {
        &self.owner_history
    }
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
}
impl IIfcRelationship for IfcRelAssignsToControl {}
impl IIfcRelAssigns for IfcRelAssignsToControl {
    fn related_objects(&self) -> &HashSet<EntityRef> {
        &self.related_objects
    }
    fn related_objects_type(&self) -> &Option<IfcObjectTypeEnum> {
        &self.related_objects_type
    }
}
impl IIfcRelAssignsToControl for IfcRelAssignsToControl {
    fn relating_control(&self) -> &EntityRef {
        &self.relating_control
    }
}
impl IfcRelAssignsToControl {
    pub fn from_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcRelAssignsToControl::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.global_id = parameter.into(),
                1usize => {
                    entity.owner_history = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => entity.related_objects = parameter.into(),
                5usize => {
                    entity.related_objects_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                6usize => entity.relating_control = parameter.into(),
                _ => {}
            }
        }
        entity
    }
    pub fn from_own_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcRelAssignsToControl::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.relating_control = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcRelAssignsToGroup: IIfcRelAssigns {
    fn relating_group(&self) -> &EntityRef;
}
#[derive(Default, Debug)]
pub struct IfcRelAssignsToGroup {
    global_id: IfcGloballyUniqueId,
    owner_history: Option<EntityRef>,
    name: Option<IfcLabel>,
    description: Option<IfcText>,
    related_objects: HashSet<EntityRef>,
    related_objects_type: Option<IfcObjectTypeEnum>,
    relating_group: EntityRef,
}
impl IIfcRoot for IfcRelAssignsToGroup {
    fn global_id(&self) -> &IfcGloballyUniqueId {
        &self.global_id
    }
    fn owner_history(&self) -> &Option<EntityRef> {
        &self.owner_history
    }
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
}
impl IIfcRelationship for IfcRelAssignsToGroup {}
impl IIfcRelAssigns for IfcRelAssignsToGroup {
    fn related_objects(&self) -> &HashSet<EntityRef> {
        &self.related_objects
    }
    fn related_objects_type(&self) -> &Option<IfcObjectTypeEnum> {
        &self.related_objects_type
    }
}
impl IIfcRelAssignsToGroup for IfcRelAssignsToGroup {
    fn relating_group(&self) -> &EntityRef {
        &self.relating_group
    }
}
impl IfcRelAssignsToGroup {
    pub fn from_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcRelAssignsToGroup::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.global_id = parameter.into(),
                1usize => {
                    entity.owner_history = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => entity.related_objects = parameter.into(),
                5usize => {
                    entity.related_objects_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                6usize => entity.relating_group = parameter.into(),
                _ => {}
            }
        }
        entity
    }
    pub fn from_own_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcRelAssignsToGroup::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.relating_group = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcRelAssignsToGroupByFactor: IIfcRelAssignsToGroup {
    fn factor(&self) -> &IfcRatioMeasure;
}
#[derive(Default, Debug)]
pub struct IfcRelAssignsToGroupByFactor {
    global_id: IfcGloballyUniqueId,
    owner_history: Option<EntityRef>,
    name: Option<IfcLabel>,
    description: Option<IfcText>,
    related_objects: HashSet<EntityRef>,
    related_objects_type: Option<IfcObjectTypeEnum>,
    relating_group: EntityRef,
    factor: IfcRatioMeasure,
}
impl IIfcRoot for IfcRelAssignsToGroupByFactor {
    fn global_id(&self) -> &IfcGloballyUniqueId {
        &self.global_id
    }
    fn owner_history(&self) -> &Option<EntityRef> {
        &self.owner_history
    }
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
}
impl IIfcRelationship for IfcRelAssignsToGroupByFactor {}
impl IIfcRelAssigns for IfcRelAssignsToGroupByFactor {
    fn related_objects(&self) -> &HashSet<EntityRef> {
        &self.related_objects
    }
    fn related_objects_type(&self) -> &Option<IfcObjectTypeEnum> {
        &self.related_objects_type
    }
}
impl IIfcRelAssignsToGroup for IfcRelAssignsToGroupByFactor {
    fn relating_group(&self) -> &EntityRef {
        &self.relating_group
    }
}
impl IIfcRelAssignsToGroupByFactor for IfcRelAssignsToGroupByFactor {
    fn factor(&self) -> &IfcRatioMeasure {
        &self.factor
    }
}
impl IfcRelAssignsToGroupByFactor {
    pub fn from_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcRelAssignsToGroupByFactor::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.global_id = parameter.into(),
                1usize => {
                    entity.owner_history = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => entity.related_objects = parameter.into(),
                5usize => {
                    entity.related_objects_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                6usize => entity.relating_group = parameter.into(),
                7usize => entity.factor = parameter.into(),
                _ => {}
            }
        }
        entity
    }
    pub fn from_own_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcRelAssignsToGroupByFactor::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.factor = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcRelAssignsToProcess: IIfcRelAssigns {
    fn relating_process(&self) -> &EntityRef;
    fn quantity_in_process(&self) -> &Option<EntityRef>;
}
#[derive(Default, Debug)]
pub struct IfcRelAssignsToProcess {
    global_id: IfcGloballyUniqueId,
    owner_history: Option<EntityRef>,
    name: Option<IfcLabel>,
    description: Option<IfcText>,
    related_objects: HashSet<EntityRef>,
    related_objects_type: Option<IfcObjectTypeEnum>,
    relating_process: EntityRef,
    quantity_in_process: Option<EntityRef>,
}
impl IIfcRoot for IfcRelAssignsToProcess {
    fn global_id(&self) -> &IfcGloballyUniqueId {
        &self.global_id
    }
    fn owner_history(&self) -> &Option<EntityRef> {
        &self.owner_history
    }
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
}
impl IIfcRelationship for IfcRelAssignsToProcess {}
impl IIfcRelAssigns for IfcRelAssignsToProcess {
    fn related_objects(&self) -> &HashSet<EntityRef> {
        &self.related_objects
    }
    fn related_objects_type(&self) -> &Option<IfcObjectTypeEnum> {
        &self.related_objects_type
    }
}
impl IIfcRelAssignsToProcess for IfcRelAssignsToProcess {
    fn relating_process(&self) -> &EntityRef {
        &self.relating_process
    }
    fn quantity_in_process(&self) -> &Option<EntityRef> {
        &self.quantity_in_process
    }
}
impl IfcRelAssignsToProcess {
    pub fn from_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcRelAssignsToProcess::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.global_id = parameter.into(),
                1usize => {
                    entity.owner_history = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => entity.related_objects = parameter.into(),
                5usize => {
                    entity.related_objects_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                6usize => entity.relating_process = parameter.into(),
                7usize => {
                    entity.quantity_in_process = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
    pub fn from_own_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcRelAssignsToProcess::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.relating_process = parameter.into(),
                1usize => {
                    entity.quantity_in_process = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcRelAssignsToProduct: IIfcRelAssigns {
    fn relating_product(&self) -> &EntityRef;
}
#[derive(Default, Debug)]
pub struct IfcRelAssignsToProduct {
    global_id: IfcGloballyUniqueId,
    owner_history: Option<EntityRef>,
    name: Option<IfcLabel>,
    description: Option<IfcText>,
    related_objects: HashSet<EntityRef>,
    related_objects_type: Option<IfcObjectTypeEnum>,
    relating_product: EntityRef,
}
impl IIfcRoot for IfcRelAssignsToProduct {
    fn global_id(&self) -> &IfcGloballyUniqueId {
        &self.global_id
    }
    fn owner_history(&self) -> &Option<EntityRef> {
        &self.owner_history
    }
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
}
impl IIfcRelationship for IfcRelAssignsToProduct {}
impl IIfcRelAssigns for IfcRelAssignsToProduct {
    fn related_objects(&self) -> &HashSet<EntityRef> {
        &self.related_objects
    }
    fn related_objects_type(&self) -> &Option<IfcObjectTypeEnum> {
        &self.related_objects_type
    }
}
impl IIfcRelAssignsToProduct for IfcRelAssignsToProduct {
    fn relating_product(&self) -> &EntityRef {
        &self.relating_product
    }
}
impl IfcRelAssignsToProduct {
    pub fn from_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcRelAssignsToProduct::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.global_id = parameter.into(),
                1usize => {
                    entity.owner_history = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => entity.related_objects = parameter.into(),
                5usize => {
                    entity.related_objects_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                6usize => entity.relating_product = parameter.into(),
                _ => {}
            }
        }
        entity
    }
    pub fn from_own_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcRelAssignsToProduct::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.relating_product = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcRelAssignsToResource: IIfcRelAssigns {
    fn relating_resource(&self) -> &EntityRef;
}
#[derive(Default, Debug)]
pub struct IfcRelAssignsToResource {
    global_id: IfcGloballyUniqueId,
    owner_history: Option<EntityRef>,
    name: Option<IfcLabel>,
    description: Option<IfcText>,
    related_objects: HashSet<EntityRef>,
    related_objects_type: Option<IfcObjectTypeEnum>,
    relating_resource: EntityRef,
}
impl IIfcRoot for IfcRelAssignsToResource {
    fn global_id(&self) -> &IfcGloballyUniqueId {
        &self.global_id
    }
    fn owner_history(&self) -> &Option<EntityRef> {
        &self.owner_history
    }
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
}
impl IIfcRelationship for IfcRelAssignsToResource {}
impl IIfcRelAssigns for IfcRelAssignsToResource {
    fn related_objects(&self) -> &HashSet<EntityRef> {
        &self.related_objects
    }
    fn related_objects_type(&self) -> &Option<IfcObjectTypeEnum> {
        &self.related_objects_type
    }
}
impl IIfcRelAssignsToResource for IfcRelAssignsToResource {
    fn relating_resource(&self) -> &EntityRef {
        &self.relating_resource
    }
}
impl IfcRelAssignsToResource {
    pub fn from_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcRelAssignsToResource::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.global_id = parameter.into(),
                1usize => {
                    entity.owner_history = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => entity.related_objects = parameter.into(),
                5usize => {
                    entity.related_objects_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                6usize => entity.relating_resource = parameter.into(),
                _ => {}
            }
        }
        entity
    }
    pub fn from_own_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcRelAssignsToResource::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.relating_resource = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcRelAssociates: IIfcRelationship {
    fn related_objects(&self) -> &HashSet<EntityRef>;
}
pub trait IIfcRelAssociatesApproval: IIfcRelAssociates {
    fn relating_approval(&self) -> &EntityRef;
}
#[derive(Default, Debug)]
pub struct IfcRelAssociatesApproval {
    global_id: IfcGloballyUniqueId,
    owner_history: Option<EntityRef>,
    name: Option<IfcLabel>,
    description: Option<IfcText>,
    related_objects: HashSet<EntityRef>,
    relating_approval: EntityRef,
}
impl IIfcRoot for IfcRelAssociatesApproval {
    fn global_id(&self) -> &IfcGloballyUniqueId {
        &self.global_id
    }
    fn owner_history(&self) -> &Option<EntityRef> {
        &self.owner_history
    }
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
}
impl IIfcRelationship for IfcRelAssociatesApproval {}
impl IIfcRelAssociates for IfcRelAssociatesApproval {
    fn related_objects(&self) -> &HashSet<EntityRef> {
        &self.related_objects
    }
}
impl IIfcRelAssociatesApproval for IfcRelAssociatesApproval {
    fn relating_approval(&self) -> &EntityRef {
        &self.relating_approval
    }
}
impl IfcRelAssociatesApproval {
    pub fn from_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcRelAssociatesApproval::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.global_id = parameter.into(),
                1usize => {
                    entity.owner_history = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => entity.related_objects = parameter.into(),
                5usize => entity.relating_approval = parameter.into(),
                _ => {}
            }
        }
        entity
    }
    pub fn from_own_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcRelAssociatesApproval::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.relating_approval = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcRelAssociatesClassification: IIfcRelAssociates {
    fn relating_classification(&self) -> &EntityRef;
}
#[derive(Default, Debug)]
pub struct IfcRelAssociatesClassification {
    global_id: IfcGloballyUniqueId,
    owner_history: Option<EntityRef>,
    name: Option<IfcLabel>,
    description: Option<IfcText>,
    related_objects: HashSet<EntityRef>,
    relating_classification: EntityRef,
}
impl IIfcRoot for IfcRelAssociatesClassification {
    fn global_id(&self) -> &IfcGloballyUniqueId {
        &self.global_id
    }
    fn owner_history(&self) -> &Option<EntityRef> {
        &self.owner_history
    }
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
}
impl IIfcRelationship for IfcRelAssociatesClassification {}
impl IIfcRelAssociates for IfcRelAssociatesClassification {
    fn related_objects(&self) -> &HashSet<EntityRef> {
        &self.related_objects
    }
}
impl IIfcRelAssociatesClassification for IfcRelAssociatesClassification {
    fn relating_classification(&self) -> &EntityRef {
        &self.relating_classification
    }
}
impl IfcRelAssociatesClassification {
    pub fn from_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcRelAssociatesClassification::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.global_id = parameter.into(),
                1usize => {
                    entity.owner_history = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => entity.related_objects = parameter.into(),
                5usize => entity.relating_classification = parameter.into(),
                _ => {}
            }
        }
        entity
    }
    pub fn from_own_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcRelAssociatesClassification::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.relating_classification = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcRelAssociatesConstraint: IIfcRelAssociates {
    fn intent(&self) -> &Option<IfcLabel>;
    fn relating_constraint(&self) -> &EntityRef;
}
#[derive(Default, Debug)]
pub struct IfcRelAssociatesConstraint {
    global_id: IfcGloballyUniqueId,
    owner_history: Option<EntityRef>,
    name: Option<IfcLabel>,
    description: Option<IfcText>,
    related_objects: HashSet<EntityRef>,
    intent: Option<IfcLabel>,
    relating_constraint: EntityRef,
}
impl IIfcRoot for IfcRelAssociatesConstraint {
    fn global_id(&self) -> &IfcGloballyUniqueId {
        &self.global_id
    }
    fn owner_history(&self) -> &Option<EntityRef> {
        &self.owner_history
    }
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
}
impl IIfcRelationship for IfcRelAssociatesConstraint {}
impl IIfcRelAssociates for IfcRelAssociatesConstraint {
    fn related_objects(&self) -> &HashSet<EntityRef> {
        &self.related_objects
    }
}
impl IIfcRelAssociatesConstraint for IfcRelAssociatesConstraint {
    fn intent(&self) -> &Option<IfcLabel> {
        &self.intent
    }
    fn relating_constraint(&self) -> &EntityRef {
        &self.relating_constraint
    }
}
impl IfcRelAssociatesConstraint {
    pub fn from_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcRelAssociatesConstraint::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.global_id = parameter.into(),
                1usize => {
                    entity.owner_history = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => entity.related_objects = parameter.into(),
                5usize => {
                    entity.intent = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                6usize => entity.relating_constraint = parameter.into(),
                _ => {}
            }
        }
        entity
    }
    pub fn from_own_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcRelAssociatesConstraint::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => {
                    entity.intent = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                1usize => entity.relating_constraint = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcRelAssociatesDocument: IIfcRelAssociates {
    fn relating_document(&self) -> &EntityRef;
}
#[derive(Default, Debug)]
pub struct IfcRelAssociatesDocument {
    global_id: IfcGloballyUniqueId,
    owner_history: Option<EntityRef>,
    name: Option<IfcLabel>,
    description: Option<IfcText>,
    related_objects: HashSet<EntityRef>,
    relating_document: EntityRef,
}
impl IIfcRoot for IfcRelAssociatesDocument {
    fn global_id(&self) -> &IfcGloballyUniqueId {
        &self.global_id
    }
    fn owner_history(&self) -> &Option<EntityRef> {
        &self.owner_history
    }
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
}
impl IIfcRelationship for IfcRelAssociatesDocument {}
impl IIfcRelAssociates for IfcRelAssociatesDocument {
    fn related_objects(&self) -> &HashSet<EntityRef> {
        &self.related_objects
    }
}
impl IIfcRelAssociatesDocument for IfcRelAssociatesDocument {
    fn relating_document(&self) -> &EntityRef {
        &self.relating_document
    }
}
impl IfcRelAssociatesDocument {
    pub fn from_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcRelAssociatesDocument::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.global_id = parameter.into(),
                1usize => {
                    entity.owner_history = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => entity.related_objects = parameter.into(),
                5usize => entity.relating_document = parameter.into(),
                _ => {}
            }
        }
        entity
    }
    pub fn from_own_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcRelAssociatesDocument::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.relating_document = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcRelAssociatesLibrary: IIfcRelAssociates {
    fn relating_library(&self) -> &EntityRef;
}
#[derive(Default, Debug)]
pub struct IfcRelAssociatesLibrary {
    global_id: IfcGloballyUniqueId,
    owner_history: Option<EntityRef>,
    name: Option<IfcLabel>,
    description: Option<IfcText>,
    related_objects: HashSet<EntityRef>,
    relating_library: EntityRef,
}
impl IIfcRoot for IfcRelAssociatesLibrary {
    fn global_id(&self) -> &IfcGloballyUniqueId {
        &self.global_id
    }
    fn owner_history(&self) -> &Option<EntityRef> {
        &self.owner_history
    }
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
}
impl IIfcRelationship for IfcRelAssociatesLibrary {}
impl IIfcRelAssociates for IfcRelAssociatesLibrary {
    fn related_objects(&self) -> &HashSet<EntityRef> {
        &self.related_objects
    }
}
impl IIfcRelAssociatesLibrary for IfcRelAssociatesLibrary {
    fn relating_library(&self) -> &EntityRef {
        &self.relating_library
    }
}
impl IfcRelAssociatesLibrary {
    pub fn from_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcRelAssociatesLibrary::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.global_id = parameter.into(),
                1usize => {
                    entity.owner_history = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => entity.related_objects = parameter.into(),
                5usize => entity.relating_library = parameter.into(),
                _ => {}
            }
        }
        entity
    }
    pub fn from_own_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcRelAssociatesLibrary::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.relating_library = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcRelAssociatesMaterial: IIfcRelAssociates {
    fn relating_material(&self) -> &EntityRef;
}
#[derive(Default, Debug)]
pub struct IfcRelAssociatesMaterial {
    global_id: IfcGloballyUniqueId,
    owner_history: Option<EntityRef>,
    name: Option<IfcLabel>,
    description: Option<IfcText>,
    related_objects: HashSet<EntityRef>,
    relating_material: EntityRef,
}
impl IIfcRoot for IfcRelAssociatesMaterial {
    fn global_id(&self) -> &IfcGloballyUniqueId {
        &self.global_id
    }
    fn owner_history(&self) -> &Option<EntityRef> {
        &self.owner_history
    }
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
}
impl IIfcRelationship for IfcRelAssociatesMaterial {}
impl IIfcRelAssociates for IfcRelAssociatesMaterial {
    fn related_objects(&self) -> &HashSet<EntityRef> {
        &self.related_objects
    }
}
impl IIfcRelAssociatesMaterial for IfcRelAssociatesMaterial {
    fn relating_material(&self) -> &EntityRef {
        &self.relating_material
    }
}
impl IfcRelAssociatesMaterial {
    pub fn from_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcRelAssociatesMaterial::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.global_id = parameter.into(),
                1usize => {
                    entity.owner_history = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => entity.related_objects = parameter.into(),
                5usize => entity.relating_material = parameter.into(),
                _ => {}
            }
        }
        entity
    }
    pub fn from_own_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcRelAssociatesMaterial::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.relating_material = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcRelConnects: IIfcRelationship {}
pub trait IIfcRelConnectsElements: IIfcRelConnects {
    fn connection_geometry(&self) -> &Option<EntityRef>;
    fn relating_element(&self) -> &EntityRef;
    fn related_element(&self) -> &EntityRef;
}
#[derive(Default, Debug)]
pub struct IfcRelConnectsElements {
    global_id: IfcGloballyUniqueId,
    owner_history: Option<EntityRef>,
    name: Option<IfcLabel>,
    description: Option<IfcText>,
    connection_geometry: Option<EntityRef>,
    relating_element: EntityRef,
    related_element: EntityRef,
}
impl IIfcRoot for IfcRelConnectsElements {
    fn global_id(&self) -> &IfcGloballyUniqueId {
        &self.global_id
    }
    fn owner_history(&self) -> &Option<EntityRef> {
        &self.owner_history
    }
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
}
impl IIfcRelationship for IfcRelConnectsElements {}
impl IIfcRelConnects for IfcRelConnectsElements {}
impl IIfcRelConnectsElements for IfcRelConnectsElements {
    fn connection_geometry(&self) -> &Option<EntityRef> {
        &self.connection_geometry
    }
    fn relating_element(&self) -> &EntityRef {
        &self.relating_element
    }
    fn related_element(&self) -> &EntityRef {
        &self.related_element
    }
}
impl IfcRelConnectsElements {
    pub fn from_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcRelConnectsElements::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.global_id = parameter.into(),
                1usize => {
                    entity.owner_history = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => {
                    entity.connection_geometry = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                5usize => entity.relating_element = parameter.into(),
                6usize => entity.related_element = parameter.into(),
                _ => {}
            }
        }
        entity
    }
    pub fn from_own_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcRelConnectsElements::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => {
                    entity.connection_geometry = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                1usize => entity.relating_element = parameter.into(),
                2usize => entity.related_element = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcRelConnectsPathElements: IIfcRelConnectsElements {
    fn relating_priorities(&self) -> &Vec<IfcInteger>;
    fn related_priorities(&self) -> &Vec<IfcInteger>;
    fn related_connection_type(&self) -> &IfcConnectionTypeEnum;
    fn relating_connection_type(&self) -> &IfcConnectionTypeEnum;
}
#[derive(Default, Debug)]
pub struct IfcRelConnectsPathElements {
    global_id: IfcGloballyUniqueId,
    owner_history: Option<EntityRef>,
    name: Option<IfcLabel>,
    description: Option<IfcText>,
    connection_geometry: Option<EntityRef>,
    relating_element: EntityRef,
    related_element: EntityRef,
    relating_priorities: Vec<IfcInteger>,
    related_priorities: Vec<IfcInteger>,
    related_connection_type: IfcConnectionTypeEnum,
    relating_connection_type: IfcConnectionTypeEnum,
}
impl IIfcRoot for IfcRelConnectsPathElements {
    fn global_id(&self) -> &IfcGloballyUniqueId {
        &self.global_id
    }
    fn owner_history(&self) -> &Option<EntityRef> {
        &self.owner_history
    }
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
}
impl IIfcRelationship for IfcRelConnectsPathElements {}
impl IIfcRelConnects for IfcRelConnectsPathElements {}
impl IIfcRelConnectsElements for IfcRelConnectsPathElements {
    fn connection_geometry(&self) -> &Option<EntityRef> {
        &self.connection_geometry
    }
    fn relating_element(&self) -> &EntityRef {
        &self.relating_element
    }
    fn related_element(&self) -> &EntityRef {
        &self.related_element
    }
}
impl IIfcRelConnectsPathElements for IfcRelConnectsPathElements {
    fn relating_priorities(&self) -> &Vec<IfcInteger> {
        &self.relating_priorities
    }
    fn related_priorities(&self) -> &Vec<IfcInteger> {
        &self.related_priorities
    }
    fn related_connection_type(&self) -> &IfcConnectionTypeEnum {
        &self.related_connection_type
    }
    fn relating_connection_type(&self) -> &IfcConnectionTypeEnum {
        &self.relating_connection_type
    }
}
impl IfcRelConnectsPathElements {
    pub fn from_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcRelConnectsPathElements::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.global_id = parameter.into(),
                1usize => {
                    entity.owner_history = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => {
                    entity.connection_geometry = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                5usize => entity.relating_element = parameter.into(),
                6usize => entity.related_element = parameter.into(),
                7usize => entity.relating_priorities = parameter.into(),
                8usize => entity.related_priorities = parameter.into(),
                9usize => entity.related_connection_type = parameter.into(),
                10usize => entity.relating_connection_type = parameter.into(),
                _ => {}
            }
        }
        entity
    }
    pub fn from_own_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcRelConnectsPathElements::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.relating_priorities = parameter.into(),
                1usize => entity.related_priorities = parameter.into(),
                2usize => entity.related_connection_type = parameter.into(),
                3usize => entity.relating_connection_type = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcRelConnectsPortToElement: IIfcRelConnects {
    fn relating_port(&self) -> &EntityRef;
    fn related_element(&self) -> &EntityRef;
}
#[derive(Default, Debug)]
pub struct IfcRelConnectsPortToElement {
    global_id: IfcGloballyUniqueId,
    owner_history: Option<EntityRef>,
    name: Option<IfcLabel>,
    description: Option<IfcText>,
    relating_port: EntityRef,
    related_element: EntityRef,
}
impl IIfcRoot for IfcRelConnectsPortToElement {
    fn global_id(&self) -> &IfcGloballyUniqueId {
        &self.global_id
    }
    fn owner_history(&self) -> &Option<EntityRef> {
        &self.owner_history
    }
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
}
impl IIfcRelationship for IfcRelConnectsPortToElement {}
impl IIfcRelConnects for IfcRelConnectsPortToElement {}
impl IIfcRelConnectsPortToElement for IfcRelConnectsPortToElement {
    fn relating_port(&self) -> &EntityRef {
        &self.relating_port
    }
    fn related_element(&self) -> &EntityRef {
        &self.related_element
    }
}
impl IfcRelConnectsPortToElement {
    pub fn from_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcRelConnectsPortToElement::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.global_id = parameter.into(),
                1usize => {
                    entity.owner_history = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => entity.relating_port = parameter.into(),
                5usize => entity.related_element = parameter.into(),
                _ => {}
            }
        }
        entity
    }
    pub fn from_own_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcRelConnectsPortToElement::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.relating_port = parameter.into(),
                1usize => entity.related_element = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcRelConnectsPorts: IIfcRelConnects {
    fn relating_port(&self) -> &EntityRef;
    fn related_port(&self) -> &EntityRef;
    fn realizing_element(&self) -> &Option<EntityRef>;
}
#[derive(Default, Debug)]
pub struct IfcRelConnectsPorts {
    global_id: IfcGloballyUniqueId,
    owner_history: Option<EntityRef>,
    name: Option<IfcLabel>,
    description: Option<IfcText>,
    relating_port: EntityRef,
    related_port: EntityRef,
    realizing_element: Option<EntityRef>,
}
impl IIfcRoot for IfcRelConnectsPorts {
    fn global_id(&self) -> &IfcGloballyUniqueId {
        &self.global_id
    }
    fn owner_history(&self) -> &Option<EntityRef> {
        &self.owner_history
    }
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
}
impl IIfcRelationship for IfcRelConnectsPorts {}
impl IIfcRelConnects for IfcRelConnectsPorts {}
impl IIfcRelConnectsPorts for IfcRelConnectsPorts {
    fn relating_port(&self) -> &EntityRef {
        &self.relating_port
    }
    fn related_port(&self) -> &EntityRef {
        &self.related_port
    }
    fn realizing_element(&self) -> &Option<EntityRef> {
        &self.realizing_element
    }
}
impl IfcRelConnectsPorts {
    pub fn from_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcRelConnectsPorts::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.global_id = parameter.into(),
                1usize => {
                    entity.owner_history = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => entity.relating_port = parameter.into(),
                5usize => entity.related_port = parameter.into(),
                6usize => {
                    entity.realizing_element = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
    pub fn from_own_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcRelConnectsPorts::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.relating_port = parameter.into(),
                1usize => entity.related_port = parameter.into(),
                2usize => {
                    entity.realizing_element = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcRelConnectsStructuralActivity: IIfcRelConnects {
    fn relating_element(&self) -> &EntityRef;
    fn related_structural_activity(&self) -> &EntityRef;
}
#[derive(Default, Debug)]
pub struct IfcRelConnectsStructuralActivity {
    global_id: IfcGloballyUniqueId,
    owner_history: Option<EntityRef>,
    name: Option<IfcLabel>,
    description: Option<IfcText>,
    relating_element: EntityRef,
    related_structural_activity: EntityRef,
}
impl IIfcRoot for IfcRelConnectsStructuralActivity {
    fn global_id(&self) -> &IfcGloballyUniqueId {
        &self.global_id
    }
    fn owner_history(&self) -> &Option<EntityRef> {
        &self.owner_history
    }
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
}
impl IIfcRelationship for IfcRelConnectsStructuralActivity {}
impl IIfcRelConnects for IfcRelConnectsStructuralActivity {}
impl IIfcRelConnectsStructuralActivity for IfcRelConnectsStructuralActivity {
    fn relating_element(&self) -> &EntityRef {
        &self.relating_element
    }
    fn related_structural_activity(&self) -> &EntityRef {
        &self.related_structural_activity
    }
}
impl IfcRelConnectsStructuralActivity {
    pub fn from_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcRelConnectsStructuralActivity::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.global_id = parameter.into(),
                1usize => {
                    entity.owner_history = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => entity.relating_element = parameter.into(),
                5usize => entity.related_structural_activity = parameter.into(),
                _ => {}
            }
        }
        entity
    }
    pub fn from_own_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcRelConnectsStructuralActivity::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.relating_element = parameter.into(),
                1usize => entity.related_structural_activity = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcRelConnectsStructuralMember: IIfcRelConnects {
    fn relating_structural_member(&self) -> &EntityRef;
    fn related_structural_connection(&self) -> &EntityRef;
    fn applied_condition(&self) -> &Option<EntityRef>;
    fn additional_conditions(&self) -> &Option<EntityRef>;
    fn supported_length(&self) -> &Option<IfcLengthMeasure>;
    fn condition_coordinate_system(&self) -> &Option<EntityRef>;
}
#[derive(Default, Debug)]
pub struct IfcRelConnectsStructuralMember {
    global_id: IfcGloballyUniqueId,
    owner_history: Option<EntityRef>,
    name: Option<IfcLabel>,
    description: Option<IfcText>,
    relating_structural_member: EntityRef,
    related_structural_connection: EntityRef,
    applied_condition: Option<EntityRef>,
    additional_conditions: Option<EntityRef>,
    supported_length: Option<IfcLengthMeasure>,
    condition_coordinate_system: Option<EntityRef>,
}
impl IIfcRoot for IfcRelConnectsStructuralMember {
    fn global_id(&self) -> &IfcGloballyUniqueId {
        &self.global_id
    }
    fn owner_history(&self) -> &Option<EntityRef> {
        &self.owner_history
    }
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
}
impl IIfcRelationship for IfcRelConnectsStructuralMember {}
impl IIfcRelConnects for IfcRelConnectsStructuralMember {}
impl IIfcRelConnectsStructuralMember for IfcRelConnectsStructuralMember {
    fn relating_structural_member(&self) -> &EntityRef {
        &self.relating_structural_member
    }
    fn related_structural_connection(&self) -> &EntityRef {
        &self.related_structural_connection
    }
    fn applied_condition(&self) -> &Option<EntityRef> {
        &self.applied_condition
    }
    fn additional_conditions(&self) -> &Option<EntityRef> {
        &self.additional_conditions
    }
    fn supported_length(&self) -> &Option<IfcLengthMeasure> {
        &self.supported_length
    }
    fn condition_coordinate_system(&self) -> &Option<EntityRef> {
        &self.condition_coordinate_system
    }
}
impl IfcRelConnectsStructuralMember {
    pub fn from_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcRelConnectsStructuralMember::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.global_id = parameter.into(),
                1usize => {
                    entity.owner_history = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => entity.relating_structural_member = parameter.into(),
                5usize => entity.related_structural_connection = parameter.into(),
                6usize => {
                    entity.applied_condition = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                7usize => {
                    entity.additional_conditions = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                8usize => {
                    entity.supported_length = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                9usize => {
                    entity.condition_coordinate_system = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
    pub fn from_own_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcRelConnectsStructuralMember::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.relating_structural_member = parameter.into(),
                1usize => entity.related_structural_connection = parameter.into(),
                2usize => {
                    entity.applied_condition = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.additional_conditions = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => {
                    entity.supported_length = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                5usize => {
                    entity.condition_coordinate_system = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcRelConnectsWithEccentricity: IIfcRelConnectsStructuralMember {
    fn connection_constraint(&self) -> &EntityRef;
}
#[derive(Default, Debug)]
pub struct IfcRelConnectsWithEccentricity {
    global_id: IfcGloballyUniqueId,
    owner_history: Option<EntityRef>,
    name: Option<IfcLabel>,
    description: Option<IfcText>,
    relating_structural_member: EntityRef,
    related_structural_connection: EntityRef,
    applied_condition: Option<EntityRef>,
    additional_conditions: Option<EntityRef>,
    supported_length: Option<IfcLengthMeasure>,
    condition_coordinate_system: Option<EntityRef>,
    connection_constraint: EntityRef,
}
impl IIfcRoot for IfcRelConnectsWithEccentricity {
    fn global_id(&self) -> &IfcGloballyUniqueId {
        &self.global_id
    }
    fn owner_history(&self) -> &Option<EntityRef> {
        &self.owner_history
    }
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
}
impl IIfcRelationship for IfcRelConnectsWithEccentricity {}
impl IIfcRelConnects for IfcRelConnectsWithEccentricity {}
impl IIfcRelConnectsStructuralMember for IfcRelConnectsWithEccentricity {
    fn relating_structural_member(&self) -> &EntityRef {
        &self.relating_structural_member
    }
    fn related_structural_connection(&self) -> &EntityRef {
        &self.related_structural_connection
    }
    fn applied_condition(&self) -> &Option<EntityRef> {
        &self.applied_condition
    }
    fn additional_conditions(&self) -> &Option<EntityRef> {
        &self.additional_conditions
    }
    fn supported_length(&self) -> &Option<IfcLengthMeasure> {
        &self.supported_length
    }
    fn condition_coordinate_system(&self) -> &Option<EntityRef> {
        &self.condition_coordinate_system
    }
}
impl IIfcRelConnectsWithEccentricity for IfcRelConnectsWithEccentricity {
    fn connection_constraint(&self) -> &EntityRef {
        &self.connection_constraint
    }
}
impl IfcRelConnectsWithEccentricity {
    pub fn from_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcRelConnectsWithEccentricity::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.global_id = parameter.into(),
                1usize => {
                    entity.owner_history = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => entity.relating_structural_member = parameter.into(),
                5usize => entity.related_structural_connection = parameter.into(),
                6usize => {
                    entity.applied_condition = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                7usize => {
                    entity.additional_conditions = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                8usize => {
                    entity.supported_length = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                9usize => {
                    entity.condition_coordinate_system = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                10usize => entity.connection_constraint = parameter.into(),
                _ => {}
            }
        }
        entity
    }
    pub fn from_own_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcRelConnectsWithEccentricity::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.connection_constraint = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcRelConnectsWithRealizingElements: IIfcRelConnectsElements {
    fn realizing_elements(&self) -> &HashSet<EntityRef>;
    fn connection_type(&self) -> &Option<IfcLabel>;
}
#[derive(Default, Debug)]
pub struct IfcRelConnectsWithRealizingElements {
    global_id: IfcGloballyUniqueId,
    owner_history: Option<EntityRef>,
    name: Option<IfcLabel>,
    description: Option<IfcText>,
    connection_geometry: Option<EntityRef>,
    relating_element: EntityRef,
    related_element: EntityRef,
    realizing_elements: HashSet<EntityRef>,
    connection_type: Option<IfcLabel>,
}
impl IIfcRoot for IfcRelConnectsWithRealizingElements {
    fn global_id(&self) -> &IfcGloballyUniqueId {
        &self.global_id
    }
    fn owner_history(&self) -> &Option<EntityRef> {
        &self.owner_history
    }
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
}
impl IIfcRelationship for IfcRelConnectsWithRealizingElements {}
impl IIfcRelConnects for IfcRelConnectsWithRealizingElements {}
impl IIfcRelConnectsElements for IfcRelConnectsWithRealizingElements {
    fn connection_geometry(&self) -> &Option<EntityRef> {
        &self.connection_geometry
    }
    fn relating_element(&self) -> &EntityRef {
        &self.relating_element
    }
    fn related_element(&self) -> &EntityRef {
        &self.related_element
    }
}
impl IIfcRelConnectsWithRealizingElements for IfcRelConnectsWithRealizingElements {
    fn realizing_elements(&self) -> &HashSet<EntityRef> {
        &self.realizing_elements
    }
    fn connection_type(&self) -> &Option<IfcLabel> {
        &self.connection_type
    }
}
impl IfcRelConnectsWithRealizingElements {
    pub fn from_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcRelConnectsWithRealizingElements::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.global_id = parameter.into(),
                1usize => {
                    entity.owner_history = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => {
                    entity.connection_geometry = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                5usize => entity.relating_element = parameter.into(),
                6usize => entity.related_element = parameter.into(),
                7usize => entity.realizing_elements = parameter.into(),
                8usize => {
                    entity.connection_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
    pub fn from_own_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcRelConnectsWithRealizingElements::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.realizing_elements = parameter.into(),
                1usize => {
                    entity.connection_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcRelContainedInSpatialStructure: IIfcRelConnects {
    fn related_elements(&self) -> &HashSet<EntityRef>;
    fn relating_structure(&self) -> &EntityRef;
}
#[derive(Default, Debug)]
pub struct IfcRelContainedInSpatialStructure {
    global_id: IfcGloballyUniqueId,
    owner_history: Option<EntityRef>,
    name: Option<IfcLabel>,
    description: Option<IfcText>,
    related_elements: HashSet<EntityRef>,
    relating_structure: EntityRef,
}
impl IIfcRoot for IfcRelContainedInSpatialStructure {
    fn global_id(&self) -> &IfcGloballyUniqueId {
        &self.global_id
    }
    fn owner_history(&self) -> &Option<EntityRef> {
        &self.owner_history
    }
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
}
impl IIfcRelationship for IfcRelContainedInSpatialStructure {}
impl IIfcRelConnects for IfcRelContainedInSpatialStructure {}
impl IIfcRelContainedInSpatialStructure for IfcRelContainedInSpatialStructure {
    fn related_elements(&self) -> &HashSet<EntityRef> {
        &self.related_elements
    }
    fn relating_structure(&self) -> &EntityRef {
        &self.relating_structure
    }
}
impl IfcRelContainedInSpatialStructure {
    pub fn from_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcRelContainedInSpatialStructure::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.global_id = parameter.into(),
                1usize => {
                    entity.owner_history = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => entity.related_elements = parameter.into(),
                5usize => entity.relating_structure = parameter.into(),
                _ => {}
            }
        }
        entity
    }
    pub fn from_own_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcRelContainedInSpatialStructure::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.related_elements = parameter.into(),
                1usize => entity.relating_structure = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcRelCoversBldgElements: IIfcRelConnects {
    fn relating_building_element(&self) -> &EntityRef;
    fn related_coverings(&self) -> &HashSet<EntityRef>;
}
#[derive(Default, Debug)]
pub struct IfcRelCoversBldgElements {
    global_id: IfcGloballyUniqueId,
    owner_history: Option<EntityRef>,
    name: Option<IfcLabel>,
    description: Option<IfcText>,
    relating_building_element: EntityRef,
    related_coverings: HashSet<EntityRef>,
}
impl IIfcRoot for IfcRelCoversBldgElements {
    fn global_id(&self) -> &IfcGloballyUniqueId {
        &self.global_id
    }
    fn owner_history(&self) -> &Option<EntityRef> {
        &self.owner_history
    }
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
}
impl IIfcRelationship for IfcRelCoversBldgElements {}
impl IIfcRelConnects for IfcRelCoversBldgElements {}
impl IIfcRelCoversBldgElements for IfcRelCoversBldgElements {
    fn relating_building_element(&self) -> &EntityRef {
        &self.relating_building_element
    }
    fn related_coverings(&self) -> &HashSet<EntityRef> {
        &self.related_coverings
    }
}
impl IfcRelCoversBldgElements {
    pub fn from_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcRelCoversBldgElements::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.global_id = parameter.into(),
                1usize => {
                    entity.owner_history = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => entity.relating_building_element = parameter.into(),
                5usize => entity.related_coverings = parameter.into(),
                _ => {}
            }
        }
        entity
    }
    pub fn from_own_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcRelCoversBldgElements::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.relating_building_element = parameter.into(),
                1usize => entity.related_coverings = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcRelCoversSpaces: IIfcRelConnects {
    fn relating_space(&self) -> &EntityRef;
    fn related_coverings(&self) -> &HashSet<EntityRef>;
}
#[derive(Default, Debug)]
pub struct IfcRelCoversSpaces {
    global_id: IfcGloballyUniqueId,
    owner_history: Option<EntityRef>,
    name: Option<IfcLabel>,
    description: Option<IfcText>,
    relating_space: EntityRef,
    related_coverings: HashSet<EntityRef>,
}
impl IIfcRoot for IfcRelCoversSpaces {
    fn global_id(&self) -> &IfcGloballyUniqueId {
        &self.global_id
    }
    fn owner_history(&self) -> &Option<EntityRef> {
        &self.owner_history
    }
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
}
impl IIfcRelationship for IfcRelCoversSpaces {}
impl IIfcRelConnects for IfcRelCoversSpaces {}
impl IIfcRelCoversSpaces for IfcRelCoversSpaces {
    fn relating_space(&self) -> &EntityRef {
        &self.relating_space
    }
    fn related_coverings(&self) -> &HashSet<EntityRef> {
        &self.related_coverings
    }
}
impl IfcRelCoversSpaces {
    pub fn from_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcRelCoversSpaces::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.global_id = parameter.into(),
                1usize => {
                    entity.owner_history = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => entity.relating_space = parameter.into(),
                5usize => entity.related_coverings = parameter.into(),
                _ => {}
            }
        }
        entity
    }
    pub fn from_own_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcRelCoversSpaces::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.relating_space = parameter.into(),
                1usize => entity.related_coverings = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcRelDeclares: IIfcRelationship {
    fn relating_context(&self) -> &EntityRef;
    fn related_definitions(&self) -> &HashSet<EntityRef>;
}
#[derive(Default, Debug)]
pub struct IfcRelDeclares {
    global_id: IfcGloballyUniqueId,
    owner_history: Option<EntityRef>,
    name: Option<IfcLabel>,
    description: Option<IfcText>,
    relating_context: EntityRef,
    related_definitions: HashSet<EntityRef>,
}
impl IIfcRoot for IfcRelDeclares {
    fn global_id(&self) -> &IfcGloballyUniqueId {
        &self.global_id
    }
    fn owner_history(&self) -> &Option<EntityRef> {
        &self.owner_history
    }
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
}
impl IIfcRelationship for IfcRelDeclares {}
impl IIfcRelDeclares for IfcRelDeclares {
    fn relating_context(&self) -> &EntityRef {
        &self.relating_context
    }
    fn related_definitions(&self) -> &HashSet<EntityRef> {
        &self.related_definitions
    }
}
impl IfcRelDeclares {
    pub fn from_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcRelDeclares::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.global_id = parameter.into(),
                1usize => {
                    entity.owner_history = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => entity.relating_context = parameter.into(),
                5usize => entity.related_definitions = parameter.into(),
                _ => {}
            }
        }
        entity
    }
    pub fn from_own_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcRelDeclares::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.relating_context = parameter.into(),
                1usize => entity.related_definitions = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcRelDecomposes: IIfcRelationship {}
pub trait IIfcRelDefines: IIfcRelationship {}
pub trait IIfcRelDefinesByObject: IIfcRelDefines {
    fn related_objects(&self) -> &HashSet<EntityRef>;
    fn relating_object(&self) -> &EntityRef;
}
#[derive(Default, Debug)]
pub struct IfcRelDefinesByObject {
    global_id: IfcGloballyUniqueId,
    owner_history: Option<EntityRef>,
    name: Option<IfcLabel>,
    description: Option<IfcText>,
    related_objects: HashSet<EntityRef>,
    relating_object: EntityRef,
}
impl IIfcRoot for IfcRelDefinesByObject {
    fn global_id(&self) -> &IfcGloballyUniqueId {
        &self.global_id
    }
    fn owner_history(&self) -> &Option<EntityRef> {
        &self.owner_history
    }
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
}
impl IIfcRelationship for IfcRelDefinesByObject {}
impl IIfcRelDefines for IfcRelDefinesByObject {}
impl IIfcRelDefinesByObject for IfcRelDefinesByObject {
    fn related_objects(&self) -> &HashSet<EntityRef> {
        &self.related_objects
    }
    fn relating_object(&self) -> &EntityRef {
        &self.relating_object
    }
}
impl IfcRelDefinesByObject {
    pub fn from_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcRelDefinesByObject::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.global_id = parameter.into(),
                1usize => {
                    entity.owner_history = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => entity.related_objects = parameter.into(),
                5usize => entity.relating_object = parameter.into(),
                _ => {}
            }
        }
        entity
    }
    pub fn from_own_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcRelDefinesByObject::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.related_objects = parameter.into(),
                1usize => entity.relating_object = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcRelDefinesByProperties: IIfcRelDefines {
    fn related_objects(&self) -> &HashSet<EntityRef>;
    fn relating_property_definition(&self) -> &IfcPropertySetDefinitionSelect;
}
#[derive(Default, Debug)]
pub struct IfcRelDefinesByProperties {
    global_id: IfcGloballyUniqueId,
    owner_history: Option<EntityRef>,
    name: Option<IfcLabel>,
    description: Option<IfcText>,
    related_objects: HashSet<EntityRef>,
    relating_property_definition: IfcPropertySetDefinitionSelect,
}
impl IIfcRoot for IfcRelDefinesByProperties {
    fn global_id(&self) -> &IfcGloballyUniqueId {
        &self.global_id
    }
    fn owner_history(&self) -> &Option<EntityRef> {
        &self.owner_history
    }
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
}
impl IIfcRelationship for IfcRelDefinesByProperties {}
impl IIfcRelDefines for IfcRelDefinesByProperties {}
impl IIfcRelDefinesByProperties for IfcRelDefinesByProperties {
    fn related_objects(&self) -> &HashSet<EntityRef> {
        &self.related_objects
    }
    fn relating_property_definition(&self) -> &IfcPropertySetDefinitionSelect {
        &self.relating_property_definition
    }
}
impl IfcRelDefinesByProperties {
    pub fn from_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcRelDefinesByProperties::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.global_id = parameter.into(),
                1usize => {
                    entity.owner_history = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => entity.related_objects = parameter.into(),
                5usize => entity.relating_property_definition = parameter.into(),
                _ => {}
            }
        }
        entity
    }
    pub fn from_own_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcRelDefinesByProperties::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.related_objects = parameter.into(),
                1usize => entity.relating_property_definition = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcRelDefinesByTemplate: IIfcRelDefines {
    fn related_property_sets(&self) -> &HashSet<EntityRef>;
    fn relating_template(&self) -> &EntityRef;
}
#[derive(Default, Debug)]
pub struct IfcRelDefinesByTemplate {
    global_id: IfcGloballyUniqueId,
    owner_history: Option<EntityRef>,
    name: Option<IfcLabel>,
    description: Option<IfcText>,
    related_property_sets: HashSet<EntityRef>,
    relating_template: EntityRef,
}
impl IIfcRoot for IfcRelDefinesByTemplate {
    fn global_id(&self) -> &IfcGloballyUniqueId {
        &self.global_id
    }
    fn owner_history(&self) -> &Option<EntityRef> {
        &self.owner_history
    }
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
}
impl IIfcRelationship for IfcRelDefinesByTemplate {}
impl IIfcRelDefines for IfcRelDefinesByTemplate {}
impl IIfcRelDefinesByTemplate for IfcRelDefinesByTemplate {
    fn related_property_sets(&self) -> &HashSet<EntityRef> {
        &self.related_property_sets
    }
    fn relating_template(&self) -> &EntityRef {
        &self.relating_template
    }
}
impl IfcRelDefinesByTemplate {
    pub fn from_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcRelDefinesByTemplate::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.global_id = parameter.into(),
                1usize => {
                    entity.owner_history = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => entity.related_property_sets = parameter.into(),
                5usize => entity.relating_template = parameter.into(),
                _ => {}
            }
        }
        entity
    }
    pub fn from_own_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcRelDefinesByTemplate::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.related_property_sets = parameter.into(),
                1usize => entity.relating_template = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcRelDefinesByType: IIfcRelDefines {
    fn related_objects(&self) -> &HashSet<EntityRef>;
    fn relating_type(&self) -> &EntityRef;
}
#[derive(Default, Debug)]
pub struct IfcRelDefinesByType {
    global_id: IfcGloballyUniqueId,
    owner_history: Option<EntityRef>,
    name: Option<IfcLabel>,
    description: Option<IfcText>,
    related_objects: HashSet<EntityRef>,
    relating_type: EntityRef,
}
impl IIfcRoot for IfcRelDefinesByType {
    fn global_id(&self) -> &IfcGloballyUniqueId {
        &self.global_id
    }
    fn owner_history(&self) -> &Option<EntityRef> {
        &self.owner_history
    }
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
}
impl IIfcRelationship for IfcRelDefinesByType {}
impl IIfcRelDefines for IfcRelDefinesByType {}
impl IIfcRelDefinesByType for IfcRelDefinesByType {
    fn related_objects(&self) -> &HashSet<EntityRef> {
        &self.related_objects
    }
    fn relating_type(&self) -> &EntityRef {
        &self.relating_type
    }
}
impl IfcRelDefinesByType {
    pub fn from_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcRelDefinesByType::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.global_id = parameter.into(),
                1usize => {
                    entity.owner_history = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => entity.related_objects = parameter.into(),
                5usize => entity.relating_type = parameter.into(),
                _ => {}
            }
        }
        entity
    }
    pub fn from_own_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcRelDefinesByType::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.related_objects = parameter.into(),
                1usize => entity.relating_type = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcRelFillsElement: IIfcRelConnects {
    fn relating_opening_element(&self) -> &EntityRef;
    fn related_building_element(&self) -> &EntityRef;
}
#[derive(Default, Debug)]
pub struct IfcRelFillsElement {
    global_id: IfcGloballyUniqueId,
    owner_history: Option<EntityRef>,
    name: Option<IfcLabel>,
    description: Option<IfcText>,
    relating_opening_element: EntityRef,
    related_building_element: EntityRef,
}
impl IIfcRoot for IfcRelFillsElement {
    fn global_id(&self) -> &IfcGloballyUniqueId {
        &self.global_id
    }
    fn owner_history(&self) -> &Option<EntityRef> {
        &self.owner_history
    }
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
}
impl IIfcRelationship for IfcRelFillsElement {}
impl IIfcRelConnects for IfcRelFillsElement {}
impl IIfcRelFillsElement for IfcRelFillsElement {
    fn relating_opening_element(&self) -> &EntityRef {
        &self.relating_opening_element
    }
    fn related_building_element(&self) -> &EntityRef {
        &self.related_building_element
    }
}
impl IfcRelFillsElement {
    pub fn from_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcRelFillsElement::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.global_id = parameter.into(),
                1usize => {
                    entity.owner_history = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => entity.relating_opening_element = parameter.into(),
                5usize => entity.related_building_element = parameter.into(),
                _ => {}
            }
        }
        entity
    }
    pub fn from_own_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcRelFillsElement::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.relating_opening_element = parameter.into(),
                1usize => entity.related_building_element = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcRelFlowControlElements: IIfcRelConnects {
    fn related_control_elements(&self) -> &HashSet<EntityRef>;
    fn relating_flow_element(&self) -> &EntityRef;
}
#[derive(Default, Debug)]
pub struct IfcRelFlowControlElements {
    global_id: IfcGloballyUniqueId,
    owner_history: Option<EntityRef>,
    name: Option<IfcLabel>,
    description: Option<IfcText>,
    related_control_elements: HashSet<EntityRef>,
    relating_flow_element: EntityRef,
}
impl IIfcRoot for IfcRelFlowControlElements {
    fn global_id(&self) -> &IfcGloballyUniqueId {
        &self.global_id
    }
    fn owner_history(&self) -> &Option<EntityRef> {
        &self.owner_history
    }
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
}
impl IIfcRelationship for IfcRelFlowControlElements {}
impl IIfcRelConnects for IfcRelFlowControlElements {}
impl IIfcRelFlowControlElements for IfcRelFlowControlElements {
    fn related_control_elements(&self) -> &HashSet<EntityRef> {
        &self.related_control_elements
    }
    fn relating_flow_element(&self) -> &EntityRef {
        &self.relating_flow_element
    }
}
impl IfcRelFlowControlElements {
    pub fn from_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcRelFlowControlElements::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.global_id = parameter.into(),
                1usize => {
                    entity.owner_history = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => entity.related_control_elements = parameter.into(),
                5usize => entity.relating_flow_element = parameter.into(),
                _ => {}
            }
        }
        entity
    }
    pub fn from_own_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcRelFlowControlElements::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.related_control_elements = parameter.into(),
                1usize => entity.relating_flow_element = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcRelInterferesElements: IIfcRelConnects {
    fn relating_element(&self) -> &EntityRef;
    fn related_element(&self) -> &EntityRef;
    fn interference_geometry(&self) -> &Option<EntityRef>;
    fn interference_type(&self) -> &Option<IfcIdentifier>;
    fn implied_order(&self) -> Option<bool>;
}
#[derive(Default, Debug)]
pub struct IfcRelInterferesElements {
    global_id: IfcGloballyUniqueId,
    owner_history: Option<EntityRef>,
    name: Option<IfcLabel>,
    description: Option<IfcText>,
    relating_element: EntityRef,
    related_element: EntityRef,
    interference_geometry: Option<EntityRef>,
    interference_type: Option<IfcIdentifier>,
    implied_order: Option<bool>,
}
impl IIfcRoot for IfcRelInterferesElements {
    fn global_id(&self) -> &IfcGloballyUniqueId {
        &self.global_id
    }
    fn owner_history(&self) -> &Option<EntityRef> {
        &self.owner_history
    }
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
}
impl IIfcRelationship for IfcRelInterferesElements {}
impl IIfcRelConnects for IfcRelInterferesElements {}
impl IIfcRelInterferesElements for IfcRelInterferesElements {
    fn relating_element(&self) -> &EntityRef {
        &self.relating_element
    }
    fn related_element(&self) -> &EntityRef {
        &self.related_element
    }
    fn interference_geometry(&self) -> &Option<EntityRef> {
        &self.interference_geometry
    }
    fn interference_type(&self) -> &Option<IfcIdentifier> {
        &self.interference_type
    }
    fn implied_order(&self) -> Option<bool> {
        self.implied_order
    }
}
impl IfcRelInterferesElements {
    pub fn from_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcRelInterferesElements::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.global_id = parameter.into(),
                1usize => {
                    entity.owner_history = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => entity.relating_element = parameter.into(),
                5usize => entity.related_element = parameter.into(),
                6usize => {
                    entity.interference_geometry = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                7usize => {
                    entity.interference_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                8usize => entity.implied_order = parameter.into(),
                _ => {}
            }
        }
        entity
    }
    pub fn from_own_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcRelInterferesElements::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.relating_element = parameter.into(),
                1usize => entity.related_element = parameter.into(),
                2usize => {
                    entity.interference_geometry = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.interference_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => entity.implied_order = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcRelNests: IIfcRelDecomposes {
    fn relating_object(&self) -> &EntityRef;
    fn related_objects(&self) -> &Vec<EntityRef>;
}
#[derive(Default, Debug)]
pub struct IfcRelNests {
    global_id: IfcGloballyUniqueId,
    owner_history: Option<EntityRef>,
    name: Option<IfcLabel>,
    description: Option<IfcText>,
    relating_object: EntityRef,
    related_objects: Vec<EntityRef>,
}
impl IIfcRoot for IfcRelNests {
    fn global_id(&self) -> &IfcGloballyUniqueId {
        &self.global_id
    }
    fn owner_history(&self) -> &Option<EntityRef> {
        &self.owner_history
    }
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
}
impl IIfcRelationship for IfcRelNests {}
impl IIfcRelDecomposes for IfcRelNests {}
impl IIfcRelNests for IfcRelNests {
    fn relating_object(&self) -> &EntityRef {
        &self.relating_object
    }
    fn related_objects(&self) -> &Vec<EntityRef> {
        &self.related_objects
    }
}
impl IfcRelNests {
    pub fn from_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcRelNests::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.global_id = parameter.into(),
                1usize => {
                    entity.owner_history = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => entity.relating_object = parameter.into(),
                5usize => entity.related_objects = parameter.into(),
                _ => {}
            }
        }
        entity
    }
    pub fn from_own_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcRelNests::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.relating_object = parameter.into(),
                1usize => entity.related_objects = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcRelProjectsElement: IIfcRelDecomposes {
    fn relating_element(&self) -> &EntityRef;
    fn related_feature_element(&self) -> &EntityRef;
}
#[derive(Default, Debug)]
pub struct IfcRelProjectsElement {
    global_id: IfcGloballyUniqueId,
    owner_history: Option<EntityRef>,
    name: Option<IfcLabel>,
    description: Option<IfcText>,
    relating_element: EntityRef,
    related_feature_element: EntityRef,
}
impl IIfcRoot for IfcRelProjectsElement {
    fn global_id(&self) -> &IfcGloballyUniqueId {
        &self.global_id
    }
    fn owner_history(&self) -> &Option<EntityRef> {
        &self.owner_history
    }
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
}
impl IIfcRelationship for IfcRelProjectsElement {}
impl IIfcRelDecomposes for IfcRelProjectsElement {}
impl IIfcRelProjectsElement for IfcRelProjectsElement {
    fn relating_element(&self) -> &EntityRef {
        &self.relating_element
    }
    fn related_feature_element(&self) -> &EntityRef {
        &self.related_feature_element
    }
}
impl IfcRelProjectsElement {
    pub fn from_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcRelProjectsElement::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.global_id = parameter.into(),
                1usize => {
                    entity.owner_history = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => entity.relating_element = parameter.into(),
                5usize => entity.related_feature_element = parameter.into(),
                _ => {}
            }
        }
        entity
    }
    pub fn from_own_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcRelProjectsElement::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.relating_element = parameter.into(),
                1usize => entity.related_feature_element = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcRelReferencedInSpatialStructure: IIfcRelConnects {
    fn related_elements(&self) -> &HashSet<EntityRef>;
    fn relating_structure(&self) -> &EntityRef;
}
#[derive(Default, Debug)]
pub struct IfcRelReferencedInSpatialStructure {
    global_id: IfcGloballyUniqueId,
    owner_history: Option<EntityRef>,
    name: Option<IfcLabel>,
    description: Option<IfcText>,
    related_elements: HashSet<EntityRef>,
    relating_structure: EntityRef,
}
impl IIfcRoot for IfcRelReferencedInSpatialStructure {
    fn global_id(&self) -> &IfcGloballyUniqueId {
        &self.global_id
    }
    fn owner_history(&self) -> &Option<EntityRef> {
        &self.owner_history
    }
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
}
impl IIfcRelationship for IfcRelReferencedInSpatialStructure {}
impl IIfcRelConnects for IfcRelReferencedInSpatialStructure {}
impl IIfcRelReferencedInSpatialStructure for IfcRelReferencedInSpatialStructure {
    fn related_elements(&self) -> &HashSet<EntityRef> {
        &self.related_elements
    }
    fn relating_structure(&self) -> &EntityRef {
        &self.relating_structure
    }
}
impl IfcRelReferencedInSpatialStructure {
    pub fn from_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcRelReferencedInSpatialStructure::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.global_id = parameter.into(),
                1usize => {
                    entity.owner_history = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => entity.related_elements = parameter.into(),
                5usize => entity.relating_structure = parameter.into(),
                _ => {}
            }
        }
        entity
    }
    pub fn from_own_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcRelReferencedInSpatialStructure::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.related_elements = parameter.into(),
                1usize => entity.relating_structure = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcRelSequence: IIfcRelConnects {
    fn relating_process(&self) -> &EntityRef;
    fn related_process(&self) -> &EntityRef;
    fn time_lag(&self) -> &Option<EntityRef>;
    fn sequence_type(&self) -> &Option<IfcSequenceEnum>;
    fn user_defined_sequence_type(&self) -> &Option<IfcLabel>;
}
#[derive(Default, Debug)]
pub struct IfcRelSequence {
    global_id: IfcGloballyUniqueId,
    owner_history: Option<EntityRef>,
    name: Option<IfcLabel>,
    description: Option<IfcText>,
    relating_process: EntityRef,
    related_process: EntityRef,
    time_lag: Option<EntityRef>,
    sequence_type: Option<IfcSequenceEnum>,
    user_defined_sequence_type: Option<IfcLabel>,
}
impl IIfcRoot for IfcRelSequence {
    fn global_id(&self) -> &IfcGloballyUniqueId {
        &self.global_id
    }
    fn owner_history(&self) -> &Option<EntityRef> {
        &self.owner_history
    }
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
}
impl IIfcRelationship for IfcRelSequence {}
impl IIfcRelConnects for IfcRelSequence {}
impl IIfcRelSequence for IfcRelSequence {
    fn relating_process(&self) -> &EntityRef {
        &self.relating_process
    }
    fn related_process(&self) -> &EntityRef {
        &self.related_process
    }
    fn time_lag(&self) -> &Option<EntityRef> {
        &self.time_lag
    }
    fn sequence_type(&self) -> &Option<IfcSequenceEnum> {
        &self.sequence_type
    }
    fn user_defined_sequence_type(&self) -> &Option<IfcLabel> {
        &self.user_defined_sequence_type
    }
}
impl IfcRelSequence {
    pub fn from_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcRelSequence::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.global_id = parameter.into(),
                1usize => {
                    entity.owner_history = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => entity.relating_process = parameter.into(),
                5usize => entity.related_process = parameter.into(),
                6usize => {
                    entity.time_lag = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                7usize => {
                    entity.sequence_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                8usize => {
                    entity.user_defined_sequence_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
    pub fn from_own_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcRelSequence::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.relating_process = parameter.into(),
                1usize => entity.related_process = parameter.into(),
                2usize => {
                    entity.time_lag = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.sequence_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => {
                    entity.user_defined_sequence_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcRelServicesBuildings: IIfcRelConnects {
    fn relating_system(&self) -> &EntityRef;
    fn related_buildings(&self) -> &HashSet<EntityRef>;
}
#[derive(Default, Debug)]
pub struct IfcRelServicesBuildings {
    global_id: IfcGloballyUniqueId,
    owner_history: Option<EntityRef>,
    name: Option<IfcLabel>,
    description: Option<IfcText>,
    relating_system: EntityRef,
    related_buildings: HashSet<EntityRef>,
}
impl IIfcRoot for IfcRelServicesBuildings {
    fn global_id(&self) -> &IfcGloballyUniqueId {
        &self.global_id
    }
    fn owner_history(&self) -> &Option<EntityRef> {
        &self.owner_history
    }
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
}
impl IIfcRelationship for IfcRelServicesBuildings {}
impl IIfcRelConnects for IfcRelServicesBuildings {}
impl IIfcRelServicesBuildings for IfcRelServicesBuildings {
    fn relating_system(&self) -> &EntityRef {
        &self.relating_system
    }
    fn related_buildings(&self) -> &HashSet<EntityRef> {
        &self.related_buildings
    }
}
impl IfcRelServicesBuildings {
    pub fn from_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcRelServicesBuildings::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.global_id = parameter.into(),
                1usize => {
                    entity.owner_history = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => entity.relating_system = parameter.into(),
                5usize => entity.related_buildings = parameter.into(),
                _ => {}
            }
        }
        entity
    }
    pub fn from_own_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcRelServicesBuildings::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.relating_system = parameter.into(),
                1usize => entity.related_buildings = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcRelSpaceBoundary: IIfcRelConnects {
    fn relating_space(&self) -> &EntityRef;
    fn related_building_element(&self) -> &EntityRef;
    fn connection_geometry(&self) -> &Option<EntityRef>;
    fn physical_or_virtual_boundary(&self) -> &IfcPhysicalOrVirtualEnum;
    fn internal_or_external_boundary(&self) -> &IfcInternalOrExternalEnum;
}
#[derive(Default, Debug)]
pub struct IfcRelSpaceBoundary {
    global_id: IfcGloballyUniqueId,
    owner_history: Option<EntityRef>,
    name: Option<IfcLabel>,
    description: Option<IfcText>,
    relating_space: EntityRef,
    related_building_element: EntityRef,
    connection_geometry: Option<EntityRef>,
    physical_or_virtual_boundary: IfcPhysicalOrVirtualEnum,
    internal_or_external_boundary: IfcInternalOrExternalEnum,
}
impl IIfcRoot for IfcRelSpaceBoundary {
    fn global_id(&self) -> &IfcGloballyUniqueId {
        &self.global_id
    }
    fn owner_history(&self) -> &Option<EntityRef> {
        &self.owner_history
    }
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
}
impl IIfcRelationship for IfcRelSpaceBoundary {}
impl IIfcRelConnects for IfcRelSpaceBoundary {}
impl IIfcRelSpaceBoundary for IfcRelSpaceBoundary {
    fn relating_space(&self) -> &EntityRef {
        &self.relating_space
    }
    fn related_building_element(&self) -> &EntityRef {
        &self.related_building_element
    }
    fn connection_geometry(&self) -> &Option<EntityRef> {
        &self.connection_geometry
    }
    fn physical_or_virtual_boundary(&self) -> &IfcPhysicalOrVirtualEnum {
        &self.physical_or_virtual_boundary
    }
    fn internal_or_external_boundary(&self) -> &IfcInternalOrExternalEnum {
        &self.internal_or_external_boundary
    }
}
impl IfcRelSpaceBoundary {
    pub fn from_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcRelSpaceBoundary::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.global_id = parameter.into(),
                1usize => {
                    entity.owner_history = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => entity.relating_space = parameter.into(),
                5usize => entity.related_building_element = parameter.into(),
                6usize => {
                    entity.connection_geometry = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                7usize => entity.physical_or_virtual_boundary = parameter.into(),
                8usize => entity.internal_or_external_boundary = parameter.into(),
                _ => {}
            }
        }
        entity
    }
    pub fn from_own_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcRelSpaceBoundary::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.relating_space = parameter.into(),
                1usize => entity.related_building_element = parameter.into(),
                2usize => {
                    entity.connection_geometry = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => entity.physical_or_virtual_boundary = parameter.into(),
                4usize => entity.internal_or_external_boundary = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcRelSpaceBoundary1stLevel: IIfcRelSpaceBoundary {
    fn parent_boundary(&self) -> &Option<EntityRef>;
}
#[derive(Default, Debug)]
pub struct IfcRelSpaceBoundary1stLevel {
    global_id: IfcGloballyUniqueId,
    owner_history: Option<EntityRef>,
    name: Option<IfcLabel>,
    description: Option<IfcText>,
    relating_space: EntityRef,
    related_building_element: EntityRef,
    connection_geometry: Option<EntityRef>,
    physical_or_virtual_boundary: IfcPhysicalOrVirtualEnum,
    internal_or_external_boundary: IfcInternalOrExternalEnum,
    parent_boundary: Option<EntityRef>,
}
impl IIfcRoot for IfcRelSpaceBoundary1stLevel {
    fn global_id(&self) -> &IfcGloballyUniqueId {
        &self.global_id
    }
    fn owner_history(&self) -> &Option<EntityRef> {
        &self.owner_history
    }
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
}
impl IIfcRelationship for IfcRelSpaceBoundary1stLevel {}
impl IIfcRelConnects for IfcRelSpaceBoundary1stLevel {}
impl IIfcRelSpaceBoundary for IfcRelSpaceBoundary1stLevel {
    fn relating_space(&self) -> &EntityRef {
        &self.relating_space
    }
    fn related_building_element(&self) -> &EntityRef {
        &self.related_building_element
    }
    fn connection_geometry(&self) -> &Option<EntityRef> {
        &self.connection_geometry
    }
    fn physical_or_virtual_boundary(&self) -> &IfcPhysicalOrVirtualEnum {
        &self.physical_or_virtual_boundary
    }
    fn internal_or_external_boundary(&self) -> &IfcInternalOrExternalEnum {
        &self.internal_or_external_boundary
    }
}
impl IIfcRelSpaceBoundary1stLevel for IfcRelSpaceBoundary1stLevel {
    fn parent_boundary(&self) -> &Option<EntityRef> {
        &self.parent_boundary
    }
}
impl IfcRelSpaceBoundary1stLevel {
    pub fn from_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcRelSpaceBoundary1stLevel::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.global_id = parameter.into(),
                1usize => {
                    entity.owner_history = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => entity.relating_space = parameter.into(),
                5usize => entity.related_building_element = parameter.into(),
                6usize => {
                    entity.connection_geometry = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                7usize => entity.physical_or_virtual_boundary = parameter.into(),
                8usize => entity.internal_or_external_boundary = parameter.into(),
                9usize => {
                    entity.parent_boundary = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
    pub fn from_own_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcRelSpaceBoundary1stLevel::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => {
                    entity.parent_boundary = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcRelSpaceBoundary2ndLevel: IIfcRelSpaceBoundary1stLevel {
    fn corresponding_boundary(&self) -> &Option<EntityRef>;
}
#[derive(Default, Debug)]
pub struct IfcRelSpaceBoundary2ndLevel {
    global_id: IfcGloballyUniqueId,
    owner_history: Option<EntityRef>,
    name: Option<IfcLabel>,
    description: Option<IfcText>,
    relating_space: EntityRef,
    related_building_element: EntityRef,
    connection_geometry: Option<EntityRef>,
    physical_or_virtual_boundary: IfcPhysicalOrVirtualEnum,
    internal_or_external_boundary: IfcInternalOrExternalEnum,
    parent_boundary: Option<EntityRef>,
    corresponding_boundary: Option<EntityRef>,
}
impl IIfcRoot for IfcRelSpaceBoundary2ndLevel {
    fn global_id(&self) -> &IfcGloballyUniqueId {
        &self.global_id
    }
    fn owner_history(&self) -> &Option<EntityRef> {
        &self.owner_history
    }
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
}
impl IIfcRelationship for IfcRelSpaceBoundary2ndLevel {}
impl IIfcRelConnects for IfcRelSpaceBoundary2ndLevel {}
impl IIfcRelSpaceBoundary for IfcRelSpaceBoundary2ndLevel {
    fn relating_space(&self) -> &EntityRef {
        &self.relating_space
    }
    fn related_building_element(&self) -> &EntityRef {
        &self.related_building_element
    }
    fn connection_geometry(&self) -> &Option<EntityRef> {
        &self.connection_geometry
    }
    fn physical_or_virtual_boundary(&self) -> &IfcPhysicalOrVirtualEnum {
        &self.physical_or_virtual_boundary
    }
    fn internal_or_external_boundary(&self) -> &IfcInternalOrExternalEnum {
        &self.internal_or_external_boundary
    }
}
impl IIfcRelSpaceBoundary1stLevel for IfcRelSpaceBoundary2ndLevel {
    fn parent_boundary(&self) -> &Option<EntityRef> {
        &self.parent_boundary
    }
}
impl IIfcRelSpaceBoundary2ndLevel for IfcRelSpaceBoundary2ndLevel {
    fn corresponding_boundary(&self) -> &Option<EntityRef> {
        &self.corresponding_boundary
    }
}
impl IfcRelSpaceBoundary2ndLevel {
    pub fn from_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcRelSpaceBoundary2ndLevel::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.global_id = parameter.into(),
                1usize => {
                    entity.owner_history = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => entity.relating_space = parameter.into(),
                5usize => entity.related_building_element = parameter.into(),
                6usize => {
                    entity.connection_geometry = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                7usize => entity.physical_or_virtual_boundary = parameter.into(),
                8usize => entity.internal_or_external_boundary = parameter.into(),
                9usize => {
                    entity.parent_boundary = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                10usize => {
                    entity.corresponding_boundary = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
    pub fn from_own_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcRelSpaceBoundary2ndLevel::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => {
                    entity.corresponding_boundary = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcRelVoidsElement: IIfcRelDecomposes {
    fn relating_building_element(&self) -> &EntityRef;
    fn related_opening_element(&self) -> &EntityRef;
}
#[derive(Default, Debug)]
pub struct IfcRelVoidsElement {
    global_id: IfcGloballyUniqueId,
    owner_history: Option<EntityRef>,
    name: Option<IfcLabel>,
    description: Option<IfcText>,
    relating_building_element: EntityRef,
    related_opening_element: EntityRef,
}
impl IIfcRoot for IfcRelVoidsElement {
    fn global_id(&self) -> &IfcGloballyUniqueId {
        &self.global_id
    }
    fn owner_history(&self) -> &Option<EntityRef> {
        &self.owner_history
    }
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
}
impl IIfcRelationship for IfcRelVoidsElement {}
impl IIfcRelDecomposes for IfcRelVoidsElement {}
impl IIfcRelVoidsElement for IfcRelVoidsElement {
    fn relating_building_element(&self) -> &EntityRef {
        &self.relating_building_element
    }
    fn related_opening_element(&self) -> &EntityRef {
        &self.related_opening_element
    }
}
impl IfcRelVoidsElement {
    pub fn from_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcRelVoidsElement::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.global_id = parameter.into(),
                1usize => {
                    entity.owner_history = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => entity.relating_building_element = parameter.into(),
                5usize => entity.related_opening_element = parameter.into(),
                _ => {}
            }
        }
        entity
    }
    pub fn from_own_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcRelVoidsElement::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.relating_building_element = parameter.into(),
                1usize => entity.related_opening_element = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcRelationship: IIfcRoot {}
pub trait IIfcReparametrisedCompositeCurveSegment: IIfcCompositeCurveSegment {
    fn param_length(&self) -> &IfcParameterValue;
}
#[derive(Default, Debug)]
pub struct IfcReparametrisedCompositeCurveSegment {
    transition: IfcTransitionCode,
    same_sense: IfcBoolean,
    parent_curve: EntityRef,
    param_length: IfcParameterValue,
}
impl IIfcRepresentationItem for IfcReparametrisedCompositeCurveSegment {}
impl IIfcGeometricRepresentationItem for IfcReparametrisedCompositeCurveSegment {}
impl IIfcCompositeCurveSegment for IfcReparametrisedCompositeCurveSegment {
    fn transition(&self) -> &IfcTransitionCode {
        &self.transition
    }
    fn same_sense(&self) -> &IfcBoolean {
        &self.same_sense
    }
    fn parent_curve(&self) -> &EntityRef {
        &self.parent_curve
    }
}
impl IIfcReparametrisedCompositeCurveSegment for IfcReparametrisedCompositeCurveSegment {
    fn param_length(&self) -> &IfcParameterValue {
        &self.param_length
    }
}
impl IfcReparametrisedCompositeCurveSegment {
    pub fn from_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcReparametrisedCompositeCurveSegment::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.transition = parameter.into(),
                1usize => entity.same_sense = parameter.into(),
                2usize => entity.parent_curve = parameter.into(),
                3usize => entity.param_length = parameter.into(),
                _ => {}
            }
        }
        entity
    }
    pub fn from_own_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcReparametrisedCompositeCurveSegment::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.param_length = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcRepresentation {
    fn context_of_items(&self) -> &EntityRef;
    fn representation_identifier(&self) -> &Option<IfcLabel>;
    fn representation_type(&self) -> &Option<IfcLabel>;
    fn items(&self) -> &HashSet<EntityRef>;
}
pub trait IIfcRepresentationContext {
    fn context_identifier(&self) -> &Option<IfcLabel>;
    fn context_type(&self) -> &Option<IfcLabel>;
}
pub trait IIfcRepresentationItem {}
pub trait IIfcRepresentationMap {
    fn mapping_origin(&self) -> &EntityRef;
    fn mapped_representation(&self) -> &EntityRef;
}
#[derive(Default, Debug)]
pub struct IfcRepresentationMap {
    mapping_origin: EntityRef,
    mapped_representation: EntityRef,
}
impl IIfcRepresentationMap for IfcRepresentationMap {
    fn mapping_origin(&self) -> &EntityRef {
        &self.mapping_origin
    }
    fn mapped_representation(&self) -> &EntityRef {
        &self.mapped_representation
    }
}
impl IfcRepresentationMap {
    pub fn from_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcRepresentationMap::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.mapping_origin = parameter.into(),
                1usize => entity.mapped_representation = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcResource: IIfcObject {
    fn identification(&self) -> &Option<IfcIdentifier>;
    fn long_description(&self) -> &Option<IfcText>;
}
pub trait IIfcResourceApprovalRelationship: IIfcResourceLevelRelationship {
    fn related_resource_objects(&self) -> &HashSet<EntityRef>;
    fn relating_approval(&self) -> &EntityRef;
}
#[derive(Default, Debug)]
pub struct IfcResourceApprovalRelationship {
    name: Option<IfcLabel>,
    description: Option<IfcText>,
    related_resource_objects: HashSet<EntityRef>,
    relating_approval: EntityRef,
}
impl IIfcResourceLevelRelationship for IfcResourceApprovalRelationship {
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
}
impl IIfcResourceApprovalRelationship for IfcResourceApprovalRelationship {
    fn related_resource_objects(&self) -> &HashSet<EntityRef> {
        &self.related_resource_objects
    }
    fn relating_approval(&self) -> &EntityRef {
        &self.relating_approval
    }
}
impl IfcResourceApprovalRelationship {
    pub fn from_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcResourceApprovalRelationship::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                1usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => entity.related_resource_objects = parameter.into(),
                3usize => entity.relating_approval = parameter.into(),
                _ => {}
            }
        }
        entity
    }
    pub fn from_own_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcResourceApprovalRelationship::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.related_resource_objects = parameter.into(),
                1usize => entity.relating_approval = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcResourceConstraintRelationship: IIfcResourceLevelRelationship {
    fn relating_constraint(&self) -> &EntityRef;
    fn related_resource_objects(&self) -> &HashSet<EntityRef>;
}
#[derive(Default, Debug)]
pub struct IfcResourceConstraintRelationship {
    name: Option<IfcLabel>,
    description: Option<IfcText>,
    relating_constraint: EntityRef,
    related_resource_objects: HashSet<EntityRef>,
}
impl IIfcResourceLevelRelationship for IfcResourceConstraintRelationship {
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
}
impl IIfcResourceConstraintRelationship for IfcResourceConstraintRelationship {
    fn relating_constraint(&self) -> &EntityRef {
        &self.relating_constraint
    }
    fn related_resource_objects(&self) -> &HashSet<EntityRef> {
        &self.related_resource_objects
    }
}
impl IfcResourceConstraintRelationship {
    pub fn from_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcResourceConstraintRelationship::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                1usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => entity.relating_constraint = parameter.into(),
                3usize => entity.related_resource_objects = parameter.into(),
                _ => {}
            }
        }
        entity
    }
    pub fn from_own_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcResourceConstraintRelationship::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.relating_constraint = parameter.into(),
                1usize => entity.related_resource_objects = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcResourceLevelRelationship {
    fn name(&self) -> &Option<IfcLabel>;
    fn description(&self) -> &Option<IfcText>;
}
pub trait IIfcResourceTime: IIfcSchedulingTime {
    fn schedule_work(&self) -> &Option<IfcDuration>;
    fn schedule_usage(&self) -> &Option<IfcPositiveRatioMeasure>;
    fn schedule_start(&self) -> &Option<IfcDateTime>;
    fn schedule_finish(&self) -> &Option<IfcDateTime>;
    fn schedule_contour(&self) -> &Option<IfcLabel>;
    fn leveling_delay(&self) -> &Option<IfcDuration>;
    fn is_over_allocated(&self) -> &Option<IfcBoolean>;
    fn status_time(&self) -> &Option<IfcDateTime>;
    fn actual_work(&self) -> &Option<IfcDuration>;
    fn actual_usage(&self) -> &Option<IfcPositiveRatioMeasure>;
    fn actual_start(&self) -> &Option<IfcDateTime>;
    fn actual_finish(&self) -> &Option<IfcDateTime>;
    fn remaining_work(&self) -> &Option<IfcDuration>;
    fn remaining_usage(&self) -> &Option<IfcPositiveRatioMeasure>;
    fn completion(&self) -> &Option<IfcPositiveRatioMeasure>;
}
#[derive(Default, Debug)]
pub struct IfcResourceTime {
    name: Option<IfcLabel>,
    data_origin: Option<IfcDataOriginEnum>,
    user_defined_data_origin: Option<IfcLabel>,
    schedule_work: Option<IfcDuration>,
    schedule_usage: Option<IfcPositiveRatioMeasure>,
    schedule_start: Option<IfcDateTime>,
    schedule_finish: Option<IfcDateTime>,
    schedule_contour: Option<IfcLabel>,
    leveling_delay: Option<IfcDuration>,
    is_over_allocated: Option<IfcBoolean>,
    status_time: Option<IfcDateTime>,
    actual_work: Option<IfcDuration>,
    actual_usage: Option<IfcPositiveRatioMeasure>,
    actual_start: Option<IfcDateTime>,
    actual_finish: Option<IfcDateTime>,
    remaining_work: Option<IfcDuration>,
    remaining_usage: Option<IfcPositiveRatioMeasure>,
    completion: Option<IfcPositiveRatioMeasure>,
}
impl IIfcSchedulingTime for IfcResourceTime {
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
    fn data_origin(&self) -> &Option<IfcDataOriginEnum> {
        &self.data_origin
    }
    fn user_defined_data_origin(&self) -> &Option<IfcLabel> {
        &self.user_defined_data_origin
    }
}
impl IIfcResourceTime for IfcResourceTime {
    fn schedule_work(&self) -> &Option<IfcDuration> {
        &self.schedule_work
    }
    fn schedule_usage(&self) -> &Option<IfcPositiveRatioMeasure> {
        &self.schedule_usage
    }
    fn schedule_start(&self) -> &Option<IfcDateTime> {
        &self.schedule_start
    }
    fn schedule_finish(&self) -> &Option<IfcDateTime> {
        &self.schedule_finish
    }
    fn schedule_contour(&self) -> &Option<IfcLabel> {
        &self.schedule_contour
    }
    fn leveling_delay(&self) -> &Option<IfcDuration> {
        &self.leveling_delay
    }
    fn is_over_allocated(&self) -> &Option<IfcBoolean> {
        &self.is_over_allocated
    }
    fn status_time(&self) -> &Option<IfcDateTime> {
        &self.status_time
    }
    fn actual_work(&self) -> &Option<IfcDuration> {
        &self.actual_work
    }
    fn actual_usage(&self) -> &Option<IfcPositiveRatioMeasure> {
        &self.actual_usage
    }
    fn actual_start(&self) -> &Option<IfcDateTime> {
        &self.actual_start
    }
    fn actual_finish(&self) -> &Option<IfcDateTime> {
        &self.actual_finish
    }
    fn remaining_work(&self) -> &Option<IfcDuration> {
        &self.remaining_work
    }
    fn remaining_usage(&self) -> &Option<IfcPositiveRatioMeasure> {
        &self.remaining_usage
    }
    fn completion(&self) -> &Option<IfcPositiveRatioMeasure> {
        &self.completion
    }
}
impl IfcResourceTime {
    pub fn from_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcResourceTime::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                1usize => {
                    entity.data_origin = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => {
                    entity.user_defined_data_origin = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.schedule_work = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => {
                    entity.schedule_usage = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                5usize => {
                    entity.schedule_start = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                6usize => {
                    entity.schedule_finish = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                7usize => {
                    entity.schedule_contour = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                8usize => {
                    entity.leveling_delay = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                9usize => {
                    entity.is_over_allocated = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                10usize => {
                    entity.status_time = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                11usize => {
                    entity.actual_work = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                12usize => {
                    entity.actual_usage = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                13usize => {
                    entity.actual_start = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                14usize => {
                    entity.actual_finish = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                15usize => {
                    entity.remaining_work = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                16usize => {
                    entity.remaining_usage = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                17usize => {
                    entity.completion = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
    pub fn from_own_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcResourceTime::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => {
                    entity.schedule_work = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                1usize => {
                    entity.schedule_usage = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => {
                    entity.schedule_start = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.schedule_finish = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => {
                    entity.schedule_contour = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                5usize => {
                    entity.leveling_delay = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                6usize => {
                    entity.is_over_allocated = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                7usize => {
                    entity.status_time = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                8usize => {
                    entity.actual_work = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                9usize => {
                    entity.actual_usage = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                10usize => {
                    entity.actual_start = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                11usize => {
                    entity.actual_finish = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                12usize => {
                    entity.remaining_work = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                13usize => {
                    entity.remaining_usage = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                14usize => {
                    entity.completion = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcRevolvedAreaSolid: IIfcSweptAreaSolid {
    fn axis(&self) -> &EntityRef;
    fn angle(&self) -> &IfcPlaneAngleMeasure;
}
#[derive(Default, Debug)]
pub struct IfcRevolvedAreaSolid {
    swept_area: EntityRef,
    position: Option<EntityRef>,
    axis: EntityRef,
    angle: IfcPlaneAngleMeasure,
}
impl IIfcRepresentationItem for IfcRevolvedAreaSolid {}
impl IIfcGeometricRepresentationItem for IfcRevolvedAreaSolid {}
impl IIfcSolidModel for IfcRevolvedAreaSolid {}
impl IIfcSweptAreaSolid for IfcRevolvedAreaSolid {
    fn swept_area(&self) -> &EntityRef {
        &self.swept_area
    }
    fn position(&self) -> &Option<EntityRef> {
        &self.position
    }
}
impl IIfcRevolvedAreaSolid for IfcRevolvedAreaSolid {
    fn axis(&self) -> &EntityRef {
        &self.axis
    }
    fn angle(&self) -> &IfcPlaneAngleMeasure {
        &self.angle
    }
}
impl IfcRevolvedAreaSolid {
    pub fn from_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcRevolvedAreaSolid::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.swept_area = parameter.into(),
                1usize => {
                    entity.position = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => entity.axis = parameter.into(),
                3usize => entity.angle = parameter.into(),
                _ => {}
            }
        }
        entity
    }
    pub fn from_own_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcRevolvedAreaSolid::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.axis = parameter.into(),
                1usize => entity.angle = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcRevolvedAreaSolidTapered: IIfcRevolvedAreaSolid {
    fn end_swept_area(&self) -> &EntityRef;
}
#[derive(Default, Debug)]
pub struct IfcRevolvedAreaSolidTapered {
    swept_area: EntityRef,
    position: Option<EntityRef>,
    axis: EntityRef,
    angle: IfcPlaneAngleMeasure,
    end_swept_area: EntityRef,
}
impl IIfcRepresentationItem for IfcRevolvedAreaSolidTapered {}
impl IIfcGeometricRepresentationItem for IfcRevolvedAreaSolidTapered {}
impl IIfcSolidModel for IfcRevolvedAreaSolidTapered {}
impl IIfcSweptAreaSolid for IfcRevolvedAreaSolidTapered {
    fn swept_area(&self) -> &EntityRef {
        &self.swept_area
    }
    fn position(&self) -> &Option<EntityRef> {
        &self.position
    }
}
impl IIfcRevolvedAreaSolid for IfcRevolvedAreaSolidTapered {
    fn axis(&self) -> &EntityRef {
        &self.axis
    }
    fn angle(&self) -> &IfcPlaneAngleMeasure {
        &self.angle
    }
}
impl IIfcRevolvedAreaSolidTapered for IfcRevolvedAreaSolidTapered {
    fn end_swept_area(&self) -> &EntityRef {
        &self.end_swept_area
    }
}
impl IfcRevolvedAreaSolidTapered {
    pub fn from_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcRevolvedAreaSolidTapered::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.swept_area = parameter.into(),
                1usize => {
                    entity.position = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => entity.axis = parameter.into(),
                3usize => entity.angle = parameter.into(),
                4usize => entity.end_swept_area = parameter.into(),
                _ => {}
            }
        }
        entity
    }
    pub fn from_own_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcRevolvedAreaSolidTapered::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.end_swept_area = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcRightCircularCone: IIfcCsgPrimitive3D {
    fn height(&self) -> &IfcPositiveLengthMeasure;
    fn bottom_radius(&self) -> &IfcPositiveLengthMeasure;
}
#[derive(Default, Debug)]
pub struct IfcRightCircularCone {
    position: EntityRef,
    height: IfcPositiveLengthMeasure,
    bottom_radius: IfcPositiveLengthMeasure,
}
impl IIfcRepresentationItem for IfcRightCircularCone {}
impl IIfcGeometricRepresentationItem for IfcRightCircularCone {}
impl IIfcCsgPrimitive3D for IfcRightCircularCone {
    fn position(&self) -> &EntityRef {
        &self.position
    }
}
impl IIfcRightCircularCone for IfcRightCircularCone {
    fn height(&self) -> &IfcPositiveLengthMeasure {
        &self.height
    }
    fn bottom_radius(&self) -> &IfcPositiveLengthMeasure {
        &self.bottom_radius
    }
}
impl IfcRightCircularCone {
    pub fn from_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcRightCircularCone::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.position = parameter.into(),
                1usize => entity.height = parameter.into(),
                2usize => entity.bottom_radius = parameter.into(),
                _ => {}
            }
        }
        entity
    }
    pub fn from_own_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcRightCircularCone::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.height = parameter.into(),
                1usize => entity.bottom_radius = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcRightCircularCylinder: IIfcCsgPrimitive3D {
    fn height(&self) -> &IfcPositiveLengthMeasure;
    fn radius(&self) -> &IfcPositiveLengthMeasure;
}
#[derive(Default, Debug)]
pub struct IfcRightCircularCylinder {
    position: EntityRef,
    height: IfcPositiveLengthMeasure,
    radius: IfcPositiveLengthMeasure,
}
impl IIfcRepresentationItem for IfcRightCircularCylinder {}
impl IIfcGeometricRepresentationItem for IfcRightCircularCylinder {}
impl IIfcCsgPrimitive3D for IfcRightCircularCylinder {
    fn position(&self) -> &EntityRef {
        &self.position
    }
}
impl IIfcRightCircularCylinder for IfcRightCircularCylinder {
    fn height(&self) -> &IfcPositiveLengthMeasure {
        &self.height
    }
    fn radius(&self) -> &IfcPositiveLengthMeasure {
        &self.radius
    }
}
impl IfcRightCircularCylinder {
    pub fn from_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcRightCircularCylinder::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.position = parameter.into(),
                1usize => entity.height = parameter.into(),
                2usize => entity.radius = parameter.into(),
                _ => {}
            }
        }
        entity
    }
    pub fn from_own_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcRightCircularCylinder::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.height = parameter.into(),
                1usize => entity.radius = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcRoof: IIfcBuildingElement {
    fn predefined_type(&self) -> &Option<IfcRoofTypeEnum>;
}
#[derive(Default, Debug)]
pub struct IfcRoof {
    global_id: IfcGloballyUniqueId,
    owner_history: Option<EntityRef>,
    name: Option<IfcLabel>,
    description: Option<IfcText>,
    object_type: Option<IfcLabel>,
    object_placement: Option<EntityRef>,
    representation: Option<EntityRef>,
    tag: Option<IfcIdentifier>,
    predefined_type: Option<IfcRoofTypeEnum>,
}
impl IIfcRoot for IfcRoof {
    fn global_id(&self) -> &IfcGloballyUniqueId {
        &self.global_id
    }
    fn owner_history(&self) -> &Option<EntityRef> {
        &self.owner_history
    }
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
}
impl IIfcObjectDefinition for IfcRoof {}
impl IIfcObject for IfcRoof {
    fn object_type(&self) -> &Option<IfcLabel> {
        &self.object_type
    }
}
impl IIfcProduct for IfcRoof {
    fn object_placement(&self) -> &Option<EntityRef> {
        &self.object_placement
    }
    fn representation(&self) -> &Option<EntityRef> {
        &self.representation
    }
}
impl IIfcElement for IfcRoof {
    fn tag(&self) -> &Option<IfcIdentifier> {
        &self.tag
    }
}
impl IIfcBuildingElement for IfcRoof {}
impl IIfcRoof for IfcRoof {
    fn predefined_type(&self) -> &Option<IfcRoofTypeEnum> {
        &self.predefined_type
    }
}
impl IfcRoof {
    pub fn from_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcRoof::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.global_id = parameter.into(),
                1usize => {
                    entity.owner_history = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => {
                    entity.object_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                5usize => {
                    entity.object_placement = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                6usize => {
                    entity.representation = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                7usize => {
                    entity.tag = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                8usize => {
                    entity.predefined_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
    pub fn from_own_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcRoof::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => {
                    entity.predefined_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcRoofType: IIfcBuildingElementType {
    fn predefined_type(&self) -> &IfcRoofTypeEnum;
}
#[derive(Default, Debug)]
pub struct IfcRoofType {
    global_id: IfcGloballyUniqueId,
    owner_history: Option<EntityRef>,
    name: Option<IfcLabel>,
    description: Option<IfcText>,
    applicable_occurrence: Option<IfcIdentifier>,
    has_property_sets: Option<HashSet<EntityRef>>,
    representation_maps: Option<Vec<EntityRef>>,
    tag: Option<IfcLabel>,
    element_type: Option<IfcLabel>,
    predefined_type: IfcRoofTypeEnum,
}
impl IIfcRoot for IfcRoofType {
    fn global_id(&self) -> &IfcGloballyUniqueId {
        &self.global_id
    }
    fn owner_history(&self) -> &Option<EntityRef> {
        &self.owner_history
    }
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
}
impl IIfcObjectDefinition for IfcRoofType {}
impl IIfcTypeObject for IfcRoofType {
    fn applicable_occurrence(&self) -> &Option<IfcIdentifier> {
        &self.applicable_occurrence
    }
    fn has_property_sets(&self) -> &Option<HashSet<EntityRef>> {
        &self.has_property_sets
    }
}
impl IIfcTypeProduct for IfcRoofType {
    fn representation_maps(&self) -> &Option<Vec<EntityRef>> {
        &self.representation_maps
    }
    fn tag(&self) -> &Option<IfcLabel> {
        &self.tag
    }
}
impl IIfcElementType for IfcRoofType {
    fn element_type(&self) -> &Option<IfcLabel> {
        &self.element_type
    }
}
impl IIfcBuildingElementType for IfcRoofType {}
impl IIfcRoofType for IfcRoofType {
    fn predefined_type(&self) -> &IfcRoofTypeEnum {
        &self.predefined_type
    }
}
impl IfcRoofType {
    pub fn from_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcRoofType::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.global_id = parameter.into(),
                1usize => {
                    entity.owner_history = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => {
                    entity.applicable_occurrence = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                5usize => {
                    entity.has_property_sets = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                6usize => {
                    entity.representation_maps = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                7usize => {
                    entity.tag = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                8usize => {
                    entity.element_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                9usize => entity.predefined_type = parameter.into(),
                _ => {}
            }
        }
        entity
    }
    pub fn from_own_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcRoofType::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.predefined_type = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcRoot {
    fn global_id(&self) -> &IfcGloballyUniqueId;
    fn owner_history(&self) -> &Option<EntityRef>;
    fn name(&self) -> &Option<IfcLabel>;
    fn description(&self) -> &Option<IfcText>;
}
pub trait IIfcRoundedRectangleProfileDef: IIfcRectangleProfileDef {
    fn rounding_radius(&self) -> &IfcPositiveLengthMeasure;
}
#[derive(Default, Debug)]
pub struct IfcRoundedRectangleProfileDef {
    profile_type: IfcProfileTypeEnum,
    profile_name: Option<IfcLabel>,
    position: Option<EntityRef>,
    x_dim: IfcPositiveLengthMeasure,
    y_dim: IfcPositiveLengthMeasure,
    rounding_radius: IfcPositiveLengthMeasure,
}
impl IIfcProfileDef for IfcRoundedRectangleProfileDef {
    fn profile_type(&self) -> &IfcProfileTypeEnum {
        &self.profile_type
    }
    fn profile_name(&self) -> &Option<IfcLabel> {
        &self.profile_name
    }
}
impl IIfcParameterizedProfileDef for IfcRoundedRectangleProfileDef {
    fn position(&self) -> &Option<EntityRef> {
        &self.position
    }
}
impl IIfcRectangleProfileDef for IfcRoundedRectangleProfileDef {
    fn x_dim(&self) -> &IfcPositiveLengthMeasure {
        &self.x_dim
    }
    fn y_dim(&self) -> &IfcPositiveLengthMeasure {
        &self.y_dim
    }
}
impl IIfcRoundedRectangleProfileDef for IfcRoundedRectangleProfileDef {
    fn rounding_radius(&self) -> &IfcPositiveLengthMeasure {
        &self.rounding_radius
    }
}
impl IfcRoundedRectangleProfileDef {
    pub fn from_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcRoundedRectangleProfileDef::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.profile_type = parameter.into(),
                1usize => {
                    entity.profile_name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => {
                    entity.position = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => entity.x_dim = parameter.into(),
                4usize => entity.y_dim = parameter.into(),
                5usize => entity.rounding_radius = parameter.into(),
                _ => {}
            }
        }
        entity
    }
    pub fn from_own_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcRoundedRectangleProfileDef::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.rounding_radius = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcSiUnit: IIfcNamedUnit {
    fn prefix(&self) -> &Option<IfcSiPrefix>;
    fn name(&self) -> &IfcSiUnitName;
}
#[derive(Default, Debug)]
pub struct IfcSiUnit {
    dimensions: EntityRef,
    unit_type: IfcUnitEnum,
    prefix: Option<IfcSiPrefix>,
    name: IfcSiUnitName,
}
impl IIfcNamedUnit for IfcSiUnit {
    fn dimensions(&self) -> &EntityRef {
        &self.dimensions
    }
    fn unit_type(&self) -> &IfcUnitEnum {
        &self.unit_type
    }
}
impl IIfcSiUnit for IfcSiUnit {
    fn prefix(&self) -> &Option<IfcSiPrefix> {
        &self.prefix
    }
    fn name(&self) -> &IfcSiUnitName {
        &self.name
    }
}
impl IfcSiUnit {
    pub fn from_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcSiUnit::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.dimensions = parameter.into(),
                1usize => entity.unit_type = parameter.into(),
                2usize => {
                    entity.prefix = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => entity.name = parameter.into(),
                _ => {}
            }
        }
        entity
    }
    pub fn from_own_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcSiUnit::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => {
                    entity.prefix = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                1usize => entity.name = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcSanitaryTerminal: IIfcFlowTerminal {
    fn predefined_type(&self) -> &Option<IfcSanitaryTerminalTypeEnum>;
}
#[derive(Default, Debug)]
pub struct IfcSanitaryTerminal {
    global_id: IfcGloballyUniqueId,
    owner_history: Option<EntityRef>,
    name: Option<IfcLabel>,
    description: Option<IfcText>,
    object_type: Option<IfcLabel>,
    object_placement: Option<EntityRef>,
    representation: Option<EntityRef>,
    tag: Option<IfcIdentifier>,
    predefined_type: Option<IfcSanitaryTerminalTypeEnum>,
}
impl IIfcRoot for IfcSanitaryTerminal {
    fn global_id(&self) -> &IfcGloballyUniqueId {
        &self.global_id
    }
    fn owner_history(&self) -> &Option<EntityRef> {
        &self.owner_history
    }
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
}
impl IIfcObjectDefinition for IfcSanitaryTerminal {}
impl IIfcObject for IfcSanitaryTerminal {
    fn object_type(&self) -> &Option<IfcLabel> {
        &self.object_type
    }
}
impl IIfcProduct for IfcSanitaryTerminal {
    fn object_placement(&self) -> &Option<EntityRef> {
        &self.object_placement
    }
    fn representation(&self) -> &Option<EntityRef> {
        &self.representation
    }
}
impl IIfcElement for IfcSanitaryTerminal {
    fn tag(&self) -> &Option<IfcIdentifier> {
        &self.tag
    }
}
impl IIfcDistributionElement for IfcSanitaryTerminal {}
impl IIfcDistributionFlowElement for IfcSanitaryTerminal {}
impl IIfcFlowTerminal for IfcSanitaryTerminal {}
impl IIfcSanitaryTerminal for IfcSanitaryTerminal {
    fn predefined_type(&self) -> &Option<IfcSanitaryTerminalTypeEnum> {
        &self.predefined_type
    }
}
impl IfcSanitaryTerminal {
    pub fn from_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcSanitaryTerminal::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.global_id = parameter.into(),
                1usize => {
                    entity.owner_history = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => {
                    entity.object_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                5usize => {
                    entity.object_placement = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                6usize => {
                    entity.representation = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                7usize => {
                    entity.tag = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                8usize => {
                    entity.predefined_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
    pub fn from_own_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcSanitaryTerminal::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => {
                    entity.predefined_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcSanitaryTerminalType: IIfcFlowTerminalType {
    fn predefined_type(&self) -> &IfcSanitaryTerminalTypeEnum;
}
#[derive(Default, Debug)]
pub struct IfcSanitaryTerminalType {
    global_id: IfcGloballyUniqueId,
    owner_history: Option<EntityRef>,
    name: Option<IfcLabel>,
    description: Option<IfcText>,
    applicable_occurrence: Option<IfcIdentifier>,
    has_property_sets: Option<HashSet<EntityRef>>,
    representation_maps: Option<Vec<EntityRef>>,
    tag: Option<IfcLabel>,
    element_type: Option<IfcLabel>,
    predefined_type: IfcSanitaryTerminalTypeEnum,
}
impl IIfcRoot for IfcSanitaryTerminalType {
    fn global_id(&self) -> &IfcGloballyUniqueId {
        &self.global_id
    }
    fn owner_history(&self) -> &Option<EntityRef> {
        &self.owner_history
    }
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
}
impl IIfcObjectDefinition for IfcSanitaryTerminalType {}
impl IIfcTypeObject for IfcSanitaryTerminalType {
    fn applicable_occurrence(&self) -> &Option<IfcIdentifier> {
        &self.applicable_occurrence
    }
    fn has_property_sets(&self) -> &Option<HashSet<EntityRef>> {
        &self.has_property_sets
    }
}
impl IIfcTypeProduct for IfcSanitaryTerminalType {
    fn representation_maps(&self) -> &Option<Vec<EntityRef>> {
        &self.representation_maps
    }
    fn tag(&self) -> &Option<IfcLabel> {
        &self.tag
    }
}
impl IIfcElementType for IfcSanitaryTerminalType {
    fn element_type(&self) -> &Option<IfcLabel> {
        &self.element_type
    }
}
impl IIfcDistributionElementType for IfcSanitaryTerminalType {}
impl IIfcDistributionFlowElementType for IfcSanitaryTerminalType {}
impl IIfcFlowTerminalType for IfcSanitaryTerminalType {}
impl IIfcSanitaryTerminalType for IfcSanitaryTerminalType {
    fn predefined_type(&self) -> &IfcSanitaryTerminalTypeEnum {
        &self.predefined_type
    }
}
impl IfcSanitaryTerminalType {
    pub fn from_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcSanitaryTerminalType::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.global_id = parameter.into(),
                1usize => {
                    entity.owner_history = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => {
                    entity.applicable_occurrence = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                5usize => {
                    entity.has_property_sets = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                6usize => {
                    entity.representation_maps = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                7usize => {
                    entity.tag = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                8usize => {
                    entity.element_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                9usize => entity.predefined_type = parameter.into(),
                _ => {}
            }
        }
        entity
    }
    pub fn from_own_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcSanitaryTerminalType::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.predefined_type = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcSchedulingTime {
    fn name(&self) -> &Option<IfcLabel>;
    fn data_origin(&self) -> &Option<IfcDataOriginEnum>;
    fn user_defined_data_origin(&self) -> &Option<IfcLabel>;
}
pub trait IIfcSeamCurve: IIfcSurfaceCurve {}
#[derive(Default, Debug)]
pub struct IfcSeamCurve {
    curve3_d: EntityRef,
    associated_geometry: Vec<EntityRef>,
    master_representation: IfcPreferredSurfaceCurveRepresentation,
}
impl IIfcRepresentationItem for IfcSeamCurve {}
impl IIfcGeometricRepresentationItem for IfcSeamCurve {}
impl IIfcCurve for IfcSeamCurve {}
impl IIfcSurfaceCurve for IfcSeamCurve {
    fn curve3_d(&self) -> &EntityRef {
        &self.curve3_d
    }
    fn associated_geometry(&self) -> &Vec<EntityRef> {
        &self.associated_geometry
    }
    fn master_representation(&self) -> &IfcPreferredSurfaceCurveRepresentation {
        &self.master_representation
    }
}
impl IIfcSeamCurve for IfcSeamCurve {}
impl IfcSeamCurve {
    pub fn from_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcSeamCurve::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.curve3_d = parameter.into(),
                1usize => entity.associated_geometry = parameter.into(),
                2usize => entity.master_representation = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcSectionProperties: IIfcPreDefinedProperties {
    fn section_type(&self) -> &IfcSectionTypeEnum;
    fn start_profile(&self) -> &EntityRef;
    fn end_profile(&self) -> &Option<EntityRef>;
}
#[derive(Default, Debug)]
pub struct IfcSectionProperties {
    section_type: IfcSectionTypeEnum,
    start_profile: EntityRef,
    end_profile: Option<EntityRef>,
}
impl IIfcPropertyAbstraction for IfcSectionProperties {}
impl IIfcPreDefinedProperties for IfcSectionProperties {}
impl IIfcSectionProperties for IfcSectionProperties {
    fn section_type(&self) -> &IfcSectionTypeEnum {
        &self.section_type
    }
    fn start_profile(&self) -> &EntityRef {
        &self.start_profile
    }
    fn end_profile(&self) -> &Option<EntityRef> {
        &self.end_profile
    }
}
impl IfcSectionProperties {
    pub fn from_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcSectionProperties::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.section_type = parameter.into(),
                1usize => entity.start_profile = parameter.into(),
                2usize => {
                    entity.end_profile = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcSectionReinforcementProperties: IIfcPreDefinedProperties {
    fn longitudinal_start_position(&self) -> &IfcLengthMeasure;
    fn longitudinal_end_position(&self) -> &IfcLengthMeasure;
    fn transverse_position(&self) -> &Option<IfcLengthMeasure>;
    fn reinforcement_role(&self) -> &IfcReinforcingBarRoleEnum;
    fn section_definition(&self) -> &EntityRef;
    fn cross_section_reinforcement_definitions(&self) -> &HashSet<EntityRef>;
}
#[derive(Default, Debug)]
pub struct IfcSectionReinforcementProperties {
    longitudinal_start_position: IfcLengthMeasure,
    longitudinal_end_position: IfcLengthMeasure,
    transverse_position: Option<IfcLengthMeasure>,
    reinforcement_role: IfcReinforcingBarRoleEnum,
    section_definition: EntityRef,
    cross_section_reinforcement_definitions: HashSet<EntityRef>,
}
impl IIfcPropertyAbstraction for IfcSectionReinforcementProperties {}
impl IIfcPreDefinedProperties for IfcSectionReinforcementProperties {}
impl IIfcSectionReinforcementProperties for IfcSectionReinforcementProperties {
    fn longitudinal_start_position(&self) -> &IfcLengthMeasure {
        &self.longitudinal_start_position
    }
    fn longitudinal_end_position(&self) -> &IfcLengthMeasure {
        &self.longitudinal_end_position
    }
    fn transverse_position(&self) -> &Option<IfcLengthMeasure> {
        &self.transverse_position
    }
    fn reinforcement_role(&self) -> &IfcReinforcingBarRoleEnum {
        &self.reinforcement_role
    }
    fn section_definition(&self) -> &EntityRef {
        &self.section_definition
    }
    fn cross_section_reinforcement_definitions(&self) -> &HashSet<EntityRef> {
        &self.cross_section_reinforcement_definitions
    }
}
impl IfcSectionReinforcementProperties {
    pub fn from_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcSectionReinforcementProperties::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.longitudinal_start_position = parameter.into(),
                1usize => entity.longitudinal_end_position = parameter.into(),
                2usize => {
                    entity.transverse_position = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => entity.reinforcement_role = parameter.into(),
                4usize => entity.section_definition = parameter.into(),
                5usize => entity.cross_section_reinforcement_definitions = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcSectionedSpine: IIfcGeometricRepresentationItem {
    fn spine_curve(&self) -> &EntityRef;
    fn cross_sections(&self) -> &Vec<EntityRef>;
    fn cross_section_positions(&self) -> &Vec<EntityRef>;
}
#[derive(Default, Debug)]
pub struct IfcSectionedSpine {
    spine_curve: EntityRef,
    cross_sections: Vec<EntityRef>,
    cross_section_positions: Vec<EntityRef>,
}
impl IIfcRepresentationItem for IfcSectionedSpine {}
impl IIfcGeometricRepresentationItem for IfcSectionedSpine {}
impl IIfcSectionedSpine for IfcSectionedSpine {
    fn spine_curve(&self) -> &EntityRef {
        &self.spine_curve
    }
    fn cross_sections(&self) -> &Vec<EntityRef> {
        &self.cross_sections
    }
    fn cross_section_positions(&self) -> &Vec<EntityRef> {
        &self.cross_section_positions
    }
}
impl IfcSectionedSpine {
    pub fn from_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcSectionedSpine::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.spine_curve = parameter.into(),
                1usize => entity.cross_sections = parameter.into(),
                2usize => entity.cross_section_positions = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcSensor: IIfcDistributionControlElement {
    fn predefined_type(&self) -> &Option<IfcSensorTypeEnum>;
}
#[derive(Default, Debug)]
pub struct IfcSensor {
    global_id: IfcGloballyUniqueId,
    owner_history: Option<EntityRef>,
    name: Option<IfcLabel>,
    description: Option<IfcText>,
    object_type: Option<IfcLabel>,
    object_placement: Option<EntityRef>,
    representation: Option<EntityRef>,
    tag: Option<IfcIdentifier>,
    predefined_type: Option<IfcSensorTypeEnum>,
}
impl IIfcRoot for IfcSensor {
    fn global_id(&self) -> &IfcGloballyUniqueId {
        &self.global_id
    }
    fn owner_history(&self) -> &Option<EntityRef> {
        &self.owner_history
    }
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
}
impl IIfcObjectDefinition for IfcSensor {}
impl IIfcObject for IfcSensor {
    fn object_type(&self) -> &Option<IfcLabel> {
        &self.object_type
    }
}
impl IIfcProduct for IfcSensor {
    fn object_placement(&self) -> &Option<EntityRef> {
        &self.object_placement
    }
    fn representation(&self) -> &Option<EntityRef> {
        &self.representation
    }
}
impl IIfcElement for IfcSensor {
    fn tag(&self) -> &Option<IfcIdentifier> {
        &self.tag
    }
}
impl IIfcDistributionElement for IfcSensor {}
impl IIfcDistributionControlElement for IfcSensor {}
impl IIfcSensor for IfcSensor {
    fn predefined_type(&self) -> &Option<IfcSensorTypeEnum> {
        &self.predefined_type
    }
}
impl IfcSensor {
    pub fn from_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcSensor::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.global_id = parameter.into(),
                1usize => {
                    entity.owner_history = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => {
                    entity.object_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                5usize => {
                    entity.object_placement = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                6usize => {
                    entity.representation = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                7usize => {
                    entity.tag = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                8usize => {
                    entity.predefined_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
    pub fn from_own_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcSensor::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => {
                    entity.predefined_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcSensorType: IIfcDistributionControlElementType {
    fn predefined_type(&self) -> &IfcSensorTypeEnum;
}
#[derive(Default, Debug)]
pub struct IfcSensorType {
    global_id: IfcGloballyUniqueId,
    owner_history: Option<EntityRef>,
    name: Option<IfcLabel>,
    description: Option<IfcText>,
    applicable_occurrence: Option<IfcIdentifier>,
    has_property_sets: Option<HashSet<EntityRef>>,
    representation_maps: Option<Vec<EntityRef>>,
    tag: Option<IfcLabel>,
    element_type: Option<IfcLabel>,
    predefined_type: IfcSensorTypeEnum,
}
impl IIfcRoot for IfcSensorType {
    fn global_id(&self) -> &IfcGloballyUniqueId {
        &self.global_id
    }
    fn owner_history(&self) -> &Option<EntityRef> {
        &self.owner_history
    }
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
}
impl IIfcObjectDefinition for IfcSensorType {}
impl IIfcTypeObject for IfcSensorType {
    fn applicable_occurrence(&self) -> &Option<IfcIdentifier> {
        &self.applicable_occurrence
    }
    fn has_property_sets(&self) -> &Option<HashSet<EntityRef>> {
        &self.has_property_sets
    }
}
impl IIfcTypeProduct for IfcSensorType {
    fn representation_maps(&self) -> &Option<Vec<EntityRef>> {
        &self.representation_maps
    }
    fn tag(&self) -> &Option<IfcLabel> {
        &self.tag
    }
}
impl IIfcElementType for IfcSensorType {
    fn element_type(&self) -> &Option<IfcLabel> {
        &self.element_type
    }
}
impl IIfcDistributionElementType for IfcSensorType {}
impl IIfcDistributionControlElementType for IfcSensorType {}
impl IIfcSensorType for IfcSensorType {
    fn predefined_type(&self) -> &IfcSensorTypeEnum {
        &self.predefined_type
    }
}
impl IfcSensorType {
    pub fn from_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcSensorType::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.global_id = parameter.into(),
                1usize => {
                    entity.owner_history = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => {
                    entity.applicable_occurrence = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                5usize => {
                    entity.has_property_sets = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                6usize => {
                    entity.representation_maps = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                7usize => {
                    entity.tag = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                8usize => {
                    entity.element_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                9usize => entity.predefined_type = parameter.into(),
                _ => {}
            }
        }
        entity
    }
    pub fn from_own_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcSensorType::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.predefined_type = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcShadingDevice: IIfcBuildingElement {
    fn predefined_type(&self) -> &Option<IfcShadingDeviceTypeEnum>;
}
#[derive(Default, Debug)]
pub struct IfcShadingDevice {
    global_id: IfcGloballyUniqueId,
    owner_history: Option<EntityRef>,
    name: Option<IfcLabel>,
    description: Option<IfcText>,
    object_type: Option<IfcLabel>,
    object_placement: Option<EntityRef>,
    representation: Option<EntityRef>,
    tag: Option<IfcIdentifier>,
    predefined_type: Option<IfcShadingDeviceTypeEnum>,
}
impl IIfcRoot for IfcShadingDevice {
    fn global_id(&self) -> &IfcGloballyUniqueId {
        &self.global_id
    }
    fn owner_history(&self) -> &Option<EntityRef> {
        &self.owner_history
    }
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
}
impl IIfcObjectDefinition for IfcShadingDevice {}
impl IIfcObject for IfcShadingDevice {
    fn object_type(&self) -> &Option<IfcLabel> {
        &self.object_type
    }
}
impl IIfcProduct for IfcShadingDevice {
    fn object_placement(&self) -> &Option<EntityRef> {
        &self.object_placement
    }
    fn representation(&self) -> &Option<EntityRef> {
        &self.representation
    }
}
impl IIfcElement for IfcShadingDevice {
    fn tag(&self) -> &Option<IfcIdentifier> {
        &self.tag
    }
}
impl IIfcBuildingElement for IfcShadingDevice {}
impl IIfcShadingDevice for IfcShadingDevice {
    fn predefined_type(&self) -> &Option<IfcShadingDeviceTypeEnum> {
        &self.predefined_type
    }
}
impl IfcShadingDevice {
    pub fn from_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcShadingDevice::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.global_id = parameter.into(),
                1usize => {
                    entity.owner_history = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => {
                    entity.object_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                5usize => {
                    entity.object_placement = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                6usize => {
                    entity.representation = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                7usize => {
                    entity.tag = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                8usize => {
                    entity.predefined_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
    pub fn from_own_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcShadingDevice::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => {
                    entity.predefined_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcShadingDeviceType: IIfcBuildingElementType {
    fn predefined_type(&self) -> &IfcShadingDeviceTypeEnum;
}
#[derive(Default, Debug)]
pub struct IfcShadingDeviceType {
    global_id: IfcGloballyUniqueId,
    owner_history: Option<EntityRef>,
    name: Option<IfcLabel>,
    description: Option<IfcText>,
    applicable_occurrence: Option<IfcIdentifier>,
    has_property_sets: Option<HashSet<EntityRef>>,
    representation_maps: Option<Vec<EntityRef>>,
    tag: Option<IfcLabel>,
    element_type: Option<IfcLabel>,
    predefined_type: IfcShadingDeviceTypeEnum,
}
impl IIfcRoot for IfcShadingDeviceType {
    fn global_id(&self) -> &IfcGloballyUniqueId {
        &self.global_id
    }
    fn owner_history(&self) -> &Option<EntityRef> {
        &self.owner_history
    }
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
}
impl IIfcObjectDefinition for IfcShadingDeviceType {}
impl IIfcTypeObject for IfcShadingDeviceType {
    fn applicable_occurrence(&self) -> &Option<IfcIdentifier> {
        &self.applicable_occurrence
    }
    fn has_property_sets(&self) -> &Option<HashSet<EntityRef>> {
        &self.has_property_sets
    }
}
impl IIfcTypeProduct for IfcShadingDeviceType {
    fn representation_maps(&self) -> &Option<Vec<EntityRef>> {
        &self.representation_maps
    }
    fn tag(&self) -> &Option<IfcLabel> {
        &self.tag
    }
}
impl IIfcElementType for IfcShadingDeviceType {
    fn element_type(&self) -> &Option<IfcLabel> {
        &self.element_type
    }
}
impl IIfcBuildingElementType for IfcShadingDeviceType {}
impl IIfcShadingDeviceType for IfcShadingDeviceType {
    fn predefined_type(&self) -> &IfcShadingDeviceTypeEnum {
        &self.predefined_type
    }
}
impl IfcShadingDeviceType {
    pub fn from_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcShadingDeviceType::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.global_id = parameter.into(),
                1usize => {
                    entity.owner_history = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => {
                    entity.applicable_occurrence = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                5usize => {
                    entity.has_property_sets = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                6usize => {
                    entity.representation_maps = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                7usize => {
                    entity.tag = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                8usize => {
                    entity.element_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                9usize => entity.predefined_type = parameter.into(),
                _ => {}
            }
        }
        entity
    }
    pub fn from_own_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcShadingDeviceType::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.predefined_type = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcShapeAspect {
    fn shape_representations(&self) -> &Vec<EntityRef>;
    fn name(&self) -> &Option<IfcLabel>;
    fn description(&self) -> &Option<IfcText>;
    fn product_definitional(&self) -> &IfcLogical;
    fn part_of_product_definition_shape(&self) -> &Option<EntityRef>;
}
#[derive(Default, Debug)]
pub struct IfcShapeAspect {
    shape_representations: Vec<EntityRef>,
    name: Option<IfcLabel>,
    description: Option<IfcText>,
    product_definitional: IfcLogical,
    part_of_product_definition_shape: Option<EntityRef>,
}
impl IIfcShapeAspect for IfcShapeAspect {
    fn shape_representations(&self) -> &Vec<EntityRef> {
        &self.shape_representations
    }
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
    fn product_definitional(&self) -> &IfcLogical {
        &self.product_definitional
    }
    fn part_of_product_definition_shape(&self) -> &Option<EntityRef> {
        &self.part_of_product_definition_shape
    }
}
impl IfcShapeAspect {
    pub fn from_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcShapeAspect::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.shape_representations = parameter.into(),
                1usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => entity.product_definitional = parameter.into(),
                4usize => {
                    entity.part_of_product_definition_shape = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcShapeModel: IIfcRepresentation {}
pub trait IIfcShapeRepresentation: IIfcShapeModel {}
#[derive(Default, Debug)]
pub struct IfcShapeRepresentation {
    context_of_items: EntityRef,
    representation_identifier: Option<IfcLabel>,
    representation_type: Option<IfcLabel>,
    items: HashSet<EntityRef>,
}
impl IIfcRepresentation for IfcShapeRepresentation {
    fn context_of_items(&self) -> &EntityRef {
        &self.context_of_items
    }
    fn representation_identifier(&self) -> &Option<IfcLabel> {
        &self.representation_identifier
    }
    fn representation_type(&self) -> &Option<IfcLabel> {
        &self.representation_type
    }
    fn items(&self) -> &HashSet<EntityRef> {
        &self.items
    }
}
impl IIfcShapeModel for IfcShapeRepresentation {}
impl IIfcShapeRepresentation for IfcShapeRepresentation {}
impl IfcShapeRepresentation {
    pub fn from_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcShapeRepresentation::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.context_of_items = parameter.into(),
                1usize => {
                    entity.representation_identifier = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => {
                    entity.representation_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => entity.items = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcShellBasedSurfaceModel: IIfcGeometricRepresentationItem {
    fn sbsm_boundary(&self) -> &HashSet<EntityRef>;
}
#[derive(Default, Debug)]
pub struct IfcShellBasedSurfaceModel {
    sbsm_boundary: HashSet<EntityRef>,
}
impl IIfcRepresentationItem for IfcShellBasedSurfaceModel {}
impl IIfcGeometricRepresentationItem for IfcShellBasedSurfaceModel {}
impl IIfcShellBasedSurfaceModel for IfcShellBasedSurfaceModel {
    fn sbsm_boundary(&self) -> &HashSet<EntityRef> {
        &self.sbsm_boundary
    }
}
impl IfcShellBasedSurfaceModel {
    pub fn from_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcShellBasedSurfaceModel::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.sbsm_boundary = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcSimpleProperty: IIfcProperty {}
pub trait IIfcSimplePropertyTemplate: IIfcPropertyTemplate {
    fn template_type(&self) -> &Option<IfcSimplePropertyTemplateTypeEnum>;
    fn primary_measure_type(&self) -> &Option<IfcLabel>;
    fn secondary_measure_type(&self) -> &Option<IfcLabel>;
    fn enumerators(&self) -> &Option<EntityRef>;
    fn primary_unit(&self) -> &Option<EntityRef>;
    fn secondary_unit(&self) -> &Option<EntityRef>;
    fn expression(&self) -> &Option<IfcLabel>;
    fn access_state(&self) -> &Option<IfcStateEnum>;
}
#[derive(Default, Debug)]
pub struct IfcSimplePropertyTemplate {
    global_id: IfcGloballyUniqueId,
    owner_history: Option<EntityRef>,
    name: Option<IfcLabel>,
    description: Option<IfcText>,
    template_type: Option<IfcSimplePropertyTemplateTypeEnum>,
    primary_measure_type: Option<IfcLabel>,
    secondary_measure_type: Option<IfcLabel>,
    enumerators: Option<EntityRef>,
    primary_unit: Option<EntityRef>,
    secondary_unit: Option<EntityRef>,
    expression: Option<IfcLabel>,
    access_state: Option<IfcStateEnum>,
}
impl IIfcRoot for IfcSimplePropertyTemplate {
    fn global_id(&self) -> &IfcGloballyUniqueId {
        &self.global_id
    }
    fn owner_history(&self) -> &Option<EntityRef> {
        &self.owner_history
    }
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
}
impl IIfcPropertyDefinition for IfcSimplePropertyTemplate {}
impl IIfcPropertyTemplateDefinition for IfcSimplePropertyTemplate {}
impl IIfcPropertyTemplate for IfcSimplePropertyTemplate {}
impl IIfcSimplePropertyTemplate for IfcSimplePropertyTemplate {
    fn template_type(&self) -> &Option<IfcSimplePropertyTemplateTypeEnum> {
        &self.template_type
    }
    fn primary_measure_type(&self) -> &Option<IfcLabel> {
        &self.primary_measure_type
    }
    fn secondary_measure_type(&self) -> &Option<IfcLabel> {
        &self.secondary_measure_type
    }
    fn enumerators(&self) -> &Option<EntityRef> {
        &self.enumerators
    }
    fn primary_unit(&self) -> &Option<EntityRef> {
        &self.primary_unit
    }
    fn secondary_unit(&self) -> &Option<EntityRef> {
        &self.secondary_unit
    }
    fn expression(&self) -> &Option<IfcLabel> {
        &self.expression
    }
    fn access_state(&self) -> &Option<IfcStateEnum> {
        &self.access_state
    }
}
impl IfcSimplePropertyTemplate {
    pub fn from_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcSimplePropertyTemplate::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.global_id = parameter.into(),
                1usize => {
                    entity.owner_history = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => {
                    entity.template_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                5usize => {
                    entity.primary_measure_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                6usize => {
                    entity.secondary_measure_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                7usize => {
                    entity.enumerators = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                8usize => {
                    entity.primary_unit = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                9usize => {
                    entity.secondary_unit = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                10usize => {
                    entity.expression = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                11usize => {
                    entity.access_state = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
    pub fn from_own_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcSimplePropertyTemplate::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => {
                    entity.template_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                1usize => {
                    entity.primary_measure_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => {
                    entity.secondary_measure_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.enumerators = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => {
                    entity.primary_unit = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                5usize => {
                    entity.secondary_unit = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                6usize => {
                    entity.expression = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                7usize => {
                    entity.access_state = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcSite: IIfcSpatialStructureElement {
    fn ref_latitude(&self) -> &Option<IfcCompoundPlaneAngleMeasure>;
    fn ref_longitude(&self) -> &Option<IfcCompoundPlaneAngleMeasure>;
    fn ref_elevation(&self) -> &Option<IfcLengthMeasure>;
    fn land_title_number(&self) -> &Option<IfcLabel>;
    fn site_address(&self) -> &Option<EntityRef>;
}
#[derive(Default, Debug)]
pub struct IfcSite {
    global_id: IfcGloballyUniqueId,
    owner_history: Option<EntityRef>,
    name: Option<IfcLabel>,
    description: Option<IfcText>,
    object_type: Option<IfcLabel>,
    object_placement: Option<EntityRef>,
    representation: Option<EntityRef>,
    long_name: Option<IfcLabel>,
    composition_type: Option<IfcElementCompositionEnum>,
    ref_latitude: Option<IfcCompoundPlaneAngleMeasure>,
    ref_longitude: Option<IfcCompoundPlaneAngleMeasure>,
    ref_elevation: Option<IfcLengthMeasure>,
    land_title_number: Option<IfcLabel>,
    site_address: Option<EntityRef>,
}
impl IIfcRoot for IfcSite {
    fn global_id(&self) -> &IfcGloballyUniqueId {
        &self.global_id
    }
    fn owner_history(&self) -> &Option<EntityRef> {
        &self.owner_history
    }
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
}
impl IIfcObjectDefinition for IfcSite {}
impl IIfcObject for IfcSite {
    fn object_type(&self) -> &Option<IfcLabel> {
        &self.object_type
    }
}
impl IIfcProduct for IfcSite {
    fn object_placement(&self) -> &Option<EntityRef> {
        &self.object_placement
    }
    fn representation(&self) -> &Option<EntityRef> {
        &self.representation
    }
}
impl IIfcSpatialElement for IfcSite {
    fn long_name(&self) -> &Option<IfcLabel> {
        &self.long_name
    }
}
impl IIfcSpatialStructureElement for IfcSite {
    fn composition_type(&self) -> &Option<IfcElementCompositionEnum> {
        &self.composition_type
    }
}
impl IIfcSite for IfcSite {
    fn ref_latitude(&self) -> &Option<IfcCompoundPlaneAngleMeasure> {
        &self.ref_latitude
    }
    fn ref_longitude(&self) -> &Option<IfcCompoundPlaneAngleMeasure> {
        &self.ref_longitude
    }
    fn ref_elevation(&self) -> &Option<IfcLengthMeasure> {
        &self.ref_elevation
    }
    fn land_title_number(&self) -> &Option<IfcLabel> {
        &self.land_title_number
    }
    fn site_address(&self) -> &Option<EntityRef> {
        &self.site_address
    }
}
impl IfcSite {
    pub fn from_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcSite::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.global_id = parameter.into(),
                1usize => {
                    entity.owner_history = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => {
                    entity.object_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                5usize => {
                    entity.object_placement = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                6usize => {
                    entity.representation = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                7usize => {
                    entity.long_name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                8usize => {
                    entity.composition_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                9usize => {
                    entity.ref_latitude = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                10usize => {
                    entity.ref_longitude = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                11usize => {
                    entity.ref_elevation = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                12usize => {
                    entity.land_title_number = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                13usize => {
                    entity.site_address = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
    pub fn from_own_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcSite::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => {
                    entity.ref_latitude = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                1usize => {
                    entity.ref_longitude = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => {
                    entity.ref_elevation = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.land_title_number = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => {
                    entity.site_address = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcSlab: IIfcBuildingElement {
    fn predefined_type(&self) -> &Option<IfcSlabTypeEnum>;
}
#[derive(Default, Debug)]
pub struct IfcSlab {
    global_id: IfcGloballyUniqueId,
    owner_history: Option<EntityRef>,
    name: Option<IfcLabel>,
    description: Option<IfcText>,
    object_type: Option<IfcLabel>,
    object_placement: Option<EntityRef>,
    representation: Option<EntityRef>,
    tag: Option<IfcIdentifier>,
    predefined_type: Option<IfcSlabTypeEnum>,
}
impl IIfcRoot for IfcSlab {
    fn global_id(&self) -> &IfcGloballyUniqueId {
        &self.global_id
    }
    fn owner_history(&self) -> &Option<EntityRef> {
        &self.owner_history
    }
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
}
impl IIfcObjectDefinition for IfcSlab {}
impl IIfcObject for IfcSlab {
    fn object_type(&self) -> &Option<IfcLabel> {
        &self.object_type
    }
}
impl IIfcProduct for IfcSlab {
    fn object_placement(&self) -> &Option<EntityRef> {
        &self.object_placement
    }
    fn representation(&self) -> &Option<EntityRef> {
        &self.representation
    }
}
impl IIfcElement for IfcSlab {
    fn tag(&self) -> &Option<IfcIdentifier> {
        &self.tag
    }
}
impl IIfcBuildingElement for IfcSlab {}
impl IIfcSlab for IfcSlab {
    fn predefined_type(&self) -> &Option<IfcSlabTypeEnum> {
        &self.predefined_type
    }
}
impl IfcSlab {
    pub fn from_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcSlab::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.global_id = parameter.into(),
                1usize => {
                    entity.owner_history = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => {
                    entity.object_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                5usize => {
                    entity.object_placement = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                6usize => {
                    entity.representation = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                7usize => {
                    entity.tag = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                8usize => {
                    entity.predefined_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
    pub fn from_own_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcSlab::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => {
                    entity.predefined_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcSlabElementedCase: IIfcSlab {}
#[derive(Default, Debug)]
pub struct IfcSlabElementedCase {
    global_id: IfcGloballyUniqueId,
    owner_history: Option<EntityRef>,
    name: Option<IfcLabel>,
    description: Option<IfcText>,
    object_type: Option<IfcLabel>,
    object_placement: Option<EntityRef>,
    representation: Option<EntityRef>,
    tag: Option<IfcIdentifier>,
    predefined_type: Option<IfcSlabTypeEnum>,
}
impl IIfcRoot for IfcSlabElementedCase {
    fn global_id(&self) -> &IfcGloballyUniqueId {
        &self.global_id
    }
    fn owner_history(&self) -> &Option<EntityRef> {
        &self.owner_history
    }
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
}
impl IIfcObjectDefinition for IfcSlabElementedCase {}
impl IIfcObject for IfcSlabElementedCase {
    fn object_type(&self) -> &Option<IfcLabel> {
        &self.object_type
    }
}
impl IIfcProduct for IfcSlabElementedCase {
    fn object_placement(&self) -> &Option<EntityRef> {
        &self.object_placement
    }
    fn representation(&self) -> &Option<EntityRef> {
        &self.representation
    }
}
impl IIfcElement for IfcSlabElementedCase {
    fn tag(&self) -> &Option<IfcIdentifier> {
        &self.tag
    }
}
impl IIfcBuildingElement for IfcSlabElementedCase {}
impl IIfcSlab for IfcSlabElementedCase {
    fn predefined_type(&self) -> &Option<IfcSlabTypeEnum> {
        &self.predefined_type
    }
}
impl IIfcSlabElementedCase for IfcSlabElementedCase {}
impl IfcSlabElementedCase {
    pub fn from_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcSlabElementedCase::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.global_id = parameter.into(),
                1usize => {
                    entity.owner_history = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => {
                    entity.object_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                5usize => {
                    entity.object_placement = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                6usize => {
                    entity.representation = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                7usize => {
                    entity.tag = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                8usize => {
                    entity.predefined_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcSlabStandardCase: IIfcSlab {}
#[derive(Default, Debug)]
pub struct IfcSlabStandardCase {
    global_id: IfcGloballyUniqueId,
    owner_history: Option<EntityRef>,
    name: Option<IfcLabel>,
    description: Option<IfcText>,
    object_type: Option<IfcLabel>,
    object_placement: Option<EntityRef>,
    representation: Option<EntityRef>,
    tag: Option<IfcIdentifier>,
    predefined_type: Option<IfcSlabTypeEnum>,
}
impl IIfcRoot for IfcSlabStandardCase {
    fn global_id(&self) -> &IfcGloballyUniqueId {
        &self.global_id
    }
    fn owner_history(&self) -> &Option<EntityRef> {
        &self.owner_history
    }
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
}
impl IIfcObjectDefinition for IfcSlabStandardCase {}
impl IIfcObject for IfcSlabStandardCase {
    fn object_type(&self) -> &Option<IfcLabel> {
        &self.object_type
    }
}
impl IIfcProduct for IfcSlabStandardCase {
    fn object_placement(&self) -> &Option<EntityRef> {
        &self.object_placement
    }
    fn representation(&self) -> &Option<EntityRef> {
        &self.representation
    }
}
impl IIfcElement for IfcSlabStandardCase {
    fn tag(&self) -> &Option<IfcIdentifier> {
        &self.tag
    }
}
impl IIfcBuildingElement for IfcSlabStandardCase {}
impl IIfcSlab for IfcSlabStandardCase {
    fn predefined_type(&self) -> &Option<IfcSlabTypeEnum> {
        &self.predefined_type
    }
}
impl IIfcSlabStandardCase for IfcSlabStandardCase {}
impl IfcSlabStandardCase {
    pub fn from_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcSlabStandardCase::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.global_id = parameter.into(),
                1usize => {
                    entity.owner_history = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => {
                    entity.object_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                5usize => {
                    entity.object_placement = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                6usize => {
                    entity.representation = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                7usize => {
                    entity.tag = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                8usize => {
                    entity.predefined_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcSlabType: IIfcBuildingElementType {
    fn predefined_type(&self) -> &IfcSlabTypeEnum;
}
#[derive(Default, Debug)]
pub struct IfcSlabType {
    global_id: IfcGloballyUniqueId,
    owner_history: Option<EntityRef>,
    name: Option<IfcLabel>,
    description: Option<IfcText>,
    applicable_occurrence: Option<IfcIdentifier>,
    has_property_sets: Option<HashSet<EntityRef>>,
    representation_maps: Option<Vec<EntityRef>>,
    tag: Option<IfcLabel>,
    element_type: Option<IfcLabel>,
    predefined_type: IfcSlabTypeEnum,
}
impl IIfcRoot for IfcSlabType {
    fn global_id(&self) -> &IfcGloballyUniqueId {
        &self.global_id
    }
    fn owner_history(&self) -> &Option<EntityRef> {
        &self.owner_history
    }
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
}
impl IIfcObjectDefinition for IfcSlabType {}
impl IIfcTypeObject for IfcSlabType {
    fn applicable_occurrence(&self) -> &Option<IfcIdentifier> {
        &self.applicable_occurrence
    }
    fn has_property_sets(&self) -> &Option<HashSet<EntityRef>> {
        &self.has_property_sets
    }
}
impl IIfcTypeProduct for IfcSlabType {
    fn representation_maps(&self) -> &Option<Vec<EntityRef>> {
        &self.representation_maps
    }
    fn tag(&self) -> &Option<IfcLabel> {
        &self.tag
    }
}
impl IIfcElementType for IfcSlabType {
    fn element_type(&self) -> &Option<IfcLabel> {
        &self.element_type
    }
}
impl IIfcBuildingElementType for IfcSlabType {}
impl IIfcSlabType for IfcSlabType {
    fn predefined_type(&self) -> &IfcSlabTypeEnum {
        &self.predefined_type
    }
}
impl IfcSlabType {
    pub fn from_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcSlabType::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.global_id = parameter.into(),
                1usize => {
                    entity.owner_history = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => {
                    entity.applicable_occurrence = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                5usize => {
                    entity.has_property_sets = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                6usize => {
                    entity.representation_maps = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                7usize => {
                    entity.tag = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                8usize => {
                    entity.element_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                9usize => entity.predefined_type = parameter.into(),
                _ => {}
            }
        }
        entity
    }
    pub fn from_own_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcSlabType::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.predefined_type = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcSlippageConnectionCondition: IIfcStructuralConnectionCondition {
    fn slippage_x(&self) -> &Option<IfcLengthMeasure>;
    fn slippage_y(&self) -> &Option<IfcLengthMeasure>;
    fn slippage_z(&self) -> &Option<IfcLengthMeasure>;
}
#[derive(Default, Debug)]
pub struct IfcSlippageConnectionCondition {
    name: Option<IfcLabel>,
    slippage_x: Option<IfcLengthMeasure>,
    slippage_y: Option<IfcLengthMeasure>,
    slippage_z: Option<IfcLengthMeasure>,
}
impl IIfcStructuralConnectionCondition for IfcSlippageConnectionCondition {
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
}
impl IIfcSlippageConnectionCondition for IfcSlippageConnectionCondition {
    fn slippage_x(&self) -> &Option<IfcLengthMeasure> {
        &self.slippage_x
    }
    fn slippage_y(&self) -> &Option<IfcLengthMeasure> {
        &self.slippage_y
    }
    fn slippage_z(&self) -> &Option<IfcLengthMeasure> {
        &self.slippage_z
    }
}
impl IfcSlippageConnectionCondition {
    pub fn from_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcSlippageConnectionCondition::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                1usize => {
                    entity.slippage_x = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => {
                    entity.slippage_y = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.slippage_z = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
    pub fn from_own_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcSlippageConnectionCondition::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => {
                    entity.slippage_x = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                1usize => {
                    entity.slippage_y = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => {
                    entity.slippage_z = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcSolarDevice: IIfcEnergyConversionDevice {
    fn predefined_type(&self) -> &Option<IfcSolarDeviceTypeEnum>;
}
#[derive(Default, Debug)]
pub struct IfcSolarDevice {
    global_id: IfcGloballyUniqueId,
    owner_history: Option<EntityRef>,
    name: Option<IfcLabel>,
    description: Option<IfcText>,
    object_type: Option<IfcLabel>,
    object_placement: Option<EntityRef>,
    representation: Option<EntityRef>,
    tag: Option<IfcIdentifier>,
    predefined_type: Option<IfcSolarDeviceTypeEnum>,
}
impl IIfcRoot for IfcSolarDevice {
    fn global_id(&self) -> &IfcGloballyUniqueId {
        &self.global_id
    }
    fn owner_history(&self) -> &Option<EntityRef> {
        &self.owner_history
    }
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
}
impl IIfcObjectDefinition for IfcSolarDevice {}
impl IIfcObject for IfcSolarDevice {
    fn object_type(&self) -> &Option<IfcLabel> {
        &self.object_type
    }
}
impl IIfcProduct for IfcSolarDevice {
    fn object_placement(&self) -> &Option<EntityRef> {
        &self.object_placement
    }
    fn representation(&self) -> &Option<EntityRef> {
        &self.representation
    }
}
impl IIfcElement for IfcSolarDevice {
    fn tag(&self) -> &Option<IfcIdentifier> {
        &self.tag
    }
}
impl IIfcDistributionElement for IfcSolarDevice {}
impl IIfcDistributionFlowElement for IfcSolarDevice {}
impl IIfcEnergyConversionDevice for IfcSolarDevice {}
impl IIfcSolarDevice for IfcSolarDevice {
    fn predefined_type(&self) -> &Option<IfcSolarDeviceTypeEnum> {
        &self.predefined_type
    }
}
impl IfcSolarDevice {
    pub fn from_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcSolarDevice::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.global_id = parameter.into(),
                1usize => {
                    entity.owner_history = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => {
                    entity.object_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                5usize => {
                    entity.object_placement = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                6usize => {
                    entity.representation = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                7usize => {
                    entity.tag = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                8usize => {
                    entity.predefined_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
    pub fn from_own_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcSolarDevice::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => {
                    entity.predefined_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcSolarDeviceType: IIfcEnergyConversionDeviceType {
    fn predefined_type(&self) -> &IfcSolarDeviceTypeEnum;
}
#[derive(Default, Debug)]
pub struct IfcSolarDeviceType {
    global_id: IfcGloballyUniqueId,
    owner_history: Option<EntityRef>,
    name: Option<IfcLabel>,
    description: Option<IfcText>,
    applicable_occurrence: Option<IfcIdentifier>,
    has_property_sets: Option<HashSet<EntityRef>>,
    representation_maps: Option<Vec<EntityRef>>,
    tag: Option<IfcLabel>,
    element_type: Option<IfcLabel>,
    predefined_type: IfcSolarDeviceTypeEnum,
}
impl IIfcRoot for IfcSolarDeviceType {
    fn global_id(&self) -> &IfcGloballyUniqueId {
        &self.global_id
    }
    fn owner_history(&self) -> &Option<EntityRef> {
        &self.owner_history
    }
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
}
impl IIfcObjectDefinition for IfcSolarDeviceType {}
impl IIfcTypeObject for IfcSolarDeviceType {
    fn applicable_occurrence(&self) -> &Option<IfcIdentifier> {
        &self.applicable_occurrence
    }
    fn has_property_sets(&self) -> &Option<HashSet<EntityRef>> {
        &self.has_property_sets
    }
}
impl IIfcTypeProduct for IfcSolarDeviceType {
    fn representation_maps(&self) -> &Option<Vec<EntityRef>> {
        &self.representation_maps
    }
    fn tag(&self) -> &Option<IfcLabel> {
        &self.tag
    }
}
impl IIfcElementType for IfcSolarDeviceType {
    fn element_type(&self) -> &Option<IfcLabel> {
        &self.element_type
    }
}
impl IIfcDistributionElementType for IfcSolarDeviceType {}
impl IIfcDistributionFlowElementType for IfcSolarDeviceType {}
impl IIfcEnergyConversionDeviceType for IfcSolarDeviceType {}
impl IIfcSolarDeviceType for IfcSolarDeviceType {
    fn predefined_type(&self) -> &IfcSolarDeviceTypeEnum {
        &self.predefined_type
    }
}
impl IfcSolarDeviceType {
    pub fn from_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcSolarDeviceType::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.global_id = parameter.into(),
                1usize => {
                    entity.owner_history = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => {
                    entity.applicable_occurrence = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                5usize => {
                    entity.has_property_sets = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                6usize => {
                    entity.representation_maps = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                7usize => {
                    entity.tag = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                8usize => {
                    entity.element_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                9usize => entity.predefined_type = parameter.into(),
                _ => {}
            }
        }
        entity
    }
    pub fn from_own_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcSolarDeviceType::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.predefined_type = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcSolidModel: IIfcGeometricRepresentationItem {}
pub trait IIfcSpace: IIfcSpatialStructureElement {
    fn predefined_type(&self) -> &Option<IfcSpaceTypeEnum>;
    fn elevation_with_flooring(&self) -> &Option<IfcLengthMeasure>;
}
#[derive(Default, Debug)]
pub struct IfcSpace {
    global_id: IfcGloballyUniqueId,
    owner_history: Option<EntityRef>,
    name: Option<IfcLabel>,
    description: Option<IfcText>,
    object_type: Option<IfcLabel>,
    object_placement: Option<EntityRef>,
    representation: Option<EntityRef>,
    long_name: Option<IfcLabel>,
    composition_type: Option<IfcElementCompositionEnum>,
    predefined_type: Option<IfcSpaceTypeEnum>,
    elevation_with_flooring: Option<IfcLengthMeasure>,
}
impl IIfcRoot for IfcSpace {
    fn global_id(&self) -> &IfcGloballyUniqueId {
        &self.global_id
    }
    fn owner_history(&self) -> &Option<EntityRef> {
        &self.owner_history
    }
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
}
impl IIfcObjectDefinition for IfcSpace {}
impl IIfcObject for IfcSpace {
    fn object_type(&self) -> &Option<IfcLabel> {
        &self.object_type
    }
}
impl IIfcProduct for IfcSpace {
    fn object_placement(&self) -> &Option<EntityRef> {
        &self.object_placement
    }
    fn representation(&self) -> &Option<EntityRef> {
        &self.representation
    }
}
impl IIfcSpatialElement for IfcSpace {
    fn long_name(&self) -> &Option<IfcLabel> {
        &self.long_name
    }
}
impl IIfcSpatialStructureElement for IfcSpace {
    fn composition_type(&self) -> &Option<IfcElementCompositionEnum> {
        &self.composition_type
    }
}
impl IIfcSpace for IfcSpace {
    fn predefined_type(&self) -> &Option<IfcSpaceTypeEnum> {
        &self.predefined_type
    }
    fn elevation_with_flooring(&self) -> &Option<IfcLengthMeasure> {
        &self.elevation_with_flooring
    }
}
impl IfcSpace {
    pub fn from_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcSpace::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.global_id = parameter.into(),
                1usize => {
                    entity.owner_history = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => {
                    entity.object_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                5usize => {
                    entity.object_placement = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                6usize => {
                    entity.representation = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                7usize => {
                    entity.long_name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                8usize => {
                    entity.composition_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                9usize => {
                    entity.predefined_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                10usize => {
                    entity.elevation_with_flooring = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
    pub fn from_own_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcSpace::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => {
                    entity.predefined_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                1usize => {
                    entity.elevation_with_flooring = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcSpaceHeater: IIfcFlowTerminal {
    fn predefined_type(&self) -> &Option<IfcSpaceHeaterTypeEnum>;
}
#[derive(Default, Debug)]
pub struct IfcSpaceHeater {
    global_id: IfcGloballyUniqueId,
    owner_history: Option<EntityRef>,
    name: Option<IfcLabel>,
    description: Option<IfcText>,
    object_type: Option<IfcLabel>,
    object_placement: Option<EntityRef>,
    representation: Option<EntityRef>,
    tag: Option<IfcIdentifier>,
    predefined_type: Option<IfcSpaceHeaterTypeEnum>,
}
impl IIfcRoot for IfcSpaceHeater {
    fn global_id(&self) -> &IfcGloballyUniqueId {
        &self.global_id
    }
    fn owner_history(&self) -> &Option<EntityRef> {
        &self.owner_history
    }
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
}
impl IIfcObjectDefinition for IfcSpaceHeater {}
impl IIfcObject for IfcSpaceHeater {
    fn object_type(&self) -> &Option<IfcLabel> {
        &self.object_type
    }
}
impl IIfcProduct for IfcSpaceHeater {
    fn object_placement(&self) -> &Option<EntityRef> {
        &self.object_placement
    }
    fn representation(&self) -> &Option<EntityRef> {
        &self.representation
    }
}
impl IIfcElement for IfcSpaceHeater {
    fn tag(&self) -> &Option<IfcIdentifier> {
        &self.tag
    }
}
impl IIfcDistributionElement for IfcSpaceHeater {}
impl IIfcDistributionFlowElement for IfcSpaceHeater {}
impl IIfcFlowTerminal for IfcSpaceHeater {}
impl IIfcSpaceHeater for IfcSpaceHeater {
    fn predefined_type(&self) -> &Option<IfcSpaceHeaterTypeEnum> {
        &self.predefined_type
    }
}
impl IfcSpaceHeater {
    pub fn from_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcSpaceHeater::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.global_id = parameter.into(),
                1usize => {
                    entity.owner_history = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => {
                    entity.object_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                5usize => {
                    entity.object_placement = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                6usize => {
                    entity.representation = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                7usize => {
                    entity.tag = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                8usize => {
                    entity.predefined_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
    pub fn from_own_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcSpaceHeater::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => {
                    entity.predefined_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcSpaceHeaterType: IIfcFlowTerminalType {
    fn predefined_type(&self) -> &IfcSpaceHeaterTypeEnum;
}
#[derive(Default, Debug)]
pub struct IfcSpaceHeaterType {
    global_id: IfcGloballyUniqueId,
    owner_history: Option<EntityRef>,
    name: Option<IfcLabel>,
    description: Option<IfcText>,
    applicable_occurrence: Option<IfcIdentifier>,
    has_property_sets: Option<HashSet<EntityRef>>,
    representation_maps: Option<Vec<EntityRef>>,
    tag: Option<IfcLabel>,
    element_type: Option<IfcLabel>,
    predefined_type: IfcSpaceHeaterTypeEnum,
}
impl IIfcRoot for IfcSpaceHeaterType {
    fn global_id(&self) -> &IfcGloballyUniqueId {
        &self.global_id
    }
    fn owner_history(&self) -> &Option<EntityRef> {
        &self.owner_history
    }
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
}
impl IIfcObjectDefinition for IfcSpaceHeaterType {}
impl IIfcTypeObject for IfcSpaceHeaterType {
    fn applicable_occurrence(&self) -> &Option<IfcIdentifier> {
        &self.applicable_occurrence
    }
    fn has_property_sets(&self) -> &Option<HashSet<EntityRef>> {
        &self.has_property_sets
    }
}
impl IIfcTypeProduct for IfcSpaceHeaterType {
    fn representation_maps(&self) -> &Option<Vec<EntityRef>> {
        &self.representation_maps
    }
    fn tag(&self) -> &Option<IfcLabel> {
        &self.tag
    }
}
impl IIfcElementType for IfcSpaceHeaterType {
    fn element_type(&self) -> &Option<IfcLabel> {
        &self.element_type
    }
}
impl IIfcDistributionElementType for IfcSpaceHeaterType {}
impl IIfcDistributionFlowElementType for IfcSpaceHeaterType {}
impl IIfcFlowTerminalType for IfcSpaceHeaterType {}
impl IIfcSpaceHeaterType for IfcSpaceHeaterType {
    fn predefined_type(&self) -> &IfcSpaceHeaterTypeEnum {
        &self.predefined_type
    }
}
impl IfcSpaceHeaterType {
    pub fn from_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcSpaceHeaterType::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.global_id = parameter.into(),
                1usize => {
                    entity.owner_history = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => {
                    entity.applicable_occurrence = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                5usize => {
                    entity.has_property_sets = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                6usize => {
                    entity.representation_maps = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                7usize => {
                    entity.tag = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                8usize => {
                    entity.element_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                9usize => entity.predefined_type = parameter.into(),
                _ => {}
            }
        }
        entity
    }
    pub fn from_own_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcSpaceHeaterType::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.predefined_type = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcSpaceType: IIfcSpatialStructureElementType {
    fn predefined_type(&self) -> &IfcSpaceTypeEnum;
    fn long_name(&self) -> &Option<IfcLabel>;
}
#[derive(Default, Debug)]
pub struct IfcSpaceType {
    global_id: IfcGloballyUniqueId,
    owner_history: Option<EntityRef>,
    name: Option<IfcLabel>,
    description: Option<IfcText>,
    applicable_occurrence: Option<IfcIdentifier>,
    has_property_sets: Option<HashSet<EntityRef>>,
    representation_maps: Option<Vec<EntityRef>>,
    tag: Option<IfcLabel>,
    element_type: Option<IfcLabel>,
    predefined_type: IfcSpaceTypeEnum,
    long_name: Option<IfcLabel>,
}
impl IIfcRoot for IfcSpaceType {
    fn global_id(&self) -> &IfcGloballyUniqueId {
        &self.global_id
    }
    fn owner_history(&self) -> &Option<EntityRef> {
        &self.owner_history
    }
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
}
impl IIfcObjectDefinition for IfcSpaceType {}
impl IIfcTypeObject for IfcSpaceType {
    fn applicable_occurrence(&self) -> &Option<IfcIdentifier> {
        &self.applicable_occurrence
    }
    fn has_property_sets(&self) -> &Option<HashSet<EntityRef>> {
        &self.has_property_sets
    }
}
impl IIfcTypeProduct for IfcSpaceType {
    fn representation_maps(&self) -> &Option<Vec<EntityRef>> {
        &self.representation_maps
    }
    fn tag(&self) -> &Option<IfcLabel> {
        &self.tag
    }
}
impl IIfcSpatialElementType for IfcSpaceType {
    fn element_type(&self) -> &Option<IfcLabel> {
        &self.element_type
    }
}
impl IIfcSpatialStructureElementType for IfcSpaceType {}
impl IIfcSpaceType for IfcSpaceType {
    fn predefined_type(&self) -> &IfcSpaceTypeEnum {
        &self.predefined_type
    }
    fn long_name(&self) -> &Option<IfcLabel> {
        &self.long_name
    }
}
impl IfcSpaceType {
    pub fn from_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcSpaceType::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.global_id = parameter.into(),
                1usize => {
                    entity.owner_history = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => {
                    entity.applicable_occurrence = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                5usize => {
                    entity.has_property_sets = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                6usize => {
                    entity.representation_maps = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                7usize => {
                    entity.tag = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                8usize => {
                    entity.element_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                9usize => entity.predefined_type = parameter.into(),
                10usize => {
                    entity.long_name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
    pub fn from_own_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcSpaceType::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.predefined_type = parameter.into(),
                1usize => {
                    entity.long_name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcSpatialElement: IIfcProduct {
    fn long_name(&self) -> &Option<IfcLabel>;
}
pub trait IIfcSpatialElementType: IIfcTypeProduct {
    fn element_type(&self) -> &Option<IfcLabel>;
}
pub trait IIfcSpatialStructureElement: IIfcSpatialElement {
    fn composition_type(&self) -> &Option<IfcElementCompositionEnum>;
}
pub trait IIfcSpatialStructureElementType: IIfcSpatialElementType {}
pub trait IIfcSpatialZone: IIfcSpatialElement {
    fn predefined_type(&self) -> &Option<IfcSpatialZoneTypeEnum>;
}
#[derive(Default, Debug)]
pub struct IfcSpatialZone {
    global_id: IfcGloballyUniqueId,
    owner_history: Option<EntityRef>,
    name: Option<IfcLabel>,
    description: Option<IfcText>,
    object_type: Option<IfcLabel>,
    object_placement: Option<EntityRef>,
    representation: Option<EntityRef>,
    long_name: Option<IfcLabel>,
    predefined_type: Option<IfcSpatialZoneTypeEnum>,
}
impl IIfcRoot for IfcSpatialZone {
    fn global_id(&self) -> &IfcGloballyUniqueId {
        &self.global_id
    }
    fn owner_history(&self) -> &Option<EntityRef> {
        &self.owner_history
    }
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
}
impl IIfcObjectDefinition for IfcSpatialZone {}
impl IIfcObject for IfcSpatialZone {
    fn object_type(&self) -> &Option<IfcLabel> {
        &self.object_type
    }
}
impl IIfcProduct for IfcSpatialZone {
    fn object_placement(&self) -> &Option<EntityRef> {
        &self.object_placement
    }
    fn representation(&self) -> &Option<EntityRef> {
        &self.representation
    }
}
impl IIfcSpatialElement for IfcSpatialZone {
    fn long_name(&self) -> &Option<IfcLabel> {
        &self.long_name
    }
}
impl IIfcSpatialZone for IfcSpatialZone {
    fn predefined_type(&self) -> &Option<IfcSpatialZoneTypeEnum> {
        &self.predefined_type
    }
}
impl IfcSpatialZone {
    pub fn from_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcSpatialZone::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.global_id = parameter.into(),
                1usize => {
                    entity.owner_history = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => {
                    entity.object_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                5usize => {
                    entity.object_placement = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                6usize => {
                    entity.representation = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                7usize => {
                    entity.long_name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                8usize => {
                    entity.predefined_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
    pub fn from_own_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcSpatialZone::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => {
                    entity.predefined_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcSpatialZoneType: IIfcSpatialElementType {
    fn predefined_type(&self) -> &IfcSpatialZoneTypeEnum;
    fn long_name(&self) -> &Option<IfcLabel>;
}
#[derive(Default, Debug)]
pub struct IfcSpatialZoneType {
    global_id: IfcGloballyUniqueId,
    owner_history: Option<EntityRef>,
    name: Option<IfcLabel>,
    description: Option<IfcText>,
    applicable_occurrence: Option<IfcIdentifier>,
    has_property_sets: Option<HashSet<EntityRef>>,
    representation_maps: Option<Vec<EntityRef>>,
    tag: Option<IfcLabel>,
    element_type: Option<IfcLabel>,
    predefined_type: IfcSpatialZoneTypeEnum,
    long_name: Option<IfcLabel>,
}
impl IIfcRoot for IfcSpatialZoneType {
    fn global_id(&self) -> &IfcGloballyUniqueId {
        &self.global_id
    }
    fn owner_history(&self) -> &Option<EntityRef> {
        &self.owner_history
    }
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
}
impl IIfcObjectDefinition for IfcSpatialZoneType {}
impl IIfcTypeObject for IfcSpatialZoneType {
    fn applicable_occurrence(&self) -> &Option<IfcIdentifier> {
        &self.applicable_occurrence
    }
    fn has_property_sets(&self) -> &Option<HashSet<EntityRef>> {
        &self.has_property_sets
    }
}
impl IIfcTypeProduct for IfcSpatialZoneType {
    fn representation_maps(&self) -> &Option<Vec<EntityRef>> {
        &self.representation_maps
    }
    fn tag(&self) -> &Option<IfcLabel> {
        &self.tag
    }
}
impl IIfcSpatialElementType for IfcSpatialZoneType {
    fn element_type(&self) -> &Option<IfcLabel> {
        &self.element_type
    }
}
impl IIfcSpatialZoneType for IfcSpatialZoneType {
    fn predefined_type(&self) -> &IfcSpatialZoneTypeEnum {
        &self.predefined_type
    }
    fn long_name(&self) -> &Option<IfcLabel> {
        &self.long_name
    }
}
impl IfcSpatialZoneType {
    pub fn from_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcSpatialZoneType::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.global_id = parameter.into(),
                1usize => {
                    entity.owner_history = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => {
                    entity.applicable_occurrence = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                5usize => {
                    entity.has_property_sets = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                6usize => {
                    entity.representation_maps = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                7usize => {
                    entity.tag = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                8usize => {
                    entity.element_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                9usize => entity.predefined_type = parameter.into(),
                10usize => {
                    entity.long_name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
    pub fn from_own_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcSpatialZoneType::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.predefined_type = parameter.into(),
                1usize => {
                    entity.long_name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcSphere: IIfcCsgPrimitive3D {
    fn radius(&self) -> &IfcPositiveLengthMeasure;
}
#[derive(Default, Debug)]
pub struct IfcSphere {
    position: EntityRef,
    radius: IfcPositiveLengthMeasure,
}
impl IIfcRepresentationItem for IfcSphere {}
impl IIfcGeometricRepresentationItem for IfcSphere {}
impl IIfcCsgPrimitive3D for IfcSphere {
    fn position(&self) -> &EntityRef {
        &self.position
    }
}
impl IIfcSphere for IfcSphere {
    fn radius(&self) -> &IfcPositiveLengthMeasure {
        &self.radius
    }
}
impl IfcSphere {
    pub fn from_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcSphere::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.position = parameter.into(),
                1usize => entity.radius = parameter.into(),
                _ => {}
            }
        }
        entity
    }
    pub fn from_own_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcSphere::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.radius = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcSphericalSurface: IIfcElementarySurface {
    fn radius(&self) -> &IfcPositiveLengthMeasure;
}
#[derive(Default, Debug)]
pub struct IfcSphericalSurface {
    position: EntityRef,
    radius: IfcPositiveLengthMeasure,
}
impl IIfcRepresentationItem for IfcSphericalSurface {}
impl IIfcGeometricRepresentationItem for IfcSphericalSurface {}
impl IIfcSurface for IfcSphericalSurface {}
impl IIfcElementarySurface for IfcSphericalSurface {
    fn position(&self) -> &EntityRef {
        &self.position
    }
}
impl IIfcSphericalSurface for IfcSphericalSurface {
    fn radius(&self) -> &IfcPositiveLengthMeasure {
        &self.radius
    }
}
impl IfcSphericalSurface {
    pub fn from_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcSphericalSurface::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.position = parameter.into(),
                1usize => entity.radius = parameter.into(),
                _ => {}
            }
        }
        entity
    }
    pub fn from_own_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcSphericalSurface::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.radius = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcStackTerminal: IIfcFlowTerminal {
    fn predefined_type(&self) -> &Option<IfcStackTerminalTypeEnum>;
}
#[derive(Default, Debug)]
pub struct IfcStackTerminal {
    global_id: IfcGloballyUniqueId,
    owner_history: Option<EntityRef>,
    name: Option<IfcLabel>,
    description: Option<IfcText>,
    object_type: Option<IfcLabel>,
    object_placement: Option<EntityRef>,
    representation: Option<EntityRef>,
    tag: Option<IfcIdentifier>,
    predefined_type: Option<IfcStackTerminalTypeEnum>,
}
impl IIfcRoot for IfcStackTerminal {
    fn global_id(&self) -> &IfcGloballyUniqueId {
        &self.global_id
    }
    fn owner_history(&self) -> &Option<EntityRef> {
        &self.owner_history
    }
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
}
impl IIfcObjectDefinition for IfcStackTerminal {}
impl IIfcObject for IfcStackTerminal {
    fn object_type(&self) -> &Option<IfcLabel> {
        &self.object_type
    }
}
impl IIfcProduct for IfcStackTerminal {
    fn object_placement(&self) -> &Option<EntityRef> {
        &self.object_placement
    }
    fn representation(&self) -> &Option<EntityRef> {
        &self.representation
    }
}
impl IIfcElement for IfcStackTerminal {
    fn tag(&self) -> &Option<IfcIdentifier> {
        &self.tag
    }
}
impl IIfcDistributionElement for IfcStackTerminal {}
impl IIfcDistributionFlowElement for IfcStackTerminal {}
impl IIfcFlowTerminal for IfcStackTerminal {}
impl IIfcStackTerminal for IfcStackTerminal {
    fn predefined_type(&self) -> &Option<IfcStackTerminalTypeEnum> {
        &self.predefined_type
    }
}
impl IfcStackTerminal {
    pub fn from_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcStackTerminal::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.global_id = parameter.into(),
                1usize => {
                    entity.owner_history = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => {
                    entity.object_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                5usize => {
                    entity.object_placement = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                6usize => {
                    entity.representation = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                7usize => {
                    entity.tag = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                8usize => {
                    entity.predefined_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
    pub fn from_own_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcStackTerminal::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => {
                    entity.predefined_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcStackTerminalType: IIfcFlowTerminalType {
    fn predefined_type(&self) -> &IfcStackTerminalTypeEnum;
}
#[derive(Default, Debug)]
pub struct IfcStackTerminalType {
    global_id: IfcGloballyUniqueId,
    owner_history: Option<EntityRef>,
    name: Option<IfcLabel>,
    description: Option<IfcText>,
    applicable_occurrence: Option<IfcIdentifier>,
    has_property_sets: Option<HashSet<EntityRef>>,
    representation_maps: Option<Vec<EntityRef>>,
    tag: Option<IfcLabel>,
    element_type: Option<IfcLabel>,
    predefined_type: IfcStackTerminalTypeEnum,
}
impl IIfcRoot for IfcStackTerminalType {
    fn global_id(&self) -> &IfcGloballyUniqueId {
        &self.global_id
    }
    fn owner_history(&self) -> &Option<EntityRef> {
        &self.owner_history
    }
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
}
impl IIfcObjectDefinition for IfcStackTerminalType {}
impl IIfcTypeObject for IfcStackTerminalType {
    fn applicable_occurrence(&self) -> &Option<IfcIdentifier> {
        &self.applicable_occurrence
    }
    fn has_property_sets(&self) -> &Option<HashSet<EntityRef>> {
        &self.has_property_sets
    }
}
impl IIfcTypeProduct for IfcStackTerminalType {
    fn representation_maps(&self) -> &Option<Vec<EntityRef>> {
        &self.representation_maps
    }
    fn tag(&self) -> &Option<IfcLabel> {
        &self.tag
    }
}
impl IIfcElementType for IfcStackTerminalType {
    fn element_type(&self) -> &Option<IfcLabel> {
        &self.element_type
    }
}
impl IIfcDistributionElementType for IfcStackTerminalType {}
impl IIfcDistributionFlowElementType for IfcStackTerminalType {}
impl IIfcFlowTerminalType for IfcStackTerminalType {}
impl IIfcStackTerminalType for IfcStackTerminalType {
    fn predefined_type(&self) -> &IfcStackTerminalTypeEnum {
        &self.predefined_type
    }
}
impl IfcStackTerminalType {
    pub fn from_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcStackTerminalType::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.global_id = parameter.into(),
                1usize => {
                    entity.owner_history = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => {
                    entity.applicable_occurrence = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                5usize => {
                    entity.has_property_sets = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                6usize => {
                    entity.representation_maps = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                7usize => {
                    entity.tag = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                8usize => {
                    entity.element_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                9usize => entity.predefined_type = parameter.into(),
                _ => {}
            }
        }
        entity
    }
    pub fn from_own_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcStackTerminalType::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.predefined_type = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcStair: IIfcBuildingElement {
    fn predefined_type(&self) -> &Option<IfcStairTypeEnum>;
}
#[derive(Default, Debug)]
pub struct IfcStair {
    global_id: IfcGloballyUniqueId,
    owner_history: Option<EntityRef>,
    name: Option<IfcLabel>,
    description: Option<IfcText>,
    object_type: Option<IfcLabel>,
    object_placement: Option<EntityRef>,
    representation: Option<EntityRef>,
    tag: Option<IfcIdentifier>,
    predefined_type: Option<IfcStairTypeEnum>,
}
impl IIfcRoot for IfcStair {
    fn global_id(&self) -> &IfcGloballyUniqueId {
        &self.global_id
    }
    fn owner_history(&self) -> &Option<EntityRef> {
        &self.owner_history
    }
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
}
impl IIfcObjectDefinition for IfcStair {}
impl IIfcObject for IfcStair {
    fn object_type(&self) -> &Option<IfcLabel> {
        &self.object_type
    }
}
impl IIfcProduct for IfcStair {
    fn object_placement(&self) -> &Option<EntityRef> {
        &self.object_placement
    }
    fn representation(&self) -> &Option<EntityRef> {
        &self.representation
    }
}
impl IIfcElement for IfcStair {
    fn tag(&self) -> &Option<IfcIdentifier> {
        &self.tag
    }
}
impl IIfcBuildingElement for IfcStair {}
impl IIfcStair for IfcStair {
    fn predefined_type(&self) -> &Option<IfcStairTypeEnum> {
        &self.predefined_type
    }
}
impl IfcStair {
    pub fn from_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcStair::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.global_id = parameter.into(),
                1usize => {
                    entity.owner_history = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => {
                    entity.object_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                5usize => {
                    entity.object_placement = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                6usize => {
                    entity.representation = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                7usize => {
                    entity.tag = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                8usize => {
                    entity.predefined_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
    pub fn from_own_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcStair::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => {
                    entity.predefined_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcStairFlight: IIfcBuildingElement {
    fn number_of_risers(&self) -> &Option<IfcInteger>;
    fn number_of_treads(&self) -> &Option<IfcInteger>;
    fn riser_height(&self) -> &Option<IfcPositiveLengthMeasure>;
    fn tread_length(&self) -> &Option<IfcPositiveLengthMeasure>;
    fn predefined_type(&self) -> &Option<IfcStairFlightTypeEnum>;
}
#[derive(Default, Debug)]
pub struct IfcStairFlight {
    global_id: IfcGloballyUniqueId,
    owner_history: Option<EntityRef>,
    name: Option<IfcLabel>,
    description: Option<IfcText>,
    object_type: Option<IfcLabel>,
    object_placement: Option<EntityRef>,
    representation: Option<EntityRef>,
    tag: Option<IfcIdentifier>,
    number_of_risers: Option<IfcInteger>,
    number_of_treads: Option<IfcInteger>,
    riser_height: Option<IfcPositiveLengthMeasure>,
    tread_length: Option<IfcPositiveLengthMeasure>,
    predefined_type: Option<IfcStairFlightTypeEnum>,
}
impl IIfcRoot for IfcStairFlight {
    fn global_id(&self) -> &IfcGloballyUniqueId {
        &self.global_id
    }
    fn owner_history(&self) -> &Option<EntityRef> {
        &self.owner_history
    }
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
}
impl IIfcObjectDefinition for IfcStairFlight {}
impl IIfcObject for IfcStairFlight {
    fn object_type(&self) -> &Option<IfcLabel> {
        &self.object_type
    }
}
impl IIfcProduct for IfcStairFlight {
    fn object_placement(&self) -> &Option<EntityRef> {
        &self.object_placement
    }
    fn representation(&self) -> &Option<EntityRef> {
        &self.representation
    }
}
impl IIfcElement for IfcStairFlight {
    fn tag(&self) -> &Option<IfcIdentifier> {
        &self.tag
    }
}
impl IIfcBuildingElement for IfcStairFlight {}
impl IIfcStairFlight for IfcStairFlight {
    fn number_of_risers(&self) -> &Option<IfcInteger> {
        &self.number_of_risers
    }
    fn number_of_treads(&self) -> &Option<IfcInteger> {
        &self.number_of_treads
    }
    fn riser_height(&self) -> &Option<IfcPositiveLengthMeasure> {
        &self.riser_height
    }
    fn tread_length(&self) -> &Option<IfcPositiveLengthMeasure> {
        &self.tread_length
    }
    fn predefined_type(&self) -> &Option<IfcStairFlightTypeEnum> {
        &self.predefined_type
    }
}
impl IfcStairFlight {
    pub fn from_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcStairFlight::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.global_id = parameter.into(),
                1usize => {
                    entity.owner_history = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => {
                    entity.object_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                5usize => {
                    entity.object_placement = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                6usize => {
                    entity.representation = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                7usize => {
                    entity.tag = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                8usize => {
                    entity.number_of_risers = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                9usize => {
                    entity.number_of_treads = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                10usize => {
                    entity.riser_height = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                11usize => {
                    entity.tread_length = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                12usize => {
                    entity.predefined_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
    pub fn from_own_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcStairFlight::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => {
                    entity.number_of_risers = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                1usize => {
                    entity.number_of_treads = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => {
                    entity.riser_height = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.tread_length = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => {
                    entity.predefined_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcStairFlightType: IIfcBuildingElementType {
    fn predefined_type(&self) -> &IfcStairFlightTypeEnum;
}
#[derive(Default, Debug)]
pub struct IfcStairFlightType {
    global_id: IfcGloballyUniqueId,
    owner_history: Option<EntityRef>,
    name: Option<IfcLabel>,
    description: Option<IfcText>,
    applicable_occurrence: Option<IfcIdentifier>,
    has_property_sets: Option<HashSet<EntityRef>>,
    representation_maps: Option<Vec<EntityRef>>,
    tag: Option<IfcLabel>,
    element_type: Option<IfcLabel>,
    predefined_type: IfcStairFlightTypeEnum,
}
impl IIfcRoot for IfcStairFlightType {
    fn global_id(&self) -> &IfcGloballyUniqueId {
        &self.global_id
    }
    fn owner_history(&self) -> &Option<EntityRef> {
        &self.owner_history
    }
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
}
impl IIfcObjectDefinition for IfcStairFlightType {}
impl IIfcTypeObject for IfcStairFlightType {
    fn applicable_occurrence(&self) -> &Option<IfcIdentifier> {
        &self.applicable_occurrence
    }
    fn has_property_sets(&self) -> &Option<HashSet<EntityRef>> {
        &self.has_property_sets
    }
}
impl IIfcTypeProduct for IfcStairFlightType {
    fn representation_maps(&self) -> &Option<Vec<EntityRef>> {
        &self.representation_maps
    }
    fn tag(&self) -> &Option<IfcLabel> {
        &self.tag
    }
}
impl IIfcElementType for IfcStairFlightType {
    fn element_type(&self) -> &Option<IfcLabel> {
        &self.element_type
    }
}
impl IIfcBuildingElementType for IfcStairFlightType {}
impl IIfcStairFlightType for IfcStairFlightType {
    fn predefined_type(&self) -> &IfcStairFlightTypeEnum {
        &self.predefined_type
    }
}
impl IfcStairFlightType {
    pub fn from_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcStairFlightType::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.global_id = parameter.into(),
                1usize => {
                    entity.owner_history = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => {
                    entity.applicable_occurrence = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                5usize => {
                    entity.has_property_sets = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                6usize => {
                    entity.representation_maps = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                7usize => {
                    entity.tag = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                8usize => {
                    entity.element_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                9usize => entity.predefined_type = parameter.into(),
                _ => {}
            }
        }
        entity
    }
    pub fn from_own_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcStairFlightType::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.predefined_type = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcStairType: IIfcBuildingElementType {
    fn predefined_type(&self) -> &IfcStairTypeEnum;
}
#[derive(Default, Debug)]
pub struct IfcStairType {
    global_id: IfcGloballyUniqueId,
    owner_history: Option<EntityRef>,
    name: Option<IfcLabel>,
    description: Option<IfcText>,
    applicable_occurrence: Option<IfcIdentifier>,
    has_property_sets: Option<HashSet<EntityRef>>,
    representation_maps: Option<Vec<EntityRef>>,
    tag: Option<IfcLabel>,
    element_type: Option<IfcLabel>,
    predefined_type: IfcStairTypeEnum,
}
impl IIfcRoot for IfcStairType {
    fn global_id(&self) -> &IfcGloballyUniqueId {
        &self.global_id
    }
    fn owner_history(&self) -> &Option<EntityRef> {
        &self.owner_history
    }
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
}
impl IIfcObjectDefinition for IfcStairType {}
impl IIfcTypeObject for IfcStairType {
    fn applicable_occurrence(&self) -> &Option<IfcIdentifier> {
        &self.applicable_occurrence
    }
    fn has_property_sets(&self) -> &Option<HashSet<EntityRef>> {
        &self.has_property_sets
    }
}
impl IIfcTypeProduct for IfcStairType {
    fn representation_maps(&self) -> &Option<Vec<EntityRef>> {
        &self.representation_maps
    }
    fn tag(&self) -> &Option<IfcLabel> {
        &self.tag
    }
}
impl IIfcElementType for IfcStairType {
    fn element_type(&self) -> &Option<IfcLabel> {
        &self.element_type
    }
}
impl IIfcBuildingElementType for IfcStairType {}
impl IIfcStairType for IfcStairType {
    fn predefined_type(&self) -> &IfcStairTypeEnum {
        &self.predefined_type
    }
}
impl IfcStairType {
    pub fn from_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcStairType::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.global_id = parameter.into(),
                1usize => {
                    entity.owner_history = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => {
                    entity.applicable_occurrence = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                5usize => {
                    entity.has_property_sets = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                6usize => {
                    entity.representation_maps = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                7usize => {
                    entity.tag = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                8usize => {
                    entity.element_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                9usize => entity.predefined_type = parameter.into(),
                _ => {}
            }
        }
        entity
    }
    pub fn from_own_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcStairType::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.predefined_type = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcStructuralAction: IIfcStructuralActivity {
    fn destabilizing_load(&self) -> &Option<IfcBoolean>;
}
pub trait IIfcStructuralActivity: IIfcProduct {
    fn applied_load(&self) -> &EntityRef;
    fn global_or_local(&self) -> &IfcGlobalOrLocalEnum;
}
pub trait IIfcStructuralAnalysisModel: IIfcSystem {
    fn predefined_type(&self) -> &IfcAnalysisModelTypeEnum;
    fn orientation_of2_d_plane(&self) -> &Option<EntityRef>;
    fn loaded_by(&self) -> &Option<HashSet<EntityRef>>;
    fn has_results(&self) -> &Option<HashSet<EntityRef>>;
    fn shared_placement(&self) -> &Option<EntityRef>;
}
#[derive(Default, Debug)]
pub struct IfcStructuralAnalysisModel {
    global_id: IfcGloballyUniqueId,
    owner_history: Option<EntityRef>,
    name: Option<IfcLabel>,
    description: Option<IfcText>,
    object_type: Option<IfcLabel>,
    predefined_type: IfcAnalysisModelTypeEnum,
    orientation_of2_d_plane: Option<EntityRef>,
    loaded_by: Option<HashSet<EntityRef>>,
    has_results: Option<HashSet<EntityRef>>,
    shared_placement: Option<EntityRef>,
}
impl IIfcRoot for IfcStructuralAnalysisModel {
    fn global_id(&self) -> &IfcGloballyUniqueId {
        &self.global_id
    }
    fn owner_history(&self) -> &Option<EntityRef> {
        &self.owner_history
    }
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
}
impl IIfcObjectDefinition for IfcStructuralAnalysisModel {}
impl IIfcObject for IfcStructuralAnalysisModel {
    fn object_type(&self) -> &Option<IfcLabel> {
        &self.object_type
    }
}
impl IIfcGroup for IfcStructuralAnalysisModel {}
impl IIfcSystem for IfcStructuralAnalysisModel {}
impl IIfcStructuralAnalysisModel for IfcStructuralAnalysisModel {
    fn predefined_type(&self) -> &IfcAnalysisModelTypeEnum {
        &self.predefined_type
    }
    fn orientation_of2_d_plane(&self) -> &Option<EntityRef> {
        &self.orientation_of2_d_plane
    }
    fn loaded_by(&self) -> &Option<HashSet<EntityRef>> {
        &self.loaded_by
    }
    fn has_results(&self) -> &Option<HashSet<EntityRef>> {
        &self.has_results
    }
    fn shared_placement(&self) -> &Option<EntityRef> {
        &self.shared_placement
    }
}
impl IfcStructuralAnalysisModel {
    pub fn from_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcStructuralAnalysisModel::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.global_id = parameter.into(),
                1usize => {
                    entity.owner_history = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => {
                    entity.object_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                5usize => entity.predefined_type = parameter.into(),
                6usize => {
                    entity.orientation_of2_d_plane = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                7usize => {
                    entity.loaded_by = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                8usize => {
                    entity.has_results = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                9usize => {
                    entity.shared_placement = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
    pub fn from_own_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcStructuralAnalysisModel::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.predefined_type = parameter.into(),
                1usize => {
                    entity.orientation_of2_d_plane = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => {
                    entity.loaded_by = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.has_results = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => {
                    entity.shared_placement = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcStructuralConnection: IIfcStructuralItem {
    fn applied_condition(&self) -> &Option<EntityRef>;
}
pub trait IIfcStructuralConnectionCondition {
    fn name(&self) -> &Option<IfcLabel>;
}
pub trait IIfcStructuralCurveAction: IIfcStructuralAction {
    fn projected_or_true(&self) -> &Option<IfcProjectedOrTrueLengthEnum>;
    fn predefined_type(&self) -> &IfcStructuralCurveActivityTypeEnum;
}
#[derive(Default, Debug)]
pub struct IfcStructuralCurveAction {
    global_id: IfcGloballyUniqueId,
    owner_history: Option<EntityRef>,
    name: Option<IfcLabel>,
    description: Option<IfcText>,
    object_type: Option<IfcLabel>,
    object_placement: Option<EntityRef>,
    representation: Option<EntityRef>,
    applied_load: EntityRef,
    global_or_local: IfcGlobalOrLocalEnum,
    destabilizing_load: Option<IfcBoolean>,
    projected_or_true: Option<IfcProjectedOrTrueLengthEnum>,
    predefined_type: IfcStructuralCurveActivityTypeEnum,
}
impl IIfcRoot for IfcStructuralCurveAction {
    fn global_id(&self) -> &IfcGloballyUniqueId {
        &self.global_id
    }
    fn owner_history(&self) -> &Option<EntityRef> {
        &self.owner_history
    }
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
}
impl IIfcObjectDefinition for IfcStructuralCurveAction {}
impl IIfcObject for IfcStructuralCurveAction {
    fn object_type(&self) -> &Option<IfcLabel> {
        &self.object_type
    }
}
impl IIfcProduct for IfcStructuralCurveAction {
    fn object_placement(&self) -> &Option<EntityRef> {
        &self.object_placement
    }
    fn representation(&self) -> &Option<EntityRef> {
        &self.representation
    }
}
impl IIfcStructuralActivity for IfcStructuralCurveAction {
    fn applied_load(&self) -> &EntityRef {
        &self.applied_load
    }
    fn global_or_local(&self) -> &IfcGlobalOrLocalEnum {
        &self.global_or_local
    }
}
impl IIfcStructuralAction for IfcStructuralCurveAction {
    fn destabilizing_load(&self) -> &Option<IfcBoolean> {
        &self.destabilizing_load
    }
}
impl IIfcStructuralCurveAction for IfcStructuralCurveAction {
    fn projected_or_true(&self) -> &Option<IfcProjectedOrTrueLengthEnum> {
        &self.projected_or_true
    }
    fn predefined_type(&self) -> &IfcStructuralCurveActivityTypeEnum {
        &self.predefined_type
    }
}
impl IfcStructuralCurveAction {
    pub fn from_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcStructuralCurveAction::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.global_id = parameter.into(),
                1usize => {
                    entity.owner_history = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => {
                    entity.object_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                5usize => {
                    entity.object_placement = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                6usize => {
                    entity.representation = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                7usize => entity.applied_load = parameter.into(),
                8usize => entity.global_or_local = parameter.into(),
                9usize => {
                    entity.destabilizing_load = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                10usize => {
                    entity.projected_or_true = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                11usize => entity.predefined_type = parameter.into(),
                _ => {}
            }
        }
        entity
    }
    pub fn from_own_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcStructuralCurveAction::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => {
                    entity.projected_or_true = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                1usize => entity.predefined_type = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcStructuralCurveConnection: IIfcStructuralConnection {
    fn axis(&self) -> &EntityRef;
}
#[derive(Default, Debug)]
pub struct IfcStructuralCurveConnection {
    global_id: IfcGloballyUniqueId,
    owner_history: Option<EntityRef>,
    name: Option<IfcLabel>,
    description: Option<IfcText>,
    object_type: Option<IfcLabel>,
    object_placement: Option<EntityRef>,
    representation: Option<EntityRef>,
    applied_condition: Option<EntityRef>,
    axis: EntityRef,
}
impl IIfcRoot for IfcStructuralCurveConnection {
    fn global_id(&self) -> &IfcGloballyUniqueId {
        &self.global_id
    }
    fn owner_history(&self) -> &Option<EntityRef> {
        &self.owner_history
    }
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
}
impl IIfcObjectDefinition for IfcStructuralCurveConnection {}
impl IIfcObject for IfcStructuralCurveConnection {
    fn object_type(&self) -> &Option<IfcLabel> {
        &self.object_type
    }
}
impl IIfcProduct for IfcStructuralCurveConnection {
    fn object_placement(&self) -> &Option<EntityRef> {
        &self.object_placement
    }
    fn representation(&self) -> &Option<EntityRef> {
        &self.representation
    }
}
impl IIfcStructuralItem for IfcStructuralCurveConnection {}
impl IIfcStructuralConnection for IfcStructuralCurveConnection {
    fn applied_condition(&self) -> &Option<EntityRef> {
        &self.applied_condition
    }
}
impl IIfcStructuralCurveConnection for IfcStructuralCurveConnection {
    fn axis(&self) -> &EntityRef {
        &self.axis
    }
}
impl IfcStructuralCurveConnection {
    pub fn from_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcStructuralCurveConnection::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.global_id = parameter.into(),
                1usize => {
                    entity.owner_history = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => {
                    entity.object_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                5usize => {
                    entity.object_placement = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                6usize => {
                    entity.representation = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                7usize => {
                    entity.applied_condition = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                8usize => entity.axis = parameter.into(),
                _ => {}
            }
        }
        entity
    }
    pub fn from_own_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcStructuralCurveConnection::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.axis = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcStructuralCurveMember: IIfcStructuralMember {
    fn predefined_type(&self) -> &IfcStructuralCurveMemberTypeEnum;
    fn axis(&self) -> &EntityRef;
}
#[derive(Default, Debug)]
pub struct IfcStructuralCurveMember {
    global_id: IfcGloballyUniqueId,
    owner_history: Option<EntityRef>,
    name: Option<IfcLabel>,
    description: Option<IfcText>,
    object_type: Option<IfcLabel>,
    object_placement: Option<EntityRef>,
    representation: Option<EntityRef>,
    predefined_type: IfcStructuralCurveMemberTypeEnum,
    axis: EntityRef,
}
impl IIfcRoot for IfcStructuralCurveMember {
    fn global_id(&self) -> &IfcGloballyUniqueId {
        &self.global_id
    }
    fn owner_history(&self) -> &Option<EntityRef> {
        &self.owner_history
    }
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
}
impl IIfcObjectDefinition for IfcStructuralCurveMember {}
impl IIfcObject for IfcStructuralCurveMember {
    fn object_type(&self) -> &Option<IfcLabel> {
        &self.object_type
    }
}
impl IIfcProduct for IfcStructuralCurveMember {
    fn object_placement(&self) -> &Option<EntityRef> {
        &self.object_placement
    }
    fn representation(&self) -> &Option<EntityRef> {
        &self.representation
    }
}
impl IIfcStructuralItem for IfcStructuralCurveMember {}
impl IIfcStructuralMember for IfcStructuralCurveMember {}
impl IIfcStructuralCurveMember for IfcStructuralCurveMember {
    fn predefined_type(&self) -> &IfcStructuralCurveMemberTypeEnum {
        &self.predefined_type
    }
    fn axis(&self) -> &EntityRef {
        &self.axis
    }
}
impl IfcStructuralCurveMember {
    pub fn from_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcStructuralCurveMember::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.global_id = parameter.into(),
                1usize => {
                    entity.owner_history = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => {
                    entity.object_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                5usize => {
                    entity.object_placement = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                6usize => {
                    entity.representation = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                7usize => entity.predefined_type = parameter.into(),
                8usize => entity.axis = parameter.into(),
                _ => {}
            }
        }
        entity
    }
    pub fn from_own_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcStructuralCurveMember::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.predefined_type = parameter.into(),
                1usize => entity.axis = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcStructuralCurveMemberVarying: IIfcStructuralCurveMember {}
#[derive(Default, Debug)]
pub struct IfcStructuralCurveMemberVarying {
    global_id: IfcGloballyUniqueId,
    owner_history: Option<EntityRef>,
    name: Option<IfcLabel>,
    description: Option<IfcText>,
    object_type: Option<IfcLabel>,
    object_placement: Option<EntityRef>,
    representation: Option<EntityRef>,
    predefined_type: IfcStructuralCurveMemberTypeEnum,
    axis: EntityRef,
}
impl IIfcRoot for IfcStructuralCurveMemberVarying {
    fn global_id(&self) -> &IfcGloballyUniqueId {
        &self.global_id
    }
    fn owner_history(&self) -> &Option<EntityRef> {
        &self.owner_history
    }
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
}
impl IIfcObjectDefinition for IfcStructuralCurveMemberVarying {}
impl IIfcObject for IfcStructuralCurveMemberVarying {
    fn object_type(&self) -> &Option<IfcLabel> {
        &self.object_type
    }
}
impl IIfcProduct for IfcStructuralCurveMemberVarying {
    fn object_placement(&self) -> &Option<EntityRef> {
        &self.object_placement
    }
    fn representation(&self) -> &Option<EntityRef> {
        &self.representation
    }
}
impl IIfcStructuralItem for IfcStructuralCurveMemberVarying {}
impl IIfcStructuralMember for IfcStructuralCurveMemberVarying {}
impl IIfcStructuralCurveMember for IfcStructuralCurveMemberVarying {
    fn predefined_type(&self) -> &IfcStructuralCurveMemberTypeEnum {
        &self.predefined_type
    }
    fn axis(&self) -> &EntityRef {
        &self.axis
    }
}
impl IIfcStructuralCurveMemberVarying for IfcStructuralCurveMemberVarying {}
impl IfcStructuralCurveMemberVarying {
    pub fn from_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcStructuralCurveMemberVarying::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.global_id = parameter.into(),
                1usize => {
                    entity.owner_history = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => {
                    entity.object_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                5usize => {
                    entity.object_placement = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                6usize => {
                    entity.representation = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                7usize => entity.predefined_type = parameter.into(),
                8usize => entity.axis = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcStructuralCurveReaction: IIfcStructuralReaction {
    fn predefined_type(&self) -> &IfcStructuralCurveActivityTypeEnum;
}
#[derive(Default, Debug)]
pub struct IfcStructuralCurveReaction {
    global_id: IfcGloballyUniqueId,
    owner_history: Option<EntityRef>,
    name: Option<IfcLabel>,
    description: Option<IfcText>,
    object_type: Option<IfcLabel>,
    object_placement: Option<EntityRef>,
    representation: Option<EntityRef>,
    applied_load: EntityRef,
    global_or_local: IfcGlobalOrLocalEnum,
    predefined_type: IfcStructuralCurveActivityTypeEnum,
}
impl IIfcRoot for IfcStructuralCurveReaction {
    fn global_id(&self) -> &IfcGloballyUniqueId {
        &self.global_id
    }
    fn owner_history(&self) -> &Option<EntityRef> {
        &self.owner_history
    }
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
}
impl IIfcObjectDefinition for IfcStructuralCurveReaction {}
impl IIfcObject for IfcStructuralCurveReaction {
    fn object_type(&self) -> &Option<IfcLabel> {
        &self.object_type
    }
}
impl IIfcProduct for IfcStructuralCurveReaction {
    fn object_placement(&self) -> &Option<EntityRef> {
        &self.object_placement
    }
    fn representation(&self) -> &Option<EntityRef> {
        &self.representation
    }
}
impl IIfcStructuralActivity for IfcStructuralCurveReaction {
    fn applied_load(&self) -> &EntityRef {
        &self.applied_load
    }
    fn global_or_local(&self) -> &IfcGlobalOrLocalEnum {
        &self.global_or_local
    }
}
impl IIfcStructuralReaction for IfcStructuralCurveReaction {}
impl IIfcStructuralCurveReaction for IfcStructuralCurveReaction {
    fn predefined_type(&self) -> &IfcStructuralCurveActivityTypeEnum {
        &self.predefined_type
    }
}
impl IfcStructuralCurveReaction {
    pub fn from_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcStructuralCurveReaction::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.global_id = parameter.into(),
                1usize => {
                    entity.owner_history = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => {
                    entity.object_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                5usize => {
                    entity.object_placement = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                6usize => {
                    entity.representation = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                7usize => entity.applied_load = parameter.into(),
                8usize => entity.global_or_local = parameter.into(),
                9usize => entity.predefined_type = parameter.into(),
                _ => {}
            }
        }
        entity
    }
    pub fn from_own_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcStructuralCurveReaction::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.predefined_type = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcStructuralItem: IIfcProduct {}
pub trait IIfcStructuralLinearAction: IIfcStructuralCurveAction {}
#[derive(Default, Debug)]
pub struct IfcStructuralLinearAction {
    global_id: IfcGloballyUniqueId,
    owner_history: Option<EntityRef>,
    name: Option<IfcLabel>,
    description: Option<IfcText>,
    object_type: Option<IfcLabel>,
    object_placement: Option<EntityRef>,
    representation: Option<EntityRef>,
    applied_load: EntityRef,
    global_or_local: IfcGlobalOrLocalEnum,
    destabilizing_load: Option<IfcBoolean>,
    projected_or_true: Option<IfcProjectedOrTrueLengthEnum>,
    predefined_type: IfcStructuralCurveActivityTypeEnum,
}
impl IIfcRoot for IfcStructuralLinearAction {
    fn global_id(&self) -> &IfcGloballyUniqueId {
        &self.global_id
    }
    fn owner_history(&self) -> &Option<EntityRef> {
        &self.owner_history
    }
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
}
impl IIfcObjectDefinition for IfcStructuralLinearAction {}
impl IIfcObject for IfcStructuralLinearAction {
    fn object_type(&self) -> &Option<IfcLabel> {
        &self.object_type
    }
}
impl IIfcProduct for IfcStructuralLinearAction {
    fn object_placement(&self) -> &Option<EntityRef> {
        &self.object_placement
    }
    fn representation(&self) -> &Option<EntityRef> {
        &self.representation
    }
}
impl IIfcStructuralActivity for IfcStructuralLinearAction {
    fn applied_load(&self) -> &EntityRef {
        &self.applied_load
    }
    fn global_or_local(&self) -> &IfcGlobalOrLocalEnum {
        &self.global_or_local
    }
}
impl IIfcStructuralAction for IfcStructuralLinearAction {
    fn destabilizing_load(&self) -> &Option<IfcBoolean> {
        &self.destabilizing_load
    }
}
impl IIfcStructuralCurveAction for IfcStructuralLinearAction {
    fn projected_or_true(&self) -> &Option<IfcProjectedOrTrueLengthEnum> {
        &self.projected_or_true
    }
    fn predefined_type(&self) -> &IfcStructuralCurveActivityTypeEnum {
        &self.predefined_type
    }
}
impl IIfcStructuralLinearAction for IfcStructuralLinearAction {}
impl IfcStructuralLinearAction {
    pub fn from_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcStructuralLinearAction::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.global_id = parameter.into(),
                1usize => {
                    entity.owner_history = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => {
                    entity.object_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                5usize => {
                    entity.object_placement = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                6usize => {
                    entity.representation = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                7usize => entity.applied_load = parameter.into(),
                8usize => entity.global_or_local = parameter.into(),
                9usize => {
                    entity.destabilizing_load = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                10usize => {
                    entity.projected_or_true = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                11usize => entity.predefined_type = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcStructuralLoad {
    fn name(&self) -> &Option<IfcLabel>;
}
pub trait IIfcStructuralLoadCase: IIfcStructuralLoadGroup {
    fn self_weight_coefficients(&self) -> &Option<Vec<IfcRatioMeasure>>;
}
#[derive(Default, Debug)]
pub struct IfcStructuralLoadCase {
    global_id: IfcGloballyUniqueId,
    owner_history: Option<EntityRef>,
    name: Option<IfcLabel>,
    description: Option<IfcText>,
    object_type: Option<IfcLabel>,
    predefined_type: IfcLoadGroupTypeEnum,
    action_type: IfcActionTypeEnum,
    action_source: IfcActionSourceTypeEnum,
    coefficient: Option<IfcRatioMeasure>,
    purpose: Option<IfcLabel>,
    self_weight_coefficients: Option<Vec<IfcRatioMeasure>>,
}
impl IIfcRoot for IfcStructuralLoadCase {
    fn global_id(&self) -> &IfcGloballyUniqueId {
        &self.global_id
    }
    fn owner_history(&self) -> &Option<EntityRef> {
        &self.owner_history
    }
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
}
impl IIfcObjectDefinition for IfcStructuralLoadCase {}
impl IIfcObject for IfcStructuralLoadCase {
    fn object_type(&self) -> &Option<IfcLabel> {
        &self.object_type
    }
}
impl IIfcGroup for IfcStructuralLoadCase {}
impl IIfcStructuralLoadGroup for IfcStructuralLoadCase {
    fn predefined_type(&self) -> &IfcLoadGroupTypeEnum {
        &self.predefined_type
    }
    fn action_type(&self) -> &IfcActionTypeEnum {
        &self.action_type
    }
    fn action_source(&self) -> &IfcActionSourceTypeEnum {
        &self.action_source
    }
    fn coefficient(&self) -> &Option<IfcRatioMeasure> {
        &self.coefficient
    }
    fn purpose(&self) -> &Option<IfcLabel> {
        &self.purpose
    }
}
impl IIfcStructuralLoadCase for IfcStructuralLoadCase {
    fn self_weight_coefficients(&self) -> &Option<Vec<IfcRatioMeasure>> {
        &self.self_weight_coefficients
    }
}
impl IfcStructuralLoadCase {
    pub fn from_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcStructuralLoadCase::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.global_id = parameter.into(),
                1usize => {
                    entity.owner_history = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => {
                    entity.object_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                5usize => entity.predefined_type = parameter.into(),
                6usize => entity.action_type = parameter.into(),
                7usize => entity.action_source = parameter.into(),
                8usize => {
                    entity.coefficient = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                9usize => {
                    entity.purpose = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                10usize => {
                    entity.self_weight_coefficients = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
    pub fn from_own_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcStructuralLoadCase::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => {
                    entity.self_weight_coefficients = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcStructuralLoadConfiguration: IIfcStructuralLoad {
    fn values(&self) -> &Vec<EntityRef>;
    fn locations(&self) -> &Option<Vec<Vec<IfcLengthMeasure>>>;
}
#[derive(Default, Debug)]
pub struct IfcStructuralLoadConfiguration {
    name: Option<IfcLabel>,
    values: Vec<EntityRef>,
    locations: Option<Vec<Vec<IfcLengthMeasure>>>,
}
impl IIfcStructuralLoad for IfcStructuralLoadConfiguration {
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
}
impl IIfcStructuralLoadConfiguration for IfcStructuralLoadConfiguration {
    fn values(&self) -> &Vec<EntityRef> {
        &self.values
    }
    fn locations(&self) -> &Option<Vec<Vec<IfcLengthMeasure>>> {
        &self.locations
    }
}
impl IfcStructuralLoadConfiguration {
    pub fn from_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcStructuralLoadConfiguration::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                1usize => entity.values = parameter.into(),
                2usize => {
                    entity.locations = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
    pub fn from_own_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcStructuralLoadConfiguration::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.values = parameter.into(),
                1usize => {
                    entity.locations = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcStructuralLoadGroup: IIfcGroup {
    fn predefined_type(&self) -> &IfcLoadGroupTypeEnum;
    fn action_type(&self) -> &IfcActionTypeEnum;
    fn action_source(&self) -> &IfcActionSourceTypeEnum;
    fn coefficient(&self) -> &Option<IfcRatioMeasure>;
    fn purpose(&self) -> &Option<IfcLabel>;
}
#[derive(Default, Debug)]
pub struct IfcStructuralLoadGroup {
    global_id: IfcGloballyUniqueId,
    owner_history: Option<EntityRef>,
    name: Option<IfcLabel>,
    description: Option<IfcText>,
    object_type: Option<IfcLabel>,
    predefined_type: IfcLoadGroupTypeEnum,
    action_type: IfcActionTypeEnum,
    action_source: IfcActionSourceTypeEnum,
    coefficient: Option<IfcRatioMeasure>,
    purpose: Option<IfcLabel>,
}
impl IIfcRoot for IfcStructuralLoadGroup {
    fn global_id(&self) -> &IfcGloballyUniqueId {
        &self.global_id
    }
    fn owner_history(&self) -> &Option<EntityRef> {
        &self.owner_history
    }
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
}
impl IIfcObjectDefinition for IfcStructuralLoadGroup {}
impl IIfcObject for IfcStructuralLoadGroup {
    fn object_type(&self) -> &Option<IfcLabel> {
        &self.object_type
    }
}
impl IIfcGroup for IfcStructuralLoadGroup {}
impl IIfcStructuralLoadGroup for IfcStructuralLoadGroup {
    fn predefined_type(&self) -> &IfcLoadGroupTypeEnum {
        &self.predefined_type
    }
    fn action_type(&self) -> &IfcActionTypeEnum {
        &self.action_type
    }
    fn action_source(&self) -> &IfcActionSourceTypeEnum {
        &self.action_source
    }
    fn coefficient(&self) -> &Option<IfcRatioMeasure> {
        &self.coefficient
    }
    fn purpose(&self) -> &Option<IfcLabel> {
        &self.purpose
    }
}
impl IfcStructuralLoadGroup {
    pub fn from_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcStructuralLoadGroup::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.global_id = parameter.into(),
                1usize => {
                    entity.owner_history = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => {
                    entity.object_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                5usize => entity.predefined_type = parameter.into(),
                6usize => entity.action_type = parameter.into(),
                7usize => entity.action_source = parameter.into(),
                8usize => {
                    entity.coefficient = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                9usize => {
                    entity.purpose = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
    pub fn from_own_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcStructuralLoadGroup::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.predefined_type = parameter.into(),
                1usize => entity.action_type = parameter.into(),
                2usize => entity.action_source = parameter.into(),
                3usize => {
                    entity.coefficient = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => {
                    entity.purpose = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcStructuralLoadLinearForce: IIfcStructuralLoadStatic {
    fn linear_force_x(&self) -> &Option<IfcLinearForceMeasure>;
    fn linear_force_y(&self) -> &Option<IfcLinearForceMeasure>;
    fn linear_force_z(&self) -> &Option<IfcLinearForceMeasure>;
    fn linear_moment_x(&self) -> &Option<IfcLinearMomentMeasure>;
    fn linear_moment_y(&self) -> &Option<IfcLinearMomentMeasure>;
    fn linear_moment_z(&self) -> &Option<IfcLinearMomentMeasure>;
}
#[derive(Default, Debug)]
pub struct IfcStructuralLoadLinearForce {
    name: Option<IfcLabel>,
    linear_force_x: Option<IfcLinearForceMeasure>,
    linear_force_y: Option<IfcLinearForceMeasure>,
    linear_force_z: Option<IfcLinearForceMeasure>,
    linear_moment_x: Option<IfcLinearMomentMeasure>,
    linear_moment_y: Option<IfcLinearMomentMeasure>,
    linear_moment_z: Option<IfcLinearMomentMeasure>,
}
impl IIfcStructuralLoad for IfcStructuralLoadLinearForce {
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
}
impl IIfcStructuralLoadOrResult for IfcStructuralLoadLinearForce {}
impl IIfcStructuralLoadStatic for IfcStructuralLoadLinearForce {}
impl IIfcStructuralLoadLinearForce for IfcStructuralLoadLinearForce {
    fn linear_force_x(&self) -> &Option<IfcLinearForceMeasure> {
        &self.linear_force_x
    }
    fn linear_force_y(&self) -> &Option<IfcLinearForceMeasure> {
        &self.linear_force_y
    }
    fn linear_force_z(&self) -> &Option<IfcLinearForceMeasure> {
        &self.linear_force_z
    }
    fn linear_moment_x(&self) -> &Option<IfcLinearMomentMeasure> {
        &self.linear_moment_x
    }
    fn linear_moment_y(&self) -> &Option<IfcLinearMomentMeasure> {
        &self.linear_moment_y
    }
    fn linear_moment_z(&self) -> &Option<IfcLinearMomentMeasure> {
        &self.linear_moment_z
    }
}
impl IfcStructuralLoadLinearForce {
    pub fn from_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcStructuralLoadLinearForce::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                1usize => {
                    entity.linear_force_x = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => {
                    entity.linear_force_y = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.linear_force_z = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => {
                    entity.linear_moment_x = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                5usize => {
                    entity.linear_moment_y = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                6usize => {
                    entity.linear_moment_z = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
    pub fn from_own_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcStructuralLoadLinearForce::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => {
                    entity.linear_force_x = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                1usize => {
                    entity.linear_force_y = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => {
                    entity.linear_force_z = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.linear_moment_x = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => {
                    entity.linear_moment_y = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                5usize => {
                    entity.linear_moment_z = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcStructuralLoadOrResult: IIfcStructuralLoad {}
pub trait IIfcStructuralLoadPlanarForce: IIfcStructuralLoadStatic {
    fn planar_force_x(&self) -> &Option<IfcPlanarForceMeasure>;
    fn planar_force_y(&self) -> &Option<IfcPlanarForceMeasure>;
    fn planar_force_z(&self) -> &Option<IfcPlanarForceMeasure>;
}
#[derive(Default, Debug)]
pub struct IfcStructuralLoadPlanarForce {
    name: Option<IfcLabel>,
    planar_force_x: Option<IfcPlanarForceMeasure>,
    planar_force_y: Option<IfcPlanarForceMeasure>,
    planar_force_z: Option<IfcPlanarForceMeasure>,
}
impl IIfcStructuralLoad for IfcStructuralLoadPlanarForce {
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
}
impl IIfcStructuralLoadOrResult for IfcStructuralLoadPlanarForce {}
impl IIfcStructuralLoadStatic for IfcStructuralLoadPlanarForce {}
impl IIfcStructuralLoadPlanarForce for IfcStructuralLoadPlanarForce {
    fn planar_force_x(&self) -> &Option<IfcPlanarForceMeasure> {
        &self.planar_force_x
    }
    fn planar_force_y(&self) -> &Option<IfcPlanarForceMeasure> {
        &self.planar_force_y
    }
    fn planar_force_z(&self) -> &Option<IfcPlanarForceMeasure> {
        &self.planar_force_z
    }
}
impl IfcStructuralLoadPlanarForce {
    pub fn from_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcStructuralLoadPlanarForce::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                1usize => {
                    entity.planar_force_x = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => {
                    entity.planar_force_y = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.planar_force_z = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
    pub fn from_own_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcStructuralLoadPlanarForce::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => {
                    entity.planar_force_x = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                1usize => {
                    entity.planar_force_y = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => {
                    entity.planar_force_z = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcStructuralLoadSingleDisplacement: IIfcStructuralLoadStatic {
    fn displacement_x(&self) -> &Option<IfcLengthMeasure>;
    fn displacement_y(&self) -> &Option<IfcLengthMeasure>;
    fn displacement_z(&self) -> &Option<IfcLengthMeasure>;
    fn rotational_displacement_rx(&self) -> &Option<IfcPlaneAngleMeasure>;
    fn rotational_displacement_ry(&self) -> &Option<IfcPlaneAngleMeasure>;
    fn rotational_displacement_rz(&self) -> &Option<IfcPlaneAngleMeasure>;
}
#[derive(Default, Debug)]
pub struct IfcStructuralLoadSingleDisplacement {
    name: Option<IfcLabel>,
    displacement_x: Option<IfcLengthMeasure>,
    displacement_y: Option<IfcLengthMeasure>,
    displacement_z: Option<IfcLengthMeasure>,
    rotational_displacement_rx: Option<IfcPlaneAngleMeasure>,
    rotational_displacement_ry: Option<IfcPlaneAngleMeasure>,
    rotational_displacement_rz: Option<IfcPlaneAngleMeasure>,
}
impl IIfcStructuralLoad for IfcStructuralLoadSingleDisplacement {
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
}
impl IIfcStructuralLoadOrResult for IfcStructuralLoadSingleDisplacement {}
impl IIfcStructuralLoadStatic for IfcStructuralLoadSingleDisplacement {}
impl IIfcStructuralLoadSingleDisplacement for IfcStructuralLoadSingleDisplacement {
    fn displacement_x(&self) -> &Option<IfcLengthMeasure> {
        &self.displacement_x
    }
    fn displacement_y(&self) -> &Option<IfcLengthMeasure> {
        &self.displacement_y
    }
    fn displacement_z(&self) -> &Option<IfcLengthMeasure> {
        &self.displacement_z
    }
    fn rotational_displacement_rx(&self) -> &Option<IfcPlaneAngleMeasure> {
        &self.rotational_displacement_rx
    }
    fn rotational_displacement_ry(&self) -> &Option<IfcPlaneAngleMeasure> {
        &self.rotational_displacement_ry
    }
    fn rotational_displacement_rz(&self) -> &Option<IfcPlaneAngleMeasure> {
        &self.rotational_displacement_rz
    }
}
impl IfcStructuralLoadSingleDisplacement {
    pub fn from_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcStructuralLoadSingleDisplacement::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                1usize => {
                    entity.displacement_x = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => {
                    entity.displacement_y = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.displacement_z = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => {
                    entity.rotational_displacement_rx = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                5usize => {
                    entity.rotational_displacement_ry = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                6usize => {
                    entity.rotational_displacement_rz = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
    pub fn from_own_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcStructuralLoadSingleDisplacement::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => {
                    entity.displacement_x = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                1usize => {
                    entity.displacement_y = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => {
                    entity.displacement_z = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.rotational_displacement_rx = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => {
                    entity.rotational_displacement_ry = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                5usize => {
                    entity.rotational_displacement_rz = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcStructuralLoadSingleDisplacementDistortion: IIfcStructuralLoadSingleDisplacement {
    fn distortion(&self) -> &Option<IfcCurvatureMeasure>;
}
#[derive(Default, Debug)]
pub struct IfcStructuralLoadSingleDisplacementDistortion {
    name: Option<IfcLabel>,
    displacement_x: Option<IfcLengthMeasure>,
    displacement_y: Option<IfcLengthMeasure>,
    displacement_z: Option<IfcLengthMeasure>,
    rotational_displacement_rx: Option<IfcPlaneAngleMeasure>,
    rotational_displacement_ry: Option<IfcPlaneAngleMeasure>,
    rotational_displacement_rz: Option<IfcPlaneAngleMeasure>,
    distortion: Option<IfcCurvatureMeasure>,
}
impl IIfcStructuralLoad for IfcStructuralLoadSingleDisplacementDistortion {
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
}
impl IIfcStructuralLoadOrResult for IfcStructuralLoadSingleDisplacementDistortion {}
impl IIfcStructuralLoadStatic for IfcStructuralLoadSingleDisplacementDistortion {}
impl IIfcStructuralLoadSingleDisplacement for IfcStructuralLoadSingleDisplacementDistortion {
    fn displacement_x(&self) -> &Option<IfcLengthMeasure> {
        &self.displacement_x
    }
    fn displacement_y(&self) -> &Option<IfcLengthMeasure> {
        &self.displacement_y
    }
    fn displacement_z(&self) -> &Option<IfcLengthMeasure> {
        &self.displacement_z
    }
    fn rotational_displacement_rx(&self) -> &Option<IfcPlaneAngleMeasure> {
        &self.rotational_displacement_rx
    }
    fn rotational_displacement_ry(&self) -> &Option<IfcPlaneAngleMeasure> {
        &self.rotational_displacement_ry
    }
    fn rotational_displacement_rz(&self) -> &Option<IfcPlaneAngleMeasure> {
        &self.rotational_displacement_rz
    }
}
impl IIfcStructuralLoadSingleDisplacementDistortion for IfcStructuralLoadSingleDisplacementDistortion {
    fn distortion(&self) -> &Option<IfcCurvatureMeasure> {
        &self.distortion
    }
}
impl IfcStructuralLoadSingleDisplacementDistortion {
    pub fn from_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcStructuralLoadSingleDisplacementDistortion::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                1usize => {
                    entity.displacement_x = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => {
                    entity.displacement_y = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.displacement_z = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => {
                    entity.rotational_displacement_rx = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                5usize => {
                    entity.rotational_displacement_ry = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                6usize => {
                    entity.rotational_displacement_rz = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                7usize => {
                    entity.distortion = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
    pub fn from_own_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcStructuralLoadSingleDisplacementDistortion::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => {
                    entity.distortion = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcStructuralLoadSingleForce: IIfcStructuralLoadStatic {
    fn force_x(&self) -> &Option<IfcForceMeasure>;
    fn force_y(&self) -> &Option<IfcForceMeasure>;
    fn force_z(&self) -> &Option<IfcForceMeasure>;
    fn moment_x(&self) -> &Option<IfcTorqueMeasure>;
    fn moment_y(&self) -> &Option<IfcTorqueMeasure>;
    fn moment_z(&self) -> &Option<IfcTorqueMeasure>;
}
#[derive(Default, Debug)]
pub struct IfcStructuralLoadSingleForce {
    name: Option<IfcLabel>,
    force_x: Option<IfcForceMeasure>,
    force_y: Option<IfcForceMeasure>,
    force_z: Option<IfcForceMeasure>,
    moment_x: Option<IfcTorqueMeasure>,
    moment_y: Option<IfcTorqueMeasure>,
    moment_z: Option<IfcTorqueMeasure>,
}
impl IIfcStructuralLoad for IfcStructuralLoadSingleForce {
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
}
impl IIfcStructuralLoadOrResult for IfcStructuralLoadSingleForce {}
impl IIfcStructuralLoadStatic for IfcStructuralLoadSingleForce {}
impl IIfcStructuralLoadSingleForce for IfcStructuralLoadSingleForce {
    fn force_x(&self) -> &Option<IfcForceMeasure> {
        &self.force_x
    }
    fn force_y(&self) -> &Option<IfcForceMeasure> {
        &self.force_y
    }
    fn force_z(&self) -> &Option<IfcForceMeasure> {
        &self.force_z
    }
    fn moment_x(&self) -> &Option<IfcTorqueMeasure> {
        &self.moment_x
    }
    fn moment_y(&self) -> &Option<IfcTorqueMeasure> {
        &self.moment_y
    }
    fn moment_z(&self) -> &Option<IfcTorqueMeasure> {
        &self.moment_z
    }
}
impl IfcStructuralLoadSingleForce {
    pub fn from_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcStructuralLoadSingleForce::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                1usize => {
                    entity.force_x = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => {
                    entity.force_y = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.force_z = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => {
                    entity.moment_x = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                5usize => {
                    entity.moment_y = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                6usize => {
                    entity.moment_z = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
    pub fn from_own_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcStructuralLoadSingleForce::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => {
                    entity.force_x = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                1usize => {
                    entity.force_y = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => {
                    entity.force_z = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.moment_x = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => {
                    entity.moment_y = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                5usize => {
                    entity.moment_z = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcStructuralLoadSingleForceWarping: IIfcStructuralLoadSingleForce {
    fn warping_moment(&self) -> &Option<IfcWarpingMomentMeasure>;
}
#[derive(Default, Debug)]
pub struct IfcStructuralLoadSingleForceWarping {
    name: Option<IfcLabel>,
    force_x: Option<IfcForceMeasure>,
    force_y: Option<IfcForceMeasure>,
    force_z: Option<IfcForceMeasure>,
    moment_x: Option<IfcTorqueMeasure>,
    moment_y: Option<IfcTorqueMeasure>,
    moment_z: Option<IfcTorqueMeasure>,
    warping_moment: Option<IfcWarpingMomentMeasure>,
}
impl IIfcStructuralLoad for IfcStructuralLoadSingleForceWarping {
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
}
impl IIfcStructuralLoadOrResult for IfcStructuralLoadSingleForceWarping {}
impl IIfcStructuralLoadStatic for IfcStructuralLoadSingleForceWarping {}
impl IIfcStructuralLoadSingleForce for IfcStructuralLoadSingleForceWarping {
    fn force_x(&self) -> &Option<IfcForceMeasure> {
        &self.force_x
    }
    fn force_y(&self) -> &Option<IfcForceMeasure> {
        &self.force_y
    }
    fn force_z(&self) -> &Option<IfcForceMeasure> {
        &self.force_z
    }
    fn moment_x(&self) -> &Option<IfcTorqueMeasure> {
        &self.moment_x
    }
    fn moment_y(&self) -> &Option<IfcTorqueMeasure> {
        &self.moment_y
    }
    fn moment_z(&self) -> &Option<IfcTorqueMeasure> {
        &self.moment_z
    }
}
impl IIfcStructuralLoadSingleForceWarping for IfcStructuralLoadSingleForceWarping {
    fn warping_moment(&self) -> &Option<IfcWarpingMomentMeasure> {
        &self.warping_moment
    }
}
impl IfcStructuralLoadSingleForceWarping {
    pub fn from_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcStructuralLoadSingleForceWarping::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                1usize => {
                    entity.force_x = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => {
                    entity.force_y = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.force_z = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => {
                    entity.moment_x = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                5usize => {
                    entity.moment_y = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                6usize => {
                    entity.moment_z = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                7usize => {
                    entity.warping_moment = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
    pub fn from_own_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcStructuralLoadSingleForceWarping::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => {
                    entity.warping_moment = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcStructuralLoadStatic: IIfcStructuralLoadOrResult {}
pub trait IIfcStructuralLoadTemperature: IIfcStructuralLoadStatic {
    fn delta_t_constant(&self) -> &Option<IfcThermodynamicTemperatureMeasure>;
    fn delta_ty(&self) -> &Option<IfcThermodynamicTemperatureMeasure>;
    fn delta_tz(&self) -> &Option<IfcThermodynamicTemperatureMeasure>;
}
#[derive(Default, Debug)]
pub struct IfcStructuralLoadTemperature {
    name: Option<IfcLabel>,
    delta_t_constant: Option<IfcThermodynamicTemperatureMeasure>,
    delta_ty: Option<IfcThermodynamicTemperatureMeasure>,
    delta_tz: Option<IfcThermodynamicTemperatureMeasure>,
}
impl IIfcStructuralLoad for IfcStructuralLoadTemperature {
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
}
impl IIfcStructuralLoadOrResult for IfcStructuralLoadTemperature {}
impl IIfcStructuralLoadStatic for IfcStructuralLoadTemperature {}
impl IIfcStructuralLoadTemperature for IfcStructuralLoadTemperature {
    fn delta_t_constant(&self) -> &Option<IfcThermodynamicTemperatureMeasure> {
        &self.delta_t_constant
    }
    fn delta_ty(&self) -> &Option<IfcThermodynamicTemperatureMeasure> {
        &self.delta_ty
    }
    fn delta_tz(&self) -> &Option<IfcThermodynamicTemperatureMeasure> {
        &self.delta_tz
    }
}
impl IfcStructuralLoadTemperature {
    pub fn from_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcStructuralLoadTemperature::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                1usize => {
                    entity.delta_t_constant = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => {
                    entity.delta_ty = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.delta_tz = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
    pub fn from_own_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcStructuralLoadTemperature::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => {
                    entity.delta_t_constant = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                1usize => {
                    entity.delta_ty = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => {
                    entity.delta_tz = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcStructuralMember: IIfcStructuralItem {}
pub trait IIfcStructuralPlanarAction: IIfcStructuralSurfaceAction {}
#[derive(Default, Debug)]
pub struct IfcStructuralPlanarAction {
    global_id: IfcGloballyUniqueId,
    owner_history: Option<EntityRef>,
    name: Option<IfcLabel>,
    description: Option<IfcText>,
    object_type: Option<IfcLabel>,
    object_placement: Option<EntityRef>,
    representation: Option<EntityRef>,
    applied_load: EntityRef,
    global_or_local: IfcGlobalOrLocalEnum,
    destabilizing_load: Option<IfcBoolean>,
    projected_or_true: Option<IfcProjectedOrTrueLengthEnum>,
    predefined_type: IfcStructuralSurfaceActivityTypeEnum,
}
impl IIfcRoot for IfcStructuralPlanarAction {
    fn global_id(&self) -> &IfcGloballyUniqueId {
        &self.global_id
    }
    fn owner_history(&self) -> &Option<EntityRef> {
        &self.owner_history
    }
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
}
impl IIfcObjectDefinition for IfcStructuralPlanarAction {}
impl IIfcObject for IfcStructuralPlanarAction {
    fn object_type(&self) -> &Option<IfcLabel> {
        &self.object_type
    }
}
impl IIfcProduct for IfcStructuralPlanarAction {
    fn object_placement(&self) -> &Option<EntityRef> {
        &self.object_placement
    }
    fn representation(&self) -> &Option<EntityRef> {
        &self.representation
    }
}
impl IIfcStructuralActivity for IfcStructuralPlanarAction {
    fn applied_load(&self) -> &EntityRef {
        &self.applied_load
    }
    fn global_or_local(&self) -> &IfcGlobalOrLocalEnum {
        &self.global_or_local
    }
}
impl IIfcStructuralAction for IfcStructuralPlanarAction {
    fn destabilizing_load(&self) -> &Option<IfcBoolean> {
        &self.destabilizing_load
    }
}
impl IIfcStructuralSurfaceAction for IfcStructuralPlanarAction {
    fn projected_or_true(&self) -> &Option<IfcProjectedOrTrueLengthEnum> {
        &self.projected_or_true
    }
    fn predefined_type(&self) -> &IfcStructuralSurfaceActivityTypeEnum {
        &self.predefined_type
    }
}
impl IIfcStructuralPlanarAction for IfcStructuralPlanarAction {}
impl IfcStructuralPlanarAction {
    pub fn from_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcStructuralPlanarAction::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.global_id = parameter.into(),
                1usize => {
                    entity.owner_history = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => {
                    entity.object_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                5usize => {
                    entity.object_placement = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                6usize => {
                    entity.representation = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                7usize => entity.applied_load = parameter.into(),
                8usize => entity.global_or_local = parameter.into(),
                9usize => {
                    entity.destabilizing_load = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                10usize => {
                    entity.projected_or_true = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                11usize => entity.predefined_type = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcStructuralPointAction: IIfcStructuralAction {}
#[derive(Default, Debug)]
pub struct IfcStructuralPointAction {
    global_id: IfcGloballyUniqueId,
    owner_history: Option<EntityRef>,
    name: Option<IfcLabel>,
    description: Option<IfcText>,
    object_type: Option<IfcLabel>,
    object_placement: Option<EntityRef>,
    representation: Option<EntityRef>,
    applied_load: EntityRef,
    global_or_local: IfcGlobalOrLocalEnum,
    destabilizing_load: Option<IfcBoolean>,
}
impl IIfcRoot for IfcStructuralPointAction {
    fn global_id(&self) -> &IfcGloballyUniqueId {
        &self.global_id
    }
    fn owner_history(&self) -> &Option<EntityRef> {
        &self.owner_history
    }
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
}
impl IIfcObjectDefinition for IfcStructuralPointAction {}
impl IIfcObject for IfcStructuralPointAction {
    fn object_type(&self) -> &Option<IfcLabel> {
        &self.object_type
    }
}
impl IIfcProduct for IfcStructuralPointAction {
    fn object_placement(&self) -> &Option<EntityRef> {
        &self.object_placement
    }
    fn representation(&self) -> &Option<EntityRef> {
        &self.representation
    }
}
impl IIfcStructuralActivity for IfcStructuralPointAction {
    fn applied_load(&self) -> &EntityRef {
        &self.applied_load
    }
    fn global_or_local(&self) -> &IfcGlobalOrLocalEnum {
        &self.global_or_local
    }
}
impl IIfcStructuralAction for IfcStructuralPointAction {
    fn destabilizing_load(&self) -> &Option<IfcBoolean> {
        &self.destabilizing_load
    }
}
impl IIfcStructuralPointAction for IfcStructuralPointAction {}
impl IfcStructuralPointAction {
    pub fn from_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcStructuralPointAction::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.global_id = parameter.into(),
                1usize => {
                    entity.owner_history = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => {
                    entity.object_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                5usize => {
                    entity.object_placement = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                6usize => {
                    entity.representation = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                7usize => entity.applied_load = parameter.into(),
                8usize => entity.global_or_local = parameter.into(),
                9usize => {
                    entity.destabilizing_load = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcStructuralPointConnection: IIfcStructuralConnection {
    fn condition_coordinate_system(&self) -> &Option<EntityRef>;
}
#[derive(Default, Debug)]
pub struct IfcStructuralPointConnection {
    global_id: IfcGloballyUniqueId,
    owner_history: Option<EntityRef>,
    name: Option<IfcLabel>,
    description: Option<IfcText>,
    object_type: Option<IfcLabel>,
    object_placement: Option<EntityRef>,
    representation: Option<EntityRef>,
    applied_condition: Option<EntityRef>,
    condition_coordinate_system: Option<EntityRef>,
}
impl IIfcRoot for IfcStructuralPointConnection {
    fn global_id(&self) -> &IfcGloballyUniqueId {
        &self.global_id
    }
    fn owner_history(&self) -> &Option<EntityRef> {
        &self.owner_history
    }
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
}
impl IIfcObjectDefinition for IfcStructuralPointConnection {}
impl IIfcObject for IfcStructuralPointConnection {
    fn object_type(&self) -> &Option<IfcLabel> {
        &self.object_type
    }
}
impl IIfcProduct for IfcStructuralPointConnection {
    fn object_placement(&self) -> &Option<EntityRef> {
        &self.object_placement
    }
    fn representation(&self) -> &Option<EntityRef> {
        &self.representation
    }
}
impl IIfcStructuralItem for IfcStructuralPointConnection {}
impl IIfcStructuralConnection for IfcStructuralPointConnection {
    fn applied_condition(&self) -> &Option<EntityRef> {
        &self.applied_condition
    }
}
impl IIfcStructuralPointConnection for IfcStructuralPointConnection {
    fn condition_coordinate_system(&self) -> &Option<EntityRef> {
        &self.condition_coordinate_system
    }
}
impl IfcStructuralPointConnection {
    pub fn from_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcStructuralPointConnection::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.global_id = parameter.into(),
                1usize => {
                    entity.owner_history = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => {
                    entity.object_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                5usize => {
                    entity.object_placement = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                6usize => {
                    entity.representation = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                7usize => {
                    entity.applied_condition = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                8usize => {
                    entity.condition_coordinate_system = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
    pub fn from_own_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcStructuralPointConnection::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => {
                    entity.condition_coordinate_system = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcStructuralPointReaction: IIfcStructuralReaction {}
#[derive(Default, Debug)]
pub struct IfcStructuralPointReaction {
    global_id: IfcGloballyUniqueId,
    owner_history: Option<EntityRef>,
    name: Option<IfcLabel>,
    description: Option<IfcText>,
    object_type: Option<IfcLabel>,
    object_placement: Option<EntityRef>,
    representation: Option<EntityRef>,
    applied_load: EntityRef,
    global_or_local: IfcGlobalOrLocalEnum,
}
impl IIfcRoot for IfcStructuralPointReaction {
    fn global_id(&self) -> &IfcGloballyUniqueId {
        &self.global_id
    }
    fn owner_history(&self) -> &Option<EntityRef> {
        &self.owner_history
    }
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
}
impl IIfcObjectDefinition for IfcStructuralPointReaction {}
impl IIfcObject for IfcStructuralPointReaction {
    fn object_type(&self) -> &Option<IfcLabel> {
        &self.object_type
    }
}
impl IIfcProduct for IfcStructuralPointReaction {
    fn object_placement(&self) -> &Option<EntityRef> {
        &self.object_placement
    }
    fn representation(&self) -> &Option<EntityRef> {
        &self.representation
    }
}
impl IIfcStructuralActivity for IfcStructuralPointReaction {
    fn applied_load(&self) -> &EntityRef {
        &self.applied_load
    }
    fn global_or_local(&self) -> &IfcGlobalOrLocalEnum {
        &self.global_or_local
    }
}
impl IIfcStructuralReaction for IfcStructuralPointReaction {}
impl IIfcStructuralPointReaction for IfcStructuralPointReaction {}
impl IfcStructuralPointReaction {
    pub fn from_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcStructuralPointReaction::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.global_id = parameter.into(),
                1usize => {
                    entity.owner_history = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => {
                    entity.object_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                5usize => {
                    entity.object_placement = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                6usize => {
                    entity.representation = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                7usize => entity.applied_load = parameter.into(),
                8usize => entity.global_or_local = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcStructuralReaction: IIfcStructuralActivity {}
pub trait IIfcStructuralResultGroup: IIfcGroup {
    fn theory_type(&self) -> &IfcAnalysisTheoryTypeEnum;
    fn result_for_load_group(&self) -> &Option<EntityRef>;
    fn is_linear(&self) -> &IfcBoolean;
}
#[derive(Default, Debug)]
pub struct IfcStructuralResultGroup {
    global_id: IfcGloballyUniqueId,
    owner_history: Option<EntityRef>,
    name: Option<IfcLabel>,
    description: Option<IfcText>,
    object_type: Option<IfcLabel>,
    theory_type: IfcAnalysisTheoryTypeEnum,
    result_for_load_group: Option<EntityRef>,
    is_linear: IfcBoolean,
}
impl IIfcRoot for IfcStructuralResultGroup {
    fn global_id(&self) -> &IfcGloballyUniqueId {
        &self.global_id
    }
    fn owner_history(&self) -> &Option<EntityRef> {
        &self.owner_history
    }
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
}
impl IIfcObjectDefinition for IfcStructuralResultGroup {}
impl IIfcObject for IfcStructuralResultGroup {
    fn object_type(&self) -> &Option<IfcLabel> {
        &self.object_type
    }
}
impl IIfcGroup for IfcStructuralResultGroup {}
impl IIfcStructuralResultGroup for IfcStructuralResultGroup {
    fn theory_type(&self) -> &IfcAnalysisTheoryTypeEnum {
        &self.theory_type
    }
    fn result_for_load_group(&self) -> &Option<EntityRef> {
        &self.result_for_load_group
    }
    fn is_linear(&self) -> &IfcBoolean {
        &self.is_linear
    }
}
impl IfcStructuralResultGroup {
    pub fn from_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcStructuralResultGroup::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.global_id = parameter.into(),
                1usize => {
                    entity.owner_history = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => {
                    entity.object_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                5usize => entity.theory_type = parameter.into(),
                6usize => {
                    entity.result_for_load_group = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                7usize => entity.is_linear = parameter.into(),
                _ => {}
            }
        }
        entity
    }
    pub fn from_own_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcStructuralResultGroup::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.theory_type = parameter.into(),
                1usize => {
                    entity.result_for_load_group = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => entity.is_linear = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcStructuralSurfaceAction: IIfcStructuralAction {
    fn projected_or_true(&self) -> &Option<IfcProjectedOrTrueLengthEnum>;
    fn predefined_type(&self) -> &IfcStructuralSurfaceActivityTypeEnum;
}
#[derive(Default, Debug)]
pub struct IfcStructuralSurfaceAction {
    global_id: IfcGloballyUniqueId,
    owner_history: Option<EntityRef>,
    name: Option<IfcLabel>,
    description: Option<IfcText>,
    object_type: Option<IfcLabel>,
    object_placement: Option<EntityRef>,
    representation: Option<EntityRef>,
    applied_load: EntityRef,
    global_or_local: IfcGlobalOrLocalEnum,
    destabilizing_load: Option<IfcBoolean>,
    projected_or_true: Option<IfcProjectedOrTrueLengthEnum>,
    predefined_type: IfcStructuralSurfaceActivityTypeEnum,
}
impl IIfcRoot for IfcStructuralSurfaceAction {
    fn global_id(&self) -> &IfcGloballyUniqueId {
        &self.global_id
    }
    fn owner_history(&self) -> &Option<EntityRef> {
        &self.owner_history
    }
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
}
impl IIfcObjectDefinition for IfcStructuralSurfaceAction {}
impl IIfcObject for IfcStructuralSurfaceAction {
    fn object_type(&self) -> &Option<IfcLabel> {
        &self.object_type
    }
}
impl IIfcProduct for IfcStructuralSurfaceAction {
    fn object_placement(&self) -> &Option<EntityRef> {
        &self.object_placement
    }
    fn representation(&self) -> &Option<EntityRef> {
        &self.representation
    }
}
impl IIfcStructuralActivity for IfcStructuralSurfaceAction {
    fn applied_load(&self) -> &EntityRef {
        &self.applied_load
    }
    fn global_or_local(&self) -> &IfcGlobalOrLocalEnum {
        &self.global_or_local
    }
}
impl IIfcStructuralAction for IfcStructuralSurfaceAction {
    fn destabilizing_load(&self) -> &Option<IfcBoolean> {
        &self.destabilizing_load
    }
}
impl IIfcStructuralSurfaceAction for IfcStructuralSurfaceAction {
    fn projected_or_true(&self) -> &Option<IfcProjectedOrTrueLengthEnum> {
        &self.projected_or_true
    }
    fn predefined_type(&self) -> &IfcStructuralSurfaceActivityTypeEnum {
        &self.predefined_type
    }
}
impl IfcStructuralSurfaceAction {
    pub fn from_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcStructuralSurfaceAction::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.global_id = parameter.into(),
                1usize => {
                    entity.owner_history = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => {
                    entity.object_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                5usize => {
                    entity.object_placement = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                6usize => {
                    entity.representation = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                7usize => entity.applied_load = parameter.into(),
                8usize => entity.global_or_local = parameter.into(),
                9usize => {
                    entity.destabilizing_load = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                10usize => {
                    entity.projected_or_true = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                11usize => entity.predefined_type = parameter.into(),
                _ => {}
            }
        }
        entity
    }
    pub fn from_own_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcStructuralSurfaceAction::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => {
                    entity.projected_or_true = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                1usize => entity.predefined_type = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcStructuralSurfaceConnection: IIfcStructuralConnection {}
#[derive(Default, Debug)]
pub struct IfcStructuralSurfaceConnection {
    global_id: IfcGloballyUniqueId,
    owner_history: Option<EntityRef>,
    name: Option<IfcLabel>,
    description: Option<IfcText>,
    object_type: Option<IfcLabel>,
    object_placement: Option<EntityRef>,
    representation: Option<EntityRef>,
    applied_condition: Option<EntityRef>,
}
impl IIfcRoot for IfcStructuralSurfaceConnection {
    fn global_id(&self) -> &IfcGloballyUniqueId {
        &self.global_id
    }
    fn owner_history(&self) -> &Option<EntityRef> {
        &self.owner_history
    }
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
}
impl IIfcObjectDefinition for IfcStructuralSurfaceConnection {}
impl IIfcObject for IfcStructuralSurfaceConnection {
    fn object_type(&self) -> &Option<IfcLabel> {
        &self.object_type
    }
}
impl IIfcProduct for IfcStructuralSurfaceConnection {
    fn object_placement(&self) -> &Option<EntityRef> {
        &self.object_placement
    }
    fn representation(&self) -> &Option<EntityRef> {
        &self.representation
    }
}
impl IIfcStructuralItem for IfcStructuralSurfaceConnection {}
impl IIfcStructuralConnection for IfcStructuralSurfaceConnection {
    fn applied_condition(&self) -> &Option<EntityRef> {
        &self.applied_condition
    }
}
impl IIfcStructuralSurfaceConnection for IfcStructuralSurfaceConnection {}
impl IfcStructuralSurfaceConnection {
    pub fn from_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcStructuralSurfaceConnection::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.global_id = parameter.into(),
                1usize => {
                    entity.owner_history = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => {
                    entity.object_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                5usize => {
                    entity.object_placement = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                6usize => {
                    entity.representation = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                7usize => {
                    entity.applied_condition = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcStructuralSurfaceMember: IIfcStructuralMember {
    fn predefined_type(&self) -> &IfcStructuralSurfaceMemberTypeEnum;
    fn thickness(&self) -> &Option<IfcPositiveLengthMeasure>;
}
#[derive(Default, Debug)]
pub struct IfcStructuralSurfaceMember {
    global_id: IfcGloballyUniqueId,
    owner_history: Option<EntityRef>,
    name: Option<IfcLabel>,
    description: Option<IfcText>,
    object_type: Option<IfcLabel>,
    object_placement: Option<EntityRef>,
    representation: Option<EntityRef>,
    predefined_type: IfcStructuralSurfaceMemberTypeEnum,
    thickness: Option<IfcPositiveLengthMeasure>,
}
impl IIfcRoot for IfcStructuralSurfaceMember {
    fn global_id(&self) -> &IfcGloballyUniqueId {
        &self.global_id
    }
    fn owner_history(&self) -> &Option<EntityRef> {
        &self.owner_history
    }
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
}
impl IIfcObjectDefinition for IfcStructuralSurfaceMember {}
impl IIfcObject for IfcStructuralSurfaceMember {
    fn object_type(&self) -> &Option<IfcLabel> {
        &self.object_type
    }
}
impl IIfcProduct for IfcStructuralSurfaceMember {
    fn object_placement(&self) -> &Option<EntityRef> {
        &self.object_placement
    }
    fn representation(&self) -> &Option<EntityRef> {
        &self.representation
    }
}
impl IIfcStructuralItem for IfcStructuralSurfaceMember {}
impl IIfcStructuralMember for IfcStructuralSurfaceMember {}
impl IIfcStructuralSurfaceMember for IfcStructuralSurfaceMember {
    fn predefined_type(&self) -> &IfcStructuralSurfaceMemberTypeEnum {
        &self.predefined_type
    }
    fn thickness(&self) -> &Option<IfcPositiveLengthMeasure> {
        &self.thickness
    }
}
impl IfcStructuralSurfaceMember {
    pub fn from_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcStructuralSurfaceMember::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.global_id = parameter.into(),
                1usize => {
                    entity.owner_history = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => {
                    entity.object_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                5usize => {
                    entity.object_placement = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                6usize => {
                    entity.representation = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                7usize => entity.predefined_type = parameter.into(),
                8usize => {
                    entity.thickness = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
    pub fn from_own_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcStructuralSurfaceMember::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.predefined_type = parameter.into(),
                1usize => {
                    entity.thickness = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcStructuralSurfaceMemberVarying: IIfcStructuralSurfaceMember {}
#[derive(Default, Debug)]
pub struct IfcStructuralSurfaceMemberVarying {
    global_id: IfcGloballyUniqueId,
    owner_history: Option<EntityRef>,
    name: Option<IfcLabel>,
    description: Option<IfcText>,
    object_type: Option<IfcLabel>,
    object_placement: Option<EntityRef>,
    representation: Option<EntityRef>,
    predefined_type: IfcStructuralSurfaceMemberTypeEnum,
    thickness: Option<IfcPositiveLengthMeasure>,
}
impl IIfcRoot for IfcStructuralSurfaceMemberVarying {
    fn global_id(&self) -> &IfcGloballyUniqueId {
        &self.global_id
    }
    fn owner_history(&self) -> &Option<EntityRef> {
        &self.owner_history
    }
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
}
impl IIfcObjectDefinition for IfcStructuralSurfaceMemberVarying {}
impl IIfcObject for IfcStructuralSurfaceMemberVarying {
    fn object_type(&self) -> &Option<IfcLabel> {
        &self.object_type
    }
}
impl IIfcProduct for IfcStructuralSurfaceMemberVarying {
    fn object_placement(&self) -> &Option<EntityRef> {
        &self.object_placement
    }
    fn representation(&self) -> &Option<EntityRef> {
        &self.representation
    }
}
impl IIfcStructuralItem for IfcStructuralSurfaceMemberVarying {}
impl IIfcStructuralMember for IfcStructuralSurfaceMemberVarying {}
impl IIfcStructuralSurfaceMember for IfcStructuralSurfaceMemberVarying {
    fn predefined_type(&self) -> &IfcStructuralSurfaceMemberTypeEnum {
        &self.predefined_type
    }
    fn thickness(&self) -> &Option<IfcPositiveLengthMeasure> {
        &self.thickness
    }
}
impl IIfcStructuralSurfaceMemberVarying for IfcStructuralSurfaceMemberVarying {}
impl IfcStructuralSurfaceMemberVarying {
    pub fn from_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcStructuralSurfaceMemberVarying::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.global_id = parameter.into(),
                1usize => {
                    entity.owner_history = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => {
                    entity.object_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                5usize => {
                    entity.object_placement = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                6usize => {
                    entity.representation = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                7usize => entity.predefined_type = parameter.into(),
                8usize => {
                    entity.thickness = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcStructuralSurfaceReaction: IIfcStructuralReaction {
    fn predefined_type(&self) -> &IfcStructuralSurfaceActivityTypeEnum;
}
#[derive(Default, Debug)]
pub struct IfcStructuralSurfaceReaction {
    global_id: IfcGloballyUniqueId,
    owner_history: Option<EntityRef>,
    name: Option<IfcLabel>,
    description: Option<IfcText>,
    object_type: Option<IfcLabel>,
    object_placement: Option<EntityRef>,
    representation: Option<EntityRef>,
    applied_load: EntityRef,
    global_or_local: IfcGlobalOrLocalEnum,
    predefined_type: IfcStructuralSurfaceActivityTypeEnum,
}
impl IIfcRoot for IfcStructuralSurfaceReaction {
    fn global_id(&self) -> &IfcGloballyUniqueId {
        &self.global_id
    }
    fn owner_history(&self) -> &Option<EntityRef> {
        &self.owner_history
    }
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
}
impl IIfcObjectDefinition for IfcStructuralSurfaceReaction {}
impl IIfcObject for IfcStructuralSurfaceReaction {
    fn object_type(&self) -> &Option<IfcLabel> {
        &self.object_type
    }
}
impl IIfcProduct for IfcStructuralSurfaceReaction {
    fn object_placement(&self) -> &Option<EntityRef> {
        &self.object_placement
    }
    fn representation(&self) -> &Option<EntityRef> {
        &self.representation
    }
}
impl IIfcStructuralActivity for IfcStructuralSurfaceReaction {
    fn applied_load(&self) -> &EntityRef {
        &self.applied_load
    }
    fn global_or_local(&self) -> &IfcGlobalOrLocalEnum {
        &self.global_or_local
    }
}
impl IIfcStructuralReaction for IfcStructuralSurfaceReaction {}
impl IIfcStructuralSurfaceReaction for IfcStructuralSurfaceReaction {
    fn predefined_type(&self) -> &IfcStructuralSurfaceActivityTypeEnum {
        &self.predefined_type
    }
}
impl IfcStructuralSurfaceReaction {
    pub fn from_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcStructuralSurfaceReaction::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.global_id = parameter.into(),
                1usize => {
                    entity.owner_history = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => {
                    entity.object_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                5usize => {
                    entity.object_placement = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                6usize => {
                    entity.representation = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                7usize => entity.applied_load = parameter.into(),
                8usize => entity.global_or_local = parameter.into(),
                9usize => entity.predefined_type = parameter.into(),
                _ => {}
            }
        }
        entity
    }
    pub fn from_own_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcStructuralSurfaceReaction::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.predefined_type = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcStyleModel: IIfcRepresentation {}
pub trait IIfcStyledItem: IIfcRepresentationItem {
    fn item(&self) -> &Option<EntityRef>;
    fn styles(&self) -> &HashSet<EntityRef>;
    fn name(&self) -> &Option<IfcLabel>;
}
#[derive(Default, Debug)]
pub struct IfcStyledItem {
    item: Option<EntityRef>,
    styles: HashSet<EntityRef>,
    name: Option<IfcLabel>,
}
impl IIfcRepresentationItem for IfcStyledItem {}
impl IIfcStyledItem for IfcStyledItem {
    fn item(&self) -> &Option<EntityRef> {
        &self.item
    }
    fn styles(&self) -> &HashSet<EntityRef> {
        &self.styles
    }
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
}
impl IfcStyledItem {
    pub fn from_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcStyledItem::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => {
                    entity.item = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                1usize => entity.styles = parameter.into(),
                2usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcStyledRepresentation: IIfcStyleModel {}
#[derive(Default, Debug)]
pub struct IfcStyledRepresentation {
    context_of_items: EntityRef,
    representation_identifier: Option<IfcLabel>,
    representation_type: Option<IfcLabel>,
    items: HashSet<EntityRef>,
}
impl IIfcRepresentation for IfcStyledRepresentation {
    fn context_of_items(&self) -> &EntityRef {
        &self.context_of_items
    }
    fn representation_identifier(&self) -> &Option<IfcLabel> {
        &self.representation_identifier
    }
    fn representation_type(&self) -> &Option<IfcLabel> {
        &self.representation_type
    }
    fn items(&self) -> &HashSet<EntityRef> {
        &self.items
    }
}
impl IIfcStyleModel for IfcStyledRepresentation {}
impl IIfcStyledRepresentation for IfcStyledRepresentation {}
impl IfcStyledRepresentation {
    pub fn from_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcStyledRepresentation::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.context_of_items = parameter.into(),
                1usize => {
                    entity.representation_identifier = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => {
                    entity.representation_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => entity.items = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcSubContractResource: IIfcConstructionResource {
    fn predefined_type(&self) -> &Option<IfcSubContractResourceTypeEnum>;
}
#[derive(Default, Debug)]
pub struct IfcSubContractResource {
    global_id: IfcGloballyUniqueId,
    owner_history: Option<EntityRef>,
    name: Option<IfcLabel>,
    description: Option<IfcText>,
    object_type: Option<IfcLabel>,
    identification: Option<IfcIdentifier>,
    long_description: Option<IfcText>,
    usage: Option<EntityRef>,
    base_costs: Option<Vec<EntityRef>>,
    base_quantity: Option<EntityRef>,
    predefined_type: Option<IfcSubContractResourceTypeEnum>,
}
impl IIfcRoot for IfcSubContractResource {
    fn global_id(&self) -> &IfcGloballyUniqueId {
        &self.global_id
    }
    fn owner_history(&self) -> &Option<EntityRef> {
        &self.owner_history
    }
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
}
impl IIfcObjectDefinition for IfcSubContractResource {}
impl IIfcObject for IfcSubContractResource {
    fn object_type(&self) -> &Option<IfcLabel> {
        &self.object_type
    }
}
impl IIfcResource for IfcSubContractResource {
    fn identification(&self) -> &Option<IfcIdentifier> {
        &self.identification
    }
    fn long_description(&self) -> &Option<IfcText> {
        &self.long_description
    }
}
impl IIfcConstructionResource for IfcSubContractResource {
    fn usage(&self) -> &Option<EntityRef> {
        &self.usage
    }
    fn base_costs(&self) -> &Option<Vec<EntityRef>> {
        &self.base_costs
    }
    fn base_quantity(&self) -> &Option<EntityRef> {
        &self.base_quantity
    }
}
impl IIfcSubContractResource for IfcSubContractResource {
    fn predefined_type(&self) -> &Option<IfcSubContractResourceTypeEnum> {
        &self.predefined_type
    }
}
impl IfcSubContractResource {
    pub fn from_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcSubContractResource::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.global_id = parameter.into(),
                1usize => {
                    entity.owner_history = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => {
                    entity.object_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                5usize => {
                    entity.identification = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                6usize => {
                    entity.long_description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                7usize => {
                    entity.usage = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                8usize => {
                    entity.base_costs = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                9usize => {
                    entity.base_quantity = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                10usize => {
                    entity.predefined_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
    pub fn from_own_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcSubContractResource::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => {
                    entity.predefined_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcSubContractResourceType: IIfcConstructionResourceType {
    fn predefined_type(&self) -> &IfcSubContractResourceTypeEnum;
}
#[derive(Default, Debug)]
pub struct IfcSubContractResourceType {
    global_id: IfcGloballyUniqueId,
    owner_history: Option<EntityRef>,
    name: Option<IfcLabel>,
    description: Option<IfcText>,
    applicable_occurrence: Option<IfcIdentifier>,
    has_property_sets: Option<HashSet<EntityRef>>,
    identification: Option<IfcIdentifier>,
    long_description: Option<IfcText>,
    resource_type: Option<IfcLabel>,
    base_costs: Option<Vec<EntityRef>>,
    base_quantity: Option<EntityRef>,
    predefined_type: IfcSubContractResourceTypeEnum,
}
impl IIfcRoot for IfcSubContractResourceType {
    fn global_id(&self) -> &IfcGloballyUniqueId {
        &self.global_id
    }
    fn owner_history(&self) -> &Option<EntityRef> {
        &self.owner_history
    }
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
}
impl IIfcObjectDefinition for IfcSubContractResourceType {}
impl IIfcTypeObject for IfcSubContractResourceType {
    fn applicable_occurrence(&self) -> &Option<IfcIdentifier> {
        &self.applicable_occurrence
    }
    fn has_property_sets(&self) -> &Option<HashSet<EntityRef>> {
        &self.has_property_sets
    }
}
impl IIfcTypeResource for IfcSubContractResourceType {
    fn identification(&self) -> &Option<IfcIdentifier> {
        &self.identification
    }
    fn long_description(&self) -> &Option<IfcText> {
        &self.long_description
    }
    fn resource_type(&self) -> &Option<IfcLabel> {
        &self.resource_type
    }
}
impl IIfcConstructionResourceType for IfcSubContractResourceType {
    fn base_costs(&self) -> &Option<Vec<EntityRef>> {
        &self.base_costs
    }
    fn base_quantity(&self) -> &Option<EntityRef> {
        &self.base_quantity
    }
}
impl IIfcSubContractResourceType for IfcSubContractResourceType {
    fn predefined_type(&self) -> &IfcSubContractResourceTypeEnum {
        &self.predefined_type
    }
}
impl IfcSubContractResourceType {
    pub fn from_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcSubContractResourceType::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.global_id = parameter.into(),
                1usize => {
                    entity.owner_history = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => {
                    entity.applicable_occurrence = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                5usize => {
                    entity.has_property_sets = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                6usize => {
                    entity.identification = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                7usize => {
                    entity.long_description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                8usize => {
                    entity.resource_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                9usize => {
                    entity.base_costs = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                10usize => {
                    entity.base_quantity = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                11usize => entity.predefined_type = parameter.into(),
                _ => {}
            }
        }
        entity
    }
    pub fn from_own_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcSubContractResourceType::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.predefined_type = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcSubedge: IIfcEdge {
    fn parent_edge(&self) -> &EntityRef;
}
#[derive(Default, Debug)]
pub struct IfcSubedge {
    edge_start: EntityRef,
    edge_end: EntityRef,
    parent_edge: EntityRef,
}
impl IIfcRepresentationItem for IfcSubedge {}
impl IIfcTopologicalRepresentationItem for IfcSubedge {}
impl IIfcEdge for IfcSubedge {
    fn edge_start(&self) -> &EntityRef {
        &self.edge_start
    }
    fn edge_end(&self) -> &EntityRef {
        &self.edge_end
    }
}
impl IIfcSubedge for IfcSubedge {
    fn parent_edge(&self) -> &EntityRef {
        &self.parent_edge
    }
}
impl IfcSubedge {
    pub fn from_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcSubedge::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.edge_start = parameter.into(),
                1usize => entity.edge_end = parameter.into(),
                2usize => entity.parent_edge = parameter.into(),
                _ => {}
            }
        }
        entity
    }
    pub fn from_own_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcSubedge::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.parent_edge = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcSurface: IIfcGeometricRepresentationItem {}
pub trait IIfcSurfaceCurve: IIfcCurve {
    fn curve3_d(&self) -> &EntityRef;
    fn associated_geometry(&self) -> &Vec<EntityRef>;
    fn master_representation(&self) -> &IfcPreferredSurfaceCurveRepresentation;
}
#[derive(Default, Debug)]
pub struct IfcSurfaceCurve {
    curve3_d: EntityRef,
    associated_geometry: Vec<EntityRef>,
    master_representation: IfcPreferredSurfaceCurveRepresentation,
}
impl IIfcRepresentationItem for IfcSurfaceCurve {}
impl IIfcGeometricRepresentationItem for IfcSurfaceCurve {}
impl IIfcCurve for IfcSurfaceCurve {}
impl IIfcSurfaceCurve for IfcSurfaceCurve {
    fn curve3_d(&self) -> &EntityRef {
        &self.curve3_d
    }
    fn associated_geometry(&self) -> &Vec<EntityRef> {
        &self.associated_geometry
    }
    fn master_representation(&self) -> &IfcPreferredSurfaceCurveRepresentation {
        &self.master_representation
    }
}
impl IfcSurfaceCurve {
    pub fn from_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcSurfaceCurve::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.curve3_d = parameter.into(),
                1usize => entity.associated_geometry = parameter.into(),
                2usize => entity.master_representation = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcSurfaceCurveSweptAreaSolid: IIfcSweptAreaSolid {
    fn directrix(&self) -> &EntityRef;
    fn start_param(&self) -> &Option<IfcParameterValue>;
    fn end_param(&self) -> &Option<IfcParameterValue>;
    fn reference_surface(&self) -> &EntityRef;
}
#[derive(Default, Debug)]
pub struct IfcSurfaceCurveSweptAreaSolid {
    swept_area: EntityRef,
    position: Option<EntityRef>,
    directrix: EntityRef,
    start_param: Option<IfcParameterValue>,
    end_param: Option<IfcParameterValue>,
    reference_surface: EntityRef,
}
impl IIfcRepresentationItem for IfcSurfaceCurveSweptAreaSolid {}
impl IIfcGeometricRepresentationItem for IfcSurfaceCurveSweptAreaSolid {}
impl IIfcSolidModel for IfcSurfaceCurveSweptAreaSolid {}
impl IIfcSweptAreaSolid for IfcSurfaceCurveSweptAreaSolid {
    fn swept_area(&self) -> &EntityRef {
        &self.swept_area
    }
    fn position(&self) -> &Option<EntityRef> {
        &self.position
    }
}
impl IIfcSurfaceCurveSweptAreaSolid for IfcSurfaceCurveSweptAreaSolid {
    fn directrix(&self) -> &EntityRef {
        &self.directrix
    }
    fn start_param(&self) -> &Option<IfcParameterValue> {
        &self.start_param
    }
    fn end_param(&self) -> &Option<IfcParameterValue> {
        &self.end_param
    }
    fn reference_surface(&self) -> &EntityRef {
        &self.reference_surface
    }
}
impl IfcSurfaceCurveSweptAreaSolid {
    pub fn from_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcSurfaceCurveSweptAreaSolid::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.swept_area = parameter.into(),
                1usize => {
                    entity.position = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => entity.directrix = parameter.into(),
                3usize => {
                    entity.start_param = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => {
                    entity.end_param = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                5usize => entity.reference_surface = parameter.into(),
                _ => {}
            }
        }
        entity
    }
    pub fn from_own_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcSurfaceCurveSweptAreaSolid::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.directrix = parameter.into(),
                1usize => {
                    entity.start_param = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => {
                    entity.end_param = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => entity.reference_surface = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcSurfaceFeature: IIfcFeatureElement {
    fn predefined_type(&self) -> &Option<IfcSurfaceFeatureTypeEnum>;
}
#[derive(Default, Debug)]
pub struct IfcSurfaceFeature {
    global_id: IfcGloballyUniqueId,
    owner_history: Option<EntityRef>,
    name: Option<IfcLabel>,
    description: Option<IfcText>,
    object_type: Option<IfcLabel>,
    object_placement: Option<EntityRef>,
    representation: Option<EntityRef>,
    tag: Option<IfcIdentifier>,
    predefined_type: Option<IfcSurfaceFeatureTypeEnum>,
}
impl IIfcRoot for IfcSurfaceFeature {
    fn global_id(&self) -> &IfcGloballyUniqueId {
        &self.global_id
    }
    fn owner_history(&self) -> &Option<EntityRef> {
        &self.owner_history
    }
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
}
impl IIfcObjectDefinition for IfcSurfaceFeature {}
impl IIfcObject for IfcSurfaceFeature {
    fn object_type(&self) -> &Option<IfcLabel> {
        &self.object_type
    }
}
impl IIfcProduct for IfcSurfaceFeature {
    fn object_placement(&self) -> &Option<EntityRef> {
        &self.object_placement
    }
    fn representation(&self) -> &Option<EntityRef> {
        &self.representation
    }
}
impl IIfcElement for IfcSurfaceFeature {
    fn tag(&self) -> &Option<IfcIdentifier> {
        &self.tag
    }
}
impl IIfcFeatureElement for IfcSurfaceFeature {}
impl IIfcSurfaceFeature for IfcSurfaceFeature {
    fn predefined_type(&self) -> &Option<IfcSurfaceFeatureTypeEnum> {
        &self.predefined_type
    }
}
impl IfcSurfaceFeature {
    pub fn from_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcSurfaceFeature::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.global_id = parameter.into(),
                1usize => {
                    entity.owner_history = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => {
                    entity.object_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                5usize => {
                    entity.object_placement = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                6usize => {
                    entity.representation = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                7usize => {
                    entity.tag = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                8usize => {
                    entity.predefined_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
    pub fn from_own_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcSurfaceFeature::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => {
                    entity.predefined_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcSurfaceOfLinearExtrusion: IIfcSweptSurface {
    fn extruded_direction(&self) -> &EntityRef;
    fn depth(&self) -> &IfcLengthMeasure;
}
#[derive(Default, Debug)]
pub struct IfcSurfaceOfLinearExtrusion {
    swept_curve: EntityRef,
    position: Option<EntityRef>,
    extruded_direction: EntityRef,
    depth: IfcLengthMeasure,
}
impl IIfcRepresentationItem for IfcSurfaceOfLinearExtrusion {}
impl IIfcGeometricRepresentationItem for IfcSurfaceOfLinearExtrusion {}
impl IIfcSurface for IfcSurfaceOfLinearExtrusion {}
impl IIfcSweptSurface for IfcSurfaceOfLinearExtrusion {
    fn swept_curve(&self) -> &EntityRef {
        &self.swept_curve
    }
    fn position(&self) -> &Option<EntityRef> {
        &self.position
    }
}
impl IIfcSurfaceOfLinearExtrusion for IfcSurfaceOfLinearExtrusion {
    fn extruded_direction(&self) -> &EntityRef {
        &self.extruded_direction
    }
    fn depth(&self) -> &IfcLengthMeasure {
        &self.depth
    }
}
impl IfcSurfaceOfLinearExtrusion {
    pub fn from_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcSurfaceOfLinearExtrusion::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.swept_curve = parameter.into(),
                1usize => {
                    entity.position = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => entity.extruded_direction = parameter.into(),
                3usize => entity.depth = parameter.into(),
                _ => {}
            }
        }
        entity
    }
    pub fn from_own_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcSurfaceOfLinearExtrusion::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.extruded_direction = parameter.into(),
                1usize => entity.depth = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcSurfaceOfRevolution: IIfcSweptSurface {
    fn axis_position(&self) -> &EntityRef;
}
#[derive(Default, Debug)]
pub struct IfcSurfaceOfRevolution {
    swept_curve: EntityRef,
    position: Option<EntityRef>,
    axis_position: EntityRef,
}
impl IIfcRepresentationItem for IfcSurfaceOfRevolution {}
impl IIfcGeometricRepresentationItem for IfcSurfaceOfRevolution {}
impl IIfcSurface for IfcSurfaceOfRevolution {}
impl IIfcSweptSurface for IfcSurfaceOfRevolution {
    fn swept_curve(&self) -> &EntityRef {
        &self.swept_curve
    }
    fn position(&self) -> &Option<EntityRef> {
        &self.position
    }
}
impl IIfcSurfaceOfRevolution for IfcSurfaceOfRevolution {
    fn axis_position(&self) -> &EntityRef {
        &self.axis_position
    }
}
impl IfcSurfaceOfRevolution {
    pub fn from_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcSurfaceOfRevolution::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.swept_curve = parameter.into(),
                1usize => {
                    entity.position = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => entity.axis_position = parameter.into(),
                _ => {}
            }
        }
        entity
    }
    pub fn from_own_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcSurfaceOfRevolution::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.axis_position = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcSurfaceReinforcementArea: IIfcStructuralLoadOrResult {
    fn surface_reinforcement1(&self) -> &Option<Vec<IfcLengthMeasure>>;
    fn surface_reinforcement2(&self) -> &Option<Vec<IfcLengthMeasure>>;
    fn shear_reinforcement(&self) -> &Option<IfcRatioMeasure>;
}
#[derive(Default, Debug)]
pub struct IfcSurfaceReinforcementArea {
    name: Option<IfcLabel>,
    surface_reinforcement1: Option<Vec<IfcLengthMeasure>>,
    surface_reinforcement2: Option<Vec<IfcLengthMeasure>>,
    shear_reinforcement: Option<IfcRatioMeasure>,
}
impl IIfcStructuralLoad for IfcSurfaceReinforcementArea {
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
}
impl IIfcStructuralLoadOrResult for IfcSurfaceReinforcementArea {}
impl IIfcSurfaceReinforcementArea for IfcSurfaceReinforcementArea {
    fn surface_reinforcement1(&self) -> &Option<Vec<IfcLengthMeasure>> {
        &self.surface_reinforcement1
    }
    fn surface_reinforcement2(&self) -> &Option<Vec<IfcLengthMeasure>> {
        &self.surface_reinforcement2
    }
    fn shear_reinforcement(&self) -> &Option<IfcRatioMeasure> {
        &self.shear_reinforcement
    }
}
impl IfcSurfaceReinforcementArea {
    pub fn from_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcSurfaceReinforcementArea::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                1usize => {
                    entity.surface_reinforcement1 = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => {
                    entity.surface_reinforcement2 = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.shear_reinforcement = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
    pub fn from_own_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcSurfaceReinforcementArea::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => {
                    entity.surface_reinforcement1 = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                1usize => {
                    entity.surface_reinforcement2 = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => {
                    entity.shear_reinforcement = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcSurfaceStyle: IIfcPresentationStyle {
    fn side(&self) -> &IfcSurfaceSide;
    fn styles(&self) -> &HashSet<EntityRef>;
}
#[derive(Default, Debug)]
pub struct IfcSurfaceStyle {
    name: Option<IfcLabel>,
    side: IfcSurfaceSide,
    styles: HashSet<EntityRef>,
}
impl IIfcPresentationStyle for IfcSurfaceStyle {
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
}
impl IIfcSurfaceStyle for IfcSurfaceStyle {
    fn side(&self) -> &IfcSurfaceSide {
        &self.side
    }
    fn styles(&self) -> &HashSet<EntityRef> {
        &self.styles
    }
}
impl IfcSurfaceStyle {
    pub fn from_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcSurfaceStyle::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                1usize => entity.side = parameter.into(),
                2usize => entity.styles = parameter.into(),
                _ => {}
            }
        }
        entity
    }
    pub fn from_own_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcSurfaceStyle::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.side = parameter.into(),
                1usize => entity.styles = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcSurfaceStyleLighting: IIfcPresentationItem {
    fn diffuse_transmission_colour(&self) -> &EntityRef;
    fn diffuse_reflection_colour(&self) -> &EntityRef;
    fn transmission_colour(&self) -> &EntityRef;
    fn reflectance_colour(&self) -> &EntityRef;
}
#[derive(Default, Debug)]
pub struct IfcSurfaceStyleLighting {
    diffuse_transmission_colour: EntityRef,
    diffuse_reflection_colour: EntityRef,
    transmission_colour: EntityRef,
    reflectance_colour: EntityRef,
}
impl IIfcPresentationItem for IfcSurfaceStyleLighting {}
impl IIfcSurfaceStyleLighting for IfcSurfaceStyleLighting {
    fn diffuse_transmission_colour(&self) -> &EntityRef {
        &self.diffuse_transmission_colour
    }
    fn diffuse_reflection_colour(&self) -> &EntityRef {
        &self.diffuse_reflection_colour
    }
    fn transmission_colour(&self) -> &EntityRef {
        &self.transmission_colour
    }
    fn reflectance_colour(&self) -> &EntityRef {
        &self.reflectance_colour
    }
}
impl IfcSurfaceStyleLighting {
    pub fn from_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcSurfaceStyleLighting::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.diffuse_transmission_colour = parameter.into(),
                1usize => entity.diffuse_reflection_colour = parameter.into(),
                2usize => entity.transmission_colour = parameter.into(),
                3usize => entity.reflectance_colour = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcSurfaceStyleRefraction: IIfcPresentationItem {
    fn refraction_index(&self) -> &Option<IfcReal>;
    fn dispersion_factor(&self) -> &Option<IfcReal>;
}
#[derive(Default, Debug)]
pub struct IfcSurfaceStyleRefraction {
    refraction_index: Option<IfcReal>,
    dispersion_factor: Option<IfcReal>,
}
impl IIfcPresentationItem for IfcSurfaceStyleRefraction {}
impl IIfcSurfaceStyleRefraction for IfcSurfaceStyleRefraction {
    fn refraction_index(&self) -> &Option<IfcReal> {
        &self.refraction_index
    }
    fn dispersion_factor(&self) -> &Option<IfcReal> {
        &self.dispersion_factor
    }
}
impl IfcSurfaceStyleRefraction {
    pub fn from_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcSurfaceStyleRefraction::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => {
                    entity.refraction_index = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                1usize => {
                    entity.dispersion_factor = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcSurfaceStyleRendering: IIfcSurfaceStyleShading {
    fn diffuse_colour(&self) -> &Option<IfcColourOrFactor>;
    fn transmission_colour(&self) -> &Option<IfcColourOrFactor>;
    fn diffuse_transmission_colour(&self) -> &Option<IfcColourOrFactor>;
    fn reflection_colour(&self) -> &Option<IfcColourOrFactor>;
    fn specular_colour(&self) -> &Option<IfcColourOrFactor>;
    fn specular_highlight(&self) -> &Option<IfcSpecularHighlightSelect>;
    fn reflectance_method(&self) -> &IfcReflectanceMethodEnum;
}
#[derive(Default, Debug)]
pub struct IfcSurfaceStyleRendering {
    surface_colour: EntityRef,
    transparency: Option<IfcNormalisedRatioMeasure>,
    diffuse_colour: Option<IfcColourOrFactor>,
    transmission_colour: Option<IfcColourOrFactor>,
    diffuse_transmission_colour: Option<IfcColourOrFactor>,
    reflection_colour: Option<IfcColourOrFactor>,
    specular_colour: Option<IfcColourOrFactor>,
    specular_highlight: Option<IfcSpecularHighlightSelect>,
    reflectance_method: IfcReflectanceMethodEnum,
}
impl IIfcPresentationItem for IfcSurfaceStyleRendering {}
impl IIfcSurfaceStyleShading for IfcSurfaceStyleRendering {
    fn surface_colour(&self) -> &EntityRef {
        &self.surface_colour
    }
    fn transparency(&self) -> &Option<IfcNormalisedRatioMeasure> {
        &self.transparency
    }
}
impl IIfcSurfaceStyleRendering for IfcSurfaceStyleRendering {
    fn diffuse_colour(&self) -> &Option<IfcColourOrFactor> {
        &self.diffuse_colour
    }
    fn transmission_colour(&self) -> &Option<IfcColourOrFactor> {
        &self.transmission_colour
    }
    fn diffuse_transmission_colour(&self) -> &Option<IfcColourOrFactor> {
        &self.diffuse_transmission_colour
    }
    fn reflection_colour(&self) -> &Option<IfcColourOrFactor> {
        &self.reflection_colour
    }
    fn specular_colour(&self) -> &Option<IfcColourOrFactor> {
        &self.specular_colour
    }
    fn specular_highlight(&self) -> &Option<IfcSpecularHighlightSelect> {
        &self.specular_highlight
    }
    fn reflectance_method(&self) -> &IfcReflectanceMethodEnum {
        &self.reflectance_method
    }
}
impl IfcSurfaceStyleRendering {
    pub fn from_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcSurfaceStyleRendering::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.surface_colour = parameter.into(),
                1usize => {
                    entity.transparency = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => {
                    entity.diffuse_colour = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.transmission_colour = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => {
                    entity.diffuse_transmission_colour = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                5usize => {
                    entity.reflection_colour = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                6usize => {
                    entity.specular_colour = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                7usize => {
                    entity.specular_highlight = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                8usize => entity.reflectance_method = parameter.into(),
                _ => {}
            }
        }
        entity
    }
    pub fn from_own_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcSurfaceStyleRendering::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => {
                    entity.diffuse_colour = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                1usize => {
                    entity.transmission_colour = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => {
                    entity.diffuse_transmission_colour = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.reflection_colour = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => {
                    entity.specular_colour = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                5usize => {
                    entity.specular_highlight = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                6usize => entity.reflectance_method = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcSurfaceStyleShading: IIfcPresentationItem {
    fn surface_colour(&self) -> &EntityRef;
    fn transparency(&self) -> &Option<IfcNormalisedRatioMeasure>;
}
#[derive(Default, Debug)]
pub struct IfcSurfaceStyleShading {
    surface_colour: EntityRef,
    transparency: Option<IfcNormalisedRatioMeasure>,
}
impl IIfcPresentationItem for IfcSurfaceStyleShading {}
impl IIfcSurfaceStyleShading for IfcSurfaceStyleShading {
    fn surface_colour(&self) -> &EntityRef {
        &self.surface_colour
    }
    fn transparency(&self) -> &Option<IfcNormalisedRatioMeasure> {
        &self.transparency
    }
}
impl IfcSurfaceStyleShading {
    pub fn from_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcSurfaceStyleShading::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.surface_colour = parameter.into(),
                1usize => {
                    entity.transparency = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcSurfaceStyleWithTextures: IIfcPresentationItem {
    fn textures(&self) -> &Vec<EntityRef>;
}
#[derive(Default, Debug)]
pub struct IfcSurfaceStyleWithTextures {
    textures: Vec<EntityRef>,
}
impl IIfcPresentationItem for IfcSurfaceStyleWithTextures {}
impl IIfcSurfaceStyleWithTextures for IfcSurfaceStyleWithTextures {
    fn textures(&self) -> &Vec<EntityRef> {
        &self.textures
    }
}
impl IfcSurfaceStyleWithTextures {
    pub fn from_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcSurfaceStyleWithTextures::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.textures = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcSurfaceTexture: IIfcPresentationItem {
    fn repeat_s(&self) -> &IfcBoolean;
    fn repeat_t(&self) -> &IfcBoolean;
    fn mode(&self) -> &Option<IfcIdentifier>;
    fn texture_transform(&self) -> &Option<EntityRef>;
    fn parameter(&self) -> &Option<Vec<IfcIdentifier>>;
}
pub trait IIfcSweptAreaSolid: IIfcSolidModel {
    fn swept_area(&self) -> &EntityRef;
    fn position(&self) -> &Option<EntityRef>;
}
pub trait IIfcSweptDiskSolid: IIfcSolidModel {
    fn directrix(&self) -> &EntityRef;
    fn radius(&self) -> &IfcPositiveLengthMeasure;
    fn inner_radius(&self) -> &Option<IfcPositiveLengthMeasure>;
    fn start_param(&self) -> &Option<IfcParameterValue>;
    fn end_param(&self) -> &Option<IfcParameterValue>;
}
#[derive(Default, Debug)]
pub struct IfcSweptDiskSolid {
    directrix: EntityRef,
    radius: IfcPositiveLengthMeasure,
    inner_radius: Option<IfcPositiveLengthMeasure>,
    start_param: Option<IfcParameterValue>,
    end_param: Option<IfcParameterValue>,
}
impl IIfcRepresentationItem for IfcSweptDiskSolid {}
impl IIfcGeometricRepresentationItem for IfcSweptDiskSolid {}
impl IIfcSolidModel for IfcSweptDiskSolid {}
impl IIfcSweptDiskSolid for IfcSweptDiskSolid {
    fn directrix(&self) -> &EntityRef {
        &self.directrix
    }
    fn radius(&self) -> &IfcPositiveLengthMeasure {
        &self.radius
    }
    fn inner_radius(&self) -> &Option<IfcPositiveLengthMeasure> {
        &self.inner_radius
    }
    fn start_param(&self) -> &Option<IfcParameterValue> {
        &self.start_param
    }
    fn end_param(&self) -> &Option<IfcParameterValue> {
        &self.end_param
    }
}
impl IfcSweptDiskSolid {
    pub fn from_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcSweptDiskSolid::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.directrix = parameter.into(),
                1usize => entity.radius = parameter.into(),
                2usize => {
                    entity.inner_radius = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.start_param = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => {
                    entity.end_param = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcSweptDiskSolidPolygonal: IIfcSweptDiskSolid {
    fn fillet_radius(&self) -> &Option<IfcPositiveLengthMeasure>;
}
#[derive(Default, Debug)]
pub struct IfcSweptDiskSolidPolygonal {
    directrix: EntityRef,
    radius: IfcPositiveLengthMeasure,
    inner_radius: Option<IfcPositiveLengthMeasure>,
    start_param: Option<IfcParameterValue>,
    end_param: Option<IfcParameterValue>,
    fillet_radius: Option<IfcPositiveLengthMeasure>,
}
impl IIfcRepresentationItem for IfcSweptDiskSolidPolygonal {}
impl IIfcGeometricRepresentationItem for IfcSweptDiskSolidPolygonal {}
impl IIfcSolidModel for IfcSweptDiskSolidPolygonal {}
impl IIfcSweptDiskSolid for IfcSweptDiskSolidPolygonal {
    fn directrix(&self) -> &EntityRef {
        &self.directrix
    }
    fn radius(&self) -> &IfcPositiveLengthMeasure {
        &self.radius
    }
    fn inner_radius(&self) -> &Option<IfcPositiveLengthMeasure> {
        &self.inner_radius
    }
    fn start_param(&self) -> &Option<IfcParameterValue> {
        &self.start_param
    }
    fn end_param(&self) -> &Option<IfcParameterValue> {
        &self.end_param
    }
}
impl IIfcSweptDiskSolidPolygonal for IfcSweptDiskSolidPolygonal {
    fn fillet_radius(&self) -> &Option<IfcPositiveLengthMeasure> {
        &self.fillet_radius
    }
}
impl IfcSweptDiskSolidPolygonal {
    pub fn from_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcSweptDiskSolidPolygonal::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.directrix = parameter.into(),
                1usize => entity.radius = parameter.into(),
                2usize => {
                    entity.inner_radius = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.start_param = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => {
                    entity.end_param = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                5usize => {
                    entity.fillet_radius = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
    pub fn from_own_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcSweptDiskSolidPolygonal::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => {
                    entity.fillet_radius = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcSweptSurface: IIfcSurface {
    fn swept_curve(&self) -> &EntityRef;
    fn position(&self) -> &Option<EntityRef>;
}
pub trait IIfcSwitchingDevice: IIfcFlowController {
    fn predefined_type(&self) -> &Option<IfcSwitchingDeviceTypeEnum>;
}
#[derive(Default, Debug)]
pub struct IfcSwitchingDevice {
    global_id: IfcGloballyUniqueId,
    owner_history: Option<EntityRef>,
    name: Option<IfcLabel>,
    description: Option<IfcText>,
    object_type: Option<IfcLabel>,
    object_placement: Option<EntityRef>,
    representation: Option<EntityRef>,
    tag: Option<IfcIdentifier>,
    predefined_type: Option<IfcSwitchingDeviceTypeEnum>,
}
impl IIfcRoot for IfcSwitchingDevice {
    fn global_id(&self) -> &IfcGloballyUniqueId {
        &self.global_id
    }
    fn owner_history(&self) -> &Option<EntityRef> {
        &self.owner_history
    }
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
}
impl IIfcObjectDefinition for IfcSwitchingDevice {}
impl IIfcObject for IfcSwitchingDevice {
    fn object_type(&self) -> &Option<IfcLabel> {
        &self.object_type
    }
}
impl IIfcProduct for IfcSwitchingDevice {
    fn object_placement(&self) -> &Option<EntityRef> {
        &self.object_placement
    }
    fn representation(&self) -> &Option<EntityRef> {
        &self.representation
    }
}
impl IIfcElement for IfcSwitchingDevice {
    fn tag(&self) -> &Option<IfcIdentifier> {
        &self.tag
    }
}
impl IIfcDistributionElement for IfcSwitchingDevice {}
impl IIfcDistributionFlowElement for IfcSwitchingDevice {}
impl IIfcFlowController for IfcSwitchingDevice {}
impl IIfcSwitchingDevice for IfcSwitchingDevice {
    fn predefined_type(&self) -> &Option<IfcSwitchingDeviceTypeEnum> {
        &self.predefined_type
    }
}
impl IfcSwitchingDevice {
    pub fn from_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcSwitchingDevice::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.global_id = parameter.into(),
                1usize => {
                    entity.owner_history = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => {
                    entity.object_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                5usize => {
                    entity.object_placement = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                6usize => {
                    entity.representation = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                7usize => {
                    entity.tag = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                8usize => {
                    entity.predefined_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
    pub fn from_own_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcSwitchingDevice::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => {
                    entity.predefined_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcSwitchingDeviceType: IIfcFlowControllerType {
    fn predefined_type(&self) -> &IfcSwitchingDeviceTypeEnum;
}
#[derive(Default, Debug)]
pub struct IfcSwitchingDeviceType {
    global_id: IfcGloballyUniqueId,
    owner_history: Option<EntityRef>,
    name: Option<IfcLabel>,
    description: Option<IfcText>,
    applicable_occurrence: Option<IfcIdentifier>,
    has_property_sets: Option<HashSet<EntityRef>>,
    representation_maps: Option<Vec<EntityRef>>,
    tag: Option<IfcLabel>,
    element_type: Option<IfcLabel>,
    predefined_type: IfcSwitchingDeviceTypeEnum,
}
impl IIfcRoot for IfcSwitchingDeviceType {
    fn global_id(&self) -> &IfcGloballyUniqueId {
        &self.global_id
    }
    fn owner_history(&self) -> &Option<EntityRef> {
        &self.owner_history
    }
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
}
impl IIfcObjectDefinition for IfcSwitchingDeviceType {}
impl IIfcTypeObject for IfcSwitchingDeviceType {
    fn applicable_occurrence(&self) -> &Option<IfcIdentifier> {
        &self.applicable_occurrence
    }
    fn has_property_sets(&self) -> &Option<HashSet<EntityRef>> {
        &self.has_property_sets
    }
}
impl IIfcTypeProduct for IfcSwitchingDeviceType {
    fn representation_maps(&self) -> &Option<Vec<EntityRef>> {
        &self.representation_maps
    }
    fn tag(&self) -> &Option<IfcLabel> {
        &self.tag
    }
}
impl IIfcElementType for IfcSwitchingDeviceType {
    fn element_type(&self) -> &Option<IfcLabel> {
        &self.element_type
    }
}
impl IIfcDistributionElementType for IfcSwitchingDeviceType {}
impl IIfcDistributionFlowElementType for IfcSwitchingDeviceType {}
impl IIfcFlowControllerType for IfcSwitchingDeviceType {}
impl IIfcSwitchingDeviceType for IfcSwitchingDeviceType {
    fn predefined_type(&self) -> &IfcSwitchingDeviceTypeEnum {
        &self.predefined_type
    }
}
impl IfcSwitchingDeviceType {
    pub fn from_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcSwitchingDeviceType::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.global_id = parameter.into(),
                1usize => {
                    entity.owner_history = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => {
                    entity.applicable_occurrence = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                5usize => {
                    entity.has_property_sets = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                6usize => {
                    entity.representation_maps = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                7usize => {
                    entity.tag = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                8usize => {
                    entity.element_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                9usize => entity.predefined_type = parameter.into(),
                _ => {}
            }
        }
        entity
    }
    pub fn from_own_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcSwitchingDeviceType::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.predefined_type = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcSystem: IIfcGroup {}
#[derive(Default, Debug)]
pub struct IfcSystem {
    global_id: IfcGloballyUniqueId,
    owner_history: Option<EntityRef>,
    name: Option<IfcLabel>,
    description: Option<IfcText>,
    object_type: Option<IfcLabel>,
}
impl IIfcRoot for IfcSystem {
    fn global_id(&self) -> &IfcGloballyUniqueId {
        &self.global_id
    }
    fn owner_history(&self) -> &Option<EntityRef> {
        &self.owner_history
    }
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
}
impl IIfcObjectDefinition for IfcSystem {}
impl IIfcObject for IfcSystem {
    fn object_type(&self) -> &Option<IfcLabel> {
        &self.object_type
    }
}
impl IIfcGroup for IfcSystem {}
impl IIfcSystem for IfcSystem {}
impl IfcSystem {
    pub fn from_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcSystem::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.global_id = parameter.into(),
                1usize => {
                    entity.owner_history = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => {
                    entity.object_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcSystemFurnitureElement: IIfcFurnishingElement {
    fn predefined_type(&self) -> &Option<IfcSystemFurnitureElementTypeEnum>;
}
#[derive(Default, Debug)]
pub struct IfcSystemFurnitureElement {
    global_id: IfcGloballyUniqueId,
    owner_history: Option<EntityRef>,
    name: Option<IfcLabel>,
    description: Option<IfcText>,
    object_type: Option<IfcLabel>,
    object_placement: Option<EntityRef>,
    representation: Option<EntityRef>,
    tag: Option<IfcIdentifier>,
    predefined_type: Option<IfcSystemFurnitureElementTypeEnum>,
}
impl IIfcRoot for IfcSystemFurnitureElement {
    fn global_id(&self) -> &IfcGloballyUniqueId {
        &self.global_id
    }
    fn owner_history(&self) -> &Option<EntityRef> {
        &self.owner_history
    }
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
}
impl IIfcObjectDefinition for IfcSystemFurnitureElement {}
impl IIfcObject for IfcSystemFurnitureElement {
    fn object_type(&self) -> &Option<IfcLabel> {
        &self.object_type
    }
}
impl IIfcProduct for IfcSystemFurnitureElement {
    fn object_placement(&self) -> &Option<EntityRef> {
        &self.object_placement
    }
    fn representation(&self) -> &Option<EntityRef> {
        &self.representation
    }
}
impl IIfcElement for IfcSystemFurnitureElement {
    fn tag(&self) -> &Option<IfcIdentifier> {
        &self.tag
    }
}
impl IIfcFurnishingElement for IfcSystemFurnitureElement {}
impl IIfcSystemFurnitureElement for IfcSystemFurnitureElement {
    fn predefined_type(&self) -> &Option<IfcSystemFurnitureElementTypeEnum> {
        &self.predefined_type
    }
}
impl IfcSystemFurnitureElement {
    pub fn from_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcSystemFurnitureElement::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.global_id = parameter.into(),
                1usize => {
                    entity.owner_history = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => {
                    entity.object_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                5usize => {
                    entity.object_placement = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                6usize => {
                    entity.representation = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                7usize => {
                    entity.tag = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                8usize => {
                    entity.predefined_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
    pub fn from_own_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcSystemFurnitureElement::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => {
                    entity.predefined_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcSystemFurnitureElementType: IIfcFurnishingElementType {
    fn predefined_type(&self) -> &Option<IfcSystemFurnitureElementTypeEnum>;
}
#[derive(Default, Debug)]
pub struct IfcSystemFurnitureElementType {
    global_id: IfcGloballyUniqueId,
    owner_history: Option<EntityRef>,
    name: Option<IfcLabel>,
    description: Option<IfcText>,
    applicable_occurrence: Option<IfcIdentifier>,
    has_property_sets: Option<HashSet<EntityRef>>,
    representation_maps: Option<Vec<EntityRef>>,
    tag: Option<IfcLabel>,
    element_type: Option<IfcLabel>,
    predefined_type: Option<IfcSystemFurnitureElementTypeEnum>,
}
impl IIfcRoot for IfcSystemFurnitureElementType {
    fn global_id(&self) -> &IfcGloballyUniqueId {
        &self.global_id
    }
    fn owner_history(&self) -> &Option<EntityRef> {
        &self.owner_history
    }
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
}
impl IIfcObjectDefinition for IfcSystemFurnitureElementType {}
impl IIfcTypeObject for IfcSystemFurnitureElementType {
    fn applicable_occurrence(&self) -> &Option<IfcIdentifier> {
        &self.applicable_occurrence
    }
    fn has_property_sets(&self) -> &Option<HashSet<EntityRef>> {
        &self.has_property_sets
    }
}
impl IIfcTypeProduct for IfcSystemFurnitureElementType {
    fn representation_maps(&self) -> &Option<Vec<EntityRef>> {
        &self.representation_maps
    }
    fn tag(&self) -> &Option<IfcLabel> {
        &self.tag
    }
}
impl IIfcElementType for IfcSystemFurnitureElementType {
    fn element_type(&self) -> &Option<IfcLabel> {
        &self.element_type
    }
}
impl IIfcFurnishingElementType for IfcSystemFurnitureElementType {}
impl IIfcSystemFurnitureElementType for IfcSystemFurnitureElementType {
    fn predefined_type(&self) -> &Option<IfcSystemFurnitureElementTypeEnum> {
        &self.predefined_type
    }
}
impl IfcSystemFurnitureElementType {
    pub fn from_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcSystemFurnitureElementType::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.global_id = parameter.into(),
                1usize => {
                    entity.owner_history = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => {
                    entity.applicable_occurrence = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                5usize => {
                    entity.has_property_sets = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                6usize => {
                    entity.representation_maps = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                7usize => {
                    entity.tag = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                8usize => {
                    entity.element_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                9usize => {
                    entity.predefined_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
    pub fn from_own_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcSystemFurnitureElementType::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => {
                    entity.predefined_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcTShapeProfileDef: IIfcParameterizedProfileDef {
    fn depth(&self) -> &IfcPositiveLengthMeasure;
    fn flange_width(&self) -> &IfcPositiveLengthMeasure;
    fn web_thickness(&self) -> &IfcPositiveLengthMeasure;
    fn flange_thickness(&self) -> &IfcPositiveLengthMeasure;
    fn fillet_radius(&self) -> &Option<IfcNonNegativeLengthMeasure>;
    fn flange_edge_radius(&self) -> &Option<IfcNonNegativeLengthMeasure>;
    fn web_edge_radius(&self) -> &Option<IfcNonNegativeLengthMeasure>;
    fn web_slope(&self) -> &Option<IfcPlaneAngleMeasure>;
    fn flange_slope(&self) -> &Option<IfcPlaneAngleMeasure>;
}
#[derive(Default, Debug)]
pub struct IfcTShapeProfileDef {
    profile_type: IfcProfileTypeEnum,
    profile_name: Option<IfcLabel>,
    position: Option<EntityRef>,
    depth: IfcPositiveLengthMeasure,
    flange_width: IfcPositiveLengthMeasure,
    web_thickness: IfcPositiveLengthMeasure,
    flange_thickness: IfcPositiveLengthMeasure,
    fillet_radius: Option<IfcNonNegativeLengthMeasure>,
    flange_edge_radius: Option<IfcNonNegativeLengthMeasure>,
    web_edge_radius: Option<IfcNonNegativeLengthMeasure>,
    web_slope: Option<IfcPlaneAngleMeasure>,
    flange_slope: Option<IfcPlaneAngleMeasure>,
}
impl IIfcProfileDef for IfcTShapeProfileDef {
    fn profile_type(&self) -> &IfcProfileTypeEnum {
        &self.profile_type
    }
    fn profile_name(&self) -> &Option<IfcLabel> {
        &self.profile_name
    }
}
impl IIfcParameterizedProfileDef for IfcTShapeProfileDef {
    fn position(&self) -> &Option<EntityRef> {
        &self.position
    }
}
impl IIfcTShapeProfileDef for IfcTShapeProfileDef {
    fn depth(&self) -> &IfcPositiveLengthMeasure {
        &self.depth
    }
    fn flange_width(&self) -> &IfcPositiveLengthMeasure {
        &self.flange_width
    }
    fn web_thickness(&self) -> &IfcPositiveLengthMeasure {
        &self.web_thickness
    }
    fn flange_thickness(&self) -> &IfcPositiveLengthMeasure {
        &self.flange_thickness
    }
    fn fillet_radius(&self) -> &Option<IfcNonNegativeLengthMeasure> {
        &self.fillet_radius
    }
    fn flange_edge_radius(&self) -> &Option<IfcNonNegativeLengthMeasure> {
        &self.flange_edge_radius
    }
    fn web_edge_radius(&self) -> &Option<IfcNonNegativeLengthMeasure> {
        &self.web_edge_radius
    }
    fn web_slope(&self) -> &Option<IfcPlaneAngleMeasure> {
        &self.web_slope
    }
    fn flange_slope(&self) -> &Option<IfcPlaneAngleMeasure> {
        &self.flange_slope
    }
}
impl IfcTShapeProfileDef {
    pub fn from_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcTShapeProfileDef::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.profile_type = parameter.into(),
                1usize => {
                    entity.profile_name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => {
                    entity.position = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => entity.depth = parameter.into(),
                4usize => entity.flange_width = parameter.into(),
                5usize => entity.web_thickness = parameter.into(),
                6usize => entity.flange_thickness = parameter.into(),
                7usize => {
                    entity.fillet_radius = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                8usize => {
                    entity.flange_edge_radius = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                9usize => {
                    entity.web_edge_radius = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                10usize => {
                    entity.web_slope = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                11usize => {
                    entity.flange_slope = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
    pub fn from_own_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcTShapeProfileDef::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.depth = parameter.into(),
                1usize => entity.flange_width = parameter.into(),
                2usize => entity.web_thickness = parameter.into(),
                3usize => entity.flange_thickness = parameter.into(),
                4usize => {
                    entity.fillet_radius = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                5usize => {
                    entity.flange_edge_radius = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                6usize => {
                    entity.web_edge_radius = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                7usize => {
                    entity.web_slope = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                8usize => {
                    entity.flange_slope = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcTable {
    fn name(&self) -> &Option<IfcLabel>;
    fn rows(&self) -> &Option<Vec<EntityRef>>;
    fn columns(&self) -> &Option<Vec<EntityRef>>;
}
#[derive(Default, Debug)]
pub struct IfcTable {
    name: Option<IfcLabel>,
    rows: Option<Vec<EntityRef>>,
    columns: Option<Vec<EntityRef>>,
}
impl IIfcTable for IfcTable {
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
    fn rows(&self) -> &Option<Vec<EntityRef>> {
        &self.rows
    }
    fn columns(&self) -> &Option<Vec<EntityRef>> {
        &self.columns
    }
}
impl IfcTable {
    pub fn from_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcTable::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                1usize => {
                    entity.rows = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => {
                    entity.columns = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcTableColumn {
    fn identifier(&self) -> &Option<IfcIdentifier>;
    fn name(&self) -> &Option<IfcLabel>;
    fn description(&self) -> &Option<IfcText>;
    fn unit(&self) -> &Option<EntityRef>;
    fn reference_path(&self) -> &Option<EntityRef>;
}
#[derive(Default, Debug)]
pub struct IfcTableColumn {
    identifier: Option<IfcIdentifier>,
    name: Option<IfcLabel>,
    description: Option<IfcText>,
    unit: Option<EntityRef>,
    reference_path: Option<EntityRef>,
}
impl IIfcTableColumn for IfcTableColumn {
    fn identifier(&self) -> &Option<IfcIdentifier> {
        &self.identifier
    }
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
    fn unit(&self) -> &Option<EntityRef> {
        &self.unit
    }
    fn reference_path(&self) -> &Option<EntityRef> {
        &self.reference_path
    }
}
impl IfcTableColumn {
    pub fn from_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcTableColumn::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => {
                    entity.identifier = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                1usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.unit = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => {
                    entity.reference_path = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcTableRow {
    fn row_cells(&self) -> &Option<Vec<IfcValue>>;
    fn is_heading(&self) -> &Option<IfcBoolean>;
}
#[derive(Default, Debug)]
pub struct IfcTableRow {
    row_cells: Option<Vec<IfcValue>>,
    is_heading: Option<IfcBoolean>,
}
impl IIfcTableRow for IfcTableRow {
    fn row_cells(&self) -> &Option<Vec<IfcValue>> {
        &self.row_cells
    }
    fn is_heading(&self) -> &Option<IfcBoolean> {
        &self.is_heading
    }
}
impl IfcTableRow {
    pub fn from_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcTableRow::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => {
                    entity.row_cells = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                1usize => {
                    entity.is_heading = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcTank: IIfcFlowStorageDevice {
    fn predefined_type(&self) -> &Option<IfcTankTypeEnum>;
}
#[derive(Default, Debug)]
pub struct IfcTank {
    global_id: IfcGloballyUniqueId,
    owner_history: Option<EntityRef>,
    name: Option<IfcLabel>,
    description: Option<IfcText>,
    object_type: Option<IfcLabel>,
    object_placement: Option<EntityRef>,
    representation: Option<EntityRef>,
    tag: Option<IfcIdentifier>,
    predefined_type: Option<IfcTankTypeEnum>,
}
impl IIfcRoot for IfcTank {
    fn global_id(&self) -> &IfcGloballyUniqueId {
        &self.global_id
    }
    fn owner_history(&self) -> &Option<EntityRef> {
        &self.owner_history
    }
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
}
impl IIfcObjectDefinition for IfcTank {}
impl IIfcObject for IfcTank {
    fn object_type(&self) -> &Option<IfcLabel> {
        &self.object_type
    }
}
impl IIfcProduct for IfcTank {
    fn object_placement(&self) -> &Option<EntityRef> {
        &self.object_placement
    }
    fn representation(&self) -> &Option<EntityRef> {
        &self.representation
    }
}
impl IIfcElement for IfcTank {
    fn tag(&self) -> &Option<IfcIdentifier> {
        &self.tag
    }
}
impl IIfcDistributionElement for IfcTank {}
impl IIfcDistributionFlowElement for IfcTank {}
impl IIfcFlowStorageDevice for IfcTank {}
impl IIfcTank for IfcTank {
    fn predefined_type(&self) -> &Option<IfcTankTypeEnum> {
        &self.predefined_type
    }
}
impl IfcTank {
    pub fn from_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcTank::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.global_id = parameter.into(),
                1usize => {
                    entity.owner_history = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => {
                    entity.object_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                5usize => {
                    entity.object_placement = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                6usize => {
                    entity.representation = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                7usize => {
                    entity.tag = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                8usize => {
                    entity.predefined_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
    pub fn from_own_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcTank::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => {
                    entity.predefined_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcTankType: IIfcFlowStorageDeviceType {
    fn predefined_type(&self) -> &IfcTankTypeEnum;
}
#[derive(Default, Debug)]
pub struct IfcTankType {
    global_id: IfcGloballyUniqueId,
    owner_history: Option<EntityRef>,
    name: Option<IfcLabel>,
    description: Option<IfcText>,
    applicable_occurrence: Option<IfcIdentifier>,
    has_property_sets: Option<HashSet<EntityRef>>,
    representation_maps: Option<Vec<EntityRef>>,
    tag: Option<IfcLabel>,
    element_type: Option<IfcLabel>,
    predefined_type: IfcTankTypeEnum,
}
impl IIfcRoot for IfcTankType {
    fn global_id(&self) -> &IfcGloballyUniqueId {
        &self.global_id
    }
    fn owner_history(&self) -> &Option<EntityRef> {
        &self.owner_history
    }
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
}
impl IIfcObjectDefinition for IfcTankType {}
impl IIfcTypeObject for IfcTankType {
    fn applicable_occurrence(&self) -> &Option<IfcIdentifier> {
        &self.applicable_occurrence
    }
    fn has_property_sets(&self) -> &Option<HashSet<EntityRef>> {
        &self.has_property_sets
    }
}
impl IIfcTypeProduct for IfcTankType {
    fn representation_maps(&self) -> &Option<Vec<EntityRef>> {
        &self.representation_maps
    }
    fn tag(&self) -> &Option<IfcLabel> {
        &self.tag
    }
}
impl IIfcElementType for IfcTankType {
    fn element_type(&self) -> &Option<IfcLabel> {
        &self.element_type
    }
}
impl IIfcDistributionElementType for IfcTankType {}
impl IIfcDistributionFlowElementType for IfcTankType {}
impl IIfcFlowStorageDeviceType for IfcTankType {}
impl IIfcTankType for IfcTankType {
    fn predefined_type(&self) -> &IfcTankTypeEnum {
        &self.predefined_type
    }
}
impl IfcTankType {
    pub fn from_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcTankType::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.global_id = parameter.into(),
                1usize => {
                    entity.owner_history = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => {
                    entity.applicable_occurrence = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                5usize => {
                    entity.has_property_sets = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                6usize => {
                    entity.representation_maps = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                7usize => {
                    entity.tag = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                8usize => {
                    entity.element_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                9usize => entity.predefined_type = parameter.into(),
                _ => {}
            }
        }
        entity
    }
    pub fn from_own_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcTankType::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.predefined_type = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcTask: IIfcProcess {
    fn status(&self) -> &Option<IfcLabel>;
    fn work_method(&self) -> &Option<IfcLabel>;
    fn is_milestone(&self) -> &IfcBoolean;
    fn priority(&self) -> &Option<IfcInteger>;
    fn task_time(&self) -> &Option<EntityRef>;
    fn predefined_type(&self) -> &Option<IfcTaskTypeEnum>;
}
#[derive(Default, Debug)]
pub struct IfcTask {
    global_id: IfcGloballyUniqueId,
    owner_history: Option<EntityRef>,
    name: Option<IfcLabel>,
    description: Option<IfcText>,
    object_type: Option<IfcLabel>,
    identification: Option<IfcIdentifier>,
    long_description: Option<IfcText>,
    status: Option<IfcLabel>,
    work_method: Option<IfcLabel>,
    is_milestone: IfcBoolean,
    priority: Option<IfcInteger>,
    task_time: Option<EntityRef>,
    predefined_type: Option<IfcTaskTypeEnum>,
}
impl IIfcRoot for IfcTask {
    fn global_id(&self) -> &IfcGloballyUniqueId {
        &self.global_id
    }
    fn owner_history(&self) -> &Option<EntityRef> {
        &self.owner_history
    }
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
}
impl IIfcObjectDefinition for IfcTask {}
impl IIfcObject for IfcTask {
    fn object_type(&self) -> &Option<IfcLabel> {
        &self.object_type
    }
}
impl IIfcProcess for IfcTask {
    fn identification(&self) -> &Option<IfcIdentifier> {
        &self.identification
    }
    fn long_description(&self) -> &Option<IfcText> {
        &self.long_description
    }
}
impl IIfcTask for IfcTask {
    fn status(&self) -> &Option<IfcLabel> {
        &self.status
    }
    fn work_method(&self) -> &Option<IfcLabel> {
        &self.work_method
    }
    fn is_milestone(&self) -> &IfcBoolean {
        &self.is_milestone
    }
    fn priority(&self) -> &Option<IfcInteger> {
        &self.priority
    }
    fn task_time(&self) -> &Option<EntityRef> {
        &self.task_time
    }
    fn predefined_type(&self) -> &Option<IfcTaskTypeEnum> {
        &self.predefined_type
    }
}
impl IfcTask {
    pub fn from_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcTask::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.global_id = parameter.into(),
                1usize => {
                    entity.owner_history = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => {
                    entity.object_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                5usize => {
                    entity.identification = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                6usize => {
                    entity.long_description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                7usize => {
                    entity.status = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                8usize => {
                    entity.work_method = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                9usize => entity.is_milestone = parameter.into(),
                10usize => {
                    entity.priority = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                11usize => {
                    entity.task_time = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                12usize => {
                    entity.predefined_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
    pub fn from_own_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcTask::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => {
                    entity.status = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                1usize => {
                    entity.work_method = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => entity.is_milestone = parameter.into(),
                3usize => {
                    entity.priority = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => {
                    entity.task_time = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                5usize => {
                    entity.predefined_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcTaskTime: IIfcSchedulingTime {
    fn duration_type(&self) -> &Option<IfcTaskDurationEnum>;
    fn schedule_duration(&self) -> &Option<IfcDuration>;
    fn schedule_start(&self) -> &Option<IfcDateTime>;
    fn schedule_finish(&self) -> &Option<IfcDateTime>;
    fn early_start(&self) -> &Option<IfcDateTime>;
    fn early_finish(&self) -> &Option<IfcDateTime>;
    fn late_start(&self) -> &Option<IfcDateTime>;
    fn late_finish(&self) -> &Option<IfcDateTime>;
    fn free_float(&self) -> &Option<IfcDuration>;
    fn total_float(&self) -> &Option<IfcDuration>;
    fn is_critical(&self) -> &Option<IfcBoolean>;
    fn status_time(&self) -> &Option<IfcDateTime>;
    fn actual_duration(&self) -> &Option<IfcDuration>;
    fn actual_start(&self) -> &Option<IfcDateTime>;
    fn actual_finish(&self) -> &Option<IfcDateTime>;
    fn remaining_time(&self) -> &Option<IfcDuration>;
    fn completion(&self) -> &Option<IfcPositiveRatioMeasure>;
}
#[derive(Default, Debug)]
pub struct IfcTaskTime {
    name: Option<IfcLabel>,
    data_origin: Option<IfcDataOriginEnum>,
    user_defined_data_origin: Option<IfcLabel>,
    duration_type: Option<IfcTaskDurationEnum>,
    schedule_duration: Option<IfcDuration>,
    schedule_start: Option<IfcDateTime>,
    schedule_finish: Option<IfcDateTime>,
    early_start: Option<IfcDateTime>,
    early_finish: Option<IfcDateTime>,
    late_start: Option<IfcDateTime>,
    late_finish: Option<IfcDateTime>,
    free_float: Option<IfcDuration>,
    total_float: Option<IfcDuration>,
    is_critical: Option<IfcBoolean>,
    status_time: Option<IfcDateTime>,
    actual_duration: Option<IfcDuration>,
    actual_start: Option<IfcDateTime>,
    actual_finish: Option<IfcDateTime>,
    remaining_time: Option<IfcDuration>,
    completion: Option<IfcPositiveRatioMeasure>,
}
impl IIfcSchedulingTime for IfcTaskTime {
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
    fn data_origin(&self) -> &Option<IfcDataOriginEnum> {
        &self.data_origin
    }
    fn user_defined_data_origin(&self) -> &Option<IfcLabel> {
        &self.user_defined_data_origin
    }
}
impl IIfcTaskTime for IfcTaskTime {
    fn duration_type(&self) -> &Option<IfcTaskDurationEnum> {
        &self.duration_type
    }
    fn schedule_duration(&self) -> &Option<IfcDuration> {
        &self.schedule_duration
    }
    fn schedule_start(&self) -> &Option<IfcDateTime> {
        &self.schedule_start
    }
    fn schedule_finish(&self) -> &Option<IfcDateTime> {
        &self.schedule_finish
    }
    fn early_start(&self) -> &Option<IfcDateTime> {
        &self.early_start
    }
    fn early_finish(&self) -> &Option<IfcDateTime> {
        &self.early_finish
    }
    fn late_start(&self) -> &Option<IfcDateTime> {
        &self.late_start
    }
    fn late_finish(&self) -> &Option<IfcDateTime> {
        &self.late_finish
    }
    fn free_float(&self) -> &Option<IfcDuration> {
        &self.free_float
    }
    fn total_float(&self) -> &Option<IfcDuration> {
        &self.total_float
    }
    fn is_critical(&self) -> &Option<IfcBoolean> {
        &self.is_critical
    }
    fn status_time(&self) -> &Option<IfcDateTime> {
        &self.status_time
    }
    fn actual_duration(&self) -> &Option<IfcDuration> {
        &self.actual_duration
    }
    fn actual_start(&self) -> &Option<IfcDateTime> {
        &self.actual_start
    }
    fn actual_finish(&self) -> &Option<IfcDateTime> {
        &self.actual_finish
    }
    fn remaining_time(&self) -> &Option<IfcDuration> {
        &self.remaining_time
    }
    fn completion(&self) -> &Option<IfcPositiveRatioMeasure> {
        &self.completion
    }
}
impl IfcTaskTime {
    pub fn from_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcTaskTime::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                1usize => {
                    entity.data_origin = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => {
                    entity.user_defined_data_origin = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.duration_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => {
                    entity.schedule_duration = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                5usize => {
                    entity.schedule_start = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                6usize => {
                    entity.schedule_finish = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                7usize => {
                    entity.early_start = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                8usize => {
                    entity.early_finish = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                9usize => {
                    entity.late_start = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                10usize => {
                    entity.late_finish = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                11usize => {
                    entity.free_float = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                12usize => {
                    entity.total_float = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                13usize => {
                    entity.is_critical = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                14usize => {
                    entity.status_time = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                15usize => {
                    entity.actual_duration = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                16usize => {
                    entity.actual_start = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                17usize => {
                    entity.actual_finish = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                18usize => {
                    entity.remaining_time = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                19usize => {
                    entity.completion = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
    pub fn from_own_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcTaskTime::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => {
                    entity.duration_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                1usize => {
                    entity.schedule_duration = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => {
                    entity.schedule_start = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.schedule_finish = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => {
                    entity.early_start = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                5usize => {
                    entity.early_finish = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                6usize => {
                    entity.late_start = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                7usize => {
                    entity.late_finish = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                8usize => {
                    entity.free_float = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                9usize => {
                    entity.total_float = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                10usize => {
                    entity.is_critical = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                11usize => {
                    entity.status_time = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                12usize => {
                    entity.actual_duration = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                13usize => {
                    entity.actual_start = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                14usize => {
                    entity.actual_finish = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                15usize => {
                    entity.remaining_time = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                16usize => {
                    entity.completion = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcTaskTimeRecurring: IIfcTaskTime {
    fn recurrence(&self) -> &EntityRef;
}
#[derive(Default, Debug)]
pub struct IfcTaskTimeRecurring {
    name: Option<IfcLabel>,
    data_origin: Option<IfcDataOriginEnum>,
    user_defined_data_origin: Option<IfcLabel>,
    duration_type: Option<IfcTaskDurationEnum>,
    schedule_duration: Option<IfcDuration>,
    schedule_start: Option<IfcDateTime>,
    schedule_finish: Option<IfcDateTime>,
    early_start: Option<IfcDateTime>,
    early_finish: Option<IfcDateTime>,
    late_start: Option<IfcDateTime>,
    late_finish: Option<IfcDateTime>,
    free_float: Option<IfcDuration>,
    total_float: Option<IfcDuration>,
    is_critical: Option<IfcBoolean>,
    status_time: Option<IfcDateTime>,
    actual_duration: Option<IfcDuration>,
    actual_start: Option<IfcDateTime>,
    actual_finish: Option<IfcDateTime>,
    remaining_time: Option<IfcDuration>,
    completion: Option<IfcPositiveRatioMeasure>,
    recurrence: EntityRef,
}
impl IIfcSchedulingTime for IfcTaskTimeRecurring {
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
    fn data_origin(&self) -> &Option<IfcDataOriginEnum> {
        &self.data_origin
    }
    fn user_defined_data_origin(&self) -> &Option<IfcLabel> {
        &self.user_defined_data_origin
    }
}
impl IIfcTaskTime for IfcTaskTimeRecurring {
    fn duration_type(&self) -> &Option<IfcTaskDurationEnum> {
        &self.duration_type
    }
    fn schedule_duration(&self) -> &Option<IfcDuration> {
        &self.schedule_duration
    }
    fn schedule_start(&self) -> &Option<IfcDateTime> {
        &self.schedule_start
    }
    fn schedule_finish(&self) -> &Option<IfcDateTime> {
        &self.schedule_finish
    }
    fn early_start(&self) -> &Option<IfcDateTime> {
        &self.early_start
    }
    fn early_finish(&self) -> &Option<IfcDateTime> {
        &self.early_finish
    }
    fn late_start(&self) -> &Option<IfcDateTime> {
        &self.late_start
    }
    fn late_finish(&self) -> &Option<IfcDateTime> {
        &self.late_finish
    }
    fn free_float(&self) -> &Option<IfcDuration> {
        &self.free_float
    }
    fn total_float(&self) -> &Option<IfcDuration> {
        &self.total_float
    }
    fn is_critical(&self) -> &Option<IfcBoolean> {
        &self.is_critical
    }
    fn status_time(&self) -> &Option<IfcDateTime> {
        &self.status_time
    }
    fn actual_duration(&self) -> &Option<IfcDuration> {
        &self.actual_duration
    }
    fn actual_start(&self) -> &Option<IfcDateTime> {
        &self.actual_start
    }
    fn actual_finish(&self) -> &Option<IfcDateTime> {
        &self.actual_finish
    }
    fn remaining_time(&self) -> &Option<IfcDuration> {
        &self.remaining_time
    }
    fn completion(&self) -> &Option<IfcPositiveRatioMeasure> {
        &self.completion
    }
}
impl IIfcTaskTimeRecurring for IfcTaskTimeRecurring {
    fn recurrence(&self) -> &EntityRef {
        &self.recurrence
    }
}
impl IfcTaskTimeRecurring {
    pub fn from_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcTaskTimeRecurring::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                1usize => {
                    entity.data_origin = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => {
                    entity.user_defined_data_origin = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.duration_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => {
                    entity.schedule_duration = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                5usize => {
                    entity.schedule_start = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                6usize => {
                    entity.schedule_finish = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                7usize => {
                    entity.early_start = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                8usize => {
                    entity.early_finish = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                9usize => {
                    entity.late_start = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                10usize => {
                    entity.late_finish = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                11usize => {
                    entity.free_float = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                12usize => {
                    entity.total_float = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                13usize => {
                    entity.is_critical = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                14usize => {
                    entity.status_time = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                15usize => {
                    entity.actual_duration = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                16usize => {
                    entity.actual_start = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                17usize => {
                    entity.actual_finish = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                18usize => {
                    entity.remaining_time = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                19usize => {
                    entity.completion = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                20usize => entity.recurrence = parameter.into(),
                _ => {}
            }
        }
        entity
    }
    pub fn from_own_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcTaskTimeRecurring::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.recurrence = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcTaskType: IIfcTypeProcess {
    fn predefined_type(&self) -> &IfcTaskTypeEnum;
    fn work_method(&self) -> &Option<IfcLabel>;
}
#[derive(Default, Debug)]
pub struct IfcTaskType {
    global_id: IfcGloballyUniqueId,
    owner_history: Option<EntityRef>,
    name: Option<IfcLabel>,
    description: Option<IfcText>,
    applicable_occurrence: Option<IfcIdentifier>,
    has_property_sets: Option<HashSet<EntityRef>>,
    identification: Option<IfcIdentifier>,
    long_description: Option<IfcText>,
    process_type: Option<IfcLabel>,
    predefined_type: IfcTaskTypeEnum,
    work_method: Option<IfcLabel>,
}
impl IIfcRoot for IfcTaskType {
    fn global_id(&self) -> &IfcGloballyUniqueId {
        &self.global_id
    }
    fn owner_history(&self) -> &Option<EntityRef> {
        &self.owner_history
    }
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
}
impl IIfcObjectDefinition for IfcTaskType {}
impl IIfcTypeObject for IfcTaskType {
    fn applicable_occurrence(&self) -> &Option<IfcIdentifier> {
        &self.applicable_occurrence
    }
    fn has_property_sets(&self) -> &Option<HashSet<EntityRef>> {
        &self.has_property_sets
    }
}
impl IIfcTypeProcess for IfcTaskType {
    fn identification(&self) -> &Option<IfcIdentifier> {
        &self.identification
    }
    fn long_description(&self) -> &Option<IfcText> {
        &self.long_description
    }
    fn process_type(&self) -> &Option<IfcLabel> {
        &self.process_type
    }
}
impl IIfcTaskType for IfcTaskType {
    fn predefined_type(&self) -> &IfcTaskTypeEnum {
        &self.predefined_type
    }
    fn work_method(&self) -> &Option<IfcLabel> {
        &self.work_method
    }
}
impl IfcTaskType {
    pub fn from_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcTaskType::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.global_id = parameter.into(),
                1usize => {
                    entity.owner_history = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => {
                    entity.applicable_occurrence = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                5usize => {
                    entity.has_property_sets = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                6usize => {
                    entity.identification = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                7usize => {
                    entity.long_description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                8usize => {
                    entity.process_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                9usize => entity.predefined_type = parameter.into(),
                10usize => {
                    entity.work_method = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
    pub fn from_own_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcTaskType::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.predefined_type = parameter.into(),
                1usize => {
                    entity.work_method = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcTelecomAddress: IIfcAddress {
    fn telephone_numbers(&self) -> &Option<Vec<IfcLabel>>;
    fn facsimile_numbers(&self) -> &Option<Vec<IfcLabel>>;
    fn pager_number(&self) -> &Option<IfcLabel>;
    fn electronic_mail_addresses(&self) -> &Option<Vec<IfcLabel>>;
    fn www_home_page_url(&self) -> &Option<IfcUriReference>;
    fn messaging_i_ds(&self) -> &Option<Vec<IfcUriReference>>;
}
#[derive(Default, Debug)]
pub struct IfcTelecomAddress {
    purpose: Option<IfcAddressTypeEnum>,
    description: Option<IfcText>,
    user_defined_purpose: Option<IfcLabel>,
    telephone_numbers: Option<Vec<IfcLabel>>,
    facsimile_numbers: Option<Vec<IfcLabel>>,
    pager_number: Option<IfcLabel>,
    electronic_mail_addresses: Option<Vec<IfcLabel>>,
    www_home_page_url: Option<IfcUriReference>,
    messaging_i_ds: Option<Vec<IfcUriReference>>,
}
impl IIfcAddress for IfcTelecomAddress {
    fn purpose(&self) -> &Option<IfcAddressTypeEnum> {
        &self.purpose
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
    fn user_defined_purpose(&self) -> &Option<IfcLabel> {
        &self.user_defined_purpose
    }
}
impl IIfcTelecomAddress for IfcTelecomAddress {
    fn telephone_numbers(&self) -> &Option<Vec<IfcLabel>> {
        &self.telephone_numbers
    }
    fn facsimile_numbers(&self) -> &Option<Vec<IfcLabel>> {
        &self.facsimile_numbers
    }
    fn pager_number(&self) -> &Option<IfcLabel> {
        &self.pager_number
    }
    fn electronic_mail_addresses(&self) -> &Option<Vec<IfcLabel>> {
        &self.electronic_mail_addresses
    }
    fn www_home_page_url(&self) -> &Option<IfcUriReference> {
        &self.www_home_page_url
    }
    fn messaging_i_ds(&self) -> &Option<Vec<IfcUriReference>> {
        &self.messaging_i_ds
    }
}
impl IfcTelecomAddress {
    pub fn from_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcTelecomAddress::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => {
                    entity.purpose = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                1usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => {
                    entity.user_defined_purpose = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.telephone_numbers = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => {
                    entity.facsimile_numbers = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                5usize => {
                    entity.pager_number = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                6usize => {
                    entity.electronic_mail_addresses = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                7usize => {
                    entity.www_home_page_url = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                8usize => {
                    entity.messaging_i_ds = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
    pub fn from_own_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcTelecomAddress::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => {
                    entity.telephone_numbers = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                1usize => {
                    entity.facsimile_numbers = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => {
                    entity.pager_number = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.electronic_mail_addresses = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => {
                    entity.www_home_page_url = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                5usize => {
                    entity.messaging_i_ds = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcTendon: IIfcReinforcingElement {
    fn predefined_type(&self) -> &Option<IfcTendonTypeEnum>;
    fn nominal_diameter(&self) -> &Option<IfcPositiveLengthMeasure>;
    fn cross_section_area(&self) -> &Option<IfcAreaMeasure>;
    fn tension_force(&self) -> &Option<IfcForceMeasure>;
    fn pre_stress(&self) -> &Option<IfcPressureMeasure>;
    fn friction_coefficient(&self) -> &Option<IfcNormalisedRatioMeasure>;
    fn anchorage_slip(&self) -> &Option<IfcPositiveLengthMeasure>;
    fn min_curvature_radius(&self) -> &Option<IfcPositiveLengthMeasure>;
}
#[derive(Default, Debug)]
pub struct IfcTendon {
    global_id: IfcGloballyUniqueId,
    owner_history: Option<EntityRef>,
    name: Option<IfcLabel>,
    description: Option<IfcText>,
    object_type: Option<IfcLabel>,
    object_placement: Option<EntityRef>,
    representation: Option<EntityRef>,
    tag: Option<IfcIdentifier>,
    steel_grade: Option<IfcLabel>,
    predefined_type: Option<IfcTendonTypeEnum>,
    nominal_diameter: Option<IfcPositiveLengthMeasure>,
    cross_section_area: Option<IfcAreaMeasure>,
    tension_force: Option<IfcForceMeasure>,
    pre_stress: Option<IfcPressureMeasure>,
    friction_coefficient: Option<IfcNormalisedRatioMeasure>,
    anchorage_slip: Option<IfcPositiveLengthMeasure>,
    min_curvature_radius: Option<IfcPositiveLengthMeasure>,
}
impl IIfcRoot for IfcTendon {
    fn global_id(&self) -> &IfcGloballyUniqueId {
        &self.global_id
    }
    fn owner_history(&self) -> &Option<EntityRef> {
        &self.owner_history
    }
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
}
impl IIfcObjectDefinition for IfcTendon {}
impl IIfcObject for IfcTendon {
    fn object_type(&self) -> &Option<IfcLabel> {
        &self.object_type
    }
}
impl IIfcProduct for IfcTendon {
    fn object_placement(&self) -> &Option<EntityRef> {
        &self.object_placement
    }
    fn representation(&self) -> &Option<EntityRef> {
        &self.representation
    }
}
impl IIfcElement for IfcTendon {
    fn tag(&self) -> &Option<IfcIdentifier> {
        &self.tag
    }
}
impl IIfcElementComponent for IfcTendon {}
impl IIfcReinforcingElement for IfcTendon {
    fn steel_grade(&self) -> &Option<IfcLabel> {
        &self.steel_grade
    }
}
impl IIfcTendon for IfcTendon {
    fn predefined_type(&self) -> &Option<IfcTendonTypeEnum> {
        &self.predefined_type
    }
    fn nominal_diameter(&self) -> &Option<IfcPositiveLengthMeasure> {
        &self.nominal_diameter
    }
    fn cross_section_area(&self) -> &Option<IfcAreaMeasure> {
        &self.cross_section_area
    }
    fn tension_force(&self) -> &Option<IfcForceMeasure> {
        &self.tension_force
    }
    fn pre_stress(&self) -> &Option<IfcPressureMeasure> {
        &self.pre_stress
    }
    fn friction_coefficient(&self) -> &Option<IfcNormalisedRatioMeasure> {
        &self.friction_coefficient
    }
    fn anchorage_slip(&self) -> &Option<IfcPositiveLengthMeasure> {
        &self.anchorage_slip
    }
    fn min_curvature_radius(&self) -> &Option<IfcPositiveLengthMeasure> {
        &self.min_curvature_radius
    }
}
impl IfcTendon {
    pub fn from_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcTendon::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.global_id = parameter.into(),
                1usize => {
                    entity.owner_history = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => {
                    entity.object_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                5usize => {
                    entity.object_placement = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                6usize => {
                    entity.representation = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                7usize => {
                    entity.tag = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                8usize => {
                    entity.steel_grade = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                9usize => {
                    entity.predefined_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                10usize => {
                    entity.nominal_diameter = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                11usize => {
                    entity.cross_section_area = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                12usize => {
                    entity.tension_force = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                13usize => {
                    entity.pre_stress = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                14usize => {
                    entity.friction_coefficient = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                15usize => {
                    entity.anchorage_slip = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                16usize => {
                    entity.min_curvature_radius = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
    pub fn from_own_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcTendon::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => {
                    entity.predefined_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                1usize => {
                    entity.nominal_diameter = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => {
                    entity.cross_section_area = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.tension_force = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => {
                    entity.pre_stress = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                5usize => {
                    entity.friction_coefficient = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                6usize => {
                    entity.anchorage_slip = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                7usize => {
                    entity.min_curvature_radius = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcTendonAnchor: IIfcReinforcingElement {
    fn predefined_type(&self) -> &Option<IfcTendonAnchorTypeEnum>;
}
#[derive(Default, Debug)]
pub struct IfcTendonAnchor {
    global_id: IfcGloballyUniqueId,
    owner_history: Option<EntityRef>,
    name: Option<IfcLabel>,
    description: Option<IfcText>,
    object_type: Option<IfcLabel>,
    object_placement: Option<EntityRef>,
    representation: Option<EntityRef>,
    tag: Option<IfcIdentifier>,
    steel_grade: Option<IfcLabel>,
    predefined_type: Option<IfcTendonAnchorTypeEnum>,
}
impl IIfcRoot for IfcTendonAnchor {
    fn global_id(&self) -> &IfcGloballyUniqueId {
        &self.global_id
    }
    fn owner_history(&self) -> &Option<EntityRef> {
        &self.owner_history
    }
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
}
impl IIfcObjectDefinition for IfcTendonAnchor {}
impl IIfcObject for IfcTendonAnchor {
    fn object_type(&self) -> &Option<IfcLabel> {
        &self.object_type
    }
}
impl IIfcProduct for IfcTendonAnchor {
    fn object_placement(&self) -> &Option<EntityRef> {
        &self.object_placement
    }
    fn representation(&self) -> &Option<EntityRef> {
        &self.representation
    }
}
impl IIfcElement for IfcTendonAnchor {
    fn tag(&self) -> &Option<IfcIdentifier> {
        &self.tag
    }
}
impl IIfcElementComponent for IfcTendonAnchor {}
impl IIfcReinforcingElement for IfcTendonAnchor {
    fn steel_grade(&self) -> &Option<IfcLabel> {
        &self.steel_grade
    }
}
impl IIfcTendonAnchor for IfcTendonAnchor {
    fn predefined_type(&self) -> &Option<IfcTendonAnchorTypeEnum> {
        &self.predefined_type
    }
}
impl IfcTendonAnchor {
    pub fn from_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcTendonAnchor::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.global_id = parameter.into(),
                1usize => {
                    entity.owner_history = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => {
                    entity.object_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                5usize => {
                    entity.object_placement = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                6usize => {
                    entity.representation = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                7usize => {
                    entity.tag = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                8usize => {
                    entity.steel_grade = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                9usize => {
                    entity.predefined_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
    pub fn from_own_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcTendonAnchor::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => {
                    entity.predefined_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcTendonAnchorType: IIfcReinforcingElementType {
    fn predefined_type(&self) -> &IfcTendonAnchorTypeEnum;
}
#[derive(Default, Debug)]
pub struct IfcTendonAnchorType {
    global_id: IfcGloballyUniqueId,
    owner_history: Option<EntityRef>,
    name: Option<IfcLabel>,
    description: Option<IfcText>,
    applicable_occurrence: Option<IfcIdentifier>,
    has_property_sets: Option<HashSet<EntityRef>>,
    representation_maps: Option<Vec<EntityRef>>,
    tag: Option<IfcLabel>,
    element_type: Option<IfcLabel>,
    predefined_type: IfcTendonAnchorTypeEnum,
}
impl IIfcRoot for IfcTendonAnchorType {
    fn global_id(&self) -> &IfcGloballyUniqueId {
        &self.global_id
    }
    fn owner_history(&self) -> &Option<EntityRef> {
        &self.owner_history
    }
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
}
impl IIfcObjectDefinition for IfcTendonAnchorType {}
impl IIfcTypeObject for IfcTendonAnchorType {
    fn applicable_occurrence(&self) -> &Option<IfcIdentifier> {
        &self.applicable_occurrence
    }
    fn has_property_sets(&self) -> &Option<HashSet<EntityRef>> {
        &self.has_property_sets
    }
}
impl IIfcTypeProduct for IfcTendonAnchorType {
    fn representation_maps(&self) -> &Option<Vec<EntityRef>> {
        &self.representation_maps
    }
    fn tag(&self) -> &Option<IfcLabel> {
        &self.tag
    }
}
impl IIfcElementType for IfcTendonAnchorType {
    fn element_type(&self) -> &Option<IfcLabel> {
        &self.element_type
    }
}
impl IIfcElementComponentType for IfcTendonAnchorType {}
impl IIfcReinforcingElementType for IfcTendonAnchorType {}
impl IIfcTendonAnchorType for IfcTendonAnchorType {
    fn predefined_type(&self) -> &IfcTendonAnchorTypeEnum {
        &self.predefined_type
    }
}
impl IfcTendonAnchorType {
    pub fn from_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcTendonAnchorType::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.global_id = parameter.into(),
                1usize => {
                    entity.owner_history = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => {
                    entity.applicable_occurrence = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                5usize => {
                    entity.has_property_sets = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                6usize => {
                    entity.representation_maps = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                7usize => {
                    entity.tag = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                8usize => {
                    entity.element_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                9usize => entity.predefined_type = parameter.into(),
                _ => {}
            }
        }
        entity
    }
    pub fn from_own_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcTendonAnchorType::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.predefined_type = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcTendonType: IIfcReinforcingElementType {
    fn predefined_type(&self) -> &IfcTendonTypeEnum;
    fn nominal_diameter(&self) -> &Option<IfcPositiveLengthMeasure>;
    fn cross_section_area(&self) -> &Option<IfcAreaMeasure>;
    fn sheath_diameter(&self) -> &Option<IfcPositiveLengthMeasure>;
}
#[derive(Default, Debug)]
pub struct IfcTendonType {
    global_id: IfcGloballyUniqueId,
    owner_history: Option<EntityRef>,
    name: Option<IfcLabel>,
    description: Option<IfcText>,
    applicable_occurrence: Option<IfcIdentifier>,
    has_property_sets: Option<HashSet<EntityRef>>,
    representation_maps: Option<Vec<EntityRef>>,
    tag: Option<IfcLabel>,
    element_type: Option<IfcLabel>,
    predefined_type: IfcTendonTypeEnum,
    nominal_diameter: Option<IfcPositiveLengthMeasure>,
    cross_section_area: Option<IfcAreaMeasure>,
    sheath_diameter: Option<IfcPositiveLengthMeasure>,
}
impl IIfcRoot for IfcTendonType {
    fn global_id(&self) -> &IfcGloballyUniqueId {
        &self.global_id
    }
    fn owner_history(&self) -> &Option<EntityRef> {
        &self.owner_history
    }
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
}
impl IIfcObjectDefinition for IfcTendonType {}
impl IIfcTypeObject for IfcTendonType {
    fn applicable_occurrence(&self) -> &Option<IfcIdentifier> {
        &self.applicable_occurrence
    }
    fn has_property_sets(&self) -> &Option<HashSet<EntityRef>> {
        &self.has_property_sets
    }
}
impl IIfcTypeProduct for IfcTendonType {
    fn representation_maps(&self) -> &Option<Vec<EntityRef>> {
        &self.representation_maps
    }
    fn tag(&self) -> &Option<IfcLabel> {
        &self.tag
    }
}
impl IIfcElementType for IfcTendonType {
    fn element_type(&self) -> &Option<IfcLabel> {
        &self.element_type
    }
}
impl IIfcElementComponentType for IfcTendonType {}
impl IIfcReinforcingElementType for IfcTendonType {}
impl IIfcTendonType for IfcTendonType {
    fn predefined_type(&self) -> &IfcTendonTypeEnum {
        &self.predefined_type
    }
    fn nominal_diameter(&self) -> &Option<IfcPositiveLengthMeasure> {
        &self.nominal_diameter
    }
    fn cross_section_area(&self) -> &Option<IfcAreaMeasure> {
        &self.cross_section_area
    }
    fn sheath_diameter(&self) -> &Option<IfcPositiveLengthMeasure> {
        &self.sheath_diameter
    }
}
impl IfcTendonType {
    pub fn from_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcTendonType::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.global_id = parameter.into(),
                1usize => {
                    entity.owner_history = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => {
                    entity.applicable_occurrence = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                5usize => {
                    entity.has_property_sets = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                6usize => {
                    entity.representation_maps = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                7usize => {
                    entity.tag = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                8usize => {
                    entity.element_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                9usize => entity.predefined_type = parameter.into(),
                10usize => {
                    entity.nominal_diameter = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                11usize => {
                    entity.cross_section_area = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                12usize => {
                    entity.sheath_diameter = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
    pub fn from_own_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcTendonType::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.predefined_type = parameter.into(),
                1usize => {
                    entity.nominal_diameter = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => {
                    entity.cross_section_area = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.sheath_diameter = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcTessellatedFaceSet: IIfcTessellatedItem {
    fn coordinates(&self) -> &EntityRef;
}
pub trait IIfcTessellatedItem: IIfcGeometricRepresentationItem {}
pub trait IIfcTextLiteral: IIfcGeometricRepresentationItem {
    fn literal(&self) -> &IfcPresentableText;
    fn placement(&self) -> &EntityRef;
    fn path(&self) -> &IfcTextPath;
}
#[derive(Default, Debug)]
pub struct IfcTextLiteral {
    literal: IfcPresentableText,
    placement: EntityRef,
    path: IfcTextPath,
}
impl IIfcRepresentationItem for IfcTextLiteral {}
impl IIfcGeometricRepresentationItem for IfcTextLiteral {}
impl IIfcTextLiteral for IfcTextLiteral {
    fn literal(&self) -> &IfcPresentableText {
        &self.literal
    }
    fn placement(&self) -> &EntityRef {
        &self.placement
    }
    fn path(&self) -> &IfcTextPath {
        &self.path
    }
}
impl IfcTextLiteral {
    pub fn from_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcTextLiteral::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.literal = parameter.into(),
                1usize => entity.placement = parameter.into(),
                2usize => entity.path = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcTextLiteralWithExtent: IIfcTextLiteral {
    fn extent(&self) -> &EntityRef;
    fn box_alignment(&self) -> &IfcBoxAlignment;
}
#[derive(Default, Debug)]
pub struct IfcTextLiteralWithExtent {
    literal: IfcPresentableText,
    placement: EntityRef,
    path: IfcTextPath,
    extent: EntityRef,
    box_alignment: IfcBoxAlignment,
}
impl IIfcRepresentationItem for IfcTextLiteralWithExtent {}
impl IIfcGeometricRepresentationItem for IfcTextLiteralWithExtent {}
impl IIfcTextLiteral for IfcTextLiteralWithExtent {
    fn literal(&self) -> &IfcPresentableText {
        &self.literal
    }
    fn placement(&self) -> &EntityRef {
        &self.placement
    }
    fn path(&self) -> &IfcTextPath {
        &self.path
    }
}
impl IIfcTextLiteralWithExtent for IfcTextLiteralWithExtent {
    fn extent(&self) -> &EntityRef {
        &self.extent
    }
    fn box_alignment(&self) -> &IfcBoxAlignment {
        &self.box_alignment
    }
}
impl IfcTextLiteralWithExtent {
    pub fn from_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcTextLiteralWithExtent::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.literal = parameter.into(),
                1usize => entity.placement = parameter.into(),
                2usize => entity.path = parameter.into(),
                3usize => entity.extent = parameter.into(),
                4usize => entity.box_alignment = parameter.into(),
                _ => {}
            }
        }
        entity
    }
    pub fn from_own_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcTextLiteralWithExtent::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.extent = parameter.into(),
                1usize => entity.box_alignment = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcTextStyle: IIfcPresentationStyle {
    fn text_character_appearance(&self) -> &Option<EntityRef>;
    fn text_style(&self) -> &Option<EntityRef>;
    fn text_font_style(&self) -> &EntityRef;
    fn model_or_draughting(&self) -> &Option<IfcBoolean>;
}
#[derive(Default, Debug)]
pub struct IfcTextStyle {
    name: Option<IfcLabel>,
    text_character_appearance: Option<EntityRef>,
    text_style: Option<EntityRef>,
    text_font_style: EntityRef,
    model_or_draughting: Option<IfcBoolean>,
}
impl IIfcPresentationStyle for IfcTextStyle {
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
}
impl IIfcTextStyle for IfcTextStyle {
    fn text_character_appearance(&self) -> &Option<EntityRef> {
        &self.text_character_appearance
    }
    fn text_style(&self) -> &Option<EntityRef> {
        &self.text_style
    }
    fn text_font_style(&self) -> &EntityRef {
        &self.text_font_style
    }
    fn model_or_draughting(&self) -> &Option<IfcBoolean> {
        &self.model_or_draughting
    }
}
impl IfcTextStyle {
    pub fn from_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcTextStyle::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                1usize => {
                    entity.text_character_appearance = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => {
                    entity.text_style = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => entity.text_font_style = parameter.into(),
                4usize => {
                    entity.model_or_draughting = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
    pub fn from_own_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcTextStyle::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => {
                    entity.text_character_appearance = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                1usize => {
                    entity.text_style = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => entity.text_font_style = parameter.into(),
                3usize => {
                    entity.model_or_draughting = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcTextStyleFontModel: IIfcPreDefinedTextFont {
    fn font_family(&self) -> &Vec<IfcTextFontName>;
    fn font_style(&self) -> &Option<IfcFontStyle>;
    fn font_variant(&self) -> &Option<IfcFontVariant>;
    fn font_weight(&self) -> &Option<IfcFontWeight>;
    fn font_size(&self) -> &IfcSizeSelect;
}
#[derive(Default, Debug)]
pub struct IfcTextStyleFontModel {
    name: IfcLabel,
    font_family: Vec<IfcTextFontName>,
    font_style: Option<IfcFontStyle>,
    font_variant: Option<IfcFontVariant>,
    font_weight: Option<IfcFontWeight>,
    font_size: IfcSizeSelect,
}
impl IIfcPresentationItem for IfcTextStyleFontModel {}
impl IIfcPreDefinedItem for IfcTextStyleFontModel {
    fn name(&self) -> &IfcLabel {
        &self.name
    }
}
impl IIfcPreDefinedTextFont for IfcTextStyleFontModel {}
impl IIfcTextStyleFontModel for IfcTextStyleFontModel {
    fn font_family(&self) -> &Vec<IfcTextFontName> {
        &self.font_family
    }
    fn font_style(&self) -> &Option<IfcFontStyle> {
        &self.font_style
    }
    fn font_variant(&self) -> &Option<IfcFontVariant> {
        &self.font_variant
    }
    fn font_weight(&self) -> &Option<IfcFontWeight> {
        &self.font_weight
    }
    fn font_size(&self) -> &IfcSizeSelect {
        &self.font_size
    }
}
impl IfcTextStyleFontModel {
    pub fn from_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcTextStyleFontModel::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => entity.font_family = parameter.into(),
                2usize => {
                    entity.font_style = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.font_variant = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => {
                    entity.font_weight = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                5usize => entity.font_size = parameter.into(),
                _ => {}
            }
        }
        entity
    }
    pub fn from_own_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcTextStyleFontModel::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.font_family = parameter.into(),
                1usize => {
                    entity.font_style = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => {
                    entity.font_variant = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.font_weight = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => entity.font_size = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcTextStyleForDefinedFont: IIfcPresentationItem {
    fn colour(&self) -> &EntityRef;
    fn background_colour(&self) -> &Option<EntityRef>;
}
#[derive(Default, Debug)]
pub struct IfcTextStyleForDefinedFont {
    colour: EntityRef,
    background_colour: Option<EntityRef>,
}
impl IIfcPresentationItem for IfcTextStyleForDefinedFont {}
impl IIfcTextStyleForDefinedFont for IfcTextStyleForDefinedFont {
    fn colour(&self) -> &EntityRef {
        &self.colour
    }
    fn background_colour(&self) -> &Option<EntityRef> {
        &self.background_colour
    }
}
impl IfcTextStyleForDefinedFont {
    pub fn from_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcTextStyleForDefinedFont::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.colour = parameter.into(),
                1usize => {
                    entity.background_colour = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcTextStyleTextModel: IIfcPresentationItem {
    fn text_indent(&self) -> &Option<IfcSizeSelect>;
    fn text_align(&self) -> &Option<IfcTextAlignment>;
    fn text_decoration(&self) -> &Option<IfcTextDecoration>;
    fn letter_spacing(&self) -> &Option<IfcSizeSelect>;
    fn word_spacing(&self) -> &Option<IfcSizeSelect>;
    fn text_transform(&self) -> &Option<IfcTextTransformation>;
    fn line_height(&self) -> &Option<IfcSizeSelect>;
}
#[derive(Default, Debug)]
pub struct IfcTextStyleTextModel {
    text_indent: Option<IfcSizeSelect>,
    text_align: Option<IfcTextAlignment>,
    text_decoration: Option<IfcTextDecoration>,
    letter_spacing: Option<IfcSizeSelect>,
    word_spacing: Option<IfcSizeSelect>,
    text_transform: Option<IfcTextTransformation>,
    line_height: Option<IfcSizeSelect>,
}
impl IIfcPresentationItem for IfcTextStyleTextModel {}
impl IIfcTextStyleTextModel for IfcTextStyleTextModel {
    fn text_indent(&self) -> &Option<IfcSizeSelect> {
        &self.text_indent
    }
    fn text_align(&self) -> &Option<IfcTextAlignment> {
        &self.text_align
    }
    fn text_decoration(&self) -> &Option<IfcTextDecoration> {
        &self.text_decoration
    }
    fn letter_spacing(&self) -> &Option<IfcSizeSelect> {
        &self.letter_spacing
    }
    fn word_spacing(&self) -> &Option<IfcSizeSelect> {
        &self.word_spacing
    }
    fn text_transform(&self) -> &Option<IfcTextTransformation> {
        &self.text_transform
    }
    fn line_height(&self) -> &Option<IfcSizeSelect> {
        &self.line_height
    }
}
impl IfcTextStyleTextModel {
    pub fn from_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcTextStyleTextModel::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => {
                    entity.text_indent = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                1usize => {
                    entity.text_align = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => {
                    entity.text_decoration = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.letter_spacing = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => {
                    entity.word_spacing = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                5usize => {
                    entity.text_transform = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                6usize => {
                    entity.line_height = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcTextureCoordinate: IIfcPresentationItem {
    fn maps(&self) -> &Vec<EntityRef>;
}
pub trait IIfcTextureCoordinateGenerator: IIfcTextureCoordinate {
    fn mode(&self) -> &IfcLabel;
    fn parameter(&self) -> &Option<Vec<IfcReal>>;
}
#[derive(Default, Debug)]
pub struct IfcTextureCoordinateGenerator {
    maps: Vec<EntityRef>,
    mode: IfcLabel,
    parameter: Option<Vec<IfcReal>>,
}
impl IIfcPresentationItem for IfcTextureCoordinateGenerator {}
impl IIfcTextureCoordinate for IfcTextureCoordinateGenerator {
    fn maps(&self) -> &Vec<EntityRef> {
        &self.maps
    }
}
impl IIfcTextureCoordinateGenerator for IfcTextureCoordinateGenerator {
    fn mode(&self) -> &IfcLabel {
        &self.mode
    }
    fn parameter(&self) -> &Option<Vec<IfcReal>> {
        &self.parameter
    }
}
impl IfcTextureCoordinateGenerator {
    pub fn from_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcTextureCoordinateGenerator::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.maps = parameter.into(),
                1usize => entity.mode = parameter.into(),
                2usize => {
                    entity.parameter = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
    pub fn from_own_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcTextureCoordinateGenerator::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.mode = parameter.into(),
                1usize => {
                    entity.parameter = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcTextureMap: IIfcTextureCoordinate {
    fn vertices(&self) -> &Vec<EntityRef>;
    fn mapped_to(&self) -> &EntityRef;
}
#[derive(Default, Debug)]
pub struct IfcTextureMap {
    maps: Vec<EntityRef>,
    vertices: Vec<EntityRef>,
    mapped_to: EntityRef,
}
impl IIfcPresentationItem for IfcTextureMap {}
impl IIfcTextureCoordinate for IfcTextureMap {
    fn maps(&self) -> &Vec<EntityRef> {
        &self.maps
    }
}
impl IIfcTextureMap for IfcTextureMap {
    fn vertices(&self) -> &Vec<EntityRef> {
        &self.vertices
    }
    fn mapped_to(&self) -> &EntityRef {
        &self.mapped_to
    }
}
impl IfcTextureMap {
    pub fn from_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcTextureMap::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.maps = parameter.into(),
                1usize => entity.vertices = parameter.into(),
                2usize => entity.mapped_to = parameter.into(),
                _ => {}
            }
        }
        entity
    }
    pub fn from_own_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcTextureMap::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.vertices = parameter.into(),
                1usize => entity.mapped_to = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcTextureVertex: IIfcPresentationItem {
    fn coordinates(&self) -> &Vec<IfcParameterValue>;
}
#[derive(Default, Debug)]
pub struct IfcTextureVertex {
    coordinates: Vec<IfcParameterValue>,
}
impl IIfcPresentationItem for IfcTextureVertex {}
impl IIfcTextureVertex for IfcTextureVertex {
    fn coordinates(&self) -> &Vec<IfcParameterValue> {
        &self.coordinates
    }
}
impl IfcTextureVertex {
    pub fn from_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcTextureVertex::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.coordinates = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcTextureVertexList: IIfcPresentationItem {
    fn tex_coords_list(&self) -> &Vec<Vec<IfcParameterValue>>;
}
#[derive(Default, Debug)]
pub struct IfcTextureVertexList {
    tex_coords_list: Vec<Vec<IfcParameterValue>>,
}
impl IIfcPresentationItem for IfcTextureVertexList {}
impl IIfcTextureVertexList for IfcTextureVertexList {
    fn tex_coords_list(&self) -> &Vec<Vec<IfcParameterValue>> {
        &self.tex_coords_list
    }
}
impl IfcTextureVertexList {
    pub fn from_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcTextureVertexList::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.tex_coords_list = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcTimePeriod {
    fn start_time(&self) -> &IfcTime;
    fn end_time(&self) -> &IfcTime;
}
#[derive(Default, Debug)]
pub struct IfcTimePeriod {
    start_time: IfcTime,
    end_time: IfcTime,
}
impl IIfcTimePeriod for IfcTimePeriod {
    fn start_time(&self) -> &IfcTime {
        &self.start_time
    }
    fn end_time(&self) -> &IfcTime {
        &self.end_time
    }
}
impl IfcTimePeriod {
    pub fn from_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcTimePeriod::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.start_time = parameter.into(),
                1usize => entity.end_time = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcTimeSeries {
    fn name(&self) -> &IfcLabel;
    fn description(&self) -> &Option<IfcText>;
    fn start_time(&self) -> &IfcDateTime;
    fn end_time(&self) -> &IfcDateTime;
    fn time_series_data_type(&self) -> &IfcTimeSeriesDataTypeEnum;
    fn data_origin(&self) -> &IfcDataOriginEnum;
    fn user_defined_data_origin(&self) -> &Option<IfcLabel>;
    fn unit(&self) -> &Option<EntityRef>;
}
pub trait IIfcTimeSeriesValue {
    fn list_values(&self) -> &Vec<IfcValue>;
}
#[derive(Default, Debug)]
pub struct IfcTimeSeriesValue {
    list_values: Vec<IfcValue>,
}
impl IIfcTimeSeriesValue for IfcTimeSeriesValue {
    fn list_values(&self) -> &Vec<IfcValue> {
        &self.list_values
    }
}
impl IfcTimeSeriesValue {
    pub fn from_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcTimeSeriesValue::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.list_values = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcTopologicalRepresentationItem: IIfcRepresentationItem {}
pub trait IIfcTopologyRepresentation: IIfcShapeModel {}
#[derive(Default, Debug)]
pub struct IfcTopologyRepresentation {
    context_of_items: EntityRef,
    representation_identifier: Option<IfcLabel>,
    representation_type: Option<IfcLabel>,
    items: HashSet<EntityRef>,
}
impl IIfcRepresentation for IfcTopologyRepresentation {
    fn context_of_items(&self) -> &EntityRef {
        &self.context_of_items
    }
    fn representation_identifier(&self) -> &Option<IfcLabel> {
        &self.representation_identifier
    }
    fn representation_type(&self) -> &Option<IfcLabel> {
        &self.representation_type
    }
    fn items(&self) -> &HashSet<EntityRef> {
        &self.items
    }
}
impl IIfcShapeModel for IfcTopologyRepresentation {}
impl IIfcTopologyRepresentation for IfcTopologyRepresentation {}
impl IfcTopologyRepresentation {
    pub fn from_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcTopologyRepresentation::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.context_of_items = parameter.into(),
                1usize => {
                    entity.representation_identifier = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => {
                    entity.representation_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => entity.items = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcToroidalSurface: IIfcElementarySurface {
    fn major_radius(&self) -> &IfcPositiveLengthMeasure;
    fn minor_radius(&self) -> &IfcPositiveLengthMeasure;
}
#[derive(Default, Debug)]
pub struct IfcToroidalSurface {
    position: EntityRef,
    major_radius: IfcPositiveLengthMeasure,
    minor_radius: IfcPositiveLengthMeasure,
}
impl IIfcRepresentationItem for IfcToroidalSurface {}
impl IIfcGeometricRepresentationItem for IfcToroidalSurface {}
impl IIfcSurface for IfcToroidalSurface {}
impl IIfcElementarySurface for IfcToroidalSurface {
    fn position(&self) -> &EntityRef {
        &self.position
    }
}
impl IIfcToroidalSurface for IfcToroidalSurface {
    fn major_radius(&self) -> &IfcPositiveLengthMeasure {
        &self.major_radius
    }
    fn minor_radius(&self) -> &IfcPositiveLengthMeasure {
        &self.minor_radius
    }
}
impl IfcToroidalSurface {
    pub fn from_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcToroidalSurface::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.position = parameter.into(),
                1usize => entity.major_radius = parameter.into(),
                2usize => entity.minor_radius = parameter.into(),
                _ => {}
            }
        }
        entity
    }
    pub fn from_own_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcToroidalSurface::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.major_radius = parameter.into(),
                1usize => entity.minor_radius = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcTransformer: IIfcEnergyConversionDevice {
    fn predefined_type(&self) -> &Option<IfcTransformerTypeEnum>;
}
#[derive(Default, Debug)]
pub struct IfcTransformer {
    global_id: IfcGloballyUniqueId,
    owner_history: Option<EntityRef>,
    name: Option<IfcLabel>,
    description: Option<IfcText>,
    object_type: Option<IfcLabel>,
    object_placement: Option<EntityRef>,
    representation: Option<EntityRef>,
    tag: Option<IfcIdentifier>,
    predefined_type: Option<IfcTransformerTypeEnum>,
}
impl IIfcRoot for IfcTransformer {
    fn global_id(&self) -> &IfcGloballyUniqueId {
        &self.global_id
    }
    fn owner_history(&self) -> &Option<EntityRef> {
        &self.owner_history
    }
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
}
impl IIfcObjectDefinition for IfcTransformer {}
impl IIfcObject for IfcTransformer {
    fn object_type(&self) -> &Option<IfcLabel> {
        &self.object_type
    }
}
impl IIfcProduct for IfcTransformer {
    fn object_placement(&self) -> &Option<EntityRef> {
        &self.object_placement
    }
    fn representation(&self) -> &Option<EntityRef> {
        &self.representation
    }
}
impl IIfcElement for IfcTransformer {
    fn tag(&self) -> &Option<IfcIdentifier> {
        &self.tag
    }
}
impl IIfcDistributionElement for IfcTransformer {}
impl IIfcDistributionFlowElement for IfcTransformer {}
impl IIfcEnergyConversionDevice for IfcTransformer {}
impl IIfcTransformer for IfcTransformer {
    fn predefined_type(&self) -> &Option<IfcTransformerTypeEnum> {
        &self.predefined_type
    }
}
impl IfcTransformer {
    pub fn from_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcTransformer::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.global_id = parameter.into(),
                1usize => {
                    entity.owner_history = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => {
                    entity.object_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                5usize => {
                    entity.object_placement = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                6usize => {
                    entity.representation = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                7usize => {
                    entity.tag = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                8usize => {
                    entity.predefined_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
    pub fn from_own_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcTransformer::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => {
                    entity.predefined_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcTransformerType: IIfcEnergyConversionDeviceType {
    fn predefined_type(&self) -> &IfcTransformerTypeEnum;
}
#[derive(Default, Debug)]
pub struct IfcTransformerType {
    global_id: IfcGloballyUniqueId,
    owner_history: Option<EntityRef>,
    name: Option<IfcLabel>,
    description: Option<IfcText>,
    applicable_occurrence: Option<IfcIdentifier>,
    has_property_sets: Option<HashSet<EntityRef>>,
    representation_maps: Option<Vec<EntityRef>>,
    tag: Option<IfcLabel>,
    element_type: Option<IfcLabel>,
    predefined_type: IfcTransformerTypeEnum,
}
impl IIfcRoot for IfcTransformerType {
    fn global_id(&self) -> &IfcGloballyUniqueId {
        &self.global_id
    }
    fn owner_history(&self) -> &Option<EntityRef> {
        &self.owner_history
    }
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
}
impl IIfcObjectDefinition for IfcTransformerType {}
impl IIfcTypeObject for IfcTransformerType {
    fn applicable_occurrence(&self) -> &Option<IfcIdentifier> {
        &self.applicable_occurrence
    }
    fn has_property_sets(&self) -> &Option<HashSet<EntityRef>> {
        &self.has_property_sets
    }
}
impl IIfcTypeProduct for IfcTransformerType {
    fn representation_maps(&self) -> &Option<Vec<EntityRef>> {
        &self.representation_maps
    }
    fn tag(&self) -> &Option<IfcLabel> {
        &self.tag
    }
}
impl IIfcElementType for IfcTransformerType {
    fn element_type(&self) -> &Option<IfcLabel> {
        &self.element_type
    }
}
impl IIfcDistributionElementType for IfcTransformerType {}
impl IIfcDistributionFlowElementType for IfcTransformerType {}
impl IIfcEnergyConversionDeviceType for IfcTransformerType {}
impl IIfcTransformerType for IfcTransformerType {
    fn predefined_type(&self) -> &IfcTransformerTypeEnum {
        &self.predefined_type
    }
}
impl IfcTransformerType {
    pub fn from_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcTransformerType::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.global_id = parameter.into(),
                1usize => {
                    entity.owner_history = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => {
                    entity.applicable_occurrence = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                5usize => {
                    entity.has_property_sets = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                6usize => {
                    entity.representation_maps = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                7usize => {
                    entity.tag = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                8usize => {
                    entity.element_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                9usize => entity.predefined_type = parameter.into(),
                _ => {}
            }
        }
        entity
    }
    pub fn from_own_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcTransformerType::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.predefined_type = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcTransportElement: IIfcElement {
    fn predefined_type(&self) -> &Option<IfcTransportElementTypeEnum>;
}
#[derive(Default, Debug)]
pub struct IfcTransportElement {
    global_id: IfcGloballyUniqueId,
    owner_history: Option<EntityRef>,
    name: Option<IfcLabel>,
    description: Option<IfcText>,
    object_type: Option<IfcLabel>,
    object_placement: Option<EntityRef>,
    representation: Option<EntityRef>,
    tag: Option<IfcIdentifier>,
    predefined_type: Option<IfcTransportElementTypeEnum>,
}
impl IIfcRoot for IfcTransportElement {
    fn global_id(&self) -> &IfcGloballyUniqueId {
        &self.global_id
    }
    fn owner_history(&self) -> &Option<EntityRef> {
        &self.owner_history
    }
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
}
impl IIfcObjectDefinition for IfcTransportElement {}
impl IIfcObject for IfcTransportElement {
    fn object_type(&self) -> &Option<IfcLabel> {
        &self.object_type
    }
}
impl IIfcProduct for IfcTransportElement {
    fn object_placement(&self) -> &Option<EntityRef> {
        &self.object_placement
    }
    fn representation(&self) -> &Option<EntityRef> {
        &self.representation
    }
}
impl IIfcElement for IfcTransportElement {
    fn tag(&self) -> &Option<IfcIdentifier> {
        &self.tag
    }
}
impl IIfcTransportElement for IfcTransportElement {
    fn predefined_type(&self) -> &Option<IfcTransportElementTypeEnum> {
        &self.predefined_type
    }
}
impl IfcTransportElement {
    pub fn from_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcTransportElement::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.global_id = parameter.into(),
                1usize => {
                    entity.owner_history = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => {
                    entity.object_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                5usize => {
                    entity.object_placement = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                6usize => {
                    entity.representation = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                7usize => {
                    entity.tag = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                8usize => {
                    entity.predefined_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
    pub fn from_own_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcTransportElement::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => {
                    entity.predefined_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcTransportElementType: IIfcElementType {
    fn predefined_type(&self) -> &IfcTransportElementTypeEnum;
}
#[derive(Default, Debug)]
pub struct IfcTransportElementType {
    global_id: IfcGloballyUniqueId,
    owner_history: Option<EntityRef>,
    name: Option<IfcLabel>,
    description: Option<IfcText>,
    applicable_occurrence: Option<IfcIdentifier>,
    has_property_sets: Option<HashSet<EntityRef>>,
    representation_maps: Option<Vec<EntityRef>>,
    tag: Option<IfcLabel>,
    element_type: Option<IfcLabel>,
    predefined_type: IfcTransportElementTypeEnum,
}
impl IIfcRoot for IfcTransportElementType {
    fn global_id(&self) -> &IfcGloballyUniqueId {
        &self.global_id
    }
    fn owner_history(&self) -> &Option<EntityRef> {
        &self.owner_history
    }
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
}
impl IIfcObjectDefinition for IfcTransportElementType {}
impl IIfcTypeObject for IfcTransportElementType {
    fn applicable_occurrence(&self) -> &Option<IfcIdentifier> {
        &self.applicable_occurrence
    }
    fn has_property_sets(&self) -> &Option<HashSet<EntityRef>> {
        &self.has_property_sets
    }
}
impl IIfcTypeProduct for IfcTransportElementType {
    fn representation_maps(&self) -> &Option<Vec<EntityRef>> {
        &self.representation_maps
    }
    fn tag(&self) -> &Option<IfcLabel> {
        &self.tag
    }
}
impl IIfcElementType for IfcTransportElementType {
    fn element_type(&self) -> &Option<IfcLabel> {
        &self.element_type
    }
}
impl IIfcTransportElementType for IfcTransportElementType {
    fn predefined_type(&self) -> &IfcTransportElementTypeEnum {
        &self.predefined_type
    }
}
impl IfcTransportElementType {
    pub fn from_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcTransportElementType::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.global_id = parameter.into(),
                1usize => {
                    entity.owner_history = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => {
                    entity.applicable_occurrence = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                5usize => {
                    entity.has_property_sets = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                6usize => {
                    entity.representation_maps = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                7usize => {
                    entity.tag = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                8usize => {
                    entity.element_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                9usize => entity.predefined_type = parameter.into(),
                _ => {}
            }
        }
        entity
    }
    pub fn from_own_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcTransportElementType::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.predefined_type = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcTrapeziumProfileDef: IIfcParameterizedProfileDef {
    fn bottom_x_dim(&self) -> &IfcPositiveLengthMeasure;
    fn top_x_dim(&self) -> &IfcPositiveLengthMeasure;
    fn y_dim(&self) -> &IfcPositiveLengthMeasure;
    fn top_x_offset(&self) -> &IfcLengthMeasure;
}
#[derive(Default, Debug)]
pub struct IfcTrapeziumProfileDef {
    profile_type: IfcProfileTypeEnum,
    profile_name: Option<IfcLabel>,
    position: Option<EntityRef>,
    bottom_x_dim: IfcPositiveLengthMeasure,
    top_x_dim: IfcPositiveLengthMeasure,
    y_dim: IfcPositiveLengthMeasure,
    top_x_offset: IfcLengthMeasure,
}
impl IIfcProfileDef for IfcTrapeziumProfileDef {
    fn profile_type(&self) -> &IfcProfileTypeEnum {
        &self.profile_type
    }
    fn profile_name(&self) -> &Option<IfcLabel> {
        &self.profile_name
    }
}
impl IIfcParameterizedProfileDef for IfcTrapeziumProfileDef {
    fn position(&self) -> &Option<EntityRef> {
        &self.position
    }
}
impl IIfcTrapeziumProfileDef for IfcTrapeziumProfileDef {
    fn bottom_x_dim(&self) -> &IfcPositiveLengthMeasure {
        &self.bottom_x_dim
    }
    fn top_x_dim(&self) -> &IfcPositiveLengthMeasure {
        &self.top_x_dim
    }
    fn y_dim(&self) -> &IfcPositiveLengthMeasure {
        &self.y_dim
    }
    fn top_x_offset(&self) -> &IfcLengthMeasure {
        &self.top_x_offset
    }
}
impl IfcTrapeziumProfileDef {
    pub fn from_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcTrapeziumProfileDef::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.profile_type = parameter.into(),
                1usize => {
                    entity.profile_name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => {
                    entity.position = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => entity.bottom_x_dim = parameter.into(),
                4usize => entity.top_x_dim = parameter.into(),
                5usize => entity.y_dim = parameter.into(),
                6usize => entity.top_x_offset = parameter.into(),
                _ => {}
            }
        }
        entity
    }
    pub fn from_own_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcTrapeziumProfileDef::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.bottom_x_dim = parameter.into(),
                1usize => entity.top_x_dim = parameter.into(),
                2usize => entity.y_dim = parameter.into(),
                3usize => entity.top_x_offset = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcTriangulatedFaceSet: IIfcTessellatedFaceSet {
    fn normals(&self) -> &Option<Vec<Vec<IfcParameterValue>>>;
    fn closed(&self) -> &Option<IfcBoolean>;
    fn coord_index(&self) -> &Vec<Vec<IfcPositiveInteger>>;
    fn pn_index(&self) -> &Option<Vec<IfcPositiveInteger>>;
}
#[derive(Default, Debug)]
pub struct IfcTriangulatedFaceSet {
    coordinates: EntityRef,
    normals: Option<Vec<Vec<IfcParameterValue>>>,
    closed: Option<IfcBoolean>,
    coord_index: Vec<Vec<IfcPositiveInteger>>,
    pn_index: Option<Vec<IfcPositiveInteger>>,
}
impl IIfcRepresentationItem for IfcTriangulatedFaceSet {}
impl IIfcGeometricRepresentationItem for IfcTriangulatedFaceSet {}
impl IIfcTessellatedItem for IfcTriangulatedFaceSet {}
impl IIfcTessellatedFaceSet for IfcTriangulatedFaceSet {
    fn coordinates(&self) -> &EntityRef {
        &self.coordinates
    }
}
impl IIfcTriangulatedFaceSet for IfcTriangulatedFaceSet {
    fn normals(&self) -> &Option<Vec<Vec<IfcParameterValue>>> {
        &self.normals
    }
    fn closed(&self) -> &Option<IfcBoolean> {
        &self.closed
    }
    fn coord_index(&self) -> &Vec<Vec<IfcPositiveInteger>> {
        &self.coord_index
    }
    fn pn_index(&self) -> &Option<Vec<IfcPositiveInteger>> {
        &self.pn_index
    }
}
impl IfcTriangulatedFaceSet {
    pub fn from_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcTriangulatedFaceSet::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.coordinates = parameter.into(),
                1usize => {
                    entity.normals = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => {
                    entity.closed = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => entity.coord_index = parameter.into(),
                4usize => {
                    entity.pn_index = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
    pub fn from_own_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcTriangulatedFaceSet::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => {
                    entity.normals = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                1usize => {
                    entity.closed = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => entity.coord_index = parameter.into(),
                3usize => {
                    entity.pn_index = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcTrimmedCurve: IIfcBoundedCurve {
    fn basis_curve(&self) -> &EntityRef;
    fn trim1(&self) -> &HashSet<IfcTrimmingSelect>;
    fn trim2(&self) -> &HashSet<IfcTrimmingSelect>;
    fn sense_agreement(&self) -> &IfcBoolean;
    fn master_representation(&self) -> &IfcTrimmingPreference;
}
#[derive(Default, Debug)]
pub struct IfcTrimmedCurve {
    basis_curve: EntityRef,
    trim1: HashSet<IfcTrimmingSelect>,
    trim2: HashSet<IfcTrimmingSelect>,
    sense_agreement: IfcBoolean,
    master_representation: IfcTrimmingPreference,
}
impl IIfcRepresentationItem for IfcTrimmedCurve {}
impl IIfcGeometricRepresentationItem for IfcTrimmedCurve {}
impl IIfcCurve for IfcTrimmedCurve {}
impl IIfcBoundedCurve for IfcTrimmedCurve {}
impl IIfcTrimmedCurve for IfcTrimmedCurve {
    fn basis_curve(&self) -> &EntityRef {
        &self.basis_curve
    }
    fn trim1(&self) -> &HashSet<IfcTrimmingSelect> {
        &self.trim1
    }
    fn trim2(&self) -> &HashSet<IfcTrimmingSelect> {
        &self.trim2
    }
    fn sense_agreement(&self) -> &IfcBoolean {
        &self.sense_agreement
    }
    fn master_representation(&self) -> &IfcTrimmingPreference {
        &self.master_representation
    }
}
impl IfcTrimmedCurve {
    pub fn from_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcTrimmedCurve::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.basis_curve = parameter.into(),
                1usize => entity.trim1 = parameter.into(),
                2usize => entity.trim2 = parameter.into(),
                3usize => entity.sense_agreement = parameter.into(),
                4usize => entity.master_representation = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcTubeBundle: IIfcEnergyConversionDevice {
    fn predefined_type(&self) -> &Option<IfcTubeBundleTypeEnum>;
}
#[derive(Default, Debug)]
pub struct IfcTubeBundle {
    global_id: IfcGloballyUniqueId,
    owner_history: Option<EntityRef>,
    name: Option<IfcLabel>,
    description: Option<IfcText>,
    object_type: Option<IfcLabel>,
    object_placement: Option<EntityRef>,
    representation: Option<EntityRef>,
    tag: Option<IfcIdentifier>,
    predefined_type: Option<IfcTubeBundleTypeEnum>,
}
impl IIfcRoot for IfcTubeBundle {
    fn global_id(&self) -> &IfcGloballyUniqueId {
        &self.global_id
    }
    fn owner_history(&self) -> &Option<EntityRef> {
        &self.owner_history
    }
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
}
impl IIfcObjectDefinition for IfcTubeBundle {}
impl IIfcObject for IfcTubeBundle {
    fn object_type(&self) -> &Option<IfcLabel> {
        &self.object_type
    }
}
impl IIfcProduct for IfcTubeBundle {
    fn object_placement(&self) -> &Option<EntityRef> {
        &self.object_placement
    }
    fn representation(&self) -> &Option<EntityRef> {
        &self.representation
    }
}
impl IIfcElement for IfcTubeBundle {
    fn tag(&self) -> &Option<IfcIdentifier> {
        &self.tag
    }
}
impl IIfcDistributionElement for IfcTubeBundle {}
impl IIfcDistributionFlowElement for IfcTubeBundle {}
impl IIfcEnergyConversionDevice for IfcTubeBundle {}
impl IIfcTubeBundle for IfcTubeBundle {
    fn predefined_type(&self) -> &Option<IfcTubeBundleTypeEnum> {
        &self.predefined_type
    }
}
impl IfcTubeBundle {
    pub fn from_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcTubeBundle::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.global_id = parameter.into(),
                1usize => {
                    entity.owner_history = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => {
                    entity.object_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                5usize => {
                    entity.object_placement = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                6usize => {
                    entity.representation = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                7usize => {
                    entity.tag = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                8usize => {
                    entity.predefined_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
    pub fn from_own_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcTubeBundle::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => {
                    entity.predefined_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcTubeBundleType: IIfcEnergyConversionDeviceType {
    fn predefined_type(&self) -> &IfcTubeBundleTypeEnum;
}
#[derive(Default, Debug)]
pub struct IfcTubeBundleType {
    global_id: IfcGloballyUniqueId,
    owner_history: Option<EntityRef>,
    name: Option<IfcLabel>,
    description: Option<IfcText>,
    applicable_occurrence: Option<IfcIdentifier>,
    has_property_sets: Option<HashSet<EntityRef>>,
    representation_maps: Option<Vec<EntityRef>>,
    tag: Option<IfcLabel>,
    element_type: Option<IfcLabel>,
    predefined_type: IfcTubeBundleTypeEnum,
}
impl IIfcRoot for IfcTubeBundleType {
    fn global_id(&self) -> &IfcGloballyUniqueId {
        &self.global_id
    }
    fn owner_history(&self) -> &Option<EntityRef> {
        &self.owner_history
    }
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
}
impl IIfcObjectDefinition for IfcTubeBundleType {}
impl IIfcTypeObject for IfcTubeBundleType {
    fn applicable_occurrence(&self) -> &Option<IfcIdentifier> {
        &self.applicable_occurrence
    }
    fn has_property_sets(&self) -> &Option<HashSet<EntityRef>> {
        &self.has_property_sets
    }
}
impl IIfcTypeProduct for IfcTubeBundleType {
    fn representation_maps(&self) -> &Option<Vec<EntityRef>> {
        &self.representation_maps
    }
    fn tag(&self) -> &Option<IfcLabel> {
        &self.tag
    }
}
impl IIfcElementType for IfcTubeBundleType {
    fn element_type(&self) -> &Option<IfcLabel> {
        &self.element_type
    }
}
impl IIfcDistributionElementType for IfcTubeBundleType {}
impl IIfcDistributionFlowElementType for IfcTubeBundleType {}
impl IIfcEnergyConversionDeviceType for IfcTubeBundleType {}
impl IIfcTubeBundleType for IfcTubeBundleType {
    fn predefined_type(&self) -> &IfcTubeBundleTypeEnum {
        &self.predefined_type
    }
}
impl IfcTubeBundleType {
    pub fn from_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcTubeBundleType::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.global_id = parameter.into(),
                1usize => {
                    entity.owner_history = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => {
                    entity.applicable_occurrence = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                5usize => {
                    entity.has_property_sets = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                6usize => {
                    entity.representation_maps = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                7usize => {
                    entity.tag = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                8usize => {
                    entity.element_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                9usize => entity.predefined_type = parameter.into(),
                _ => {}
            }
        }
        entity
    }
    pub fn from_own_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcTubeBundleType::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.predefined_type = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcTypeObject: IIfcObjectDefinition {
    fn applicable_occurrence(&self) -> &Option<IfcIdentifier>;
    fn has_property_sets(&self) -> &Option<HashSet<EntityRef>>;
}
#[derive(Default, Debug)]
pub struct IfcTypeObject {
    global_id: IfcGloballyUniqueId,
    owner_history: Option<EntityRef>,
    name: Option<IfcLabel>,
    description: Option<IfcText>,
    applicable_occurrence: Option<IfcIdentifier>,
    has_property_sets: Option<HashSet<EntityRef>>,
}
impl IIfcRoot for IfcTypeObject {
    fn global_id(&self) -> &IfcGloballyUniqueId {
        &self.global_id
    }
    fn owner_history(&self) -> &Option<EntityRef> {
        &self.owner_history
    }
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
}
impl IIfcObjectDefinition for IfcTypeObject {}
impl IIfcTypeObject for IfcTypeObject {
    fn applicable_occurrence(&self) -> &Option<IfcIdentifier> {
        &self.applicable_occurrence
    }
    fn has_property_sets(&self) -> &Option<HashSet<EntityRef>> {
        &self.has_property_sets
    }
}
impl IfcTypeObject {
    pub fn from_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcTypeObject::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.global_id = parameter.into(),
                1usize => {
                    entity.owner_history = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => {
                    entity.applicable_occurrence = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                5usize => {
                    entity.has_property_sets = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
    pub fn from_own_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcTypeObject::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => {
                    entity.applicable_occurrence = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                1usize => {
                    entity.has_property_sets = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcTypeProcess: IIfcTypeObject {
    fn identification(&self) -> &Option<IfcIdentifier>;
    fn long_description(&self) -> &Option<IfcText>;
    fn process_type(&self) -> &Option<IfcLabel>;
}
pub trait IIfcTypeProduct: IIfcTypeObject {
    fn representation_maps(&self) -> &Option<Vec<EntityRef>>;
    fn tag(&self) -> &Option<IfcLabel>;
}
#[derive(Default, Debug)]
pub struct IfcTypeProduct {
    global_id: IfcGloballyUniqueId,
    owner_history: Option<EntityRef>,
    name: Option<IfcLabel>,
    description: Option<IfcText>,
    applicable_occurrence: Option<IfcIdentifier>,
    has_property_sets: Option<HashSet<EntityRef>>,
    representation_maps: Option<Vec<EntityRef>>,
    tag: Option<IfcLabel>,
}
impl IIfcRoot for IfcTypeProduct {
    fn global_id(&self) -> &IfcGloballyUniqueId {
        &self.global_id
    }
    fn owner_history(&self) -> &Option<EntityRef> {
        &self.owner_history
    }
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
}
impl IIfcObjectDefinition for IfcTypeProduct {}
impl IIfcTypeObject for IfcTypeProduct {
    fn applicable_occurrence(&self) -> &Option<IfcIdentifier> {
        &self.applicable_occurrence
    }
    fn has_property_sets(&self) -> &Option<HashSet<EntityRef>> {
        &self.has_property_sets
    }
}
impl IIfcTypeProduct for IfcTypeProduct {
    fn representation_maps(&self) -> &Option<Vec<EntityRef>> {
        &self.representation_maps
    }
    fn tag(&self) -> &Option<IfcLabel> {
        &self.tag
    }
}
impl IfcTypeProduct {
    pub fn from_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcTypeProduct::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.global_id = parameter.into(),
                1usize => {
                    entity.owner_history = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => {
                    entity.applicable_occurrence = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                5usize => {
                    entity.has_property_sets = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                6usize => {
                    entity.representation_maps = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                7usize => {
                    entity.tag = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
    pub fn from_own_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcTypeProduct::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => {
                    entity.representation_maps = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                1usize => {
                    entity.tag = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcTypeResource: IIfcTypeObject {
    fn identification(&self) -> &Option<IfcIdentifier>;
    fn long_description(&self) -> &Option<IfcText>;
    fn resource_type(&self) -> &Option<IfcLabel>;
}
pub trait IIfcUShapeProfileDef: IIfcParameterizedProfileDef {
    fn depth(&self) -> &IfcPositiveLengthMeasure;
    fn flange_width(&self) -> &IfcPositiveLengthMeasure;
    fn web_thickness(&self) -> &IfcPositiveLengthMeasure;
    fn flange_thickness(&self) -> &IfcPositiveLengthMeasure;
    fn fillet_radius(&self) -> &Option<IfcNonNegativeLengthMeasure>;
    fn edge_radius(&self) -> &Option<IfcNonNegativeLengthMeasure>;
    fn flange_slope(&self) -> &Option<IfcPlaneAngleMeasure>;
}
#[derive(Default, Debug)]
pub struct IfcUShapeProfileDef {
    profile_type: IfcProfileTypeEnum,
    profile_name: Option<IfcLabel>,
    position: Option<EntityRef>,
    depth: IfcPositiveLengthMeasure,
    flange_width: IfcPositiveLengthMeasure,
    web_thickness: IfcPositiveLengthMeasure,
    flange_thickness: IfcPositiveLengthMeasure,
    fillet_radius: Option<IfcNonNegativeLengthMeasure>,
    edge_radius: Option<IfcNonNegativeLengthMeasure>,
    flange_slope: Option<IfcPlaneAngleMeasure>,
}
impl IIfcProfileDef for IfcUShapeProfileDef {
    fn profile_type(&self) -> &IfcProfileTypeEnum {
        &self.profile_type
    }
    fn profile_name(&self) -> &Option<IfcLabel> {
        &self.profile_name
    }
}
impl IIfcParameterizedProfileDef for IfcUShapeProfileDef {
    fn position(&self) -> &Option<EntityRef> {
        &self.position
    }
}
impl IIfcUShapeProfileDef for IfcUShapeProfileDef {
    fn depth(&self) -> &IfcPositiveLengthMeasure {
        &self.depth
    }
    fn flange_width(&self) -> &IfcPositiveLengthMeasure {
        &self.flange_width
    }
    fn web_thickness(&self) -> &IfcPositiveLengthMeasure {
        &self.web_thickness
    }
    fn flange_thickness(&self) -> &IfcPositiveLengthMeasure {
        &self.flange_thickness
    }
    fn fillet_radius(&self) -> &Option<IfcNonNegativeLengthMeasure> {
        &self.fillet_radius
    }
    fn edge_radius(&self) -> &Option<IfcNonNegativeLengthMeasure> {
        &self.edge_radius
    }
    fn flange_slope(&self) -> &Option<IfcPlaneAngleMeasure> {
        &self.flange_slope
    }
}
impl IfcUShapeProfileDef {
    pub fn from_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcUShapeProfileDef::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.profile_type = parameter.into(),
                1usize => {
                    entity.profile_name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => {
                    entity.position = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => entity.depth = parameter.into(),
                4usize => entity.flange_width = parameter.into(),
                5usize => entity.web_thickness = parameter.into(),
                6usize => entity.flange_thickness = parameter.into(),
                7usize => {
                    entity.fillet_radius = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                8usize => {
                    entity.edge_radius = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                9usize => {
                    entity.flange_slope = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
    pub fn from_own_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcUShapeProfileDef::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.depth = parameter.into(),
                1usize => entity.flange_width = parameter.into(),
                2usize => entity.web_thickness = parameter.into(),
                3usize => entity.flange_thickness = parameter.into(),
                4usize => {
                    entity.fillet_radius = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                5usize => {
                    entity.edge_radius = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                6usize => {
                    entity.flange_slope = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcUnitAssignment {
    fn units(&self) -> &HashSet<EntityRef>;
}
#[derive(Default, Debug)]
pub struct IfcUnitAssignment {
    units: HashSet<EntityRef>,
}
impl IIfcUnitAssignment for IfcUnitAssignment {
    fn units(&self) -> &HashSet<EntityRef> {
        &self.units
    }
}
impl IfcUnitAssignment {
    pub fn from_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcUnitAssignment::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.units = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcUnitaryControlElement: IIfcDistributionControlElement {
    fn predefined_type(&self) -> &Option<IfcUnitaryControlElementTypeEnum>;
}
#[derive(Default, Debug)]
pub struct IfcUnitaryControlElement {
    global_id: IfcGloballyUniqueId,
    owner_history: Option<EntityRef>,
    name: Option<IfcLabel>,
    description: Option<IfcText>,
    object_type: Option<IfcLabel>,
    object_placement: Option<EntityRef>,
    representation: Option<EntityRef>,
    tag: Option<IfcIdentifier>,
    predefined_type: Option<IfcUnitaryControlElementTypeEnum>,
}
impl IIfcRoot for IfcUnitaryControlElement {
    fn global_id(&self) -> &IfcGloballyUniqueId {
        &self.global_id
    }
    fn owner_history(&self) -> &Option<EntityRef> {
        &self.owner_history
    }
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
}
impl IIfcObjectDefinition for IfcUnitaryControlElement {}
impl IIfcObject for IfcUnitaryControlElement {
    fn object_type(&self) -> &Option<IfcLabel> {
        &self.object_type
    }
}
impl IIfcProduct for IfcUnitaryControlElement {
    fn object_placement(&self) -> &Option<EntityRef> {
        &self.object_placement
    }
    fn representation(&self) -> &Option<EntityRef> {
        &self.representation
    }
}
impl IIfcElement for IfcUnitaryControlElement {
    fn tag(&self) -> &Option<IfcIdentifier> {
        &self.tag
    }
}
impl IIfcDistributionElement for IfcUnitaryControlElement {}
impl IIfcDistributionControlElement for IfcUnitaryControlElement {}
impl IIfcUnitaryControlElement for IfcUnitaryControlElement {
    fn predefined_type(&self) -> &Option<IfcUnitaryControlElementTypeEnum> {
        &self.predefined_type
    }
}
impl IfcUnitaryControlElement {
    pub fn from_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcUnitaryControlElement::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.global_id = parameter.into(),
                1usize => {
                    entity.owner_history = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => {
                    entity.object_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                5usize => {
                    entity.object_placement = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                6usize => {
                    entity.representation = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                7usize => {
                    entity.tag = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                8usize => {
                    entity.predefined_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
    pub fn from_own_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcUnitaryControlElement::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => {
                    entity.predefined_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcUnitaryControlElementType: IIfcDistributionControlElementType {
    fn predefined_type(&self) -> &IfcUnitaryControlElementTypeEnum;
}
#[derive(Default, Debug)]
pub struct IfcUnitaryControlElementType {
    global_id: IfcGloballyUniqueId,
    owner_history: Option<EntityRef>,
    name: Option<IfcLabel>,
    description: Option<IfcText>,
    applicable_occurrence: Option<IfcIdentifier>,
    has_property_sets: Option<HashSet<EntityRef>>,
    representation_maps: Option<Vec<EntityRef>>,
    tag: Option<IfcLabel>,
    element_type: Option<IfcLabel>,
    predefined_type: IfcUnitaryControlElementTypeEnum,
}
impl IIfcRoot for IfcUnitaryControlElementType {
    fn global_id(&self) -> &IfcGloballyUniqueId {
        &self.global_id
    }
    fn owner_history(&self) -> &Option<EntityRef> {
        &self.owner_history
    }
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
}
impl IIfcObjectDefinition for IfcUnitaryControlElementType {}
impl IIfcTypeObject for IfcUnitaryControlElementType {
    fn applicable_occurrence(&self) -> &Option<IfcIdentifier> {
        &self.applicable_occurrence
    }
    fn has_property_sets(&self) -> &Option<HashSet<EntityRef>> {
        &self.has_property_sets
    }
}
impl IIfcTypeProduct for IfcUnitaryControlElementType {
    fn representation_maps(&self) -> &Option<Vec<EntityRef>> {
        &self.representation_maps
    }
    fn tag(&self) -> &Option<IfcLabel> {
        &self.tag
    }
}
impl IIfcElementType for IfcUnitaryControlElementType {
    fn element_type(&self) -> &Option<IfcLabel> {
        &self.element_type
    }
}
impl IIfcDistributionElementType for IfcUnitaryControlElementType {}
impl IIfcDistributionControlElementType for IfcUnitaryControlElementType {}
impl IIfcUnitaryControlElementType for IfcUnitaryControlElementType {
    fn predefined_type(&self) -> &IfcUnitaryControlElementTypeEnum {
        &self.predefined_type
    }
}
impl IfcUnitaryControlElementType {
    pub fn from_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcUnitaryControlElementType::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.global_id = parameter.into(),
                1usize => {
                    entity.owner_history = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => {
                    entity.applicable_occurrence = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                5usize => {
                    entity.has_property_sets = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                6usize => {
                    entity.representation_maps = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                7usize => {
                    entity.tag = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                8usize => {
                    entity.element_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                9usize => entity.predefined_type = parameter.into(),
                _ => {}
            }
        }
        entity
    }
    pub fn from_own_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcUnitaryControlElementType::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.predefined_type = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcUnitaryEquipment: IIfcEnergyConversionDevice {
    fn predefined_type(&self) -> &Option<IfcUnitaryEquipmentTypeEnum>;
}
#[derive(Default, Debug)]
pub struct IfcUnitaryEquipment {
    global_id: IfcGloballyUniqueId,
    owner_history: Option<EntityRef>,
    name: Option<IfcLabel>,
    description: Option<IfcText>,
    object_type: Option<IfcLabel>,
    object_placement: Option<EntityRef>,
    representation: Option<EntityRef>,
    tag: Option<IfcIdentifier>,
    predefined_type: Option<IfcUnitaryEquipmentTypeEnum>,
}
impl IIfcRoot for IfcUnitaryEquipment {
    fn global_id(&self) -> &IfcGloballyUniqueId {
        &self.global_id
    }
    fn owner_history(&self) -> &Option<EntityRef> {
        &self.owner_history
    }
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
}
impl IIfcObjectDefinition for IfcUnitaryEquipment {}
impl IIfcObject for IfcUnitaryEquipment {
    fn object_type(&self) -> &Option<IfcLabel> {
        &self.object_type
    }
}
impl IIfcProduct for IfcUnitaryEquipment {
    fn object_placement(&self) -> &Option<EntityRef> {
        &self.object_placement
    }
    fn representation(&self) -> &Option<EntityRef> {
        &self.representation
    }
}
impl IIfcElement for IfcUnitaryEquipment {
    fn tag(&self) -> &Option<IfcIdentifier> {
        &self.tag
    }
}
impl IIfcDistributionElement for IfcUnitaryEquipment {}
impl IIfcDistributionFlowElement for IfcUnitaryEquipment {}
impl IIfcEnergyConversionDevice for IfcUnitaryEquipment {}
impl IIfcUnitaryEquipment for IfcUnitaryEquipment {
    fn predefined_type(&self) -> &Option<IfcUnitaryEquipmentTypeEnum> {
        &self.predefined_type
    }
}
impl IfcUnitaryEquipment {
    pub fn from_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcUnitaryEquipment::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.global_id = parameter.into(),
                1usize => {
                    entity.owner_history = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => {
                    entity.object_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                5usize => {
                    entity.object_placement = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                6usize => {
                    entity.representation = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                7usize => {
                    entity.tag = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                8usize => {
                    entity.predefined_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
    pub fn from_own_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcUnitaryEquipment::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => {
                    entity.predefined_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcUnitaryEquipmentType: IIfcEnergyConversionDeviceType {
    fn predefined_type(&self) -> &IfcUnitaryEquipmentTypeEnum;
}
#[derive(Default, Debug)]
pub struct IfcUnitaryEquipmentType {
    global_id: IfcGloballyUniqueId,
    owner_history: Option<EntityRef>,
    name: Option<IfcLabel>,
    description: Option<IfcText>,
    applicable_occurrence: Option<IfcIdentifier>,
    has_property_sets: Option<HashSet<EntityRef>>,
    representation_maps: Option<Vec<EntityRef>>,
    tag: Option<IfcLabel>,
    element_type: Option<IfcLabel>,
    predefined_type: IfcUnitaryEquipmentTypeEnum,
}
impl IIfcRoot for IfcUnitaryEquipmentType {
    fn global_id(&self) -> &IfcGloballyUniqueId {
        &self.global_id
    }
    fn owner_history(&self) -> &Option<EntityRef> {
        &self.owner_history
    }
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
}
impl IIfcObjectDefinition for IfcUnitaryEquipmentType {}
impl IIfcTypeObject for IfcUnitaryEquipmentType {
    fn applicable_occurrence(&self) -> &Option<IfcIdentifier> {
        &self.applicable_occurrence
    }
    fn has_property_sets(&self) -> &Option<HashSet<EntityRef>> {
        &self.has_property_sets
    }
}
impl IIfcTypeProduct for IfcUnitaryEquipmentType {
    fn representation_maps(&self) -> &Option<Vec<EntityRef>> {
        &self.representation_maps
    }
    fn tag(&self) -> &Option<IfcLabel> {
        &self.tag
    }
}
impl IIfcElementType for IfcUnitaryEquipmentType {
    fn element_type(&self) -> &Option<IfcLabel> {
        &self.element_type
    }
}
impl IIfcDistributionElementType for IfcUnitaryEquipmentType {}
impl IIfcDistributionFlowElementType for IfcUnitaryEquipmentType {}
impl IIfcEnergyConversionDeviceType for IfcUnitaryEquipmentType {}
impl IIfcUnitaryEquipmentType for IfcUnitaryEquipmentType {
    fn predefined_type(&self) -> &IfcUnitaryEquipmentTypeEnum {
        &self.predefined_type
    }
}
impl IfcUnitaryEquipmentType {
    pub fn from_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcUnitaryEquipmentType::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.global_id = parameter.into(),
                1usize => {
                    entity.owner_history = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => {
                    entity.applicable_occurrence = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                5usize => {
                    entity.has_property_sets = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                6usize => {
                    entity.representation_maps = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                7usize => {
                    entity.tag = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                8usize => {
                    entity.element_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                9usize => entity.predefined_type = parameter.into(),
                _ => {}
            }
        }
        entity
    }
    pub fn from_own_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcUnitaryEquipmentType::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.predefined_type = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcValve: IIfcFlowController {
    fn predefined_type(&self) -> &Option<IfcValveTypeEnum>;
}
#[derive(Default, Debug)]
pub struct IfcValve {
    global_id: IfcGloballyUniqueId,
    owner_history: Option<EntityRef>,
    name: Option<IfcLabel>,
    description: Option<IfcText>,
    object_type: Option<IfcLabel>,
    object_placement: Option<EntityRef>,
    representation: Option<EntityRef>,
    tag: Option<IfcIdentifier>,
    predefined_type: Option<IfcValveTypeEnum>,
}
impl IIfcRoot for IfcValve {
    fn global_id(&self) -> &IfcGloballyUniqueId {
        &self.global_id
    }
    fn owner_history(&self) -> &Option<EntityRef> {
        &self.owner_history
    }
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
}
impl IIfcObjectDefinition for IfcValve {}
impl IIfcObject for IfcValve {
    fn object_type(&self) -> &Option<IfcLabel> {
        &self.object_type
    }
}
impl IIfcProduct for IfcValve {
    fn object_placement(&self) -> &Option<EntityRef> {
        &self.object_placement
    }
    fn representation(&self) -> &Option<EntityRef> {
        &self.representation
    }
}
impl IIfcElement for IfcValve {
    fn tag(&self) -> &Option<IfcIdentifier> {
        &self.tag
    }
}
impl IIfcDistributionElement for IfcValve {}
impl IIfcDistributionFlowElement for IfcValve {}
impl IIfcFlowController for IfcValve {}
impl IIfcValve for IfcValve {
    fn predefined_type(&self) -> &Option<IfcValveTypeEnum> {
        &self.predefined_type
    }
}
impl IfcValve {
    pub fn from_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcValve::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.global_id = parameter.into(),
                1usize => {
                    entity.owner_history = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => {
                    entity.object_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                5usize => {
                    entity.object_placement = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                6usize => {
                    entity.representation = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                7usize => {
                    entity.tag = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                8usize => {
                    entity.predefined_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
    pub fn from_own_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcValve::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => {
                    entity.predefined_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcValveType: IIfcFlowControllerType {
    fn predefined_type(&self) -> &IfcValveTypeEnum;
}
#[derive(Default, Debug)]
pub struct IfcValveType {
    global_id: IfcGloballyUniqueId,
    owner_history: Option<EntityRef>,
    name: Option<IfcLabel>,
    description: Option<IfcText>,
    applicable_occurrence: Option<IfcIdentifier>,
    has_property_sets: Option<HashSet<EntityRef>>,
    representation_maps: Option<Vec<EntityRef>>,
    tag: Option<IfcLabel>,
    element_type: Option<IfcLabel>,
    predefined_type: IfcValveTypeEnum,
}
impl IIfcRoot for IfcValveType {
    fn global_id(&self) -> &IfcGloballyUniqueId {
        &self.global_id
    }
    fn owner_history(&self) -> &Option<EntityRef> {
        &self.owner_history
    }
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
}
impl IIfcObjectDefinition for IfcValveType {}
impl IIfcTypeObject for IfcValveType {
    fn applicable_occurrence(&self) -> &Option<IfcIdentifier> {
        &self.applicable_occurrence
    }
    fn has_property_sets(&self) -> &Option<HashSet<EntityRef>> {
        &self.has_property_sets
    }
}
impl IIfcTypeProduct for IfcValveType {
    fn representation_maps(&self) -> &Option<Vec<EntityRef>> {
        &self.representation_maps
    }
    fn tag(&self) -> &Option<IfcLabel> {
        &self.tag
    }
}
impl IIfcElementType for IfcValveType {
    fn element_type(&self) -> &Option<IfcLabel> {
        &self.element_type
    }
}
impl IIfcDistributionElementType for IfcValveType {}
impl IIfcDistributionFlowElementType for IfcValveType {}
impl IIfcFlowControllerType for IfcValveType {}
impl IIfcValveType for IfcValveType {
    fn predefined_type(&self) -> &IfcValveTypeEnum {
        &self.predefined_type
    }
}
impl IfcValveType {
    pub fn from_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcValveType::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.global_id = parameter.into(),
                1usize => {
                    entity.owner_history = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => {
                    entity.applicable_occurrence = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                5usize => {
                    entity.has_property_sets = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                6usize => {
                    entity.representation_maps = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                7usize => {
                    entity.tag = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                8usize => {
                    entity.element_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                9usize => entity.predefined_type = parameter.into(),
                _ => {}
            }
        }
        entity
    }
    pub fn from_own_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcValveType::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.predefined_type = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcVector: IIfcGeometricRepresentationItem {
    fn orientation(&self) -> &EntityRef;
    fn magnitude(&self) -> &IfcLengthMeasure;
}
#[derive(Default, Debug)]
pub struct IfcVector {
    orientation: EntityRef,
    magnitude: IfcLengthMeasure,
}
impl IIfcRepresentationItem for IfcVector {}
impl IIfcGeometricRepresentationItem for IfcVector {}
impl IIfcVector for IfcVector {
    fn orientation(&self) -> &EntityRef {
        &self.orientation
    }
    fn magnitude(&self) -> &IfcLengthMeasure {
        &self.magnitude
    }
}
impl IfcVector {
    pub fn from_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcVector::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.orientation = parameter.into(),
                1usize => entity.magnitude = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcVertex: IIfcTopologicalRepresentationItem {}
#[derive(Default, Debug)]
pub struct IfcVertex {}
impl IIfcRepresentationItem for IfcVertex {}
impl IIfcTopologicalRepresentationItem for IfcVertex {}
impl IIfcVertex for IfcVertex {}
impl IfcVertex {
    pub fn from_parameters(_parameters: Vec<Parameter>) -> Self {
        IfcVertex::default()
    }
}
pub trait IIfcVertexLoop: IIfcLoop {
    fn loop_vertex(&self) -> &EntityRef;
}
#[derive(Default, Debug)]
pub struct IfcVertexLoop {
    loop_vertex: EntityRef,
}
impl IIfcRepresentationItem for IfcVertexLoop {}
impl IIfcTopologicalRepresentationItem for IfcVertexLoop {}
impl IIfcLoop for IfcVertexLoop {}
impl IIfcVertexLoop for IfcVertexLoop {
    fn loop_vertex(&self) -> &EntityRef {
        &self.loop_vertex
    }
}
impl IfcVertexLoop {
    pub fn from_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcVertexLoop::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.loop_vertex = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcVertexPoint: IIfcVertex {
    fn vertex_geometry(&self) -> &EntityRef;
}
#[derive(Default, Debug)]
pub struct IfcVertexPoint {
    vertex_geometry: EntityRef,
}
impl IIfcRepresentationItem for IfcVertexPoint {}
impl IIfcTopologicalRepresentationItem for IfcVertexPoint {}
impl IIfcVertex for IfcVertexPoint {}
impl IIfcVertexPoint for IfcVertexPoint {
    fn vertex_geometry(&self) -> &EntityRef {
        &self.vertex_geometry
    }
}
impl IfcVertexPoint {
    pub fn from_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcVertexPoint::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.vertex_geometry = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcVibrationIsolator: IIfcElementComponent {
    fn predefined_type(&self) -> &Option<IfcVibrationIsolatorTypeEnum>;
}
#[derive(Default, Debug)]
pub struct IfcVibrationIsolator {
    global_id: IfcGloballyUniqueId,
    owner_history: Option<EntityRef>,
    name: Option<IfcLabel>,
    description: Option<IfcText>,
    object_type: Option<IfcLabel>,
    object_placement: Option<EntityRef>,
    representation: Option<EntityRef>,
    tag: Option<IfcIdentifier>,
    predefined_type: Option<IfcVibrationIsolatorTypeEnum>,
}
impl IIfcRoot for IfcVibrationIsolator {
    fn global_id(&self) -> &IfcGloballyUniqueId {
        &self.global_id
    }
    fn owner_history(&self) -> &Option<EntityRef> {
        &self.owner_history
    }
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
}
impl IIfcObjectDefinition for IfcVibrationIsolator {}
impl IIfcObject for IfcVibrationIsolator {
    fn object_type(&self) -> &Option<IfcLabel> {
        &self.object_type
    }
}
impl IIfcProduct for IfcVibrationIsolator {
    fn object_placement(&self) -> &Option<EntityRef> {
        &self.object_placement
    }
    fn representation(&self) -> &Option<EntityRef> {
        &self.representation
    }
}
impl IIfcElement for IfcVibrationIsolator {
    fn tag(&self) -> &Option<IfcIdentifier> {
        &self.tag
    }
}
impl IIfcElementComponent for IfcVibrationIsolator {}
impl IIfcVibrationIsolator for IfcVibrationIsolator {
    fn predefined_type(&self) -> &Option<IfcVibrationIsolatorTypeEnum> {
        &self.predefined_type
    }
}
impl IfcVibrationIsolator {
    pub fn from_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcVibrationIsolator::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.global_id = parameter.into(),
                1usize => {
                    entity.owner_history = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => {
                    entity.object_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                5usize => {
                    entity.object_placement = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                6usize => {
                    entity.representation = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                7usize => {
                    entity.tag = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                8usize => {
                    entity.predefined_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
    pub fn from_own_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcVibrationIsolator::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => {
                    entity.predefined_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcVibrationIsolatorType: IIfcElementComponentType {
    fn predefined_type(&self) -> &IfcVibrationIsolatorTypeEnum;
}
#[derive(Default, Debug)]
pub struct IfcVibrationIsolatorType {
    global_id: IfcGloballyUniqueId,
    owner_history: Option<EntityRef>,
    name: Option<IfcLabel>,
    description: Option<IfcText>,
    applicable_occurrence: Option<IfcIdentifier>,
    has_property_sets: Option<HashSet<EntityRef>>,
    representation_maps: Option<Vec<EntityRef>>,
    tag: Option<IfcLabel>,
    element_type: Option<IfcLabel>,
    predefined_type: IfcVibrationIsolatorTypeEnum,
}
impl IIfcRoot for IfcVibrationIsolatorType {
    fn global_id(&self) -> &IfcGloballyUniqueId {
        &self.global_id
    }
    fn owner_history(&self) -> &Option<EntityRef> {
        &self.owner_history
    }
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
}
impl IIfcObjectDefinition for IfcVibrationIsolatorType {}
impl IIfcTypeObject for IfcVibrationIsolatorType {
    fn applicable_occurrence(&self) -> &Option<IfcIdentifier> {
        &self.applicable_occurrence
    }
    fn has_property_sets(&self) -> &Option<HashSet<EntityRef>> {
        &self.has_property_sets
    }
}
impl IIfcTypeProduct for IfcVibrationIsolatorType {
    fn representation_maps(&self) -> &Option<Vec<EntityRef>> {
        &self.representation_maps
    }
    fn tag(&self) -> &Option<IfcLabel> {
        &self.tag
    }
}
impl IIfcElementType for IfcVibrationIsolatorType {
    fn element_type(&self) -> &Option<IfcLabel> {
        &self.element_type
    }
}
impl IIfcElementComponentType for IfcVibrationIsolatorType {}
impl IIfcVibrationIsolatorType for IfcVibrationIsolatorType {
    fn predefined_type(&self) -> &IfcVibrationIsolatorTypeEnum {
        &self.predefined_type
    }
}
impl IfcVibrationIsolatorType {
    pub fn from_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcVibrationIsolatorType::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.global_id = parameter.into(),
                1usize => {
                    entity.owner_history = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => {
                    entity.applicable_occurrence = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                5usize => {
                    entity.has_property_sets = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                6usize => {
                    entity.representation_maps = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                7usize => {
                    entity.tag = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                8usize => {
                    entity.element_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                9usize => entity.predefined_type = parameter.into(),
                _ => {}
            }
        }
        entity
    }
    pub fn from_own_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcVibrationIsolatorType::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.predefined_type = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcVirtualElement: IIfcElement {}
#[derive(Default, Debug)]
pub struct IfcVirtualElement {
    global_id: IfcGloballyUniqueId,
    owner_history: Option<EntityRef>,
    name: Option<IfcLabel>,
    description: Option<IfcText>,
    object_type: Option<IfcLabel>,
    object_placement: Option<EntityRef>,
    representation: Option<EntityRef>,
    tag: Option<IfcIdentifier>,
}
impl IIfcRoot for IfcVirtualElement {
    fn global_id(&self) -> &IfcGloballyUniqueId {
        &self.global_id
    }
    fn owner_history(&self) -> &Option<EntityRef> {
        &self.owner_history
    }
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
}
impl IIfcObjectDefinition for IfcVirtualElement {}
impl IIfcObject for IfcVirtualElement {
    fn object_type(&self) -> &Option<IfcLabel> {
        &self.object_type
    }
}
impl IIfcProduct for IfcVirtualElement {
    fn object_placement(&self) -> &Option<EntityRef> {
        &self.object_placement
    }
    fn representation(&self) -> &Option<EntityRef> {
        &self.representation
    }
}
impl IIfcElement for IfcVirtualElement {
    fn tag(&self) -> &Option<IfcIdentifier> {
        &self.tag
    }
}
impl IIfcVirtualElement for IfcVirtualElement {}
impl IfcVirtualElement {
    pub fn from_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcVirtualElement::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.global_id = parameter.into(),
                1usize => {
                    entity.owner_history = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => {
                    entity.object_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                5usize => {
                    entity.object_placement = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                6usize => {
                    entity.representation = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                7usize => {
                    entity.tag = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcVirtualGridIntersection {
    fn intersecting_axes(&self) -> &Vec<EntityRef>;
    fn offset_distances(&self) -> &Vec<IfcLengthMeasure>;
}
#[derive(Default, Debug)]
pub struct IfcVirtualGridIntersection {
    intersecting_axes: Vec<EntityRef>,
    offset_distances: Vec<IfcLengthMeasure>,
}
impl IIfcVirtualGridIntersection for IfcVirtualGridIntersection {
    fn intersecting_axes(&self) -> &Vec<EntityRef> {
        &self.intersecting_axes
    }
    fn offset_distances(&self) -> &Vec<IfcLengthMeasure> {
        &self.offset_distances
    }
}
impl IfcVirtualGridIntersection {
    pub fn from_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcVirtualGridIntersection::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.intersecting_axes = parameter.into(),
                1usize => entity.offset_distances = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcVoidingFeature: IIfcFeatureElementSubtraction {
    fn predefined_type(&self) -> &Option<IfcVoidingFeatureTypeEnum>;
}
#[derive(Default, Debug)]
pub struct IfcVoidingFeature {
    global_id: IfcGloballyUniqueId,
    owner_history: Option<EntityRef>,
    name: Option<IfcLabel>,
    description: Option<IfcText>,
    object_type: Option<IfcLabel>,
    object_placement: Option<EntityRef>,
    representation: Option<EntityRef>,
    tag: Option<IfcIdentifier>,
    predefined_type: Option<IfcVoidingFeatureTypeEnum>,
}
impl IIfcRoot for IfcVoidingFeature {
    fn global_id(&self) -> &IfcGloballyUniqueId {
        &self.global_id
    }
    fn owner_history(&self) -> &Option<EntityRef> {
        &self.owner_history
    }
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
}
impl IIfcObjectDefinition for IfcVoidingFeature {}
impl IIfcObject for IfcVoidingFeature {
    fn object_type(&self) -> &Option<IfcLabel> {
        &self.object_type
    }
}
impl IIfcProduct for IfcVoidingFeature {
    fn object_placement(&self) -> &Option<EntityRef> {
        &self.object_placement
    }
    fn representation(&self) -> &Option<EntityRef> {
        &self.representation
    }
}
impl IIfcElement for IfcVoidingFeature {
    fn tag(&self) -> &Option<IfcIdentifier> {
        &self.tag
    }
}
impl IIfcFeatureElement for IfcVoidingFeature {}
impl IIfcFeatureElementSubtraction for IfcVoidingFeature {}
impl IIfcVoidingFeature for IfcVoidingFeature {
    fn predefined_type(&self) -> &Option<IfcVoidingFeatureTypeEnum> {
        &self.predefined_type
    }
}
impl IfcVoidingFeature {
    pub fn from_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcVoidingFeature::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.global_id = parameter.into(),
                1usize => {
                    entity.owner_history = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => {
                    entity.object_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                5usize => {
                    entity.object_placement = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                6usize => {
                    entity.representation = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                7usize => {
                    entity.tag = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                8usize => {
                    entity.predefined_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
    pub fn from_own_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcVoidingFeature::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => {
                    entity.predefined_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcWall: IIfcBuildingElement {
    fn predefined_type(&self) -> &Option<IfcWallTypeEnum>;
}
#[derive(Default, Debug)]
pub struct IfcWall {
    global_id: IfcGloballyUniqueId,
    owner_history: Option<EntityRef>,
    name: Option<IfcLabel>,
    description: Option<IfcText>,
    object_type: Option<IfcLabel>,
    object_placement: Option<EntityRef>,
    representation: Option<EntityRef>,
    tag: Option<IfcIdentifier>,
    predefined_type: Option<IfcWallTypeEnum>,
}
impl IIfcRoot for IfcWall {
    fn global_id(&self) -> &IfcGloballyUniqueId {
        &self.global_id
    }
    fn owner_history(&self) -> &Option<EntityRef> {
        &self.owner_history
    }
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
}
impl IIfcObjectDefinition for IfcWall {}
impl IIfcObject for IfcWall {
    fn object_type(&self) -> &Option<IfcLabel> {
        &self.object_type
    }
}
impl IIfcProduct for IfcWall {
    fn object_placement(&self) -> &Option<EntityRef> {
        &self.object_placement
    }
    fn representation(&self) -> &Option<EntityRef> {
        &self.representation
    }
}
impl IIfcElement for IfcWall {
    fn tag(&self) -> &Option<IfcIdentifier> {
        &self.tag
    }
}
impl IIfcBuildingElement for IfcWall {}
impl IIfcWall for IfcWall {
    fn predefined_type(&self) -> &Option<IfcWallTypeEnum> {
        &self.predefined_type
    }
}
impl IfcWall {
    pub fn from_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcWall::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.global_id = parameter.into(),
                1usize => {
                    entity.owner_history = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => {
                    entity.object_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                5usize => {
                    entity.object_placement = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                6usize => {
                    entity.representation = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                7usize => {
                    entity.tag = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                8usize => {
                    entity.predefined_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
    pub fn from_own_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcWall::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => {
                    entity.predefined_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcWallElementedCase: IIfcWall {}
#[derive(Default, Debug)]
pub struct IfcWallElementedCase {
    global_id: IfcGloballyUniqueId,
    owner_history: Option<EntityRef>,
    name: Option<IfcLabel>,
    description: Option<IfcText>,
    object_type: Option<IfcLabel>,
    object_placement: Option<EntityRef>,
    representation: Option<EntityRef>,
    tag: Option<IfcIdentifier>,
    predefined_type: Option<IfcWallTypeEnum>,
}
impl IIfcRoot for IfcWallElementedCase {
    fn global_id(&self) -> &IfcGloballyUniqueId {
        &self.global_id
    }
    fn owner_history(&self) -> &Option<EntityRef> {
        &self.owner_history
    }
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
}
impl IIfcObjectDefinition for IfcWallElementedCase {}
impl IIfcObject for IfcWallElementedCase {
    fn object_type(&self) -> &Option<IfcLabel> {
        &self.object_type
    }
}
impl IIfcProduct for IfcWallElementedCase {
    fn object_placement(&self) -> &Option<EntityRef> {
        &self.object_placement
    }
    fn representation(&self) -> &Option<EntityRef> {
        &self.representation
    }
}
impl IIfcElement for IfcWallElementedCase {
    fn tag(&self) -> &Option<IfcIdentifier> {
        &self.tag
    }
}
impl IIfcBuildingElement for IfcWallElementedCase {}
impl IIfcWall for IfcWallElementedCase {
    fn predefined_type(&self) -> &Option<IfcWallTypeEnum> {
        &self.predefined_type
    }
}
impl IIfcWallElementedCase for IfcWallElementedCase {}
impl IfcWallElementedCase {
    pub fn from_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcWallElementedCase::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.global_id = parameter.into(),
                1usize => {
                    entity.owner_history = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => {
                    entity.object_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                5usize => {
                    entity.object_placement = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                6usize => {
                    entity.representation = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                7usize => {
                    entity.tag = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                8usize => {
                    entity.predefined_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcWallStandardCase: IIfcWall {}
#[derive(Default, Debug)]
pub struct IfcWallStandardCase {
    global_id: IfcGloballyUniqueId,
    owner_history: Option<EntityRef>,
    name: Option<IfcLabel>,
    description: Option<IfcText>,
    object_type: Option<IfcLabel>,
    object_placement: Option<EntityRef>,
    representation: Option<EntityRef>,
    tag: Option<IfcIdentifier>,
    predefined_type: Option<IfcWallTypeEnum>,
}
impl IIfcRoot for IfcWallStandardCase {
    fn global_id(&self) -> &IfcGloballyUniqueId {
        &self.global_id
    }
    fn owner_history(&self) -> &Option<EntityRef> {
        &self.owner_history
    }
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
}
impl IIfcObjectDefinition for IfcWallStandardCase {}
impl IIfcObject for IfcWallStandardCase {
    fn object_type(&self) -> &Option<IfcLabel> {
        &self.object_type
    }
}
impl IIfcProduct for IfcWallStandardCase {
    fn object_placement(&self) -> &Option<EntityRef> {
        &self.object_placement
    }
    fn representation(&self) -> &Option<EntityRef> {
        &self.representation
    }
}
impl IIfcElement for IfcWallStandardCase {
    fn tag(&self) -> &Option<IfcIdentifier> {
        &self.tag
    }
}
impl IIfcBuildingElement for IfcWallStandardCase {}
impl IIfcWall for IfcWallStandardCase {
    fn predefined_type(&self) -> &Option<IfcWallTypeEnum> {
        &self.predefined_type
    }
}
impl IIfcWallStandardCase for IfcWallStandardCase {}
impl IfcWallStandardCase {
    pub fn from_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcWallStandardCase::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.global_id = parameter.into(),
                1usize => {
                    entity.owner_history = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => {
                    entity.object_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                5usize => {
                    entity.object_placement = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                6usize => {
                    entity.representation = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                7usize => {
                    entity.tag = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                8usize => {
                    entity.predefined_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcWallType: IIfcBuildingElementType {
    fn predefined_type(&self) -> &IfcWallTypeEnum;
}
#[derive(Default, Debug)]
pub struct IfcWallType {
    global_id: IfcGloballyUniqueId,
    owner_history: Option<EntityRef>,
    name: Option<IfcLabel>,
    description: Option<IfcText>,
    applicable_occurrence: Option<IfcIdentifier>,
    has_property_sets: Option<HashSet<EntityRef>>,
    representation_maps: Option<Vec<EntityRef>>,
    tag: Option<IfcLabel>,
    element_type: Option<IfcLabel>,
    predefined_type: IfcWallTypeEnum,
}
impl IIfcRoot for IfcWallType {
    fn global_id(&self) -> &IfcGloballyUniqueId {
        &self.global_id
    }
    fn owner_history(&self) -> &Option<EntityRef> {
        &self.owner_history
    }
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
}
impl IIfcObjectDefinition for IfcWallType {}
impl IIfcTypeObject for IfcWallType {
    fn applicable_occurrence(&self) -> &Option<IfcIdentifier> {
        &self.applicable_occurrence
    }
    fn has_property_sets(&self) -> &Option<HashSet<EntityRef>> {
        &self.has_property_sets
    }
}
impl IIfcTypeProduct for IfcWallType {
    fn representation_maps(&self) -> &Option<Vec<EntityRef>> {
        &self.representation_maps
    }
    fn tag(&self) -> &Option<IfcLabel> {
        &self.tag
    }
}
impl IIfcElementType for IfcWallType {
    fn element_type(&self) -> &Option<IfcLabel> {
        &self.element_type
    }
}
impl IIfcBuildingElementType for IfcWallType {}
impl IIfcWallType for IfcWallType {
    fn predefined_type(&self) -> &IfcWallTypeEnum {
        &self.predefined_type
    }
}
impl IfcWallType {
    pub fn from_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcWallType::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.global_id = parameter.into(),
                1usize => {
                    entity.owner_history = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => {
                    entity.applicable_occurrence = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                5usize => {
                    entity.has_property_sets = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                6usize => {
                    entity.representation_maps = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                7usize => {
                    entity.tag = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                8usize => {
                    entity.element_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                9usize => entity.predefined_type = parameter.into(),
                _ => {}
            }
        }
        entity
    }
    pub fn from_own_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcWallType::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.predefined_type = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcWasteTerminal: IIfcFlowTerminal {
    fn predefined_type(&self) -> &Option<IfcWasteTerminalTypeEnum>;
}
#[derive(Default, Debug)]
pub struct IfcWasteTerminal {
    global_id: IfcGloballyUniqueId,
    owner_history: Option<EntityRef>,
    name: Option<IfcLabel>,
    description: Option<IfcText>,
    object_type: Option<IfcLabel>,
    object_placement: Option<EntityRef>,
    representation: Option<EntityRef>,
    tag: Option<IfcIdentifier>,
    predefined_type: Option<IfcWasteTerminalTypeEnum>,
}
impl IIfcRoot for IfcWasteTerminal {
    fn global_id(&self) -> &IfcGloballyUniqueId {
        &self.global_id
    }
    fn owner_history(&self) -> &Option<EntityRef> {
        &self.owner_history
    }
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
}
impl IIfcObjectDefinition for IfcWasteTerminal {}
impl IIfcObject for IfcWasteTerminal {
    fn object_type(&self) -> &Option<IfcLabel> {
        &self.object_type
    }
}
impl IIfcProduct for IfcWasteTerminal {
    fn object_placement(&self) -> &Option<EntityRef> {
        &self.object_placement
    }
    fn representation(&self) -> &Option<EntityRef> {
        &self.representation
    }
}
impl IIfcElement for IfcWasteTerminal {
    fn tag(&self) -> &Option<IfcIdentifier> {
        &self.tag
    }
}
impl IIfcDistributionElement for IfcWasteTerminal {}
impl IIfcDistributionFlowElement for IfcWasteTerminal {}
impl IIfcFlowTerminal for IfcWasteTerminal {}
impl IIfcWasteTerminal for IfcWasteTerminal {
    fn predefined_type(&self) -> &Option<IfcWasteTerminalTypeEnum> {
        &self.predefined_type
    }
}
impl IfcWasteTerminal {
    pub fn from_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcWasteTerminal::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.global_id = parameter.into(),
                1usize => {
                    entity.owner_history = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => {
                    entity.object_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                5usize => {
                    entity.object_placement = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                6usize => {
                    entity.representation = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                7usize => {
                    entity.tag = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                8usize => {
                    entity.predefined_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
    pub fn from_own_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcWasteTerminal::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => {
                    entity.predefined_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcWasteTerminalType: IIfcFlowTerminalType {
    fn predefined_type(&self) -> &IfcWasteTerminalTypeEnum;
}
#[derive(Default, Debug)]
pub struct IfcWasteTerminalType {
    global_id: IfcGloballyUniqueId,
    owner_history: Option<EntityRef>,
    name: Option<IfcLabel>,
    description: Option<IfcText>,
    applicable_occurrence: Option<IfcIdentifier>,
    has_property_sets: Option<HashSet<EntityRef>>,
    representation_maps: Option<Vec<EntityRef>>,
    tag: Option<IfcLabel>,
    element_type: Option<IfcLabel>,
    predefined_type: IfcWasteTerminalTypeEnum,
}
impl IIfcRoot for IfcWasteTerminalType {
    fn global_id(&self) -> &IfcGloballyUniqueId {
        &self.global_id
    }
    fn owner_history(&self) -> &Option<EntityRef> {
        &self.owner_history
    }
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
}
impl IIfcObjectDefinition for IfcWasteTerminalType {}
impl IIfcTypeObject for IfcWasteTerminalType {
    fn applicable_occurrence(&self) -> &Option<IfcIdentifier> {
        &self.applicable_occurrence
    }
    fn has_property_sets(&self) -> &Option<HashSet<EntityRef>> {
        &self.has_property_sets
    }
}
impl IIfcTypeProduct for IfcWasteTerminalType {
    fn representation_maps(&self) -> &Option<Vec<EntityRef>> {
        &self.representation_maps
    }
    fn tag(&self) -> &Option<IfcLabel> {
        &self.tag
    }
}
impl IIfcElementType for IfcWasteTerminalType {
    fn element_type(&self) -> &Option<IfcLabel> {
        &self.element_type
    }
}
impl IIfcDistributionElementType for IfcWasteTerminalType {}
impl IIfcDistributionFlowElementType for IfcWasteTerminalType {}
impl IIfcFlowTerminalType for IfcWasteTerminalType {}
impl IIfcWasteTerminalType for IfcWasteTerminalType {
    fn predefined_type(&self) -> &IfcWasteTerminalTypeEnum {
        &self.predefined_type
    }
}
impl IfcWasteTerminalType {
    pub fn from_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcWasteTerminalType::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.global_id = parameter.into(),
                1usize => {
                    entity.owner_history = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => {
                    entity.applicable_occurrence = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                5usize => {
                    entity.has_property_sets = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                6usize => {
                    entity.representation_maps = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                7usize => {
                    entity.tag = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                8usize => {
                    entity.element_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                9usize => entity.predefined_type = parameter.into(),
                _ => {}
            }
        }
        entity
    }
    pub fn from_own_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcWasteTerminalType::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.predefined_type = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcWindow: IIfcBuildingElement {
    fn overall_height(&self) -> &Option<IfcPositiveLengthMeasure>;
    fn overall_width(&self) -> &Option<IfcPositiveLengthMeasure>;
    fn predefined_type(&self) -> &Option<IfcWindowTypeEnum>;
    fn partitioning_type(&self) -> &Option<IfcWindowTypePartitioningEnum>;
    fn user_defined_partitioning_type(&self) -> &Option<IfcLabel>;
}
#[derive(Default, Debug)]
pub struct IfcWindow {
    global_id: IfcGloballyUniqueId,
    owner_history: Option<EntityRef>,
    name: Option<IfcLabel>,
    description: Option<IfcText>,
    object_type: Option<IfcLabel>,
    object_placement: Option<EntityRef>,
    representation: Option<EntityRef>,
    tag: Option<IfcIdentifier>,
    overall_height: Option<IfcPositiveLengthMeasure>,
    overall_width: Option<IfcPositiveLengthMeasure>,
    predefined_type: Option<IfcWindowTypeEnum>,
    partitioning_type: Option<IfcWindowTypePartitioningEnum>,
    user_defined_partitioning_type: Option<IfcLabel>,
}
impl IIfcRoot for IfcWindow {
    fn global_id(&self) -> &IfcGloballyUniqueId {
        &self.global_id
    }
    fn owner_history(&self) -> &Option<EntityRef> {
        &self.owner_history
    }
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
}
impl IIfcObjectDefinition for IfcWindow {}
impl IIfcObject for IfcWindow {
    fn object_type(&self) -> &Option<IfcLabel> {
        &self.object_type
    }
}
impl IIfcProduct for IfcWindow {
    fn object_placement(&self) -> &Option<EntityRef> {
        &self.object_placement
    }
    fn representation(&self) -> &Option<EntityRef> {
        &self.representation
    }
}
impl IIfcElement for IfcWindow {
    fn tag(&self) -> &Option<IfcIdentifier> {
        &self.tag
    }
}
impl IIfcBuildingElement for IfcWindow {}
impl IIfcWindow for IfcWindow {
    fn overall_height(&self) -> &Option<IfcPositiveLengthMeasure> {
        &self.overall_height
    }
    fn overall_width(&self) -> &Option<IfcPositiveLengthMeasure> {
        &self.overall_width
    }
    fn predefined_type(&self) -> &Option<IfcWindowTypeEnum> {
        &self.predefined_type
    }
    fn partitioning_type(&self) -> &Option<IfcWindowTypePartitioningEnum> {
        &self.partitioning_type
    }
    fn user_defined_partitioning_type(&self) -> &Option<IfcLabel> {
        &self.user_defined_partitioning_type
    }
}
impl IfcWindow {
    pub fn from_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcWindow::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.global_id = parameter.into(),
                1usize => {
                    entity.owner_history = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => {
                    entity.object_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                5usize => {
                    entity.object_placement = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                6usize => {
                    entity.representation = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                7usize => {
                    entity.tag = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                8usize => {
                    entity.overall_height = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                9usize => {
                    entity.overall_width = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                10usize => {
                    entity.predefined_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                11usize => {
                    entity.partitioning_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                12usize => {
                    entity.user_defined_partitioning_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
    pub fn from_own_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcWindow::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => {
                    entity.overall_height = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                1usize => {
                    entity.overall_width = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => {
                    entity.predefined_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.partitioning_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => {
                    entity.user_defined_partitioning_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcWindowLiningProperties: IIfcPreDefinedPropertySet {
    fn lining_depth(&self) -> &Option<IfcPositiveLengthMeasure>;
    fn lining_thickness(&self) -> &Option<IfcNonNegativeLengthMeasure>;
    fn transom_thickness(&self) -> &Option<IfcNonNegativeLengthMeasure>;
    fn mullion_thickness(&self) -> &Option<IfcNonNegativeLengthMeasure>;
    fn first_transom_offset(&self) -> &Option<IfcNormalisedRatioMeasure>;
    fn second_transom_offset(&self) -> &Option<IfcNormalisedRatioMeasure>;
    fn first_mullion_offset(&self) -> &Option<IfcNormalisedRatioMeasure>;
    fn second_mullion_offset(&self) -> &Option<IfcNormalisedRatioMeasure>;
    fn shape_aspect_style(&self) -> &Option<EntityRef>;
    fn lining_offset(&self) -> &Option<IfcLengthMeasure>;
    fn lining_to_panel_offset_x(&self) -> &Option<IfcLengthMeasure>;
    fn lining_to_panel_offset_y(&self) -> &Option<IfcLengthMeasure>;
}
#[derive(Default, Debug)]
pub struct IfcWindowLiningProperties {
    global_id: IfcGloballyUniqueId,
    owner_history: Option<EntityRef>,
    name: Option<IfcLabel>,
    description: Option<IfcText>,
    lining_depth: Option<IfcPositiveLengthMeasure>,
    lining_thickness: Option<IfcNonNegativeLengthMeasure>,
    transom_thickness: Option<IfcNonNegativeLengthMeasure>,
    mullion_thickness: Option<IfcNonNegativeLengthMeasure>,
    first_transom_offset: Option<IfcNormalisedRatioMeasure>,
    second_transom_offset: Option<IfcNormalisedRatioMeasure>,
    first_mullion_offset: Option<IfcNormalisedRatioMeasure>,
    second_mullion_offset: Option<IfcNormalisedRatioMeasure>,
    shape_aspect_style: Option<EntityRef>,
    lining_offset: Option<IfcLengthMeasure>,
    lining_to_panel_offset_x: Option<IfcLengthMeasure>,
    lining_to_panel_offset_y: Option<IfcLengthMeasure>,
}
impl IIfcRoot for IfcWindowLiningProperties {
    fn global_id(&self) -> &IfcGloballyUniqueId {
        &self.global_id
    }
    fn owner_history(&self) -> &Option<EntityRef> {
        &self.owner_history
    }
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
}
impl IIfcPropertyDefinition for IfcWindowLiningProperties {}
impl IIfcPropertySetDefinition for IfcWindowLiningProperties {}
impl IIfcPreDefinedPropertySet for IfcWindowLiningProperties {}
impl IIfcWindowLiningProperties for IfcWindowLiningProperties {
    fn lining_depth(&self) -> &Option<IfcPositiveLengthMeasure> {
        &self.lining_depth
    }
    fn lining_thickness(&self) -> &Option<IfcNonNegativeLengthMeasure> {
        &self.lining_thickness
    }
    fn transom_thickness(&self) -> &Option<IfcNonNegativeLengthMeasure> {
        &self.transom_thickness
    }
    fn mullion_thickness(&self) -> &Option<IfcNonNegativeLengthMeasure> {
        &self.mullion_thickness
    }
    fn first_transom_offset(&self) -> &Option<IfcNormalisedRatioMeasure> {
        &self.first_transom_offset
    }
    fn second_transom_offset(&self) -> &Option<IfcNormalisedRatioMeasure> {
        &self.second_transom_offset
    }
    fn first_mullion_offset(&self) -> &Option<IfcNormalisedRatioMeasure> {
        &self.first_mullion_offset
    }
    fn second_mullion_offset(&self) -> &Option<IfcNormalisedRatioMeasure> {
        &self.second_mullion_offset
    }
    fn shape_aspect_style(&self) -> &Option<EntityRef> {
        &self.shape_aspect_style
    }
    fn lining_offset(&self) -> &Option<IfcLengthMeasure> {
        &self.lining_offset
    }
    fn lining_to_panel_offset_x(&self) -> &Option<IfcLengthMeasure> {
        &self.lining_to_panel_offset_x
    }
    fn lining_to_panel_offset_y(&self) -> &Option<IfcLengthMeasure> {
        &self.lining_to_panel_offset_y
    }
}
impl IfcWindowLiningProperties {
    pub fn from_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcWindowLiningProperties::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.global_id = parameter.into(),
                1usize => {
                    entity.owner_history = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => {
                    entity.lining_depth = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                5usize => {
                    entity.lining_thickness = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                6usize => {
                    entity.transom_thickness = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                7usize => {
                    entity.mullion_thickness = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                8usize => {
                    entity.first_transom_offset = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                9usize => {
                    entity.second_transom_offset = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                10usize => {
                    entity.first_mullion_offset = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                11usize => {
                    entity.second_mullion_offset = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                12usize => {
                    entity.shape_aspect_style = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                13usize => {
                    entity.lining_offset = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                14usize => {
                    entity.lining_to_panel_offset_x = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                15usize => {
                    entity.lining_to_panel_offset_y = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
    pub fn from_own_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcWindowLiningProperties::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => {
                    entity.lining_depth = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                1usize => {
                    entity.lining_thickness = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => {
                    entity.transom_thickness = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.mullion_thickness = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => {
                    entity.first_transom_offset = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                5usize => {
                    entity.second_transom_offset = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                6usize => {
                    entity.first_mullion_offset = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                7usize => {
                    entity.second_mullion_offset = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                8usize => {
                    entity.shape_aspect_style = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                9usize => {
                    entity.lining_offset = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                10usize => {
                    entity.lining_to_panel_offset_x = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                11usize => {
                    entity.lining_to_panel_offset_y = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcWindowPanelProperties: IIfcPreDefinedPropertySet {
    fn operation_type(&self) -> &IfcWindowPanelOperationEnum;
    fn panel_position(&self) -> &IfcWindowPanelPositionEnum;
    fn frame_depth(&self) -> &Option<IfcPositiveLengthMeasure>;
    fn frame_thickness(&self) -> &Option<IfcPositiveLengthMeasure>;
    fn shape_aspect_style(&self) -> &Option<EntityRef>;
}
#[derive(Default, Debug)]
pub struct IfcWindowPanelProperties {
    global_id: IfcGloballyUniqueId,
    owner_history: Option<EntityRef>,
    name: Option<IfcLabel>,
    description: Option<IfcText>,
    operation_type: IfcWindowPanelOperationEnum,
    panel_position: IfcWindowPanelPositionEnum,
    frame_depth: Option<IfcPositiveLengthMeasure>,
    frame_thickness: Option<IfcPositiveLengthMeasure>,
    shape_aspect_style: Option<EntityRef>,
}
impl IIfcRoot for IfcWindowPanelProperties {
    fn global_id(&self) -> &IfcGloballyUniqueId {
        &self.global_id
    }
    fn owner_history(&self) -> &Option<EntityRef> {
        &self.owner_history
    }
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
}
impl IIfcPropertyDefinition for IfcWindowPanelProperties {}
impl IIfcPropertySetDefinition for IfcWindowPanelProperties {}
impl IIfcPreDefinedPropertySet for IfcWindowPanelProperties {}
impl IIfcWindowPanelProperties for IfcWindowPanelProperties {
    fn operation_type(&self) -> &IfcWindowPanelOperationEnum {
        &self.operation_type
    }
    fn panel_position(&self) -> &IfcWindowPanelPositionEnum {
        &self.panel_position
    }
    fn frame_depth(&self) -> &Option<IfcPositiveLengthMeasure> {
        &self.frame_depth
    }
    fn frame_thickness(&self) -> &Option<IfcPositiveLengthMeasure> {
        &self.frame_thickness
    }
    fn shape_aspect_style(&self) -> &Option<EntityRef> {
        &self.shape_aspect_style
    }
}
impl IfcWindowPanelProperties {
    pub fn from_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcWindowPanelProperties::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.global_id = parameter.into(),
                1usize => {
                    entity.owner_history = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => entity.operation_type = parameter.into(),
                5usize => entity.panel_position = parameter.into(),
                6usize => {
                    entity.frame_depth = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                7usize => {
                    entity.frame_thickness = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                8usize => {
                    entity.shape_aspect_style = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
    pub fn from_own_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcWindowPanelProperties::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.operation_type = parameter.into(),
                1usize => entity.panel_position = parameter.into(),
                2usize => {
                    entity.frame_depth = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.frame_thickness = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => {
                    entity.shape_aspect_style = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcWindowStandardCase: IIfcWindow {}
#[derive(Default, Debug)]
pub struct IfcWindowStandardCase {
    global_id: IfcGloballyUniqueId,
    owner_history: Option<EntityRef>,
    name: Option<IfcLabel>,
    description: Option<IfcText>,
    object_type: Option<IfcLabel>,
    object_placement: Option<EntityRef>,
    representation: Option<EntityRef>,
    tag: Option<IfcIdentifier>,
    overall_height: Option<IfcPositiveLengthMeasure>,
    overall_width: Option<IfcPositiveLengthMeasure>,
    predefined_type: Option<IfcWindowTypeEnum>,
    partitioning_type: Option<IfcWindowTypePartitioningEnum>,
    user_defined_partitioning_type: Option<IfcLabel>,
}
impl IIfcRoot for IfcWindowStandardCase {
    fn global_id(&self) -> &IfcGloballyUniqueId {
        &self.global_id
    }
    fn owner_history(&self) -> &Option<EntityRef> {
        &self.owner_history
    }
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
}
impl IIfcObjectDefinition for IfcWindowStandardCase {}
impl IIfcObject for IfcWindowStandardCase {
    fn object_type(&self) -> &Option<IfcLabel> {
        &self.object_type
    }
}
impl IIfcProduct for IfcWindowStandardCase {
    fn object_placement(&self) -> &Option<EntityRef> {
        &self.object_placement
    }
    fn representation(&self) -> &Option<EntityRef> {
        &self.representation
    }
}
impl IIfcElement for IfcWindowStandardCase {
    fn tag(&self) -> &Option<IfcIdentifier> {
        &self.tag
    }
}
impl IIfcBuildingElement for IfcWindowStandardCase {}
impl IIfcWindow for IfcWindowStandardCase {
    fn overall_height(&self) -> &Option<IfcPositiveLengthMeasure> {
        &self.overall_height
    }
    fn overall_width(&self) -> &Option<IfcPositiveLengthMeasure> {
        &self.overall_width
    }
    fn predefined_type(&self) -> &Option<IfcWindowTypeEnum> {
        &self.predefined_type
    }
    fn partitioning_type(&self) -> &Option<IfcWindowTypePartitioningEnum> {
        &self.partitioning_type
    }
    fn user_defined_partitioning_type(&self) -> &Option<IfcLabel> {
        &self.user_defined_partitioning_type
    }
}
impl IIfcWindowStandardCase for IfcWindowStandardCase {}
impl IfcWindowStandardCase {
    pub fn from_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcWindowStandardCase::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.global_id = parameter.into(),
                1usize => {
                    entity.owner_history = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => {
                    entity.object_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                5usize => {
                    entity.object_placement = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                6usize => {
                    entity.representation = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                7usize => {
                    entity.tag = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                8usize => {
                    entity.overall_height = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                9usize => {
                    entity.overall_width = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                10usize => {
                    entity.predefined_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                11usize => {
                    entity.partitioning_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                12usize => {
                    entity.user_defined_partitioning_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcWindowStyle: IIfcTypeProduct {
    fn construction_type(&self) -> &IfcWindowStyleConstructionEnum;
    fn operation_type(&self) -> &IfcWindowStyleOperationEnum;
    fn parameter_takes_precedence(&self) -> &IfcBoolean;
    fn sizeable(&self) -> &IfcBoolean;
}
#[derive(Default, Debug)]
pub struct IfcWindowStyle {
    global_id: IfcGloballyUniqueId,
    owner_history: Option<EntityRef>,
    name: Option<IfcLabel>,
    description: Option<IfcText>,
    applicable_occurrence: Option<IfcIdentifier>,
    has_property_sets: Option<HashSet<EntityRef>>,
    representation_maps: Option<Vec<EntityRef>>,
    tag: Option<IfcLabel>,
    construction_type: IfcWindowStyleConstructionEnum,
    operation_type: IfcWindowStyleOperationEnum,
    parameter_takes_precedence: IfcBoolean,
    sizeable: IfcBoolean,
}
impl IIfcRoot for IfcWindowStyle {
    fn global_id(&self) -> &IfcGloballyUniqueId {
        &self.global_id
    }
    fn owner_history(&self) -> &Option<EntityRef> {
        &self.owner_history
    }
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
}
impl IIfcObjectDefinition for IfcWindowStyle {}
impl IIfcTypeObject for IfcWindowStyle {
    fn applicable_occurrence(&self) -> &Option<IfcIdentifier> {
        &self.applicable_occurrence
    }
    fn has_property_sets(&self) -> &Option<HashSet<EntityRef>> {
        &self.has_property_sets
    }
}
impl IIfcTypeProduct for IfcWindowStyle {
    fn representation_maps(&self) -> &Option<Vec<EntityRef>> {
        &self.representation_maps
    }
    fn tag(&self) -> &Option<IfcLabel> {
        &self.tag
    }
}
impl IIfcWindowStyle for IfcWindowStyle {
    fn construction_type(&self) -> &IfcWindowStyleConstructionEnum {
        &self.construction_type
    }
    fn operation_type(&self) -> &IfcWindowStyleOperationEnum {
        &self.operation_type
    }
    fn parameter_takes_precedence(&self) -> &IfcBoolean {
        &self.parameter_takes_precedence
    }
    fn sizeable(&self) -> &IfcBoolean {
        &self.sizeable
    }
}
impl IfcWindowStyle {
    pub fn from_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcWindowStyle::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.global_id = parameter.into(),
                1usize => {
                    entity.owner_history = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => {
                    entity.applicable_occurrence = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                5usize => {
                    entity.has_property_sets = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                6usize => {
                    entity.representation_maps = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                7usize => {
                    entity.tag = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                8usize => entity.construction_type = parameter.into(),
                9usize => entity.operation_type = parameter.into(),
                10usize => entity.parameter_takes_precedence = parameter.into(),
                11usize => entity.sizeable = parameter.into(),
                _ => {}
            }
        }
        entity
    }
    pub fn from_own_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcWindowStyle::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.construction_type = parameter.into(),
                1usize => entity.operation_type = parameter.into(),
                2usize => entity.parameter_takes_precedence = parameter.into(),
                3usize => entity.sizeable = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcWindowType: IIfcBuildingElementType {
    fn predefined_type(&self) -> &IfcWindowTypeEnum;
    fn partitioning_type(&self) -> &IfcWindowTypePartitioningEnum;
    fn parameter_takes_precedence(&self) -> &Option<IfcBoolean>;
    fn user_defined_partitioning_type(&self) -> &Option<IfcLabel>;
}
#[derive(Default, Debug)]
pub struct IfcWindowType {
    global_id: IfcGloballyUniqueId,
    owner_history: Option<EntityRef>,
    name: Option<IfcLabel>,
    description: Option<IfcText>,
    applicable_occurrence: Option<IfcIdentifier>,
    has_property_sets: Option<HashSet<EntityRef>>,
    representation_maps: Option<Vec<EntityRef>>,
    tag: Option<IfcLabel>,
    element_type: Option<IfcLabel>,
    predefined_type: IfcWindowTypeEnum,
    partitioning_type: IfcWindowTypePartitioningEnum,
    parameter_takes_precedence: Option<IfcBoolean>,
    user_defined_partitioning_type: Option<IfcLabel>,
}
impl IIfcRoot for IfcWindowType {
    fn global_id(&self) -> &IfcGloballyUniqueId {
        &self.global_id
    }
    fn owner_history(&self) -> &Option<EntityRef> {
        &self.owner_history
    }
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
}
impl IIfcObjectDefinition for IfcWindowType {}
impl IIfcTypeObject for IfcWindowType {
    fn applicable_occurrence(&self) -> &Option<IfcIdentifier> {
        &self.applicable_occurrence
    }
    fn has_property_sets(&self) -> &Option<HashSet<EntityRef>> {
        &self.has_property_sets
    }
}
impl IIfcTypeProduct for IfcWindowType {
    fn representation_maps(&self) -> &Option<Vec<EntityRef>> {
        &self.representation_maps
    }
    fn tag(&self) -> &Option<IfcLabel> {
        &self.tag
    }
}
impl IIfcElementType for IfcWindowType {
    fn element_type(&self) -> &Option<IfcLabel> {
        &self.element_type
    }
}
impl IIfcBuildingElementType for IfcWindowType {}
impl IIfcWindowType for IfcWindowType {
    fn predefined_type(&self) -> &IfcWindowTypeEnum {
        &self.predefined_type
    }
    fn partitioning_type(&self) -> &IfcWindowTypePartitioningEnum {
        &self.partitioning_type
    }
    fn parameter_takes_precedence(&self) -> &Option<IfcBoolean> {
        &self.parameter_takes_precedence
    }
    fn user_defined_partitioning_type(&self) -> &Option<IfcLabel> {
        &self.user_defined_partitioning_type
    }
}
impl IfcWindowType {
    pub fn from_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcWindowType::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.global_id = parameter.into(),
                1usize => {
                    entity.owner_history = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => {
                    entity.applicable_occurrence = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                5usize => {
                    entity.has_property_sets = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                6usize => {
                    entity.representation_maps = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                7usize => {
                    entity.tag = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                8usize => {
                    entity.element_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                9usize => entity.predefined_type = parameter.into(),
                10usize => entity.partitioning_type = parameter.into(),
                11usize => {
                    entity.parameter_takes_precedence = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                12usize => {
                    entity.user_defined_partitioning_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
    pub fn from_own_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcWindowType::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.predefined_type = parameter.into(),
                1usize => entity.partitioning_type = parameter.into(),
                2usize => {
                    entity.parameter_takes_precedence = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.user_defined_partitioning_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcWorkCalendar: IIfcControl {
    fn working_times(&self) -> &Option<HashSet<EntityRef>>;
    fn exception_times(&self) -> &Option<HashSet<EntityRef>>;
    fn predefined_type(&self) -> &Option<IfcWorkCalendarTypeEnum>;
}
#[derive(Default, Debug)]
pub struct IfcWorkCalendar {
    global_id: IfcGloballyUniqueId,
    owner_history: Option<EntityRef>,
    name: Option<IfcLabel>,
    description: Option<IfcText>,
    object_type: Option<IfcLabel>,
    identification: Option<IfcIdentifier>,
    working_times: Option<HashSet<EntityRef>>,
    exception_times: Option<HashSet<EntityRef>>,
    predefined_type: Option<IfcWorkCalendarTypeEnum>,
}
impl IIfcRoot for IfcWorkCalendar {
    fn global_id(&self) -> &IfcGloballyUniqueId {
        &self.global_id
    }
    fn owner_history(&self) -> &Option<EntityRef> {
        &self.owner_history
    }
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
}
impl IIfcObjectDefinition for IfcWorkCalendar {}
impl IIfcObject for IfcWorkCalendar {
    fn object_type(&self) -> &Option<IfcLabel> {
        &self.object_type
    }
}
impl IIfcControl for IfcWorkCalendar {
    fn identification(&self) -> &Option<IfcIdentifier> {
        &self.identification
    }
}
impl IIfcWorkCalendar for IfcWorkCalendar {
    fn working_times(&self) -> &Option<HashSet<EntityRef>> {
        &self.working_times
    }
    fn exception_times(&self) -> &Option<HashSet<EntityRef>> {
        &self.exception_times
    }
    fn predefined_type(&self) -> &Option<IfcWorkCalendarTypeEnum> {
        &self.predefined_type
    }
}
impl IfcWorkCalendar {
    pub fn from_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcWorkCalendar::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.global_id = parameter.into(),
                1usize => {
                    entity.owner_history = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => {
                    entity.object_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                5usize => {
                    entity.identification = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                6usize => {
                    entity.working_times = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                7usize => {
                    entity.exception_times = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                8usize => {
                    entity.predefined_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
    pub fn from_own_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcWorkCalendar::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => {
                    entity.working_times = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                1usize => {
                    entity.exception_times = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => {
                    entity.predefined_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcWorkControl: IIfcControl {
    fn creation_date(&self) -> &IfcDateTime;
    fn creators(&self) -> &Option<HashSet<EntityRef>>;
    fn purpose(&self) -> &Option<IfcLabel>;
    fn duration(&self) -> &Option<IfcDuration>;
    fn total_float(&self) -> &Option<IfcDuration>;
    fn start_time(&self) -> &IfcDateTime;
    fn finish_time(&self) -> &Option<IfcDateTime>;
}
pub trait IIfcWorkPlan: IIfcWorkControl {
    fn predefined_type(&self) -> &Option<IfcWorkPlanTypeEnum>;
}
#[derive(Default, Debug)]
pub struct IfcWorkPlan {
    global_id: IfcGloballyUniqueId,
    owner_history: Option<EntityRef>,
    name: Option<IfcLabel>,
    description: Option<IfcText>,
    object_type: Option<IfcLabel>,
    identification: Option<IfcIdentifier>,
    creation_date: IfcDateTime,
    creators: Option<HashSet<EntityRef>>,
    purpose: Option<IfcLabel>,
    duration: Option<IfcDuration>,
    total_float: Option<IfcDuration>,
    start_time: IfcDateTime,
    finish_time: Option<IfcDateTime>,
    predefined_type: Option<IfcWorkPlanTypeEnum>,
}
impl IIfcRoot for IfcWorkPlan {
    fn global_id(&self) -> &IfcGloballyUniqueId {
        &self.global_id
    }
    fn owner_history(&self) -> &Option<EntityRef> {
        &self.owner_history
    }
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
}
impl IIfcObjectDefinition for IfcWorkPlan {}
impl IIfcObject for IfcWorkPlan {
    fn object_type(&self) -> &Option<IfcLabel> {
        &self.object_type
    }
}
impl IIfcControl for IfcWorkPlan {
    fn identification(&self) -> &Option<IfcIdentifier> {
        &self.identification
    }
}
impl IIfcWorkControl for IfcWorkPlan {
    fn creation_date(&self) -> &IfcDateTime {
        &self.creation_date
    }
    fn creators(&self) -> &Option<HashSet<EntityRef>> {
        &self.creators
    }
    fn purpose(&self) -> &Option<IfcLabel> {
        &self.purpose
    }
    fn duration(&self) -> &Option<IfcDuration> {
        &self.duration
    }
    fn total_float(&self) -> &Option<IfcDuration> {
        &self.total_float
    }
    fn start_time(&self) -> &IfcDateTime {
        &self.start_time
    }
    fn finish_time(&self) -> &Option<IfcDateTime> {
        &self.finish_time
    }
}
impl IIfcWorkPlan for IfcWorkPlan {
    fn predefined_type(&self) -> &Option<IfcWorkPlanTypeEnum> {
        &self.predefined_type
    }
}
impl IfcWorkPlan {
    pub fn from_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcWorkPlan::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.global_id = parameter.into(),
                1usize => {
                    entity.owner_history = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => {
                    entity.object_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                5usize => {
                    entity.identification = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                6usize => entity.creation_date = parameter.into(),
                7usize => {
                    entity.creators = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                8usize => {
                    entity.purpose = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                9usize => {
                    entity.duration = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                10usize => {
                    entity.total_float = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                11usize => entity.start_time = parameter.into(),
                12usize => {
                    entity.finish_time = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                13usize => {
                    entity.predefined_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
    pub fn from_own_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcWorkPlan::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => {
                    entity.predefined_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcWorkSchedule: IIfcWorkControl {
    fn predefined_type(&self) -> &Option<IfcWorkScheduleTypeEnum>;
}
#[derive(Default, Debug)]
pub struct IfcWorkSchedule {
    global_id: IfcGloballyUniqueId,
    owner_history: Option<EntityRef>,
    name: Option<IfcLabel>,
    description: Option<IfcText>,
    object_type: Option<IfcLabel>,
    identification: Option<IfcIdentifier>,
    creation_date: IfcDateTime,
    creators: Option<HashSet<EntityRef>>,
    purpose: Option<IfcLabel>,
    duration: Option<IfcDuration>,
    total_float: Option<IfcDuration>,
    start_time: IfcDateTime,
    finish_time: Option<IfcDateTime>,
    predefined_type: Option<IfcWorkScheduleTypeEnum>,
}
impl IIfcRoot for IfcWorkSchedule {
    fn global_id(&self) -> &IfcGloballyUniqueId {
        &self.global_id
    }
    fn owner_history(&self) -> &Option<EntityRef> {
        &self.owner_history
    }
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
}
impl IIfcObjectDefinition for IfcWorkSchedule {}
impl IIfcObject for IfcWorkSchedule {
    fn object_type(&self) -> &Option<IfcLabel> {
        &self.object_type
    }
}
impl IIfcControl for IfcWorkSchedule {
    fn identification(&self) -> &Option<IfcIdentifier> {
        &self.identification
    }
}
impl IIfcWorkControl for IfcWorkSchedule {
    fn creation_date(&self) -> &IfcDateTime {
        &self.creation_date
    }
    fn creators(&self) -> &Option<HashSet<EntityRef>> {
        &self.creators
    }
    fn purpose(&self) -> &Option<IfcLabel> {
        &self.purpose
    }
    fn duration(&self) -> &Option<IfcDuration> {
        &self.duration
    }
    fn total_float(&self) -> &Option<IfcDuration> {
        &self.total_float
    }
    fn start_time(&self) -> &IfcDateTime {
        &self.start_time
    }
    fn finish_time(&self) -> &Option<IfcDateTime> {
        &self.finish_time
    }
}
impl IIfcWorkSchedule for IfcWorkSchedule {
    fn predefined_type(&self) -> &Option<IfcWorkScheduleTypeEnum> {
        &self.predefined_type
    }
}
impl IfcWorkSchedule {
    pub fn from_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcWorkSchedule::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.global_id = parameter.into(),
                1usize => {
                    entity.owner_history = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => {
                    entity.object_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                5usize => {
                    entity.identification = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                6usize => entity.creation_date = parameter.into(),
                7usize => {
                    entity.creators = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                8usize => {
                    entity.purpose = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                9usize => {
                    entity.duration = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                10usize => {
                    entity.total_float = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                11usize => entity.start_time = parameter.into(),
                12usize => {
                    entity.finish_time = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                13usize => {
                    entity.predefined_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
    pub fn from_own_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcWorkSchedule::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => {
                    entity.predefined_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcWorkTime: IIfcSchedulingTime {
    fn recurrence_pattern(&self) -> &Option<EntityRef>;
    fn start(&self) -> &Option<IfcDate>;
    fn finish(&self) -> &Option<IfcDate>;
}
#[derive(Default, Debug)]
pub struct IfcWorkTime {
    name: Option<IfcLabel>,
    data_origin: Option<IfcDataOriginEnum>,
    user_defined_data_origin: Option<IfcLabel>,
    recurrence_pattern: Option<EntityRef>,
    start: Option<IfcDate>,
    finish: Option<IfcDate>,
}
impl IIfcSchedulingTime for IfcWorkTime {
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
    fn data_origin(&self) -> &Option<IfcDataOriginEnum> {
        &self.data_origin
    }
    fn user_defined_data_origin(&self) -> &Option<IfcLabel> {
        &self.user_defined_data_origin
    }
}
impl IIfcWorkTime for IfcWorkTime {
    fn recurrence_pattern(&self) -> &Option<EntityRef> {
        &self.recurrence_pattern
    }
    fn start(&self) -> &Option<IfcDate> {
        &self.start
    }
    fn finish(&self) -> &Option<IfcDate> {
        &self.finish
    }
}
impl IfcWorkTime {
    pub fn from_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcWorkTime::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                1usize => {
                    entity.data_origin = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => {
                    entity.user_defined_data_origin = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.recurrence_pattern = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => {
                    entity.start = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                5usize => {
                    entity.finish = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
    pub fn from_own_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcWorkTime::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => {
                    entity.recurrence_pattern = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                1usize => {
                    entity.start = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => {
                    entity.finish = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcZShapeProfileDef: IIfcParameterizedProfileDef {
    fn depth(&self) -> &IfcPositiveLengthMeasure;
    fn flange_width(&self) -> &IfcPositiveLengthMeasure;
    fn web_thickness(&self) -> &IfcPositiveLengthMeasure;
    fn flange_thickness(&self) -> &IfcPositiveLengthMeasure;
    fn fillet_radius(&self) -> &Option<IfcNonNegativeLengthMeasure>;
    fn edge_radius(&self) -> &Option<IfcNonNegativeLengthMeasure>;
}
#[derive(Default, Debug)]
pub struct IfcZShapeProfileDef {
    profile_type: IfcProfileTypeEnum,
    profile_name: Option<IfcLabel>,
    position: Option<EntityRef>,
    depth: IfcPositiveLengthMeasure,
    flange_width: IfcPositiveLengthMeasure,
    web_thickness: IfcPositiveLengthMeasure,
    flange_thickness: IfcPositiveLengthMeasure,
    fillet_radius: Option<IfcNonNegativeLengthMeasure>,
    edge_radius: Option<IfcNonNegativeLengthMeasure>,
}
impl IIfcProfileDef for IfcZShapeProfileDef {
    fn profile_type(&self) -> &IfcProfileTypeEnum {
        &self.profile_type
    }
    fn profile_name(&self) -> &Option<IfcLabel> {
        &self.profile_name
    }
}
impl IIfcParameterizedProfileDef for IfcZShapeProfileDef {
    fn position(&self) -> &Option<EntityRef> {
        &self.position
    }
}
impl IIfcZShapeProfileDef for IfcZShapeProfileDef {
    fn depth(&self) -> &IfcPositiveLengthMeasure {
        &self.depth
    }
    fn flange_width(&self) -> &IfcPositiveLengthMeasure {
        &self.flange_width
    }
    fn web_thickness(&self) -> &IfcPositiveLengthMeasure {
        &self.web_thickness
    }
    fn flange_thickness(&self) -> &IfcPositiveLengthMeasure {
        &self.flange_thickness
    }
    fn fillet_radius(&self) -> &Option<IfcNonNegativeLengthMeasure> {
        &self.fillet_radius
    }
    fn edge_radius(&self) -> &Option<IfcNonNegativeLengthMeasure> {
        &self.edge_radius
    }
}
impl IfcZShapeProfileDef {
    pub fn from_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcZShapeProfileDef::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.profile_type = parameter.into(),
                1usize => {
                    entity.profile_name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => {
                    entity.position = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => entity.depth = parameter.into(),
                4usize => entity.flange_width = parameter.into(),
                5usize => entity.web_thickness = parameter.into(),
                6usize => entity.flange_thickness = parameter.into(),
                7usize => {
                    entity.fillet_radius = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                8usize => {
                    entity.edge_radius = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
    pub fn from_own_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcZShapeProfileDef::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.depth = parameter.into(),
                1usize => entity.flange_width = parameter.into(),
                2usize => entity.web_thickness = parameter.into(),
                3usize => entity.flange_thickness = parameter.into(),
                4usize => {
                    entity.fillet_radius = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                5usize => {
                    entity.edge_radius = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcZone: IIfcSystem {
    fn long_name(&self) -> &Option<IfcLabel>;
}
#[derive(Default, Debug)]
pub struct IfcZone {
    global_id: IfcGloballyUniqueId,
    owner_history: Option<EntityRef>,
    name: Option<IfcLabel>,
    description: Option<IfcText>,
    object_type: Option<IfcLabel>,
    long_name: Option<IfcLabel>,
}
impl IIfcRoot for IfcZone {
    fn global_id(&self) -> &IfcGloballyUniqueId {
        &self.global_id
    }
    fn owner_history(&self) -> &Option<EntityRef> {
        &self.owner_history
    }
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
}
impl IIfcObjectDefinition for IfcZone {}
impl IIfcObject for IfcZone {
    fn object_type(&self) -> &Option<IfcLabel> {
        &self.object_type
    }
}
impl IIfcGroup for IfcZone {}
impl IIfcSystem for IfcZone {}
impl IIfcZone for IfcZone {
    fn long_name(&self) -> &Option<IfcLabel> {
        &self.long_name
    }
}
impl IfcZone {
    pub fn from_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcZone::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.global_id = parameter.into(),
                1usize => {
                    entity.owner_history = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => {
                    entity.object_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                5usize => {
                    entity.long_name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
    pub fn from_own_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcZone::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => {
                    entity.long_name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
}
use std::any::{Any, TypeId};
use std::collections::{BTreeMap, HashMap};
pub struct Ifc4Reader {
    pub entities: BTreeMap<i64, Box<dyn Any>>,
    pub type_ids: HashMap<TypeId, Vec<i64>>,
    pub type_names: HashMap<TypeId, &'static str>,
    empty: Vec<i64>,
}
impl Ifc4Reader {
    pub fn new() -> Self {
        Ifc4Reader {
            entities: BTreeMap::new(),
            type_ids: HashMap::new(),
            type_names: HashMap::new(),
            empty: Vec::new(),
        }
    }
    pub fn add_entity<T: Any>(&mut self, id: i64, entity: T) {
        let type_id = entity.type_id();
        self.entities.insert(id, Box::new(entity));
        self.type_ids.entry(type_id).or_insert(vec![]).push(id);
        self.type_names.entry(type_id).or_insert(std::any::type_name::<T>());
    }
    pub fn get_entity<T: Any>(&self, entity_ref: &EntityRef) -> Option<&T> {
        self.entities
            .get(&entity_ref.0)
            .map(|entity| entity.downcast_ref::<T>())
            .flatten()
    }
    pub fn get_entities<T: Any>(&self) -> impl Iterator<Item = (i64, &T)> {
        let type_id = TypeId::of::<T>();
        self.type_ids
            .get(&type_id)
            .unwrap_or(&self.empty)
            .iter()
            .map(move |id| (*id, self.entities[id].downcast_ref::<T>().unwrap()))
    }
    pub fn get_type_name(&self, id: i64) -> &'static str {
        let type_id = (*self.entities[&id]).type_id();
        self.type_names[&type_id]
    }
}
impl StepReader for Ifc4Reader {
    fn insert_entity(&mut self, id: i64, type_id: TypeId, type_name: &'static str, entity: Box<dyn Any>) {
        self.entities.insert(id, entity);
        self.type_ids.entry(type_id).or_insert(vec![]).push(id);
        self.type_names.entry(type_id).or_insert(type_name);
    }
    fn create_simple_entity(
        &self,
        typed_parameter: TypedParameter,
        own_parameters_only: bool,
    ) -> Option<(TypeId, &'static str, Box<dyn Any>)> {
        match typed_parameter.type_name.as_str() {
            "IFCACTIONREQUEST" => {
                let entity = if own_parameters_only {
                    IfcActionRequest::from_own_parameters(typed_parameter.parameters)
                } else {
                    IfcActionRequest::from_parameters(typed_parameter.parameters)
                };
                Some((
                    entity.type_id(),
                    std::any::type_name::<IfcActionRequest>(),
                    Box::new(entity),
                ))
            }
            "IFCACTOR" => {
                let entity = if own_parameters_only {
                    IfcActor::from_own_parameters(typed_parameter.parameters)
                } else {
                    IfcActor::from_parameters(typed_parameter.parameters)
                };
                Some((entity.type_id(), std::any::type_name::<IfcActor>(), Box::new(entity)))
            }
            "IFCACTORROLE" => {
                let entity = IfcActorRole::from_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<IfcActorRole>(),
                    Box::new(entity),
                ))
            }
            "IFCACTUATOR" => {
                let entity = if own_parameters_only {
                    IfcActuator::from_own_parameters(typed_parameter.parameters)
                } else {
                    IfcActuator::from_parameters(typed_parameter.parameters)
                };
                Some((entity.type_id(), std::any::type_name::<IfcActuator>(), Box::new(entity)))
            }
            "IFCACTUATORTYPE" => {
                let entity = if own_parameters_only {
                    IfcActuatorType::from_own_parameters(typed_parameter.parameters)
                } else {
                    IfcActuatorType::from_parameters(typed_parameter.parameters)
                };
                Some((
                    entity.type_id(),
                    std::any::type_name::<IfcActuatorType>(),
                    Box::new(entity),
                ))
            }
            "IFCADVANCEDBREP" => {
                let entity = IfcAdvancedBrep::from_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<IfcAdvancedBrep>(),
                    Box::new(entity),
                ))
            }
            "IFCADVANCEDBREPWITHVOIDS" => {
                let entity = if own_parameters_only {
                    IfcAdvancedBrepWithVoids::from_own_parameters(typed_parameter.parameters)
                } else {
                    IfcAdvancedBrepWithVoids::from_parameters(typed_parameter.parameters)
                };
                Some((
                    entity.type_id(),
                    std::any::type_name::<IfcAdvancedBrepWithVoids>(),
                    Box::new(entity),
                ))
            }
            "IFCADVANCEDFACE" => {
                let entity = IfcAdvancedFace::from_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<IfcAdvancedFace>(),
                    Box::new(entity),
                ))
            }
            "IFCAIRTERMINAL" => {
                let entity = if own_parameters_only {
                    IfcAirTerminal::from_own_parameters(typed_parameter.parameters)
                } else {
                    IfcAirTerminal::from_parameters(typed_parameter.parameters)
                };
                Some((
                    entity.type_id(),
                    std::any::type_name::<IfcAirTerminal>(),
                    Box::new(entity),
                ))
            }
            "IFCAIRTERMINALBOX" => {
                let entity = if own_parameters_only {
                    IfcAirTerminalBox::from_own_parameters(typed_parameter.parameters)
                } else {
                    IfcAirTerminalBox::from_parameters(typed_parameter.parameters)
                };
                Some((
                    entity.type_id(),
                    std::any::type_name::<IfcAirTerminalBox>(),
                    Box::new(entity),
                ))
            }
            "IFCAIRTERMINALBOXTYPE" => {
                let entity = if own_parameters_only {
                    IfcAirTerminalBoxType::from_own_parameters(typed_parameter.parameters)
                } else {
                    IfcAirTerminalBoxType::from_parameters(typed_parameter.parameters)
                };
                Some((
                    entity.type_id(),
                    std::any::type_name::<IfcAirTerminalBoxType>(),
                    Box::new(entity),
                ))
            }
            "IFCAIRTERMINALTYPE" => {
                let entity = if own_parameters_only {
                    IfcAirTerminalType::from_own_parameters(typed_parameter.parameters)
                } else {
                    IfcAirTerminalType::from_parameters(typed_parameter.parameters)
                };
                Some((
                    entity.type_id(),
                    std::any::type_name::<IfcAirTerminalType>(),
                    Box::new(entity),
                ))
            }
            "IFCAIRTOAIRHEATRECOVERY" => {
                let entity = if own_parameters_only {
                    IfcAirToAirHeatRecovery::from_own_parameters(typed_parameter.parameters)
                } else {
                    IfcAirToAirHeatRecovery::from_parameters(typed_parameter.parameters)
                };
                Some((
                    entity.type_id(),
                    std::any::type_name::<IfcAirToAirHeatRecovery>(),
                    Box::new(entity),
                ))
            }
            "IFCAIRTOAIRHEATRECOVERYTYPE" => {
                let entity = if own_parameters_only {
                    IfcAirToAirHeatRecoveryType::from_own_parameters(typed_parameter.parameters)
                } else {
                    IfcAirToAirHeatRecoveryType::from_parameters(typed_parameter.parameters)
                };
                Some((
                    entity.type_id(),
                    std::any::type_name::<IfcAirToAirHeatRecoveryType>(),
                    Box::new(entity),
                ))
            }
            "IFCALARM" => {
                let entity = if own_parameters_only {
                    IfcAlarm::from_own_parameters(typed_parameter.parameters)
                } else {
                    IfcAlarm::from_parameters(typed_parameter.parameters)
                };
                Some((entity.type_id(), std::any::type_name::<IfcAlarm>(), Box::new(entity)))
            }
            "IFCALARMTYPE" => {
                let entity = if own_parameters_only {
                    IfcAlarmType::from_own_parameters(typed_parameter.parameters)
                } else {
                    IfcAlarmType::from_parameters(typed_parameter.parameters)
                };
                Some((
                    entity.type_id(),
                    std::any::type_name::<IfcAlarmType>(),
                    Box::new(entity),
                ))
            }
            "IFCANNOTATION" => {
                let entity = IfcAnnotation::from_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<IfcAnnotation>(),
                    Box::new(entity),
                ))
            }
            "IFCANNOTATIONFILLAREA" => {
                let entity = IfcAnnotationFillArea::from_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<IfcAnnotationFillArea>(),
                    Box::new(entity),
                ))
            }
            "IFCAPPLICATION" => {
                let entity = IfcApplication::from_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<IfcApplication>(),
                    Box::new(entity),
                ))
            }
            "IFCAPPLIEDVALUE" => {
                let entity = IfcAppliedValue::from_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<IfcAppliedValue>(),
                    Box::new(entity),
                ))
            }
            "IFCAPPROVAL" => {
                let entity = IfcApproval::from_parameters(typed_parameter.parameters);
                Some((entity.type_id(), std::any::type_name::<IfcApproval>(), Box::new(entity)))
            }
            "IFCAPPROVALRELATIONSHIP" => {
                let entity = if own_parameters_only {
                    IfcApprovalRelationship::from_own_parameters(typed_parameter.parameters)
                } else {
                    IfcApprovalRelationship::from_parameters(typed_parameter.parameters)
                };
                Some((
                    entity.type_id(),
                    std::any::type_name::<IfcApprovalRelationship>(),
                    Box::new(entity),
                ))
            }
            "IFCARBITRARYCLOSEDPROFILEDEF" => {
                let entity = if own_parameters_only {
                    IfcArbitraryClosedProfileDef::from_own_parameters(typed_parameter.parameters)
                } else {
                    IfcArbitraryClosedProfileDef::from_parameters(typed_parameter.parameters)
                };
                Some((
                    entity.type_id(),
                    std::any::type_name::<IfcArbitraryClosedProfileDef>(),
                    Box::new(entity),
                ))
            }
            "IFCARBITRARYOPENPROFILEDEF" => {
                let entity = if own_parameters_only {
                    IfcArbitraryOpenProfileDef::from_own_parameters(typed_parameter.parameters)
                } else {
                    IfcArbitraryOpenProfileDef::from_parameters(typed_parameter.parameters)
                };
                Some((
                    entity.type_id(),
                    std::any::type_name::<IfcArbitraryOpenProfileDef>(),
                    Box::new(entity),
                ))
            }
            "IFCARBITRARYPROFILEDEFWITHVOIDS" => {
                let entity = if own_parameters_only {
                    IfcArbitraryProfileDefWithVoids::from_own_parameters(typed_parameter.parameters)
                } else {
                    IfcArbitraryProfileDefWithVoids::from_parameters(typed_parameter.parameters)
                };
                Some((
                    entity.type_id(),
                    std::any::type_name::<IfcArbitraryProfileDefWithVoids>(),
                    Box::new(entity),
                ))
            }
            "IFCASSET" => {
                let entity = if own_parameters_only {
                    IfcAsset::from_own_parameters(typed_parameter.parameters)
                } else {
                    IfcAsset::from_parameters(typed_parameter.parameters)
                };
                Some((entity.type_id(), std::any::type_name::<IfcAsset>(), Box::new(entity)))
            }
            "IFCASYMMETRICISHAPEPROFILEDEF" => {
                let entity = if own_parameters_only {
                    IfcAsymmetricIShapeProfileDef::from_own_parameters(typed_parameter.parameters)
                } else {
                    IfcAsymmetricIShapeProfileDef::from_parameters(typed_parameter.parameters)
                };
                Some((
                    entity.type_id(),
                    std::any::type_name::<IfcAsymmetricIShapeProfileDef>(),
                    Box::new(entity),
                ))
            }
            "IFCAUDIOVISUALAPPLIANCE" => {
                let entity = if own_parameters_only {
                    IfcAudioVisualAppliance::from_own_parameters(typed_parameter.parameters)
                } else {
                    IfcAudioVisualAppliance::from_parameters(typed_parameter.parameters)
                };
                Some((
                    entity.type_id(),
                    std::any::type_name::<IfcAudioVisualAppliance>(),
                    Box::new(entity),
                ))
            }
            "IFCAUDIOVISUALAPPLIANCETYPE" => {
                let entity = if own_parameters_only {
                    IfcAudioVisualApplianceType::from_own_parameters(typed_parameter.parameters)
                } else {
                    IfcAudioVisualApplianceType::from_parameters(typed_parameter.parameters)
                };
                Some((
                    entity.type_id(),
                    std::any::type_name::<IfcAudioVisualApplianceType>(),
                    Box::new(entity),
                ))
            }
            "IFCAXIS1PLACEMENT" => {
                let entity = if own_parameters_only {
                    IfcAxis1Placement::from_own_parameters(typed_parameter.parameters)
                } else {
                    IfcAxis1Placement::from_parameters(typed_parameter.parameters)
                };
                Some((
                    entity.type_id(),
                    std::any::type_name::<IfcAxis1Placement>(),
                    Box::new(entity),
                ))
            }
            "IFCAXIS2PLACEMENT2D" => {
                let entity = if own_parameters_only {
                    IfcAxis2Placement2D::from_own_parameters(typed_parameter.parameters)
                } else {
                    IfcAxis2Placement2D::from_parameters(typed_parameter.parameters)
                };
                Some((
                    entity.type_id(),
                    std::any::type_name::<IfcAxis2Placement2D>(),
                    Box::new(entity),
                ))
            }
            "IFCAXIS2PLACEMENT3D" => {
                let entity = if own_parameters_only {
                    IfcAxis2Placement3D::from_own_parameters(typed_parameter.parameters)
                } else {
                    IfcAxis2Placement3D::from_parameters(typed_parameter.parameters)
                };
                Some((
                    entity.type_id(),
                    std::any::type_name::<IfcAxis2Placement3D>(),
                    Box::new(entity),
                ))
            }
            "IFCBSPLINECURVEWITHKNOTS" => {
                let entity = if own_parameters_only {
                    IfcBSplineCurveWithKnots::from_own_parameters(typed_parameter.parameters)
                } else {
                    IfcBSplineCurveWithKnots::from_parameters(typed_parameter.parameters)
                };
                Some((
                    entity.type_id(),
                    std::any::type_name::<IfcBSplineCurveWithKnots>(),
                    Box::new(entity),
                ))
            }
            "IFCBSPLINESURFACEWITHKNOTS" => {
                let entity = if own_parameters_only {
                    IfcBSplineSurfaceWithKnots::from_own_parameters(typed_parameter.parameters)
                } else {
                    IfcBSplineSurfaceWithKnots::from_parameters(typed_parameter.parameters)
                };
                Some((
                    entity.type_id(),
                    std::any::type_name::<IfcBSplineSurfaceWithKnots>(),
                    Box::new(entity),
                ))
            }
            "IFCBEAM" => {
                let entity = if own_parameters_only {
                    IfcBeam::from_own_parameters(typed_parameter.parameters)
                } else {
                    IfcBeam::from_parameters(typed_parameter.parameters)
                };
                Some((entity.type_id(), std::any::type_name::<IfcBeam>(), Box::new(entity)))
            }
            "IFCBEAMSTANDARDCASE" => {
                let entity = IfcBeamStandardCase::from_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<IfcBeamStandardCase>(),
                    Box::new(entity),
                ))
            }
            "IFCBEAMTYPE" => {
                let entity = if own_parameters_only {
                    IfcBeamType::from_own_parameters(typed_parameter.parameters)
                } else {
                    IfcBeamType::from_parameters(typed_parameter.parameters)
                };
                Some((entity.type_id(), std::any::type_name::<IfcBeamType>(), Box::new(entity)))
            }
            "IFCBLOBTEXTURE" => {
                let entity = if own_parameters_only {
                    IfcBlobTexture::from_own_parameters(typed_parameter.parameters)
                } else {
                    IfcBlobTexture::from_parameters(typed_parameter.parameters)
                };
                Some((
                    entity.type_id(),
                    std::any::type_name::<IfcBlobTexture>(),
                    Box::new(entity),
                ))
            }
            "IFCBLOCK" => {
                let entity = if own_parameters_only {
                    IfcBlock::from_own_parameters(typed_parameter.parameters)
                } else {
                    IfcBlock::from_parameters(typed_parameter.parameters)
                };
                Some((entity.type_id(), std::any::type_name::<IfcBlock>(), Box::new(entity)))
            }
            "IFCBOILER" => {
                let entity = if own_parameters_only {
                    IfcBoiler::from_own_parameters(typed_parameter.parameters)
                } else {
                    IfcBoiler::from_parameters(typed_parameter.parameters)
                };
                Some((entity.type_id(), std::any::type_name::<IfcBoiler>(), Box::new(entity)))
            }
            "IFCBOILERTYPE" => {
                let entity = if own_parameters_only {
                    IfcBoilerType::from_own_parameters(typed_parameter.parameters)
                } else {
                    IfcBoilerType::from_parameters(typed_parameter.parameters)
                };
                Some((
                    entity.type_id(),
                    std::any::type_name::<IfcBoilerType>(),
                    Box::new(entity),
                ))
            }
            "IFCBOOLEANCLIPPINGRESULT" => {
                let entity = IfcBooleanClippingResult::from_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<IfcBooleanClippingResult>(),
                    Box::new(entity),
                ))
            }
            "IFCBOOLEANRESULT" => {
                let entity = IfcBooleanResult::from_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<IfcBooleanResult>(),
                    Box::new(entity),
                ))
            }
            "IFCBOUNDARYCURVE" => {
                let entity = IfcBoundaryCurve::from_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<IfcBoundaryCurve>(),
                    Box::new(entity),
                ))
            }
            "IFCBOUNDARYEDGECONDITION" => {
                let entity = if own_parameters_only {
                    IfcBoundaryEdgeCondition::from_own_parameters(typed_parameter.parameters)
                } else {
                    IfcBoundaryEdgeCondition::from_parameters(typed_parameter.parameters)
                };
                Some((
                    entity.type_id(),
                    std::any::type_name::<IfcBoundaryEdgeCondition>(),
                    Box::new(entity),
                ))
            }
            "IFCBOUNDARYFACECONDITION" => {
                let entity = if own_parameters_only {
                    IfcBoundaryFaceCondition::from_own_parameters(typed_parameter.parameters)
                } else {
                    IfcBoundaryFaceCondition::from_parameters(typed_parameter.parameters)
                };
                Some((
                    entity.type_id(),
                    std::any::type_name::<IfcBoundaryFaceCondition>(),
                    Box::new(entity),
                ))
            }
            "IFCBOUNDARYNODECONDITION" => {
                let entity = if own_parameters_only {
                    IfcBoundaryNodeCondition::from_own_parameters(typed_parameter.parameters)
                } else {
                    IfcBoundaryNodeCondition::from_parameters(typed_parameter.parameters)
                };
                Some((
                    entity.type_id(),
                    std::any::type_name::<IfcBoundaryNodeCondition>(),
                    Box::new(entity),
                ))
            }
            "IFCBOUNDARYNODECONDITIONWARPING" => {
                let entity = if own_parameters_only {
                    IfcBoundaryNodeConditionWarping::from_own_parameters(typed_parameter.parameters)
                } else {
                    IfcBoundaryNodeConditionWarping::from_parameters(typed_parameter.parameters)
                };
                Some((
                    entity.type_id(),
                    std::any::type_name::<IfcBoundaryNodeConditionWarping>(),
                    Box::new(entity),
                ))
            }
            "IFCBOUNDINGBOX" => {
                let entity = IfcBoundingBox::from_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<IfcBoundingBox>(),
                    Box::new(entity),
                ))
            }
            "IFCBOXEDHALFSPACE" => {
                let entity = if own_parameters_only {
                    IfcBoxedHalfSpace::from_own_parameters(typed_parameter.parameters)
                } else {
                    IfcBoxedHalfSpace::from_parameters(typed_parameter.parameters)
                };
                Some((
                    entity.type_id(),
                    std::any::type_name::<IfcBoxedHalfSpace>(),
                    Box::new(entity),
                ))
            }
            "IFCBUILDING" => {
                let entity = if own_parameters_only {
                    IfcBuilding::from_own_parameters(typed_parameter.parameters)
                } else {
                    IfcBuilding::from_parameters(typed_parameter.parameters)
                };
                Some((entity.type_id(), std::any::type_name::<IfcBuilding>(), Box::new(entity)))
            }
            "IFCBUILDINGELEMENTPART" => {
                let entity = if own_parameters_only {
                    IfcBuildingElementPart::from_own_parameters(typed_parameter.parameters)
                } else {
                    IfcBuildingElementPart::from_parameters(typed_parameter.parameters)
                };
                Some((
                    entity.type_id(),
                    std::any::type_name::<IfcBuildingElementPart>(),
                    Box::new(entity),
                ))
            }
            "IFCBUILDINGELEMENTPARTTYPE" => {
                let entity = if own_parameters_only {
                    IfcBuildingElementPartType::from_own_parameters(typed_parameter.parameters)
                } else {
                    IfcBuildingElementPartType::from_parameters(typed_parameter.parameters)
                };
                Some((
                    entity.type_id(),
                    std::any::type_name::<IfcBuildingElementPartType>(),
                    Box::new(entity),
                ))
            }
            "IFCBUILDINGELEMENTPROXY" => {
                let entity = if own_parameters_only {
                    IfcBuildingElementProxy::from_own_parameters(typed_parameter.parameters)
                } else {
                    IfcBuildingElementProxy::from_parameters(typed_parameter.parameters)
                };
                Some((
                    entity.type_id(),
                    std::any::type_name::<IfcBuildingElementProxy>(),
                    Box::new(entity),
                ))
            }
            "IFCBUILDINGELEMENTPROXYTYPE" => {
                let entity = if own_parameters_only {
                    IfcBuildingElementProxyType::from_own_parameters(typed_parameter.parameters)
                } else {
                    IfcBuildingElementProxyType::from_parameters(typed_parameter.parameters)
                };
                Some((
                    entity.type_id(),
                    std::any::type_name::<IfcBuildingElementProxyType>(),
                    Box::new(entity),
                ))
            }
            "IFCBUILDINGSTOREY" => {
                let entity = if own_parameters_only {
                    IfcBuildingStorey::from_own_parameters(typed_parameter.parameters)
                } else {
                    IfcBuildingStorey::from_parameters(typed_parameter.parameters)
                };
                Some((
                    entity.type_id(),
                    std::any::type_name::<IfcBuildingStorey>(),
                    Box::new(entity),
                ))
            }
            "IFCBUILDINGSYSTEM" => {
                let entity = if own_parameters_only {
                    IfcBuildingSystem::from_own_parameters(typed_parameter.parameters)
                } else {
                    IfcBuildingSystem::from_parameters(typed_parameter.parameters)
                };
                Some((
                    entity.type_id(),
                    std::any::type_name::<IfcBuildingSystem>(),
                    Box::new(entity),
                ))
            }
            "IFCBURNER" => {
                let entity = if own_parameters_only {
                    IfcBurner::from_own_parameters(typed_parameter.parameters)
                } else {
                    IfcBurner::from_parameters(typed_parameter.parameters)
                };
                Some((entity.type_id(), std::any::type_name::<IfcBurner>(), Box::new(entity)))
            }
            "IFCBURNERTYPE" => {
                let entity = if own_parameters_only {
                    IfcBurnerType::from_own_parameters(typed_parameter.parameters)
                } else {
                    IfcBurnerType::from_parameters(typed_parameter.parameters)
                };
                Some((
                    entity.type_id(),
                    std::any::type_name::<IfcBurnerType>(),
                    Box::new(entity),
                ))
            }
            "IFCCSHAPEPROFILEDEF" => {
                let entity = if own_parameters_only {
                    IfcCShapeProfileDef::from_own_parameters(typed_parameter.parameters)
                } else {
                    IfcCShapeProfileDef::from_parameters(typed_parameter.parameters)
                };
                Some((
                    entity.type_id(),
                    std::any::type_name::<IfcCShapeProfileDef>(),
                    Box::new(entity),
                ))
            }
            "IFCCABLECARRIERFITTING" => {
                let entity = if own_parameters_only {
                    IfcCableCarrierFitting::from_own_parameters(typed_parameter.parameters)
                } else {
                    IfcCableCarrierFitting::from_parameters(typed_parameter.parameters)
                };
                Some((
                    entity.type_id(),
                    std::any::type_name::<IfcCableCarrierFitting>(),
                    Box::new(entity),
                ))
            }
            "IFCCABLECARRIERFITTINGTYPE" => {
                let entity = if own_parameters_only {
                    IfcCableCarrierFittingType::from_own_parameters(typed_parameter.parameters)
                } else {
                    IfcCableCarrierFittingType::from_parameters(typed_parameter.parameters)
                };
                Some((
                    entity.type_id(),
                    std::any::type_name::<IfcCableCarrierFittingType>(),
                    Box::new(entity),
                ))
            }
            "IFCCABLECARRIERSEGMENT" => {
                let entity = if own_parameters_only {
                    IfcCableCarrierSegment::from_own_parameters(typed_parameter.parameters)
                } else {
                    IfcCableCarrierSegment::from_parameters(typed_parameter.parameters)
                };
                Some((
                    entity.type_id(),
                    std::any::type_name::<IfcCableCarrierSegment>(),
                    Box::new(entity),
                ))
            }
            "IFCCABLECARRIERSEGMENTTYPE" => {
                let entity = if own_parameters_only {
                    IfcCableCarrierSegmentType::from_own_parameters(typed_parameter.parameters)
                } else {
                    IfcCableCarrierSegmentType::from_parameters(typed_parameter.parameters)
                };
                Some((
                    entity.type_id(),
                    std::any::type_name::<IfcCableCarrierSegmentType>(),
                    Box::new(entity),
                ))
            }
            "IFCCABLEFITTING" => {
                let entity = if own_parameters_only {
                    IfcCableFitting::from_own_parameters(typed_parameter.parameters)
                } else {
                    IfcCableFitting::from_parameters(typed_parameter.parameters)
                };
                Some((
                    entity.type_id(),
                    std::any::type_name::<IfcCableFitting>(),
                    Box::new(entity),
                ))
            }
            "IFCCABLEFITTINGTYPE" => {
                let entity = if own_parameters_only {
                    IfcCableFittingType::from_own_parameters(typed_parameter.parameters)
                } else {
                    IfcCableFittingType::from_parameters(typed_parameter.parameters)
                };
                Some((
                    entity.type_id(),
                    std::any::type_name::<IfcCableFittingType>(),
                    Box::new(entity),
                ))
            }
            "IFCCABLESEGMENT" => {
                let entity = if own_parameters_only {
                    IfcCableSegment::from_own_parameters(typed_parameter.parameters)
                } else {
                    IfcCableSegment::from_parameters(typed_parameter.parameters)
                };
                Some((
                    entity.type_id(),
                    std::any::type_name::<IfcCableSegment>(),
                    Box::new(entity),
                ))
            }
            "IFCCABLESEGMENTTYPE" => {
                let entity = if own_parameters_only {
                    IfcCableSegmentType::from_own_parameters(typed_parameter.parameters)
                } else {
                    IfcCableSegmentType::from_parameters(typed_parameter.parameters)
                };
                Some((
                    entity.type_id(),
                    std::any::type_name::<IfcCableSegmentType>(),
                    Box::new(entity),
                ))
            }
            "IFCCARTESIANPOINT" => {
                let entity = IfcCartesianPoint::from_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<IfcCartesianPoint>(),
                    Box::new(entity),
                ))
            }
            "IFCCARTESIANPOINTLIST2D" => {
                let entity = IfcCartesianPointList2D::from_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<IfcCartesianPointList2D>(),
                    Box::new(entity),
                ))
            }
            "IFCCARTESIANPOINTLIST3D" => {
                let entity = IfcCartesianPointList3D::from_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<IfcCartesianPointList3D>(),
                    Box::new(entity),
                ))
            }
            "IFCCARTESIANTRANSFORMATIONOPERATOR2D" => {
                let entity = IfcCartesianTransformationOperator2D::from_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<IfcCartesianTransformationOperator2D>(),
                    Box::new(entity),
                ))
            }
            "IFCCARTESIANTRANSFORMATIONOPERATOR2DNONUNIFORM" => {
                let entity = if own_parameters_only {
                    IfcCartesianTransformationOperator2DnonUniform::from_own_parameters(typed_parameter.parameters)
                } else {
                    IfcCartesianTransformationOperator2DnonUniform::from_parameters(typed_parameter.parameters)
                };
                Some((
                    entity.type_id(),
                    std::any::type_name::<IfcCartesianTransformationOperator2DnonUniform>(),
                    Box::new(entity),
                ))
            }
            "IFCCARTESIANTRANSFORMATIONOPERATOR3D" => {
                let entity = if own_parameters_only {
                    IfcCartesianTransformationOperator3D::from_own_parameters(typed_parameter.parameters)
                } else {
                    IfcCartesianTransformationOperator3D::from_parameters(typed_parameter.parameters)
                };
                Some((
                    entity.type_id(),
                    std::any::type_name::<IfcCartesianTransformationOperator3D>(),
                    Box::new(entity),
                ))
            }
            "IFCCARTESIANTRANSFORMATIONOPERATOR3DNONUNIFORM" => {
                let entity = if own_parameters_only {
                    IfcCartesianTransformationOperator3DnonUniform::from_own_parameters(typed_parameter.parameters)
                } else {
                    IfcCartesianTransformationOperator3DnonUniform::from_parameters(typed_parameter.parameters)
                };
                Some((
                    entity.type_id(),
                    std::any::type_name::<IfcCartesianTransformationOperator3DnonUniform>(),
                    Box::new(entity),
                ))
            }
            "IFCCENTERLINEPROFILEDEF" => {
                let entity = if own_parameters_only {
                    IfcCenterLineProfileDef::from_own_parameters(typed_parameter.parameters)
                } else {
                    IfcCenterLineProfileDef::from_parameters(typed_parameter.parameters)
                };
                Some((
                    entity.type_id(),
                    std::any::type_name::<IfcCenterLineProfileDef>(),
                    Box::new(entity),
                ))
            }
            "IFCCHILLER" => {
                let entity = if own_parameters_only {
                    IfcChiller::from_own_parameters(typed_parameter.parameters)
                } else {
                    IfcChiller::from_parameters(typed_parameter.parameters)
                };
                Some((entity.type_id(), std::any::type_name::<IfcChiller>(), Box::new(entity)))
            }
            "IFCCHILLERTYPE" => {
                let entity = if own_parameters_only {
                    IfcChillerType::from_own_parameters(typed_parameter.parameters)
                } else {
                    IfcChillerType::from_parameters(typed_parameter.parameters)
                };
                Some((
                    entity.type_id(),
                    std::any::type_name::<IfcChillerType>(),
                    Box::new(entity),
                ))
            }
            "IFCCHIMNEY" => {
                let entity = if own_parameters_only {
                    IfcChimney::from_own_parameters(typed_parameter.parameters)
                } else {
                    IfcChimney::from_parameters(typed_parameter.parameters)
                };
                Some((entity.type_id(), std::any::type_name::<IfcChimney>(), Box::new(entity)))
            }
            "IFCCHIMNEYTYPE" => {
                let entity = if own_parameters_only {
                    IfcChimneyType::from_own_parameters(typed_parameter.parameters)
                } else {
                    IfcChimneyType::from_parameters(typed_parameter.parameters)
                };
                Some((
                    entity.type_id(),
                    std::any::type_name::<IfcChimneyType>(),
                    Box::new(entity),
                ))
            }
            "IFCCIRCLE" => {
                let entity = if own_parameters_only {
                    IfcCircle::from_own_parameters(typed_parameter.parameters)
                } else {
                    IfcCircle::from_parameters(typed_parameter.parameters)
                };
                Some((entity.type_id(), std::any::type_name::<IfcCircle>(), Box::new(entity)))
            }
            "IFCCIRCLEHOLLOWPROFILEDEF" => {
                let entity = if own_parameters_only {
                    IfcCircleHollowProfileDef::from_own_parameters(typed_parameter.parameters)
                } else {
                    IfcCircleHollowProfileDef::from_parameters(typed_parameter.parameters)
                };
                Some((
                    entity.type_id(),
                    std::any::type_name::<IfcCircleHollowProfileDef>(),
                    Box::new(entity),
                ))
            }
            "IFCCIRCLEPROFILEDEF" => {
                let entity = if own_parameters_only {
                    IfcCircleProfileDef::from_own_parameters(typed_parameter.parameters)
                } else {
                    IfcCircleProfileDef::from_parameters(typed_parameter.parameters)
                };
                Some((
                    entity.type_id(),
                    std::any::type_name::<IfcCircleProfileDef>(),
                    Box::new(entity),
                ))
            }
            "IFCCIVILELEMENT" => {
                let entity = IfcCivilElement::from_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<IfcCivilElement>(),
                    Box::new(entity),
                ))
            }
            "IFCCIVILELEMENTTYPE" => {
                let entity = IfcCivilElementType::from_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<IfcCivilElementType>(),
                    Box::new(entity),
                ))
            }
            "IFCCLASSIFICATION" => {
                let entity = IfcClassification::from_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<IfcClassification>(),
                    Box::new(entity),
                ))
            }
            "IFCCLASSIFICATIONREFERENCE" => {
                let entity = if own_parameters_only {
                    IfcClassificationReference::from_own_parameters(typed_parameter.parameters)
                } else {
                    IfcClassificationReference::from_parameters(typed_parameter.parameters)
                };
                Some((
                    entity.type_id(),
                    std::any::type_name::<IfcClassificationReference>(),
                    Box::new(entity),
                ))
            }
            "IFCCLOSEDSHELL" => {
                let entity = IfcClosedShell::from_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<IfcClosedShell>(),
                    Box::new(entity),
                ))
            }
            "IFCCOIL" => {
                let entity = if own_parameters_only {
                    IfcCoil::from_own_parameters(typed_parameter.parameters)
                } else {
                    IfcCoil::from_parameters(typed_parameter.parameters)
                };
                Some((entity.type_id(), std::any::type_name::<IfcCoil>(), Box::new(entity)))
            }
            "IFCCOILTYPE" => {
                let entity = if own_parameters_only {
                    IfcCoilType::from_own_parameters(typed_parameter.parameters)
                } else {
                    IfcCoilType::from_parameters(typed_parameter.parameters)
                };
                Some((entity.type_id(), std::any::type_name::<IfcCoilType>(), Box::new(entity)))
            }
            "IFCCOLOURRGB" => {
                let entity = if own_parameters_only {
                    IfcColourRgb::from_own_parameters(typed_parameter.parameters)
                } else {
                    IfcColourRgb::from_parameters(typed_parameter.parameters)
                };
                Some((
                    entity.type_id(),
                    std::any::type_name::<IfcColourRgb>(),
                    Box::new(entity),
                ))
            }
            "IFCCOLOURRGBLIST" => {
                let entity = IfcColourRgbList::from_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<IfcColourRgbList>(),
                    Box::new(entity),
                ))
            }
            "IFCCOLUMN" => {
                let entity = if own_parameters_only {
                    IfcColumn::from_own_parameters(typed_parameter.parameters)
                } else {
                    IfcColumn::from_parameters(typed_parameter.parameters)
                };
                Some((entity.type_id(), std::any::type_name::<IfcColumn>(), Box::new(entity)))
            }
            "IFCCOLUMNSTANDARDCASE" => {
                let entity = IfcColumnStandardCase::from_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<IfcColumnStandardCase>(),
                    Box::new(entity),
                ))
            }
            "IFCCOLUMNTYPE" => {
                let entity = if own_parameters_only {
                    IfcColumnType::from_own_parameters(typed_parameter.parameters)
                } else {
                    IfcColumnType::from_parameters(typed_parameter.parameters)
                };
                Some((
                    entity.type_id(),
                    std::any::type_name::<IfcColumnType>(),
                    Box::new(entity),
                ))
            }
            "IFCCOMMUNICATIONSAPPLIANCE" => {
                let entity = if own_parameters_only {
                    IfcCommunicationsAppliance::from_own_parameters(typed_parameter.parameters)
                } else {
                    IfcCommunicationsAppliance::from_parameters(typed_parameter.parameters)
                };
                Some((
                    entity.type_id(),
                    std::any::type_name::<IfcCommunicationsAppliance>(),
                    Box::new(entity),
                ))
            }
            "IFCCOMMUNICATIONSAPPLIANCETYPE" => {
                let entity = if own_parameters_only {
                    IfcCommunicationsApplianceType::from_own_parameters(typed_parameter.parameters)
                } else {
                    IfcCommunicationsApplianceType::from_parameters(typed_parameter.parameters)
                };
                Some((
                    entity.type_id(),
                    std::any::type_name::<IfcCommunicationsApplianceType>(),
                    Box::new(entity),
                ))
            }
            "IFCCOMPLEXPROPERTY" => {
                let entity = if own_parameters_only {
                    IfcComplexProperty::from_own_parameters(typed_parameter.parameters)
                } else {
                    IfcComplexProperty::from_parameters(typed_parameter.parameters)
                };
                Some((
                    entity.type_id(),
                    std::any::type_name::<IfcComplexProperty>(),
                    Box::new(entity),
                ))
            }
            "IFCCOMPLEXPROPERTYTEMPLATE" => {
                let entity = if own_parameters_only {
                    IfcComplexPropertyTemplate::from_own_parameters(typed_parameter.parameters)
                } else {
                    IfcComplexPropertyTemplate::from_parameters(typed_parameter.parameters)
                };
                Some((
                    entity.type_id(),
                    std::any::type_name::<IfcComplexPropertyTemplate>(),
                    Box::new(entity),
                ))
            }
            "IFCCOMPOSITECURVE" => {
                let entity = IfcCompositeCurve::from_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<IfcCompositeCurve>(),
                    Box::new(entity),
                ))
            }
            "IFCCOMPOSITECURVEONSURFACE" => {
                let entity = IfcCompositeCurveOnSurface::from_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<IfcCompositeCurveOnSurface>(),
                    Box::new(entity),
                ))
            }
            "IFCCOMPOSITECURVESEGMENT" => {
                let entity = IfcCompositeCurveSegment::from_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<IfcCompositeCurveSegment>(),
                    Box::new(entity),
                ))
            }
            "IFCCOMPOSITEPROFILEDEF" => {
                let entity = if own_parameters_only {
                    IfcCompositeProfileDef::from_own_parameters(typed_parameter.parameters)
                } else {
                    IfcCompositeProfileDef::from_parameters(typed_parameter.parameters)
                };
                Some((
                    entity.type_id(),
                    std::any::type_name::<IfcCompositeProfileDef>(),
                    Box::new(entity),
                ))
            }
            "IFCCOMPRESSOR" => {
                let entity = if own_parameters_only {
                    IfcCompressor::from_own_parameters(typed_parameter.parameters)
                } else {
                    IfcCompressor::from_parameters(typed_parameter.parameters)
                };
                Some((
                    entity.type_id(),
                    std::any::type_name::<IfcCompressor>(),
                    Box::new(entity),
                ))
            }
            "IFCCOMPRESSORTYPE" => {
                let entity = if own_parameters_only {
                    IfcCompressorType::from_own_parameters(typed_parameter.parameters)
                } else {
                    IfcCompressorType::from_parameters(typed_parameter.parameters)
                };
                Some((
                    entity.type_id(),
                    std::any::type_name::<IfcCompressorType>(),
                    Box::new(entity),
                ))
            }
            "IFCCONDENSER" => {
                let entity = if own_parameters_only {
                    IfcCondenser::from_own_parameters(typed_parameter.parameters)
                } else {
                    IfcCondenser::from_parameters(typed_parameter.parameters)
                };
                Some((
                    entity.type_id(),
                    std::any::type_name::<IfcCondenser>(),
                    Box::new(entity),
                ))
            }
            "IFCCONDENSERTYPE" => {
                let entity = if own_parameters_only {
                    IfcCondenserType::from_own_parameters(typed_parameter.parameters)
                } else {
                    IfcCondenserType::from_parameters(typed_parameter.parameters)
                };
                Some((
                    entity.type_id(),
                    std::any::type_name::<IfcCondenserType>(),
                    Box::new(entity),
                ))
            }
            "IFCCONNECTEDFACESET" => {
                let entity = IfcConnectedFaceSet::from_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<IfcConnectedFaceSet>(),
                    Box::new(entity),
                ))
            }
            "IFCCONNECTIONCURVEGEOMETRY" => {
                let entity = IfcConnectionCurveGeometry::from_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<IfcConnectionCurveGeometry>(),
                    Box::new(entity),
                ))
            }
            "IFCCONNECTIONPOINTECCENTRICITY" => {
                let entity = if own_parameters_only {
                    IfcConnectionPointEccentricity::from_own_parameters(typed_parameter.parameters)
                } else {
                    IfcConnectionPointEccentricity::from_parameters(typed_parameter.parameters)
                };
                Some((
                    entity.type_id(),
                    std::any::type_name::<IfcConnectionPointEccentricity>(),
                    Box::new(entity),
                ))
            }
            "IFCCONNECTIONPOINTGEOMETRY" => {
                let entity = IfcConnectionPointGeometry::from_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<IfcConnectionPointGeometry>(),
                    Box::new(entity),
                ))
            }
            "IFCCONNECTIONSURFACEGEOMETRY" => {
                let entity = IfcConnectionSurfaceGeometry::from_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<IfcConnectionSurfaceGeometry>(),
                    Box::new(entity),
                ))
            }
            "IFCCONNECTIONVOLUMEGEOMETRY" => {
                let entity = IfcConnectionVolumeGeometry::from_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<IfcConnectionVolumeGeometry>(),
                    Box::new(entity),
                ))
            }
            "IFCCONSTRUCTIONEQUIPMENTRESOURCE" => {
                let entity = if own_parameters_only {
                    IfcConstructionEquipmentResource::from_own_parameters(typed_parameter.parameters)
                } else {
                    IfcConstructionEquipmentResource::from_parameters(typed_parameter.parameters)
                };
                Some((
                    entity.type_id(),
                    std::any::type_name::<IfcConstructionEquipmentResource>(),
                    Box::new(entity),
                ))
            }
            "IFCCONSTRUCTIONEQUIPMENTRESOURCETYPE" => {
                let entity = if own_parameters_only {
                    IfcConstructionEquipmentResourceType::from_own_parameters(typed_parameter.parameters)
                } else {
                    IfcConstructionEquipmentResourceType::from_parameters(typed_parameter.parameters)
                };
                Some((
                    entity.type_id(),
                    std::any::type_name::<IfcConstructionEquipmentResourceType>(),
                    Box::new(entity),
                ))
            }
            "IFCCONSTRUCTIONMATERIALRESOURCE" => {
                let entity = if own_parameters_only {
                    IfcConstructionMaterialResource::from_own_parameters(typed_parameter.parameters)
                } else {
                    IfcConstructionMaterialResource::from_parameters(typed_parameter.parameters)
                };
                Some((
                    entity.type_id(),
                    std::any::type_name::<IfcConstructionMaterialResource>(),
                    Box::new(entity),
                ))
            }
            "IFCCONSTRUCTIONMATERIALRESOURCETYPE" => {
                let entity = if own_parameters_only {
                    IfcConstructionMaterialResourceType::from_own_parameters(typed_parameter.parameters)
                } else {
                    IfcConstructionMaterialResourceType::from_parameters(typed_parameter.parameters)
                };
                Some((
                    entity.type_id(),
                    std::any::type_name::<IfcConstructionMaterialResourceType>(),
                    Box::new(entity),
                ))
            }
            "IFCCONSTRUCTIONPRODUCTRESOURCE" => {
                let entity = if own_parameters_only {
                    IfcConstructionProductResource::from_own_parameters(typed_parameter.parameters)
                } else {
                    IfcConstructionProductResource::from_parameters(typed_parameter.parameters)
                };
                Some((
                    entity.type_id(),
                    std::any::type_name::<IfcConstructionProductResource>(),
                    Box::new(entity),
                ))
            }
            "IFCCONSTRUCTIONPRODUCTRESOURCETYPE" => {
                let entity = if own_parameters_only {
                    IfcConstructionProductResourceType::from_own_parameters(typed_parameter.parameters)
                } else {
                    IfcConstructionProductResourceType::from_parameters(typed_parameter.parameters)
                };
                Some((
                    entity.type_id(),
                    std::any::type_name::<IfcConstructionProductResourceType>(),
                    Box::new(entity),
                ))
            }
            "IFCCONTEXTDEPENDENTUNIT" => {
                let entity = if own_parameters_only {
                    IfcContextDependentUnit::from_own_parameters(typed_parameter.parameters)
                } else {
                    IfcContextDependentUnit::from_parameters(typed_parameter.parameters)
                };
                Some((
                    entity.type_id(),
                    std::any::type_name::<IfcContextDependentUnit>(),
                    Box::new(entity),
                ))
            }
            "IFCCONTROLLER" => {
                let entity = if own_parameters_only {
                    IfcController::from_own_parameters(typed_parameter.parameters)
                } else {
                    IfcController::from_parameters(typed_parameter.parameters)
                };
                Some((
                    entity.type_id(),
                    std::any::type_name::<IfcController>(),
                    Box::new(entity),
                ))
            }
            "IFCCONTROLLERTYPE" => {
                let entity = if own_parameters_only {
                    IfcControllerType::from_own_parameters(typed_parameter.parameters)
                } else {
                    IfcControllerType::from_parameters(typed_parameter.parameters)
                };
                Some((
                    entity.type_id(),
                    std::any::type_name::<IfcControllerType>(),
                    Box::new(entity),
                ))
            }
            "IFCCONVERSIONBASEDUNIT" => {
                let entity = if own_parameters_only {
                    IfcConversionBasedUnit::from_own_parameters(typed_parameter.parameters)
                } else {
                    IfcConversionBasedUnit::from_parameters(typed_parameter.parameters)
                };
                Some((
                    entity.type_id(),
                    std::any::type_name::<IfcConversionBasedUnit>(),
                    Box::new(entity),
                ))
            }
            "IFCCONVERSIONBASEDUNITWITHOFFSET" => {
                let entity = if own_parameters_only {
                    IfcConversionBasedUnitWithOffset::from_own_parameters(typed_parameter.parameters)
                } else {
                    IfcConversionBasedUnitWithOffset::from_parameters(typed_parameter.parameters)
                };
                Some((
                    entity.type_id(),
                    std::any::type_name::<IfcConversionBasedUnitWithOffset>(),
                    Box::new(entity),
                ))
            }
            "IFCCOOLEDBEAM" => {
                let entity = if own_parameters_only {
                    IfcCooledBeam::from_own_parameters(typed_parameter.parameters)
                } else {
                    IfcCooledBeam::from_parameters(typed_parameter.parameters)
                };
                Some((
                    entity.type_id(),
                    std::any::type_name::<IfcCooledBeam>(),
                    Box::new(entity),
                ))
            }
            "IFCCOOLEDBEAMTYPE" => {
                let entity = if own_parameters_only {
                    IfcCooledBeamType::from_own_parameters(typed_parameter.parameters)
                } else {
                    IfcCooledBeamType::from_parameters(typed_parameter.parameters)
                };
                Some((
                    entity.type_id(),
                    std::any::type_name::<IfcCooledBeamType>(),
                    Box::new(entity),
                ))
            }
            "IFCCOOLINGTOWER" => {
                let entity = if own_parameters_only {
                    IfcCoolingTower::from_own_parameters(typed_parameter.parameters)
                } else {
                    IfcCoolingTower::from_parameters(typed_parameter.parameters)
                };
                Some((
                    entity.type_id(),
                    std::any::type_name::<IfcCoolingTower>(),
                    Box::new(entity),
                ))
            }
            "IFCCOOLINGTOWERTYPE" => {
                let entity = if own_parameters_only {
                    IfcCoolingTowerType::from_own_parameters(typed_parameter.parameters)
                } else {
                    IfcCoolingTowerType::from_parameters(typed_parameter.parameters)
                };
                Some((
                    entity.type_id(),
                    std::any::type_name::<IfcCoolingTowerType>(),
                    Box::new(entity),
                ))
            }
            "IFCCOSTITEM" => {
                let entity = if own_parameters_only {
                    IfcCostItem::from_own_parameters(typed_parameter.parameters)
                } else {
                    IfcCostItem::from_parameters(typed_parameter.parameters)
                };
                Some((entity.type_id(), std::any::type_name::<IfcCostItem>(), Box::new(entity)))
            }
            "IFCCOSTSCHEDULE" => {
                let entity = if own_parameters_only {
                    IfcCostSchedule::from_own_parameters(typed_parameter.parameters)
                } else {
                    IfcCostSchedule::from_parameters(typed_parameter.parameters)
                };
                Some((
                    entity.type_id(),
                    std::any::type_name::<IfcCostSchedule>(),
                    Box::new(entity),
                ))
            }
            "IFCCOSTVALUE" => {
                let entity = IfcCostValue::from_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<IfcCostValue>(),
                    Box::new(entity),
                ))
            }
            "IFCCOVERING" => {
                let entity = if own_parameters_only {
                    IfcCovering::from_own_parameters(typed_parameter.parameters)
                } else {
                    IfcCovering::from_parameters(typed_parameter.parameters)
                };
                Some((entity.type_id(), std::any::type_name::<IfcCovering>(), Box::new(entity)))
            }
            "IFCCOVERINGTYPE" => {
                let entity = if own_parameters_only {
                    IfcCoveringType::from_own_parameters(typed_parameter.parameters)
                } else {
                    IfcCoveringType::from_parameters(typed_parameter.parameters)
                };
                Some((
                    entity.type_id(),
                    std::any::type_name::<IfcCoveringType>(),
                    Box::new(entity),
                ))
            }
            "IFCCREWRESOURCE" => {
                let entity = if own_parameters_only {
                    IfcCrewResource::from_own_parameters(typed_parameter.parameters)
                } else {
                    IfcCrewResource::from_parameters(typed_parameter.parameters)
                };
                Some((
                    entity.type_id(),
                    std::any::type_name::<IfcCrewResource>(),
                    Box::new(entity),
                ))
            }
            "IFCCREWRESOURCETYPE" => {
                let entity = if own_parameters_only {
                    IfcCrewResourceType::from_own_parameters(typed_parameter.parameters)
                } else {
                    IfcCrewResourceType::from_parameters(typed_parameter.parameters)
                };
                Some((
                    entity.type_id(),
                    std::any::type_name::<IfcCrewResourceType>(),
                    Box::new(entity),
                ))
            }
            "IFCCSGSOLID" => {
                let entity = IfcCsgSolid::from_parameters(typed_parameter.parameters);
                Some((entity.type_id(), std::any::type_name::<IfcCsgSolid>(), Box::new(entity)))
            }
            "IFCCURRENCYRELATIONSHIP" => {
                let entity = if own_parameters_only {
                    IfcCurrencyRelationship::from_own_parameters(typed_parameter.parameters)
                } else {
                    IfcCurrencyRelationship::from_parameters(typed_parameter.parameters)
                };
                Some((
                    entity.type_id(),
                    std::any::type_name::<IfcCurrencyRelationship>(),
                    Box::new(entity),
                ))
            }
            "IFCCURTAINWALL" => {
                let entity = if own_parameters_only {
                    IfcCurtainWall::from_own_parameters(typed_parameter.parameters)
                } else {
                    IfcCurtainWall::from_parameters(typed_parameter.parameters)
                };
                Some((
                    entity.type_id(),
                    std::any::type_name::<IfcCurtainWall>(),
                    Box::new(entity),
                ))
            }
            "IFCCURTAINWALLTYPE" => {
                let entity = if own_parameters_only {
                    IfcCurtainWallType::from_own_parameters(typed_parameter.parameters)
                } else {
                    IfcCurtainWallType::from_parameters(typed_parameter.parameters)
                };
                Some((
                    entity.type_id(),
                    std::any::type_name::<IfcCurtainWallType>(),
                    Box::new(entity),
                ))
            }
            "IFCCURVEBOUNDEDPLANE" => {
                let entity = IfcCurveBoundedPlane::from_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<IfcCurveBoundedPlane>(),
                    Box::new(entity),
                ))
            }
            "IFCCURVEBOUNDEDSURFACE" => {
                let entity = IfcCurveBoundedSurface::from_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<IfcCurveBoundedSurface>(),
                    Box::new(entity),
                ))
            }
            "IFCCURVESTYLE" => {
                let entity = if own_parameters_only {
                    IfcCurveStyle::from_own_parameters(typed_parameter.parameters)
                } else {
                    IfcCurveStyle::from_parameters(typed_parameter.parameters)
                };
                Some((
                    entity.type_id(),
                    std::any::type_name::<IfcCurveStyle>(),
                    Box::new(entity),
                ))
            }
            "IFCCURVESTYLEFONT" => {
                let entity = IfcCurveStyleFont::from_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<IfcCurveStyleFont>(),
                    Box::new(entity),
                ))
            }
            "IFCCURVESTYLEFONTANDSCALING" => {
                let entity = IfcCurveStyleFontAndScaling::from_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<IfcCurveStyleFontAndScaling>(),
                    Box::new(entity),
                ))
            }
            "IFCCURVESTYLEFONTPATTERN" => {
                let entity = IfcCurveStyleFontPattern::from_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<IfcCurveStyleFontPattern>(),
                    Box::new(entity),
                ))
            }
            "IFCCYLINDRICALSURFACE" => {
                let entity = if own_parameters_only {
                    IfcCylindricalSurface::from_own_parameters(typed_parameter.parameters)
                } else {
                    IfcCylindricalSurface::from_parameters(typed_parameter.parameters)
                };
                Some((
                    entity.type_id(),
                    std::any::type_name::<IfcCylindricalSurface>(),
                    Box::new(entity),
                ))
            }
            "IFCDAMPER" => {
                let entity = if own_parameters_only {
                    IfcDamper::from_own_parameters(typed_parameter.parameters)
                } else {
                    IfcDamper::from_parameters(typed_parameter.parameters)
                };
                Some((entity.type_id(), std::any::type_name::<IfcDamper>(), Box::new(entity)))
            }
            "IFCDAMPERTYPE" => {
                let entity = if own_parameters_only {
                    IfcDamperType::from_own_parameters(typed_parameter.parameters)
                } else {
                    IfcDamperType::from_parameters(typed_parameter.parameters)
                };
                Some((
                    entity.type_id(),
                    std::any::type_name::<IfcDamperType>(),
                    Box::new(entity),
                ))
            }
            "IFCDERIVEDPROFILEDEF" => {
                let entity = if own_parameters_only {
                    IfcDerivedProfileDef::from_own_parameters(typed_parameter.parameters)
                } else {
                    IfcDerivedProfileDef::from_parameters(typed_parameter.parameters)
                };
                Some((
                    entity.type_id(),
                    std::any::type_name::<IfcDerivedProfileDef>(),
                    Box::new(entity),
                ))
            }
            "IFCDERIVEDUNIT" => {
                let entity = IfcDerivedUnit::from_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<IfcDerivedUnit>(),
                    Box::new(entity),
                ))
            }
            "IFCDERIVEDUNITELEMENT" => {
                let entity = IfcDerivedUnitElement::from_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<IfcDerivedUnitElement>(),
                    Box::new(entity),
                ))
            }
            "IFCDIMENSIONALEXPONENTS" => {
                let entity = IfcDimensionalExponents::from_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<IfcDimensionalExponents>(),
                    Box::new(entity),
                ))
            }
            "IFCDIRECTION" => {
                let entity = IfcDirection::from_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<IfcDirection>(),
                    Box::new(entity),
                ))
            }
            "IFCDISCRETEACCESSORY" => {
                let entity = if own_parameters_only {
                    IfcDiscreteAccessory::from_own_parameters(typed_parameter.parameters)
                } else {
                    IfcDiscreteAccessory::from_parameters(typed_parameter.parameters)
                };
                Some((
                    entity.type_id(),
                    std::any::type_name::<IfcDiscreteAccessory>(),
                    Box::new(entity),
                ))
            }
            "IFCDISCRETEACCESSORYTYPE" => {
                let entity = if own_parameters_only {
                    IfcDiscreteAccessoryType::from_own_parameters(typed_parameter.parameters)
                } else {
                    IfcDiscreteAccessoryType::from_parameters(typed_parameter.parameters)
                };
                Some((
                    entity.type_id(),
                    std::any::type_name::<IfcDiscreteAccessoryType>(),
                    Box::new(entity),
                ))
            }
            "IFCDISTRIBUTIONCHAMBERELEMENT" => {
                let entity = if own_parameters_only {
                    IfcDistributionChamberElement::from_own_parameters(typed_parameter.parameters)
                } else {
                    IfcDistributionChamberElement::from_parameters(typed_parameter.parameters)
                };
                Some((
                    entity.type_id(),
                    std::any::type_name::<IfcDistributionChamberElement>(),
                    Box::new(entity),
                ))
            }
            "IFCDISTRIBUTIONCHAMBERELEMENTTYPE" => {
                let entity = if own_parameters_only {
                    IfcDistributionChamberElementType::from_own_parameters(typed_parameter.parameters)
                } else {
                    IfcDistributionChamberElementType::from_parameters(typed_parameter.parameters)
                };
                Some((
                    entity.type_id(),
                    std::any::type_name::<IfcDistributionChamberElementType>(),
                    Box::new(entity),
                ))
            }
            "IFCDISTRIBUTIONCIRCUIT" => {
                let entity = IfcDistributionCircuit::from_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<IfcDistributionCircuit>(),
                    Box::new(entity),
                ))
            }
            "IFCDISTRIBUTIONCONTROLELEMENT" => {
                let entity = IfcDistributionControlElement::from_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<IfcDistributionControlElement>(),
                    Box::new(entity),
                ))
            }
            "IFCDISTRIBUTIONELEMENT" => {
                let entity = IfcDistributionElement::from_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<IfcDistributionElement>(),
                    Box::new(entity),
                ))
            }
            "IFCDISTRIBUTIONELEMENTTYPE" => {
                let entity = IfcDistributionElementType::from_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<IfcDistributionElementType>(),
                    Box::new(entity),
                ))
            }
            "IFCDISTRIBUTIONFLOWELEMENT" => {
                let entity = IfcDistributionFlowElement::from_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<IfcDistributionFlowElement>(),
                    Box::new(entity),
                ))
            }
            "IFCDISTRIBUTIONPORT" => {
                let entity = if own_parameters_only {
                    IfcDistributionPort::from_own_parameters(typed_parameter.parameters)
                } else {
                    IfcDistributionPort::from_parameters(typed_parameter.parameters)
                };
                Some((
                    entity.type_id(),
                    std::any::type_name::<IfcDistributionPort>(),
                    Box::new(entity),
                ))
            }
            "IFCDISTRIBUTIONSYSTEM" => {
                let entity = if own_parameters_only {
                    IfcDistributionSystem::from_own_parameters(typed_parameter.parameters)
                } else {
                    IfcDistributionSystem::from_parameters(typed_parameter.parameters)
                };
                Some((
                    entity.type_id(),
                    std::any::type_name::<IfcDistributionSystem>(),
                    Box::new(entity),
                ))
            }
            "IFCDOCUMENTINFORMATION" => {
                let entity = IfcDocumentInformation::from_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<IfcDocumentInformation>(),
                    Box::new(entity),
                ))
            }
            "IFCDOCUMENTINFORMATIONRELATIONSHIP" => {
                let entity = if own_parameters_only {
                    IfcDocumentInformationRelationship::from_own_parameters(typed_parameter.parameters)
                } else {
                    IfcDocumentInformationRelationship::from_parameters(typed_parameter.parameters)
                };
                Some((
                    entity.type_id(),
                    std::any::type_name::<IfcDocumentInformationRelationship>(),
                    Box::new(entity),
                ))
            }
            "IFCDOCUMENTREFERENCE" => {
                let entity = if own_parameters_only {
                    IfcDocumentReference::from_own_parameters(typed_parameter.parameters)
                } else {
                    IfcDocumentReference::from_parameters(typed_parameter.parameters)
                };
                Some((
                    entity.type_id(),
                    std::any::type_name::<IfcDocumentReference>(),
                    Box::new(entity),
                ))
            }
            "IFCDOOR" => {
                let entity = if own_parameters_only {
                    IfcDoor::from_own_parameters(typed_parameter.parameters)
                } else {
                    IfcDoor::from_parameters(typed_parameter.parameters)
                };
                Some((entity.type_id(), std::any::type_name::<IfcDoor>(), Box::new(entity)))
            }
            "IFCDOORLININGPROPERTIES" => {
                let entity = if own_parameters_only {
                    IfcDoorLiningProperties::from_own_parameters(typed_parameter.parameters)
                } else {
                    IfcDoorLiningProperties::from_parameters(typed_parameter.parameters)
                };
                Some((
                    entity.type_id(),
                    std::any::type_name::<IfcDoorLiningProperties>(),
                    Box::new(entity),
                ))
            }
            "IFCDOORPANELPROPERTIES" => {
                let entity = if own_parameters_only {
                    IfcDoorPanelProperties::from_own_parameters(typed_parameter.parameters)
                } else {
                    IfcDoorPanelProperties::from_parameters(typed_parameter.parameters)
                };
                Some((
                    entity.type_id(),
                    std::any::type_name::<IfcDoorPanelProperties>(),
                    Box::new(entity),
                ))
            }
            "IFCDOORSTANDARDCASE" => {
                let entity = IfcDoorStandardCase::from_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<IfcDoorStandardCase>(),
                    Box::new(entity),
                ))
            }
            "IFCDOORSTYLE" => {
                let entity = if own_parameters_only {
                    IfcDoorStyle::from_own_parameters(typed_parameter.parameters)
                } else {
                    IfcDoorStyle::from_parameters(typed_parameter.parameters)
                };
                Some((
                    entity.type_id(),
                    std::any::type_name::<IfcDoorStyle>(),
                    Box::new(entity),
                ))
            }
            "IFCDOORTYPE" => {
                let entity = if own_parameters_only {
                    IfcDoorType::from_own_parameters(typed_parameter.parameters)
                } else {
                    IfcDoorType::from_parameters(typed_parameter.parameters)
                };
                Some((entity.type_id(), std::any::type_name::<IfcDoorType>(), Box::new(entity)))
            }
            "IFCDRAUGHTINGPREDEFINEDCOLOUR" => {
                let entity = IfcDraughtingPreDefinedColour::from_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<IfcDraughtingPreDefinedColour>(),
                    Box::new(entity),
                ))
            }
            "IFCDRAUGHTINGPREDEFINEDCURVEFONT" => {
                let entity = IfcDraughtingPreDefinedCurveFont::from_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<IfcDraughtingPreDefinedCurveFont>(),
                    Box::new(entity),
                ))
            }
            "IFCDUCTFITTING" => {
                let entity = if own_parameters_only {
                    IfcDuctFitting::from_own_parameters(typed_parameter.parameters)
                } else {
                    IfcDuctFitting::from_parameters(typed_parameter.parameters)
                };
                Some((
                    entity.type_id(),
                    std::any::type_name::<IfcDuctFitting>(),
                    Box::new(entity),
                ))
            }
            "IFCDUCTFITTINGTYPE" => {
                let entity = if own_parameters_only {
                    IfcDuctFittingType::from_own_parameters(typed_parameter.parameters)
                } else {
                    IfcDuctFittingType::from_parameters(typed_parameter.parameters)
                };
                Some((
                    entity.type_id(),
                    std::any::type_name::<IfcDuctFittingType>(),
                    Box::new(entity),
                ))
            }
            "IFCDUCTSEGMENT" => {
                let entity = if own_parameters_only {
                    IfcDuctSegment::from_own_parameters(typed_parameter.parameters)
                } else {
                    IfcDuctSegment::from_parameters(typed_parameter.parameters)
                };
                Some((
                    entity.type_id(),
                    std::any::type_name::<IfcDuctSegment>(),
                    Box::new(entity),
                ))
            }
            "IFCDUCTSEGMENTTYPE" => {
                let entity = if own_parameters_only {
                    IfcDuctSegmentType::from_own_parameters(typed_parameter.parameters)
                } else {
                    IfcDuctSegmentType::from_parameters(typed_parameter.parameters)
                };
                Some((
                    entity.type_id(),
                    std::any::type_name::<IfcDuctSegmentType>(),
                    Box::new(entity),
                ))
            }
            "IFCDUCTSILENCER" => {
                let entity = if own_parameters_only {
                    IfcDuctSilencer::from_own_parameters(typed_parameter.parameters)
                } else {
                    IfcDuctSilencer::from_parameters(typed_parameter.parameters)
                };
                Some((
                    entity.type_id(),
                    std::any::type_name::<IfcDuctSilencer>(),
                    Box::new(entity),
                ))
            }
            "IFCDUCTSILENCERTYPE" => {
                let entity = if own_parameters_only {
                    IfcDuctSilencerType::from_own_parameters(typed_parameter.parameters)
                } else {
                    IfcDuctSilencerType::from_parameters(typed_parameter.parameters)
                };
                Some((
                    entity.type_id(),
                    std::any::type_name::<IfcDuctSilencerType>(),
                    Box::new(entity),
                ))
            }
            "IFCEDGE" => {
                let entity = IfcEdge::from_parameters(typed_parameter.parameters);
                Some((entity.type_id(), std::any::type_name::<IfcEdge>(), Box::new(entity)))
            }
            "IFCEDGECURVE" => {
                let entity = if own_parameters_only {
                    IfcEdgeCurve::from_own_parameters(typed_parameter.parameters)
                } else {
                    IfcEdgeCurve::from_parameters(typed_parameter.parameters)
                };
                Some((
                    entity.type_id(),
                    std::any::type_name::<IfcEdgeCurve>(),
                    Box::new(entity),
                ))
            }
            "IFCEDGELOOP" => {
                let entity = IfcEdgeLoop::from_parameters(typed_parameter.parameters);
                Some((entity.type_id(), std::any::type_name::<IfcEdgeLoop>(), Box::new(entity)))
            }
            "IFCELECTRICAPPLIANCE" => {
                let entity = if own_parameters_only {
                    IfcElectricAppliance::from_own_parameters(typed_parameter.parameters)
                } else {
                    IfcElectricAppliance::from_parameters(typed_parameter.parameters)
                };
                Some((
                    entity.type_id(),
                    std::any::type_name::<IfcElectricAppliance>(),
                    Box::new(entity),
                ))
            }
            "IFCELECTRICAPPLIANCETYPE" => {
                let entity = if own_parameters_only {
                    IfcElectricApplianceType::from_own_parameters(typed_parameter.parameters)
                } else {
                    IfcElectricApplianceType::from_parameters(typed_parameter.parameters)
                };
                Some((
                    entity.type_id(),
                    std::any::type_name::<IfcElectricApplianceType>(),
                    Box::new(entity),
                ))
            }
            "IFCELECTRICDISTRIBUTIONBOARD" => {
                let entity = if own_parameters_only {
                    IfcElectricDistributionBoard::from_own_parameters(typed_parameter.parameters)
                } else {
                    IfcElectricDistributionBoard::from_parameters(typed_parameter.parameters)
                };
                Some((
                    entity.type_id(),
                    std::any::type_name::<IfcElectricDistributionBoard>(),
                    Box::new(entity),
                ))
            }
            "IFCELECTRICDISTRIBUTIONBOARDTYPE" => {
                let entity = if own_parameters_only {
                    IfcElectricDistributionBoardType::from_own_parameters(typed_parameter.parameters)
                } else {
                    IfcElectricDistributionBoardType::from_parameters(typed_parameter.parameters)
                };
                Some((
                    entity.type_id(),
                    std::any::type_name::<IfcElectricDistributionBoardType>(),
                    Box::new(entity),
                ))
            }
            "IFCELECTRICFLOWSTORAGEDEVICE" => {
                let entity = if own_parameters_only {
                    IfcElectricFlowStorageDevice::from_own_parameters(typed_parameter.parameters)
                } else {
                    IfcElectricFlowStorageDevice::from_parameters(typed_parameter.parameters)
                };
                Some((
                    entity.type_id(),
                    std::any::type_name::<IfcElectricFlowStorageDevice>(),
                    Box::new(entity),
                ))
            }
            "IFCELECTRICFLOWSTORAGEDEVICETYPE" => {
                let entity = if own_parameters_only {
                    IfcElectricFlowStorageDeviceType::from_own_parameters(typed_parameter.parameters)
                } else {
                    IfcElectricFlowStorageDeviceType::from_parameters(typed_parameter.parameters)
                };
                Some((
                    entity.type_id(),
                    std::any::type_name::<IfcElectricFlowStorageDeviceType>(),
                    Box::new(entity),
                ))
            }
            "IFCELECTRICGENERATOR" => {
                let entity = if own_parameters_only {
                    IfcElectricGenerator::from_own_parameters(typed_parameter.parameters)
                } else {
                    IfcElectricGenerator::from_parameters(typed_parameter.parameters)
                };
                Some((
                    entity.type_id(),
                    std::any::type_name::<IfcElectricGenerator>(),
                    Box::new(entity),
                ))
            }
            "IFCELECTRICGENERATORTYPE" => {
                let entity = if own_parameters_only {
                    IfcElectricGeneratorType::from_own_parameters(typed_parameter.parameters)
                } else {
                    IfcElectricGeneratorType::from_parameters(typed_parameter.parameters)
                };
                Some((
                    entity.type_id(),
                    std::any::type_name::<IfcElectricGeneratorType>(),
                    Box::new(entity),
                ))
            }
            "IFCELECTRICMOTOR" => {
                let entity = if own_parameters_only {
                    IfcElectricMotor::from_own_parameters(typed_parameter.parameters)
                } else {
                    IfcElectricMotor::from_parameters(typed_parameter.parameters)
                };
                Some((
                    entity.type_id(),
                    std::any::type_name::<IfcElectricMotor>(),
                    Box::new(entity),
                ))
            }
            "IFCELECTRICMOTORTYPE" => {
                let entity = if own_parameters_only {
                    IfcElectricMotorType::from_own_parameters(typed_parameter.parameters)
                } else {
                    IfcElectricMotorType::from_parameters(typed_parameter.parameters)
                };
                Some((
                    entity.type_id(),
                    std::any::type_name::<IfcElectricMotorType>(),
                    Box::new(entity),
                ))
            }
            "IFCELECTRICTIMECONTROL" => {
                let entity = if own_parameters_only {
                    IfcElectricTimeControl::from_own_parameters(typed_parameter.parameters)
                } else {
                    IfcElectricTimeControl::from_parameters(typed_parameter.parameters)
                };
                Some((
                    entity.type_id(),
                    std::any::type_name::<IfcElectricTimeControl>(),
                    Box::new(entity),
                ))
            }
            "IFCELECTRICTIMECONTROLTYPE" => {
                let entity = if own_parameters_only {
                    IfcElectricTimeControlType::from_own_parameters(typed_parameter.parameters)
                } else {
                    IfcElectricTimeControlType::from_parameters(typed_parameter.parameters)
                };
                Some((
                    entity.type_id(),
                    std::any::type_name::<IfcElectricTimeControlType>(),
                    Box::new(entity),
                ))
            }
            "IFCELEMENTASSEMBLY" => {
                let entity = if own_parameters_only {
                    IfcElementAssembly::from_own_parameters(typed_parameter.parameters)
                } else {
                    IfcElementAssembly::from_parameters(typed_parameter.parameters)
                };
                Some((
                    entity.type_id(),
                    std::any::type_name::<IfcElementAssembly>(),
                    Box::new(entity),
                ))
            }
            "IFCELEMENTASSEMBLYTYPE" => {
                let entity = if own_parameters_only {
                    IfcElementAssemblyType::from_own_parameters(typed_parameter.parameters)
                } else {
                    IfcElementAssemblyType::from_parameters(typed_parameter.parameters)
                };
                Some((
                    entity.type_id(),
                    std::any::type_name::<IfcElementAssemblyType>(),
                    Box::new(entity),
                ))
            }
            "IFCELEMENTQUANTITY" => {
                let entity = if own_parameters_only {
                    IfcElementQuantity::from_own_parameters(typed_parameter.parameters)
                } else {
                    IfcElementQuantity::from_parameters(typed_parameter.parameters)
                };
                Some((
                    entity.type_id(),
                    std::any::type_name::<IfcElementQuantity>(),
                    Box::new(entity),
                ))
            }
            "IFCELLIPSE" => {
                let entity = if own_parameters_only {
                    IfcEllipse::from_own_parameters(typed_parameter.parameters)
                } else {
                    IfcEllipse::from_parameters(typed_parameter.parameters)
                };
                Some((entity.type_id(), std::any::type_name::<IfcEllipse>(), Box::new(entity)))
            }
            "IFCELLIPSEPROFILEDEF" => {
                let entity = if own_parameters_only {
                    IfcEllipseProfileDef::from_own_parameters(typed_parameter.parameters)
                } else {
                    IfcEllipseProfileDef::from_parameters(typed_parameter.parameters)
                };
                Some((
                    entity.type_id(),
                    std::any::type_name::<IfcEllipseProfileDef>(),
                    Box::new(entity),
                ))
            }
            "IFCENERGYCONVERSIONDEVICE" => {
                let entity = IfcEnergyConversionDevice::from_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<IfcEnergyConversionDevice>(),
                    Box::new(entity),
                ))
            }
            "IFCENGINE" => {
                let entity = if own_parameters_only {
                    IfcEngine::from_own_parameters(typed_parameter.parameters)
                } else {
                    IfcEngine::from_parameters(typed_parameter.parameters)
                };
                Some((entity.type_id(), std::any::type_name::<IfcEngine>(), Box::new(entity)))
            }
            "IFCENGINETYPE" => {
                let entity = if own_parameters_only {
                    IfcEngineType::from_own_parameters(typed_parameter.parameters)
                } else {
                    IfcEngineType::from_parameters(typed_parameter.parameters)
                };
                Some((
                    entity.type_id(),
                    std::any::type_name::<IfcEngineType>(),
                    Box::new(entity),
                ))
            }
            "IFCEVAPORATIVECOOLER" => {
                let entity = if own_parameters_only {
                    IfcEvaporativeCooler::from_own_parameters(typed_parameter.parameters)
                } else {
                    IfcEvaporativeCooler::from_parameters(typed_parameter.parameters)
                };
                Some((
                    entity.type_id(),
                    std::any::type_name::<IfcEvaporativeCooler>(),
                    Box::new(entity),
                ))
            }
            "IFCEVAPORATIVECOOLERTYPE" => {
                let entity = if own_parameters_only {
                    IfcEvaporativeCoolerType::from_own_parameters(typed_parameter.parameters)
                } else {
                    IfcEvaporativeCoolerType::from_parameters(typed_parameter.parameters)
                };
                Some((
                    entity.type_id(),
                    std::any::type_name::<IfcEvaporativeCoolerType>(),
                    Box::new(entity),
                ))
            }
            "IFCEVAPORATOR" => {
                let entity = if own_parameters_only {
                    IfcEvaporator::from_own_parameters(typed_parameter.parameters)
                } else {
                    IfcEvaporator::from_parameters(typed_parameter.parameters)
                };
                Some((
                    entity.type_id(),
                    std::any::type_name::<IfcEvaporator>(),
                    Box::new(entity),
                ))
            }
            "IFCEVAPORATORTYPE" => {
                let entity = if own_parameters_only {
                    IfcEvaporatorType::from_own_parameters(typed_parameter.parameters)
                } else {
                    IfcEvaporatorType::from_parameters(typed_parameter.parameters)
                };
                Some((
                    entity.type_id(),
                    std::any::type_name::<IfcEvaporatorType>(),
                    Box::new(entity),
                ))
            }
            "IFCEVENT" => {
                let entity = if own_parameters_only {
                    IfcEvent::from_own_parameters(typed_parameter.parameters)
                } else {
                    IfcEvent::from_parameters(typed_parameter.parameters)
                };
                Some((entity.type_id(), std::any::type_name::<IfcEvent>(), Box::new(entity)))
            }
            "IFCEVENTTIME" => {
                let entity = if own_parameters_only {
                    IfcEventTime::from_own_parameters(typed_parameter.parameters)
                } else {
                    IfcEventTime::from_parameters(typed_parameter.parameters)
                };
                Some((
                    entity.type_id(),
                    std::any::type_name::<IfcEventTime>(),
                    Box::new(entity),
                ))
            }
            "IFCEVENTTYPE" => {
                let entity = if own_parameters_only {
                    IfcEventType::from_own_parameters(typed_parameter.parameters)
                } else {
                    IfcEventType::from_parameters(typed_parameter.parameters)
                };
                Some((
                    entity.type_id(),
                    std::any::type_name::<IfcEventType>(),
                    Box::new(entity),
                ))
            }
            "IFCEXTERNALREFERENCERELATIONSHIP" => {
                let entity = if own_parameters_only {
                    IfcExternalReferenceRelationship::from_own_parameters(typed_parameter.parameters)
                } else {
                    IfcExternalReferenceRelationship::from_parameters(typed_parameter.parameters)
                };
                Some((
                    entity.type_id(),
                    std::any::type_name::<IfcExternalReferenceRelationship>(),
                    Box::new(entity),
                ))
            }
            "IFCEXTERNALSPATIALELEMENT" => {
                let entity = if own_parameters_only {
                    IfcExternalSpatialElement::from_own_parameters(typed_parameter.parameters)
                } else {
                    IfcExternalSpatialElement::from_parameters(typed_parameter.parameters)
                };
                Some((
                    entity.type_id(),
                    std::any::type_name::<IfcExternalSpatialElement>(),
                    Box::new(entity),
                ))
            }
            "IFCEXTERNALLYDEFINEDHATCHSTYLE" => {
                let entity = IfcExternallyDefinedHatchStyle::from_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<IfcExternallyDefinedHatchStyle>(),
                    Box::new(entity),
                ))
            }
            "IFCEXTERNALLYDEFINEDSURFACESTYLE" => {
                let entity = IfcExternallyDefinedSurfaceStyle::from_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<IfcExternallyDefinedSurfaceStyle>(),
                    Box::new(entity),
                ))
            }
            "IFCEXTERNALLYDEFINEDTEXTFONT" => {
                let entity = IfcExternallyDefinedTextFont::from_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<IfcExternallyDefinedTextFont>(),
                    Box::new(entity),
                ))
            }
            "IFCEXTRUDEDAREASOLID" => {
                let entity = if own_parameters_only {
                    IfcExtrudedAreaSolid::from_own_parameters(typed_parameter.parameters)
                } else {
                    IfcExtrudedAreaSolid::from_parameters(typed_parameter.parameters)
                };
                Some((
                    entity.type_id(),
                    std::any::type_name::<IfcExtrudedAreaSolid>(),
                    Box::new(entity),
                ))
            }
            "IFCEXTRUDEDAREASOLIDTAPERED" => {
                let entity = if own_parameters_only {
                    IfcExtrudedAreaSolidTapered::from_own_parameters(typed_parameter.parameters)
                } else {
                    IfcExtrudedAreaSolidTapered::from_parameters(typed_parameter.parameters)
                };
                Some((
                    entity.type_id(),
                    std::any::type_name::<IfcExtrudedAreaSolidTapered>(),
                    Box::new(entity),
                ))
            }
            "IFCFACE" => {
                let entity = IfcFace::from_parameters(typed_parameter.parameters);
                Some((entity.type_id(), std::any::type_name::<IfcFace>(), Box::new(entity)))
            }
            "IFCFACEBASEDSURFACEMODEL" => {
                let entity = IfcFaceBasedSurfaceModel::from_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<IfcFaceBasedSurfaceModel>(),
                    Box::new(entity),
                ))
            }
            "IFCFACEBOUND" => {
                let entity = IfcFaceBound::from_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<IfcFaceBound>(),
                    Box::new(entity),
                ))
            }
            "IFCFACEOUTERBOUND" => {
                let entity = IfcFaceOuterBound::from_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<IfcFaceOuterBound>(),
                    Box::new(entity),
                ))
            }
            "IFCFACESURFACE" => {
                let entity = if own_parameters_only {
                    IfcFaceSurface::from_own_parameters(typed_parameter.parameters)
                } else {
                    IfcFaceSurface::from_parameters(typed_parameter.parameters)
                };
                Some((
                    entity.type_id(),
                    std::any::type_name::<IfcFaceSurface>(),
                    Box::new(entity),
                ))
            }
            "IFCFACETEDBREP" => {
                let entity = IfcFacetedBrep::from_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<IfcFacetedBrep>(),
                    Box::new(entity),
                ))
            }
            "IFCFACETEDBREPWITHVOIDS" => {
                let entity = if own_parameters_only {
                    IfcFacetedBrepWithVoids::from_own_parameters(typed_parameter.parameters)
                } else {
                    IfcFacetedBrepWithVoids::from_parameters(typed_parameter.parameters)
                };
                Some((
                    entity.type_id(),
                    std::any::type_name::<IfcFacetedBrepWithVoids>(),
                    Box::new(entity),
                ))
            }
            "IFCFAILURECONNECTIONCONDITION" => {
                let entity = if own_parameters_only {
                    IfcFailureConnectionCondition::from_own_parameters(typed_parameter.parameters)
                } else {
                    IfcFailureConnectionCondition::from_parameters(typed_parameter.parameters)
                };
                Some((
                    entity.type_id(),
                    std::any::type_name::<IfcFailureConnectionCondition>(),
                    Box::new(entity),
                ))
            }
            "IFCFAN" => {
                let entity = if own_parameters_only {
                    IfcFan::from_own_parameters(typed_parameter.parameters)
                } else {
                    IfcFan::from_parameters(typed_parameter.parameters)
                };
                Some((entity.type_id(), std::any::type_name::<IfcFan>(), Box::new(entity)))
            }
            "IFCFANTYPE" => {
                let entity = if own_parameters_only {
                    IfcFanType::from_own_parameters(typed_parameter.parameters)
                } else {
                    IfcFanType::from_parameters(typed_parameter.parameters)
                };
                Some((entity.type_id(), std::any::type_name::<IfcFanType>(), Box::new(entity)))
            }
            "IFCFASTENER" => {
                let entity = if own_parameters_only {
                    IfcFastener::from_own_parameters(typed_parameter.parameters)
                } else {
                    IfcFastener::from_parameters(typed_parameter.parameters)
                };
                Some((entity.type_id(), std::any::type_name::<IfcFastener>(), Box::new(entity)))
            }
            "IFCFASTENERTYPE" => {
                let entity = if own_parameters_only {
                    IfcFastenerType::from_own_parameters(typed_parameter.parameters)
                } else {
                    IfcFastenerType::from_parameters(typed_parameter.parameters)
                };
                Some((
                    entity.type_id(),
                    std::any::type_name::<IfcFastenerType>(),
                    Box::new(entity),
                ))
            }
            "IFCFILLAREASTYLE" => {
                let entity = if own_parameters_only {
                    IfcFillAreaStyle::from_own_parameters(typed_parameter.parameters)
                } else {
                    IfcFillAreaStyle::from_parameters(typed_parameter.parameters)
                };
                Some((
                    entity.type_id(),
                    std::any::type_name::<IfcFillAreaStyle>(),
                    Box::new(entity),
                ))
            }
            "IFCFILLAREASTYLEHATCHING" => {
                let entity = IfcFillAreaStyleHatching::from_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<IfcFillAreaStyleHatching>(),
                    Box::new(entity),
                ))
            }
            "IFCFILLAREASTYLETILES" => {
                let entity = IfcFillAreaStyleTiles::from_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<IfcFillAreaStyleTiles>(),
                    Box::new(entity),
                ))
            }
            "IFCFILTER" => {
                let entity = if own_parameters_only {
                    IfcFilter::from_own_parameters(typed_parameter.parameters)
                } else {
                    IfcFilter::from_parameters(typed_parameter.parameters)
                };
                Some((entity.type_id(), std::any::type_name::<IfcFilter>(), Box::new(entity)))
            }
            "IFCFILTERTYPE" => {
                let entity = if own_parameters_only {
                    IfcFilterType::from_own_parameters(typed_parameter.parameters)
                } else {
                    IfcFilterType::from_parameters(typed_parameter.parameters)
                };
                Some((
                    entity.type_id(),
                    std::any::type_name::<IfcFilterType>(),
                    Box::new(entity),
                ))
            }
            "IFCFIRESUPPRESSIONTERMINAL" => {
                let entity = if own_parameters_only {
                    IfcFireSuppressionTerminal::from_own_parameters(typed_parameter.parameters)
                } else {
                    IfcFireSuppressionTerminal::from_parameters(typed_parameter.parameters)
                };
                Some((
                    entity.type_id(),
                    std::any::type_name::<IfcFireSuppressionTerminal>(),
                    Box::new(entity),
                ))
            }
            "IFCFIRESUPPRESSIONTERMINALTYPE" => {
                let entity = if own_parameters_only {
                    IfcFireSuppressionTerminalType::from_own_parameters(typed_parameter.parameters)
                } else {
                    IfcFireSuppressionTerminalType::from_parameters(typed_parameter.parameters)
                };
                Some((
                    entity.type_id(),
                    std::any::type_name::<IfcFireSuppressionTerminalType>(),
                    Box::new(entity),
                ))
            }
            "IFCFIXEDREFERENCESWEPTAREASOLID" => {
                let entity = if own_parameters_only {
                    IfcFixedReferenceSweptAreaSolid::from_own_parameters(typed_parameter.parameters)
                } else {
                    IfcFixedReferenceSweptAreaSolid::from_parameters(typed_parameter.parameters)
                };
                Some((
                    entity.type_id(),
                    std::any::type_name::<IfcFixedReferenceSweptAreaSolid>(),
                    Box::new(entity),
                ))
            }
            "IFCFLOWCONTROLLER" => {
                let entity = IfcFlowController::from_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<IfcFlowController>(),
                    Box::new(entity),
                ))
            }
            "IFCFLOWFITTING" => {
                let entity = IfcFlowFitting::from_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<IfcFlowFitting>(),
                    Box::new(entity),
                ))
            }
            "IFCFLOWINSTRUMENT" => {
                let entity = if own_parameters_only {
                    IfcFlowInstrument::from_own_parameters(typed_parameter.parameters)
                } else {
                    IfcFlowInstrument::from_parameters(typed_parameter.parameters)
                };
                Some((
                    entity.type_id(),
                    std::any::type_name::<IfcFlowInstrument>(),
                    Box::new(entity),
                ))
            }
            "IFCFLOWINSTRUMENTTYPE" => {
                let entity = if own_parameters_only {
                    IfcFlowInstrumentType::from_own_parameters(typed_parameter.parameters)
                } else {
                    IfcFlowInstrumentType::from_parameters(typed_parameter.parameters)
                };
                Some((
                    entity.type_id(),
                    std::any::type_name::<IfcFlowInstrumentType>(),
                    Box::new(entity),
                ))
            }
            "IFCFLOWMETER" => {
                let entity = if own_parameters_only {
                    IfcFlowMeter::from_own_parameters(typed_parameter.parameters)
                } else {
                    IfcFlowMeter::from_parameters(typed_parameter.parameters)
                };
                Some((
                    entity.type_id(),
                    std::any::type_name::<IfcFlowMeter>(),
                    Box::new(entity),
                ))
            }
            "IFCFLOWMETERTYPE" => {
                let entity = if own_parameters_only {
                    IfcFlowMeterType::from_own_parameters(typed_parameter.parameters)
                } else {
                    IfcFlowMeterType::from_parameters(typed_parameter.parameters)
                };
                Some((
                    entity.type_id(),
                    std::any::type_name::<IfcFlowMeterType>(),
                    Box::new(entity),
                ))
            }
            "IFCFLOWMOVINGDEVICE" => {
                let entity = IfcFlowMovingDevice::from_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<IfcFlowMovingDevice>(),
                    Box::new(entity),
                ))
            }
            "IFCFLOWSEGMENT" => {
                let entity = IfcFlowSegment::from_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<IfcFlowSegment>(),
                    Box::new(entity),
                ))
            }
            "IFCFLOWSTORAGEDEVICE" => {
                let entity = IfcFlowStorageDevice::from_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<IfcFlowStorageDevice>(),
                    Box::new(entity),
                ))
            }
            "IFCFLOWTERMINAL" => {
                let entity = IfcFlowTerminal::from_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<IfcFlowTerminal>(),
                    Box::new(entity),
                ))
            }
            "IFCFLOWTREATMENTDEVICE" => {
                let entity = IfcFlowTreatmentDevice::from_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<IfcFlowTreatmentDevice>(),
                    Box::new(entity),
                ))
            }
            "IFCFOOTING" => {
                let entity = if own_parameters_only {
                    IfcFooting::from_own_parameters(typed_parameter.parameters)
                } else {
                    IfcFooting::from_parameters(typed_parameter.parameters)
                };
                Some((entity.type_id(), std::any::type_name::<IfcFooting>(), Box::new(entity)))
            }
            "IFCFOOTINGTYPE" => {
                let entity = if own_parameters_only {
                    IfcFootingType::from_own_parameters(typed_parameter.parameters)
                } else {
                    IfcFootingType::from_parameters(typed_parameter.parameters)
                };
                Some((
                    entity.type_id(),
                    std::any::type_name::<IfcFootingType>(),
                    Box::new(entity),
                ))
            }
            "IFCFURNISHINGELEMENT" => {
                let entity = IfcFurnishingElement::from_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<IfcFurnishingElement>(),
                    Box::new(entity),
                ))
            }
            "IFCFURNISHINGELEMENTTYPE" => {
                let entity = IfcFurnishingElementType::from_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<IfcFurnishingElementType>(),
                    Box::new(entity),
                ))
            }
            "IFCFURNITURE" => {
                let entity = if own_parameters_only {
                    IfcFurniture::from_own_parameters(typed_parameter.parameters)
                } else {
                    IfcFurniture::from_parameters(typed_parameter.parameters)
                };
                Some((
                    entity.type_id(),
                    std::any::type_name::<IfcFurniture>(),
                    Box::new(entity),
                ))
            }
            "IFCFURNITURETYPE" => {
                let entity = if own_parameters_only {
                    IfcFurnitureType::from_own_parameters(typed_parameter.parameters)
                } else {
                    IfcFurnitureType::from_parameters(typed_parameter.parameters)
                };
                Some((
                    entity.type_id(),
                    std::any::type_name::<IfcFurnitureType>(),
                    Box::new(entity),
                ))
            }
            "IFCGEOGRAPHICELEMENT" => {
                let entity = if own_parameters_only {
                    IfcGeographicElement::from_own_parameters(typed_parameter.parameters)
                } else {
                    IfcGeographicElement::from_parameters(typed_parameter.parameters)
                };
                Some((
                    entity.type_id(),
                    std::any::type_name::<IfcGeographicElement>(),
                    Box::new(entity),
                ))
            }
            "IFCGEOGRAPHICELEMENTTYPE" => {
                let entity = if own_parameters_only {
                    IfcGeographicElementType::from_own_parameters(typed_parameter.parameters)
                } else {
                    IfcGeographicElementType::from_parameters(typed_parameter.parameters)
                };
                Some((
                    entity.type_id(),
                    std::any::type_name::<IfcGeographicElementType>(),
                    Box::new(entity),
                ))
            }
            "IFCGEOMETRICCURVESET" => {
                let entity = IfcGeometricCurveSet::from_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<IfcGeometricCurveSet>(),
                    Box::new(entity),
                ))
            }
            "IFCGEOMETRICREPRESENTATIONCONTEXT" => {
                let entity = if own_parameters_only {
                    IfcGeometricRepresentationContext::from_own_parameters(typed_parameter.parameters)
                } else {
                    IfcGeometricRepresentationContext::from_parameters(typed_parameter.parameters)
                };
                Some((
                    entity.type_id(),
                    std::any::type_name::<IfcGeometricRepresentationContext>(),
                    Box::new(entity),
                ))
            }
            "IFCGEOMETRICREPRESENTATIONSUBCONTEXT" => {
                let entity = if own_parameters_only {
                    IfcGeometricRepresentationSubContext::from_own_parameters(typed_parameter.parameters)
                } else {
                    IfcGeometricRepresentationSubContext::from_parameters(typed_parameter.parameters)
                };
                Some((
                    entity.type_id(),
                    std::any::type_name::<IfcGeometricRepresentationSubContext>(),
                    Box::new(entity),
                ))
            }
            "IFCGEOMETRICSET" => {
                let entity = IfcGeometricSet::from_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<IfcGeometricSet>(),
                    Box::new(entity),
                ))
            }
            "IFCGRID" => {
                let entity = if own_parameters_only {
                    IfcGrid::from_own_parameters(typed_parameter.parameters)
                } else {
                    IfcGrid::from_parameters(typed_parameter.parameters)
                };
                Some((entity.type_id(), std::any::type_name::<IfcGrid>(), Box::new(entity)))
            }
            "IFCGRIDAXIS" => {
                let entity = IfcGridAxis::from_parameters(typed_parameter.parameters);
                Some((entity.type_id(), std::any::type_name::<IfcGridAxis>(), Box::new(entity)))
            }
            "IFCGRIDPLACEMENT" => {
                let entity = IfcGridPlacement::from_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<IfcGridPlacement>(),
                    Box::new(entity),
                ))
            }
            "IFCGROUP" => {
                let entity = IfcGroup::from_parameters(typed_parameter.parameters);
                Some((entity.type_id(), std::any::type_name::<IfcGroup>(), Box::new(entity)))
            }
            "IFCHALFSPACESOLID" => {
                let entity = IfcHalfSpaceSolid::from_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<IfcHalfSpaceSolid>(),
                    Box::new(entity),
                ))
            }
            "IFCHEATEXCHANGER" => {
                let entity = if own_parameters_only {
                    IfcHeatExchanger::from_own_parameters(typed_parameter.parameters)
                } else {
                    IfcHeatExchanger::from_parameters(typed_parameter.parameters)
                };
                Some((
                    entity.type_id(),
                    std::any::type_name::<IfcHeatExchanger>(),
                    Box::new(entity),
                ))
            }
            "IFCHEATEXCHANGERTYPE" => {
                let entity = if own_parameters_only {
                    IfcHeatExchangerType::from_own_parameters(typed_parameter.parameters)
                } else {
                    IfcHeatExchangerType::from_parameters(typed_parameter.parameters)
                };
                Some((
                    entity.type_id(),
                    std::any::type_name::<IfcHeatExchangerType>(),
                    Box::new(entity),
                ))
            }
            "IFCHUMIDIFIER" => {
                let entity = if own_parameters_only {
                    IfcHumidifier::from_own_parameters(typed_parameter.parameters)
                } else {
                    IfcHumidifier::from_parameters(typed_parameter.parameters)
                };
                Some((
                    entity.type_id(),
                    std::any::type_name::<IfcHumidifier>(),
                    Box::new(entity),
                ))
            }
            "IFCHUMIDIFIERTYPE" => {
                let entity = if own_parameters_only {
                    IfcHumidifierType::from_own_parameters(typed_parameter.parameters)
                } else {
                    IfcHumidifierType::from_parameters(typed_parameter.parameters)
                };
                Some((
                    entity.type_id(),
                    std::any::type_name::<IfcHumidifierType>(),
                    Box::new(entity),
                ))
            }
            "IFCISHAPEPROFILEDEF" => {
                let entity = if own_parameters_only {
                    IfcIShapeProfileDef::from_own_parameters(typed_parameter.parameters)
                } else {
                    IfcIShapeProfileDef::from_parameters(typed_parameter.parameters)
                };
                Some((
                    entity.type_id(),
                    std::any::type_name::<IfcIShapeProfileDef>(),
                    Box::new(entity),
                ))
            }
            "IFCIMAGETEXTURE" => {
                let entity = if own_parameters_only {
                    IfcImageTexture::from_own_parameters(typed_parameter.parameters)
                } else {
                    IfcImageTexture::from_parameters(typed_parameter.parameters)
                };
                Some((
                    entity.type_id(),
                    std::any::type_name::<IfcImageTexture>(),
                    Box::new(entity),
                ))
            }
            "IFCINDEXEDCOLOURMAP" => {
                let entity = IfcIndexedColourMap::from_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<IfcIndexedColourMap>(),
                    Box::new(entity),
                ))
            }
            "IFCINDEXEDPOLYCURVE" => {
                let entity = IfcIndexedPolyCurve::from_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<IfcIndexedPolyCurve>(),
                    Box::new(entity),
                ))
            }
            "IFCINDEXEDPOLYGONALFACE" => {
                let entity = IfcIndexedPolygonalFace::from_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<IfcIndexedPolygonalFace>(),
                    Box::new(entity),
                ))
            }
            "IFCINDEXEDPOLYGONALFACEWITHVOIDS" => {
                let entity = if own_parameters_only {
                    IfcIndexedPolygonalFaceWithVoids::from_own_parameters(typed_parameter.parameters)
                } else {
                    IfcIndexedPolygonalFaceWithVoids::from_parameters(typed_parameter.parameters)
                };
                Some((
                    entity.type_id(),
                    std::any::type_name::<IfcIndexedPolygonalFaceWithVoids>(),
                    Box::new(entity),
                ))
            }
            "IFCINDEXEDTRIANGLETEXTUREMAP" => {
                let entity = if own_parameters_only {
                    IfcIndexedTriangleTextureMap::from_own_parameters(typed_parameter.parameters)
                } else {
                    IfcIndexedTriangleTextureMap::from_parameters(typed_parameter.parameters)
                };
                Some((
                    entity.type_id(),
                    std::any::type_name::<IfcIndexedTriangleTextureMap>(),
                    Box::new(entity),
                ))
            }
            "IFCINTERCEPTOR" => {
                let entity = if own_parameters_only {
                    IfcInterceptor::from_own_parameters(typed_parameter.parameters)
                } else {
                    IfcInterceptor::from_parameters(typed_parameter.parameters)
                };
                Some((
                    entity.type_id(),
                    std::any::type_name::<IfcInterceptor>(),
                    Box::new(entity),
                ))
            }
            "IFCINTERCEPTORTYPE" => {
                let entity = if own_parameters_only {
                    IfcInterceptorType::from_own_parameters(typed_parameter.parameters)
                } else {
                    IfcInterceptorType::from_parameters(typed_parameter.parameters)
                };
                Some((
                    entity.type_id(),
                    std::any::type_name::<IfcInterceptorType>(),
                    Box::new(entity),
                ))
            }
            "IFCINTERSECTIONCURVE" => {
                let entity = IfcIntersectionCurve::from_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<IfcIntersectionCurve>(),
                    Box::new(entity),
                ))
            }
            "IFCINVENTORY" => {
                let entity = if own_parameters_only {
                    IfcInventory::from_own_parameters(typed_parameter.parameters)
                } else {
                    IfcInventory::from_parameters(typed_parameter.parameters)
                };
                Some((
                    entity.type_id(),
                    std::any::type_name::<IfcInventory>(),
                    Box::new(entity),
                ))
            }
            "IFCIRREGULARTIMESERIES" => {
                let entity = if own_parameters_only {
                    IfcIrregularTimeSeries::from_own_parameters(typed_parameter.parameters)
                } else {
                    IfcIrregularTimeSeries::from_parameters(typed_parameter.parameters)
                };
                Some((
                    entity.type_id(),
                    std::any::type_name::<IfcIrregularTimeSeries>(),
                    Box::new(entity),
                ))
            }
            "IFCIRREGULARTIMESERIESVALUE" => {
                let entity = IfcIrregularTimeSeriesValue::from_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<IfcIrregularTimeSeriesValue>(),
                    Box::new(entity),
                ))
            }
            "IFCJUNCTIONBOX" => {
                let entity = if own_parameters_only {
                    IfcJunctionBox::from_own_parameters(typed_parameter.parameters)
                } else {
                    IfcJunctionBox::from_parameters(typed_parameter.parameters)
                };
                Some((
                    entity.type_id(),
                    std::any::type_name::<IfcJunctionBox>(),
                    Box::new(entity),
                ))
            }
            "IFCJUNCTIONBOXTYPE" => {
                let entity = if own_parameters_only {
                    IfcJunctionBoxType::from_own_parameters(typed_parameter.parameters)
                } else {
                    IfcJunctionBoxType::from_parameters(typed_parameter.parameters)
                };
                Some((
                    entity.type_id(),
                    std::any::type_name::<IfcJunctionBoxType>(),
                    Box::new(entity),
                ))
            }
            "IFCLSHAPEPROFILEDEF" => {
                let entity = if own_parameters_only {
                    IfcLShapeProfileDef::from_own_parameters(typed_parameter.parameters)
                } else {
                    IfcLShapeProfileDef::from_parameters(typed_parameter.parameters)
                };
                Some((
                    entity.type_id(),
                    std::any::type_name::<IfcLShapeProfileDef>(),
                    Box::new(entity),
                ))
            }
            "IFCLABORRESOURCE" => {
                let entity = if own_parameters_only {
                    IfcLaborResource::from_own_parameters(typed_parameter.parameters)
                } else {
                    IfcLaborResource::from_parameters(typed_parameter.parameters)
                };
                Some((
                    entity.type_id(),
                    std::any::type_name::<IfcLaborResource>(),
                    Box::new(entity),
                ))
            }
            "IFCLABORRESOURCETYPE" => {
                let entity = if own_parameters_only {
                    IfcLaborResourceType::from_own_parameters(typed_parameter.parameters)
                } else {
                    IfcLaborResourceType::from_parameters(typed_parameter.parameters)
                };
                Some((
                    entity.type_id(),
                    std::any::type_name::<IfcLaborResourceType>(),
                    Box::new(entity),
                ))
            }
            "IFCLAGTIME" => {
                let entity = if own_parameters_only {
                    IfcLagTime::from_own_parameters(typed_parameter.parameters)
                } else {
                    IfcLagTime::from_parameters(typed_parameter.parameters)
                };
                Some((entity.type_id(), std::any::type_name::<IfcLagTime>(), Box::new(entity)))
            }
            "IFCLAMP" => {
                let entity = if own_parameters_only {
                    IfcLamp::from_own_parameters(typed_parameter.parameters)
                } else {
                    IfcLamp::from_parameters(typed_parameter.parameters)
                };
                Some((entity.type_id(), std::any::type_name::<IfcLamp>(), Box::new(entity)))
            }
            "IFCLAMPTYPE" => {
                let entity = if own_parameters_only {
                    IfcLampType::from_own_parameters(typed_parameter.parameters)
                } else {
                    IfcLampType::from_parameters(typed_parameter.parameters)
                };
                Some((entity.type_id(), std::any::type_name::<IfcLampType>(), Box::new(entity)))
            }
            "IFCLIBRARYINFORMATION" => {
                let entity = IfcLibraryInformation::from_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<IfcLibraryInformation>(),
                    Box::new(entity),
                ))
            }
            "IFCLIBRARYREFERENCE" => {
                let entity = if own_parameters_only {
                    IfcLibraryReference::from_own_parameters(typed_parameter.parameters)
                } else {
                    IfcLibraryReference::from_parameters(typed_parameter.parameters)
                };
                Some((
                    entity.type_id(),
                    std::any::type_name::<IfcLibraryReference>(),
                    Box::new(entity),
                ))
            }
            "IFCLIGHTDISTRIBUTIONDATA" => {
                let entity = IfcLightDistributionData::from_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<IfcLightDistributionData>(),
                    Box::new(entity),
                ))
            }
            "IFCLIGHTFIXTURE" => {
                let entity = if own_parameters_only {
                    IfcLightFixture::from_own_parameters(typed_parameter.parameters)
                } else {
                    IfcLightFixture::from_parameters(typed_parameter.parameters)
                };
                Some((
                    entity.type_id(),
                    std::any::type_name::<IfcLightFixture>(),
                    Box::new(entity),
                ))
            }
            "IFCLIGHTFIXTURETYPE" => {
                let entity = if own_parameters_only {
                    IfcLightFixtureType::from_own_parameters(typed_parameter.parameters)
                } else {
                    IfcLightFixtureType::from_parameters(typed_parameter.parameters)
                };
                Some((
                    entity.type_id(),
                    std::any::type_name::<IfcLightFixtureType>(),
                    Box::new(entity),
                ))
            }
            "IFCLIGHTINTENSITYDISTRIBUTION" => {
                let entity = IfcLightIntensityDistribution::from_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<IfcLightIntensityDistribution>(),
                    Box::new(entity),
                ))
            }
            "IFCLIGHTSOURCEAMBIENT" => {
                let entity = IfcLightSourceAmbient::from_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<IfcLightSourceAmbient>(),
                    Box::new(entity),
                ))
            }
            "IFCLIGHTSOURCEDIRECTIONAL" => {
                let entity = if own_parameters_only {
                    IfcLightSourceDirectional::from_own_parameters(typed_parameter.parameters)
                } else {
                    IfcLightSourceDirectional::from_parameters(typed_parameter.parameters)
                };
                Some((
                    entity.type_id(),
                    std::any::type_name::<IfcLightSourceDirectional>(),
                    Box::new(entity),
                ))
            }
            "IFCLIGHTSOURCEGONIOMETRIC" => {
                let entity = if own_parameters_only {
                    IfcLightSourceGoniometric::from_own_parameters(typed_parameter.parameters)
                } else {
                    IfcLightSourceGoniometric::from_parameters(typed_parameter.parameters)
                };
                Some((
                    entity.type_id(),
                    std::any::type_name::<IfcLightSourceGoniometric>(),
                    Box::new(entity),
                ))
            }
            "IFCLIGHTSOURCEPOSITIONAL" => {
                let entity = if own_parameters_only {
                    IfcLightSourcePositional::from_own_parameters(typed_parameter.parameters)
                } else {
                    IfcLightSourcePositional::from_parameters(typed_parameter.parameters)
                };
                Some((
                    entity.type_id(),
                    std::any::type_name::<IfcLightSourcePositional>(),
                    Box::new(entity),
                ))
            }
            "IFCLIGHTSOURCESPOT" => {
                let entity = if own_parameters_only {
                    IfcLightSourceSpot::from_own_parameters(typed_parameter.parameters)
                } else {
                    IfcLightSourceSpot::from_parameters(typed_parameter.parameters)
                };
                Some((
                    entity.type_id(),
                    std::any::type_name::<IfcLightSourceSpot>(),
                    Box::new(entity),
                ))
            }
            "IFCLINE" => {
                let entity = IfcLine::from_parameters(typed_parameter.parameters);
                Some((entity.type_id(), std::any::type_name::<IfcLine>(), Box::new(entity)))
            }
            "IFCLOCALPLACEMENT" => {
                let entity = IfcLocalPlacement::from_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<IfcLocalPlacement>(),
                    Box::new(entity),
                ))
            }
            "IFCLOOP" => {
                let entity = IfcLoop::from_parameters(typed_parameter.parameters);
                Some((entity.type_id(), std::any::type_name::<IfcLoop>(), Box::new(entity)))
            }
            "IFCMAPCONVERSION" => {
                let entity = if own_parameters_only {
                    IfcMapConversion::from_own_parameters(typed_parameter.parameters)
                } else {
                    IfcMapConversion::from_parameters(typed_parameter.parameters)
                };
                Some((
                    entity.type_id(),
                    std::any::type_name::<IfcMapConversion>(),
                    Box::new(entity),
                ))
            }
            "IFCMAPPEDITEM" => {
                let entity = IfcMappedItem::from_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<IfcMappedItem>(),
                    Box::new(entity),
                ))
            }
            "IFCMATERIAL" => {
                let entity = IfcMaterial::from_parameters(typed_parameter.parameters);
                Some((entity.type_id(), std::any::type_name::<IfcMaterial>(), Box::new(entity)))
            }
            "IFCMATERIALCLASSIFICATIONRELATIONSHIP" => {
                let entity = IfcMaterialClassificationRelationship::from_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<IfcMaterialClassificationRelationship>(),
                    Box::new(entity),
                ))
            }
            "IFCMATERIALCONSTITUENT" => {
                let entity = IfcMaterialConstituent::from_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<IfcMaterialConstituent>(),
                    Box::new(entity),
                ))
            }
            "IFCMATERIALCONSTITUENTSET" => {
                let entity = IfcMaterialConstituentSet::from_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<IfcMaterialConstituentSet>(),
                    Box::new(entity),
                ))
            }
            "IFCMATERIALDEFINITIONREPRESENTATION" => {
                let entity = if own_parameters_only {
                    IfcMaterialDefinitionRepresentation::from_own_parameters(typed_parameter.parameters)
                } else {
                    IfcMaterialDefinitionRepresentation::from_parameters(typed_parameter.parameters)
                };
                Some((
                    entity.type_id(),
                    std::any::type_name::<IfcMaterialDefinitionRepresentation>(),
                    Box::new(entity),
                ))
            }
            "IFCMATERIALLAYER" => {
                let entity = IfcMaterialLayer::from_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<IfcMaterialLayer>(),
                    Box::new(entity),
                ))
            }
            "IFCMATERIALLAYERSET" => {
                let entity = IfcMaterialLayerSet::from_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<IfcMaterialLayerSet>(),
                    Box::new(entity),
                ))
            }
            "IFCMATERIALLAYERSETUSAGE" => {
                let entity = IfcMaterialLayerSetUsage::from_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<IfcMaterialLayerSetUsage>(),
                    Box::new(entity),
                ))
            }
            "IFCMATERIALLAYERWITHOFFSETS" => {
                let entity = if own_parameters_only {
                    IfcMaterialLayerWithOffsets::from_own_parameters(typed_parameter.parameters)
                } else {
                    IfcMaterialLayerWithOffsets::from_parameters(typed_parameter.parameters)
                };
                Some((
                    entity.type_id(),
                    std::any::type_name::<IfcMaterialLayerWithOffsets>(),
                    Box::new(entity),
                ))
            }
            "IFCMATERIALLIST" => {
                let entity = IfcMaterialList::from_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<IfcMaterialList>(),
                    Box::new(entity),
                ))
            }
            "IFCMATERIALPROFILE" => {
                let entity = IfcMaterialProfile::from_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<IfcMaterialProfile>(),
                    Box::new(entity),
                ))
            }
            "IFCMATERIALPROFILESET" => {
                let entity = IfcMaterialProfileSet::from_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<IfcMaterialProfileSet>(),
                    Box::new(entity),
                ))
            }
            "IFCMATERIALPROFILESETUSAGE" => {
                let entity = IfcMaterialProfileSetUsage::from_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<IfcMaterialProfileSetUsage>(),
                    Box::new(entity),
                ))
            }
            "IFCMATERIALPROFILESETUSAGETAPERING" => {
                let entity = if own_parameters_only {
                    IfcMaterialProfileSetUsageTapering::from_own_parameters(typed_parameter.parameters)
                } else {
                    IfcMaterialProfileSetUsageTapering::from_parameters(typed_parameter.parameters)
                };
                Some((
                    entity.type_id(),
                    std::any::type_name::<IfcMaterialProfileSetUsageTapering>(),
                    Box::new(entity),
                ))
            }
            "IFCMATERIALPROFILEWITHOFFSETS" => {
                let entity = if own_parameters_only {
                    IfcMaterialProfileWithOffsets::from_own_parameters(typed_parameter.parameters)
                } else {
                    IfcMaterialProfileWithOffsets::from_parameters(typed_parameter.parameters)
                };
                Some((
                    entity.type_id(),
                    std::any::type_name::<IfcMaterialProfileWithOffsets>(),
                    Box::new(entity),
                ))
            }
            "IFCMATERIALPROPERTIES" => {
                let entity = if own_parameters_only {
                    IfcMaterialProperties::from_own_parameters(typed_parameter.parameters)
                } else {
                    IfcMaterialProperties::from_parameters(typed_parameter.parameters)
                };
                Some((
                    entity.type_id(),
                    std::any::type_name::<IfcMaterialProperties>(),
                    Box::new(entity),
                ))
            }
            "IFCMATERIALRELATIONSHIP" => {
                let entity = if own_parameters_only {
                    IfcMaterialRelationship::from_own_parameters(typed_parameter.parameters)
                } else {
                    IfcMaterialRelationship::from_parameters(typed_parameter.parameters)
                };
                Some((
                    entity.type_id(),
                    std::any::type_name::<IfcMaterialRelationship>(),
                    Box::new(entity),
                ))
            }
            "IFCMEASUREWITHUNIT" => {
                let entity = IfcMeasureWithUnit::from_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<IfcMeasureWithUnit>(),
                    Box::new(entity),
                ))
            }
            "IFCMECHANICALFASTENER" => {
                let entity = if own_parameters_only {
                    IfcMechanicalFastener::from_own_parameters(typed_parameter.parameters)
                } else {
                    IfcMechanicalFastener::from_parameters(typed_parameter.parameters)
                };
                Some((
                    entity.type_id(),
                    std::any::type_name::<IfcMechanicalFastener>(),
                    Box::new(entity),
                ))
            }
            "IFCMECHANICALFASTENERTYPE" => {
                let entity = if own_parameters_only {
                    IfcMechanicalFastenerType::from_own_parameters(typed_parameter.parameters)
                } else {
                    IfcMechanicalFastenerType::from_parameters(typed_parameter.parameters)
                };
                Some((
                    entity.type_id(),
                    std::any::type_name::<IfcMechanicalFastenerType>(),
                    Box::new(entity),
                ))
            }
            "IFCMEDICALDEVICE" => {
                let entity = if own_parameters_only {
                    IfcMedicalDevice::from_own_parameters(typed_parameter.parameters)
                } else {
                    IfcMedicalDevice::from_parameters(typed_parameter.parameters)
                };
                Some((
                    entity.type_id(),
                    std::any::type_name::<IfcMedicalDevice>(),
                    Box::new(entity),
                ))
            }
            "IFCMEDICALDEVICETYPE" => {
                let entity = if own_parameters_only {
                    IfcMedicalDeviceType::from_own_parameters(typed_parameter.parameters)
                } else {
                    IfcMedicalDeviceType::from_parameters(typed_parameter.parameters)
                };
                Some((
                    entity.type_id(),
                    std::any::type_name::<IfcMedicalDeviceType>(),
                    Box::new(entity),
                ))
            }
            "IFCMEMBER" => {
                let entity = if own_parameters_only {
                    IfcMember::from_own_parameters(typed_parameter.parameters)
                } else {
                    IfcMember::from_parameters(typed_parameter.parameters)
                };
                Some((entity.type_id(), std::any::type_name::<IfcMember>(), Box::new(entity)))
            }
            "IFCMEMBERSTANDARDCASE" => {
                let entity = IfcMemberStandardCase::from_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<IfcMemberStandardCase>(),
                    Box::new(entity),
                ))
            }
            "IFCMEMBERTYPE" => {
                let entity = if own_parameters_only {
                    IfcMemberType::from_own_parameters(typed_parameter.parameters)
                } else {
                    IfcMemberType::from_parameters(typed_parameter.parameters)
                };
                Some((
                    entity.type_id(),
                    std::any::type_name::<IfcMemberType>(),
                    Box::new(entity),
                ))
            }
            "IFCMETRIC" => {
                let entity = if own_parameters_only {
                    IfcMetric::from_own_parameters(typed_parameter.parameters)
                } else {
                    IfcMetric::from_parameters(typed_parameter.parameters)
                };
                Some((entity.type_id(), std::any::type_name::<IfcMetric>(), Box::new(entity)))
            }
            "IFCMIRROREDPROFILEDEF" => {
                let entity = IfcMirroredProfileDef::from_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<IfcMirroredProfileDef>(),
                    Box::new(entity),
                ))
            }
            "IFCMONETARYUNIT" => {
                let entity = IfcMonetaryUnit::from_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<IfcMonetaryUnit>(),
                    Box::new(entity),
                ))
            }
            "IFCMOTORCONNECTION" => {
                let entity = if own_parameters_only {
                    IfcMotorConnection::from_own_parameters(typed_parameter.parameters)
                } else {
                    IfcMotorConnection::from_parameters(typed_parameter.parameters)
                };
                Some((
                    entity.type_id(),
                    std::any::type_name::<IfcMotorConnection>(),
                    Box::new(entity),
                ))
            }
            "IFCMOTORCONNECTIONTYPE" => {
                let entity = if own_parameters_only {
                    IfcMotorConnectionType::from_own_parameters(typed_parameter.parameters)
                } else {
                    IfcMotorConnectionType::from_parameters(typed_parameter.parameters)
                };
                Some((
                    entity.type_id(),
                    std::any::type_name::<IfcMotorConnectionType>(),
                    Box::new(entity),
                ))
            }
            "IFCOBJECTIVE" => {
                let entity = if own_parameters_only {
                    IfcObjective::from_own_parameters(typed_parameter.parameters)
                } else {
                    IfcObjective::from_parameters(typed_parameter.parameters)
                };
                Some((
                    entity.type_id(),
                    std::any::type_name::<IfcObjective>(),
                    Box::new(entity),
                ))
            }
            "IFCOCCUPANT" => {
                let entity = if own_parameters_only {
                    IfcOccupant::from_own_parameters(typed_parameter.parameters)
                } else {
                    IfcOccupant::from_parameters(typed_parameter.parameters)
                };
                Some((entity.type_id(), std::any::type_name::<IfcOccupant>(), Box::new(entity)))
            }
            "IFCOFFSETCURVE2D" => {
                let entity = IfcOffsetCurve2D::from_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<IfcOffsetCurve2D>(),
                    Box::new(entity),
                ))
            }
            "IFCOFFSETCURVE3D" => {
                let entity = IfcOffsetCurve3D::from_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<IfcOffsetCurve3D>(),
                    Box::new(entity),
                ))
            }
            "IFCOPENSHELL" => {
                let entity = IfcOpenShell::from_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<IfcOpenShell>(),
                    Box::new(entity),
                ))
            }
            "IFCOPENINGELEMENT" => {
                let entity = if own_parameters_only {
                    IfcOpeningElement::from_own_parameters(typed_parameter.parameters)
                } else {
                    IfcOpeningElement::from_parameters(typed_parameter.parameters)
                };
                Some((
                    entity.type_id(),
                    std::any::type_name::<IfcOpeningElement>(),
                    Box::new(entity),
                ))
            }
            "IFCOPENINGSTANDARDCASE" => {
                let entity = IfcOpeningStandardCase::from_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<IfcOpeningStandardCase>(),
                    Box::new(entity),
                ))
            }
            "IFCORGANIZATION" => {
                let entity = IfcOrganization::from_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<IfcOrganization>(),
                    Box::new(entity),
                ))
            }
            "IFCORGANIZATIONRELATIONSHIP" => {
                let entity = if own_parameters_only {
                    IfcOrganizationRelationship::from_own_parameters(typed_parameter.parameters)
                } else {
                    IfcOrganizationRelationship::from_parameters(typed_parameter.parameters)
                };
                Some((
                    entity.type_id(),
                    std::any::type_name::<IfcOrganizationRelationship>(),
                    Box::new(entity),
                ))
            }
            "IFCORIENTEDEDGE" => {
                let entity = if own_parameters_only {
                    IfcOrientedEdge::from_own_parameters(typed_parameter.parameters)
                } else {
                    IfcOrientedEdge::from_parameters(typed_parameter.parameters)
                };
                Some((
                    entity.type_id(),
                    std::any::type_name::<IfcOrientedEdge>(),
                    Box::new(entity),
                ))
            }
            "IFCOUTERBOUNDARYCURVE" => {
                let entity = IfcOuterBoundaryCurve::from_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<IfcOuterBoundaryCurve>(),
                    Box::new(entity),
                ))
            }
            "IFCOUTLET" => {
                let entity = if own_parameters_only {
                    IfcOutlet::from_own_parameters(typed_parameter.parameters)
                } else {
                    IfcOutlet::from_parameters(typed_parameter.parameters)
                };
                Some((entity.type_id(), std::any::type_name::<IfcOutlet>(), Box::new(entity)))
            }
            "IFCOUTLETTYPE" => {
                let entity = if own_parameters_only {
                    IfcOutletType::from_own_parameters(typed_parameter.parameters)
                } else {
                    IfcOutletType::from_parameters(typed_parameter.parameters)
                };
                Some((
                    entity.type_id(),
                    std::any::type_name::<IfcOutletType>(),
                    Box::new(entity),
                ))
            }
            "IFCOWNERHISTORY" => {
                let entity = IfcOwnerHistory::from_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<IfcOwnerHistory>(),
                    Box::new(entity),
                ))
            }
            "IFCPATH" => {
                let entity = IfcPath::from_parameters(typed_parameter.parameters);
                Some((entity.type_id(), std::any::type_name::<IfcPath>(), Box::new(entity)))
            }
            "IFCPCURVE" => {
                let entity = IfcPcurve::from_parameters(typed_parameter.parameters);
                Some((entity.type_id(), std::any::type_name::<IfcPcurve>(), Box::new(entity)))
            }
            "IFCPERFORMANCEHISTORY" => {
                let entity = if own_parameters_only {
                    IfcPerformanceHistory::from_own_parameters(typed_parameter.parameters)
                } else {
                    IfcPerformanceHistory::from_parameters(typed_parameter.parameters)
                };
                Some((
                    entity.type_id(),
                    std::any::type_name::<IfcPerformanceHistory>(),
                    Box::new(entity),
                ))
            }
            "IFCPERMEABLECOVERINGPROPERTIES" => {
                let entity = if own_parameters_only {
                    IfcPermeableCoveringProperties::from_own_parameters(typed_parameter.parameters)
                } else {
                    IfcPermeableCoveringProperties::from_parameters(typed_parameter.parameters)
                };
                Some((
                    entity.type_id(),
                    std::any::type_name::<IfcPermeableCoveringProperties>(),
                    Box::new(entity),
                ))
            }
            "IFCPERMIT" => {
                let entity = if own_parameters_only {
                    IfcPermit::from_own_parameters(typed_parameter.parameters)
                } else {
                    IfcPermit::from_parameters(typed_parameter.parameters)
                };
                Some((entity.type_id(), std::any::type_name::<IfcPermit>(), Box::new(entity)))
            }
            "IFCPERSON" => {
                let entity = IfcPerson::from_parameters(typed_parameter.parameters);
                Some((entity.type_id(), std::any::type_name::<IfcPerson>(), Box::new(entity)))
            }
            "IFCPERSONANDORGANIZATION" => {
                let entity = IfcPersonAndOrganization::from_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<IfcPersonAndOrganization>(),
                    Box::new(entity),
                ))
            }
            "IFCPHYSICALCOMPLEXQUANTITY" => {
                let entity = if own_parameters_only {
                    IfcPhysicalComplexQuantity::from_own_parameters(typed_parameter.parameters)
                } else {
                    IfcPhysicalComplexQuantity::from_parameters(typed_parameter.parameters)
                };
                Some((
                    entity.type_id(),
                    std::any::type_name::<IfcPhysicalComplexQuantity>(),
                    Box::new(entity),
                ))
            }
            "IFCPILE" => {
                let entity = if own_parameters_only {
                    IfcPile::from_own_parameters(typed_parameter.parameters)
                } else {
                    IfcPile::from_parameters(typed_parameter.parameters)
                };
                Some((entity.type_id(), std::any::type_name::<IfcPile>(), Box::new(entity)))
            }
            "IFCPILETYPE" => {
                let entity = if own_parameters_only {
                    IfcPileType::from_own_parameters(typed_parameter.parameters)
                } else {
                    IfcPileType::from_parameters(typed_parameter.parameters)
                };
                Some((entity.type_id(), std::any::type_name::<IfcPileType>(), Box::new(entity)))
            }
            "IFCPIPEFITTING" => {
                let entity = if own_parameters_only {
                    IfcPipeFitting::from_own_parameters(typed_parameter.parameters)
                } else {
                    IfcPipeFitting::from_parameters(typed_parameter.parameters)
                };
                Some((
                    entity.type_id(),
                    std::any::type_name::<IfcPipeFitting>(),
                    Box::new(entity),
                ))
            }
            "IFCPIPEFITTINGTYPE" => {
                let entity = if own_parameters_only {
                    IfcPipeFittingType::from_own_parameters(typed_parameter.parameters)
                } else {
                    IfcPipeFittingType::from_parameters(typed_parameter.parameters)
                };
                Some((
                    entity.type_id(),
                    std::any::type_name::<IfcPipeFittingType>(),
                    Box::new(entity),
                ))
            }
            "IFCPIPESEGMENT" => {
                let entity = if own_parameters_only {
                    IfcPipeSegment::from_own_parameters(typed_parameter.parameters)
                } else {
                    IfcPipeSegment::from_parameters(typed_parameter.parameters)
                };
                Some((
                    entity.type_id(),
                    std::any::type_name::<IfcPipeSegment>(),
                    Box::new(entity),
                ))
            }
            "IFCPIPESEGMENTTYPE" => {
                let entity = if own_parameters_only {
                    IfcPipeSegmentType::from_own_parameters(typed_parameter.parameters)
                } else {
                    IfcPipeSegmentType::from_parameters(typed_parameter.parameters)
                };
                Some((
                    entity.type_id(),
                    std::any::type_name::<IfcPipeSegmentType>(),
                    Box::new(entity),
                ))
            }
            "IFCPIXELTEXTURE" => {
                let entity = if own_parameters_only {
                    IfcPixelTexture::from_own_parameters(typed_parameter.parameters)
                } else {
                    IfcPixelTexture::from_parameters(typed_parameter.parameters)
                };
                Some((
                    entity.type_id(),
                    std::any::type_name::<IfcPixelTexture>(),
                    Box::new(entity),
                ))
            }
            "IFCPLANARBOX" => {
                let entity = if own_parameters_only {
                    IfcPlanarBox::from_own_parameters(typed_parameter.parameters)
                } else {
                    IfcPlanarBox::from_parameters(typed_parameter.parameters)
                };
                Some((
                    entity.type_id(),
                    std::any::type_name::<IfcPlanarBox>(),
                    Box::new(entity),
                ))
            }
            "IFCPLANAREXTENT" => {
                let entity = IfcPlanarExtent::from_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<IfcPlanarExtent>(),
                    Box::new(entity),
                ))
            }
            "IFCPLANE" => {
                let entity = IfcPlane::from_parameters(typed_parameter.parameters);
                Some((entity.type_id(), std::any::type_name::<IfcPlane>(), Box::new(entity)))
            }
            "IFCPLATE" => {
                let entity = if own_parameters_only {
                    IfcPlate::from_own_parameters(typed_parameter.parameters)
                } else {
                    IfcPlate::from_parameters(typed_parameter.parameters)
                };
                Some((entity.type_id(), std::any::type_name::<IfcPlate>(), Box::new(entity)))
            }
            "IFCPLATESTANDARDCASE" => {
                let entity = IfcPlateStandardCase::from_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<IfcPlateStandardCase>(),
                    Box::new(entity),
                ))
            }
            "IFCPLATETYPE" => {
                let entity = if own_parameters_only {
                    IfcPlateType::from_own_parameters(typed_parameter.parameters)
                } else {
                    IfcPlateType::from_parameters(typed_parameter.parameters)
                };
                Some((
                    entity.type_id(),
                    std::any::type_name::<IfcPlateType>(),
                    Box::new(entity),
                ))
            }
            "IFCPOINTONCURVE" => {
                let entity = IfcPointOnCurve::from_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<IfcPointOnCurve>(),
                    Box::new(entity),
                ))
            }
            "IFCPOINTONSURFACE" => {
                let entity = IfcPointOnSurface::from_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<IfcPointOnSurface>(),
                    Box::new(entity),
                ))
            }
            "IFCPOLYLOOP" => {
                let entity = IfcPolyLoop::from_parameters(typed_parameter.parameters);
                Some((entity.type_id(), std::any::type_name::<IfcPolyLoop>(), Box::new(entity)))
            }
            "IFCPOLYGONALBOUNDEDHALFSPACE" => {
                let entity = if own_parameters_only {
                    IfcPolygonalBoundedHalfSpace::from_own_parameters(typed_parameter.parameters)
                } else {
                    IfcPolygonalBoundedHalfSpace::from_parameters(typed_parameter.parameters)
                };
                Some((
                    entity.type_id(),
                    std::any::type_name::<IfcPolygonalBoundedHalfSpace>(),
                    Box::new(entity),
                ))
            }
            "IFCPOLYGONALFACESET" => {
                let entity = if own_parameters_only {
                    IfcPolygonalFaceSet::from_own_parameters(typed_parameter.parameters)
                } else {
                    IfcPolygonalFaceSet::from_parameters(typed_parameter.parameters)
                };
                Some((
                    entity.type_id(),
                    std::any::type_name::<IfcPolygonalFaceSet>(),
                    Box::new(entity),
                ))
            }
            "IFCPOLYLINE" => {
                let entity = IfcPolyline::from_parameters(typed_parameter.parameters);
                Some((entity.type_id(), std::any::type_name::<IfcPolyline>(), Box::new(entity)))
            }
            "IFCPOSTALADDRESS" => {
                let entity = if own_parameters_only {
                    IfcPostalAddress::from_own_parameters(typed_parameter.parameters)
                } else {
                    IfcPostalAddress::from_parameters(typed_parameter.parameters)
                };
                Some((
                    entity.type_id(),
                    std::any::type_name::<IfcPostalAddress>(),
                    Box::new(entity),
                ))
            }
            "IFCPRESENTATIONLAYERASSIGNMENT" => {
                let entity = IfcPresentationLayerAssignment::from_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<IfcPresentationLayerAssignment>(),
                    Box::new(entity),
                ))
            }
            "IFCPRESENTATIONLAYERWITHSTYLE" => {
                let entity = if own_parameters_only {
                    IfcPresentationLayerWithStyle::from_own_parameters(typed_parameter.parameters)
                } else {
                    IfcPresentationLayerWithStyle::from_parameters(typed_parameter.parameters)
                };
                Some((
                    entity.type_id(),
                    std::any::type_name::<IfcPresentationLayerWithStyle>(),
                    Box::new(entity),
                ))
            }
            "IFCPRESENTATIONSTYLEASSIGNMENT" => {
                let entity = IfcPresentationStyleAssignment::from_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<IfcPresentationStyleAssignment>(),
                    Box::new(entity),
                ))
            }
            "IFCPROCEDURE" => {
                let entity = if own_parameters_only {
                    IfcProcedure::from_own_parameters(typed_parameter.parameters)
                } else {
                    IfcProcedure::from_parameters(typed_parameter.parameters)
                };
                Some((
                    entity.type_id(),
                    std::any::type_name::<IfcProcedure>(),
                    Box::new(entity),
                ))
            }
            "IFCPROCEDURETYPE" => {
                let entity = if own_parameters_only {
                    IfcProcedureType::from_own_parameters(typed_parameter.parameters)
                } else {
                    IfcProcedureType::from_parameters(typed_parameter.parameters)
                };
                Some((
                    entity.type_id(),
                    std::any::type_name::<IfcProcedureType>(),
                    Box::new(entity),
                ))
            }
            "IFCPRODUCTDEFINITIONSHAPE" => {
                let entity = IfcProductDefinitionShape::from_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<IfcProductDefinitionShape>(),
                    Box::new(entity),
                ))
            }
            "IFCPROFILEDEF" => {
                let entity = IfcProfileDef::from_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<IfcProfileDef>(),
                    Box::new(entity),
                ))
            }
            "IFCPROFILEPROPERTIES" => {
                let entity = if own_parameters_only {
                    IfcProfileProperties::from_own_parameters(typed_parameter.parameters)
                } else {
                    IfcProfileProperties::from_parameters(typed_parameter.parameters)
                };
                Some((
                    entity.type_id(),
                    std::any::type_name::<IfcProfileProperties>(),
                    Box::new(entity),
                ))
            }
            "IFCPROJECT" => {
                let entity = IfcProject::from_parameters(typed_parameter.parameters);
                Some((entity.type_id(), std::any::type_name::<IfcProject>(), Box::new(entity)))
            }
            "IFCPROJECTLIBRARY" => {
                let entity = IfcProjectLibrary::from_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<IfcProjectLibrary>(),
                    Box::new(entity),
                ))
            }
            "IFCPROJECTORDER" => {
                let entity = if own_parameters_only {
                    IfcProjectOrder::from_own_parameters(typed_parameter.parameters)
                } else {
                    IfcProjectOrder::from_parameters(typed_parameter.parameters)
                };
                Some((
                    entity.type_id(),
                    std::any::type_name::<IfcProjectOrder>(),
                    Box::new(entity),
                ))
            }
            "IFCPROJECTEDCRS" => {
                let entity = if own_parameters_only {
                    IfcProjectedCrs::from_own_parameters(typed_parameter.parameters)
                } else {
                    IfcProjectedCrs::from_parameters(typed_parameter.parameters)
                };
                Some((
                    entity.type_id(),
                    std::any::type_name::<IfcProjectedCrs>(),
                    Box::new(entity),
                ))
            }
            "IFCPROJECTIONELEMENT" => {
                let entity = if own_parameters_only {
                    IfcProjectionElement::from_own_parameters(typed_parameter.parameters)
                } else {
                    IfcProjectionElement::from_parameters(typed_parameter.parameters)
                };
                Some((
                    entity.type_id(),
                    std::any::type_name::<IfcProjectionElement>(),
                    Box::new(entity),
                ))
            }
            "IFCPROPERTYBOUNDEDVALUE" => {
                let entity = if own_parameters_only {
                    IfcPropertyBoundedValue::from_own_parameters(typed_parameter.parameters)
                } else {
                    IfcPropertyBoundedValue::from_parameters(typed_parameter.parameters)
                };
                Some((
                    entity.type_id(),
                    std::any::type_name::<IfcPropertyBoundedValue>(),
                    Box::new(entity),
                ))
            }
            "IFCPROPERTYDEPENDENCYRELATIONSHIP" => {
                let entity = if own_parameters_only {
                    IfcPropertyDependencyRelationship::from_own_parameters(typed_parameter.parameters)
                } else {
                    IfcPropertyDependencyRelationship::from_parameters(typed_parameter.parameters)
                };
                Some((
                    entity.type_id(),
                    std::any::type_name::<IfcPropertyDependencyRelationship>(),
                    Box::new(entity),
                ))
            }
            "IFCPROPERTYENUMERATEDVALUE" => {
                let entity = if own_parameters_only {
                    IfcPropertyEnumeratedValue::from_own_parameters(typed_parameter.parameters)
                } else {
                    IfcPropertyEnumeratedValue::from_parameters(typed_parameter.parameters)
                };
                Some((
                    entity.type_id(),
                    std::any::type_name::<IfcPropertyEnumeratedValue>(),
                    Box::new(entity),
                ))
            }
            "IFCPROPERTYENUMERATION" => {
                let entity = IfcPropertyEnumeration::from_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<IfcPropertyEnumeration>(),
                    Box::new(entity),
                ))
            }
            "IFCPROPERTYLISTVALUE" => {
                let entity = if own_parameters_only {
                    IfcPropertyListValue::from_own_parameters(typed_parameter.parameters)
                } else {
                    IfcPropertyListValue::from_parameters(typed_parameter.parameters)
                };
                Some((
                    entity.type_id(),
                    std::any::type_name::<IfcPropertyListValue>(),
                    Box::new(entity),
                ))
            }
            "IFCPROPERTYREFERENCEVALUE" => {
                let entity = if own_parameters_only {
                    IfcPropertyReferenceValue::from_own_parameters(typed_parameter.parameters)
                } else {
                    IfcPropertyReferenceValue::from_parameters(typed_parameter.parameters)
                };
                Some((
                    entity.type_id(),
                    std::any::type_name::<IfcPropertyReferenceValue>(),
                    Box::new(entity),
                ))
            }
            "IFCPROPERTYSET" => {
                let entity = if own_parameters_only {
                    IfcPropertySet::from_own_parameters(typed_parameter.parameters)
                } else {
                    IfcPropertySet::from_parameters(typed_parameter.parameters)
                };
                Some((
                    entity.type_id(),
                    std::any::type_name::<IfcPropertySet>(),
                    Box::new(entity),
                ))
            }
            "IFCPROPERTYSETTEMPLATE" => {
                let entity = if own_parameters_only {
                    IfcPropertySetTemplate::from_own_parameters(typed_parameter.parameters)
                } else {
                    IfcPropertySetTemplate::from_parameters(typed_parameter.parameters)
                };
                Some((
                    entity.type_id(),
                    std::any::type_name::<IfcPropertySetTemplate>(),
                    Box::new(entity),
                ))
            }
            "IFCPROPERTYSINGLEVALUE" => {
                let entity = if own_parameters_only {
                    IfcPropertySingleValue::from_own_parameters(typed_parameter.parameters)
                } else {
                    IfcPropertySingleValue::from_parameters(typed_parameter.parameters)
                };
                Some((
                    entity.type_id(),
                    std::any::type_name::<IfcPropertySingleValue>(),
                    Box::new(entity),
                ))
            }
            "IFCPROPERTYTABLEVALUE" => {
                let entity = if own_parameters_only {
                    IfcPropertyTableValue::from_own_parameters(typed_parameter.parameters)
                } else {
                    IfcPropertyTableValue::from_parameters(typed_parameter.parameters)
                };
                Some((
                    entity.type_id(),
                    std::any::type_name::<IfcPropertyTableValue>(),
                    Box::new(entity),
                ))
            }
            "IFCPROTECTIVEDEVICE" => {
                let entity = if own_parameters_only {
                    IfcProtectiveDevice::from_own_parameters(typed_parameter.parameters)
                } else {
                    IfcProtectiveDevice::from_parameters(typed_parameter.parameters)
                };
                Some((
                    entity.type_id(),
                    std::any::type_name::<IfcProtectiveDevice>(),
                    Box::new(entity),
                ))
            }
            "IFCPROTECTIVEDEVICETRIPPINGUNIT" => {
                let entity = if own_parameters_only {
                    IfcProtectiveDeviceTrippingUnit::from_own_parameters(typed_parameter.parameters)
                } else {
                    IfcProtectiveDeviceTrippingUnit::from_parameters(typed_parameter.parameters)
                };
                Some((
                    entity.type_id(),
                    std::any::type_name::<IfcProtectiveDeviceTrippingUnit>(),
                    Box::new(entity),
                ))
            }
            "IFCPROTECTIVEDEVICETRIPPINGUNITTYPE" => {
                let entity = if own_parameters_only {
                    IfcProtectiveDeviceTrippingUnitType::from_own_parameters(typed_parameter.parameters)
                } else {
                    IfcProtectiveDeviceTrippingUnitType::from_parameters(typed_parameter.parameters)
                };
                Some((
                    entity.type_id(),
                    std::any::type_name::<IfcProtectiveDeviceTrippingUnitType>(),
                    Box::new(entity),
                ))
            }
            "IFCPROTECTIVEDEVICETYPE" => {
                let entity = if own_parameters_only {
                    IfcProtectiveDeviceType::from_own_parameters(typed_parameter.parameters)
                } else {
                    IfcProtectiveDeviceType::from_parameters(typed_parameter.parameters)
                };
                Some((
                    entity.type_id(),
                    std::any::type_name::<IfcProtectiveDeviceType>(),
                    Box::new(entity),
                ))
            }
            "IFCPROXY" => {
                let entity = if own_parameters_only {
                    IfcProxy::from_own_parameters(typed_parameter.parameters)
                } else {
                    IfcProxy::from_parameters(typed_parameter.parameters)
                };
                Some((entity.type_id(), std::any::type_name::<IfcProxy>(), Box::new(entity)))
            }
            "IFCPUMP" => {
                let entity = if own_parameters_only {
                    IfcPump::from_own_parameters(typed_parameter.parameters)
                } else {
                    IfcPump::from_parameters(typed_parameter.parameters)
                };
                Some((entity.type_id(), std::any::type_name::<IfcPump>(), Box::new(entity)))
            }
            "IFCPUMPTYPE" => {
                let entity = if own_parameters_only {
                    IfcPumpType::from_own_parameters(typed_parameter.parameters)
                } else {
                    IfcPumpType::from_parameters(typed_parameter.parameters)
                };
                Some((entity.type_id(), std::any::type_name::<IfcPumpType>(), Box::new(entity)))
            }
            "IFCQUANTITYAREA" => {
                let entity = if own_parameters_only {
                    IfcQuantityArea::from_own_parameters(typed_parameter.parameters)
                } else {
                    IfcQuantityArea::from_parameters(typed_parameter.parameters)
                };
                Some((
                    entity.type_id(),
                    std::any::type_name::<IfcQuantityArea>(),
                    Box::new(entity),
                ))
            }
            "IFCQUANTITYCOUNT" => {
                let entity = if own_parameters_only {
                    IfcQuantityCount::from_own_parameters(typed_parameter.parameters)
                } else {
                    IfcQuantityCount::from_parameters(typed_parameter.parameters)
                };
                Some((
                    entity.type_id(),
                    std::any::type_name::<IfcQuantityCount>(),
                    Box::new(entity),
                ))
            }
            "IFCQUANTITYLENGTH" => {
                let entity = if own_parameters_only {
                    IfcQuantityLength::from_own_parameters(typed_parameter.parameters)
                } else {
                    IfcQuantityLength::from_parameters(typed_parameter.parameters)
                };
                Some((
                    entity.type_id(),
                    std::any::type_name::<IfcQuantityLength>(),
                    Box::new(entity),
                ))
            }
            "IFCQUANTITYTIME" => {
                let entity = if own_parameters_only {
                    IfcQuantityTime::from_own_parameters(typed_parameter.parameters)
                } else {
                    IfcQuantityTime::from_parameters(typed_parameter.parameters)
                };
                Some((
                    entity.type_id(),
                    std::any::type_name::<IfcQuantityTime>(),
                    Box::new(entity),
                ))
            }
            "IFCQUANTITYVOLUME" => {
                let entity = if own_parameters_only {
                    IfcQuantityVolume::from_own_parameters(typed_parameter.parameters)
                } else {
                    IfcQuantityVolume::from_parameters(typed_parameter.parameters)
                };
                Some((
                    entity.type_id(),
                    std::any::type_name::<IfcQuantityVolume>(),
                    Box::new(entity),
                ))
            }
            "IFCQUANTITYWEIGHT" => {
                let entity = if own_parameters_only {
                    IfcQuantityWeight::from_own_parameters(typed_parameter.parameters)
                } else {
                    IfcQuantityWeight::from_parameters(typed_parameter.parameters)
                };
                Some((
                    entity.type_id(),
                    std::any::type_name::<IfcQuantityWeight>(),
                    Box::new(entity),
                ))
            }
            "IFCRAILING" => {
                let entity = if own_parameters_only {
                    IfcRailing::from_own_parameters(typed_parameter.parameters)
                } else {
                    IfcRailing::from_parameters(typed_parameter.parameters)
                };
                Some((entity.type_id(), std::any::type_name::<IfcRailing>(), Box::new(entity)))
            }
            "IFCRAILINGTYPE" => {
                let entity = if own_parameters_only {
                    IfcRailingType::from_own_parameters(typed_parameter.parameters)
                } else {
                    IfcRailingType::from_parameters(typed_parameter.parameters)
                };
                Some((
                    entity.type_id(),
                    std::any::type_name::<IfcRailingType>(),
                    Box::new(entity),
                ))
            }
            "IFCRAMP" => {
                let entity = if own_parameters_only {
                    IfcRamp::from_own_parameters(typed_parameter.parameters)
                } else {
                    IfcRamp::from_parameters(typed_parameter.parameters)
                };
                Some((entity.type_id(), std::any::type_name::<IfcRamp>(), Box::new(entity)))
            }
            "IFCRAMPFLIGHT" => {
                let entity = if own_parameters_only {
                    IfcRampFlight::from_own_parameters(typed_parameter.parameters)
                } else {
                    IfcRampFlight::from_parameters(typed_parameter.parameters)
                };
                Some((
                    entity.type_id(),
                    std::any::type_name::<IfcRampFlight>(),
                    Box::new(entity),
                ))
            }
            "IFCRAMPFLIGHTTYPE" => {
                let entity = if own_parameters_only {
                    IfcRampFlightType::from_own_parameters(typed_parameter.parameters)
                } else {
                    IfcRampFlightType::from_parameters(typed_parameter.parameters)
                };
                Some((
                    entity.type_id(),
                    std::any::type_name::<IfcRampFlightType>(),
                    Box::new(entity),
                ))
            }
            "IFCRAMPTYPE" => {
                let entity = if own_parameters_only {
                    IfcRampType::from_own_parameters(typed_parameter.parameters)
                } else {
                    IfcRampType::from_parameters(typed_parameter.parameters)
                };
                Some((entity.type_id(), std::any::type_name::<IfcRampType>(), Box::new(entity)))
            }
            "IFCRATIONALBSPLINECURVEWITHKNOTS" => {
                let entity = if own_parameters_only {
                    IfcRationalBSplineCurveWithKnots::from_own_parameters(typed_parameter.parameters)
                } else {
                    IfcRationalBSplineCurveWithKnots::from_parameters(typed_parameter.parameters)
                };
                Some((
                    entity.type_id(),
                    std::any::type_name::<IfcRationalBSplineCurveWithKnots>(),
                    Box::new(entity),
                ))
            }
            "IFCRATIONALBSPLINESURFACEWITHKNOTS" => {
                let entity = if own_parameters_only {
                    IfcRationalBSplineSurfaceWithKnots::from_own_parameters(typed_parameter.parameters)
                } else {
                    IfcRationalBSplineSurfaceWithKnots::from_parameters(typed_parameter.parameters)
                };
                Some((
                    entity.type_id(),
                    std::any::type_name::<IfcRationalBSplineSurfaceWithKnots>(),
                    Box::new(entity),
                ))
            }
            "IFCRECTANGLEHOLLOWPROFILEDEF" => {
                let entity = if own_parameters_only {
                    IfcRectangleHollowProfileDef::from_own_parameters(typed_parameter.parameters)
                } else {
                    IfcRectangleHollowProfileDef::from_parameters(typed_parameter.parameters)
                };
                Some((
                    entity.type_id(),
                    std::any::type_name::<IfcRectangleHollowProfileDef>(),
                    Box::new(entity),
                ))
            }
            "IFCRECTANGLEPROFILEDEF" => {
                let entity = if own_parameters_only {
                    IfcRectangleProfileDef::from_own_parameters(typed_parameter.parameters)
                } else {
                    IfcRectangleProfileDef::from_parameters(typed_parameter.parameters)
                };
                Some((
                    entity.type_id(),
                    std::any::type_name::<IfcRectangleProfileDef>(),
                    Box::new(entity),
                ))
            }
            "IFCRECTANGULARPYRAMID" => {
                let entity = if own_parameters_only {
                    IfcRectangularPyramid::from_own_parameters(typed_parameter.parameters)
                } else {
                    IfcRectangularPyramid::from_parameters(typed_parameter.parameters)
                };
                Some((
                    entity.type_id(),
                    std::any::type_name::<IfcRectangularPyramid>(),
                    Box::new(entity),
                ))
            }
            "IFCRECTANGULARTRIMMEDSURFACE" => {
                let entity = IfcRectangularTrimmedSurface::from_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<IfcRectangularTrimmedSurface>(),
                    Box::new(entity),
                ))
            }
            "IFCRECURRENCEPATTERN" => {
                let entity = IfcRecurrencePattern::from_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<IfcRecurrencePattern>(),
                    Box::new(entity),
                ))
            }
            "IFCREFERENCE" => {
                let entity = IfcReference::from_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<IfcReference>(),
                    Box::new(entity),
                ))
            }
            "IFCREGULARTIMESERIES" => {
                let entity = if own_parameters_only {
                    IfcRegularTimeSeries::from_own_parameters(typed_parameter.parameters)
                } else {
                    IfcRegularTimeSeries::from_parameters(typed_parameter.parameters)
                };
                Some((
                    entity.type_id(),
                    std::any::type_name::<IfcRegularTimeSeries>(),
                    Box::new(entity),
                ))
            }
            "IFCREINFORCEMENTBARPROPERTIES" => {
                let entity = IfcReinforcementBarProperties::from_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<IfcReinforcementBarProperties>(),
                    Box::new(entity),
                ))
            }
            "IFCREINFORCEMENTDEFINITIONPROPERTIES" => {
                let entity = if own_parameters_only {
                    IfcReinforcementDefinitionProperties::from_own_parameters(typed_parameter.parameters)
                } else {
                    IfcReinforcementDefinitionProperties::from_parameters(typed_parameter.parameters)
                };
                Some((
                    entity.type_id(),
                    std::any::type_name::<IfcReinforcementDefinitionProperties>(),
                    Box::new(entity),
                ))
            }
            "IFCREINFORCINGBAR" => {
                let entity = if own_parameters_only {
                    IfcReinforcingBar::from_own_parameters(typed_parameter.parameters)
                } else {
                    IfcReinforcingBar::from_parameters(typed_parameter.parameters)
                };
                Some((
                    entity.type_id(),
                    std::any::type_name::<IfcReinforcingBar>(),
                    Box::new(entity),
                ))
            }
            "IFCREINFORCINGBARTYPE" => {
                let entity = if own_parameters_only {
                    IfcReinforcingBarType::from_own_parameters(typed_parameter.parameters)
                } else {
                    IfcReinforcingBarType::from_parameters(typed_parameter.parameters)
                };
                Some((
                    entity.type_id(),
                    std::any::type_name::<IfcReinforcingBarType>(),
                    Box::new(entity),
                ))
            }
            "IFCREINFORCINGMESH" => {
                let entity = if own_parameters_only {
                    IfcReinforcingMesh::from_own_parameters(typed_parameter.parameters)
                } else {
                    IfcReinforcingMesh::from_parameters(typed_parameter.parameters)
                };
                Some((
                    entity.type_id(),
                    std::any::type_name::<IfcReinforcingMesh>(),
                    Box::new(entity),
                ))
            }
            "IFCREINFORCINGMESHTYPE" => {
                let entity = if own_parameters_only {
                    IfcReinforcingMeshType::from_own_parameters(typed_parameter.parameters)
                } else {
                    IfcReinforcingMeshType::from_parameters(typed_parameter.parameters)
                };
                Some((
                    entity.type_id(),
                    std::any::type_name::<IfcReinforcingMeshType>(),
                    Box::new(entity),
                ))
            }
            "IFCRELAGGREGATES" => {
                let entity = if own_parameters_only {
                    IfcRelAggregates::from_own_parameters(typed_parameter.parameters)
                } else {
                    IfcRelAggregates::from_parameters(typed_parameter.parameters)
                };
                Some((
                    entity.type_id(),
                    std::any::type_name::<IfcRelAggregates>(),
                    Box::new(entity),
                ))
            }
            "IFCRELASSIGNSTOACTOR" => {
                let entity = if own_parameters_only {
                    IfcRelAssignsToActor::from_own_parameters(typed_parameter.parameters)
                } else {
                    IfcRelAssignsToActor::from_parameters(typed_parameter.parameters)
                };
                Some((
                    entity.type_id(),
                    std::any::type_name::<IfcRelAssignsToActor>(),
                    Box::new(entity),
                ))
            }
            "IFCRELASSIGNSTOCONTROL" => {
                let entity = if own_parameters_only {
                    IfcRelAssignsToControl::from_own_parameters(typed_parameter.parameters)
                } else {
                    IfcRelAssignsToControl::from_parameters(typed_parameter.parameters)
                };
                Some((
                    entity.type_id(),
                    std::any::type_name::<IfcRelAssignsToControl>(),
                    Box::new(entity),
                ))
            }
            "IFCRELASSIGNSTOGROUP" => {
                let entity = if own_parameters_only {
                    IfcRelAssignsToGroup::from_own_parameters(typed_parameter.parameters)
                } else {
                    IfcRelAssignsToGroup::from_parameters(typed_parameter.parameters)
                };
                Some((
                    entity.type_id(),
                    std::any::type_name::<IfcRelAssignsToGroup>(),
                    Box::new(entity),
                ))
            }
            "IFCRELASSIGNSTOGROUPBYFACTOR" => {
                let entity = if own_parameters_only {
                    IfcRelAssignsToGroupByFactor::from_own_parameters(typed_parameter.parameters)
                } else {
                    IfcRelAssignsToGroupByFactor::from_parameters(typed_parameter.parameters)
                };
                Some((
                    entity.type_id(),
                    std::any::type_name::<IfcRelAssignsToGroupByFactor>(),
                    Box::new(entity),
                ))
            }
            "IFCRELASSIGNSTOPROCESS" => {
                let entity = if own_parameters_only {
                    IfcRelAssignsToProcess::from_own_parameters(typed_parameter.parameters)
                } else {
                    IfcRelAssignsToProcess::from_parameters(typed_parameter.parameters)
                };
                Some((
                    entity.type_id(),
                    std::any::type_name::<IfcRelAssignsToProcess>(),
                    Box::new(entity),
                ))
            }
            "IFCRELASSIGNSTOPRODUCT" => {
                let entity = if own_parameters_only {
                    IfcRelAssignsToProduct::from_own_parameters(typed_parameter.parameters)
                } else {
                    IfcRelAssignsToProduct::from_parameters(typed_parameter.parameters)
                };
                Some((
                    entity.type_id(),
                    std::any::type_name::<IfcRelAssignsToProduct>(),
                    Box::new(entity),
                ))
            }
            "IFCRELASSIGNSTORESOURCE" => {
                let entity = if own_parameters_only {
                    IfcRelAssignsToResource::from_own_parameters(typed_parameter.parameters)
                } else {
                    IfcRelAssignsToResource::from_parameters(typed_parameter.parameters)
                };
                Some((
                    entity.type_id(),
                    std::any::type_name::<IfcRelAssignsToResource>(),
                    Box::new(entity),
                ))
            }
            "IFCRELASSOCIATESAPPROVAL" => {
                let entity = if own_parameters_only {
                    IfcRelAssociatesApproval::from_own_parameters(typed_parameter.parameters)
                } else {
                    IfcRelAssociatesApproval::from_parameters(typed_parameter.parameters)
                };
                Some((
                    entity.type_id(),
                    std::any::type_name::<IfcRelAssociatesApproval>(),
                    Box::new(entity),
                ))
            }
            "IFCRELASSOCIATESCLASSIFICATION" => {
                let entity = if own_parameters_only {
                    IfcRelAssociatesClassification::from_own_parameters(typed_parameter.parameters)
                } else {
                    IfcRelAssociatesClassification::from_parameters(typed_parameter.parameters)
                };
                Some((
                    entity.type_id(),
                    std::any::type_name::<IfcRelAssociatesClassification>(),
                    Box::new(entity),
                ))
            }
            "IFCRELASSOCIATESCONSTRAINT" => {
                let entity = if own_parameters_only {
                    IfcRelAssociatesConstraint::from_own_parameters(typed_parameter.parameters)
                } else {
                    IfcRelAssociatesConstraint::from_parameters(typed_parameter.parameters)
                };
                Some((
                    entity.type_id(),
                    std::any::type_name::<IfcRelAssociatesConstraint>(),
                    Box::new(entity),
                ))
            }
            "IFCRELASSOCIATESDOCUMENT" => {
                let entity = if own_parameters_only {
                    IfcRelAssociatesDocument::from_own_parameters(typed_parameter.parameters)
                } else {
                    IfcRelAssociatesDocument::from_parameters(typed_parameter.parameters)
                };
                Some((
                    entity.type_id(),
                    std::any::type_name::<IfcRelAssociatesDocument>(),
                    Box::new(entity),
                ))
            }
            "IFCRELASSOCIATESLIBRARY" => {
                let entity = if own_parameters_only {
                    IfcRelAssociatesLibrary::from_own_parameters(typed_parameter.parameters)
                } else {
                    IfcRelAssociatesLibrary::from_parameters(typed_parameter.parameters)
                };
                Some((
                    entity.type_id(),
                    std::any::type_name::<IfcRelAssociatesLibrary>(),
                    Box::new(entity),
                ))
            }
            "IFCRELASSOCIATESMATERIAL" => {
                let entity = if own_parameters_only {
                    IfcRelAssociatesMaterial::from_own_parameters(typed_parameter.parameters)
                } else {
                    IfcRelAssociatesMaterial::from_parameters(typed_parameter.parameters)
                };
                Some((
                    entity.type_id(),
                    std::any::type_name::<IfcRelAssociatesMaterial>(),
                    Box::new(entity),
                ))
            }
            "IFCRELCONNECTSELEMENTS" => {
                let entity = if own_parameters_only {
                    IfcRelConnectsElements::from_own_parameters(typed_parameter.parameters)
                } else {
                    IfcRelConnectsElements::from_parameters(typed_parameter.parameters)
                };
                Some((
                    entity.type_id(),
                    std::any::type_name::<IfcRelConnectsElements>(),
                    Box::new(entity),
                ))
            }
            "IFCRELCONNECTSPATHELEMENTS" => {
                let entity = if own_parameters_only {
                    IfcRelConnectsPathElements::from_own_parameters(typed_parameter.parameters)
                } else {
                    IfcRelConnectsPathElements::from_parameters(typed_parameter.parameters)
                };
                Some((
                    entity.type_id(),
                    std::any::type_name::<IfcRelConnectsPathElements>(),
                    Box::new(entity),
                ))
            }
            "IFCRELCONNECTSPORTTOELEMENT" => {
                let entity = if own_parameters_only {
                    IfcRelConnectsPortToElement::from_own_parameters(typed_parameter.parameters)
                } else {
                    IfcRelConnectsPortToElement::from_parameters(typed_parameter.parameters)
                };
                Some((
                    entity.type_id(),
                    std::any::type_name::<IfcRelConnectsPortToElement>(),
                    Box::new(entity),
                ))
            }
            "IFCRELCONNECTSPORTS" => {
                let entity = if own_parameters_only {
                    IfcRelConnectsPorts::from_own_parameters(typed_parameter.parameters)
                } else {
                    IfcRelConnectsPorts::from_parameters(typed_parameter.parameters)
                };
                Some((
                    entity.type_id(),
                    std::any::type_name::<IfcRelConnectsPorts>(),
                    Box::new(entity),
                ))
            }
            "IFCRELCONNECTSSTRUCTURALACTIVITY" => {
                let entity = if own_parameters_only {
                    IfcRelConnectsStructuralActivity::from_own_parameters(typed_parameter.parameters)
                } else {
                    IfcRelConnectsStructuralActivity::from_parameters(typed_parameter.parameters)
                };
                Some((
                    entity.type_id(),
                    std::any::type_name::<IfcRelConnectsStructuralActivity>(),
                    Box::new(entity),
                ))
            }
            "IFCRELCONNECTSSTRUCTURALMEMBER" => {
                let entity = if own_parameters_only {
                    IfcRelConnectsStructuralMember::from_own_parameters(typed_parameter.parameters)
                } else {
                    IfcRelConnectsStructuralMember::from_parameters(typed_parameter.parameters)
                };
                Some((
                    entity.type_id(),
                    std::any::type_name::<IfcRelConnectsStructuralMember>(),
                    Box::new(entity),
                ))
            }
            "IFCRELCONNECTSWITHECCENTRICITY" => {
                let entity = if own_parameters_only {
                    IfcRelConnectsWithEccentricity::from_own_parameters(typed_parameter.parameters)
                } else {
                    IfcRelConnectsWithEccentricity::from_parameters(typed_parameter.parameters)
                };
                Some((
                    entity.type_id(),
                    std::any::type_name::<IfcRelConnectsWithEccentricity>(),
                    Box::new(entity),
                ))
            }
            "IFCRELCONNECTSWITHREALIZINGELEMENTS" => {
                let entity = if own_parameters_only {
                    IfcRelConnectsWithRealizingElements::from_own_parameters(typed_parameter.parameters)
                } else {
                    IfcRelConnectsWithRealizingElements::from_parameters(typed_parameter.parameters)
                };
                Some((
                    entity.type_id(),
                    std::any::type_name::<IfcRelConnectsWithRealizingElements>(),
                    Box::new(entity),
                ))
            }
            "IFCRELCONTAINEDINSPATIALSTRUCTURE" => {
                let entity = if own_parameters_only {
                    IfcRelContainedInSpatialStructure::from_own_parameters(typed_parameter.parameters)
                } else {
                    IfcRelContainedInSpatialStructure::from_parameters(typed_parameter.parameters)
                };
                Some((
                    entity.type_id(),
                    std::any::type_name::<IfcRelContainedInSpatialStructure>(),
                    Box::new(entity),
                ))
            }
            "IFCRELCOVERSBLDGELEMENTS" => {
                let entity = if own_parameters_only {
                    IfcRelCoversBldgElements::from_own_parameters(typed_parameter.parameters)
                } else {
                    IfcRelCoversBldgElements::from_parameters(typed_parameter.parameters)
                };
                Some((
                    entity.type_id(),
                    std::any::type_name::<IfcRelCoversBldgElements>(),
                    Box::new(entity),
                ))
            }
            "IFCRELCOVERSSPACES" => {
                let entity = if own_parameters_only {
                    IfcRelCoversSpaces::from_own_parameters(typed_parameter.parameters)
                } else {
                    IfcRelCoversSpaces::from_parameters(typed_parameter.parameters)
                };
                Some((
                    entity.type_id(),
                    std::any::type_name::<IfcRelCoversSpaces>(),
                    Box::new(entity),
                ))
            }
            "IFCRELDECLARES" => {
                let entity = if own_parameters_only {
                    IfcRelDeclares::from_own_parameters(typed_parameter.parameters)
                } else {
                    IfcRelDeclares::from_parameters(typed_parameter.parameters)
                };
                Some((
                    entity.type_id(),
                    std::any::type_name::<IfcRelDeclares>(),
                    Box::new(entity),
                ))
            }
            "IFCRELDEFINESBYOBJECT" => {
                let entity = if own_parameters_only {
                    IfcRelDefinesByObject::from_own_parameters(typed_parameter.parameters)
                } else {
                    IfcRelDefinesByObject::from_parameters(typed_parameter.parameters)
                };
                Some((
                    entity.type_id(),
                    std::any::type_name::<IfcRelDefinesByObject>(),
                    Box::new(entity),
                ))
            }
            "IFCRELDEFINESBYPROPERTIES" => {
                let entity = if own_parameters_only {
                    IfcRelDefinesByProperties::from_own_parameters(typed_parameter.parameters)
                } else {
                    IfcRelDefinesByProperties::from_parameters(typed_parameter.parameters)
                };
                Some((
                    entity.type_id(),
                    std::any::type_name::<IfcRelDefinesByProperties>(),
                    Box::new(entity),
                ))
            }
            "IFCRELDEFINESBYTEMPLATE" => {
                let entity = if own_parameters_only {
                    IfcRelDefinesByTemplate::from_own_parameters(typed_parameter.parameters)
                } else {
                    IfcRelDefinesByTemplate::from_parameters(typed_parameter.parameters)
                };
                Some((
                    entity.type_id(),
                    std::any::type_name::<IfcRelDefinesByTemplate>(),
                    Box::new(entity),
                ))
            }
            "IFCRELDEFINESBYTYPE" => {
                let entity = if own_parameters_only {
                    IfcRelDefinesByType::from_own_parameters(typed_parameter.parameters)
                } else {
                    IfcRelDefinesByType::from_parameters(typed_parameter.parameters)
                };
                Some((
                    entity.type_id(),
                    std::any::type_name::<IfcRelDefinesByType>(),
                    Box::new(entity),
                ))
            }
            "IFCRELFILLSELEMENT" => {
                let entity = if own_parameters_only {
                    IfcRelFillsElement::from_own_parameters(typed_parameter.parameters)
                } else {
                    IfcRelFillsElement::from_parameters(typed_parameter.parameters)
                };
                Some((
                    entity.type_id(),
                    std::any::type_name::<IfcRelFillsElement>(),
                    Box::new(entity),
                ))
            }
            "IFCRELFLOWCONTROLELEMENTS" => {
                let entity = if own_parameters_only {
                    IfcRelFlowControlElements::from_own_parameters(typed_parameter.parameters)
                } else {
                    IfcRelFlowControlElements::from_parameters(typed_parameter.parameters)
                };
                Some((
                    entity.type_id(),
                    std::any::type_name::<IfcRelFlowControlElements>(),
                    Box::new(entity),
                ))
            }
            "IFCRELINTERFERESELEMENTS" => {
                let entity = if own_parameters_only {
                    IfcRelInterferesElements::from_own_parameters(typed_parameter.parameters)
                } else {
                    IfcRelInterferesElements::from_parameters(typed_parameter.parameters)
                };
                Some((
                    entity.type_id(),
                    std::any::type_name::<IfcRelInterferesElements>(),
                    Box::new(entity),
                ))
            }
            "IFCRELNESTS" => {
                let entity = if own_parameters_only {
                    IfcRelNests::from_own_parameters(typed_parameter.parameters)
                } else {
                    IfcRelNests::from_parameters(typed_parameter.parameters)
                };
                Some((entity.type_id(), std::any::type_name::<IfcRelNests>(), Box::new(entity)))
            }
            "IFCRELPROJECTSELEMENT" => {
                let entity = if own_parameters_only {
                    IfcRelProjectsElement::from_own_parameters(typed_parameter.parameters)
                } else {
                    IfcRelProjectsElement::from_parameters(typed_parameter.parameters)
                };
                Some((
                    entity.type_id(),
                    std::any::type_name::<IfcRelProjectsElement>(),
                    Box::new(entity),
                ))
            }
            "IFCRELREFERENCEDINSPATIALSTRUCTURE" => {
                let entity = if own_parameters_only {
                    IfcRelReferencedInSpatialStructure::from_own_parameters(typed_parameter.parameters)
                } else {
                    IfcRelReferencedInSpatialStructure::from_parameters(typed_parameter.parameters)
                };
                Some((
                    entity.type_id(),
                    std::any::type_name::<IfcRelReferencedInSpatialStructure>(),
                    Box::new(entity),
                ))
            }
            "IFCRELSEQUENCE" => {
                let entity = if own_parameters_only {
                    IfcRelSequence::from_own_parameters(typed_parameter.parameters)
                } else {
                    IfcRelSequence::from_parameters(typed_parameter.parameters)
                };
                Some((
                    entity.type_id(),
                    std::any::type_name::<IfcRelSequence>(),
                    Box::new(entity),
                ))
            }
            "IFCRELSERVICESBUILDINGS" => {
                let entity = if own_parameters_only {
                    IfcRelServicesBuildings::from_own_parameters(typed_parameter.parameters)
                } else {
                    IfcRelServicesBuildings::from_parameters(typed_parameter.parameters)
                };
                Some((
                    entity.type_id(),
                    std::any::type_name::<IfcRelServicesBuildings>(),
                    Box::new(entity),
                ))
            }
            "IFCRELSPACEBOUNDARY" => {
                let entity = if own_parameters_only {
                    IfcRelSpaceBoundary::from_own_parameters(typed_parameter.parameters)
                } else {
                    IfcRelSpaceBoundary::from_parameters(typed_parameter.parameters)
                };
                Some((
                    entity.type_id(),
                    std::any::type_name::<IfcRelSpaceBoundary>(),
                    Box::new(entity),
                ))
            }
            "IFCRELSPACEBOUNDARY1STLEVEL" => {
                let entity = if own_parameters_only {
                    IfcRelSpaceBoundary1stLevel::from_own_parameters(typed_parameter.parameters)
                } else {
                    IfcRelSpaceBoundary1stLevel::from_parameters(typed_parameter.parameters)
                };
                Some((
                    entity.type_id(),
                    std::any::type_name::<IfcRelSpaceBoundary1stLevel>(),
                    Box::new(entity),
                ))
            }
            "IFCRELSPACEBOUNDARY2NDLEVEL" => {
                let entity = if own_parameters_only {
                    IfcRelSpaceBoundary2ndLevel::from_own_parameters(typed_parameter.parameters)
                } else {
                    IfcRelSpaceBoundary2ndLevel::from_parameters(typed_parameter.parameters)
                };
                Some((
                    entity.type_id(),
                    std::any::type_name::<IfcRelSpaceBoundary2ndLevel>(),
                    Box::new(entity),
                ))
            }
            "IFCRELVOIDSELEMENT" => {
                let entity = if own_parameters_only {
                    IfcRelVoidsElement::from_own_parameters(typed_parameter.parameters)
                } else {
                    IfcRelVoidsElement::from_parameters(typed_parameter.parameters)
                };
                Some((
                    entity.type_id(),
                    std::any::type_name::<IfcRelVoidsElement>(),
                    Box::new(entity),
                ))
            }
            "IFCREPARAMETRISEDCOMPOSITECURVESEGMENT" => {
                let entity = if own_parameters_only {
                    IfcReparametrisedCompositeCurveSegment::from_own_parameters(typed_parameter.parameters)
                } else {
                    IfcReparametrisedCompositeCurveSegment::from_parameters(typed_parameter.parameters)
                };
                Some((
                    entity.type_id(),
                    std::any::type_name::<IfcReparametrisedCompositeCurveSegment>(),
                    Box::new(entity),
                ))
            }
            "IFCREPRESENTATIONMAP" => {
                let entity = IfcRepresentationMap::from_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<IfcRepresentationMap>(),
                    Box::new(entity),
                ))
            }
            "IFCRESOURCEAPPROVALRELATIONSHIP" => {
                let entity = if own_parameters_only {
                    IfcResourceApprovalRelationship::from_own_parameters(typed_parameter.parameters)
                } else {
                    IfcResourceApprovalRelationship::from_parameters(typed_parameter.parameters)
                };
                Some((
                    entity.type_id(),
                    std::any::type_name::<IfcResourceApprovalRelationship>(),
                    Box::new(entity),
                ))
            }
            "IFCRESOURCECONSTRAINTRELATIONSHIP" => {
                let entity = if own_parameters_only {
                    IfcResourceConstraintRelationship::from_own_parameters(typed_parameter.parameters)
                } else {
                    IfcResourceConstraintRelationship::from_parameters(typed_parameter.parameters)
                };
                Some((
                    entity.type_id(),
                    std::any::type_name::<IfcResourceConstraintRelationship>(),
                    Box::new(entity),
                ))
            }
            "IFCRESOURCETIME" => {
                let entity = if own_parameters_only {
                    IfcResourceTime::from_own_parameters(typed_parameter.parameters)
                } else {
                    IfcResourceTime::from_parameters(typed_parameter.parameters)
                };
                Some((
                    entity.type_id(),
                    std::any::type_name::<IfcResourceTime>(),
                    Box::new(entity),
                ))
            }
            "IFCREVOLVEDAREASOLID" => {
                let entity = if own_parameters_only {
                    IfcRevolvedAreaSolid::from_own_parameters(typed_parameter.parameters)
                } else {
                    IfcRevolvedAreaSolid::from_parameters(typed_parameter.parameters)
                };
                Some((
                    entity.type_id(),
                    std::any::type_name::<IfcRevolvedAreaSolid>(),
                    Box::new(entity),
                ))
            }
            "IFCREVOLVEDAREASOLIDTAPERED" => {
                let entity = if own_parameters_only {
                    IfcRevolvedAreaSolidTapered::from_own_parameters(typed_parameter.parameters)
                } else {
                    IfcRevolvedAreaSolidTapered::from_parameters(typed_parameter.parameters)
                };
                Some((
                    entity.type_id(),
                    std::any::type_name::<IfcRevolvedAreaSolidTapered>(),
                    Box::new(entity),
                ))
            }
            "IFCRIGHTCIRCULARCONE" => {
                let entity = if own_parameters_only {
                    IfcRightCircularCone::from_own_parameters(typed_parameter.parameters)
                } else {
                    IfcRightCircularCone::from_parameters(typed_parameter.parameters)
                };
                Some((
                    entity.type_id(),
                    std::any::type_name::<IfcRightCircularCone>(),
                    Box::new(entity),
                ))
            }
            "IFCRIGHTCIRCULARCYLINDER" => {
                let entity = if own_parameters_only {
                    IfcRightCircularCylinder::from_own_parameters(typed_parameter.parameters)
                } else {
                    IfcRightCircularCylinder::from_parameters(typed_parameter.parameters)
                };
                Some((
                    entity.type_id(),
                    std::any::type_name::<IfcRightCircularCylinder>(),
                    Box::new(entity),
                ))
            }
            "IFCROOF" => {
                let entity = if own_parameters_only {
                    IfcRoof::from_own_parameters(typed_parameter.parameters)
                } else {
                    IfcRoof::from_parameters(typed_parameter.parameters)
                };
                Some((entity.type_id(), std::any::type_name::<IfcRoof>(), Box::new(entity)))
            }
            "IFCROOFTYPE" => {
                let entity = if own_parameters_only {
                    IfcRoofType::from_own_parameters(typed_parameter.parameters)
                } else {
                    IfcRoofType::from_parameters(typed_parameter.parameters)
                };
                Some((entity.type_id(), std::any::type_name::<IfcRoofType>(), Box::new(entity)))
            }
            "IFCROUNDEDRECTANGLEPROFILEDEF" => {
                let entity = if own_parameters_only {
                    IfcRoundedRectangleProfileDef::from_own_parameters(typed_parameter.parameters)
                } else {
                    IfcRoundedRectangleProfileDef::from_parameters(typed_parameter.parameters)
                };
                Some((
                    entity.type_id(),
                    std::any::type_name::<IfcRoundedRectangleProfileDef>(),
                    Box::new(entity),
                ))
            }
            "IFCSIUNIT" => {
                let entity = if own_parameters_only {
                    IfcSiUnit::from_own_parameters(typed_parameter.parameters)
                } else {
                    IfcSiUnit::from_parameters(typed_parameter.parameters)
                };
                Some((entity.type_id(), std::any::type_name::<IfcSiUnit>(), Box::new(entity)))
            }
            "IFCSANITARYTERMINAL" => {
                let entity = if own_parameters_only {
                    IfcSanitaryTerminal::from_own_parameters(typed_parameter.parameters)
                } else {
                    IfcSanitaryTerminal::from_parameters(typed_parameter.parameters)
                };
                Some((
                    entity.type_id(),
                    std::any::type_name::<IfcSanitaryTerminal>(),
                    Box::new(entity),
                ))
            }
            "IFCSANITARYTERMINALTYPE" => {
                let entity = if own_parameters_only {
                    IfcSanitaryTerminalType::from_own_parameters(typed_parameter.parameters)
                } else {
                    IfcSanitaryTerminalType::from_parameters(typed_parameter.parameters)
                };
                Some((
                    entity.type_id(),
                    std::any::type_name::<IfcSanitaryTerminalType>(),
                    Box::new(entity),
                ))
            }
            "IFCSEAMCURVE" => {
                let entity = IfcSeamCurve::from_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<IfcSeamCurve>(),
                    Box::new(entity),
                ))
            }
            "IFCSECTIONPROPERTIES" => {
                let entity = IfcSectionProperties::from_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<IfcSectionProperties>(),
                    Box::new(entity),
                ))
            }
            "IFCSECTIONREINFORCEMENTPROPERTIES" => {
                let entity = IfcSectionReinforcementProperties::from_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<IfcSectionReinforcementProperties>(),
                    Box::new(entity),
                ))
            }
            "IFCSECTIONEDSPINE" => {
                let entity = IfcSectionedSpine::from_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<IfcSectionedSpine>(),
                    Box::new(entity),
                ))
            }
            "IFCSENSOR" => {
                let entity = if own_parameters_only {
                    IfcSensor::from_own_parameters(typed_parameter.parameters)
                } else {
                    IfcSensor::from_parameters(typed_parameter.parameters)
                };
                Some((entity.type_id(), std::any::type_name::<IfcSensor>(), Box::new(entity)))
            }
            "IFCSENSORTYPE" => {
                let entity = if own_parameters_only {
                    IfcSensorType::from_own_parameters(typed_parameter.parameters)
                } else {
                    IfcSensorType::from_parameters(typed_parameter.parameters)
                };
                Some((
                    entity.type_id(),
                    std::any::type_name::<IfcSensorType>(),
                    Box::new(entity),
                ))
            }
            "IFCSHADINGDEVICE" => {
                let entity = if own_parameters_only {
                    IfcShadingDevice::from_own_parameters(typed_parameter.parameters)
                } else {
                    IfcShadingDevice::from_parameters(typed_parameter.parameters)
                };
                Some((
                    entity.type_id(),
                    std::any::type_name::<IfcShadingDevice>(),
                    Box::new(entity),
                ))
            }
            "IFCSHADINGDEVICETYPE" => {
                let entity = if own_parameters_only {
                    IfcShadingDeviceType::from_own_parameters(typed_parameter.parameters)
                } else {
                    IfcShadingDeviceType::from_parameters(typed_parameter.parameters)
                };
                Some((
                    entity.type_id(),
                    std::any::type_name::<IfcShadingDeviceType>(),
                    Box::new(entity),
                ))
            }
            "IFCSHAPEASPECT" => {
                let entity = IfcShapeAspect::from_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<IfcShapeAspect>(),
                    Box::new(entity),
                ))
            }
            "IFCSHAPEREPRESENTATION" => {
                let entity = IfcShapeRepresentation::from_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<IfcShapeRepresentation>(),
                    Box::new(entity),
                ))
            }
            "IFCSHELLBASEDSURFACEMODEL" => {
                let entity = IfcShellBasedSurfaceModel::from_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<IfcShellBasedSurfaceModel>(),
                    Box::new(entity),
                ))
            }
            "IFCSIMPLEPROPERTYTEMPLATE" => {
                let entity = if own_parameters_only {
                    IfcSimplePropertyTemplate::from_own_parameters(typed_parameter.parameters)
                } else {
                    IfcSimplePropertyTemplate::from_parameters(typed_parameter.parameters)
                };
                Some((
                    entity.type_id(),
                    std::any::type_name::<IfcSimplePropertyTemplate>(),
                    Box::new(entity),
                ))
            }
            "IFCSITE" => {
                let entity = if own_parameters_only {
                    IfcSite::from_own_parameters(typed_parameter.parameters)
                } else {
                    IfcSite::from_parameters(typed_parameter.parameters)
                };
                Some((entity.type_id(), std::any::type_name::<IfcSite>(), Box::new(entity)))
            }
            "IFCSLAB" => {
                let entity = if own_parameters_only {
                    IfcSlab::from_own_parameters(typed_parameter.parameters)
                } else {
                    IfcSlab::from_parameters(typed_parameter.parameters)
                };
                Some((entity.type_id(), std::any::type_name::<IfcSlab>(), Box::new(entity)))
            }
            "IFCSLABELEMENTEDCASE" => {
                let entity = IfcSlabElementedCase::from_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<IfcSlabElementedCase>(),
                    Box::new(entity),
                ))
            }
            "IFCSLABSTANDARDCASE" => {
                let entity = IfcSlabStandardCase::from_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<IfcSlabStandardCase>(),
                    Box::new(entity),
                ))
            }
            "IFCSLABTYPE" => {
                let entity = if own_parameters_only {
                    IfcSlabType::from_own_parameters(typed_parameter.parameters)
                } else {
                    IfcSlabType::from_parameters(typed_parameter.parameters)
                };
                Some((entity.type_id(), std::any::type_name::<IfcSlabType>(), Box::new(entity)))
            }
            "IFCSLIPPAGECONNECTIONCONDITION" => {
                let entity = if own_parameters_only {
                    IfcSlippageConnectionCondition::from_own_parameters(typed_parameter.parameters)
                } else {
                    IfcSlippageConnectionCondition::from_parameters(typed_parameter.parameters)
                };
                Some((
                    entity.type_id(),
                    std::any::type_name::<IfcSlippageConnectionCondition>(),
                    Box::new(entity),
                ))
            }
            "IFCSOLARDEVICE" => {
                let entity = if own_parameters_only {
                    IfcSolarDevice::from_own_parameters(typed_parameter.parameters)
                } else {
                    IfcSolarDevice::from_parameters(typed_parameter.parameters)
                };
                Some((
                    entity.type_id(),
                    std::any::type_name::<IfcSolarDevice>(),
                    Box::new(entity),
                ))
            }
            "IFCSOLARDEVICETYPE" => {
                let entity = if own_parameters_only {
                    IfcSolarDeviceType::from_own_parameters(typed_parameter.parameters)
                } else {
                    IfcSolarDeviceType::from_parameters(typed_parameter.parameters)
                };
                Some((
                    entity.type_id(),
                    std::any::type_name::<IfcSolarDeviceType>(),
                    Box::new(entity),
                ))
            }
            "IFCSPACE" => {
                let entity = if own_parameters_only {
                    IfcSpace::from_own_parameters(typed_parameter.parameters)
                } else {
                    IfcSpace::from_parameters(typed_parameter.parameters)
                };
                Some((entity.type_id(), std::any::type_name::<IfcSpace>(), Box::new(entity)))
            }
            "IFCSPACEHEATER" => {
                let entity = if own_parameters_only {
                    IfcSpaceHeater::from_own_parameters(typed_parameter.parameters)
                } else {
                    IfcSpaceHeater::from_parameters(typed_parameter.parameters)
                };
                Some((
                    entity.type_id(),
                    std::any::type_name::<IfcSpaceHeater>(),
                    Box::new(entity),
                ))
            }
            "IFCSPACEHEATERTYPE" => {
                let entity = if own_parameters_only {
                    IfcSpaceHeaterType::from_own_parameters(typed_parameter.parameters)
                } else {
                    IfcSpaceHeaterType::from_parameters(typed_parameter.parameters)
                };
                Some((
                    entity.type_id(),
                    std::any::type_name::<IfcSpaceHeaterType>(),
                    Box::new(entity),
                ))
            }
            "IFCSPACETYPE" => {
                let entity = if own_parameters_only {
                    IfcSpaceType::from_own_parameters(typed_parameter.parameters)
                } else {
                    IfcSpaceType::from_parameters(typed_parameter.parameters)
                };
                Some((
                    entity.type_id(),
                    std::any::type_name::<IfcSpaceType>(),
                    Box::new(entity),
                ))
            }
            "IFCSPATIALZONE" => {
                let entity = if own_parameters_only {
                    IfcSpatialZone::from_own_parameters(typed_parameter.parameters)
                } else {
                    IfcSpatialZone::from_parameters(typed_parameter.parameters)
                };
                Some((
                    entity.type_id(),
                    std::any::type_name::<IfcSpatialZone>(),
                    Box::new(entity),
                ))
            }
            "IFCSPATIALZONETYPE" => {
                let entity = if own_parameters_only {
                    IfcSpatialZoneType::from_own_parameters(typed_parameter.parameters)
                } else {
                    IfcSpatialZoneType::from_parameters(typed_parameter.parameters)
                };
                Some((
                    entity.type_id(),
                    std::any::type_name::<IfcSpatialZoneType>(),
                    Box::new(entity),
                ))
            }
            "IFCSPHERE" => {
                let entity = if own_parameters_only {
                    IfcSphere::from_own_parameters(typed_parameter.parameters)
                } else {
                    IfcSphere::from_parameters(typed_parameter.parameters)
                };
                Some((entity.type_id(), std::any::type_name::<IfcSphere>(), Box::new(entity)))
            }
            "IFCSPHERICALSURFACE" => {
                let entity = if own_parameters_only {
                    IfcSphericalSurface::from_own_parameters(typed_parameter.parameters)
                } else {
                    IfcSphericalSurface::from_parameters(typed_parameter.parameters)
                };
                Some((
                    entity.type_id(),
                    std::any::type_name::<IfcSphericalSurface>(),
                    Box::new(entity),
                ))
            }
            "IFCSTACKTERMINAL" => {
                let entity = if own_parameters_only {
                    IfcStackTerminal::from_own_parameters(typed_parameter.parameters)
                } else {
                    IfcStackTerminal::from_parameters(typed_parameter.parameters)
                };
                Some((
                    entity.type_id(),
                    std::any::type_name::<IfcStackTerminal>(),
                    Box::new(entity),
                ))
            }
            "IFCSTACKTERMINALTYPE" => {
                let entity = if own_parameters_only {
                    IfcStackTerminalType::from_own_parameters(typed_parameter.parameters)
                } else {
                    IfcStackTerminalType::from_parameters(typed_parameter.parameters)
                };
                Some((
                    entity.type_id(),
                    std::any::type_name::<IfcStackTerminalType>(),
                    Box::new(entity),
                ))
            }
            "IFCSTAIR" => {
                let entity = if own_parameters_only {
                    IfcStair::from_own_parameters(typed_parameter.parameters)
                } else {
                    IfcStair::from_parameters(typed_parameter.parameters)
                };
                Some((entity.type_id(), std::any::type_name::<IfcStair>(), Box::new(entity)))
            }
            "IFCSTAIRFLIGHT" => {
                let entity = if own_parameters_only {
                    IfcStairFlight::from_own_parameters(typed_parameter.parameters)
                } else {
                    IfcStairFlight::from_parameters(typed_parameter.parameters)
                };
                Some((
                    entity.type_id(),
                    std::any::type_name::<IfcStairFlight>(),
                    Box::new(entity),
                ))
            }
            "IFCSTAIRFLIGHTTYPE" => {
                let entity = if own_parameters_only {
                    IfcStairFlightType::from_own_parameters(typed_parameter.parameters)
                } else {
                    IfcStairFlightType::from_parameters(typed_parameter.parameters)
                };
                Some((
                    entity.type_id(),
                    std::any::type_name::<IfcStairFlightType>(),
                    Box::new(entity),
                ))
            }
            "IFCSTAIRTYPE" => {
                let entity = if own_parameters_only {
                    IfcStairType::from_own_parameters(typed_parameter.parameters)
                } else {
                    IfcStairType::from_parameters(typed_parameter.parameters)
                };
                Some((
                    entity.type_id(),
                    std::any::type_name::<IfcStairType>(),
                    Box::new(entity),
                ))
            }
            "IFCSTRUCTURALANALYSISMODEL" => {
                let entity = if own_parameters_only {
                    IfcStructuralAnalysisModel::from_own_parameters(typed_parameter.parameters)
                } else {
                    IfcStructuralAnalysisModel::from_parameters(typed_parameter.parameters)
                };
                Some((
                    entity.type_id(),
                    std::any::type_name::<IfcStructuralAnalysisModel>(),
                    Box::new(entity),
                ))
            }
            "IFCSTRUCTURALCURVEACTION" => {
                let entity = if own_parameters_only {
                    IfcStructuralCurveAction::from_own_parameters(typed_parameter.parameters)
                } else {
                    IfcStructuralCurveAction::from_parameters(typed_parameter.parameters)
                };
                Some((
                    entity.type_id(),
                    std::any::type_name::<IfcStructuralCurveAction>(),
                    Box::new(entity),
                ))
            }
            "IFCSTRUCTURALCURVECONNECTION" => {
                let entity = if own_parameters_only {
                    IfcStructuralCurveConnection::from_own_parameters(typed_parameter.parameters)
                } else {
                    IfcStructuralCurveConnection::from_parameters(typed_parameter.parameters)
                };
                Some((
                    entity.type_id(),
                    std::any::type_name::<IfcStructuralCurveConnection>(),
                    Box::new(entity),
                ))
            }
            "IFCSTRUCTURALCURVEMEMBER" => {
                let entity = if own_parameters_only {
                    IfcStructuralCurveMember::from_own_parameters(typed_parameter.parameters)
                } else {
                    IfcStructuralCurveMember::from_parameters(typed_parameter.parameters)
                };
                Some((
                    entity.type_id(),
                    std::any::type_name::<IfcStructuralCurveMember>(),
                    Box::new(entity),
                ))
            }
            "IFCSTRUCTURALCURVEMEMBERVARYING" => {
                let entity = IfcStructuralCurveMemberVarying::from_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<IfcStructuralCurveMemberVarying>(),
                    Box::new(entity),
                ))
            }
            "IFCSTRUCTURALCURVEREACTION" => {
                let entity = if own_parameters_only {
                    IfcStructuralCurveReaction::from_own_parameters(typed_parameter.parameters)
                } else {
                    IfcStructuralCurveReaction::from_parameters(typed_parameter.parameters)
                };
                Some((
                    entity.type_id(),
                    std::any::type_name::<IfcStructuralCurveReaction>(),
                    Box::new(entity),
                ))
            }
            "IFCSTRUCTURALLINEARACTION" => {
                let entity = IfcStructuralLinearAction::from_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<IfcStructuralLinearAction>(),
                    Box::new(entity),
                ))
            }
            "IFCSTRUCTURALLOADCASE" => {
                let entity = if own_parameters_only {
                    IfcStructuralLoadCase::from_own_parameters(typed_parameter.parameters)
                } else {
                    IfcStructuralLoadCase::from_parameters(typed_parameter.parameters)
                };
                Some((
                    entity.type_id(),
                    std::any::type_name::<IfcStructuralLoadCase>(),
                    Box::new(entity),
                ))
            }
            "IFCSTRUCTURALLOADCONFIGURATION" => {
                let entity = if own_parameters_only {
                    IfcStructuralLoadConfiguration::from_own_parameters(typed_parameter.parameters)
                } else {
                    IfcStructuralLoadConfiguration::from_parameters(typed_parameter.parameters)
                };
                Some((
                    entity.type_id(),
                    std::any::type_name::<IfcStructuralLoadConfiguration>(),
                    Box::new(entity),
                ))
            }
            "IFCSTRUCTURALLOADGROUP" => {
                let entity = if own_parameters_only {
                    IfcStructuralLoadGroup::from_own_parameters(typed_parameter.parameters)
                } else {
                    IfcStructuralLoadGroup::from_parameters(typed_parameter.parameters)
                };
                Some((
                    entity.type_id(),
                    std::any::type_name::<IfcStructuralLoadGroup>(),
                    Box::new(entity),
                ))
            }
            "IFCSTRUCTURALLOADLINEARFORCE" => {
                let entity = if own_parameters_only {
                    IfcStructuralLoadLinearForce::from_own_parameters(typed_parameter.parameters)
                } else {
                    IfcStructuralLoadLinearForce::from_parameters(typed_parameter.parameters)
                };
                Some((
                    entity.type_id(),
                    std::any::type_name::<IfcStructuralLoadLinearForce>(),
                    Box::new(entity),
                ))
            }
            "IFCSTRUCTURALLOADPLANARFORCE" => {
                let entity = if own_parameters_only {
                    IfcStructuralLoadPlanarForce::from_own_parameters(typed_parameter.parameters)
                } else {
                    IfcStructuralLoadPlanarForce::from_parameters(typed_parameter.parameters)
                };
                Some((
                    entity.type_id(),
                    std::any::type_name::<IfcStructuralLoadPlanarForce>(),
                    Box::new(entity),
                ))
            }
            "IFCSTRUCTURALLOADSINGLEDISPLACEMENT" => {
                let entity = if own_parameters_only {
                    IfcStructuralLoadSingleDisplacement::from_own_parameters(typed_parameter.parameters)
                } else {
                    IfcStructuralLoadSingleDisplacement::from_parameters(typed_parameter.parameters)
                };
                Some((
                    entity.type_id(),
                    std::any::type_name::<IfcStructuralLoadSingleDisplacement>(),
                    Box::new(entity),
                ))
            }
            "IFCSTRUCTURALLOADSINGLEDISPLACEMENTDISTORTION" => {
                let entity = if own_parameters_only {
                    IfcStructuralLoadSingleDisplacementDistortion::from_own_parameters(typed_parameter.parameters)
                } else {
                    IfcStructuralLoadSingleDisplacementDistortion::from_parameters(typed_parameter.parameters)
                };
                Some((
                    entity.type_id(),
                    std::any::type_name::<IfcStructuralLoadSingleDisplacementDistortion>(),
                    Box::new(entity),
                ))
            }
            "IFCSTRUCTURALLOADSINGLEFORCE" => {
                let entity = if own_parameters_only {
                    IfcStructuralLoadSingleForce::from_own_parameters(typed_parameter.parameters)
                } else {
                    IfcStructuralLoadSingleForce::from_parameters(typed_parameter.parameters)
                };
                Some((
                    entity.type_id(),
                    std::any::type_name::<IfcStructuralLoadSingleForce>(),
                    Box::new(entity),
                ))
            }
            "IFCSTRUCTURALLOADSINGLEFORCEWARPING" => {
                let entity = if own_parameters_only {
                    IfcStructuralLoadSingleForceWarping::from_own_parameters(typed_parameter.parameters)
                } else {
                    IfcStructuralLoadSingleForceWarping::from_parameters(typed_parameter.parameters)
                };
                Some((
                    entity.type_id(),
                    std::any::type_name::<IfcStructuralLoadSingleForceWarping>(),
                    Box::new(entity),
                ))
            }
            "IFCSTRUCTURALLOADTEMPERATURE" => {
                let entity = if own_parameters_only {
                    IfcStructuralLoadTemperature::from_own_parameters(typed_parameter.parameters)
                } else {
                    IfcStructuralLoadTemperature::from_parameters(typed_parameter.parameters)
                };
                Some((
                    entity.type_id(),
                    std::any::type_name::<IfcStructuralLoadTemperature>(),
                    Box::new(entity),
                ))
            }
            "IFCSTRUCTURALPLANARACTION" => {
                let entity = IfcStructuralPlanarAction::from_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<IfcStructuralPlanarAction>(),
                    Box::new(entity),
                ))
            }
            "IFCSTRUCTURALPOINTACTION" => {
                let entity = IfcStructuralPointAction::from_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<IfcStructuralPointAction>(),
                    Box::new(entity),
                ))
            }
            "IFCSTRUCTURALPOINTCONNECTION" => {
                let entity = if own_parameters_only {
                    IfcStructuralPointConnection::from_own_parameters(typed_parameter.parameters)
                } else {
                    IfcStructuralPointConnection::from_parameters(typed_parameter.parameters)
                };
                Some((
                    entity.type_id(),
                    std::any::type_name::<IfcStructuralPointConnection>(),
                    Box::new(entity),
                ))
            }
            "IFCSTRUCTURALPOINTREACTION" => {
                let entity = IfcStructuralPointReaction::from_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<IfcStructuralPointReaction>(),
                    Box::new(entity),
                ))
            }
            "IFCSTRUCTURALRESULTGROUP" => {
                let entity = if own_parameters_only {
                    IfcStructuralResultGroup::from_own_parameters(typed_parameter.parameters)
                } else {
                    IfcStructuralResultGroup::from_parameters(typed_parameter.parameters)
                };
                Some((
                    entity.type_id(),
                    std::any::type_name::<IfcStructuralResultGroup>(),
                    Box::new(entity),
                ))
            }
            "IFCSTRUCTURALSURFACEACTION" => {
                let entity = if own_parameters_only {
                    IfcStructuralSurfaceAction::from_own_parameters(typed_parameter.parameters)
                } else {
                    IfcStructuralSurfaceAction::from_parameters(typed_parameter.parameters)
                };
                Some((
                    entity.type_id(),
                    std::any::type_name::<IfcStructuralSurfaceAction>(),
                    Box::new(entity),
                ))
            }
            "IFCSTRUCTURALSURFACECONNECTION" => {
                let entity = IfcStructuralSurfaceConnection::from_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<IfcStructuralSurfaceConnection>(),
                    Box::new(entity),
                ))
            }
            "IFCSTRUCTURALSURFACEMEMBER" => {
                let entity = if own_parameters_only {
                    IfcStructuralSurfaceMember::from_own_parameters(typed_parameter.parameters)
                } else {
                    IfcStructuralSurfaceMember::from_parameters(typed_parameter.parameters)
                };
                Some((
                    entity.type_id(),
                    std::any::type_name::<IfcStructuralSurfaceMember>(),
                    Box::new(entity),
                ))
            }
            "IFCSTRUCTURALSURFACEMEMBERVARYING" => {
                let entity = IfcStructuralSurfaceMemberVarying::from_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<IfcStructuralSurfaceMemberVarying>(),
                    Box::new(entity),
                ))
            }
            "IFCSTRUCTURALSURFACEREACTION" => {
                let entity = if own_parameters_only {
                    IfcStructuralSurfaceReaction::from_own_parameters(typed_parameter.parameters)
                } else {
                    IfcStructuralSurfaceReaction::from_parameters(typed_parameter.parameters)
                };
                Some((
                    entity.type_id(),
                    std::any::type_name::<IfcStructuralSurfaceReaction>(),
                    Box::new(entity),
                ))
            }
            "IFCSTYLEDITEM" => {
                let entity = IfcStyledItem::from_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<IfcStyledItem>(),
                    Box::new(entity),
                ))
            }
            "IFCSTYLEDREPRESENTATION" => {
                let entity = IfcStyledRepresentation::from_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<IfcStyledRepresentation>(),
                    Box::new(entity),
                ))
            }
            "IFCSUBCONTRACTRESOURCE" => {
                let entity = if own_parameters_only {
                    IfcSubContractResource::from_own_parameters(typed_parameter.parameters)
                } else {
                    IfcSubContractResource::from_parameters(typed_parameter.parameters)
                };
                Some((
                    entity.type_id(),
                    std::any::type_name::<IfcSubContractResource>(),
                    Box::new(entity),
                ))
            }
            "IFCSUBCONTRACTRESOURCETYPE" => {
                let entity = if own_parameters_only {
                    IfcSubContractResourceType::from_own_parameters(typed_parameter.parameters)
                } else {
                    IfcSubContractResourceType::from_parameters(typed_parameter.parameters)
                };
                Some((
                    entity.type_id(),
                    std::any::type_name::<IfcSubContractResourceType>(),
                    Box::new(entity),
                ))
            }
            "IFCSUBEDGE" => {
                let entity = if own_parameters_only {
                    IfcSubedge::from_own_parameters(typed_parameter.parameters)
                } else {
                    IfcSubedge::from_parameters(typed_parameter.parameters)
                };
                Some((entity.type_id(), std::any::type_name::<IfcSubedge>(), Box::new(entity)))
            }
            "IFCSURFACECURVE" => {
                let entity = IfcSurfaceCurve::from_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<IfcSurfaceCurve>(),
                    Box::new(entity),
                ))
            }
            "IFCSURFACECURVESWEPTAREASOLID" => {
                let entity = if own_parameters_only {
                    IfcSurfaceCurveSweptAreaSolid::from_own_parameters(typed_parameter.parameters)
                } else {
                    IfcSurfaceCurveSweptAreaSolid::from_parameters(typed_parameter.parameters)
                };
                Some((
                    entity.type_id(),
                    std::any::type_name::<IfcSurfaceCurveSweptAreaSolid>(),
                    Box::new(entity),
                ))
            }
            "IFCSURFACEFEATURE" => {
                let entity = if own_parameters_only {
                    IfcSurfaceFeature::from_own_parameters(typed_parameter.parameters)
                } else {
                    IfcSurfaceFeature::from_parameters(typed_parameter.parameters)
                };
                Some((
                    entity.type_id(),
                    std::any::type_name::<IfcSurfaceFeature>(),
                    Box::new(entity),
                ))
            }
            "IFCSURFACEOFLINEAREXTRUSION" => {
                let entity = if own_parameters_only {
                    IfcSurfaceOfLinearExtrusion::from_own_parameters(typed_parameter.parameters)
                } else {
                    IfcSurfaceOfLinearExtrusion::from_parameters(typed_parameter.parameters)
                };
                Some((
                    entity.type_id(),
                    std::any::type_name::<IfcSurfaceOfLinearExtrusion>(),
                    Box::new(entity),
                ))
            }
            "IFCSURFACEOFREVOLUTION" => {
                let entity = if own_parameters_only {
                    IfcSurfaceOfRevolution::from_own_parameters(typed_parameter.parameters)
                } else {
                    IfcSurfaceOfRevolution::from_parameters(typed_parameter.parameters)
                };
                Some((
                    entity.type_id(),
                    std::any::type_name::<IfcSurfaceOfRevolution>(),
                    Box::new(entity),
                ))
            }
            "IFCSURFACEREINFORCEMENTAREA" => {
                let entity = if own_parameters_only {
                    IfcSurfaceReinforcementArea::from_own_parameters(typed_parameter.parameters)
                } else {
                    IfcSurfaceReinforcementArea::from_parameters(typed_parameter.parameters)
                };
                Some((
                    entity.type_id(),
                    std::any::type_name::<IfcSurfaceReinforcementArea>(),
                    Box::new(entity),
                ))
            }
            "IFCSURFACESTYLE" => {
                let entity = if own_parameters_only {
                    IfcSurfaceStyle::from_own_parameters(typed_parameter.parameters)
                } else {
                    IfcSurfaceStyle::from_parameters(typed_parameter.parameters)
                };
                Some((
                    entity.type_id(),
                    std::any::type_name::<IfcSurfaceStyle>(),
                    Box::new(entity),
                ))
            }
            "IFCSURFACESTYLELIGHTING" => {
                let entity = IfcSurfaceStyleLighting::from_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<IfcSurfaceStyleLighting>(),
                    Box::new(entity),
                ))
            }
            "IFCSURFACESTYLEREFRACTION" => {
                let entity = IfcSurfaceStyleRefraction::from_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<IfcSurfaceStyleRefraction>(),
                    Box::new(entity),
                ))
            }
            "IFCSURFACESTYLERENDERING" => {
                let entity = if own_parameters_only {
                    IfcSurfaceStyleRendering::from_own_parameters(typed_parameter.parameters)
                } else {
                    IfcSurfaceStyleRendering::from_parameters(typed_parameter.parameters)
                };
                Some((
                    entity.type_id(),
                    std::any::type_name::<IfcSurfaceStyleRendering>(),
                    Box::new(entity),
                ))
            }
            "IFCSURFACESTYLESHADING" => {
                let entity = IfcSurfaceStyleShading::from_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<IfcSurfaceStyleShading>(),
                    Box::new(entity),
                ))
            }
            "IFCSURFACESTYLEWITHTEXTURES" => {
                let entity = IfcSurfaceStyleWithTextures::from_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<IfcSurfaceStyleWithTextures>(),
                    Box::new(entity),
                ))
            }
            "IFCSWEPTDISKSOLID" => {
                let entity = IfcSweptDiskSolid::from_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<IfcSweptDiskSolid>(),
                    Box::new(entity),
                ))
            }
            "IFCSWEPTDISKSOLIDPOLYGONAL" => {
                let entity = if own_parameters_only {
                    IfcSweptDiskSolidPolygonal::from_own_parameters(typed_parameter.parameters)
                } else {
                    IfcSweptDiskSolidPolygonal::from_parameters(typed_parameter.parameters)
                };
                Some((
                    entity.type_id(),
                    std::any::type_name::<IfcSweptDiskSolidPolygonal>(),
                    Box::new(entity),
                ))
            }
            "IFCSWITCHINGDEVICE" => {
                let entity = if own_parameters_only {
                    IfcSwitchingDevice::from_own_parameters(typed_parameter.parameters)
                } else {
                    IfcSwitchingDevice::from_parameters(typed_parameter.parameters)
                };
                Some((
                    entity.type_id(),
                    std::any::type_name::<IfcSwitchingDevice>(),
                    Box::new(entity),
                ))
            }
            "IFCSWITCHINGDEVICETYPE" => {
                let entity = if own_parameters_only {
                    IfcSwitchingDeviceType::from_own_parameters(typed_parameter.parameters)
                } else {
                    IfcSwitchingDeviceType::from_parameters(typed_parameter.parameters)
                };
                Some((
                    entity.type_id(),
                    std::any::type_name::<IfcSwitchingDeviceType>(),
                    Box::new(entity),
                ))
            }
            "IFCSYSTEM" => {
                let entity = IfcSystem::from_parameters(typed_parameter.parameters);
                Some((entity.type_id(), std::any::type_name::<IfcSystem>(), Box::new(entity)))
            }
            "IFCSYSTEMFURNITUREELEMENT" => {
                let entity = if own_parameters_only {
                    IfcSystemFurnitureElement::from_own_parameters(typed_parameter.parameters)
                } else {
                    IfcSystemFurnitureElement::from_parameters(typed_parameter.parameters)
                };
                Some((
                    entity.type_id(),
                    std::any::type_name::<IfcSystemFurnitureElement>(),
                    Box::new(entity),
                ))
            }
            "IFCSYSTEMFURNITUREELEMENTTYPE" => {
                let entity = if own_parameters_only {
                    IfcSystemFurnitureElementType::from_own_parameters(typed_parameter.parameters)
                } else {
                    IfcSystemFurnitureElementType::from_parameters(typed_parameter.parameters)
                };
                Some((
                    entity.type_id(),
                    std::any::type_name::<IfcSystemFurnitureElementType>(),
                    Box::new(entity),
                ))
            }
            "IFCTSHAPEPROFILEDEF" => {
                let entity = if own_parameters_only {
                    IfcTShapeProfileDef::from_own_parameters(typed_parameter.parameters)
                } else {
                    IfcTShapeProfileDef::from_parameters(typed_parameter.parameters)
                };
                Some((
                    entity.type_id(),
                    std::any::type_name::<IfcTShapeProfileDef>(),
                    Box::new(entity),
                ))
            }
            "IFCTABLE" => {
                let entity = IfcTable::from_parameters(typed_parameter.parameters);
                Some((entity.type_id(), std::any::type_name::<IfcTable>(), Box::new(entity)))
            }
            "IFCTABLECOLUMN" => {
                let entity = IfcTableColumn::from_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<IfcTableColumn>(),
                    Box::new(entity),
                ))
            }
            "IFCTABLEROW" => {
                let entity = IfcTableRow::from_parameters(typed_parameter.parameters);
                Some((entity.type_id(), std::any::type_name::<IfcTableRow>(), Box::new(entity)))
            }
            "IFCTANK" => {
                let entity = if own_parameters_only {
                    IfcTank::from_own_parameters(typed_parameter.parameters)
                } else {
                    IfcTank::from_parameters(typed_parameter.parameters)
                };
                Some((entity.type_id(), std::any::type_name::<IfcTank>(), Box::new(entity)))
            }
            "IFCTANKTYPE" => {
                let entity = if own_parameters_only {
                    IfcTankType::from_own_parameters(typed_parameter.parameters)
                } else {
                    IfcTankType::from_parameters(typed_parameter.parameters)
                };
                Some((entity.type_id(), std::any::type_name::<IfcTankType>(), Box::new(entity)))
            }
            "IFCTASK" => {
                let entity = if own_parameters_only {
                    IfcTask::from_own_parameters(typed_parameter.parameters)
                } else {
                    IfcTask::from_parameters(typed_parameter.parameters)
                };
                Some((entity.type_id(), std::any::type_name::<IfcTask>(), Box::new(entity)))
            }
            "IFCTASKTIME" => {
                let entity = if own_parameters_only {
                    IfcTaskTime::from_own_parameters(typed_parameter.parameters)
                } else {
                    IfcTaskTime::from_parameters(typed_parameter.parameters)
                };
                Some((entity.type_id(), std::any::type_name::<IfcTaskTime>(), Box::new(entity)))
            }
            "IFCTASKTIMERECURRING" => {
                let entity = if own_parameters_only {
                    IfcTaskTimeRecurring::from_own_parameters(typed_parameter.parameters)
                } else {
                    IfcTaskTimeRecurring::from_parameters(typed_parameter.parameters)
                };
                Some((
                    entity.type_id(),
                    std::any::type_name::<IfcTaskTimeRecurring>(),
                    Box::new(entity),
                ))
            }
            "IFCTASKTYPE" => {
                let entity = if own_parameters_only {
                    IfcTaskType::from_own_parameters(typed_parameter.parameters)
                } else {
                    IfcTaskType::from_parameters(typed_parameter.parameters)
                };
                Some((entity.type_id(), std::any::type_name::<IfcTaskType>(), Box::new(entity)))
            }
            "IFCTELECOMADDRESS" => {
                let entity = if own_parameters_only {
                    IfcTelecomAddress::from_own_parameters(typed_parameter.parameters)
                } else {
                    IfcTelecomAddress::from_parameters(typed_parameter.parameters)
                };
                Some((
                    entity.type_id(),
                    std::any::type_name::<IfcTelecomAddress>(),
                    Box::new(entity),
                ))
            }
            "IFCTENDON" => {
                let entity = if own_parameters_only {
                    IfcTendon::from_own_parameters(typed_parameter.parameters)
                } else {
                    IfcTendon::from_parameters(typed_parameter.parameters)
                };
                Some((entity.type_id(), std::any::type_name::<IfcTendon>(), Box::new(entity)))
            }
            "IFCTENDONANCHOR" => {
                let entity = if own_parameters_only {
                    IfcTendonAnchor::from_own_parameters(typed_parameter.parameters)
                } else {
                    IfcTendonAnchor::from_parameters(typed_parameter.parameters)
                };
                Some((
                    entity.type_id(),
                    std::any::type_name::<IfcTendonAnchor>(),
                    Box::new(entity),
                ))
            }
            "IFCTENDONANCHORTYPE" => {
                let entity = if own_parameters_only {
                    IfcTendonAnchorType::from_own_parameters(typed_parameter.parameters)
                } else {
                    IfcTendonAnchorType::from_parameters(typed_parameter.parameters)
                };
                Some((
                    entity.type_id(),
                    std::any::type_name::<IfcTendonAnchorType>(),
                    Box::new(entity),
                ))
            }
            "IFCTENDONTYPE" => {
                let entity = if own_parameters_only {
                    IfcTendonType::from_own_parameters(typed_parameter.parameters)
                } else {
                    IfcTendonType::from_parameters(typed_parameter.parameters)
                };
                Some((
                    entity.type_id(),
                    std::any::type_name::<IfcTendonType>(),
                    Box::new(entity),
                ))
            }
            "IFCTEXTLITERAL" => {
                let entity = IfcTextLiteral::from_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<IfcTextLiteral>(),
                    Box::new(entity),
                ))
            }
            "IFCTEXTLITERALWITHEXTENT" => {
                let entity = if own_parameters_only {
                    IfcTextLiteralWithExtent::from_own_parameters(typed_parameter.parameters)
                } else {
                    IfcTextLiteralWithExtent::from_parameters(typed_parameter.parameters)
                };
                Some((
                    entity.type_id(),
                    std::any::type_name::<IfcTextLiteralWithExtent>(),
                    Box::new(entity),
                ))
            }
            "IFCTEXTSTYLE" => {
                let entity = if own_parameters_only {
                    IfcTextStyle::from_own_parameters(typed_parameter.parameters)
                } else {
                    IfcTextStyle::from_parameters(typed_parameter.parameters)
                };
                Some((
                    entity.type_id(),
                    std::any::type_name::<IfcTextStyle>(),
                    Box::new(entity),
                ))
            }
            "IFCTEXTSTYLEFONTMODEL" => {
                let entity = if own_parameters_only {
                    IfcTextStyleFontModel::from_own_parameters(typed_parameter.parameters)
                } else {
                    IfcTextStyleFontModel::from_parameters(typed_parameter.parameters)
                };
                Some((
                    entity.type_id(),
                    std::any::type_name::<IfcTextStyleFontModel>(),
                    Box::new(entity),
                ))
            }
            "IFCTEXTSTYLEFORDEFINEDFONT" => {
                let entity = IfcTextStyleForDefinedFont::from_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<IfcTextStyleForDefinedFont>(),
                    Box::new(entity),
                ))
            }
            "IFCTEXTSTYLETEXTMODEL" => {
                let entity = IfcTextStyleTextModel::from_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<IfcTextStyleTextModel>(),
                    Box::new(entity),
                ))
            }
            "IFCTEXTURECOORDINATEGENERATOR" => {
                let entity = if own_parameters_only {
                    IfcTextureCoordinateGenerator::from_own_parameters(typed_parameter.parameters)
                } else {
                    IfcTextureCoordinateGenerator::from_parameters(typed_parameter.parameters)
                };
                Some((
                    entity.type_id(),
                    std::any::type_name::<IfcTextureCoordinateGenerator>(),
                    Box::new(entity),
                ))
            }
            "IFCTEXTUREMAP" => {
                let entity = if own_parameters_only {
                    IfcTextureMap::from_own_parameters(typed_parameter.parameters)
                } else {
                    IfcTextureMap::from_parameters(typed_parameter.parameters)
                };
                Some((
                    entity.type_id(),
                    std::any::type_name::<IfcTextureMap>(),
                    Box::new(entity),
                ))
            }
            "IFCTEXTUREVERTEX" => {
                let entity = IfcTextureVertex::from_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<IfcTextureVertex>(),
                    Box::new(entity),
                ))
            }
            "IFCTEXTUREVERTEXLIST" => {
                let entity = IfcTextureVertexList::from_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<IfcTextureVertexList>(),
                    Box::new(entity),
                ))
            }
            "IFCTIMEPERIOD" => {
                let entity = IfcTimePeriod::from_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<IfcTimePeriod>(),
                    Box::new(entity),
                ))
            }
            "IFCTIMESERIESVALUE" => {
                let entity = IfcTimeSeriesValue::from_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<IfcTimeSeriesValue>(),
                    Box::new(entity),
                ))
            }
            "IFCTOPOLOGYREPRESENTATION" => {
                let entity = IfcTopologyRepresentation::from_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<IfcTopologyRepresentation>(),
                    Box::new(entity),
                ))
            }
            "IFCTOROIDALSURFACE" => {
                let entity = if own_parameters_only {
                    IfcToroidalSurface::from_own_parameters(typed_parameter.parameters)
                } else {
                    IfcToroidalSurface::from_parameters(typed_parameter.parameters)
                };
                Some((
                    entity.type_id(),
                    std::any::type_name::<IfcToroidalSurface>(),
                    Box::new(entity),
                ))
            }
            "IFCTRANSFORMER" => {
                let entity = if own_parameters_only {
                    IfcTransformer::from_own_parameters(typed_parameter.parameters)
                } else {
                    IfcTransformer::from_parameters(typed_parameter.parameters)
                };
                Some((
                    entity.type_id(),
                    std::any::type_name::<IfcTransformer>(),
                    Box::new(entity),
                ))
            }
            "IFCTRANSFORMERTYPE" => {
                let entity = if own_parameters_only {
                    IfcTransformerType::from_own_parameters(typed_parameter.parameters)
                } else {
                    IfcTransformerType::from_parameters(typed_parameter.parameters)
                };
                Some((
                    entity.type_id(),
                    std::any::type_name::<IfcTransformerType>(),
                    Box::new(entity),
                ))
            }
            "IFCTRANSPORTELEMENT" => {
                let entity = if own_parameters_only {
                    IfcTransportElement::from_own_parameters(typed_parameter.parameters)
                } else {
                    IfcTransportElement::from_parameters(typed_parameter.parameters)
                };
                Some((
                    entity.type_id(),
                    std::any::type_name::<IfcTransportElement>(),
                    Box::new(entity),
                ))
            }
            "IFCTRANSPORTELEMENTTYPE" => {
                let entity = if own_parameters_only {
                    IfcTransportElementType::from_own_parameters(typed_parameter.parameters)
                } else {
                    IfcTransportElementType::from_parameters(typed_parameter.parameters)
                };
                Some((
                    entity.type_id(),
                    std::any::type_name::<IfcTransportElementType>(),
                    Box::new(entity),
                ))
            }
            "IFCTRAPEZIUMPROFILEDEF" => {
                let entity = if own_parameters_only {
                    IfcTrapeziumProfileDef::from_own_parameters(typed_parameter.parameters)
                } else {
                    IfcTrapeziumProfileDef::from_parameters(typed_parameter.parameters)
                };
                Some((
                    entity.type_id(),
                    std::any::type_name::<IfcTrapeziumProfileDef>(),
                    Box::new(entity),
                ))
            }
            "IFCTRIANGULATEDFACESET" => {
                let entity = if own_parameters_only {
                    IfcTriangulatedFaceSet::from_own_parameters(typed_parameter.parameters)
                } else {
                    IfcTriangulatedFaceSet::from_parameters(typed_parameter.parameters)
                };
                Some((
                    entity.type_id(),
                    std::any::type_name::<IfcTriangulatedFaceSet>(),
                    Box::new(entity),
                ))
            }
            "IFCTRIMMEDCURVE" => {
                let entity = IfcTrimmedCurve::from_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<IfcTrimmedCurve>(),
                    Box::new(entity),
                ))
            }
            "IFCTUBEBUNDLE" => {
                let entity = if own_parameters_only {
                    IfcTubeBundle::from_own_parameters(typed_parameter.parameters)
                } else {
                    IfcTubeBundle::from_parameters(typed_parameter.parameters)
                };
                Some((
                    entity.type_id(),
                    std::any::type_name::<IfcTubeBundle>(),
                    Box::new(entity),
                ))
            }
            "IFCTUBEBUNDLETYPE" => {
                let entity = if own_parameters_only {
                    IfcTubeBundleType::from_own_parameters(typed_parameter.parameters)
                } else {
                    IfcTubeBundleType::from_parameters(typed_parameter.parameters)
                };
                Some((
                    entity.type_id(),
                    std::any::type_name::<IfcTubeBundleType>(),
                    Box::new(entity),
                ))
            }
            "IFCTYPEOBJECT" => {
                let entity = if own_parameters_only {
                    IfcTypeObject::from_own_parameters(typed_parameter.parameters)
                } else {
                    IfcTypeObject::from_parameters(typed_parameter.parameters)
                };
                Some((
                    entity.type_id(),
                    std::any::type_name::<IfcTypeObject>(),
                    Box::new(entity),
                ))
            }
            "IFCTYPEPRODUCT" => {
                let entity = if own_parameters_only {
                    IfcTypeProduct::from_own_parameters(typed_parameter.parameters)
                } else {
                    IfcTypeProduct::from_parameters(typed_parameter.parameters)
                };
                Some((
                    entity.type_id(),
                    std::any::type_name::<IfcTypeProduct>(),
                    Box::new(entity),
                ))
            }
            "IFCUSHAPEPROFILEDEF" => {
                let entity = if own_parameters_only {
                    IfcUShapeProfileDef::from_own_parameters(typed_parameter.parameters)
                } else {
                    IfcUShapeProfileDef::from_parameters(typed_parameter.parameters)
                };
                Some((
                    entity.type_id(),
                    std::any::type_name::<IfcUShapeProfileDef>(),
                    Box::new(entity),
                ))
            }
            "IFCUNITASSIGNMENT" => {
                let entity = IfcUnitAssignment::from_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<IfcUnitAssignment>(),
                    Box::new(entity),
                ))
            }
            "IFCUNITARYCONTROLELEMENT" => {
                let entity = if own_parameters_only {
                    IfcUnitaryControlElement::from_own_parameters(typed_parameter.parameters)
                } else {
                    IfcUnitaryControlElement::from_parameters(typed_parameter.parameters)
                };
                Some((
                    entity.type_id(),
                    std::any::type_name::<IfcUnitaryControlElement>(),
                    Box::new(entity),
                ))
            }
            "IFCUNITARYCONTROLELEMENTTYPE" => {
                let entity = if own_parameters_only {
                    IfcUnitaryControlElementType::from_own_parameters(typed_parameter.parameters)
                } else {
                    IfcUnitaryControlElementType::from_parameters(typed_parameter.parameters)
                };
                Some((
                    entity.type_id(),
                    std::any::type_name::<IfcUnitaryControlElementType>(),
                    Box::new(entity),
                ))
            }
            "IFCUNITARYEQUIPMENT" => {
                let entity = if own_parameters_only {
                    IfcUnitaryEquipment::from_own_parameters(typed_parameter.parameters)
                } else {
                    IfcUnitaryEquipment::from_parameters(typed_parameter.parameters)
                };
                Some((
                    entity.type_id(),
                    std::any::type_name::<IfcUnitaryEquipment>(),
                    Box::new(entity),
                ))
            }
            "IFCUNITARYEQUIPMENTTYPE" => {
                let entity = if own_parameters_only {
                    IfcUnitaryEquipmentType::from_own_parameters(typed_parameter.parameters)
                } else {
                    IfcUnitaryEquipmentType::from_parameters(typed_parameter.parameters)
                };
                Some((
                    entity.type_id(),
                    std::any::type_name::<IfcUnitaryEquipmentType>(),
                    Box::new(entity),
                ))
            }
            "IFCVALVE" => {
                let entity = if own_parameters_only {
                    IfcValve::from_own_parameters(typed_parameter.parameters)
                } else {
                    IfcValve::from_parameters(typed_parameter.parameters)
                };
                Some((entity.type_id(), std::any::type_name::<IfcValve>(), Box::new(entity)))
            }
            "IFCVALVETYPE" => {
                let entity = if own_parameters_only {
                    IfcValveType::from_own_parameters(typed_parameter.parameters)
                } else {
                    IfcValveType::from_parameters(typed_parameter.parameters)
                };
                Some((
                    entity.type_id(),
                    std::any::type_name::<IfcValveType>(),
                    Box::new(entity),
                ))
            }
            "IFCVECTOR" => {
                let entity = IfcVector::from_parameters(typed_parameter.parameters);
                Some((entity.type_id(), std::any::type_name::<IfcVector>(), Box::new(entity)))
            }
            "IFCVERTEX" => {
                let entity = IfcVertex::from_parameters(typed_parameter.parameters);
                Some((entity.type_id(), std::any::type_name::<IfcVertex>(), Box::new(entity)))
            }
            "IFCVERTEXLOOP" => {
                let entity = IfcVertexLoop::from_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<IfcVertexLoop>(),
                    Box::new(entity),
                ))
            }
            "IFCVERTEXPOINT" => {
                let entity = IfcVertexPoint::from_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<IfcVertexPoint>(),
                    Box::new(entity),
                ))
            }
            "IFCVIBRATIONISOLATOR" => {
                let entity = if own_parameters_only {
                    IfcVibrationIsolator::from_own_parameters(typed_parameter.parameters)
                } else {
                    IfcVibrationIsolator::from_parameters(typed_parameter.parameters)
                };
                Some((
                    entity.type_id(),
                    std::any::type_name::<IfcVibrationIsolator>(),
                    Box::new(entity),
                ))
            }
            "IFCVIBRATIONISOLATORTYPE" => {
                let entity = if own_parameters_only {
                    IfcVibrationIsolatorType::from_own_parameters(typed_parameter.parameters)
                } else {
                    IfcVibrationIsolatorType::from_parameters(typed_parameter.parameters)
                };
                Some((
                    entity.type_id(),
                    std::any::type_name::<IfcVibrationIsolatorType>(),
                    Box::new(entity),
                ))
            }
            "IFCVIRTUALELEMENT" => {
                let entity = IfcVirtualElement::from_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<IfcVirtualElement>(),
                    Box::new(entity),
                ))
            }
            "IFCVIRTUALGRIDINTERSECTION" => {
                let entity = IfcVirtualGridIntersection::from_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<IfcVirtualGridIntersection>(),
                    Box::new(entity),
                ))
            }
            "IFCVOIDINGFEATURE" => {
                let entity = if own_parameters_only {
                    IfcVoidingFeature::from_own_parameters(typed_parameter.parameters)
                } else {
                    IfcVoidingFeature::from_parameters(typed_parameter.parameters)
                };
                Some((
                    entity.type_id(),
                    std::any::type_name::<IfcVoidingFeature>(),
                    Box::new(entity),
                ))
            }
            "IFCWALL" => {
                let entity = if own_parameters_only {
                    IfcWall::from_own_parameters(typed_parameter.parameters)
                } else {
                    IfcWall::from_parameters(typed_parameter.parameters)
                };
                Some((entity.type_id(), std::any::type_name::<IfcWall>(), Box::new(entity)))
            }
            "IFCWALLELEMENTEDCASE" => {
                let entity = IfcWallElementedCase::from_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<IfcWallElementedCase>(),
                    Box::new(entity),
                ))
            }
            "IFCWALLSTANDARDCASE" => {
                let entity = IfcWallStandardCase::from_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<IfcWallStandardCase>(),
                    Box::new(entity),
                ))
            }
            "IFCWALLTYPE" => {
                let entity = if own_parameters_only {
                    IfcWallType::from_own_parameters(typed_parameter.parameters)
                } else {
                    IfcWallType::from_parameters(typed_parameter.parameters)
                };
                Some((entity.type_id(), std::any::type_name::<IfcWallType>(), Box::new(entity)))
            }
            "IFCWASTETERMINAL" => {
                let entity = if own_parameters_only {
                    IfcWasteTerminal::from_own_parameters(typed_parameter.parameters)
                } else {
                    IfcWasteTerminal::from_parameters(typed_parameter.parameters)
                };
                Some((
                    entity.type_id(),
                    std::any::type_name::<IfcWasteTerminal>(),
                    Box::new(entity),
                ))
            }
            "IFCWASTETERMINALTYPE" => {
                let entity = if own_parameters_only {
                    IfcWasteTerminalType::from_own_parameters(typed_parameter.parameters)
                } else {
                    IfcWasteTerminalType::from_parameters(typed_parameter.parameters)
                };
                Some((
                    entity.type_id(),
                    std::any::type_name::<IfcWasteTerminalType>(),
                    Box::new(entity),
                ))
            }
            "IFCWINDOW" => {
                let entity = if own_parameters_only {
                    IfcWindow::from_own_parameters(typed_parameter.parameters)
                } else {
                    IfcWindow::from_parameters(typed_parameter.parameters)
                };
                Some((entity.type_id(), std::any::type_name::<IfcWindow>(), Box::new(entity)))
            }
            "IFCWINDOWLININGPROPERTIES" => {
                let entity = if own_parameters_only {
                    IfcWindowLiningProperties::from_own_parameters(typed_parameter.parameters)
                } else {
                    IfcWindowLiningProperties::from_parameters(typed_parameter.parameters)
                };
                Some((
                    entity.type_id(),
                    std::any::type_name::<IfcWindowLiningProperties>(),
                    Box::new(entity),
                ))
            }
            "IFCWINDOWPANELPROPERTIES" => {
                let entity = if own_parameters_only {
                    IfcWindowPanelProperties::from_own_parameters(typed_parameter.parameters)
                } else {
                    IfcWindowPanelProperties::from_parameters(typed_parameter.parameters)
                };
                Some((
                    entity.type_id(),
                    std::any::type_name::<IfcWindowPanelProperties>(),
                    Box::new(entity),
                ))
            }
            "IFCWINDOWSTANDARDCASE" => {
                let entity = IfcWindowStandardCase::from_parameters(typed_parameter.parameters);
                Some((
                    entity.type_id(),
                    std::any::type_name::<IfcWindowStandardCase>(),
                    Box::new(entity),
                ))
            }
            "IFCWINDOWSTYLE" => {
                let entity = if own_parameters_only {
                    IfcWindowStyle::from_own_parameters(typed_parameter.parameters)
                } else {
                    IfcWindowStyle::from_parameters(typed_parameter.parameters)
                };
                Some((
                    entity.type_id(),
                    std::any::type_name::<IfcWindowStyle>(),
                    Box::new(entity),
                ))
            }
            "IFCWINDOWTYPE" => {
                let entity = if own_parameters_only {
                    IfcWindowType::from_own_parameters(typed_parameter.parameters)
                } else {
                    IfcWindowType::from_parameters(typed_parameter.parameters)
                };
                Some((
                    entity.type_id(),
                    std::any::type_name::<IfcWindowType>(),
                    Box::new(entity),
                ))
            }
            "IFCWORKCALENDAR" => {
                let entity = if own_parameters_only {
                    IfcWorkCalendar::from_own_parameters(typed_parameter.parameters)
                } else {
                    IfcWorkCalendar::from_parameters(typed_parameter.parameters)
                };
                Some((
                    entity.type_id(),
                    std::any::type_name::<IfcWorkCalendar>(),
                    Box::new(entity),
                ))
            }
            "IFCWORKPLAN" => {
                let entity = if own_parameters_only {
                    IfcWorkPlan::from_own_parameters(typed_parameter.parameters)
                } else {
                    IfcWorkPlan::from_parameters(typed_parameter.parameters)
                };
                Some((entity.type_id(), std::any::type_name::<IfcWorkPlan>(), Box::new(entity)))
            }
            "IFCWORKSCHEDULE" => {
                let entity = if own_parameters_only {
                    IfcWorkSchedule::from_own_parameters(typed_parameter.parameters)
                } else {
                    IfcWorkSchedule::from_parameters(typed_parameter.parameters)
                };
                Some((
                    entity.type_id(),
                    std::any::type_name::<IfcWorkSchedule>(),
                    Box::new(entity),
                ))
            }
            "IFCWORKTIME" => {
                let entity = if own_parameters_only {
                    IfcWorkTime::from_own_parameters(typed_parameter.parameters)
                } else {
                    IfcWorkTime::from_parameters(typed_parameter.parameters)
                };
                Some((entity.type_id(), std::any::type_name::<IfcWorkTime>(), Box::new(entity)))
            }
            "IFCZSHAPEPROFILEDEF" => {
                let entity = if own_parameters_only {
                    IfcZShapeProfileDef::from_own_parameters(typed_parameter.parameters)
                } else {
                    IfcZShapeProfileDef::from_parameters(typed_parameter.parameters)
                };
                Some((
                    entity.type_id(),
                    std::any::type_name::<IfcZShapeProfileDef>(),
                    Box::new(entity),
                ))
            }
            "IFCZONE" => {
                let entity = if own_parameters_only {
                    IfcZone::from_own_parameters(typed_parameter.parameters)
                } else {
                    IfcZone::from_parameters(typed_parameter.parameters)
                };
                Some((entity.type_id(), std::any::type_name::<IfcZone>(), Box::new(entity)))
            }
            _ => {
                println!("{} is not implemented", typed_parameter.type_name);
                None
            }
        }
    }
}
